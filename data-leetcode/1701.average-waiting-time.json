[
    {
        "title": "Possible Bipartition",
        "question_content": "We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.\nGiven the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.\n&nbsp;\nExample 1:\n\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: The first group has [1,4], and the second group has [2,3].\n\nExample 2:\n\nInput: n = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\nExplanation: We need at least 3 groups to divide them. We cannot put them in two groups.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 2000\n\t0 <= dislikes.length <= 104\n\tdislikes[i].length == 2\n\t1 <= ai < bi <= n\n\tAll the pairs of dislikes are unique.",
        "solutions": [
            {
                "id": 654955,
                "title": "python-c-java-sol-by-dfs-and-coloring-w-graph",
                "content": "Sol by DFS and coloring.\\n\\n---\\n\\n**Hint**:\\n\\nThink of **graph**, **node coloring**, and **DFS**.\\n\\nAbstract model transformation:\\n\\n**Person** <-> **Node**\\n\\nP1 **dislikes P2** <-> Node 1 and Node 2 **share one edge**, and they should be **drawed with different two colors** (i.e., for dislike relation)\\n\\n\\nIf we can **draw each dislike pair** with **different two colors**, and **keep the dislike relationship always**, then there exists at least one possible **bipartition**.\\n\\n---\\n\\n**Illustration** and **Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1590572143.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1590572156.png)\\n\\n\\n---\\n\\n**Implementation** by DFS and coloring:\\n\\n**Special thanks to @ezpzm9\\'s contribution** in discussion.\\n\\n```python []\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        \\n        # Constant defined for color drawing to person\\n        BLUE, GREEN = 1, -1\\n        # -------------------------------------\\n        \\n        def draw( person_id, color ):\\n            \\n            # Draw person_id as color\\n            color_of[person_id] = color\\n            \\n            # Draw the_other, with opposite color, in dislike table of current person_id\\n            for the_other in dislike_table[ person_id ]:\\n   \\n                if color_of[the_other] == color:\\n                    # the_other has the same color of current person_id\\n                    # Reject due to breaking the relationship of dislike\\n                    return False\\n\\n                if (not color_of[the_other]) and (not draw( the_other, -color)):\\n                    # Other people can not be colored with two different colors. \\n\\t\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                    return False\\n                    \\n            return True\\n        \\n        \\n        # ------------------------------------------------\\n\\t\\t\\n\\t\\t\\n        if N == 1 or not dislikes:\\n            # Quick response for simple cases\\n            return True\\n        \\n        # each person maintain a list of dislike\\n        dislike_table = defaultdict( list )\\n        \\n        # key: person ID\\n        # value: color of person\\n        color_of = defaultdict(int)\\n        \\n        for p1, p2 in dislikes:\\n            \\n            # P1 dislikes P2\\n            # P1 and P2 should be painted with two different color\\n            dislike_table[p1].append( p2 )\\n            dislike_table[p2].append( p1 )\\n            \\n        \\n        # Try to draw dislike pair with different colors in DFS\\n        for person_id in range(1, N+1):\\n            \\n            if (not color_of[person_id])  and (not draw( person_id, BLUE)):\\n                # Other people can not be colored with two different colors. \\n\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                return False \\n        \\n        return True\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        enum COLOR_CONSTANT{\\n            GREEN = -1,         // -1\\n            NOT_COLORDED,       // 0\\n            BLUE                // 1\\n        };\\n        \\n        \\n        if( n == 1 || dislikes.size() == 0 ){\\n            \\n            // Quick response for simple cases\\n            return true;\\n        }\\n        \\n        // each person maintains a list of dislike\\n        unordered_map< int, vector<int> > dislikeTable;\\n        \\n        // key: personID\\n        // value: color of person\\n        unordered_map< int, int> colorTable;\\n        \\n        // -----------------------\\n        \\n        std::function< bool( int, int ) > helper;\\n        helper = [&]( int personID, int color)->bool{\\n            \\n            // Draw personID as color\\n            colorTable[personID] = color;\\n            \\n            // Draw theOther, with opposite color, in dislike table of current personID\\n            for( const int& theOther : dislikeTable[ personID ] ){\\n                \\n                if( colorTable[theOther] == color ){\\n                    // the_other has the same color of current person_id\\n                    // Reject due to breaking the relationship of dislike\\n                    return false;\\n                }\\n                \\n                if( colorTable[theOther] == NOT_COLORDED && ( !helper(theOther, -color) ) ){\\n                    // Other people can not be colored with two different colors. \\n                    // Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                    return false;\\n                }\\n            }\\n            \\n            return true;\\n            \\n        };\\n        \\n        // -----------------------\\n        \\n        \\n        // update dislike table\\n        for( const auto& relation : dislikes ){\\n            \\n            int p1 = relation[0], p2 = relation[1];\\n            \\n            dislikeTable[p1].emplace_back( p2 );\\n            dislikeTable[p2].emplace_back( p1 );\\n            \\n        }\\n        \\n        // Try to draw dislike pair with different color in DFS\\n        for( int personID = 1 ; personID <= n ; personID++){\\n            \\n            if( colorTable[personID] == NOT_COLORDED && ( !helper(personID, BLUE) ) ){\\n                    // Other people can not be colored with two different colors. \\n\\t\\t\\t\\t    // Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                    return false;\\n            }\\n        }\\n        \\n\\n        return true;        \\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {        \\n        List<Integer>[] graph = new List[N + 1];  \\n\\n        for (int i = 1; i <= N; ++i) graph[i] = new ArrayList<>();        \\n\\n        for (int[] dislike : dislikes) {\\n            graph[dislike[0]].add(dislike[1]);\\n            graph[dislike[1]].add(dislike[0]);\\n        }\\n\\n        Integer[] colors = new Integer[N + 1];\\n\\n        for (int i = 1; i <= N; ++i) {\\n            // If the connected component that node i belongs to hasn\\'t been colored yet then try coloring it.\\n            if (colors[i] == null && !dfs(graph, colors, i, 1)) return false;\\n        }\\n        return true;   \\n    }\\n\\n    private boolean dfs(List<Integer>[] graph, Integer[] colors, int currNode, int currColor) {\\n        colors[currNode] = currColor;\\n\\n        // Color all uncolored adjacent nodes.\\n        for (Integer adjacentNode : graph[currNode]) {\\n\\n            if (colors[adjacentNode] == null) {\\n                if (!dfs(graph, colors, adjacentNode, currColor * -1)) return false;     \\n\\n            } else if (colors[adjacentNode] == currColor) {\\n                return false;                                     \\n            }\\n        }\\n        return true;        \\n    }\\n}\\n```\\n\\n---\\n\\nSupplement material:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1590639902.png)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Bipartite graph](https://en.wikipedia.org/wiki/Bipartite_graph)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python []\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        \\n        # Constant defined for color drawing to person\\n        BLUE, GREEN = 1, -1\\n        # -------------------------------------\\n        \\n        def draw( person_id, color ):\\n            \\n            # Draw person_id as color\\n            color_of[person_id] = color\\n            \\n            # Draw the_other, with opposite color, in dislike table of current person_id\\n            for the_other in dislike_table[ person_id ]:\\n   \\n                if color_of[the_other] == color:\\n                    # the_other has the same color of current person_id\\n                    # Reject due to breaking the relationship of dislike\\n                    return False\\n\\n                if (not color_of[the_other]) and (not draw( the_other, -color)):\\n                    # Other people can not be colored with two different colors. \\n\\t\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                    return False\\n                    \\n            return True\\n        \\n        \\n        # ------------------------------------------------\\n\\t\\t\\n\\t\\t\\n        if N == 1 or not dislikes:\\n            # Quick response for simple cases\\n            return True\\n        \\n        # each person maintain a list of dislike\\n        dislike_table = defaultdict( list )\\n        \\n        # key: person ID\\n        # value: color of person\\n        color_of = defaultdict(int)\\n        \\n        for p1, p2 in dislikes:\\n            \\n            # P1 dislikes P2\\n            # P1 and P2 should be painted with two different color\\n            dislike_table[p1].append( p2 )\\n            dislike_table[p2].append( p1 )\\n            \\n        \\n        # Try to draw dislike pair with different colors in DFS\\n        for person_id in range(1, N+1):\\n            \\n            if (not color_of[person_id])  and (not draw( person_id, BLUE)):\\n                # Other people can not be colored with two different colors. \\n\\t\\t\\t\\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                return False \\n        \\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        enum COLOR_CONSTANT{\\n            GREEN = -1,         // -1\\n            NOT_COLORDED,       // 0\\n            BLUE                // 1\\n        };\\n        \\n        \\n        if( n == 1 || dislikes.size() == 0 ){\\n            \\n            // Quick response for simple cases\\n            return true;\\n        }\\n        \\n        // each person maintains a list of dislike\\n        unordered_map< int, vector<int> > dislikeTable;\\n        \\n        // key: personID\\n        // value: color of person\\n        unordered_map< int, int> colorTable;\\n        \\n        // -----------------------\\n        \\n        std::function< bool( int, int ) > helper;\\n        helper = [&]( int personID, int color)->bool{\\n            \\n            // Draw personID as color\\n            colorTable[personID] = color;\\n            \\n            // Draw theOther, with opposite color, in dislike table of current personID\\n            for( const int& theOther : dislikeTable[ personID ] ){\\n                \\n                if( colorTable[theOther] == color ){\\n                    // the_other has the same color of current person_id\\n                    // Reject due to breaking the relationship of dislike\\n                    return false;\\n                }\\n                \\n                if( colorTable[theOther] == NOT_COLORDED && ( !helper(theOther, -color) ) ){\\n                    // Other people can not be colored with two different colors. \\n                    // Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                    return false;\\n                }\\n            }\\n            \\n            return true;\\n            \\n        };\\n        \\n        // -----------------------\\n        \\n        \\n        // update dislike table\\n        for( const auto& relation : dislikes ){\\n            \\n            int p1 = relation[0], p2 = relation[1];\\n            \\n            dislikeTable[p1].emplace_back( p2 );\\n            dislikeTable[p2].emplace_back( p1 );\\n            \\n        }\\n        \\n        // Try to draw dislike pair with different color in DFS\\n        for( int personID = 1 ; personID <= n ; personID++){\\n            \\n            if( colorTable[personID] == NOT_COLORDED && ( !helper(personID, BLUE) ) ){\\n                    // Other people can not be colored with two different colors. \\n\\t\\t\\t\\t    // Therefore, it is impossible to keep dis-like relationship with bipartition.\\n                    return false;\\n            }\\n        }\\n        \\n\\n        return true;        \\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {        \\n        List<Integer>[] graph = new List[N + 1];  \\n\\n        for (int i = 1; i <= N; ++i) graph[i] = new ArrayList<>();        \\n\\n        for (int[] dislike : dislikes) {\\n            graph[dislike[0]].add(dislike[1]);\\n            graph[dislike[1]].add(dislike[0]);\\n        }\\n\\n        Integer[] colors = new Integer[N + 1];\\n\\n        for (int i = 1; i <= N; ++i) {\\n            // If the connected component that node i belongs to hasn\\'t been colored yet then try coloring it.\\n            if (colors[i] == null && !dfs(graph, colors, i, 1)) return false;\\n        }\\n        return true;   \\n    }\\n\\n    private boolean dfs(List<Integer>[] graph, Integer[] colors, int currNode, int currColor) {\\n        colors[currNode] = currColor;\\n\\n        // Color all uncolored adjacent nodes.\\n        for (Integer adjacentNode : graph[currNode]) {\\n\\n            if (colors[adjacentNode] == null) {\\n                if (!dfs(graph, colors, adjacentNode, currColor * -1)) return false;     \\n\\n            } else if (colors[adjacentNode] == currColor) {\\n                return false;                                     \\n            }\\n        }\\n        return true;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654887,
                "title": "c-bfs-with-detailed-explanation",
                "content": "The question asks us to divide given people into two groups such that no two people in the same group dislike each other. \\n\\nFor ease of understanding, we can represent this problem as a **graph**, with people being the **vertices** and dislike-pairs being the **edges** of this graph. \\n\\nWe have to find out if the vertices can be divided into two sets such that there *aren\\'t* any edges between vertices of the same set. A graph satisfying this condition is called a **bipartite graph**. For more on bipartite graphs, refer **[here](https://en.wikipedia.org/wiki/Bipartite_graph).**\\n\\nWe try to color the two sets of vertices, with RED and BLUE colors. In a bipartite graph, a RED vertex must be connected only with BLUE vertices and a BLUE vertex must be connected only with RED vertices. In other words, there must NOT be any edge connecting two vertices of the same color. Such an edge will be a **conflict edge**. \\n\\n***The presence of conflict edges indicate that bipartition is NOT possible.***\\n\\nThe graph may consist of many connected components. For each connected component, we run our **BFS** algorithm to find conflict edges, if any. For each component, we start by coloring one vertex RED, and all it\\'s neighbours BLUE. Then we visit the BLUE vertices and color all their neighbours as RED, and so on. During this process, if we come across any **RED-RED** edge or **BLUE-BLUE** edge, we have found a **conflict edge** and we immediately return **false**, as bipartition will not be possible. \\n\\nIf no conflict edges are found at the end of the algorithm, it means bipartition is possible, hence we return **true**.\\n\\nCode for the above algorithm: \\n```\\n#define WHITE 0\\n#define RED 1\\n#define BLUE 2\\n\\nclass Solution \\n{\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>> &edges) \\n    {\\n        vector<vector<int>> adj(N + 1); // adjacency list for undirected graph\\n        vector<int> color(N + 1, WHITE); // color of each vertex in graph, initially WHITE\\n        vector<bool> explored(N + 1, false); // to check if each vertex has been explored exactly once\\n        \\n        // create adjacency list from given edges\\n        for (auto &edge: edges)\\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // print adjacency list (comment out before submitting)\\n        for (int i = 0; i <= N; ++i)\\n        {\\n            cout << \"adj[\" << i << \"]: \";\\n            for (int j = 0; j < adj[i].size(); ++j)\\n            {\\n                cout << adj[i][j] << \" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        \\n        // queue to perform BFS over each connected component in the graph\\n        // while performing BFS, we check if we encounter any conflicts while\\n        // coloring the vertices of the graph\\n        // conflicts indicate that bi-partition is not possible\\n        queue<int> q;\\n        \\n        for (int i = 1; i <= N; ++i)\\n        {\\n            if (!explored[i])\\n            {\\n                // this component has not been colored yet\\n\\t\\t\\t\\t// we color the first vertex RED and push it into the queue\\n                color[i] = RED;\\n                q.push(i);\\n                \\n                // perform BFS from vertex i\\n                while (!q.empty())\\n                {\\n                    int u = q.front();\\n                    q.pop();\\n                    \\n                    // check if u is already explored \\n                    if (explored[u])\\n                    {\\n                        continue;\\n                    }\\n                    \\n                    explored[u] = true;\\n                    \\n                    // for each neighbor of u, execute this loop\\n                    for (auto v: adj[u])\\n                    {\\n                        // v is u\\'s neighboring vertex\\n                        \\n                        // checking if there\\'s any conflict in coloring\\n                        if (color[v] == color[u])\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// conflict edge found, so we return false \\n\\t\\t\\t\\t\\t\\t\\t// as bi-partition will not be possible\\n                            return false;\\n                        }\\n                        \\n                        // we color v with the opposite color of u\\n                        if (color[u] == RED)\\n                        {\\n                            color[v] = BLUE;\\n                        }\\n                        else \\n                        {\\n                            color[v] = RED;\\n                        }\\n                        \\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // if no conflicts encountered then graph must be bipartite\\n        // so we return true\\n        \\n        return true;\\n    }\\n};\\n```\\n\\nTime Complexity: O(N + E)\\nSpace Complexity: O(N + E)\\n\\nwhere N is the number of people and E is the number of dislike pairs.\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define WHITE 0\\n#define RED 1\\n#define BLUE 2\\n\\nclass Solution \\n{\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>> &edges) \\n    {\\n        vector<vector<int>> adj(N + 1); // adjacency list for undirected graph\\n        vector<int> color(N + 1, WHITE); // color of each vertex in graph, initially WHITE\\n        vector<bool> explored(N + 1, false); // to check if each vertex has been explored exactly once\\n        \\n        // create adjacency list from given edges\\n        for (auto &edge: edges)\\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        // print adjacency list (comment out before submitting)\\n        for (int i = 0; i <= N; ++i)\\n        {\\n            cout << \"adj[\" << i << \"]: \";\\n            for (int j = 0; j < adj[i].size(); ++j)\\n            {\\n                cout << adj[i][j] << \" \";\\n            }\\n            cout << \"\\\\n\";\\n        }\\n        \\n        // queue to perform BFS over each connected component in the graph\\n        // while performing BFS, we check if we encounter any conflicts while\\n        // coloring the vertices of the graph\\n        // conflicts indicate that bi-partition is not possible\\n        queue<int> q;\\n        \\n        for (int i = 1; i <= N; ++i)\\n        {\\n            if (!explored[i])\\n            {\\n                // this component has not been colored yet\\n\\t\\t\\t\\t// we color the first vertex RED and push it into the queue\\n                color[i] = RED;\\n                q.push(i);\\n                \\n                // perform BFS from vertex i\\n                while (!q.empty())\\n                {\\n                    int u = q.front();\\n                    q.pop();\\n                    \\n                    // check if u is already explored \\n                    if (explored[u])\\n                    {\\n                        continue;\\n                    }\\n                    \\n                    explored[u] = true;\\n                    \\n                    // for each neighbor of u, execute this loop\\n                    for (auto v: adj[u])\\n                    {\\n                        // v is u\\'s neighboring vertex\\n                        \\n                        // checking if there\\'s any conflict in coloring\\n                        if (color[v] == color[u])\\n                        {\\n\\t\\t\\t\\t\\t\\t\\t// conflict edge found, so we return false \\n\\t\\t\\t\\t\\t\\t\\t// as bi-partition will not be possible\\n                            return false;\\n                        }\\n                        \\n                        // we color v with the opposite color of u\\n                        if (color[u] == RED)\\n                        {\\n                            color[v] = BLUE;\\n                        }\\n                        else \\n                        {\\n                            color[v] = RED;\\n                        }\\n                        \\n                        q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // if no conflicts encountered then graph must be bipartite\\n        // so we return true\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 158957,
                "title": "java-dfs-solution",
                "content": "Notes:\\n`group[i] = 0` means node `i` hasn\\'t been visited.\\n`group[i] = 1` means node `i` has been grouped to `1`.\\n`group[i] = -1` means node `i` has been grouped to `-1`.\\n```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[][] graph = new int[N][N];\\n        for (int[] d : dislikes) {\\n            graph[d[0] - 1][d[1] - 1] = 1;\\n            graph[d[1] - 1][d[0] - 1] = 1;\\n        }\\n        int[] group = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            if (group[i] == 0 && !dfs(graph, group, i, 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int[][] graph, int[] group, int index, int g) {\\n        group[index] = g;\\n        for (int i = 0; i < graph.length; i++) {\\n            if (graph[index][i] == 1) {\\n                if (group[i] == g) {\\n                    return false;\\n                }\\n                if (group[i] == 0 && !dfs(graph, group, i, -g)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[][] graph = new int[N][N];\\n        for (int[] d : dislikes) {\\n            graph[d[0] - 1][d[1] - 1] = 1;\\n            graph[d[1] - 1][d[0] - 1] = 1;\\n        }\\n        int[] group = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            if (group[i] == 0 && !dfs(graph, group, i, 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int[][] graph, int[] group, int index, int g) {\\n        group[index] = g;\\n        for (int i = 0; i < graph.length; i++) {\\n            if (graph[index][i] == 1) {\\n                if (group[i] == g) {\\n                    return false;\\n                }\\n                if (group[i] == 0 && !dfs(graph, group, i, -g)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159085,
                "title": "java-graph",
                "content": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] color = new int[N + 1];\\n        List<List<Integer>> adj = new ArrayList<>(N + 1);\\n        for(int i = 0; i <= N; i++) adj.add(new ArrayList<Integer>());\\n        for(int[] d : dislikes) {\\n            adj.get(d[0]).add(d[1]);\\n            adj.get(d[1]).add(d[0]);\\n        }\\n        \\n        for(int i = 1; i <= N; i++) {\\n            if(color[i] == 0) {\\n                color[i] = 1;\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                while(!q.isEmpty()) {\\n                    int cur = q.poll();\\n                    for(int nb : adj.get(cur)) {\\n                        if(color[nb] == 0) {\\n                            color[nb] = color[cur] == 1 ? 2 : 1;\\n                            q.add(nb);\\n                        } else {\\n                            if(color[nb] == color[cur]) return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] color = new int[N + 1];\\n        List<List<Integer>> adj = new ArrayList<>(N + 1);\\n        for(int i = 0; i <= N; i++) adj.add(new ArrayList<Integer>());\\n        for(int[] d : dislikes) {\\n            adj.get(d[0]).add(d[1]);\\n            adj.get(d[1]).add(d[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 655842,
                "title": "python-union-find-dfs-bfs-with-explanation",
                "content": "Union Find: \\nTypical union find, but when union, add an if statement to check **if parent of dislike node is same as parent of current node**.\\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.p = [i for i in range(n+1)]\\n    \\n    def find(self, i):                                        # Find parent\\n        if i != self.p[i]:\\n            self.p[i] = self.find(self.p[i])\\n        return self.p[i]    \\n        \\n    def union(self, j, parent_dislike_i, parent_i):    \\n        p_j = self.find(j)\\n        self.p[p_j] = parent_dislike_i \\n        return p_j != parent_i                                # Check if there is a parent conflict\\n        \\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        self.graph = collections.defaultdict(list)            # Create graph and initilize union find\\n        uf = UF(N)\\n        for (u, v) in dislikes:\\n            self.graph[u].append(v)\\n            self.graph[v].append(u)\\n        \\n        for i in range(1, N+1):\\n            parent_i = uf.find(i)\\n            if parent_i in self.graph:\\n                parent_dislike_i = uf.find(self.graph[i][0])  # Pick a dislike node\\'s parent as a common parent for the rest of dislike nodes\\n                for dis in self.graph[i][1:]:                 # For each dislike node\\n                    if not uf.union(dis, parent_dislike_i, parent_i): return False   # Return False if there is a conflict when grouping\\n        return True            \\n```\\n\\nDFS\\n```\\nclass Solution:\\n    def dfs(self, i, group):\\n        if i in self.group_mapping and group != self.group_mapping[i]:   # Check if there is a conflict\\n            return False                                                 # between given group and existing group\\n        self.group_mapping[i] = group\\n        if i not in self.visited:\\n            self.visited.add(i)\\n            for dis in self.graph[i]:                                    # DFS for each dislike node recursively\\n                if not self.dfs(dis, not group): return False            # Assign contrary group to dislike node\\n        return True    \\n        \\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        self.graph = collections.defaultdict(list)\\n        self.visited, self.group_mapping = set(), {}\\n        for (u, v) in dislikes:                                          # Create graph \\n            self.graph[u].append(v)\\n            self.graph[v].append(u)\\n        \\n        for i in range(1, N+1):                                          # DFS until eror\\n            if i not in self.visited:                                    # We don\\'t want to revisit since it\\'s DFS\\n                if not self.dfs(i, True):                                # If conflict occurs during DFS, return False\\n                    return False\\n        return True\\n```\\n\\nBFS\\n```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        self.graph = collections.defaultdict(list)\\n        group_mapping = {}\\n        for (u, v) in dislikes:                             # Create graph\\n            self.graph[u].append(v)\\n            self.graph[v].append(u)\\n        \\n        visited = set()\\n        for i in range(1, N + 1):                           # Iterate each node\\n            if i in visited: continue                       # No need to revisit, since it\\'s a non-directed graph\\n            stack = [(i, 0)]                                # Use stack for BFS\\n            while stack:                                    # You can also use a deque instead of 2 while loop on stack\\n                tmp_stack = []\\n                while stack:                                # exhaust current stack before go to next layer (BFS)\\n                    cur_node, group = stack.pop()\\n                    if cur_node in group_mapping and group != group_mapping[cur_node]:  # check if it\\'s conflict\\n                        return False\\n                    if cur_node in visited: continue        # If visited and no conflict, continue to avoid dead loop\\n                    group_mapping[cur_node] = group         # Assign group for current node\\n                    visited.add(cur_node)\\n                    for child in self.graph[cur_node]:      # Assign contrary group for dislikes of current node\\n                        tmp_stack.append((child, not group))\\n                stack = tmp_stack            \\n        return True   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.p = [i for i in range(n+1)]\\n    \\n    def find(self, i):                                        # Find parent\\n        if i != self.p[i]:\\n            self.p[i] = self.find(self.p[i])\\n        return self.p[i]    \\n        \\n    def union(self, j, parent_dislike_i, parent_i):    \\n        p_j = self.find(j)\\n        self.p[p_j] = parent_dislike_i \\n        return p_j != parent_i                                # Check if there is a parent conflict\\n        \\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        self.graph = collections.defaultdict(list)            # Create graph and initilize union find\\n        uf = UF(N)\\n        for (u, v) in dislikes:\\n            self.graph[u].append(v)\\n            self.graph[v].append(u)\\n        \\n        for i in range(1, N+1):\\n            parent_i = uf.find(i)\\n            if parent_i in self.graph:\\n                parent_dislike_i = uf.find(self.graph[i][0])  # Pick a dislike node\\'s parent as a common parent for the rest of dislike nodes\\n                for dis in self.graph[i][1:]:                 # For each dislike node\\n                    if not uf.union(dis, parent_dislike_i, parent_i): return False   # Return False if there is a conflict when grouping\\n        return True            \\n```\n```\\nclass Solution:\\n    def dfs(self, i, group):\\n        if i in self.group_mapping and group != self.group_mapping[i]:   # Check if there is a conflict\\n            return False                                                 # between given group and existing group\\n        self.group_mapping[i] = group\\n        if i not in self.visited:\\n            self.visited.add(i)\\n            for dis in self.graph[i]:                                    # DFS for each dislike node recursively\\n                if not self.dfs(dis, not group): return False            # Assign contrary group to dislike node\\n        return True    \\n        \\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        self.graph = collections.defaultdict(list)\\n        self.visited, self.group_mapping = set(), {}\\n        for (u, v) in dislikes:                                          # Create graph \\n            self.graph[u].append(v)\\n            self.graph[v].append(u)\\n        \\n        for i in range(1, N+1):                                          # DFS until eror\\n            if i not in self.visited:                                    # We don\\'t want to revisit since it\\'s DFS\\n                if not self.dfs(i, True):                                # If conflict occurs during DFS, return False\\n                    return False\\n        return True\\n```\n```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        self.graph = collections.defaultdict(list)\\n        group_mapping = {}\\n        for (u, v) in dislikes:                             # Create graph\\n            self.graph[u].append(v)\\n            self.graph[v].append(u)\\n        \\n        visited = set()\\n        for i in range(1, N + 1):                           # Iterate each node\\n            if i in visited: continue                       # No need to revisit, since it\\'s a non-directed graph\\n            stack = [(i, 0)]                                # Use stack for BFS\\n            while stack:                                    # You can also use a deque instead of 2 while loop on stack\\n                tmp_stack = []\\n                while stack:                                # exhaust current stack before go to next layer (BFS)\\n                    cur_node, group = stack.pop()\\n                    if cur_node in group_mapping and group != group_mapping[cur_node]:  # check if it\\'s conflict\\n                        return False\\n                    if cur_node in visited: continue        # If visited and no conflict, continue to avoid dead loop\\n                    group_mapping[cur_node] = group         # Assign group for current node\\n                    visited.add(cur_node)\\n                    for child in self.graph[cur_node]:      # Assign contrary group for dislikes of current node\\n                        tmp_stack.append((child, not group))\\n                stack = tmp_stack            \\n        return True   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 655414,
                "title": "python-dfs-clean-concise",
                "content": "```python\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        color = [-1] * n\\n        graph = defaultdict(list)\\n        for a, b in dislikes:\\n            graph[a-1].append(b-1)\\n            graph[b-1].append(a-1)\\n\\n        def dfs(u, c):\\n            color[u] = c\\n            for v in graph[u]:\\n                if color[v] != -1 and color[v] != 1 - c:  # Neighbor is already has color, but it\\'s not our expection!\\n                    return False\\n                if color[v] == -1 and not dfs(v, 1 - c):\\n                    return False\\n            return True\\n\\n        for i in range(n):\\n            if color[i] == -1 and not dfs(i, 0):\\n                return False\\n\\n        return True\\n```\\n**Complexity**\\n- Time: `O(M + N)`, where `N <= 2000`, `M <= 10^4` is length of dislikes.\\n- Space: `O(M + N)`",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        color = [-1] * n\\n        graph = defaultdict(list)\\n        for a, b in dislikes:\\n            graph[a-1].append(b-1)\\n            graph[b-1].append(a-1)\\n\\n        def dfs(u, c):\\n            color[u] = c\\n            for v in graph[u]:\\n                if color[v] != -1 and color[v] != 1 - c:  # Neighbor is already has color, but it\\'s not our expection!\\n                    return False\\n                if color[v] == -1 and not dfs(v, 1 - c):\\n                    return False\\n            return True\\n\\n        for i in range(n):\\n            if color[i] == -1 and not dfs(i, 0):\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934065,
                "title": "c-bfs-solution-dfs-solution-easy-to-understand",
                "content": "\\n# Approach: BFS\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> color(n+1,0);\\n        vector<int> adj[n+1];\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(color[i]==0){\\n                color[i]=1;\\n                queue<int> q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int node=q.front();\\n                    q.pop();\\n                    for(int child:adj[node]){\\n                        if(color[child]==color[node])return false;\\n                        if(!color[child]){\\n                            q.push(child);\\n                            color[child]=-1*color[node];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n\\n\\n# Approach: DFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> color(n+1,-1);\\n        vector<int> adj[n+1];\\n        for(auto p:dislikes){\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        for(int node=1;node<=n;node++){\\n            if(color[node]==-1){\\n                \\n                if(cycle(node,adj,color)){\\n                    return false; // if adjacent node become same color as \\n                                  // current node, no bipartition possible\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool cycle(int node,vector<int> adj[], vector<int> &color){\\n        if(color[node]==-1){\\n            color[node]=1;\\n        }\\n        for(int child:adj[node]){\\n            if(color[child]==-1){\\n                color[child]=1-color[node];\\n                if(cycle(child,adj,color)){\\n                    return true; // finding adjacent node having same color\\n                }\\n            }\\n            else if(color[child]==color[node]){\\n                return true;// finding adjacent node having same color\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> color(n+1,0);\\n        vector<int> adj[n+1];\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(color[i]==0){\\n                color[i]=1;\\n                queue<int> q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int node=q.front();\\n                    q.pop();\\n                    for(int child:adj[node]){\\n                        if(color[child]==color[node])return false;\\n                        if(!color[child]){\\n                            q.push(child);\\n                            color[child]=-1*color[node];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> color(n+1,-1);\\n        vector<int> adj[n+1];\\n        for(auto p:dislikes){\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        for(int node=1;node<=n;node++){\\n            if(color[node]==-1){\\n                \\n                if(cycle(node,adj,color)){\\n                    return false; // if adjacent node become same color as \\n                                  // current node, no bipartition possible\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool cycle(int node,vector<int> adj[], vector<int> &color){\\n        if(color[node]==-1){\\n            color[node]=1;\\n        }\\n        for(int child:adj[node]){\\n            if(color[child]==-1){\\n                color[child]=1-color[node];\\n                if(cycle(child,adj,color)){\\n                    return true; // finding adjacent node having same color\\n                }\\n            }\\n            else if(color[child]==color[node]){\\n                return true;// finding adjacent node having same color\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934339,
                "title": "beats-100-codedominar-solution",
                "content": "- **Time complexity:** `O(V + E), where V is the number of vertices and E is the number of edges in the graph.`\\n\\n# Code\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:     \\n        # Create an adjacency list representation of the graph\\n        adj_list = [[] for _ in range(n)]\\n        for a, b in dislikes:\\n            adj_list[a - 1].append(b - 1)\\n            adj_list[b - 1].append(a - 1)\\n        \\n        # Initialize a colors array to store the colors of the vertices\\n        # 0 = not visited, 1 = set A, 2 = set B\\n        colors = [0] * n\\n        \\n        # Perform BFS starting from each vertex\\n        for start in range(n):\\n            # If the vertex has not been visited, perform BFS\\n            if colors[start] == 0:\\n                # Initialize the queue with the starting vertex\\n                queue = deque([start])\\n                colors[start] = 1\\n                \\n                # Perform BFS\\n                while queue:\\n                    vertex = queue.popleft()\\n                    for neighbor in adj_list[vertex]:\\n                        # If the neighbor has not been visited, assign it to the other set and add it to the queue\\n                        if colors[neighbor] == 0:\\n                            colors[neighbor] = 3 - colors[vertex]\\n                            queue.append(neighbor)\\n                        # If the neighbor is in the same set as the current vertex, return False (not bipartite)\\n                        elif colors[neighbor] == colors[vertex]:\\n                            return False\\n        # If BFS was successful for all vertices, return True (bipartite)\\n        return True\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:     \\n        # Create an adjacency list representation of the graph\\n        adj_list = [[] for _ in range(n)]\\n        for a, b in dislikes:\\n            adj_list[a - 1].append(b - 1)\\n            adj_list[b - 1].append(a - 1)\\n        \\n        # Initialize a colors array to store the colors of the vertices\\n        # 0 = not visited, 1 = set A, 2 = set B\\n        colors = [0] * n\\n        \\n        # Perform BFS starting from each vertex\\n        for start in range(n):\\n            # If the vertex has not been visited, perform BFS\\n            if colors[start] == 0:\\n                # Initialize the queue with the starting vertex\\n                queue = deque([start])\\n                colors[start] = 1\\n                \\n                # Perform BFS\\n                while queue:\\n                    vertex = queue.popleft()\\n                    for neighbor in adj_list[vertex]:\\n                        # If the neighbor has not been visited, assign it to the other set and add it to the queue\\n                        if colors[neighbor] == 0:\\n                            colors[neighbor] = 3 - colors[vertex]\\n                            queue.append(neighbor)\\n                        # If the neighbor is in the same set as the current vertex, return False (not bipartite)\\n                        elif colors[neighbor] == colors[vertex]:\\n                            return False\\n        # If BFS was successful for all vertices, return True (bipartite)\\n        return True\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 654840,
                "title": "python-simple-dfs-traversal-o-e-v-detailed-explanations",
                "content": "This is classical graph theory problem: you have graph, and you need to check if it can be bipartitioned: all nodes must be divided into two groups, such that there is not connections between nodes in each group.\\n\\nClassical way to solve this problem is any graph traversal algorighm, here I chose dfs. \\nThe variable `self.adj_list` is adjacency list of our graph, for example if we have connections\\n`[[1,2],[2,3],[3,4],[4,5],[1,5]]`, then it is equal to `1:{2,5}; 2:{1,3}, 3:{4,2}, 4:{3,5}, 5:{1,4}`\\nI also have `self.found_loop` variable to terminate early if we found loop with odd length, which is sufficient and necessary condition that graph **can not be bipartitioned**, for example in our case we have `1->2->3->4->5->1` the loop with size 5.\\n\\nWhen we traverse nodes, we evaluate their distances (in my code list `self.dist`) from the starting point, and if in some moment node is already visited and its parity is broken, than we found odd loop.\\n\\nNote also, that original graph is not necessarily connected, and we need to start our dfs from all nodes to make sure that we traverse all graph.\\n\\n**Complexity** We traverse every connection between nodes only once, so we have classical O(E+V) time complexity, where E is number of edges and V is number of vertices (V = N in our case and V = len(dislikes)). Space complexity is also O(E+V), because we keep adjacency list for all our nodes and colors\\n\\n```\\nclass Solution:\\n    def dfs(self, start):\\n        if self.found_loop == 1: return        #early stop if we found odd cycle\\n    \\n        for neib in self.adj_list[start]:\\n            if self.dist[neib] > 0 and (self.dist[neib] - self.dist[start]) %2 == 0:\\n                self.found_loop = 1\\n            elif self.dist[neib] < 0:  #not visited yet\\n                self.dist[neib] = self.dist[start] + 1\\n                self.dfs(neib)\\n            \\n    def possibleBipartition(self, N, dislikes):\\n        self.adj_list = defaultdict(list)\\n        self.found_loop, self.dist = 0, [-1] *(N+1)\\n        \\n        for i,j in dislikes:\\n            self.adj_list[i].append(j)\\n            self.adj_list[j].append(i)\\n        \\n        for i in range(N):\\n            if self.found_loop: return False    #early stop if we found odd cycle\\n            \\n            if self.dist[i] == -1:    #not visited yet\\n                self.dist[i] = 0\\n                self.dfs(i)\\n        \\n        return True\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please upvote",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, start):\\n        if self.found_loop == 1: return        #early stop if we found odd cycle\\n    \\n        for neib in self.adj_list[start]:\\n            if self.dist[neib] > 0 and (self.dist[neib] - self.dist[start]) %2 == 0:\\n                self.found_loop = 1\\n            elif self.dist[neib] < 0:  #not visited yet\\n                self.dist[neib] = self.dist[start] + 1\\n                self.dfs(neib)\\n            \\n    def possibleBipartition(self, N, dislikes):\\n        self.adj_list = defaultdict(list)\\n        self.found_loop, self.dist = 0, [-1] *(N+1)\\n        \\n        for i,j in dislikes:\\n            self.adj_list[i].append(j)\\n            self.adj_list[j].append(i)\\n        \\n        for i in range(N):\\n            if self.found_loop: return False    #early stop if we found odd cycle\\n            \\n            if self.dist[i] == -1:    #not visited yet\\n                self.dist[i] = 0\\n                self.dfs(i)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301784,
                "title": "union-find-with-explanation-java",
                "content": "Union find can be used to solve this problem because we are essentially trying to see if a node is connected to a node in the same component. Union find helps us connect components together and figure out what nodes belong in the same component. If we ever find a node is part of the same component as any of its neighbors, we know the graph is not bipartite.\\n\\n![image](https://assets.leetcode.com/users/images/43277fb3-b43f-4f47-a345-e82de6ea90a1_1624850091.8785458.webp)\\n\\n\\nSteps:\\n1) Build graph of dislikes using the edges input\\n2) Initialize union find of size n\\n3) Iterate across all the vertices `(1..n)` and check if the vertex is connected with any of its neighbors\\n\\t3a) In the figure above, this step is checking to see if all node 2\\'s neighbors (5 and 7) are on the right side.\\n\\t3b) If the current vertex is connected to any of it\\'s neighbors, (5 or 7 is actually on the left side) that makes the graph NOT bipartite\\n\\t3c) Unionize all of a node 2\\'s neighbors together because they belong to the same set. This puts 5 and 7 on the right side set.\\n\\n```\\nclass Solution {\\n  public boolean possibleBipartition(int n, int[][] dislikes) {    \\n    Map<Integer, Set<Integer>> graph = buildGraph(dislikes, n);\\n    UnionFind uf = new UnionFind(n);\\n    \\n    for(int i = 1; i < n+1; i++) {\\n      Set<Integer> neighbors = graph.get(i);\\n      if(neighbors.size() == 0) continue;\\n      int firstNeighbor = neighbors.iterator().next(); // gets the first item in the set\\n      \\n      for(int neighbor : neighbors) {\\n        if(uf.isConnected(i, neighbor)) return false; // if vertex i is connected with any of its neighbors, graph is not bipartite\\n        uf.union(firstNeighbor, neighbor); // unionize all its neighbors\\n      }\\n    }\\n        \\n    return true;\\n  }\\n  \\n  public Map<Integer, Set<Integer>> buildGraph(int[][] edges, int n) {\\n    Map<Integer, Set<Integer>> graph = new HashMap<>();\\n    \\n    for(int i = 1; i < n+1; i++) graph.put(i, new HashSet<>());\\n    \\n    for(int[] edge : edges) {\\n      int src = edge[0];\\n      int dest = edge[1];\\n      \\n      graph.get(src).add(dest);\\n      graph.get(dest).add(src);\\n    }\\n    \\n    return graph;\\n  }\\n  \\n  class UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public UnionFind(int n) {\\n      parent = new int[n+1];\\n      rank = new int[n+1];\\n      \\n      for(int i = 0; i < n+1; i++) {\\n        parent[i] = i;\\n      }\\n    }\\n    \\n    public void union(int x, int y) {\\n      int rootX = find(x);\\n      int rootY = find(y);\\n      \\n      if(rootX != rootY) {\\n        if(rank[rootX] > rank[rootY]) {\\n          rank[rootX]++;\\n          parent[rootY] = rootX;\\n        } else {\\n          rank[rootY]++;\\n          parent[rootX] = rootY;\\n        }\\n      }\\n    }\\n    \\n    public int find(int x) {\\n      if(parent[x] == x) return x;\\n      \\n      int root = find(parent[x]);\\n      parent[x] = root; //path compression\\n      return root;\\n    }\\n    \\n    public boolean isConnected(int x, int y) {\\n      return find(x) == find(y);\\n    }\\n  }\\n}\\n```\\n\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n  public boolean possibleBipartition(int n, int[][] dislikes) {    \\n    Map<Integer, Set<Integer>> graph = buildGraph(dislikes, n);\\n    UnionFind uf = new UnionFind(n);\\n    \\n    for(int i = 1; i < n+1; i++) {\\n      Set<Integer> neighbors = graph.get(i);\\n      if(neighbors.size() == 0) continue;\\n      int firstNeighbor = neighbors.iterator().next(); // gets the first item in the set\\n      \\n      for(int neighbor : neighbors) {\\n        if(uf.isConnected(i, neighbor)) return false; // if vertex i is connected with any of its neighbors, graph is not bipartite\\n        uf.union(firstNeighbor, neighbor); // unionize all its neighbors\\n      }\\n    }\\n        \\n    return true;\\n  }\\n  \\n  public Map<Integer, Set<Integer>> buildGraph(int[][] edges, int n) {\\n    Map<Integer, Set<Integer>> graph = new HashMap<>();\\n    \\n    for(int i = 1; i < n+1; i++) graph.put(i, new HashSet<>());\\n    \\n    for(int[] edge : edges) {\\n      int src = edge[0];\\n      int dest = edge[1];\\n      \\n      graph.get(src).add(dest);\\n      graph.get(dest).add(src);\\n    }\\n    \\n    return graph;\\n  }\\n  \\n  class UnionFind {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public UnionFind(int n) {\\n      parent = new int[n+1];\\n      rank = new int[n+1];\\n      \\n      for(int i = 0; i < n+1; i++) {\\n        parent[i] = i;\\n      }\\n    }\\n    \\n    public void union(int x, int y) {\\n      int rootX = find(x);\\n      int rootY = find(y);\\n      \\n      if(rootX != rootY) {\\n        if(rank[rootX] > rank[rootY]) {\\n          rank[rootX]++;\\n          parent[rootY] = rootX;\\n        } else {\\n          rank[rootY]++;\\n          parent[rootX] = rootY;\\n        }\\n      }\\n    }\\n    \\n    public int find(int x) {\\n      if(parent[x] == x) return x;\\n      \\n      int root = find(parent[x]);\\n      parent[x] = root; //path compression\\n      return root;\\n    }\\n    \\n    public boolean isConnected(int x, int y) {\\n      return find(x) == find(y);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159009,
                "title": "python-dfs-with-explanation",
                "content": "Let\\'s consider it as a graph, and consider the dislike as an edge. If the graph is acyclic, simply put the people in the zig-zag way.\\n\\nExample: `1 - 2 - 3 - 4 - 5`. Put `1, 3, 5` as group 1, and `2, 4` as group 2.\\n\\nIf there is a cycle. If the vertices are even, say `1 - 2 -  3 - 4 - 1`, it can be put into `1 - 3` and `2 - 4`. If the vertices are odd, there is no way to put them.\\n \\nThe main idea is to find if the graph contains a cycle with odd number of vertices. If it contains a cycle with odd vertices, return `False`. Otherwise (cycle with even vertices or acyclic), return `True`.\\n\\nI use the `visited` array to store the depth of the vertice. If the current vertice has been visited, if its depth minus the original depth is a odd number, then return `False`.\\n\\nExample: `1 - 2 - 3 -1`. When I visit the vertix `3`, `visited = [0, 1, 2]`. When I visit the vertix `1` again, the current depth is `3` and the original depth of the vertix `1` is 0, then `3 - 0 = 3`, which is odd, so return `False`.\\n\\n----\\nUpdate: this idea is similar as using color. We can color the vertices in zig-zag way. For example, the first vertix is `red`, and its nearby vertices should be `black`. If the nearby vertix has the same color as the current one, return `False`. This corresponds to the situation that the depth difference is odd.\\n\\n\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        bag = [[] for i in range(N+1)]\\n        visited = [-1] * (N+1)\\n        count = 0\\n        for dislike in dislikes:\\n            bag[dislike[0]].append(dislike[1])\\n            bag[dislike[1]].append(dislike[0])\\n        \\n        for i in range(1, N+1):\\n            if visited[i] == -1 and  len(bag[i]) > 0:\\n                if not self.visit(0, i, bag, visited):\\n                    return False\\n                \\n        return True\\n      \\n    def visit(self, curLevel, i, bag, visited):     \\n        if visited[i] >= 0:\\n            return (curLevel - visited[i]) % 2 == 0\\n                \\n        visited[i] = curLevel\\n        for des in bag[i]:\\n            if not self.visit(curLevel + 1, des, bag, visited):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        bag = [[] for i in range(N+1)]\\n        visited = [-1] * (N+1)\\n        count = 0\\n        for dislike in dislikes:\\n            bag[dislike[0]].append(dislike[1])\\n            bag[dislike[1]].append(dislike[0])\\n        \\n        for i in range(1, N+1):\\n            if visited[i] == -1 and  len(bag[i]) > 0:\\n                if not self.visit(0, i, bag, visited):\\n                    return False\\n                \\n        return True\\n      \\n    def visit(self, curLevel, i, bag, visited):     \\n        if visited[i] >= 0:\\n            return (curLevel - visited[i]) % 2 == 0\\n                \\n        visited[i] = curLevel\\n        for des in bag[i]:\\n            if not self.visit(curLevel + 1, des, bag, visited):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673596,
                "title": "c-dfs-and-bfs-w-2-way-coloring-with-comments",
                "content": "```\\nstatic const auto ____ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n// DFS\\n// Runtime - 460 ms, Memory - 66.6 MB\\nclass Solution {\\n    unordered_map <int, int> color;\\n    vector<int> *adjlist;\\n    \\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        adjlist = new vector<int>[n+1];\\n        for(const vector<int> &d: dislikes) {\\n            adjlist[d[0]].emplace_back(d[1]);\\n            adjlist[d[1]].emplace_back(d[0]);\\n        }\\n        \\n        // for all connected components check if they are bipartite\\n        for(int i = 1; i <= n; i++) {\\n            // check if a node doesn\\'t already exist in hash map and if dfs on it returns false then that connected component is not bipartite\\n            if(color.find(i) == color.end() && !dfs(i, 0))  return false;\\n        }\\n        return true;\\n    }\\n    \\n    // color each adjacent node with alternate color (2 way graph coloring)\\n    bool dfs(int node, int c) {\\n        // if a node already exists in map and its color differ from the one in this dfs call then return false (graph cannot be bipartite)\\n        if(color.find(node) != color.end()) return color[node] == c;\\n        else    color.insert({node, c});\\n        \\n        for(auto itr = adjlist[node].begin(); itr != adjlist[node].end(); itr++) {\\n            if(!dfs(*itr, c^1)) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n// BFS\\n// Runtime - 396 ms, Memory - 80.4 MB\\nclass Solution {\\n    unordered_map <int, int> color;\\n    vector<int> *adjlist;\\n    \\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        adjlist = new vector<int>[n+1];\\n        for(const vector<int> &d: dislikes) {\\n            adjlist[d[0]].emplace_back(d[1]);\\n            adjlist[d[1]].emplace_back(d[0]);\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            queue<int> q;\\n            q.push(i);\\n            color.insert({i, 0});\\n            \\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n                \\n                for(auto itr = adjlist[node].begin(); itr != adjlist[node].end(); itr++) {\\n                    // all neighbors of current node are given alternate color\\n                    int altColor = color[node]^1;\\n                    if(color.find(*itr) == color.end()) color.insert({*itr, altColor});\\n                    else if(color[*itr] == altColor)    continue;\\n                    else    return false;\\n                    \\n                    q.push(*itr);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto ____ = [](){\\n\\t// fast I/O\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr), cout.tie(nullptr);\\n    return 0;\\n}();\\n\\n// DFS\\n// Runtime - 460 ms, Memory - 66.6 MB\\nclass Solution {\\n    unordered_map <int, int> color;\\n    vector<int> *adjlist;\\n    \\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        adjlist = new vector<int>[n+1];\\n        for(const vector<int> &d: dislikes) {\\n            adjlist[d[0]].emplace_back(d[1]);\\n            adjlist[d[1]].emplace_back(d[0]);\\n        }\\n        \\n        // for all connected components check if they are bipartite\\n        for(int i = 1; i <= n; i++) {\\n            // check if a node doesn\\'t already exist in hash map and if dfs on it returns false then that connected component is not bipartite\\n            if(color.find(i) == color.end() && !dfs(i, 0))  return false;\\n        }\\n        return true;\\n    }\\n    \\n    // color each adjacent node with alternate color (2 way graph coloring)\\n    bool dfs(int node, int c) {\\n        // if a node already exists in map and its color differ from the one in this dfs call then return false (graph cannot be bipartite)\\n        if(color.find(node) != color.end()) return color[node] == c;\\n        else    color.insert({node, c});\\n        \\n        for(auto itr = adjlist[node].begin(); itr != adjlist[node].end(); itr++) {\\n            if(!dfs(*itr, c^1)) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n// BFS\\n// Runtime - 396 ms, Memory - 80.4 MB\\nclass Solution {\\n    unordered_map <int, int> color;\\n    vector<int> *adjlist;\\n    \\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        adjlist = new vector<int>[n+1];\\n        for(const vector<int> &d: dislikes) {\\n            adjlist[d[0]].emplace_back(d[1]);\\n            adjlist[d[1]].emplace_back(d[0]);\\n        }\\n        \\n        for(int i = 1; i <= n; i++) {\\n            queue<int> q;\\n            q.push(i);\\n            color.insert({i, 0});\\n            \\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n                \\n                for(auto itr = adjlist[node].begin(); itr != adjlist[node].end(); itr++) {\\n                    // all neighbors of current node are given alternate color\\n                    int altColor = color[node]^1;\\n                    if(color.find(*itr) == color.end()) color.insert({*itr, altColor});\\n                    else if(color[*itr] == altColor)    continue;\\n                    else    return false;\\n                    \\n                    q.push(*itr);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 654830,
                "title": "c-dfs-using-lambda-function-simple-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n        bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> adj[N+1];\\n        for(auto dislike : dislikes) {\\n            adj[dislike[0]].push_back(dislike[1]);\\n            adj[dislike[1]].push_back(dislike[0]);\\n        }\\n\\n        vector<int> color(N+1, 0);\\n        function<bool(int, int)> dfs = [&](int cur, int col) {\\n            if(color[cur] != 0) \\n                return color[cur] == col;\\n            color[cur] = col;\\n            for(auto nxt : adj[cur]) \\n                if(!dfs(nxt, -col)) \\n                    return false;\\n            return true;\\n        };\\n\\n        for(int i = 1; i <= N; i++) {\\n            if(color[i] == 0 && !dfs(i, 1)) \\n                return false;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> adj[N+1];\\n        for(auto dislike : dislikes) {\\n            adj[dislike[0]].push_back(dislike[1]);\\n            adj[dislike[1]].push_back(dislike[0]);\\n        }\\n\\n        vector<int> color(N+1, 0);\\n        function<bool(int, int)> dfs = [&](int cur, int col) {\\n            if(color[cur] != 0) \\n                return color[cur] == col;\\n            color[cur] = col;\\n            for(auto nxt : adj[cur]) \\n                if(!dfs(nxt, -col)) \\n                    return false;\\n            return true;\\n        };\\n\\n        for(int i = 1; i <= N; i++) {\\n            if(color[i] == 0 && !dfs(i, 1)) \\n                return false;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267265,
                "title": "python-dfs-for-bipartite-problem",
                "content": "Here is a template problem of bipartite.\\n\\nFirst we convert ```dislikes``` to a graph. And nodes from any edge can\\'t be in the same group. Since it\\'s bipartite, there are only two kinds of group: 0 and 1.\\n\\nSo we DFS each node and all of its children nodes should be in different group with it. And when we visit a visited node and there is a group conflict, then the graph can\\'t be bipartite.\\n```\\ndef possibleBipartition(N, dislikes):\\n\\tgraph, group = collections.defaultdict(set), {}\\n\\tfor u, v in dislikes: graph[u].add(v), graph[v].add(u)\\n\\tdef dfs(node, g):\\n\\t\\tif node in group: return group[node] == g\\n\\t\\tgroup[node] = g\\n\\t\\treturn all(dfs(nei, 1-g) for nei in graph[node])\\n\\treturn all(dfs(node, 0) for node in range(1,N+1) if node not in group)\\n```",
                "solutionTags": [],
                "code": "```dislikes```\n```\\ndef possibleBipartition(N, dislikes):\\n\\tgraph, group = collections.defaultdict(set), {}\\n\\tfor u, v in dislikes: graph[u].add(v), graph[v].add(u)\\n\\tdef dfs(node, g):\\n\\t\\tif node in group: return group[node] == g\\n\\t\\tgroup[node] = g\\n\\t\\treturn all(dfs(nei, 1-g) for nei in graph[node])\\n\\treturn all(dfs(node, 0) for node in range(1,N+1) if node not in group)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 641515,
                "title": "dfs-bfs-solution-c",
                "content": "```\\nBy BFS--::\\n\\nclass Solution {\\n    unordered_map<int,vector<int> > gr;\\n    vector<int> vis;\\n    vector<int> colo;\\npublic:\\n    bool bfs(int u){\\n        colo[u]=1;\\n        queue<int> que;\\n        que.push(u);\\n        while(!que.empty()){\\n            int i=que.front();\\n            que.pop();\\n            for(auto v:gr[i]){\\n                if(colo[v]==-1){\\n                    colo[v]=1-colo[i];\\n                    que.push(v);\\n                }\\n                else if(colo[v]==colo[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        for(auto d:dislikes){\\n            gr[d[0]].push_back(d[1]);\\n            gr[d[1]].push_back(d[0]);\\n        }\\n        colo.resize(N+1,-1);\\n        for(int i=1;i<=N;i++){\\n            if(colo[i]==-1){\\n                if(!bfs(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\nBy DFS--::\\n\\nclass Solution {\\n    unordered_map<int,vector<int> > gr;\\n    vector<int> vis;\\n    vector<int> colo;\\npublic:\\n    bool dfs(int u){\\n        vis[u]=1;\\n        for(auto v:gr[u]){\\n            if(!vis[v]){\\n                colo[v]=1-colo[u];\\n                if(!dfs(v)){\\n                    return false;\\n                }\\n            }\\n            else if(colo[v]==colo[u]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        for(auto d:dislikes){\\n            gr[d[0]].push_back(d[1]);\\n            gr[d[1]].push_back(d[0]);\\n        }\\n        colo.resize(N+1,-1);\\n        vis.resize(N+1,0);\\n        for(int i=1;i<=N;i++){\\n            if(colo[i]==-1){\\n                colo[i]=1;\\n                if(!dfs(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nBy BFS--::\\n\\nclass Solution {\\n    unordered_map<int,vector<int> > gr;\\n    vector<int> vis;\\n    vector<int> colo;\\npublic:\\n    bool bfs(int u){\\n        colo[u]=1;\\n        queue<int> que;\\n        que.push(u);\\n        while(!que.empty()){\\n            int i=que.front();\\n            que.pop();\\n            for(auto v:gr[i]){\\n                if(colo[v]==-1){\\n                    colo[v]=1-colo[i];\\n                    que.push(v);\\n                }\\n                else if(colo[v]==colo[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        for(auto d:dislikes){\\n            gr[d[0]].push_back(d[1]);\\n            gr[d[1]].push_back(d[0]);\\n        }\\n        colo.resize(N+1,-1);\\n        for(int i=1;i<=N;i++){\\n            if(colo[i]==-1){\\n                if(!bfs(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\nBy DFS--::\\n\\nclass Solution {\\n    unordered_map<int,vector<int> > gr;\\n    vector<int> vis;\\n    vector<int> colo;\\npublic:\\n    bool dfs(int u){\\n        vis[u]=1;\\n        for(auto v:gr[u]){\\n            if(!vis[v]){\\n                colo[v]=1-colo[u];\\n                if(!dfs(v)){\\n                    return false;\\n                }\\n            }\\n            else if(colo[v]==colo[u]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        for(auto d:dislikes){\\n            gr[d[0]].push_back(d[1]);\\n            gr[d[1]].push_back(d[0]);\\n        }\\n        colo.resize(N+1,-1);\\n        vis.resize(N+1,0);\\n        for(int i=1;i<=N;i++){\\n            if(colo[i]==-1){\\n                colo[i]=1;\\n                if(!dfs(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160371,
                "title": "python-decide-if-a-graph-is-bipartite-by-checking-the-existence-of-odd-cycles",
                "content": "It can be shown that an undirected graph is bipartite if and only if it contains no odd cycles. The detailed proof can be found at: https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles. Then we can use DFS to detect the existence of odd cycles.\\n\\n```\\n# Time complexity: O(|V| + |E|)\\n# Space complxity: O(|V|)\\n# |V| = N, |E| = len(dislikes).\\n\\nclass Solution:\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        # Create an undirected graph where vertices are \"N\" people and edges are\\n        # the dislikes between people.\\n        neighbor_list = [[] for _ in range(N)]\\n        for dislike in dislikes:\\n            # The vertex index starts from \"0\".\\n            neighbor_list[dislike[0] - 1].append(dislike[1] - 1)\\n            neighbor_list[dislike[1] - 1].append(dislike[0] - 1)\\n        \\n        # People can be partitioned into two groups if and only if the graph is\\n        # bipartite where:\\n        # (1) vertices can be partitioned into two groups;\\n        # (2) no edges are within each group and all edges connect two nodes in\\n        # different groups.\\n        # It can be shown that a graph is bipartite if and only if it contains no\\n        # odd cycles. The detailed proof can be found at:\\n        # https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles\\n        def isOddCyclic(curr, parent, path, path_len, visited):\\n            \"\"\"Detects if the undirected graph has an odd cycle.\"\"\"\\n            visited[curr] = True\\n            # path = the dict from the vertex to its index in the \"path\".\\n            path[curr] = path_len\\n            \\n            for neighbor in neighbor_list[curr]:\\n                if not visited[neighbor]:\\n                    # Recursively check if the neighbor has an odd cycle.\\n                    if isOddCyclic(neighbor, curr, path, path_len + 1, visited):\\n                        return True\\n                elif neighbor != parent:\\n                    # If we see a vertex other than the parent, we have found a cycle.      \\n                    if neighbor in path and (path_len - path[neighbor]) % 2 == 0:\\n                        return True\\n                    \\n            path.pop(curr)\\n            return False\\n            \\n        path = {}\\n        visited = [False] * N\\n        for i in range(N):\\n            if not visited[i] and isOddCyclic(i, -1, path, 0, visited):\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n# Time complexity: O(|V| + |E|)\\n# Space complxity: O(|V|)\\n# |V| = N, |E| = len(dislikes).\\n\\nclass Solution:\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        # Create an undirected graph where vertices are \"N\" people and edges are\\n        # the dislikes between people.\\n        neighbor_list = [[] for _ in range(N)]\\n        for dislike in dislikes:\\n            # The vertex index starts from \"0\".\\n            neighbor_list[dislike[0] - 1].append(dislike[1] - 1)\\n            neighbor_list[dislike[1] - 1].append(dislike[0] - 1)\\n        \\n        # People can be partitioned into two groups if and only if the graph is\\n        # bipartite where:\\n        # (1) vertices can be partitioned into two groups;\\n        # (2) no edges are within each group and all edges connect two nodes in\\n        # different groups.\\n        # It can be shown that a graph is bipartite if and only if it contains no\\n        # odd cycles. The detailed proof can be found at:\\n        # https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles\\n        def isOddCyclic(curr, parent, path, path_len, visited):\\n            \"\"\"Detects if the undirected graph has an odd cycle.\"\"\"\\n            visited[curr] = True\\n            # path = the dict from the vertex to its index in the \"path\".\\n            path[curr] = path_len\\n            \\n            for neighbor in neighbor_list[curr]:\\n                if not visited[neighbor]:\\n                    # Recursively check if the neighbor has an odd cycle.\\n                    if isOddCyclic(neighbor, curr, path, path_len + 1, visited):\\n                        return True\\n                elif neighbor != parent:\\n                    # If we see a vertex other than the parent, we have found a cycle.      \\n                    if neighbor in path and (path_len - path[neighbor]) % 2 == 0:\\n                        return True\\n                    \\n            path.pop(curr)\\n            return False\\n            \\n        path = {}\\n        visited = [False] * N\\n        for i in range(N):\\n            if not visited[i] and isOddCyclic(i, -1, path, 0, visited):\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654784,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        int i, j, k, u, v, s;\\n        vector<vector<int>> graph(N, vector<int>());\\n        queue<int> q;\\n        vector<int> visited(N, 0);\\n        for(i = 0; i < dislikes.size(); i++){\\n            u = dislikes[i][0] - 1;\\n            v = dislikes[i][1] - 1;\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(i = 0; i < N; i++){\\n            if(visited[i] != 0){\\n                continue;\\n            }\\n            q.push(i);\\n            visited[i] = 1;\\n            while(!q.empty()){\\n                s = q.size();\\n                for(j = 0; j < s; j++){\\n                    u = q.front();\\n                    q.pop();\\n                    for(k = 0; k < graph[u].size(); k++){\\n                        v = graph[u][k];\\n                        if(visited[v] == 0){\\n                            q.push(v);\\n                            visited[v] = visited[u] == 1 ? 2 : 1;\\n                        }\\n                        \\n                        if(visited[v] == visited[u]){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        int i, j, k, u, v, s;\\n        vector<vector<int>> graph(N, vector<int>());\\n        queue<int> q;\\n        vector<int> visited(N, 0);\\n        for(i = 0; i < dislikes.size(); i++){\\n            u = dislikes[i][0] - 1;\\n            v = dislikes[i][1] - 1;\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        for(i = 0; i < N; i++){\\n            if(visited[i] != 0){\\n                continue;\\n            }\\n            q.push(i);\\n            visited[i] = 1;\\n            while(!q.empty()){\\n                s = q.size();\\n                for(j = 0; j < s; j++){\\n                    u = q.front();\\n                    q.pop();\\n                    for(k = 0; k < graph[u].size(); k++){\\n                        v = graph[u][k];\\n                        if(visited[v] == 0){\\n                            q.push(v);\\n                            visited[v] = visited[u] == 1 ? 2 : 1;\\n                        }\\n                        \\n                        if(visited[v] == visited[u]){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593828,
                "title": "java-dfs-bfs-3-clean-simple-approaches-intuitive-unusual-better-than-most-voted",
                "content": "\\t// bfs approach\\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t  graph[i] = new ArrayList<>();\\n\\t\\t}\\n\\n\\t\\tfor (int[] dislike : dislikes) {\\n\\t\\t  int u = dislike[0] - 1;\\n\\t\\t  int v = dislike[1] - 1;\\n\\n\\t\\t  graph[u].add(v);\\n\\t\\t  graph[v].add(u);\\n\\t\\t}\\n\\n\\t\\tint[] colors = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t  if (colors[i] != 0) {\\n\\t\\t\\tcontinue;\\n\\t\\t  }\\n\\n\\t\\t  colors[i] = 1;\\n\\n\\t\\t  Queue<Integer> queue = new LinkedList<>();\\n\\t\\t  queue.add(i);\\n\\n\\t\\t  while (!queue.isEmpty()) {\\n\\t\\t\\tint node = queue.poll();\\n\\n\\t\\t\\tfor (int adj : graph[node]) {\\n\\t\\t\\t  if (colors[adj] == colors[node]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t  }\\n\\n\\t\\t\\t  if (colors[adj] == 0) {\\n\\t\\t\\t\\tcolors[adj] = -colors[node];\\n\\t\\t\\t\\tqueue.add(adj);\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t  }\\n\\t  \\n\\t  // dfs approach\\n\\t  \\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n      List<Integer>[] graph = new ArrayList[n + 1];\\n      for (int i = 1; i <= n; i++) {\\n        graph[i] = new ArrayList<>();\\n      }\\n\\n      for (int[] dislike : dislikes) {\\n        graph[dislike[0]].add(dislike[1]);\\n        graph[dislike[1]].add(dislike[0]);\\n      }\\n\\n      int[] colors = new int[n + 1];\\n\\n      for (int node = 1; node <= n; node++) {\\n        if (colors[node] == 0 && !paint(colors, node, graph, 1)) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    }\\n\\n    private boolean paint(int[] colors, int node, List<Integer>[] graph, int color) {\\n      if (colors[node] != 0) {\\n        return colors[node] == color;\\n      }\\n\\n      colors[node] = color;\\n\\n      for (int adj : graph[node]) {\\n        if (!paint(colors, adj, graph, -color)) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    }\\n\\t\\n\\t// dfs approach #2\\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n      List<Integer>[] graph = new ArrayList[n + 1];\\n      for (int i = 1; i <= n; i++) {\\n        graph[i] = new ArrayList<>();\\n      }\\n\\n      for (int[] dislike : dislikes) {\\n        graph[dislike[0]].add(dislike[1]);\\n        graph[dislike[1]].add(dislike[0]);\\n      }\\n\\n      int[] colors = new int[n + 1];\\n\\n      for (int node = 1; node <= n; node++) {\\n        if (colors[node] == 0) {\\n          colors[node] = 1;\\n\\n          if (!dfs(colors, node, graph)) {\\n            return false;\\n          }\\n        }\\n      }\\n\\n      return true;\\n    }\\n\\n    private boolean dfs(int[] colors, int person, List<Integer>[] graph) {\\n      for (int p : graph[person]) {\\n        if (colors[person] == colors[p]) {\\n          return false;\\n        }\\n\\n        if (colors[p] == 0) {\\n          colors[p] = -colors[person];\\n\\n          if (!dfs(colors, p, graph)) {\\n            return false;\\n          }\\n        }\\n      }\\n\\n      return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\t// bfs approach\\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n\\t\\tList<Integer>[] graph = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t  graph[i] = new ArrayList<>();\\n\\t\\t}\\n\\n\\t\\tfor (int[] dislike : dislikes) {\\n\\t\\t  int u = dislike[0] - 1;\\n\\t\\t  int v = dislike[1] - 1;\\n\\n\\t\\t  graph[u].add(v);\\n\\t\\t  graph[v].add(u);\\n\\t\\t}\\n\\n\\t\\tint[] colors = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t  if (colors[i] != 0) {\\n\\t\\t\\tcontinue;\\n\\t\\t  }\\n\\n\\t\\t  colors[i] = 1;\\n\\n\\t\\t  Queue<Integer> queue = new LinkedList<>();\\n\\t\\t  queue.add(i);\\n\\n\\t\\t  while (!queue.isEmpty()) {\\n\\t\\t\\tint node = queue.poll();\\n\\n\\t\\t\\tfor (int adj : graph[node]) {\\n\\t\\t\\t  if (colors[adj] == colors[node]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t  }\\n\\n\\t\\t\\t  if (colors[adj] == 0) {\\n\\t\\t\\t\\tcolors[adj] = -colors[node];\\n\\t\\t\\t\\tqueue.add(adj);\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t  }\\n\\t  \\n\\t  // dfs approach\\n\\t  \\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n      List<Integer>[] graph = new ArrayList[n + 1];\\n      for (int i = 1; i <= n; i++) {\\n        graph[i] = new ArrayList<>();\\n      }\\n\\n      for (int[] dislike : dislikes) {\\n        graph[dislike[0]].add(dislike[1]);\\n        graph[dislike[1]].add(dislike[0]);\\n      }\\n\\n      int[] colors = new int[n + 1];\\n\\n      for (int node = 1; node <= n; node++) {\\n        if (colors[node] == 0 && !paint(colors, node, graph, 1)) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    }\\n\\n    private boolean paint(int[] colors, int node, List<Integer>[] graph, int color) {\\n      if (colors[node] != 0) {\\n        return colors[node] == color;\\n      }\\n\\n      colors[node] = color;\\n\\n      for (int adj : graph[node]) {\\n        if (!paint(colors, adj, graph, -color)) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    }\\n\\t\\n\\t// dfs approach #2\\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n      List<Integer>[] graph = new ArrayList[n + 1];\\n      for (int i = 1; i <= n; i++) {\\n        graph[i] = new ArrayList<>();\\n      }\\n\\n      for (int[] dislike : dislikes) {\\n        graph[dislike[0]].add(dislike[1]);\\n        graph[dislike[1]].add(dislike[0]);\\n      }\\n\\n      int[] colors = new int[n + 1];\\n\\n      for (int node = 1; node <= n; node++) {\\n        if (colors[node] == 0) {\\n          colors[node] = 1;\\n\\n          if (!dfs(colors, node, graph)) {\\n            return false;\\n          }\\n        }\\n      }\\n\\n      return true;\\n    }\\n\\n    private boolean dfs(int[] colors, int person, List<Integer>[] graph) {\\n      for (int p : graph[person]) {\\n        if (colors[person] == colors[p]) {\\n          return false;\\n        }\\n\\n        if (colors[p] == 0) {\\n          colors[p] = -colors[person];\\n\\n          if (!dfs(colors, p, graph)) {\\n            return false;\\n          }\\n        }\\n      }\\n\\n      return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 173898,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] colors = new int[N + 1];\\n        for(int i = 1; i <= N; ++i) colors[i] = i;\\n        for(int i = 0; i < dislikes.length; ++i) {\\n            int p1 = dislikes[i][0], p2 = dislikes[i][1];\\n            if(colors[p2] == p2) colors[p2] = p1;\\n            else {\\n                int[] uf1 = find(p1, colors), uf2 = find(p2, colors);\\n                if(uf1[0] == uf2[0] && uf1[1] == uf2[1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private int[] find(int p, int[] colors) {\\n        int color = 0;\\n        while(colors[p] != p) {\\n            p = colors[p];\\n            color = color == 0 ? 1 : 0;\\n        }\\n        return new int[] {p, color};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] colors = new int[N + 1];\\n        for(int i = 1; i <= N; ++i) colors[i] = i;\\n        for(int i = 0; i < dislikes.length; ++i) {\\n            int p1 = dislikes[i][0], p2 = dislikes[i][1];\\n            if(colors[p2] == p2) colors[p2] = p1;\\n            else {\\n                int[] uf1 = find(p1, colors), uf2 = find(p2, colors);\\n                if(uf1[0] == uf2[0] && uf1[1] == uf2[1]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private int[] find(int p, int[] colors) {\\n        int color = 0;\\n        while(colors[p] != p) {\\n            p = colors[p];\\n            color = color == 0 ? 1 : 0;\\n        }\\n        return new int[] {p, color};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933892,
                "title": "python-2-coloring-using-dfs-bfs",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Comment.** The idea of this solution consists in traversing the graph of dislikes and coloring each next vertex into the opposite color. If, on some iteratrion, there is a collision (i.e., coloring second time with a different color) then the bipartition is not possible.\\n\\n**Python #1.** DFS.\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dis: List[List[int]]) -> bool:\\n        \\n        G, P = defaultdict(set), {}\\n        for i,j in dis : G[i].add(j), G[j].add(i)\\n        \\n        def dfs(i, p):\\n            if i in P : return P[i] == p\\n            P[i] = p\\n            return all(dfs(j, not p) for j in G[i])\\n\\n        return all(dfs(i, True) for i in range(1,n+1) if i not in P)\\n```\\n\\n**Python #2.** BFS.\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dis: List[List[int]]) -> bool:\\n        \\n        G = defaultdict(set)\\n        for i,j in dis : G[i].add(j), G[j].add(i)\\n        \\n        seen = dict()\\n\\n        for k in range(1,n+1):\\n            if k not in seen:\\n                Q = deque([(k,True)])\\n                while Q:\\n                    i, g = Q.popleft()\\n                    seen[i] = g\\n                    for j in G[i]:\\n                        if j in seen:\\n                            if seen[j] == g : return False\\n                        else:\\n                            seen[j] = not g\\n                            Q.append((j, not g))\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dis: List[List[int]]) -> bool:\\n        \\n        G, P = defaultdict(set), {}\\n        for i,j in dis : G[i].add(j), G[j].add(i)\\n        \\n        def dfs(i, p):\\n            if i in P : return P[i] == p\\n            P[i] = p\\n            return all(dfs(j, not p) for j in G[i])\\n\\n        return all(dfs(i, True) for i in range(1,n+1) if i not in P)\\n```\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dis: List[List[int]]) -> bool:\\n        \\n        G = defaultdict(set)\\n        for i,j in dis : G[i].add(j), G[j].add(i)\\n        \\n        seen = dict()\\n\\n        for k in range(1,n+1):\\n            if k not in seen:\\n                Q = deque([(k,True)])\\n                while Q:\\n                    i, g = Q.popleft()\\n                    seen[i] = g\\n                    for j in G[i]:\\n                        if j in seen:\\n                            if seen[j] == g : return False\\n                        else:\\n                            seen[j] = not g\\n                            Q.append((j, not g))\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223619,
                "title": "3-ways-bfs-dfs-union-find",
                "content": "Approach is same as M-Coloring Problem where M=2\\n\\n**BFS :**\\n```\\nclass Solution {\\npublic:\\n    // BFS\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> graph[n+1];\\n        \\n        for(auto &d : dislikes){\\n            graph[d[0]].push_back(d[1]);\\n            graph[d[1]].push_back(d[0]);\\n        }\\n        \\n        vector<int> color(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            if(color[i]!=0)\\n                continue;\\n            \\n            color[i] = 1;\\n            queue<int> q;\\n            q.push(i);\\n            \\n            while(!q.empty()){\\n                int node = q.front();\\n                q.pop();\\n                for(auto &v : graph[node]){\\n                    if(color[v]==0){\\n                        color[v] = 3-color[node];\\n                        q.push(v);\\n                    }\\n                    else if(color[v]==color[node])\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n\\n**DFS :**\\n```\\nclass Solution {\\npublic:\\n    // DFS\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> graph[n+1];\\n        \\n        for(auto &d : dislikes){\\n            graph[d[0]].push_back(d[1]);\\n            graph[d[1]].push_back(d[0]);\\n        }\\n        \\n        vector<int> color(n+1,0);\\n        vector<int> visited(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            if(color[i]==0){\\n                color[i] = 1;\\n                if(!dfs(graph,visited,color,i))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool dfs(vector<int> graph[],vector<int> &visited,vector<int> &color,int node){\\n        visited[node] = 1;\\n        for(auto &v : graph[node]){\\n            if(!visited[v]){\\n                color[v] = 3-color[node];\\n                if(!dfs(graph,visited,color,v))\\n                    return false;\\n            }\\n            else if(color[v]==color[node])\\n                return false;\\n        }   \\n        return true;\\n    }\\n};\\n```\\n\\n\\n**Union Find :**\\n```\\nclass UnionFind{\\nprivate:\\n    vector<int> parents;\\n    vector<int> ranks;\\n    int size;\\npublic:\\n    UnionFind(int n){\\n        size = n;\\n        parents.resize(size);\\n        ranks.resize(size,0);\\n        \\n        for(int i=0;i<size;i++){\\n            parents[i] = i;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(x!=parents[x])\\n            parents[x] = find(parents[x]);\\n        return parents[x];\\n    }\\n    \\n    bool union_set(int x,int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX==rootY)\\n            return false;\\n        if(ranks[rootX]>ranks[rootY])\\n            parents[rootY] = rootX;\\n        else{\\n            parents[rootX] = rootY;\\n            if(ranks[rootX]==ranks[rootY])\\n                ranks[rootY]++;\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        unordered_map<int,vector<int>> adjMap;\\n        \\n        for(auto &d : dislikes){\\n            adjMap[d[0]].push_back(d[1]);\\n            adjMap[d[1]].push_back(d[0]);\\n        }\\n        \\n        UnionFind uf(n+1);\\n        \\n        for(auto &pair : adjMap){\\n            auto currVec = pair.second;\\n            int first = currVec[0];\\n            for(int i=1;i<currVec.size();i++){\\n                uf.union_set(first,currVec[i]); \\n                // making set of all disliked people by the current key\\n            }\\n        }\\n        \\n        //checking if two disliking people are in same set\\n        for(auto &d : dislikes){\\n            if(uf.find(d[0]) == uf.find(d[1]))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\nThank You!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // BFS\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> graph[n+1];\\n        \\n        for(auto &d : dislikes){\\n            graph[d[0]].push_back(d[1]);\\n            graph[d[1]].push_back(d[0]);\\n        }\\n        \\n        vector<int> color(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            if(color[i]!=0)\\n                continue;\\n            \\n            color[i] = 1;\\n            queue<int> q;\\n            q.push(i);\\n            \\n            while(!q.empty()){\\n                int node = q.front();\\n                q.pop();\\n                for(auto &v : graph[node]){\\n                    if(color[v]==0){\\n                        color[v] = 3-color[node];\\n                        q.push(v);\\n                    }\\n                    else if(color[v]==color[node])\\n                        return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // DFS\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> graph[n+1];\\n        \\n        for(auto &d : dislikes){\\n            graph[d[0]].push_back(d[1]);\\n            graph[d[1]].push_back(d[0]);\\n        }\\n        \\n        vector<int> color(n+1,0);\\n        vector<int> visited(n+1,0);\\n        \\n        for(int i=1;i<=n;i++){\\n            if(color[i]==0){\\n                color[i] = 1;\\n                if(!dfs(graph,visited,color,i))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool dfs(vector<int> graph[],vector<int> &visited,vector<int> &color,int node){\\n        visited[node] = 1;\\n        for(auto &v : graph[node]){\\n            if(!visited[v]){\\n                color[v] = 3-color[node];\\n                if(!dfs(graph,visited,color,v))\\n                    return false;\\n            }\\n            else if(color[v]==color[node])\\n                return false;\\n        }   \\n        return true;\\n    }\\n};\\n```\n```\\nclass UnionFind{\\nprivate:\\n    vector<int> parents;\\n    vector<int> ranks;\\n    int size;\\npublic:\\n    UnionFind(int n){\\n        size = n;\\n        parents.resize(size);\\n        ranks.resize(size,0);\\n        \\n        for(int i=0;i<size;i++){\\n            parents[i] = i;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(x!=parents[x])\\n            parents[x] = find(parents[x]);\\n        return parents[x];\\n    }\\n    \\n    bool union_set(int x,int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX==rootY)\\n            return false;\\n        if(ranks[rootX]>ranks[rootY])\\n            parents[rootY] = rootX;\\n        else{\\n            parents[rootX] = rootY;\\n            if(ranks[rootX]==ranks[rootY])\\n                ranks[rootY]++;\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        unordered_map<int,vector<int>> adjMap;\\n        \\n        for(auto &d : dislikes){\\n            adjMap[d[0]].push_back(d[1]);\\n            adjMap[d[1]].push_back(d[0]);\\n        }\\n        \\n        UnionFind uf(n+1);\\n        \\n        for(auto &pair : adjMap){\\n            auto currVec = pair.second;\\n            int first = currVec[0];\\n            for(int i=1;i<currVec.size();i++){\\n                uf.union_set(first,currVec[i]); \\n                // making set of all disliked people by the current key\\n            }\\n        }\\n        \\n        //checking if two disliking people are in same set\\n        for(auto &d : dislikes){\\n            if(uf.find(d[0]) == uf.find(d[1]))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650805,
                "title": "c-union-find-with-complement-nodes-fast-155ms-100",
                "content": "I got the idea from [this post](https://leetcode.com/problems/possible-bipartition/discuss/655184/C%2B%2B-UNION-FIND). I have added inline comments to explain why this works.\\n\\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> uf_;\\n\\npublic:\\n    UnionFind(int n) : uf_(n) {\\n        iota(uf_.begin(), uf_.end(), 0);\\n    }\\n\\n    int find(int x) {\\n        if (uf_[x] != x)\\n            x = uf_[x] = find(uf_[x]);\\n        return x;\\n    }\\n\\n    void join(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        uf_[y] = x;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        UnionFind uf(2 * n + 1);\\n        for (const vector<int>& dislike : dislikes) {\\n            // We treat |a + n| and |b + n| as complement nodes to |a| an |b|,\\n            // which means that |a| and |a + n| have the opposite colors, hence\\n            // are in different groups. Same for |b| and |b + n|.\\n            // If |a| and |b| dislike each other then |a| and |b| have to have\\n            // a different color, hence |a| and |b + n| have the same color, and\\n            // so does |b| and |a + n|.\\n            const int a = dislike[0];\\n            const int b = dislike[1];\\n            uf.join(a, b + n);\\n            uf.join(b, a + n);\\n        }\\n        // If |a| and |a + n| end up in the same group, i.e. have the same\\n        // color we have a conflict and the graph isn\\'t bipartite.\\n        for (int i = 1; i <= n; ++i) {\\n            if (uf.find(i) == uf.find(i + n)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nTODO(heder): Space Complexity is straightforward, time complexity is a bit more tricky, something something reverse Ackerman function, need to look this up.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\nprivate:\\n    vector<int> uf_;\\n\\npublic:\\n    UnionFind(int n) : uf_(n) {\\n        iota(uf_.begin(), uf_.end(), 0);\\n    }\\n\\n    int find(int x) {\\n        if (uf_[x] != x)\\n            x = uf_[x] = find(uf_[x]);\\n        return x;\\n    }\\n\\n    void join(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        uf_[y] = x;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        UnionFind uf(2 * n + 1);\\n        for (const vector<int>& dislike : dislikes) {\\n            // We treat |a + n| and |b + n| as complement nodes to |a| an |b|,\\n            // which means that |a| and |a + n| have the opposite colors, hence\\n            // are in different groups. Same for |b| and |b + n|.\\n            // If |a| and |b| dislike each other then |a| and |b| have to have\\n            // a different color, hence |a| and |b + n| have the same color, and\\n            // so does |b| and |a + n|.\\n            const int a = dislike[0];\\n            const int b = dislike[1];\\n            uf.join(a, b + n);\\n            uf.join(b, a + n);\\n        }\\n        // If |a| and |a + n| end up in the same group, i.e. have the same\\n        // color we have a conflict and the graph isn\\'t bipartite.\\n        for (int i = 1; i <= n; ++i) {\\n            if (uf.find(i) == uf.find(i + n)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427753,
                "title": "c-bipartition-2-color-graph-coloring",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n\\t\\tvector<int> adj[n + 1];\\n\\t\\t//graph adj generation using given vector<vector<int>>dislikes\\n\\t\\tfor (auto i : dislikes)\\n\\t\\t{\\n\\t\\t\\tadj[i[0]].push_back(i[1]);\\n\\t\\t\\tadj[i[1]].push_back(i[0]);\\n\\t\\t}\\n\\t\\t//graph coloring using 2 color\\n\\t\\t//color are 0 & 1\\n\\t\\tvector<int>color(n + 1, -1);\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tif (color[i] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!possibleToColor(i, 1, adj, color))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool possibleToColor(int node, int newcolor, vector<int> adj[], vector<int>&color)\\n\\t{\\n\\t\\tcolor[node] = newcolor;\\n\\t\\tfor (auto i : adj[node])\\n\\t\\t{\\n\\t\\t\\tif (color[i] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpossibleToColor(i, 1 - newcolor, adj, color);\\n\\t\\t\\t}\\n\\t\\t\\telse if (color[i] == color[node])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvoet It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n\\t\\tvector<int> adj[n + 1];\\n\\t\\t//graph adj generation using given vector<vector<int>>dislikes\\n\\t\\tfor (auto i : dislikes)\\n\\t\\t{\\n\\t\\t\\tadj[i[0]].push_back(i[1]);\\n\\t\\t\\tadj[i[1]].push_back(i[0]);\\n\\t\\t}\\n\\t\\t//graph coloring using 2 color\\n\\t\\t//color are 0 & 1\\n\\t\\tvector<int>color(n + 1, -1);\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tif (color[i] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!possibleToColor(i, 1, adj, color))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool possibleToColor(int node, int newcolor, vector<int> adj[], vector<int>&color)\\n\\t{\\n\\t\\tcolor[node] = newcolor;\\n\\t\\tfor (auto i : adj[node])\\n\\t\\t{\\n\\t\\t\\tif (color[i] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpossibleToColor(i, 1 - newcolor, adj, color);\\n\\t\\t\\t}\\n\\t\\t\\telse if (color[i] == color[node])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159224,
                "title": "java-solution-dfs-using-set-very-easy-to-understand",
                "content": "# Approach\\nBipartition is the term associated with graph.  So, lets solve this problem using graph traversal algorithms.\\n* Create a graph with N nodes (1,2,3.. N)\\n* Dislikes is an arry which contain group of people who are not willing to be part of same team.  dislikes[i] will contain 2 nodes(source,target) who  dont\\' like each other company.  If x doesn\\'t like y then y also doesn\\'t like x. Which indicates we need to create an undirected graph.\\n* Iterate of dislikes array add 2 edges to graph.\\n\\t* One from Source(dislikes[i][0]) to Target(dislikes[i][1])\\n\\t* Another from Target(dislikes[i][1]) to Source(dislikes[i][0]\\n* Create an another integer array called colors.  Used for bipartition.  If a person x doesn\\'t like y, then x will go to Green team and y will go to Red team.\\n\\t* We can create integer/short/byte array.  On tight memory constraint we can use byte[], as we only need 3 values.\\n\\t\\t* Uncolored nodes(-1)\\n\\t\\t* Green Nodes(1)\\n\\t\\t* Red Nodes(2)\\n* Now traverse the graph using any of the graph traversal algorithms(DFS/BFS).  If at any point in time we find a case where one of the Green team member needs to be moved to Red or vice versa, then it\\'s not possible to partition nodes into 2 groups.  So, return false.  Otherwise return true.\\n* Java code using dfs is given below. (46 ms)  Probably we can improve time 46 ms to few ms lower, but if you are practicing this for interview pay attention to (on white board coding following matters, than getting to run few ms faster)\\n\\t* Readability of the code.\\n\\t* Clarity of the graph traversal concept\\n\\t* Clarity on the data structure used.\\n\\t* Correctness of the solution.(Most important).\\n\\t* Time/Space Complexity of the code.\\n# Code\\n```\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        // HashSet used as adjacencySet dataStructure for Graph.  If duplicate nodes are allowed then use List.\\n\\tSet<Integer>[] graph = new HashSet[N+1] ;\\n\\t// Vertex 0 has no data in this graph as per problem statement.  So, start at 1.\\t\\n        for (int i = 1 ; i <= N ; ++ i) {\\n\\t// Initialize HashSet\\n            graph[i] = new HashSet<>() ;\\n        }\\n\\n        for (int i = 0 ; i < dislikes.length ; ++ i) {\\n            int source = dislikes[i][0], target = dislikes[i][1] ;\\n\\t// Add edges in both direction to create undirected graph\\n            graph[source].add(target) ;\\n            graph[target].add(source) ;\\n        }\\n\\n        int colors[] = new int[N+1] ;\\n\\t// Initially no one belongs to any group.  So, initialize every node to -1.\\n\\tArrays.fill(colors, -1) ;\\n        for (int v = 1 ; v < graph.length ; ++ v) {\\n\\t// Start dfs only if current node is not part of any group.  If node is not assigned to group and dfs returns false then it\\'s not possible to bi-partition this graph.  So, answer is false.\\n            if (colors[v] == -1 &&  !dfs (graph, v, colors, 0))\\n            return false ;\\n        }\\n\\t// if we are able to visit all nodes then answer is yes.  We are able to split the nodes into 2 different groups.\\n        return true ;\\n    }\\n\\t// DFS returns true only 2 conditions.\\n\\t//  1.  We reached all nodes from the current source vertex - s\\n\\t//  2.  We reached the already visited and that belongs the the same team we expect.\\n    boolean dfs(Set<Integer>[] graph, int s, int[] colors, int color) {\\n        if (colors[s] != -1) {\\n            return colors[s] == color ;\\n        }\\n        colors[s] = color ;\\n        for (int w : graph[s]) {\\n            if (!dfs(graph, w, colors, 1 - color))\\n                return false ;\\n        }\\n        return true ;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        // HashSet used as adjacencySet dataStructure for Graph.  If duplicate nodes are allowed then use List.\\n\\tSet<Integer>[] graph = new HashSet[N+1] ;\\n\\t// Vertex 0 has no data in this graph as per problem statement.  So, start at 1.\\t\\n        for (int i = 1 ; i <= N ; ++ i) {\\n\\t// Initialize HashSet\\n            graph[i] = new HashSet<>() ;\\n        }\\n\\n        for (int i = 0 ; i < dislikes.length ; ++ i) {\\n            int source = dislikes[i][0], target = dislikes[i][1] ;\\n\\t// Add edges in both direction to create undirected graph\\n            graph[source].add(target) ;\\n            graph[target].add(source) ;\\n        }\\n\\n        int colors[] = new int[N+1] ;\\n\\t// Initially no one belongs to any group.  So, initialize every node to -1.\\n\\tArrays.fill(colors, -1) ;\\n        for (int v = 1 ; v < graph.length ; ++ v) {\\n\\t// Start dfs only if current node is not part of any group.  If node is not assigned to group and dfs returns false then it\\'s not possible to bi-partition this graph.  So, answer is false.\\n            if (colors[v] == -1 &&  !dfs (graph, v, colors, 0))\\n            return false ;\\n        }\\n\\t// if we are able to visit all nodes then answer is yes.  We are able to split the nodes into 2 different groups.\\n        return true ;\\n    }\\n\\t// DFS returns true only 2 conditions.\\n\\t//  1.  We reached all nodes from the current source vertex - s\\n\\t//  2.  We reached the already visited and that belongs the the same team we expect.\\n    boolean dfs(Set<Integer>[] graph, int s, int[] colors, int color) {\\n        if (colors[s] != -1) {\\n            return colors[s] == color ;\\n        }\\n        colors[s] = color ;\\n        for (int w : graph[s]) {\\n            if (!dfs(graph, w, colors, 1 - color))\\n                return false ;\\n        }\\n        return true ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644973,
                "title": "c-union-find-easy-to-understand-solution",
                "content": "```\\nclass UnionFind {\\nprivate:\\n    int N;\\n    vector<int> _parent;\\n    vector<int> _rank;\\npublic:\\n    UnionFind(int n):\\n    N(move(n)) \\n    {\\n        _parent = vector<int>(N);\\n        _rank = vector<int>(N, 0);\\n        \\n        for(int i = 0; i < N; i++)\\n            _parent[i] = i;\\n    }\\n    \\n    int find(int i) {\\n        if(_parent[i] != i) {\\n            _parent[i] = find(_parent[i]);\\n        }\\n        return _parent[i];\\n    }\\n    \\n    bool _union(const int& i, const int& j) {\\n        int parentI = find(i);\\n        int parentJ = find(j);\\n        \\n        if(parentI == parentJ)\\n            return false;\\n        \\n        if(_rank[parentI] < _rank[parentJ]) {\\n            _parent[parentI] = parentJ;\\n        }\\n        else if(_rank[parentI] > _rank[parentJ]) {\\n            _parent[parentJ] = parentI;\\n        }\\n        else {\\n            _parent[parentJ] = parentI;\\n            _rank[parentI]++;\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        unordered_map<int, vector<int>> _adjacencyMap;\\n        \\n        UnionFind uF(N+1);\\n        \\n        for(const auto& vec: dislikes) {\\n            _adjacencyMap[vec[0]].push_back(vec[1]); \\n            _adjacencyMap[vec[1]].push_back(vec[0]); \\n        }\\n        \\n        for(const auto& pair: _adjacencyMap) {\\n            const auto& list = pair.second;\\n            int first = list[0];\\n            for(int i = 1; i < list.size(); i++) {\\n                uF._union(first, list[i]);\\n            }\\n        }\\n        \\n        for(const auto& vec: dislikes) {\\n            if(uF.find(vec[0]) == uF.find(vec[1]))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\nprivate:\\n    int N;\\n    vector<int> _parent;\\n    vector<int> _rank;\\npublic:\\n    UnionFind(int n):\\n    N(move(n)) \\n    {\\n        _parent = vector<int>(N);\\n        _rank = vector<int>(N, 0);\\n        \\n        for(int i = 0; i < N; i++)\\n            _parent[i] = i;\\n    }\\n    \\n    int find(int i) {\\n        if(_parent[i] != i) {\\n            _parent[i] = find(_parent[i]);\\n        }\\n        return _parent[i];\\n    }\\n    \\n    bool _union(const int& i, const int& j) {\\n        int parentI = find(i);\\n        int parentJ = find(j);\\n        \\n        if(parentI == parentJ)\\n            return false;\\n        \\n        if(_rank[parentI] < _rank[parentJ]) {\\n            _parent[parentI] = parentJ;\\n        }\\n        else if(_rank[parentI] > _rank[parentJ]) {\\n            _parent[parentJ] = parentI;\\n        }\\n        else {\\n            _parent[parentJ] = parentI;\\n            _rank[parentI]++;\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        unordered_map<int, vector<int>> _adjacencyMap;\\n        \\n        UnionFind uF(N+1);\\n        \\n        for(const auto& vec: dislikes) {\\n            _adjacencyMap[vec[0]].push_back(vec[1]); \\n            _adjacencyMap[vec[1]].push_back(vec[0]); \\n        }\\n        \\n        for(const auto& pair: _adjacencyMap) {\\n            const auto& list = pair.second;\\n            int first = list[0];\\n            for(int i = 1; i < list.size(); i++) {\\n                uF._union(first, list[i]);\\n            }\\n        }\\n        \\n        for(const auto& vec: dislikes) {\\n            if(uF.find(vec[0]) == uF.find(vec[1]))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195303,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    \\n    /**\\n    union find\\n    **/\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] parent = new int[N + 1];\\n        for (int i = 0; i <= N; i++) parent[i] = i;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] pair : dislikes) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            map.putIfAbsent(a, new ArrayList<>());\\n            map.putIfAbsent(b, new ArrayList<>());\\n            map.get(a).add(b);\\n            map.get(b).add(a);\\n        }\\n        for (int i = 1; i <= N; i++) {\\n            if (map.containsKey(i)) {\\n                int parent1 = find(parent, i);\\n                List<Integer> opponents = map.get(i);\\n                int parent2 = find(parent, opponents.get(0));\\n                if (parent1 == parent2) return false;\\n                for (int j = 1; j < opponents.size(); j++) {\\n                    int opponentParent = find(parent, opponents.get(j));\\n                    if (parent1 == opponentParent) return false;\\n                    parent[opponentParent] = parent2;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private int find(int[] parent, int i) {\\n        while (i != parent[i]) {\\n            i = parent[parent[i]];\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /**\\n    union find\\n    **/\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] parent = new int[N + 1];\\n        for (int i = 0; i <= N; i++) parent[i] = i;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] pair : dislikes) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            map.putIfAbsent(a, new ArrayList<>());\\n            map.putIfAbsent(b, new ArrayList<>());\\n            map.get(a).add(b);\\n            map.get(b).add(a);\\n        }\\n        for (int i = 1; i <= N; i++) {\\n            if (map.containsKey(i)) {\\n                int parent1 = find(parent, i);\\n                List<Integer> opponents = map.get(i);\\n                int parent2 = find(parent, opponents.get(0));\\n                if (parent1 == parent2) return false;\\n                for (int j = 1; j < opponents.size(); j++) {\\n                    int opponentParent = find(parent, opponents.get(j));\\n                    if (parent1 == opponentParent) return false;\\n                    parent[opponentParent] = parent2;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private int find(int[] parent, int i) {\\n        while (i != parent[i]) {\\n            i = parent[parent[i]];\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140797,
                "title": "javascript-simple-graph-coloring-with-detailed-explanation",
                "content": "Approach:\\n1. We can color each node either `1` or `2`\\n2. Same colored nodes can not be neighbors  \\n3. So, first removed colors that are already used by neighbors\\n4. If no color is left (aka conneceted to both `1` and `2` color nodes) return `false`\\n5. Assign the current node the smalles available color\\n\\nTime: `O(N + E)`\\nSpace: `O(N)`\\n\\n```javascript\\nvar possibleBipartition = function(N, dislikes) {\\n    const graph = [...Array(N+1)].map(() => []);\\n    const visited = Array(N+1).fill(false);\\n    const color = Array(N+1).fill(0);\\n\\n    for(let [u, v] of dislikes) {\\n        graph[u].push(v);\\n        graph[v].push(u);\\n    }\\n\\n    for(let i = 1; i <= N; i++) {\\n        if(!colorNodes(i)) return false;\\n    }\\n    return true;\\n\\n    function colorNodes(node) {\\n        if(visited[node]) return true;\\n        const currColor = new Set([1, 2]);\\n\\n\\t\\t// remove colors used by neighbors\\n        for(let child of graph[node]) {\\n            if(color[child] === 1) currColor.delete(1);\\n            if(color[child] === 2) currColor.delete(2);\\n        }\\n\\n\\t\\t// no color is available return false\\n        if(currColor.size === 0) return false;\\n\\t\\t\\n\\t\\t// assign the smallest available color\\n        color[node] = Math.min(...currColor);\\n        visited[node] = true;  \\n\\n        for(let child of graph[node]) {\\n            if(!colorNodes(child)) return false; \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```javascript\\nvar possibleBipartition = function(N, dislikes) {\\n    const graph = [...Array(N+1)].map(() => []);\\n    const visited = Array(N+1).fill(false);\\n    const color = Array(N+1).fill(0);\\n\\n    for(let [u, v] of dislikes) {\\n        graph[u].push(v);\\n        graph[v].push(u);\\n    }\\n\\n    for(let i = 1; i <= N; i++) {\\n        if(!colorNodes(i)) return false;\\n    }\\n    return true;\\n\\n    function colorNodes(node) {\\n        if(visited[node]) return true;\\n        const currColor = new Set([1, 2]);\\n\\n\\t\\t// remove colors used by neighbors\\n        for(let child of graph[node]) {\\n            if(color[child] === 1) currColor.delete(1);\\n            if(color[child] === 2) currColor.delete(2);\\n        }\\n\\n\\t\\t// no color is available return false\\n        if(currColor.size === 0) return false;\\n\\t\\t\\n\\t\\t// assign the smallest available color\\n        color[node] = Math.min(...currColor);\\n        visited[node] = true;  \\n\\n        for(let child of graph[node]) {\\n            if(!colorNodes(child)) return false; \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654940,
                "title": "c-dfs-graph-coloring",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& graph, int i, int col, vector<int>& color) {\\n        color[i] = col;\\n        for(auto x: graph[i]) {\\n            if(color[x] == color[i]) {\\n                return 0;\\n            }\\n            if(color[x] == 0 && !dfs(graph, x, -col, color)) {\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(N+1);\\n        for(auto i: dislikes) {\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        vector<int> color(N+1, 0); // 0 -> not visited, 1 -> group 1, -1 -> group 2\\n        for(int i=1;i<=N;i++) {\\n            if(color[i] == 0 && !dfs(graph, i, 1, color)) {\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& graph, int i, int col, vector<int>& color) {\\n        color[i] = col;\\n        for(auto x: graph[i]) {\\n            if(color[x] == color[i]) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2934909,
                "title": "c-simple-dfs-solution-bipartite-graph",
                "content": "# Bipartite graph\\na bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint and independent sets U and V, that is every edge connects a vertex in U to one in V. Vertex sets U and V are usually called the parts of the graph.\\n\\n# Test cases\\n![bi.jpg](https://assets.leetcode.com/users/images/75d09c25-7f1f-426b-9ffc-83436328399f_1671611046.255755.jpeg)\\n\\nfirst test case is true because the graph is Bipartite graph\\n\\n![bi2.jpg](https://assets.leetcode.com/users/images/3af97ca8-1ad3-430b-9ac6-43be9467b192_1671611106.7889366.jpeg)\\n\\nSecond test case is false because the graph is not Bipartite graph\\nBecause there node 2 linked with node 3 in the same part \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing dfs .. assign a first group to node and the nodes linked with it assign a second group and so on\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn is number of nodes \\nm is number of edges \\n### O(n+m)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int>g1,g2;//two parts of gragh \\n    const static int N = 2009;\\n    vector<int>adj[N];//adjacency matrix\\n    bool vis[N];// boolean array to check nodes are visted or not \\n    //dfs take a current node and boolean to set the node to part of gragh\\n    void dfs(int u, bool g){\\n        //Determine the node group\\n        (g)?g1.insert(u):g2.insert(u);\\n        //If visited it before then stop dfs\\n        if(vis[u])\\n            return;\\n        //mark is visited\\n        vis[u]=1;\\n        // Recur for all the vertices adjacent\\n        for(auto v:adj[u])\\n            //flip the boolean Because each Node is linked to Nodes in the other group\\n            dfs(v,g^1);\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        //fill adjacency matrix\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        //call dfs\\n        for(int i=1;i<=n;i++){\\n            if(!vis[i])\\n                dfs(i,0);\\n        }\\n        //if the number of nodes of two parts of graph = the number of all nodes\\n        //then the graph is Bipartite graph\\n        //if the number of nodes of two parts of graph > the number of all nodes \\n        //then the graph is not Bipartite graph\\n        //Because there are some Nodes linked with nodes in the same part \\n        return g1.size()+g2.size()==n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int>g1,g2;//two parts of gragh \\n    const static int N = 2009;\\n    vector<int>adj[N];//adjacency matrix\\n    bool vis[N];// boolean array to check nodes are visted or not \\n    //dfs take a current node and boolean to set the node to part of gragh\\n    void dfs(int u, bool g){\\n        //Determine the node group\\n        (g)?g1.insert(u):g2.insert(u);\\n        //If visited it before then stop dfs\\n        if(vis[u])\\n            return;\\n        //mark is visited\\n        vis[u]=1;\\n        // Recur for all the vertices adjacent\\n        for(auto v:adj[u])\\n            //flip the boolean Because each Node is linked to Nodes in the other group\\n            dfs(v,g^1);\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        //fill adjacency matrix\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        //call dfs\\n        for(int i=1;i<=n;i++){\\n            if(!vis[i])\\n                dfs(i,0);\\n        }\\n        //if the number of nodes of two parts of graph = the number of all nodes\\n        //then the graph is Bipartite graph\\n        //if the number of nodes of two parts of graph > the number of all nodes \\n        //then the graph is not Bipartite graph\\n        //Because there are some Nodes linked with nodes in the same part \\n        return g1.size()+g2.size()==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715453,
                "title": "union-find-solution-with-explanation-python",
                "content": "\\t\"\"\"\\n\\tIt is same problem as bipartite graph or graph coloring \\n\\t-Here we used union find \\n\\t-Here we are first creating the adjancy list (0 based indexing)\\n\\t-Then we are traversing through the neighbours of the node - neighbours should not have the same color because if they have same color then they dont dislike each other so ans is FALSE return False\\n\\t-Then we check for all the neighbours then if the neighbour doesn\\'t have the same color as the parent/node then we can give two neighbour as same color \\n\\n\\t\"\"\"\\n\\tfrom collections import defaultdict\\n\\tclass DSU:\\n\\t\\tdef __init__(self,n):\\n\\t\\t\\tself.parent=[i for i in range(n+1)]\\n\\t\\tdef findPar(self,u):\\n\\t\\t\\tif self.parent[u]!=u:\\n\\t\\t\\t\\tself.parent[u]=self.findPar(self.parent[u])\\n\\t\\t\\treturn self.parent[u]\\n\\t\\tdef union(self,u,v):\\n\\t\\t\\tpu = self.findPar(u)\\n\\t\\t\\tpv = self.findPar(v)\\n\\t\\t\\tself.parent[pu] = pv\\n\\n\\tclass Solution(object):\\n\\t\\tdef possibleBipartition(self, n, dislikes):\\n\\t\\t\\tdsu = DSU(n)\\n\\t\\t\\tadj=defaultdict(list)\\n\\t\\t\\tfor i,j in dislikes:\\n\\t\\t\\t\\tadj[i-1].append(j-1)\\n\\t\\t\\t\\tadj[j-1].append(i-1)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tnei = adj[i]\\n\\t\\t\\t\\tdis = dsu.findPar(i)\\n\\t\\t\\t\\tif not nei: continue\\n\\t\\t\\t\\tfor j in nei[1:]:\\n\\t\\t\\t\\t\\tif dsu.findPar(j)==dis:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdsu.union(nei[0],j)\\n\\t\\t\\treturn True\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "\\t\"\"\"\\n\\tIt is same problem as bipartite graph or graph coloring \\n\\t-Here we used union find \\n\\t-Here we are first creating the adjancy list (0 based indexing)\\n\\t-Then we are traversing through the neighbours of the node - neighbours should not have the same color because if they have same color then they dont dislike each other so ans is FALSE return False\\n\\t-Then we check for all the neighbours then if the neighbour doesn\\'t have the same color as the parent/node then we can give two neighbour as same color \\n\\n\\t\"\"\"\\n\\tfrom collections import defaultdict\\n\\tclass DSU:\\n\\t\\tdef __init__(self,n):\\n\\t\\t\\tself.parent=[i for i in range(n+1)]\\n\\t\\tdef findPar(self,u):\\n\\t\\t\\tif self.parent[u]!=u:\\n\\t\\t\\t\\tself.parent[u]=self.findPar(self.parent[u])\\n\\t\\t\\treturn self.parent[u]\\n\\t\\tdef union(self,u,v):\\n\\t\\t\\tpu = self.findPar(u)\\n\\t\\t\\tpv = self.findPar(v)\\n\\t\\t\\tself.parent[pu] = pv\\n\\n\\tclass Solution(object):\\n\\t\\tdef possibleBipartition(self, n, dislikes):\\n\\t\\t\\tdsu = DSU(n)\\n\\t\\t\\tadj=defaultdict(list)\\n\\t\\t\\tfor i,j in dislikes:\\n\\t\\t\\t\\tadj[i-1].append(j-1)\\n\\t\\t\\t\\tadj[j-1].append(i-1)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tnei = adj[i]\\n\\t\\t\\t\\tdis = dsu.findPar(i)\\n\\t\\t\\t\\tif not nei: continue\\n\\t\\t\\t\\tfor j in nei[1:]:\\n\\t\\t\\t\\t\\tif dsu.findPar(j)==dis:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdsu.union(nei[0],j)\\n\\t\\t\\treturn True\\n",
                "codeTag": "Java"
            },
            {
                "id": 862916,
                "title": "python-solution-graph-coloring",
                "content": "This question is samiler as LC785. The only deffirence is the input list: the input list of LC785 is graph, while the linput list of LC886 is node pair. If we can transfer the LC886\\'s input list to graph, then we can use LC785\\'s method to solve this question.\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n       \\n\\t\\tif N < 1 or not dislikes:\\n            return True\\n\\t\\t\\n\\t\\t# Transfer LC886 node pair list to LC785 graph list\\n        graph = {}\\n        for node1, node2 in dislikes:\\n            if node1 not in graph: graph[node1] = []\\n            if node2 not in graph: graph[node2] = []\\n            \\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n         \\n\\t\\t# Use LC785\\'s graph coloring method to solve this quetion\\n        dic = {}\\n        for graph_node in graph.keys():\\n            if graph_node not in dic:\\n                queue = [(graph_node, 0)]\\n                dic[graph_node] = 0\\n                \\n                while queue:\\n                    queue_node, flag = queue.pop(0)\\n                    tmp_flag = (flag + 1) % 2\\n                    for edge in graph[queue_node]:\\n                        if edge in dic:\\n                            if dic[edge] != tmp_flag:\\n                                return False\\n                        else:\\n                            queue.append((edge, tmp_flag))\\n                            dic[edge] = tmp_flag\\n                        \\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n       \\n\\t\\tif N < 1 or not dislikes:\\n            return True\\n\\t\\t\\n\\t\\t# Transfer LC886 node pair list to LC785 graph list\\n        graph = {}\\n        for node1, node2 in dislikes:\\n            if node1 not in graph: graph[node1] = []\\n            if node2 not in graph: graph[node2] = []\\n            \\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n         \\n\\t\\t# Use LC785\\'s graph coloring method to solve this quetion\\n        dic = {}\\n        for graph_node in graph.keys():\\n            if graph_node not in dic:\\n                queue = [(graph_node, 0)]\\n                dic[graph_node] = 0\\n                \\n                while queue:\\n                    queue_node, flag = queue.pop(0)\\n                    tmp_flag = (flag + 1) % 2\\n                    for edge in graph[queue_node]:\\n                        if edge in dic:\\n                            if dic[edge] != tmp_flag:\\n                                return False\\n                        else:\\n                            queue.append((edge, tmp_flag))\\n                            dic[edge] = tmp_flag\\n                        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655181,
                "title": "python-bfs-dfs-solution",
                "content": "```\\n#BFS:-\\nclass Solution:\\n    def possibleBipartition(self, N, dislikes):\\n        graph = collections.defaultdict(list)\\n        colors =collections.defaultdict(int)\\n        for a, b in dislikes:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        color = [-1] * (N + 1)\\n        for i in range(1, N + 1):\\n            if color[i] == -1:\\n                color[i] = 0\\n                q = [i]\\n                while q:\\n                    node = q.pop()\\n                    for j in graph[node]:\\n                        if color[j] == color[node]:\\n                            return False\\n                        if color[j] == -1:\\n                            color[j] = color[node] ^ 1\\n                            q.append(j)\\n        return True\\n```\\n\\n```\\n#DFS:-\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        graph = collections.defaultdict(list)\\n        for 0, 1 in dislikes:\\n            graph[0].append(1)\\n            graph[1].append(0)\\n\\n        color = {}\\n        def dfs(node, c = 0):\\n            if node in color:\\n                return color[node] == c\\n            color[node] = c\\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\\n\\n        return all(dfs(node)\\n                   for node in range(1, N+1)\\n                   if node not in color)\\n```",
                "solutionTags": [],
                "code": "```\\n#BFS:-\\nclass Solution:\\n    def possibleBipartition(self, N, dislikes):\\n        graph = collections.defaultdict(list)\\n        colors =collections.defaultdict(int)\\n        for a, b in dislikes:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        color = [-1] * (N + 1)\\n        for i in range(1, N + 1):\\n            if color[i] == -1:\\n                color[i] = 0\\n                q = [i]\\n                while q:\\n                    node = q.pop()\\n                    for j in graph[node]:\\n                        if color[j] == color[node]:\\n                            return False\\n                        if color[j] == -1:\\n                            color[j] = color[node] ^ 1\\n                            q.append(j)\\n        return True\\n```\n```\\n#DFS:-\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        graph = collections.defaultdict(list)\\n        for 0, 1 in dislikes:\\n            graph[0].append(1)\\n            graph[1].append(0)\\n\\n        color = {}\\n        def dfs(node, c = 0):\\n            if node in color:\\n                return color[node] == c\\n            color[node] = c\\n            return all(dfs(nei, c ^ 1) for nei in graph[node])\\n\\n        return all(dfs(node)\\n                   for node in range(1, N+1)\\n                   if node not in color)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654826,
                "title": "python-3-bfs-solution",
                "content": "```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        visited = [0] * N\\n        graph = [[] for _ in range(N)]\\n        for edge in dislikes:\\n            u = edge[0] - 1\\n            v = edge[1] - 1\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        q = Queue()\\n        for i in range(0, N):\\n            if visited[i] != 0:\\n                continue\\n            visited[i] = 1\\n            q.put(i)\\n            while not q.empty():\\n                s = q.qsize()\\n                for j in range(0, s):\\n                    u = q.get()\\n                    for k in range(0, len(graph[u])):\\n                        v = graph[u][k]\\n                        if visited[v] == 0:\\n                            visited[v] = 2 if visited[u] == 1 else 1\\n                            q.put(v)\\n                        \\n                        if visited[v] == visited[u]:\\n                            return False\\n                    \\n        return True\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        visited = [0] * N\\n        graph = [[] for _ in range(N)]\\n        for edge in dislikes:\\n            u = edge[0] - 1\\n            v = edge[1] - 1\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        q = Queue()\\n        for i in range(0, N):\\n            if visited[i] != 0:\\n                continue\\n            visited[i] = 1\\n            q.put(i)\\n            while not q.empty():\\n                s = q.qsize()\\n                for j in range(0, s):\\n                    u = q.get()\\n                    for k in range(0, len(graph[u])):\\n                        v = graph[u][k]\\n                        if visited[v] == 0:\\n                            visited[v] = 2 if visited[u] == 1 else 1\\n                            q.put(v)\\n                        \\n                        if visited[v] == visited[u]:\\n                            return False\\n                    \\n        return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934626,
                "title": "c-bfs-comments-added-easy-to-understand",
                "content": "**Please Upvote If You Like it**\\n\\n**Intuition**\\n```\\n# we can solve problem by using bipartite graph problem\\n\\n# how : as we know in bipartite grapg we have exact two colols by which we can color it\\n\\n# so here we can think if there are only two colors by which we can color it, so what if we think instead of color, we can exactly store these values in two groups without conflict Right?\\n\\n# now question becomes Is given 2d vector biparite (true) or not (false)\\n        \\ncolor 0 : set 1\\ncolor 1 : set 2\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \\n    {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<dislikes.size();i++)\\n        {\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);   \\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);   \\n        }\\n        \\n        vector<int> color(n+1,-1);                 // checking for colors\\n        \\n        // for every component\\n        for(int i=1;i<=n;i++)\\n        {\\n            // not colored\\n            if(color[i]==-1)\\n            {\\n                queue<int> q;\\n                q.push(i);\\n                color[i] = 0;\\n\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n\\n                    // checking for all adjacency nodes\\n                    for(auto it : adj[node])\\n                    {\\n                        // if not colored then color it with oppodite color and push it into the queue\\n                        if(color[it]==-1)\\n                        {\\n                            color[it] = 1-color[node];\\n                            q.push(it);\\n                        }\\n                        // already colored and having same color then return false\\n                        else if(color[it]==color[node])\\n                        {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n# we can solve problem by using bipartite graph problem\\n\\n# how : as we know in bipartite grapg we have exact two colols by which we can color it\\n\\n# so here we can think if there are only two colors by which we can color it, so what if we think instead of color, we can exactly store these values in two groups without conflict Right?\\n\\n# now question becomes Is given 2d vector biparite (true) or not (false)\\n        \\ncolor 0 : set 1\\ncolor 1 : set 2\\n```\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \\n    {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<dislikes.size();i++)\\n        {\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);   \\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);   \\n        }\\n        \\n        vector<int> color(n+1,-1);                 // checking for colors\\n        \\n        // for every component\\n        for(int i=1;i<=n;i++)\\n        {\\n            // not colored\\n            if(color[i]==-1)\\n            {\\n                queue<int> q;\\n                q.push(i);\\n                color[i] = 0;\\n\\n                while(!q.empty())\\n                {\\n                    int node = q.front();\\n                    q.pop();\\n\\n                    // checking for all adjacency nodes\\n                    for(auto it : adj[node])\\n                    {\\n                        // if not colored then color it with oppodite color and push it into the queue\\n                        if(color[it]==-1)\\n                        {\\n                            color[it] = 1-color[node];\\n                            q.push(it);\\n                        }\\n                        // already colored and having same color then return false\\n                        else if(color[it]==color[node])\\n                        {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505207,
                "title": "easy-peasy-java-solution-from-bfs-graph-coloring",
                "content": "Hello coders !\\nHope you all are safe !\\nhere\\'s my solution with BFS - Graph Coloring method\\n```\\nRuntime: 26 ms, faster than 52.97% .\\nMemory Usage: 86 MB, less than 26.01% .\\n```\\nIf you have any doubts or suggestions feel free to comment.\\nHappy coding ! :) :)\\n```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes)\\n    {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < n+1 ; i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] dis:dislikes)\\n        {\\n            graph.get(dis[0]).add(dis[1]);\\n            graph.get(dis[1]).add(dis[0]);\\n        }\\n        \\n        \\n        // System.out.println(graph);\\n        \\n        // using graph coloring\\n        \\n        int[] colors = new int[n+1];\\n        \\n        for (int i = 0; i < n+1 ; i++) {\\n            if (colors[i] == 0)\\n            { \\n                Queue<Integer> q = new ArrayDeque<>();\\n                q.add(i);\\n                colors[i] = 1; \\n\\n                while (!q.isEmpty()) {\\n                    int rm = q.remove(); \\n                    for (int g : graph.get(rm)) {\\n                        if (colors[g] == 0) { \\n                            colors[g] = -colors[rm]; \\n                            q.add(g);\\n                        } else if (colors[g]==colors[rm])\\n                            return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nRuntime: 26 ms, faster than 52.97% .\\nMemory Usage: 86 MB, less than 26.01% .\\n```\n```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes)\\n    {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < n+1 ; i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int[] dis:dislikes)\\n        {\\n            graph.get(dis[0]).add(dis[1]);\\n            graph.get(dis[1]).add(dis[0]);\\n        }\\n        \\n        \\n        // System.out.println(graph);\\n        \\n        // using graph coloring\\n        \\n        int[] colors = new int[n+1];\\n        \\n        for (int i = 0; i < n+1 ; i++) {\\n            if (colors[i] == 0)\\n            { \\n                Queue<Integer> q = new ArrayDeque<>();\\n                q.add(i);\\n                colors[i] = 1; \\n\\n                while (!q.isEmpty()) {\\n                    int rm = q.remove(); \\n                    for (int g : graph.get(rm)) {\\n                        if (colors[g] == 0) { \\n                            colors[g] = -colors[rm]; \\n                            q.add(g);\\n                        } else if (colors[g]==colors[rm])\\n                            return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909830,
                "title": "java-union-find",
                "content": "```\\npublic class PossibleBipartition {\\n\\n  public boolean possibleBipartition(int N, int[][] dislikes) {\\n    if (dislikes.length <= 1) {\\n      return true;\\n    }\\n    UnionFind uf = new UnionFind(N << 1);\\n    for (int[] dislike : dislikes) {\\n      uf.union(dislike[0], dislike[1] + N);\\n      uf.union(dislike[1], dislike[0] + N);\\n    }\\n    for (int i = 1; i <= N; i++) {\\n      if (uf.find(i) == uf.find(i + N)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  private static class UnionFind {\\n\\n    int[] parent;\\n    int[] size;\\n    int count;\\n\\n    public UnionFind(int n) {\\n      parent = new int[n + 1];\\n      size = new int[n + 1];\\n      for (int i = 0; i <= n; i++) {\\n        parent[i] = i;\\n        size[i] = 1;\\n      }\\n      this.count = n;\\n    }\\n\\n    public int find(int i) {\\n      if (i != parent[i]) {\\n        parent[i] = find(parent[i]);\\n      }\\n      return parent[i];\\n    }\\n\\n    public void union(int p, int q) {\\n      int i = find(p);\\n      int j = find(q);\\n      if (size[i] > size[j]) {\\n        parent[j] = i;\\n        size[i] += size[j];\\n      } else {\\n        parent[i] = j;\\n        size[j] += size[i];\\n      }\\n      this.count--;\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\npublic class PossibleBipartition {\\n\\n  public boolean possibleBipartition(int N, int[][] dislikes) {\\n    if (dislikes.length <= 1) {\\n      return true;\\n    }\\n    UnionFind uf = new UnionFind(N << 1);\\n    for (int[] dislike : dislikes) {\\n      uf.union(dislike[0], dislike[1] + N);\\n      uf.union(dislike[1], dislike[0] + N);\\n    }\\n    for (int i = 1; i <= N; i++) {\\n      if (uf.find(i) == uf.find(i + N)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  private static class UnionFind {\\n\\n    int[] parent;\\n    int[] size;\\n    int count;\\n\\n    public UnionFind(int n) {\\n      parent = new int[n + 1];\\n      size = new int[n + 1];\\n      for (int i = 0; i <= n; i++) {\\n        parent[i] = i;\\n        size[i] = 1;\\n      }\\n      this.count = n;\\n    }\\n\\n    public int find(int i) {\\n      if (i != parent[i]) {\\n        parent[i] = find(parent[i]);\\n      }\\n      return parent[i];\\n    }\\n\\n    public void union(int p, int q) {\\n      int i = find(p);\\n      int j = find(q);\\n      if (size[i] > size[j]) {\\n        parent[j] = i;\\n        size[i] += size[j];\\n      } else {\\n        parent[i] = j;\\n        size[j] += size[i];\\n      }\\n      this.count--;\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655839,
                "title": "python-two-methods-1-coloring-2-union-find",
                "content": "Coloring problem\\n```py\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        graph = defaultdict(list)\\n        for u, v in dislikes:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        color = [0] * (N + 1)\\n        \\n        def valid(node, target):\\n            # The colored nodes, no matter 1 or -1, they and their children have been\\n            # verified before so that we just need to return whether this node is valid.\\n            if color[node] != 0:\\n                return True if color[node] == target else False\\n            color[node] = target\\n            for dislike in graph[node]:\\n                if not valid(dislike, target * -1):\\n                    return False\\n            return True\\n            \\n        for node in range(1, N + 1):\\n            # only consider the nodes that haven\\'t been colored(checked) before.\\n            # because the colored nodes already have their children also been checked during \\n            # the previous DFS\\n            if color[node] == 0 and not valid(node, 1):\\n                return False\\n        return True\\n```\\nUnion find\\n```py\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        dus = DisjointUnionSet(N)\\n        reject = defaultdict(list)\\n        for u, v in dislikes:\\n            reject[u].append(v)\\n            reject[v].append(u)\\n            \\n        for u, rivals in reject.items():\\n            if not rivals:\\n                continue\\n            for i, v in enumerate(rivals):\\n                if dus.find(u) == dus.find(v):\\n                    return False\\n                dus.merge(rivals[0], v)\\n        return True\\n                \\n        \\nclass DisjointUnionSet(object):\\n    def __init__(self, n):\\n        # parents/rank index from 1\\n        self.parents = range(n + 1)\\n        self.rank = [1] * (n + 1)\\n        \\n    def find(self, u):\\n        if u == self.parents[u]:\\n            return u\\n        self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n        \\n    def merge(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        ru, rv = self.rank[pu], self.rank[pv]\\n        if ru > rv:\\n            self.parents[pv] = pu\\n        elif ru < rv:\\n            self.parents[pu] = pv\\n        else:\\n            self.parents[pu] = pv\\n            self.rank[pv] += 1    \\n        return\\n```",
                "solutionTags": [],
                "code": "```py\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        graph = defaultdict(list)\\n        for u, v in dislikes:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        color = [0] * (N + 1)\\n        \\n        def valid(node, target):\\n            # The colored nodes, no matter 1 or -1, they and their children have been\\n            # verified before so that we just need to return whether this node is valid.\\n            if color[node] != 0:\\n                return True if color[node] == target else False\\n            color[node] = target\\n            for dislike in graph[node]:\\n                if not valid(dislike, target * -1):\\n                    return False\\n            return True\\n            \\n        for node in range(1, N + 1):\\n            # only consider the nodes that haven\\'t been colored(checked) before.\\n            # because the colored nodes already have their children also been checked during \\n            # the previous DFS\\n            if color[node] == 0 and not valid(node, 1):\\n                return False\\n        return True\\n```\n```py\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        dus = DisjointUnionSet(N)\\n        reject = defaultdict(list)\\n        for u, v in dislikes:\\n            reject[u].append(v)\\n            reject[v].append(u)\\n            \\n        for u, rivals in reject.items():\\n            if not rivals:\\n                continue\\n            for i, v in enumerate(rivals):\\n                if dus.find(u) == dus.find(v):\\n                    return False\\n                dus.merge(rivals[0], v)\\n        return True\\n                \\n        \\nclass DisjointUnionSet(object):\\n    def __init__(self, n):\\n        # parents/rank index from 1\\n        self.parents = range(n + 1)\\n        self.rank = [1] * (n + 1)\\n        \\n    def find(self, u):\\n        if u == self.parents[u]:\\n            return u\\n        self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n        \\n    def merge(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        ru, rv = self.rank[pu], self.rank[pv]\\n        if ru > rv:\\n            self.parents[pv] = pu\\n        elif ru < rv:\\n            self.parents[pu] = pv\\n        else:\\n            self.parents[pu] = pv\\n            self.rank[pv] += 1    \\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655384,
                "title": "javascript-straight-thinking-100ms",
                "content": "My idea is give every person a group number, where follow these step:\\n1. Prepare an array **map** for recording everyone\\'s group number. Since *1 <= **N**<= 2000*, I used an Uint16Array and initialized with a greater number which never be used. Also prepare a group number counter from 0.\\n\\n2. For all dislikes pair (**i**, **j**)\\n* **If both i & j are UNGROUPED**\\n Give them a new paired group number and rise the counter.\\n **ex:** Got first dislikes pair (1, 2), map[1] = 0 (means Group 0), map[2] = 1 (means Group 1), and counter goes to 2.\\n* **If i or j is GROUPED**\\n Give another one a paired group number.\\n **ex:** Next dislikes pair is (1,3), since map[1] already assigned as Group 0, so assign map[3] as a paired group, Group 1.\\n* **If both i & j are GROUPED**\\n We have 3 situations.\\n**(i) map[i] === map[j]**\\n  Unacceptable. ***Return false***.\\n  **ex:** Following next pair as (2, 3). Since both of them are Group 1, return false.\\n **(ii) They are alerady a pair**\\n  Nothing to do. ***Continue***.\\n**(iii) The others**\\n The concept is combining two group pairs together. **Move whole group pair to the the other\\'s opposite**.\\n **ex:**\\n***Paired Group A*** { Group 0 : **1**, 2  /  Group 1 : 3, 4 } with ***Paired Group B*** { Group 4 : **11**, 12 / Group 5 : 13, 14}\\n Now we got a dislikes pair (**1**, **11**), so **Group 4**\\'s members will join **Group 1** and **Group 5** goes to **Group 0**.\\n\\n3. After passing all tests, ***Return true***.\\n\\n```\\nvar possibleBipartition = function(N, dislikes) {\\n  const map = new Uint16Array(N+1).fill(2047);\\n  let counter = 0;\\n  const len = dislikes.length;\\n  for(let i = 0;i < len; i++){\\n    const A = map[dislikes[i][0]], B = map[dislikes[i][1]];\\n    const AP = A + (A % 2 ? -1 : 1), BP = B + (B % 2 ? -1 : 1);\\n    if(A===2047){\\n      if(B===2047){\\n        map[dislikes[i][0]] = counter++;\\n        map[dislikes[i][1]] = counter++;\\n      } else {\\n        map[dislikes[i][0]] = BP;\\n      }\\n    } else if(B===2047){\\n      map[dislikes[i][1]] = AP;\\n    } else{ \\n      if(A===B) return false;\\n      if(A===BP) continue;\\n      for(let j = 1; j<=N; j++){\\n        map[j] === B ? map[j] = AP :\\n        map[j] === BP ? map[j] = A :\\n        null;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar possibleBipartition = function(N, dislikes) {\\n  const map = new Uint16Array(N+1).fill(2047);\\n  let counter = 0;\\n  const len = dislikes.length;\\n  for(let i = 0;i < len; i++){\\n    const A = map[dislikes[i][0]], B = map[dislikes[i][1]];\\n    const AP = A + (A % 2 ? -1 : 1), BP = B + (B % 2 ? -1 : 1);\\n    if(A===2047){\\n      if(B===2047){\\n        map[dislikes[i][0]] = counter++;\\n        map[dislikes[i][1]] = counter++;\\n      } else {\\n        map[dislikes[i][0]] = BP;\\n      }\\n    } else if(B===2047){\\n      map[dislikes[i][1]] = AP;\\n    } else{ \\n      if(A===B) return false;\\n      if(A===BP) continue;\\n      for(let j = 1; j<=N; j++){\\n        map[j] === B ? map[j] = AP :\\n        map[j] === BP ? map[j] = A :\\n        null;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654808,
                "title": "java-clear-code-using-bipartite-graph-algorithm",
                "content": "Just model the dislikes like edges of undirected graph. We just need to check if graph is 2 colorable. Just do normal DFS and keep track of color being assigned to vertices. If anytime you find same color vertex then its not possible to have bipartite graph.\\n\\nIn below code, I keep track of color to be assigned to current vertex. And as I move to other adjacent vertices, I will try to assign opposite color to them. If I find same color already then its not possible to partition. Also color array is kind of visited array - if colour[u] is null that means it is not visited. This we can use in DFS to check for non visited vertex.\\n```\\nclass Solution {\\n    \\n    private static enum Colour {\\n        RED, BLUE;\\n    }\\n    \\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if (dislikes == null || dislikes.length == 0) return true;\\n        \\n        MyGraph g = new MyGraph(N+1);\\n        for (int[] d : dislikes) {\\n            g.addEdge(d[0], d[1]);\\n        }\\n        Colour[] colours = new Colour[N+1];\\n        for (int u = 1; u <= N; u++) {\\n            if (colours[u] == null) {\\n                if (!isBipartite(g, u, colours, Colour.RED))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    private static class MyGraph {\\n        int V;\\n        List<Integer>[] adj;\\n        public MyGraph(int V) {\\n            this.V = V;\\n            this.adj = (List<Integer>[])new ArrayList[V];\\n            for (int u = 0; u < V; u++) {\\n                adj[u] = new ArrayList<>();\\n            }\\n        }\\n        public void addEdge(int u, int v) {\\n            this.adj[u].add(v);\\n            this.adj[v].add(u);\\n        }\\n        \\n    }\\n    \\n    public boolean isBipartite(MyGraph g, int u, Colour[] colours, Colour colour) {\\n        colours[u] = colour;\\n        Colour nextColour = (colour == Colour.RED) ? Colour.BLUE : Colour.RED;\\n        for (int v : g.adj[u]) {\\n            if (colours[v] == null) {\\n                if (!isBipartite(g, v, colours, nextColour))\\n                    return false;\\n            }\\n            else if (colours[v] == colour)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static enum Colour {\\n        RED, BLUE;\\n    }\\n    \\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if (dislikes == null || dislikes.length == 0) return true;\\n        \\n        MyGraph g = new MyGraph(N+1);\\n        for (int[] d : dislikes) {\\n            g.addEdge(d[0], d[1]);\\n        }\\n        Colour[] colours = new Colour[N+1];\\n        for (int u = 1; u <= N; u++) {\\n            if (colours[u] == null) {\\n                if (!isBipartite(g, u, colours, Colour.RED))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    private static class MyGraph {\\n        int V;\\n        List<Integer>[] adj;\\n        public MyGraph(int V) {\\n            this.V = V;\\n            this.adj = (List<Integer>[])new ArrayList[V];\\n            for (int u = 0; u < V; u++) {\\n                adj[u] = new ArrayList<>();\\n            }\\n        }\\n        public void addEdge(int u, int v) {\\n            this.adj[u].add(v);\\n            this.adj[v].add(u);\\n        }\\n        \\n    }\\n    \\n    public boolean isBipartite(MyGraph g, int u, Colour[] colours, Colour colour) {\\n        colours[u] = colour;\\n        Colour nextColour = (colour == Colour.RED) ? Colour.BLUE : Colour.RED;\\n        for (int v : g.adj[u]) {\\n            if (colours[v] == null) {\\n                if (!isBipartite(g, v, colours, nextColour))\\n                    return false;\\n            }\\n            else if (colours[v] == colour)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633713,
                "title": "c-bipartite-bfs-graph-coloring-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>>graph(N+1);\\n        \\n        int n = dislikes.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[dislikes[i][0]].push_back(dislikes[i][1]);\\n            graph[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        \\n        vector<int>color(N+1, -1);\\n        \\n        for (int i = 1; i <= N; i++) {\\n            if (color[i] != -1)\\n                continue;\\n            \\n            queue<int>q;\\n            q.push(i);\\n            color[i] = 1;\\n            \\n            while (!q.empty()) {\\n                int t = q.front();\\n                q.pop();\\n                for (int j = 0; j < graph[t].size(); j++) {\\n                    if (color[graph[t][j]] == -1) {\\n                        color[graph[t][j]] = 1-color[t];\\n                        q.push(graph[t][j]);\\n                    } else if (color[graph[t][j]] == color[t]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>>graph(N+1);\\n        \\n        int n = dislikes.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            graph[dislikes[i][0]].push_back(dislikes[i][1]);\\n            graph[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        \\n        vector<int>color(N+1, -1);\\n        \\n        for (int i = 1; i <= N; i++) {\\n            if (color[i] != -1)\\n                continue;\\n            \\n            queue<int>q;\\n            q.push(i);\\n            color[i] = 1;\\n            \\n            while (!q.empty()) {\\n                int t = q.front();\\n                q.pop();\\n                for (int j = 0; j < graph[t].size(); j++) {\\n                    if (color[graph[t][j]] == -1) {\\n                        color[graph[t][j]] = 1-color[t];\\n                        q.push(graph[t][j]);\\n                    } else if (color[graph[t][j]] == color[t]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934084,
                "title": "dfs-bfs-cpp",
                "content": "## Two Ways:\\n    1. DFS\\n    2. BFS\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. ### DFS\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        vector<int>color(n+1,-1);\\n        for(int i = 0; i < dislikes.size(); ++i){\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        for(int i = 1; i <= n; ++i){\\n            if(color[i] == -1){\\n                if(!bipartiteDfs(i,adj,color)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool bipartiteDfs(int node,vector<int>adj[],vector<int>& color){\\n        \\n        for(auto& edges: adj[node]){\\n            if(color[edges] == -1){\\n                color[edges] = 1 - color[node];\\n                if(!bipartiteDfs(edges,adj,color)) return false;\\n            }\\n            else if(color[edges] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n2. ### BFS\\n\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        vector<int>color(n+1,-1);\\n        for(int i = 0; i < dislikes.size(); ++i){\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        for(int i = 1; i <= n; ++i){\\n            if(color[i] == -1){\\n                if(!bipartiteBfs(i,adj,color)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool bipartiteBfs(int i,vector<int>adj[],vector<int>& color){\\n        queue<int>q;\\n        q.push(i);\\n        color[i] = 1;\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto &it:adj[node]){\\n                if(color[it] == -1){\\n                    color[it] = 1-color[node];\\n                    q.push(it);\\n                }\\n                else if(color[it] == color[node]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        vector<int>color(n+1,-1);\\n        for(int i = 0; i < dislikes.size(); ++i){\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        for(int i = 1; i <= n; ++i){\\n            if(color[i] == -1){\\n                if(!bipartiteDfs(i,adj,color)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool bipartiteDfs(int node,vector<int>adj[],vector<int>& color){\\n        \\n        for(auto& edges: adj[node]){\\n            if(color[edges] == -1){\\n                color[edges] = 1 - color[node];\\n                if(!bipartiteDfs(edges,adj,color)) return false;\\n            }\\n            else if(color[edges] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        vector<int>color(n+1,-1);\\n        for(int i = 0; i < dislikes.size(); ++i){\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        for(int i = 1; i <= n; ++i){\\n            if(color[i] == -1){\\n                if(!bipartiteBfs(i,adj,color)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool bipartiteBfs(int i,vector<int>adj[],vector<int>& color){\\n        queue<int>q;\\n        q.push(i);\\n        color[i] = 1;\\n\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto &it:adj[node]){\\n                if(color[it] == -1){\\n                    color[it] = 1-color[node];\\n                    q.push(it);\\n                }\\n                else if(color[it] == color[node]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041364,
                "title": "c-easy-intuitive-dfs-bfs-approach-solutions-with-time-complexity",
                "content": "***Intuition is to use bipartite graph & Graph coloring to check if it is possible to split everyone into two groups or not .\\nWe can use adjacency matrix but that will cost us TC : O(n^2)\\nAdjacency List can be used to optimised the code in O(n+E)***\\n***Both DFS and BFS can be used here.***\\n\\n\\n**1. DFS**\\n```\\nclass Solution {\\n    // standard dfs\\n     bool dfs( vector<vector<int>> &adj,vector<int> &color,int node)\\n    {\\n        if(color[node]==-1)\\n            color[node]=1;\\n        \\n        for(auto i:adj[node])\\n        {\\n            if(color[i]==-1)\\n            { \\n                color[i]=1-color[node]; // color the i with different color than node\\n                // call dfs\\n                if(!dfs(adj,color,i))\\n                   return 0;\\n            }\\n            else if(color[i]==color[node])  // color of two adjacent elements are same\\n                return 0;                   \\n        }\\n        return 1;\\n    }\\n    \\npublic:\\n   bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adj(n+1);  // adj list\\n        vector<int> color(n+1,-1);     // color array ****        \\n        \\n        // making the adjacency list for undirected graph\\n        for(auto i:dislikes)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n                if(!dfs(adj,color,i))\\n                   return 0;\\n        }\\n        return true;\\n    }       \\n};\\nTIme Complexity: O(n+2E)\\n```\\n\\n**2. BFS**\\n```\\nclass Solution {\\n    // standard bfs\\n     bool bfs( vector<vector<int>> &adj,vector<int> &color,int node)\\n    {\\n        queue<int> q;\\n        q.push(node);\\n        color[node]=1;\\n        \\n        while(!q.empty())\\n        {\\n            int parent=q.front();\\n            q.pop();\\n            \\n            for(auto i:adj[parent])\\n            {\\n                if(color[i]==color[parent])\\n                    return false;\\n                \\n                if(color[i]==-1)\\n                {\\n                    q.push(i);\\n                    color[i]=1-color[parent];\\n                }              \\n            }            \\n        }\\n        return 1;  \\n    }\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adj(n+1);  // adj list\\n        vector<int> color(n+1,-1);     // color array \\n        \\n        \\n        // making the adjacency list for undirected graph\\n        for(auto i:dislikes)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n                if(!bfs(adj,color,i))\\n                   return 0;\\n        }\\n        return true;\\n    }       \\n};\\nTIme Complexity: O(n+2E)\\n```\\n\\n### DO UPVOTE IF U FIND IT HELPFUL :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    // standard dfs\\n     bool dfs( vector<vector<int>> &adj,vector<int> &color,int node)\\n    {\\n        if(color[node]==-1)\\n            color[node]=1;\\n        \\n        for(auto i:adj[node])\\n        {\\n            if(color[i]==-1)\\n            { \\n                color[i]=1-color[node]; // color the i with different color than node\\n                // call dfs\\n                if(!dfs(adj,color,i))\\n                   return 0;\\n            }\\n            else if(color[i]==color[node])  // color of two adjacent elements are same\\n                return 0;                   \\n        }\\n        return 1;\\n    }\\n    \\npublic:\\n   bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adj(n+1);  // adj list\\n        vector<int> color(n+1,-1);     // color array ****        \\n        \\n        // making the adjacency list for undirected graph\\n        for(auto i:dislikes)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n                if(!dfs(adj,color,i))\\n                   return 0;\\n        }\\n        return true;\\n    }       \\n};\\nTIme Complexity: O(n+2E)\\n```\n```\\nclass Solution {\\n    // standard bfs\\n     bool bfs( vector<vector<int>> &adj,vector<int> &color,int node)\\n    {\\n        queue<int> q;\\n        q.push(node);\\n        color[node]=1;\\n        \\n        while(!q.empty())\\n        {\\n            int parent=q.front();\\n            q.pop();\\n            \\n            for(auto i:adj[parent])\\n            {\\n                if(color[i]==color[parent])\\n                    return false;\\n                \\n                if(color[i]==-1)\\n                {\\n                    q.push(i);\\n                    color[i]=1-color[parent];\\n                }              \\n            }            \\n        }\\n        return 1;  \\n    }\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adj(n+1);  // adj list\\n        vector<int> color(n+1,-1);     // color array \\n        \\n        \\n        // making the adjacency list for undirected graph\\n        for(auto i:dislikes)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n                if(!bfs(adj,color,i))\\n                   return 0;\\n        }\\n        return true;\\n    }       \\n};\\nTIme Complexity: O(n+2E)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643964,
                "title": "c-concise-union-find",
                "content": "(Dec24, 2021)\\nReference solution to similar problem [Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/discuss/1065302/3-Solutions-or-BFS-or-DFS-or-DSU-(Union-Find)-or-Graph-Coloring)\\nHmm, this solution is not the most optimal, but it is nice still. There must be a way to get rid of the adjacency list...\\n```\\nvector <int> f;\\nint find(int x) {\\n    if (f[x] != x)\\n        f[x] = find(f[x]);\\n    return f[x];\\n}\\nvoid unify(int x, int y) {\\n    x = find(x);\\n    y = find(y);\\n    f[x] = y;\\n}\\nbool possibleBipartition(int n, vector<vector<int>>& a) {\\n    f.resize(n + 1);\\n    iota(f.begin(), f.end(), 0);\\n    vector <vector <int>> m(n + 1);\\n    for (auto &z : a) {\\n        m[z[0]].push_back(z[1]);\\n        m[z[1]].push_back(z[0]);\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < m[i].size(); j++) {\\n            if (find(i) == find(m[i][j]))\\n                return false;\\n            unify(m[i][0], m[i][j]);\\n        }\\n    }\\n    return true;\\n}\\n```\\n\\nAha, so I really liked the solution by [this](https://leetcode.com/problems/possible-bipartition/discuss/173898/Java-Union-Find-Solution) guy, but it wasn\\'t a complete UF as he wasn\\'t compressing the paths. So modified it a bit and now it is amazing!\\n```\\nclass Solution {\\npublic:\\n    vector <int> f, p;\\n    pair <int, int> find(int x) {\\n        int pa = 0;\\n        while (x != f[x]) {\\n            p[x] ^= p[f[x]];\\n            pa ^= p[x];\\n            f[x] = f[f[x]];\\n            x = f[x];\\n        }\\n        return {x, pa};\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& a) {\\n        f.resize(n);\\n        p.resize(n, 0);\\n        iota(f.begin(), f.end(), 0);\\n        for (int i = 0; i < a.size(); i++) {\\n            int x = a[i][0] - 1, y = a[i][1] - 1;\\n            if (f[y] == y) { f[y] = x; p[y] = 1; }\\n            else {\\n                auto [xx, px] = find(x);\\n                auto [yy, py] = find(y);\\n                if (xx == yy && px == py) \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nOr the same but more consice.\\n```\\nvector <int> f, p;\\nint find(int x) {\\n    if (f[x] != x) {\\n        int next = find(f[x]);\\n        p[x] ^= p[f[x]];\\n        f[x] = next;\\n    }\\n    return f[x];\\n}\\nbool possibleBipartition(int n, vector<vector<int>>& a) {\\n    f.resize(n + 1);\\n    p.resize(n + 1, 0);\\n    iota(f.begin(), f.end(), 0);\\n    for (auto &z : a) {\\n        int x = z[0], y = z[1];\\n        if (f[y] == y) { f[y] = x; p[y] = 1; }\\n        else if (find(x) == find(y) && p[x] == p[y]) \\n            return false;\\n    }\\n    return true;\\n}\\n```\\nLet me know if something isn\\'t clear.\\n\\n(Jan15, 2022) There is a nice solution with explanation that I want to add here written by [this guy](https://leetcode.com/problems/possible-bipartition/discuss/1650805/C%2B%2B-Union-Find-with-%22complement-nodes%22-100). Yeah, just wanted to add this solution as I really like it!\\n\\n```\\nvector <int> f;\\nint find(int x) {\\n    if (f[x] != x) \\n        f[x] = find(f[x]);\\n    return f[x];\\n}\\nvoid unify(int x, int y) {\\n    x = find(x);\\n    y = find(y);\\n    f[x] = y;\\n}\\nbool possibleBipartition(int n, vector<vector<int>>& a) {\\n    f.resize(n * 2 + 1);\\n    iota(f.begin(), f.end(), 0);\\n    for (auto z : a) {\\n        int x = z[0], y = z[1];\\n        unify(x, y + n);\\n        unify(y, x + n);\\n        if (find(x) == find(y)) return false;\\n    }\\n    return true;\\n}\\n```\\nThe nodes that dislike the nodes that we dislike (NDND).\\n\\nThe nutshell of the idea above is that we cannot connect to nodes that we dislike, but we can connect to NDND. The only problem is that we don\\'t know NDND beforehand, so to trick the system we create complementary nodes that are already NDND and connect to them without any shame.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector <int> f;\\nint find(int x) {\\n    if (f[x] != x)\\n        f[x] = find(f[x]);\\n    return f[x];\\n}\\nvoid unify(int x, int y) {\\n    x = find(x);\\n    y = find(y);\\n    f[x] = y;\\n}\\nbool possibleBipartition(int n, vector<vector<int>>& a) {\\n    f.resize(n + 1);\\n    iota(f.begin(), f.end(), 0);\\n    vector <vector <int>> m(n + 1);\\n    for (auto &z : a) {\\n        m[z[0]].push_back(z[1]);\\n        m[z[1]].push_back(z[0]);\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < m[i].size(); j++) {\\n            if (find(i) == find(m[i][j]))\\n                return false;\\n            unify(m[i][0], m[i][j]);\\n        }\\n    }\\n    return true;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector <int> f, p;\\n    pair <int, int> find(int x) {\\n        int pa = 0;\\n        while (x != f[x]) {\\n            p[x] ^= p[f[x]];\\n            pa ^= p[x];\\n            f[x] = f[f[x]];\\n            x = f[x];\\n        }\\n        return {x, pa};\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& a) {\\n        f.resize(n);\\n        p.resize(n, 0);\\n        iota(f.begin(), f.end(), 0);\\n        for (int i = 0; i < a.size(); i++) {\\n            int x = a[i][0] - 1, y = a[i][1] - 1;\\n            if (f[y] == y) { f[y] = x; p[y] = 1; }\\n            else {\\n                auto [xx, px] = find(x);\\n                auto [yy, py] = find(y);\\n                if (xx == yy && px == py) \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nvector <int> f, p;\\nint find(int x) {\\n    if (f[x] != x) {\\n        int next = find(f[x]);\\n        p[x] ^= p[f[x]];\\n        f[x] = next;\\n    }\\n    return f[x];\\n}\\nbool possibleBipartition(int n, vector<vector<int>>& a) {\\n    f.resize(n + 1);\\n    p.resize(n + 1, 0);\\n    iota(f.begin(), f.end(), 0);\\n    for (auto &z : a) {\\n        int x = z[0], y = z[1];\\n        if (f[y] == y) { f[y] = x; p[y] = 1; }\\n        else if (find(x) == find(y) && p[x] == p[y]) \\n            return false;\\n    }\\n    return true;\\n}\\n```\n```\\nvector <int> f;\\nint find(int x) {\\n    if (f[x] != x) \\n        f[x] = find(f[x]);\\n    return f[x];\\n}\\nvoid unify(int x, int y) {\\n    x = find(x);\\n    y = find(y);\\n    f[x] = y;\\n}\\nbool possibleBipartition(int n, vector<vector<int>>& a) {\\n    f.resize(n * 2 + 1);\\n    iota(f.begin(), f.end(), 0);\\n    for (auto z : a) {\\n        int x = z[0], y = z[1];\\n        unify(x, y + n);\\n        unify(y, x + n);\\n        if (find(x) == find(y)) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416469,
                "title": "python-clean-and-simple-bfs-solution",
                "content": "\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        if not dislikes:\\n            return True\\n        queue,visited = deque(),{}\\n        graph = defaultdict(set)\\n        for f,t in dislikes: \\n            graph[f].add(t)\\n            graph[t].add(f)\\n            \\n        for i in range(1,n+1):\\n            if i not in visited:\\n                queue.append(i)\\n                visited[i] = 0 if i-1 in visited and visited[i-1]==1 else 1 \\n            while queue:\\n                curr = queue.popleft()\\n                for nbr in graph[curr]:\\n                    if nbr not in visited:\\n                        queue.append(nbr)\\n                        visited[nbr] = 1 if visited[curr]==0 else 0\\n                    else:\\n                        if visited[nbr] == visited[curr]:\\n                            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        if not dislikes:\\n            return True\\n        queue,visited = deque(),{}\\n        graph = defaultdict(set)\\n        for f,t in dislikes: \\n            graph[f].add(t)\\n            graph[t].add(f)\\n            \\n        for i in range(1,n+1):\\n            if i not in visited:\\n                queue.append(i)\\n                visited[i] = 0 if i-1 in visited and visited[i-1]==1 else 1 \\n            while queue:\\n                curr = queue.popleft()\\n                for nbr in graph[curr]:\\n                    if nbr not in visited:\\n                        queue.append(nbr)\\n                        visited[nbr] = 1 if visited[curr]==0 else 0\\n                    else:\\n                        if visited[nbr] == visited[curr]:\\n                            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657085,
                "title": "c-dfs-bfs-simple-understanding-bonus-union-find",
                "content": "*DFS solution here we pass along the assigned color in `col` variable*\\n`col`\\n```\\n-1 => unvisited\\n0 => first bucket\\n1 => second bucket\\n````\\n\\n```\\n bool dfs(vector<vector<int>> &adjL, int start, vector<int> &color, int col){\\n       \\n        color[start] = col;\\n        \\n        for(int x: adjL[start]){\\n            if(color[x] == color[start]){\\n                return false;\\n            }\\n            if(color[x] == -1 && !dfs(adjL,x,color,1-col)){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adjL(N);\\n        \\n        vector<int> color(N,-1);        \\n        \\n        for(auto dislike: dislikes){\\n            adjL[dislike[0]-1].push_back(dislike[1]-1);\\n            adjL[dislike[1]-1].push_back(dislike[0]-1);\\n        }\\n        \\n        for(int i =0;i<N;++i){\\n            if(color[i] == -1 && !dfs(adjL,i,color,0)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\nWe can easily convert this solution to BFS:\\n```\\nbool bfs(vector<vector<int>> &adjL, int start, vector<int> &color){\\n           queue<int> q;        \\n           q.push(start);\\n           color[start] =1;\\n           while(!q.empty()){\\n               int node = q.front(); q.pop();\\n               for(int x: adjL[node]){\\n                   if(color[x] == -1){\\n                       q.push(x);\\n                       color[x] = 1 - color[node]; \\n                   } \\n                   else if(color[x] == color[node]){\\n                           return false;\\n                    }\\n                   }\\n               }\\n           return true;\\n    }\\n    \\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adjL(N);\\n        \\n        vector<int> color(N,-1);        \\n        \\n        for(auto dislike: dislikes){\\n            adjL[dislike[0]-1].push_back(dislike[1]-1);\\n            adjL[dislike[1]-1].push_back(dislike[0]-1);\\n        }\\n        \\n        for(int i =0;i<N;++i){\\n            if(color[i] == -1 && !bfs(adjL,i,color)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n```\\n\\nUnion find\\n\\n```\\n    int find( vector<int> &parents, int i ) {\\n        if( i != parents[i] )\\n            i = parents[i];\\n        return i;\\n    }\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> parents(N);\\n        for( int i=0; i < N; i++ )\\n            parents[i] = i;\\n        \\n        unordered_map<int, vector<int>> adjList;\\n        for( auto dislike : dislikes ) {\\n            adjList[ dislike[0] - 1 ].push_back( dislike[1] - 1 );\\n            adjList[ dislike[1] - 1 ].push_back( dislike[0] - 1 );\\n        }\\n        \\n        for( auto adj : adjList ) {\\n            int root1 = find( parents, adj.first );\\n            for( auto nbr : adj.second ) {\\n                int root2 = find( parents, nbr );\\n                if( root1 == root2 )\\n                    return false;\\n                else\\n                    parents[root2] = adj.second[0];\\n            }\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\n-1 => unvisited\\n0 => first bucket\\n1 => second bucket\\n```\n```\\n bool dfs(vector<vector<int>> &adjL, int start, vector<int> &color, int col){\\n       \\n        color[start] = col;\\n        \\n        for(int x: adjL[start]){\\n            if(color[x] == color[start]){\\n                return false;\\n            }\\n            if(color[x] == -1 && !dfs(adjL,x,color,1-col)){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adjL(N);\\n        \\n        vector<int> color(N,-1);        \\n        \\n        for(auto dislike: dislikes){\\n            adjL[dislike[0]-1].push_back(dislike[1]-1);\\n            adjL[dislike[1]-1].push_back(dislike[0]-1);\\n        }\\n        \\n        for(int i =0;i<N;++i){\\n            if(color[i] == -1 && !dfs(adjL,i,color,0)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\nbool bfs(vector<vector<int>> &adjL, int start, vector<int> &color){\\n           queue<int> q;        \\n           q.push(start);\\n           color[start] =1;\\n           while(!q.empty()){\\n               int node = q.front(); q.pop();\\n               for(int x: adjL[node]){\\n                   if(color[x] == -1){\\n                       q.push(x);\\n                       color[x] = 1 - color[node]; \\n                   } \\n                   else if(color[x] == color[node]){\\n                           return false;\\n                    }\\n                   }\\n               }\\n           return true;\\n    }\\n    \\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        \\n        vector<vector<int>> adjL(N);\\n        \\n        vector<int> color(N,-1);        \\n        \\n        for(auto dislike: dislikes){\\n            adjL[dislike[0]-1].push_back(dislike[1]-1);\\n            adjL[dislike[1]-1].push_back(dislike[0]-1);\\n        }\\n        \\n        for(int i =0;i<N;++i){\\n            if(color[i] == -1 && !bfs(adjL,i,color)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n```\n```\\n    int find( vector<int> &parents, int i ) {\\n        if( i != parents[i] )\\n            i = parents[i];\\n        return i;\\n    }\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> parents(N);\\n        for( int i=0; i < N; i++ )\\n            parents[i] = i;\\n        \\n        unordered_map<int, vector<int>> adjList;\\n        for( auto dislike : dislikes ) {\\n            adjList[ dislike[0] - 1 ].push_back( dislike[1] - 1 );\\n            adjList[ dislike[1] - 1 ].push_back( dislike[0] - 1 );\\n        }\\n        \\n        for( auto adj : adjList ) {\\n            int root1 = find( parents, adj.first );\\n            for( auto nbr : adj.second ) {\\n                int root2 = find( parents, nbr );\\n                if( root1 == root2 )\\n                    return false;\\n                else\\n                    parents[root2] = adj.second[0];\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656353,
                "title": "c-using-union-find",
                "content": "```\\nclass Solution {\\n    int find( vector<int> &parents, int i ) {\\n        if( i != parents[i] )\\n            i = parents[i];\\n        return i;\\n    }\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> parents(N);\\n        for( int i=0; i < N; i++ )\\n            parents[i] = i;\\n        \\n        unordered_map<int, vector<int>> adjList;\\n        for( auto dislike : dislikes ) {\\n            adjList[ dislike[0] - 1 ].push_back( dislike[1] - 1 );\\n            adjList[ dislike[1] - 1 ].push_back( dislike[0] - 1 );\\n        }\\n        \\n        for( auto adj : adjList ) {\\n            int root1 = find( parents, adj.first );\\n            for( auto nbr : adj.second ) {\\n                int root2 = find( parents, nbr );\\n                if( root1 == root2 )\\n                    return false;\\n                else\\n                    parents[root2] = adj.second[0];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int find( vector<int> &parents, int i ) {\\n        if( i != parents[i] )\\n            i = parents[i];\\n        return i;\\n    }\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> parents(N);\\n        for( int i=0; i < N; i++ )\\n            parents[i] = i;\\n        \\n        unordered_map<int, vector<int>> adjList;\\n        for( auto dislike : dislikes ) {\\n            adjList[ dislike[0] - 1 ].push_back( dislike[1] - 1 );\\n            adjList[ dislike[1] - 1 ].push_back( dislike[0] - 1 );\\n        }\\n        \\n        for( auto adj : adjList ) {\\n            int root1 = find( parents, adj.first );\\n            for( auto nbr : adj.second ) {\\n                int root2 = find( parents, nbr );\\n                if( root1 == root2 )\\n                    return false;\\n                else\\n                    parents[root2] = adj.second[0];\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655184,
                "title": "c-union-find",
                "content": "Complexity:  O(n log* n  + m)\\nIt\\u2018s not  an optimized solution, but easy to work out when you\\'ve prepared an UnionFound class\\n```\\nclass UnionF {\\n\\tint *id,c,*sz;\\npublic:\\n\\tUnionF(int N) {\\n\\t\\tc=N;\\n\\t\\tid=new int[N];\\n\\t\\tsz=new int[N];\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tid[i]=i;\\n\\t\\t\\tsz[i]=1;\\n\\t\\t}\\n\\t}\\n\\t~UnionF() {\\n\\t\\tdelete[] id;\\n\\t\\tdelete[] sz;\\n\\t}\\n\\tvoid clear(int N) {\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tid[i]=i;\\n\\t\\t\\tsz[i]=1;\\n\\t\\t}\\n\\t\\tc=N;\\n\\t}\\n\\tinline int find(int p) {\\n\\t\\tint root=p;\\n\\t\\twhile(root!=id[root])root=id[root];\\n\\t\\twhile(p!=root) {\\n\\t\\t\\tint x=p;\\n\\t\\t\\tid[x]=root;\\n\\t\\t\\tp=id[p];\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n\\n\\tbool link(int p,int q) {\\n\\t\\tint pid=find(p);\\n\\t\\tint qid=find(q);\\n\\t\\tif(qid==pid) return false;\\n\\t\\tif(sz[pid]<sz[qid]) {\\n\\t\\t\\tid[pid]=qid;\\n\\t\\t\\tsz[qid]+=sz[pid];\\n\\t\\t} else {\\n\\t\\t\\tid[qid]=pid;\\n\\t\\t\\tsz[pid]+=sz[qid];\\n\\t\\t}\\n\\t\\t--c;\\n\\t\\treturn true;\\n\\t}\\n\\tint count() {\\n\\t\\treturn c;\\n\\t}\\n\\tbool connected(int p,int q) {\\n\\t\\treturn find(p)==find(q);\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        int m=dislikes.size();\\n        if(m<2) return true;\\n        UnionF uf(N*2+1);\\n        for(auto &E: dislikes){\\n            uf.link(E[0],E[1]+N);\\n            uf.link(E[1],E[0]+N);\\n        }\\n        for(int i=1;i<=N;++i){\\n            if(uf.find(i)==uf.find(i+N)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass UnionF {\\n\\tint *id,c,*sz;\\npublic:\\n\\tUnionF(int N) {\\n\\t\\tc=N;\\n\\t\\tid=new int[N];\\n\\t\\tsz=new int[N];\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tid[i]=i;\\n\\t\\t\\tsz[i]=1;\\n\\t\\t}\\n\\t}\\n\\t~UnionF() {\\n\\t\\tdelete[] id;\\n\\t\\tdelete[] sz;\\n\\t}\\n\\tvoid clear(int N) {\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tid[i]=i;\\n\\t\\t\\tsz[i]=1;\\n\\t\\t}\\n\\t\\tc=N;\\n\\t}\\n\\tinline int find(int p) {\\n\\t\\tint root=p;\\n\\t\\twhile(root!=id[root])root=id[root];\\n\\t\\twhile(p!=root) {\\n\\t\\t\\tint x=p;\\n\\t\\t\\tid[x]=root;\\n\\t\\t\\tp=id[p];\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n\\n\\tbool link(int p,int q) {\\n\\t\\tint pid=find(p);\\n\\t\\tint qid=find(q);\\n\\t\\tif(qid==pid) return false;\\n\\t\\tif(sz[pid]<sz[qid]) {\\n\\t\\t\\tid[pid]=qid;\\n\\t\\t\\tsz[qid]+=sz[pid];\\n\\t\\t} else {\\n\\t\\t\\tid[qid]=pid;\\n\\t\\t\\tsz[pid]+=sz[qid];\\n\\t\\t}\\n\\t\\t--c;\\n\\t\\treturn true;\\n\\t}\\n\\tint count() {\\n\\t\\treturn c;\\n\\t}\\n\\tbool connected(int p,int q) {\\n\\t\\treturn find(p)==find(q);\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        int m=dislikes.size();\\n        if(m<2) return true;\\n        UnionF uf(N*2+1);\\n        for(auto &E: dislikes){\\n            uf.link(E[0],E[1]+N);\\n            uf.link(E[1],E[0]+N);\\n        }\\n        for(int i=1;i<=N;++i){\\n            if(uf.find(i)==uf.find(i+N)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445660,
                "title": "java-bfs-solution",
                "content": "This problem is a classic Bipartite problem. We can do https://leetcode.com/problems/is-graph-bipartite/ first. The only difference is we need to construct our own graph here.\\n\\nTesting a graph for bipartiteness:\\n1. run BFS and adjacent vertices with different color\\n2. test whether 2 vertices connected by 1 edge has the same color\\n\\n\\n```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if (dislikes.length == 0) {\\n            return true;\\n        }\\n        \\n        HashMap<Integer, List<Integer>> edgeList = new HashMap<>(); \\n        //since using i to represent people i in dislikes[][] instead of i-1\\n        int[] color = new int[N + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        //construct edgelist\\n        for (int i = 1; i <= N; i++) {\\n            edgeList.put(i, new ArrayList<>());\\n        }\\n        for (int[] dislike: dislikes) {\\n            edgeList.get(dislike[0]).add(dislike[1]);\\n            edgeList.get(dislike[1]).add(dislike[0]);\\n        }\\n\\n        //since using i to represent people i in dislikes[][] instead of i-1\\n        for (int index = 1; index <= N; index++) {\\n            if (color[index] == 0) {\\n                q.add(index);\\n                color[index] = 1;\\n\\n                while (!q.isEmpty()) {\\n                    int size = q.size();\\n                    for (int i = 0; i < size; i++) {\\n                        int person = q.poll();\\n                        int nextColor = color[person] == 1 ? 2 : 1;\\n                        List<Integer> dislikePeople = edgeList.get(person);\\n                        for (int j = 0; j < dislikePeople.size(); j++) {\\n                            int dislikePerson = dislikePeople.get(j);\\n                            if (color[dislikePerson] == color[person]) {\\n                                return false;\\n                            }\\n                            if (color[dislikePerson] == 0) {\\n                                color[dislikePerson] = nextColor;\\n                                q.add(dislikePerson);\\n                            }\\n                        }\\n                    }\\n                }                \\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if (dislikes.length == 0) {\\n            return true;\\n        }\\n        \\n        HashMap<Integer, List<Integer>> edgeList = new HashMap<>(); \\n        //since using i to represent people i in dislikes[][] instead of i-1\\n        int[] color = new int[N + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        //construct edgelist\\n        for (int i = 1; i <= N; i++) {\\n            edgeList.put(i, new ArrayList<>());\\n        }\\n        for (int[] dislike: dislikes) {\\n            edgeList.get(dislike[0]).add(dislike[1]);\\n            edgeList.get(dislike[1]).add(dislike[0]);\\n        }\\n\\n        //since using i to represent people i in dislikes[][] instead of i-1\\n        for (int index = 1; index <= N; index++) {\\n            if (color[index] == 0) {\\n                q.add(index);\\n                color[index] = 1;\\n\\n                while (!q.isEmpty()) {\\n                    int size = q.size();\\n                    for (int i = 0; i < size; i++) {\\n                        int person = q.poll();\\n                        int nextColor = color[person] == 1 ? 2 : 1;\\n                        List<Integer> dislikePeople = edgeList.get(person);\\n                        for (int j = 0; j < dislikePeople.size(); j++) {\\n                            int dislikePerson = dislikePeople.get(j);\\n                            if (color[dislikePerson] == color[person]) {\\n                                return false;\\n                            }\\n                            if (color[dislikePerson] == 0) {\\n                                color[dislikePerson] = nextColor;\\n                                q.add(dislikePerson);\\n                            }\\n                        }\\n                    }\\n                }                \\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167151,
                "title": "c-neat",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> g;\\n    vector<int> color;\\n    \\n    bool colorNode(int u, int c) {\\n        if (color[u] == c)\\n            return true;\\n        if (color[u] != -1)\\n            return false;\\n        color[u] = c;\\n        \\n        for (auto v : g[u]) {\\n            if (colorNode(v, c == 0 ? 1 : 0) == false)\\n                return false;\\n        }\\n        return true;\\n    } \\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        g = vector<vector<int>>(N+1);\\n        color = vector<int>(N+1, -1);\\n        \\n        for(auto e : dislikes) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        for (int v = 1; v < N+1; ++v) {\\n            if (color[v] == -1 && !colorNode(v, 0))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> g;\\n    vector<int> color;\\n    \\n    bool colorNode(int u, int c) {\\n        if (color[u] == c)\\n            return true;\\n        if (color[u] != -1)\\n            return false;\\n        color[u] = c;\\n        \\n        for (auto v : g[u]) {\\n            if (colorNode(v, c == 0 ? 1 : 0) == false)\\n                return false;\\n        }\\n        return true;\\n    } \\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        g = vector<vector<int>>(N+1);\\n        color = vector<int>(N+1, -1);\\n        \\n        for(auto e : dislikes) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        for (int v = 1; v < N+1; ++v) {\\n            if (color[v] == -1 && !colorNode(v, 0))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158993,
                "title": "java-bfs",
                "content": "\\tpublic boolean possibleBipartition(int N, int[][] dislikes) {\\n\\t\\tList<Integer>[] adjLists = new ArrayList[N];\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tadjLists[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tfor (int[] pair: dislikes) {\\n\\t\\t\\tadjLists[pair[0]-1].add(pair[1]-1);\\n\\t\\t\\tadjLists[pair[1]-1].add(pair[0]-1);\\n\\t\\t} \\n\\n\\t\\tint[] color = new int[N];\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tif (color[i] == 0 && !bfs(adjLists, i, color)) return false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n   // color: 0 not colored yet; 1: group1; 2: group2\\n```\\n    private boolean bfs(List<Integer>[] adjLists, int s, int[] color) {\\n        Queue<Integer> q = new LinkedList<>();\\n        color[s] = 1;\\n        q.offer(s);\\n        while (!q.isEmpty()) {\\n          Integer v = q.poll();\\n          for (Integer neighbor: adjLists[v]) {\\n            if (color[neighbor] == 0) {\\n              color[neighbor] = color[v] == 1 ? 2 : 1;\\n              q.offer(neighbor);\\n            } else if (color[v] == color[neighbor]) {\\n              return false;\\n            }\\n          }\\n        }\\n      return true;\\n      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private boolean bfs(List<Integer>[] adjLists, int s, int[] color) {\\n        Queue<Integer> q = new LinkedList<>();\\n        color[s] = 1;\\n        q.offer(s);\\n        while (!q.isEmpty()) {\\n          Integer v = q.poll();\\n          for (Integer neighbor: adjLists[v]) {\\n            if (color[neighbor] == 0) {\\n              color[neighbor] = color[v] == 1 ? 2 : 1;\\n              q.offer(neighbor);\\n            } else if (color[v] == color[neighbor]) {\\n              return false;\\n            }\\n          }\\n        }\\n      return true;\\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158965,
                "title": "graph-bipartite-problem-dfs",
                "content": "we treat each dislike like an edge in graph, so our goal is to find whether this graph is bipartite. So we can use paint algorithm, \\n-1: Haven\\'t color;\\n0:  group 0;\\n1:  group 1;\\n\\n\\t class Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] colors = new int[N + 1];\\n        Arrays.fill(colors, -1);\\n        int[][] graph = new int[N + 1][N + 1];\\n        \\n        for(int[] dislike : dislikes) {\\n            graph[dislike[0]][dislike[1]] = 1;\\n            graph[dislike[1]][dislike[0]] = 1;\\n        }\\n        for(int i = 1; i <= N; i++) {\\n            if(colors[i] == -1 && !isValid(graph, colors, 0, i)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isValid(int[][] graph, int[] colors, int color, int node) {\\n        if(colors[node] != -1) {\\n            return colors[node] == color;\\n        }\\n        \\n        colors[node] = color;\\n        \\n        for(int i = 1; i < graph[node].length; i++) {\\n            if(graph[node][i] == 1 && !isValid(graph, colors, 1 - color, i)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] colors = new int[N + 1];\\n        Arrays.fill(colors, -1);\\n        int[][] graph = new int[N + 1][N + 1];\\n        \\n        for(int[] dislike : dislikes) {\\n            graph[dislike[0]][dislike[1]] = 1;\\n            graph[dislike[1]][dislike[0]] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3687048,
                "title": "is-graph-biparties-or-not-c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int s,vector<vector<int>> &g,vector<int> &c,int x){\\n        if(c[s] != -1 && c[s]!=x)return 0;\\n        if(c[s]!=-1&&c[s]==x)return 1;\\n        bool a = true;\\n        c[s] = x;\\n        for(auto &i: g[s]){\\n            a &= solve(i,g,c,1^x);\\n        }\\n        return a;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> g(n);\\n        for(auto &i: dislikes){\\n            g[i[0]-1].push_back(i[1]-1);\\n            g[i[1]-1].push_back(i[0]-1);\\n        }\\n        vector<int> c(n,-1);\\n        bool ans = true;\\n        for(int i = 0; i < n; i++){\\n            if(c[i]==-1){\\n                ans &= solve(i,g,c,0);\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int s,vector<vector<int>> &g,vector<int> &c,int x){\\n        if(c[s] != -1 && c[s]!=x)return 0;\\n        if(c[s]!=-1&&c[s]==x)return 1;\\n        bool a = true;\\n        c[s] = x;\\n        for(auto &i: g[s]){\\n            a &= solve(i,g,c,1^x);\\n        }\\n        return a;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> g(n);\\n        for(auto &i: dislikes){\\n            g[i[0]-1].push_back(i[1]-1);\\n            g[i[1]-1].push_back(i[0]-1);\\n        }\\n        vector<int> c(n,-1);\\n        bool ans = true;\\n        for(int i = 0; i < n; i++){\\n            if(c[i]==-1){\\n                ans &= solve(i,g,c,0);\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952880,
                "title": "iterative-dfs-beats-99-in-runtime",
                "content": "# Complexity\\nLet $$E$$ be the size of dislikes and $$N$$ be the number of people.\\n\\n## Time complexity: $$O(E + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n## Space complexity: $$O(E + N)$$\\n- Graph (adjacentcy list) size can have $$O(N)$$ and $$O(E)$$\\n- The stack size used by dfs can have no more than $$N$$ elements in the worst-case scenario. It would take up $$O(N)$$ space in that case.\\n- Group dictionary can have no more than $$N$$ keys\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        # key: nodeNumber\\n        # value: array of neighbours\\n        graph: dict[int, List[int]] = dict()\\n        for d in dislikes:\\n            if d[0] not in graph:\\n                graph[d[0]] = []\\n            graph[d[0]].append(d[1])\\n        \\n        \\n        # key: node nodeNumber\\n        # value: group number (1 or -1)\\n        group = dict()\\n\\n        def dfs(group, node, initGroup):\\n            stack = [(node, initGroup)]\\n            while len(stack) > 0:\\n                curNode, curGroup = stack.pop()\\n                otherGroupNumber = curGroup * -1\\n                if curNode not in group:\\n                    group[curNode] = curGroup\\n\\n                    neighbours = graph.get(curNode) or []\\n                    for neighbour in neighbours:\\n                        stack.append((neighbour, otherGroupNumber))\\n                else:\\n                    if group[curNode] == -1 * curGroup:\\n                        # print(\"false\", curNode, curGroup, group)\\n                        return False\\n            \\n            return True\\n\\n        for node in range(1, n + 1):\\n            if node not in group:\\n                valid = dfs(group, node, node)\\n                if not valid:\\n                    # print(group)\\n                    return False\\n\\n\\n        # print(group)\\n        return True\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        # key: nodeNumber\\n        # value: array of neighbours\\n        graph: dict[int, List[int]] = dict()\\n        for d in dislikes:\\n            if d[0] not in graph:\\n                graph[d[0]] = []\\n            graph[d[0]].append(d[1])\\n        \\n        \\n        # key: node nodeNumber\\n        # value: group number (1 or -1)\\n        group = dict()\\n\\n        def dfs(group, node, initGroup):\\n            stack = [(node, initGroup)]\\n            while len(stack) > 0:\\n                curNode, curGroup = stack.pop()\\n                otherGroupNumber = curGroup * -1\\n                if curNode not in group:\\n                    group[curNode] = curGroup\\n\\n                    neighbours = graph.get(curNode) or []\\n                    for neighbour in neighbours:\\n                        stack.append((neighbour, otherGroupNumber))\\n                else:\\n                    if group[curNode] == -1 * curGroup:\\n                        # print(\"false\", curNode, curGroup, group)\\n                        return False\\n            \\n            return True\\n\\n        for node in range(1, n + 1):\\n            if node not in group:\\n                valid = dfs(group, node, node)\\n                if not valid:\\n                    # print(group)\\n                    return False\\n\\n\\n        # print(group)\\n        return True\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939359,
                "title": "simple-dfs-soln-bipartite-coloring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node,int col,vector<int> & Color,vector<int> adjLs[]){ \\n        Color[node] = col;\\n        for(auto it : adjLs[node]){\\n                if( Color[it] == -1){ // Not colored so unvisited so DFS is called for it\\n                   if( dfs(it,!col,Color,adjLs) == false) return false;\\n                }\\n                else if(Color[it]==col){ // Cannot have same color as the Adjacent node\\n                    return false;\\n                }\\n        }\\n       return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        //Initialise Color array\\n        vector<int> Color(n+1,-1);\\n        for(int i=0;i<=n;i++){\\n            Color[i] = -1;\\n        }\\n        //Converting into adjacency list\\n        vector<int> adjLs[n+1];\\n        for(auto it : dislikes ){\\n            adjLs[it[0]].push_back(it[1]);  \\n            adjLs[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n\\n               if(Color[i]==-1){ //Uncolored so call DFS               //1 | 2 |3 \\n                    if(dfs(i,0,Color,adjLs) == false ) return false; // 1-->{2,3}\\n               }\\n        }\\n         return true;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node,int col,vector<int> & Color,vector<int> adjLs[]){ \\n        Color[node] = col;\\n        for(auto it : adjLs[node]){\\n                if( Color[it] == -1){ // Not colored so unvisited so DFS is called for it\\n                   if( dfs(it,!col,Color,adjLs) == false) return false;\\n                }\\n                else if(Color[it]==col){ // Cannot have same color as the Adjacent node\\n                    return false;\\n                }\\n        }\\n       return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        //Initialise Color array\\n        vector<int> Color(n+1,-1);\\n        for(int i=0;i<=n;i++){\\n            Color[i] = -1;\\n        }\\n        //Converting into adjacency list\\n        vector<int> adjLs[n+1];\\n        for(auto it : dislikes ){\\n            adjLs[it[0]].push_back(it[1]);  \\n            adjLs[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n\\n               if(Color[i]==-1){ //Uncolored so call DFS               //1 | 2 |3 \\n                    if(dfs(i,0,Color,adjLs) == false ) return false; // 1-->{2,3}\\n               }\\n        }\\n         return true;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935204,
                "title": "java-2-solutions-bfs-map-arraylist-array",
                "content": "# Please Upvote :D\\nBoth the approaches are same but in the first we are using a hashmap to store the adjacency of each node in the graph while int the second we are using an array of arraylists.\\n\\n---\\n\\n##### 1. Using HashMap:\\n``` java []\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if (dislikes.length == 0) {\\n            return true;\\n        }\\n\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] e : dislikes) {\\n            if (!map.containsKey(e[0])) {\\n                map.put(e[0], new ArrayList<>());\\n            }\\n            if (!map.containsKey(e[1])) {\\n                map.put(e[1], new ArrayList<>());\\n            }\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n\\n        int[] color = new int[n + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (color[i] == 0) {\\n                q.add(i);\\n                color[i] = 1;\\n\\n                while (!q.isEmpty()) {\\n                    int curr = q.poll();\\n                    if (map.get(curr) == null) {\\n                        continue;\\n                    }\\n                    for (int v : map.get(curr)) {\\n                        if (color[v] == 0) {\\n                            color[v] = -color[curr];\\n                            q.add(v);\\n                        }\\n                        else if (color[v] == color[curr]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n + e), SC: O(n + e) + O(n) + O(n)\\n```\\n---\\n\\n##### 2. Using array of arraylists:\\n``` java []\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if (dislikes.length == 0) {\\n            return true;\\n        }\\n\\n        List<Integer>[] list = new List[n + 1];\\n        for (int[] d : dislikes) {\\n            if (list[d[0]] == null) {\\n                list[d[0]] = new ArrayList<>();\\n            }\\n            if (list[d[1]] == null) {\\n                list[d[1]] = new ArrayList<>();\\n            }\\n\\n            list[d[0]].add(d[1]);\\n            list[d[1]].add(d[0]);\\n        }\\n\\n        int[] color = new int[n + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (color[i] == 0) {\\n                q.add(i);\\n                color[i] = 1;\\n\\n                while (!q.isEmpty()) {\\n                    int curr = q.poll();\\n                    if (list[curr] == null) {\\n                        continue;\\n                    }\\n                    for (int v : list[curr]) {\\n                        if (color[v] == 0) {\\n                            color[v] = -color[curr];\\n                            q.add(v);\\n                        }\\n                        else if (color[v] == color[curr]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n + e), SC: O(n + e) + O(n) + O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if (dislikes.length == 0) {\\n            return true;\\n        }\\n\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int[] e : dislikes) {\\n            if (!map.containsKey(e[0])) {\\n                map.put(e[0], new ArrayList<>());\\n            }\\n            if (!map.containsKey(e[1])) {\\n                map.put(e[1], new ArrayList<>());\\n            }\\n            map.get(e[0]).add(e[1]);\\n            map.get(e[1]).add(e[0]);\\n        }\\n\\n        int[] color = new int[n + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (color[i] == 0) {\\n                q.add(i);\\n                color[i] = 1;\\n\\n                while (!q.isEmpty()) {\\n                    int curr = q.poll();\\n                    if (map.get(curr) == null) {\\n                        continue;\\n                    }\\n                    for (int v : map.get(curr)) {\\n                        if (color[v] == 0) {\\n                            color[v] = -color[curr];\\n                            q.add(v);\\n                        }\\n                        else if (color[v] == color[curr]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n + e), SC: O(n + e) + O(n) + O(n)\\n```\n``` java []\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if (dislikes.length == 0) {\\n            return true;\\n        }\\n\\n        List<Integer>[] list = new List[n + 1];\\n        for (int[] d : dislikes) {\\n            if (list[d[0]] == null) {\\n                list[d[0]] = new ArrayList<>();\\n            }\\n            if (list[d[1]] == null) {\\n                list[d[1]] = new ArrayList<>();\\n            }\\n\\n            list[d[0]].add(d[1]);\\n            list[d[1]].add(d[0]);\\n        }\\n\\n        int[] color = new int[n + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (color[i] == 0) {\\n                q.add(i);\\n                color[i] = 1;\\n\\n                while (!q.isEmpty()) {\\n                    int curr = q.poll();\\n                    if (list[curr] == null) {\\n                        continue;\\n                    }\\n                    for (int v : list[curr]) {\\n                        if (color[v] == 0) {\\n                            color[v] = -color[curr];\\n                            q.add(v);\\n                        }\\n                        else if (color[v] == color[curr]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n + e), SC: O(n + e) + O(n) + O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934798,
                "title": "c-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. First thought of using union find.\\n2. We can merge those dislikes the same person into the same group, and check whether they dislike each other afterward.\\n3. Quick example:  [a] dislike [c], [b] dislike [c] => [a & b] are in the group that dislike [c].\\nif afterwards we got [a] dislike [b], means need to split \"dislike c group\" into two, thus can\\'t make it total of two groups.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Put each into default group, and let (n + i) as group that dislike i.\\n2. Iterate throuth dislikes, join [a.i] to dislike [b.i] group and join [b.i]to dislike [a.i] group.\\n3. Check if any [a.i] and [b.i] dislke each other are in the same group.\\n\\n# Complexity\\nLet N is number of people, M is length of dislikes.\\n- Time complexity: O(N + M).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        ++n;\\n        vector<int> groups(2 * n);\\n        for (int i = 0; i < 2 * n; ++i) {\\n            groups[i] = i;\\n        }\\n        \\n        for (auto& dlk: dislikes) {\\n            if (unionFind(dlk[0], groups) == unionFind(dlk[1], groups)) return false;\\n            groups[unionFind(dlk[0], groups)] = unionFind(n + dlk[1], groups);\\n            groups[unionFind(dlk[1], groups)] = unionFind(n + dlk[0], groups);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int unionFind(int v, vector<int>& groups) {\\n        if (v != groups[v]) groups[v] = unionFind(groups[v], groups);\\n        return groups[v];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        ++n;\\n        vector<int> groups(2 * n);\\n        for (int i = 0; i < 2 * n; ++i) {\\n            groups[i] = i;\\n        }\\n        \\n        for (auto& dlk: dislikes) {\\n            if (unionFind(dlk[0], groups) == unionFind(dlk[1], groups)) return false;\\n            groups[unionFind(dlk[0], groups)] = unionFind(n + dlk[1], groups);\\n            groups[unionFind(dlk[1], groups)] = unionFind(n + dlk[0], groups);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int unionFind(int v, vector<int>& groups) {\\n        if (v != groups[v]) groups[v] = unionFind(groups[v], groups);\\n        return groups[v];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934111,
                "title": "js-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Beats 95.18%\\n\\n- Space complexity: 51.1 MB, Beats 93.98%\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} dislikes\\n * @return {boolean}\\n */\\nvar possibleBipartition = function(n, dislikes) {\\n    if (!dislikes.length) {\\n        return true;\\n    }\\n    const g1 = new Set();\\n    const g2 = new Set();\\n    g1.add(dislikes[0][0]);\\n    g2.add(dislikes[0][1]);\\n    dislikes = dislikes.slice(1);\\n    while (dislikes.length) {\\n        const q = [];\\n        \\n        for (const [a, b] of dislikes) {\\n            if (g1.has(a) || g2.has(b)) {\\n                if (g1.has(b) || g2.has(a)) {\\n                    return false;\\n                }\\n                g1.add(a);\\n                g2.add(b);\\n            } else if (g2.has(a) || g1.has(b)) {\\n                if (g1.has(a) || g2.has(b)) {\\n                    return false;\\n                }\\n                g1.add(b);\\n                g2.add(a);\\n            } else {\\n                q.push([a, b]);\\n            }\\n        }\\n        if (q.length === dislikes.length) {\\n            g1.add(dislikes[0][0]);\\n            g2.add(dislikes[0][1]);\\n            dislikes = dislikes.slice(1);\\n        } else {\\n            dislikes = q;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} dislikes\\n * @return {boolean}\\n */\\nvar possibleBipartition = function(n, dislikes) {\\n    if (!dislikes.length) {\\n        return true;\\n    }\\n    const g1 = new Set();\\n    const g2 = new Set();\\n    g1.add(dislikes[0][0]);\\n    g2.add(dislikes[0][1]);\\n    dislikes = dislikes.slice(1);\\n    while (dislikes.length) {\\n        const q = [];\\n        \\n        for (const [a, b] of dislikes) {\\n            if (g1.has(a) || g2.has(b)) {\\n                if (g1.has(b) || g2.has(a)) {\\n                    return false;\\n                }\\n                g1.add(a);\\n                g2.add(b);\\n            } else if (g2.has(a) || g1.has(b)) {\\n                if (g1.has(a) || g2.has(b)) {\\n                    return false;\\n                }\\n                g1.add(b);\\n                g2.add(a);\\n            } else {\\n                q.push([a, b]);\\n            }\\n        }\\n        if (q.length === dislikes.length) {\\n            g1.add(dislikes[0][0]);\\n            g2.add(dislikes[0][1]);\\n            dislikes = dislikes.slice(1);\\n        } else {\\n            dislikes = q;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2933948,
                "title": "go-minimalistic-bfs",
                "content": "```\\nfunc possibleBipartition(n int, dislikes [][]int) bool {\\n    edges := make([][]int, n + 1)\\n    for _, dislike := range dislikes {\\n        edges[dislike[0]] = append(edges[dislike[0]], dislike[1])\\n        edges[dislike[1]] = append(edges[dislike[1]], dislike[0])\\n    }\\n    colors := make([]int, n + 1)\\n    for i := 1; i <= n; i++ {\\n        if colors[i] == 0 && !bfs(i, edges, colors) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc bfs(start int, edges [][]int, colors []int) bool {\\n    colors[start] = 1\\n    for queue := []int{start}; len(queue) > 0; queue = queue[1:] {\\n        node := queue[0]\\n        for _, neighbor := range edges[node] {\\n            if colors[neighbor] == colors[node] {\\n                return false\\n            }\\n            if colors[neighbor] == 0 {\\n                colors[neighbor] = -colors[node]\\n                queue = append(queue, neighbor)\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc possibleBipartition(n int, dislikes [][]int) bool {\\n    edges := make([][]int, n + 1)\\n    for _, dislike := range dislikes {\\n        edges[dislike[0]] = append(edges[dislike[0]], dislike[1])\\n        edges[dislike[1]] = append(edges[dislike[1]], dislike[0])\\n    }\\n    colors := make([]int, n + 1)\\n    for i := 1; i <= n; i++ {\\n        if colors[i] == 0 && !bfs(i, edges, colors) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc bfs(start int, edges [][]int, colors []int) bool {\\n    colors[start] = 1\\n    for queue := []int{start}; len(queue) > 0; queue = queue[1:] {\\n        node := queue[0]\\n        for _, neighbor := range edges[node] {\\n            if colors[neighbor] == colors[node] {\\n                return false\\n            }\\n            if colors[neighbor] == 0 {\\n                colors[neighbor] = -colors[node]\\n                queue = append(queue, neighbor)\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2933887,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//DFS \\nclass Solution {\\npublic:\\n    bool isBipartite(int node,int color,vector<int>& isVisited,vector<int> adj[]){\\n        isVisited[node]=color;\\n        int adjColor=(color==1)?2:1;\\n        for(auto i:adj[node]){\\n            if(!isVisited[i]){\\n                if(isBipartite(i,adjColor,isVisited,adj)){\\n                    return true;\\n                }\\n            }\\n            else if(isVisited[i]==color){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> adj[n+1];\\n        for(auto i:dislikes){\\n            int u=i[0];\\n            int v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> isVisited(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            if(!isVisited[i]){\\n                if(isBipartite(i,1,isVisited,adj)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```\\n//BFS\\nclass Solution {\\npublic:\\n    bool isBipartite(int node,vector<int>& isVisited,vector<int> adj[]){\\n        isVisited[node]=1;\\n        queue<pair<int,int>> q;\\n        q.push({node,1});\\n        while(!q.empty()){\\n            auto front=q.front();\\n            int currNode=front.first;\\n            int color=front.second;\\n            int adjColor=(color==1)?2:1;\\n            q.pop();\\n            for(auto i:adj[currNode]){\\n                if(!isVisited[i]){\\n                    q.push({i,adjColor});\\n                    isVisited[i]=adjColor;\\n                }\\n                else if(isVisited[i]==color){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> adj[n+1];\\n        for(auto i:dislikes){\\n            int u=i[0];\\n            int v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> isVisited(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            if(!isVisited[i]){\\n                if(isBipartite(i,isVisited,adj)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n//DFS \\nclass Solution {\\npublic:\\n    bool isBipartite(int node,int color,vector<int>& isVisited,vector<int> adj[]){\\n        isVisited[node]=color;\\n        int adjColor=(color==1)?2:1;\\n        for(auto i:adj[node]){\\n            if(!isVisited[i]){\\n                if(isBipartite(i,adjColor,isVisited,adj)){\\n                    return true;\\n                }\\n            }\\n            else if(isVisited[i]==color){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> adj[n+1];\\n        for(auto i:dislikes){\\n            int u=i[0];\\n            int v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> isVisited(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            if(!isVisited[i]){\\n                if(isBipartite(i,1,isVisited,adj)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n//BFS\\nclass Solution {\\npublic:\\n    bool isBipartite(int node,vector<int>& isVisited,vector<int> adj[]){\\n        isVisited[node]=1;\\n        queue<pair<int,int>> q;\\n        q.push({node,1});\\n        while(!q.empty()){\\n            auto front=q.front();\\n            int currNode=front.first;\\n            int color=front.second;\\n            int adjColor=(color==1)?2:1;\\n            q.pop();\\n            for(auto i:adj[currNode]){\\n                if(!isVisited[i]){\\n                    q.push({i,adjColor});\\n                    isVisited[i]=adjColor;\\n                }\\n                else if(isVisited[i]==color){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> adj[n+1];\\n        for(auto i:dislikes){\\n            int u=i[0];\\n            int v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        vector<int> isVisited(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            if(!isVisited[i]){\\n                if(isBipartite(i,isVisited,adj)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904129,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> color(2005, -1);\\n        vector<int> g[2005];\\n        for(auto x: dislikes) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n\\t    for(int s=1; s<=n; s++) {\\n            if(color[s] == -1) {\\n                color[s] = 1;\\n                queue<int> q;\\n                q.push(s);\\n                while(!q.empty()) {\\n                    int u = q.front();\\n                    q.pop();\\n                    for(int v: g[u]) {\\n                        if(color[v] == -1) {\\n                            color[v] = color[u] ^ 1;\\n                            q.push(v);\\n                        }\\n                        else {\\n                            if(color[u] == color[v]) return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\t    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> color(2005, -1);\\n        vector<int> g[2005];\\n        for(auto x: dislikes) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n\\t    for(int s=1; s<=n; s++) {\\n            if(color[s] == -1) {\\n                color[s] = 1;\\n                queue<int> q;\\n                q.push(s);\\n                while(!q.empty()) {\\n                    int u = q.front();\\n                    q.pop();\\n                    for(int v: g[u]) {\\n                        if(color[v] == -1) {\\n                            color[v] = color[u] ^ 1;\\n                            q.push(v);\\n                        }\\n                        else {\\n                            if(color[u] == color[v]) return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\t    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368431,
                "title": "c-bfs-and-dfs-using-graph-coloring-clean-code",
                "content": "**BFS:** Faster than 97%\\n```\\nclass Solution {\\npublic:\\n    bool bfs(unordered_map<int,vector<int>>& adj,vector<int>& color,int src)\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        color[src]=0;\\n        \\n        while(!q.empty())\\n        {\\n            int front = q.front();\\n            q.pop();\\n            \\n            for(auto i: adj[front])\\n            {\\n                if(color[i]==-1)\\n                {\\n                    q.push(i);\\n                    color[i] = 1-color[front];\\n                }\\n                \\n                if(color[i]==color[front]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        unordered_map<int,vector<int>> adj;\\n        for(int i=0;i<dislikes.size();i++)\\n        {\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!bfs(adj,color,i)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**DFS:** Faster then 75%\\n```\\nclass Solution {\\npublic:\\n    bool dfs(unordered_map<int,vector<int>>& adj,vector<int>& color,int src,int parent)\\n    {\\n        if(parent==-2) color[src]=0;\\n        else color[src]=1-color[parent];\\n        \\n        for(auto i: adj[src])\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!dfs(adj,color,i,src)) return false;\\n            }\\n            \\n            if(color[i]!=-1 && color[i]==color[src])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        unordered_map<int,vector<int>> adj;\\n        for(int i=0;i<dislikes.size();i++)\\n        {\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!dfs(adj,color,i,-2)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(unordered_map<int,vector<int>>& adj,vector<int>& color,int src)\\n    {\\n        queue<int> q;\\n        q.push(src);\\n        color[src]=0;\\n        \\n        while(!q.empty())\\n        {\\n            int front = q.front();\\n            q.pop();\\n            \\n            for(auto i: adj[front])\\n            {\\n                if(color[i]==-1)\\n                {\\n                    q.push(i);\\n                    color[i] = 1-color[front];\\n                }\\n                \\n                if(color[i]==color[front]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        unordered_map<int,vector<int>> adj;\\n        for(int i=0;i<dislikes.size();i++)\\n        {\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!bfs(adj,color,i)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool dfs(unordered_map<int,vector<int>>& adj,vector<int>& color,int src,int parent)\\n    {\\n        if(parent==-2) color[src]=0;\\n        else color[src]=1-color[parent];\\n        \\n        for(auto i: adj[src])\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!dfs(adj,color,i,src)) return false;\\n            }\\n            \\n            if(color[i]!=-1 && color[i]==color[src])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        unordered_map<int,vector<int>> adj;\\n        for(int i=0;i<dislikes.size();i++)\\n        {\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!dfs(adj,color,i,-2)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597414,
                "title": "java-bfs-bipartition-graph-coloring-approach",
                "content": "**Do vote up if you like it :)**\\n\\n\\tMake the given dislike people as each others neighbour.\\n\\tNow it\\'s a simple graph coloring or graph bipartition problem.\\n\\nBFS\\n\\n```\\nclass Solution {\\n//     Not visited : -1\\n//     Red : 0, visited\\n//     Green : 1, visited\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        \\n        // graph ranges from [1 - n], so size will be n + 1, where graph[0] will be a waste \\n\\t\\t\\n\\t\\t// Graph creation\\n        ArrayList<Integer>[] graph = new ArrayList[n + 1];\\n        for(int i = 0; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] dislike : dislikes) {\\n            graph[dislike[1]].add(dislike[0]);\\n            graph[dislike[0]].add(dislike[1]);\\n        }\\n        \\n\\t\\t// Keeping visited and marked color in the  same array\\n        int[] visOrColor = new int[n + 1];\\n        Arrays.fill(visOrColor, -1); // Initially marking all nodes as unvisited \\n        \\n        for(int i = 1; i <= n; i++) {\\n            if(visOrColor[i] == -1 && !isComponentBipartite(i, visOrColor, graph)) {  //Check for all components\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public static boolean isComponentBipartite(int src, int[] visOrColor, ArrayList<Integer>[] graph) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(src);\\n        \\n        int color = 0; // Source node color will be Red\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int currVtx = queue.poll();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Already visited\\n                if(visOrColor[currVtx] != -1) { \\n                    if(visOrColor[currVtx] != color) { // Already visited with different color => Conflict => Odd edge cycle\\n                        return false; // That\\'s the end return \\n                    }\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Already visited with same color => No conflict => Even edge cycle => Further process your BFS   \\n                    // NOTE : The already visited nodes have already added it\\'s nbr so why to waste the below for loop check, so continue\\n\\t\\t\\t\\t\\tcontinue; // Don\\'t forget this line else it will increase the complexity\\n\\t\\t\\t\\t\\t\\n                }\\n                \\n                visOrColor[currVtx] = color; // Marking visited or assigned color\\n                for(int nbr : graph[currVtx]) { //Adding unvisited nbr\\'s in the queue\\n                    if(visOrColor[nbr] == -1) {\\n                        queue.add(nbr);\\n                    }\\n                }\\n            }\\n            color = (color + 1) % 2; // Toggling color to mark the next level nodes with different color\\n        }\\n        return true;\\n    }\\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n//     Not visited : -1\\n//     Red : 0, visited\\n//     Green : 1, visited\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        \\n        // graph ranges from [1 - n], so size will be n + 1, where graph[0] will be a waste \\n\\t\\t\\n\\t\\t// Graph creation\\n        ArrayList<Integer>[] graph = new ArrayList[n + 1];\\n        for(int i = 0; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] dislike : dislikes) {\\n            graph[dislike[1]].add(dislike[0]);\\n            graph[dislike[0]].add(dislike[1]);\\n        }\\n        \\n\\t\\t// Keeping visited and marked color in the  same array\\n        int[] visOrColor = new int[n + 1];\\n        Arrays.fill(visOrColor, -1); // Initially marking all nodes as unvisited \\n        \\n        for(int i = 1; i <= n; i++) {\\n            if(visOrColor[i] == -1 && !isComponentBipartite(i, visOrColor, graph)) {  //Check for all components\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public static boolean isComponentBipartite(int src, int[] visOrColor, ArrayList<Integer>[] graph) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(src);\\n        \\n        int color = 0; // Source node color will be Red\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int currVtx = queue.poll();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Already visited\\n                if(visOrColor[currVtx] != -1) { \\n                    if(visOrColor[currVtx] != color) { // Already visited with different color => Conflict => Odd edge cycle\\n                        return false; // That\\'s the end return \\n                    }\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Already visited with same color => No conflict => Even edge cycle => Further process your BFS   \\n                    // NOTE : The already visited nodes have already added it\\'s nbr so why to waste the below for loop check, so continue\\n\\t\\t\\t\\t\\tcontinue; // Don\\'t forget this line else it will increase the complexity\\n\\t\\t\\t\\t\\t\\n                }\\n                \\n                visOrColor[currVtx] = color; // Marking visited or assigned color\\n                for(int nbr : graph[currVtx]) { //Adding unvisited nbr\\'s in the queue\\n                    if(visOrColor[nbr] == -1) {\\n                        queue.add(nbr);\\n                    }\\n                }\\n            }\\n            color = (color + 1) % 2; // Toggling color to mark the next level nodes with different color\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121070,
                "title": "java-clear-dfs-solution-o-n-e",
                "content": "```\\n// DFS color and negative color confliction solution\\n// if color the neighbor with -color, if conflict, return false.\\n// Same idea with Leetcode 785. Is Graph Bipartite\\n// Time complexity: O(N+E)\\n// Space complexity: O(N+E)\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        // Ask whether dislikes could be null\\n        if (N <= 2) return true;\\n        List<Integer>[] adj = new ArrayList[N+1];\\n        for (int i = 1; i <= N; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : dislikes) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        int[] colors = new int[N+1];\\n        for (int i = 1; i <= N; i++) {\\n            if (colors[i] == 0) {\\n                if (!dfs(i, adj, colors, 1)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int node, List<Integer>[] adj, int[] colors, int color) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }\\n        colors[node] = color;\\n        for (int neighbor : adj[node]) {\\n            if (!dfs(neighbor, adj, colors, -color)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// DFS color and negative color confliction solution\\n// if color the neighbor with -color, if conflict, return false.\\n// Same idea with Leetcode 785. Is Graph Bipartite\\n// Time complexity: O(N+E)\\n// Space complexity: O(N+E)\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        // Ask whether dislikes could be null\\n        if (N <= 2) return true;\\n        List<Integer>[] adj = new ArrayList[N+1];\\n        for (int i = 1; i <= N; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : dislikes) {\\n            adj[edge[0]].add(edge[1]);\\n            adj[edge[1]].add(edge[0]);\\n        }\\n        int[] colors = new int[N+1];\\n        for (int i = 1; i <= N; i++) {\\n            if (colors[i] == 0) {\\n                if (!dfs(i, adj, colors, 1)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int node, List<Integer>[] adj, int[] colors, int color) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }\\n        colors[node] = color;\\n        for (int neighbor : adj[node]) {\\n            if (!dfs(neighbor, adj, colors, -color)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656394,
                "title": "python-much-easy-approach-using-dfs",
                "content": "```\\nfrom collections import defaultdict as dd\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        graph = dd(list)\\n        for u,v in dislikes:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n            \\n        def dfs(graph, color, node, col):\\n            color[node] = col\\n            for neigh in graph[node]:\\n                if color[neigh] == col:\\n                    return False\\n                if color[neigh] == 0 and not dfs(graph, color, neigh, -col):\\n                    return False\\n            return True \\n        \\n        \\n        color = [0] * (N+1)  \\n        for i in range(1,N):\\n            if color[i] == 0 and not dfs(graph, color, i, 1):\\n                return False\\n        return True\\n        \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict as dd\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        graph = dd(list)\\n        for u,v in dislikes:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n            \\n        def dfs(graph, color, node, col):\\n            color[node] = col\\n            for neigh in graph[node]:\\n                if color[neigh] == col:\\n                    return False\\n                if color[neigh] == 0 and not dfs(graph, color, neigh, -col):\\n                    return False\\n            return True \\n        \\n        \\n        color = [0] * (N+1)  \\n        for i in range(1,N):\\n            if color[i] == 0 and not dfs(graph, color, i, 1):\\n                return False\\n        return True\\n        \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 655432,
                "title": "c-bfs-as-well-as-dfs-best-simple-and-cute-solution",
                "content": "I tried my best, to make you understand the code. Go with the comments :)\\n\\n**BFS**\\n* Make an Adjacency list and a Color Array.\\n* Make a Queue, push the parent, give color to parent.\\n* Traverse the queue, check whether a parent and its neighbour should not have the same color, if they\\'ve simply return false.\\n* Else return true.\\n**Code in C++ :**\\n```\\n class Solution {\\n public:\\n vector<int> adj[2001];// declare a adjacency list\\n int colors[2001]; // declare a array for inserting the colors\\n        \\n bool possibleBipartition(int N, vector<vector<int>>& dislikes)\\n {       \\n     for(int i=1;i<=N;i++)\\n        colors[i]=0;// making all nodes to be of \\'0\\' color\\n        \\n        \\n     for(auto v : dislikes)\\n     {\\n        adj[v[0]].push_back(v[1]); // connecting u--v\\n        adj[v[1]].push_back(v[0]);  // connecting v--u\\n     }\\n        \\n     for(int i=1;i<=N;i++)\\n     {\\n        if(colors[i]==0) // node is not colored yet !!\\n          {\\n             queue<int>q; \\n             q.push(i); // pushing into the Queue\\n             colors[i]=1; // coloring the node-->\\'i\\' to \\'1\\'\\n                \\n             while(!q.empty()) // will check until the queue is empty\\n              {\\n\\n                int f=q.front(); // taking the parent\\n                q.pop(); // poping it\\n\\n                for(int neigh : adj[f]) // will traverse through level ordering\\n                {\\n                  if(colors[neigh]==colors[f])\\n                     return false; // if parent and its neighbourer \\n                        //have same color return false\\n                        \\n                  if(colors[neigh]==0) // if not yet colored\\n                  {\\n                     colors[neigh]=-colors[f]; // coloring it with just opposite \\n                            // sign of parent\\n                     q.push(neigh);// pushing it into the queue\\n                  }\\n                }    \\n             }\\n          }\\n      }\\n      return true;\\n    }\\n    \\n};\\n```\\n**DFS**\\n* Use a color[] array which stores 0 or 1 for every node which denotes opposite colors.\\n* Call the function DFS from any node.\\n* If the node u has not been visited previously, then assign !color[v] to color[u] and call DFS again to visit nodes connected to u.\\n* If at any point, color[u] is equal to !color[v], then the node is bipartite.\\n* Modify the DFS function such that it returns a boolean value at the end.\\n\\n**Code in C++ :**\\n```\\nclass Solution {\\n public:\\n    vector<int> adj[2001];// declare a adjacency list\\n    int colors[2001]; // declare a array for inserting the colors\\n    int vis[2001]; // declare a visited array\\n\\n    bool dfs(int v, int c)\\n    {\\n       \\n        vis[v]=1; // visiting the node\\n        colors[v]=c; // providing a color-->\\'c\\'\\n    \\n        for(int child : adj[v]) // going from parent to its children\\n        {\\n            if(!vis[child]) // if not visisted\\n            {\\n                if(dfs(child,c^1)==false) // \\'c^1\\' toggle the value, \\n                    //so if parent and child do have same color(c) then return false\\n                    return false;\\n            }\\n            else // if visited\\n            {\\n                if(colors[child]==colors[v]) // while back-tracking \\n                    //if parent and child have same color(c) then return false\\n                    return false;\\n            }\\n        }    \\n        return true;   \\n    }\\n\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) { \\n        \\n        for(int i=1;i<=N;i++)\\n            colors[i]=0;\\n        for(int i=1;i<=N;i++)\\n            vis[i]=0;\\n        \\n        for(auto v : dislikes)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        // if graph is disconneted, then check for individual connected components\\n        for(int i=1;i<=N;i++) \\n        {\\n            if(vis[i]==0 && !dfs(i,0))\\n               return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n```\\n\\nYou can check my blog, if you wish ^_^\\n[http://piyushnirala28.blogspot.com/](http://)",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n public:\\n vector<int> adj[2001];// declare a adjacency list\\n int colors[2001]; // declare a array for inserting the colors\\n        \\n bool possibleBipartition(int N, vector<vector<int>>& dislikes)\\n {       \\n     for(int i=1;i<=N;i++)\\n        colors[i]=0;// making all nodes to be of \\'0\\' color\\n        \\n        \\n     for(auto v : dislikes)\\n     {\\n        adj[v[0]].push_back(v[1]); // connecting u--v\\n        adj[v[1]].push_back(v[0]);  // connecting v--u\\n     }\\n        \\n     for(int i=1;i<=N;i++)\\n     {\\n        if(colors[i]==0) // node is not colored yet !!\\n          {\\n             queue<int>q; \\n             q.push(i); // pushing into the Queue\\n             colors[i]=1; // coloring the node-->\\'i\\' to \\'1\\'\\n                \\n             while(!q.empty()) // will check until the queue is empty\\n              {\\n\\n                int f=q.front(); // taking the parent\\n                q.pop(); // poping it\\n\\n                for(int neigh : adj[f]) // will traverse through level ordering\\n                {\\n                  if(colors[neigh]==colors[f])\\n                     return false; // if parent and its neighbourer \\n                        //have same color return false\\n                        \\n                  if(colors[neigh]==0) // if not yet colored\\n                  {\\n                     colors[neigh]=-colors[f]; // coloring it with just opposite \\n                            // sign of parent\\n                     q.push(neigh);// pushing it into the queue\\n                  }\\n                }    \\n             }\\n          }\\n      }\\n      return true;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n public:\\n    vector<int> adj[2001];// declare a adjacency list\\n    int colors[2001]; // declare a array for inserting the colors\\n    int vis[2001]; // declare a visited array\\n\\n    bool dfs(int v, int c)\\n    {\\n       \\n        vis[v]=1; // visiting the node\\n        colors[v]=c; // providing a color-->\\'c\\'\\n    \\n        for(int child : adj[v]) // going from parent to its children\\n        {\\n            if(!vis[child]) // if not visisted\\n            {\\n                if(dfs(child,c^1)==false) // \\'c^1\\' toggle the value, \\n                    //so if parent and child do have same color(c) then return false\\n                    return false;\\n            }\\n            else // if visited\\n            {\\n                if(colors[child]==colors[v]) // while back-tracking \\n                    //if parent and child have same color(c) then return false\\n                    return false;\\n            }\\n        }    \\n        return true;   \\n    }\\n\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) { \\n        \\n        for(int i=1;i<=N;i++)\\n            colors[i]=0;\\n        for(int i=1;i<=N;i++)\\n            vis[i]=0;\\n        \\n        for(auto v : dislikes)\\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        // if graph is disconneted, then check for individual connected components\\n        for(int i=1;i<=N;i++) \\n        {\\n            if(vis[i]==0 && !dfs(i,0))\\n               return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655201,
                "title": "python-solution-gradually-partition-the-numbers-into-2-groups",
                "content": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        if not dislikes: return True\\n        set1 = set([dislikes[0][0]])\\n        set2 = set([dislikes[0][1]])\\n        i = 1\\n        first = None\\n        while i < len(dislikes):\\n            dis = dislikes[i]\\n            if dis[0] in set1:\\n                first = None\\n                if dis[1] in set1: return False\\n                set2.add(dis[1])\\n            elif dis[0] in set2:\\n                first = None\\n                if dis[1] in set2: return False\\n                set1.add(dis[1])\\n            elif dis[1] in set1:\\n                first = None\\n                set2.add(dis[0])\\n            elif dis[1] in set2: \\n                first = None\\n                set1.add(dis[0])\\n                \\n            else:\\n                if not first: \\n                    first = dis\\n                    dislikes.append(dis)\\n                elif dis == first:\\n                    set1.add(dis[0])\\n                    set2.add(dis[1])\\n                else: dislikes.append(dis) \\n            i += 1\\n        return True\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        if not dislikes: return True\\n        set1 = set([dislikes[0][0]])\\n        set2 = set([dislikes[0][1]])\\n        i = 1\\n        first = None\\n        while i < len(dislikes):\\n            dis = dislikes[i]\\n            if dis[0] in set1:\\n                first = None\\n                if dis[1] in set1: return False\\n                set2.add(dis[1])\\n            elif dis[0] in set2:\\n                first = None\\n                if dis[1] in set2: return False\\n                set1.add(dis[1])\\n            elif dis[1] in set1:\\n                first = None\\n                set2.add(dis[0])\\n            elif dis[1] in set2: \\n                first = None\\n                set1.add(dis[0])\\n                \\n            else:\\n                if not first: \\n                    first = dis\\n                    dislikes.append(dis)\\n                elif dis == first:\\n                    set1.add(dis[0])\\n                    set2.add(dis[1])\\n                else: dislikes.append(dis) \\n            i += 1\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 655104,
                "title": "why-does-dfs-cause-tle",
                "content": "```\\nclass Solution {\\npublic:    \\n    int flag=true;\\n    void dfs(vector<vector<int>> v, vector<int>& color, int node, int p_color){\\n        \\n      if(flag==false){\\n            return;\\n      }\\n\\n      if(color[node]==p_color){\\n        flag=false;\\n        return;\\n      }\\n      else if(color[node]==0)\\n        color[node]=-p_color;\\n      else return;\\n\\n      if(flag)\\n      for(int i=0;i<v[node].size() && flag;i++){\\n        int n_node = v[node][i];\\n        if(color[n_node]==color[node]){\\n          flag=false;\\n          return;\\n        }\\n        else if(color[n_node]==0){\\n          dfs(v, color, n_node, -p_color);\\n        }\\n        else{}\\n\\n      }\\n      if(flag==false){\\n            return;\\n      }\\n    }\\n\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<vector<int>>v(N);\\n        vector<int>color(N);\\n\\n        for(int i=0;i<dislikes.size();i++){\\n            int a = dislikes[i][0]-1;\\n            int b = dislikes[i][1]-1;\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n\\n        for(int i=0;i<N && flag;i++){\\n          if(color[i]==0)\\n          dfs(v, color, i, 1);\\n          if(flag==false)break;\\n        }\\n\\n        return flag;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int flag=true;\\n    void dfs(vector<vector<int>> v, vector<int>& color, int node, int p_color){\\n        \\n      if(flag==false){\\n            return;\\n      }\\n\\n      if(color[node]==p_color){\\n        flag=false;\\n        return;\\n      }\\n      else if(color[node]==0)\\n        color[node]=-p_color;\\n      else return;\\n\\n      if(flag)\\n      for(int i=0;i<v[node].size() && flag;i++){\\n        int n_node = v[node][i];\\n        if(color[n_node]==color[node]){\\n          flag=false;\\n          return;\\n        }\\n        else if(color[n_node]==0){\\n          dfs(v, color, n_node, -p_color);\\n        }\\n        else{}\\n\\n      }\\n      if(flag==false){\\n            return;\\n      }\\n    }\\n\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<vector<int>>v(N);\\n        vector<int>color(N);\\n\\n        for(int i=0;i<dislikes.size();i++){\\n            int a = dislikes[i][0]-1;\\n            int b = dislikes[i][1]-1;\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n\\n        for(int i=0;i<N && flag;i++){\\n          if(color[i]==0)\\n          dfs(v, color, i, 1);\\n          if(flag==false)break;\\n        }\\n\\n        return flag;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654880,
                "title": "go-solution",
                "content": "```\\n\\nvar colorMap map[int]int\\nvar edges map[int][]int\\n\\nfunc possibleBipartition(N int, dislikes [][]int) bool {\\n    \\n    colorMap = make(map[int]int)\\n    edges = make(map[int][]int)\\n    \\n    for _, dislike:= range dislikes{\\n        edges[dislike[0]]=append(edges[dislike[0]], dislike[1])\\n        edges[dislike[1]]=append(edges[dislike[1]], dislike[0])\\n    }\\n    \\n    for node:=1; node<= N; node++{\\n        \\n        if _, ok:= colorMap[node]; !ok{\\n            if !dfs(node, 0){\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n    \\n}\\n\\nfunc dfs(node int, color int) bool{\\n    \\n    if val, ok:= colorMap[node]; ok{\\n        return val==color\\n    }else{\\n        colorMap[node]=color\\n    }\\n    \\n    for _, neigh:= range edges[node]{\\n        \\n        if !dfs(neigh, color ^ 1){\\n            return false\\n        }\\n    }\\n    \\n    return true\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar colorMap map[int]int\\nvar edges map[int][]int\\n\\nfunc possibleBipartition(N int, dislikes [][]int) bool {\\n    \\n    colorMap = make(map[int]int)\\n    edges = make(map[int][]int)\\n    \\n    for _, dislike:= range dislikes{\\n        edges[dislike[0]]=append(edges[dislike[0]], dislike[1])\\n        edges[dislike[1]]=append(edges[dislike[1]], dislike[0])\\n    }\\n    \\n    for node:=1; node<= N; node++{\\n        \\n        if _, ok:= colorMap[node]; !ok{\\n            if !dfs(node, 0){\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n    \\n}\\n\\nfunc dfs(node int, color int) bool{\\n    \\n    if val, ok:= colorMap[node]; ok{\\n        return val==color\\n    }else{\\n        colorMap[node]=color\\n    }\\n    \\n    for _, neigh:= range edges[node]{\\n        \\n        if !dfs(neigh, color ^ 1){\\n            return false\\n        }\\n    }\\n    \\n    return true\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654847,
                "title": "c-bfs-with-graph-coloring-algo",
                "content": "for every vertex u check its adjacent vertices v, if v is not already in the queue and not visited add it,if v is aready visited, then mark its color as not possible for the color of u. Then starting from 1, find the color which is not marked as \\'not possible\\', and color it to u.\\nwhite -> not visited and not added in the queue\\ngrey -> already in the queue, not visited yet\\nblack -> visited\\n```\\nbool possibleBipartition(int N, vector<vector<int>>& dislikes) //1 is white,0 is grey,-1 is black\\n{\\n\\tvector<int> visited(N+1,1);\\n\\tvector<vector<int>> adj(N+1,vector<int>(0,0));\\n\\tqueue<int> q;\\n\\tfor(auto v:dislikes)\\n\\t{\\n\\t\\tadj[v[0]].push_back(v[1]);   \\n\\t\\tadj[v[1]].push_back(v[0]); \\n\\t}\\n\\tvector<int> color(N+1,-1);\\n    for(int i=1;i<=N;++i)// this loop is to make sure that every person is checked.\\n        if(visited[i]==1)\\n        {\\n\\t\\t\\tvisited[i]=0;\\n\\t\\t\\tq.push(i);\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tvector<int> c(N+1,0);\\n\\t\\t\\t\\tfor(int v:adj[u])\\n\\t\\t\\t\\t\\tif(visited[v]==1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(v);\\n\\t\\t\\t\\t\\t\\tvisited[v]=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(visited[v]==-1)\\n\\t\\t\\t\\t\\t\\tc[color[v]]=1;\\n\\t\\t\\t\\tfor(int i=1;i<c.size();++i)\\n\\t\\t        {\\n\\t\\t\\t\\t\\tif(i>2)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tif(c[i]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcolor[u]=i;\\n\\t\\t                break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t        }\\n\\t\\t\\t\\tvisited[u]=-1;\\n\\t\\t\\t}\\n        }\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nbool possibleBipartition(int N, vector<vector<int>>& dislikes) //1 is white,0 is grey,-1 is black\\n{\\n\\tvector<int> visited(N+1,1);\\n\\tvector<vector<int>> adj(N+1,vector<int>(0,0));\\n\\tqueue<int> q;\\n\\tfor(auto v:dislikes)\\n\\t{\\n\\t\\tadj[v[0]].push_back(v[1]);   \\n\\t\\tadj[v[1]].push_back(v[0]); \\n\\t}\\n\\tvector<int> color(N+1,-1);\\n    for(int i=1;i<=N;++i)// this loop is to make sure that every person is checked.\\n        if(visited[i]==1)\\n        {\\n\\t\\t\\tvisited[i]=0;\\n\\t\\t\\tq.push(i);\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tvector<int> c(N+1,0);\\n\\t\\t\\t\\tfor(int v:adj[u])\\n\\t\\t\\t\\t\\tif(visited[v]==1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tq.push(v);\\n\\t\\t\\t\\t\\t\\tvisited[v]=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(visited[v]==-1)\\n\\t\\t\\t\\t\\t\\tc[color[v]]=1;\\n\\t\\t\\t\\tfor(int i=1;i<c.size();++i)\\n\\t\\t        {\\n\\t\\t\\t\\t\\tif(i>2)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tif(c[i]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcolor[u]=i;\\n\\t\\t                break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t        }\\n\\t\\t\\t\\tvisited[u]=-1;\\n\\t\\t\\t}\\n        }\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 651697,
                "title": "python-bfs",
                "content": "Intuitions:\\n- Build a graph for both nodes in dislikes (i.e., a->b & b->a).\\n- Use a dictionary (\"group\" in the code below) to keep track of which group each node belongs to. \\n- Perform BFS. If a neighbor hasn\\'t been labelled to either group, then label the neighbor to the group opposite to the node\\'s. If the neighbor has already been labelled, check if it\\'s labelled as the opposite group.\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        \\n        from collections import defaultdict, deque\\n        \\n        graph = defaultdict(list)\\n        for a,b in dislikes:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        q = deque()\\n        group = defaultdict(int)\\n\\n        for i in range(1, N+1):\\n            if i not in group:\\n                q.append(i)\\n                group[i] = 1\\n                \\n            while q:\\n                node = q.popleft()\\n                for nei in graph[node]:\\n                    if nei not in group:\\n                        group[nei] = -group[node]\\n                        q.append(nei)\\n                    elif nei in group and group[nei] != -group[node]:\\n                        return False\\n\\n        return True\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        \\n        from collections import defaultdict, deque\\n        \\n        graph = defaultdict(list)\\n        for a,b in dislikes:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        q = deque()\\n        group = defaultdict(int)\\n\\n        for i in range(1, N+1):\\n            if i not in group:\\n                q.append(i)\\n                group[i] = 1\\n                \\n            while q:\\n                node = q.popleft()\\n                for nei in graph[node]:\\n                    if nei not in group:\\n                        group[nei] = -group[node]\\n                        q.append(nei)\\n                    elif nei in group and group[nei] != -group[node]:\\n                        return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650930,
                "title": "java-2-solutions-union-find-graph-coloring",
                "content": "```\\n/* Union-find solution */\\npublic boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] root = new int[n];\\n        for (int i = 0; i < root.length; i++) {\\n            root[i] = i;\\n        }\\n        \\n        LinkedList<Integer>[] graph = new LinkedList[n];\\n        \\n        for (int i = 0; i < n ; i++ ) {\\n            graph[i] = new LinkedList<Integer>();\\n        }\\n\\n        for(int[] dislike : dislikes){\\n            int a = dislike[0] - 1;\\n            int b = dislike[1] - 1;\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            LinkedList<Integer> adjList = graph[i];\\n            for(int adj : adjList) {\\n                int xRoot = find(i, root);\\n                int yRoot = find(adj, root);\\n                if(xRoot != yRoot){\\n                    root[find(adjList.get(0), root)] = yRoot;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int find(int x, int[] root){\\n        while(x != root[x]){\\n            root[x] = root[root[x]];\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n\\t\\n\\t/* Graph coloring solution */\\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] colors = new int[n];\\n        LinkedList<Integer>[] graph = new LinkedList[n];\\n\\n        for (int i = 0; i < n ; i++ ) {\\n            graph[i] = new LinkedList<>();\\n        }\\n\\n        for(int[] dislike : dislikes){\\n            int a = dislike[0];\\n            int b = dislike[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n\\n        for(int i = 0; i < n; i++ ){\\n            if(colors[i] != 0) continue;\\n\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n\\n            while(!queue.isEmpty()){\\n                int curr = queue.poll();\\n                colors[curr] = 1;\\n                for(int adj : graph[curr]){\\n                    if(colors[adj] == 0){\\n                        colors[adj] = -colors[curr];\\n                    }else if(colors[adj] != -colors[curr]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/* Union-find solution */\\npublic boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] root = new int[n];\\n        for (int i = 0; i < root.length; i++) {\\n            root[i] = i;\\n        }\\n        \\n        LinkedList<Integer>[] graph = new LinkedList[n];\\n        \\n        for (int i = 0; i < n ; i++ ) {\\n            graph[i] = new LinkedList<Integer>();\\n        }\\n\\n        for(int[] dislike : dislikes){\\n            int a = dislike[0] - 1;\\n            int b = dislike[1] - 1;\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            LinkedList<Integer> adjList = graph[i];\\n            for(int adj : adjList) {\\n                int xRoot = find(i, root);\\n                int yRoot = find(adj, root);\\n                if(xRoot != yRoot){\\n                    root[find(adjList.get(0), root)] = yRoot;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int find(int x, int[] root){\\n        while(x != root[x]){\\n            root[x] = root[root[x]];\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n\\t\\n\\t/* Graph coloring solution */\\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] colors = new int[n];\\n        LinkedList<Integer>[] graph = new LinkedList[n];\\n\\n        for (int i = 0; i < n ; i++ ) {\\n            graph[i] = new LinkedList<>();\\n        }\\n\\n        for(int[] dislike : dislikes){\\n            int a = dislike[0];\\n            int b = dislike[1];\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n\\n        for(int i = 0; i < n; i++ ){\\n            if(colors[i] != 0) continue;\\n\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n\\n            while(!queue.isEmpty()){\\n                int curr = queue.poll();\\n                colors[curr] = 1;\\n                for(int adj : graph[curr]){\\n                    if(colors[adj] == 0){\\n                        colors[adj] = -colors[curr];\\n                    }else if(colors[adj] != -colors[curr]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 569281,
                "title": "the-question-is-similar-to-lc-785",
                "content": "The question is similar to [L.785](https://leetcode.com/problems/is-graph-bipartite/)\\n```cpp\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int>color(N + 1, 0);\\n        vector<vector<int>>g(N+1);\\n        for(auto a:dislikes)\\n        {\\n            g[a[0]].push_back(a[1]);\\n            g[a[1]].push_back(a[0]);\\n        }\\n        for(int i = 1; i <= N; i++)\\n        {\\n            if(color[i] != 0)continue;\\n            color[i] = 1;\\n            queue<int>q{{i}};\\n            while(!q.empty())\\n            {\\n                auto t = q.front(); q.pop();\\n                for(auto a:g[t])\\n                {\\n                    if(color[a] == color[t])return false;\\n                    if(color[a] == 0)\\n                    {\\n                        color[a] = -1*color[t];\\n                        q.push(a);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int>color(N + 1, 0);\\n        vector<vector<int>>g(N+1);\\n        for(auto a:dislikes)\\n        {\\n            g[a[0]].push_back(a[1]);\\n            g[a[1]].push_back(a[0]);\\n        }\\n        for(int i = 1; i <= N; i++)\\n        {\\n            if(color[i] != 0)continue;\\n            color[i] = 1;\\n            queue<int>q{{i}};\\n            while(!q.empty())\\n            {\\n                auto t = q.front(); q.pop();\\n                for(auto a:g[t])\\n                {\\n                    if(color[a] == color[t])return false;\\n                    if(color[a] == 0)\\n                    {\\n                        color[a] = -1*color[t];\\n                        q.push(a);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536760,
                "title": "c-dfs-with-some-comments-with-no-confusing-color-references",
                "content": "```\\nclass Solution {\\n    public:\\n        bool possibleBipartition(int N, vector<vector<int>>& dislikes) \\n        {\\n            vector<vector<int>> graph(N+1); // (\\'people\\' are 1-based)\\n            for(auto& p : dislikes)\\n            {\\n                graph[p.front()].push_back(p.back());\\n                graph[p.back()].push_back(p.front());\\n            }\\n\\n            vector<int> groups(N+1); // 0 = not assigned; 1 = group 1; -1 = group 2.\\n            for(int i = 1; i < graph.size(); ++i) // (1-based)\\n            {\\n                // if not assigned - should be able to assign to group 1\\n                if(groups[i] == 0 && !assign_group(graph, groups, i, 1))\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n    protected:\\n        bool assign_group(vector<vector<int>>& graph, vector<int>& groups, int indx, int group)\\n        {\\n            groups[indx] = group;\\n            // make sure all it\\'s \\'dislikes\\' assigned or can be assigned to the opposite group\\n            for(int n : graph[indx]) \\n            {\\n                if(groups[n] == group) \\n                    return false;\\n                if(groups[n] == 0 && !assign_group(graph, groups, n, -group)) \\n                    return false;\\n            }\\n            return true;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        bool possibleBipartition(int N, vector<vector<int>>& dislikes) \\n        {\\n            vector<vector<int>> graph(N+1); // (\\'people\\' are 1-based)\\n            for(auto& p : dislikes)\\n            {\\n                graph[p.front()].push_back(p.back());\\n                graph[p.back()].push_back(p.front());\\n            }\\n\\n            vector<int> groups(N+1); // 0 = not assigned; 1 = group 1; -1 = group 2.\\n            for(int i = 1; i < graph.size(); ++i) // (1-based)\\n            {\\n                // if not assigned - should be able to assign to group 1\\n                if(groups[i] == 0 && !assign_group(graph, groups, i, 1))\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n    protected:\\n        bool assign_group(vector<vector<int>>& graph, vector<int>& groups, int indx, int group)\\n        {\\n            groups[indx] = group;\\n            // make sure all it\\'s \\'dislikes\\' assigned or can be assigned to the opposite group\\n            for(int n : graph[indx]) \\n            {\\n                if(groups[n] == group) \\n                    return false;\\n                if(groups[n] == 0 && !assign_group(graph, groups, n, -group)) \\n                    return false;\\n            }\\n            return true;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351923,
                "title": "easy-java-solution-bfs",
                "content": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] partition = new int[N];\\n        //construct a new data structure\\n        ArrayList<Integer>[] graph = new ArrayList[N];//[ArrayList, ...]\\n        for(int i = 0; i < N; i++)\\n            graph[i] = new ArrayList<>();\\n        //initialiazed\\n        for(int i = 0; i < dislikes.length; i++){\\n            graph[dislikes[i][0] - 1].add(dislikes[i][1] -1);\\n            graph[dislikes[i][1] - 1].add(dislikes[i][0] -1);\\n        }\\n        //Queue for BFS\\n        Queue<Integer> queue = new LinkedList<>();        \\n        for(int n = 0; n < N; n++){\\n            if(partition[n] == 0) {queue.offer(n); partition[n] = 1;}\\n            while(!queue.isEmpty()){\\n                int cur = queue.poll();\\n                for(int i: graph[cur]){\\n                    if(partition[i] == partition[cur]) return false;\\n                    if(partition[i] == 0){\\n                        partition[i] = -partition[cur];\\n                        queue.offer(i);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int[] partition = new int[N];\\n        //construct a new data structure\\n        ArrayList<Integer>[] graph = new ArrayList[N];//[ArrayList, ...]\\n        for(int i = 0; i < N; i++)\\n            graph[i] = new ArrayList<>();\\n        //initialiazed\\n        for(int i = 0; i < dislikes.length; i++){\\n            graph[dislikes[i][0] - 1].add(dislikes[i][1] -1);\\n            graph[dislikes[i][1] - 1].add(dislikes[i][0] -1);\\n        }\\n        //Queue for BFS\\n        Queue<Integer> queue = new LinkedList<>();        \\n        for(int n = 0; n < N; n++){\\n            if(partition[n] == 0) {queue.offer(n); partition[n] = 1;}\\n            while(!queue.isEmpty()){\\n                int cur = queue.poll();\\n                for(int i: graph[cur]){\\n                    if(partition[i] == partition[cur]) return false;\\n                    if(partition[i] == 0){\\n                        partition[i] = -partition[cur];\\n                        queue.offer(i);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245314,
                "title": "c-union-find-solution",
                "content": "```\\nclass UNF {\\npublic:\\n    UNF(int N) {\\n        this->size = N;\\n        this->father = vector<int>(N + 1, 0);\\n        int i;\\n        for (i = 0 ; i <= N; i++) {\\n            father[i] = i;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (father[x] == x) {\\n            return x;\\n        }\\n        father[x] = find(father[x]);\\n        return father[x];\\n    }\\n    \\n    int sameset(int x, int y) {\\n        return (find(x) == find(y));\\n    }\\n    \\n    void unionset(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        father[b] = a;\\n    }\\n    \\n    \\nprivate:\\n    int size;\\n    vector<int> father;\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        UNF s = UNF(2 * N);\\n        for (auto d : dislikes) {\\n            s.unionset(d[0], d[1] + N);\\n            s.unionset(d[1], d[0] + N);\\n            if (s.sameset(d[0], d[1])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UNF {\\npublic:\\n    UNF(int N) {\\n        this->size = N;\\n        this->father = vector<int>(N + 1, 0);\\n        int i;\\n        for (i = 0 ; i <= N; i++) {\\n            father[i] = i;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (father[x] == x) {\\n            return x;\\n        }\\n        father[x] = find(father[x]);\\n        return father[x];\\n    }\\n    \\n    int sameset(int x, int y) {\\n        return (find(x) == find(y));\\n    }\\n    \\n    void unionset(int x, int y) {\\n        int a = find(x);\\n        int b = find(y);\\n        father[b] = a;\\n    }\\n    \\n    \\nprivate:\\n    int size;\\n    vector<int> father;\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        UNF s = UNF(2 * N);\\n        for (auto d : dislikes) {\\n            s.unionset(d[0], d[1] + N);\\n            s.unionset(d[1], d[0] + N);\\n            if (s.sameset(d[0], d[1])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203522,
                "title": "c-solution-using-colors",
                "content": "`0`: unvisited, `1`: first group, `-1`: second group\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(N);\\n        for(vector<int> d : dislikes) {\\n            graph[d[0]-1].push_back(d[1]-1);\\n            graph[d[1]-1].push_back(d[0]-1);\\n        }\\n        \\n        vector<int> colors(N);\\n        for(int i = 0; i < N; i++) {\\n            if(colors[i] == 0 && !dfs(graph, colors, i, 1)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\nprivate:\\n    bool dfs(vector<vector<int>> &graph, vector<int> &colors, int idx, int cc) {\\n        if(colors[idx] != 0) return colors[idx] == cc;\\n        colors[idx] = cc;\\n        \\n        for(int nidx : graph[idx]) {\\n            if(!dfs(graph, colors, nidx, -cc)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(N);\\n        for(vector<int> d : dislikes) {\\n            graph[d[0]-1].push_back(d[1]-1);\\n            graph[d[1]-1].push_back(d[0]-1);\\n        }\\n        \\n        vector<int> colors(N);\\n        for(int i = 0; i < N; i++) {\\n            if(colors[i] == 0 && !dfs(graph, colors, i, 1)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\nprivate:\\n    bool dfs(vector<vector<int>> &graph, vector<int> &colors, int idx, int cc) {\\n        if(colors[idx] != 0) return colors[idx] == cc;\\n        colors[idx] = cc;\\n        \\n        for(int nidx : graph[idx]) {\\n            if(!dfs(graph, colors, nidx, -cc)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158984,
                "title": "eager-even-odd-graph-coloring-detailed-explanation",
                "content": "* use a graph to represent the `dislike` constraints. an edge `(a,b)` means `a`, `b` must have a different color. since this also means `b`, `a` must have a different color, treat edges as undirected.\\n* since mutually disconnected subgraphs do not affect each other, treat them as independent problems\\n* the color of any node in a connected component is constrained by at least one other node. pick a random color for any node in the graph, and use a DFS to eagerly enforce neighborining constraints\\n* if a constraint cannot be enforced, return false. otherwise if the graph is fully colored, return true\\n* ensure every subgraph can be colored\\n\\n\\n\\n```\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\n\\n        d=[None]*N # the color of each node\\n\\n        out=[[] for _ in range(N)] # out-edges for each node\\n\\n        for a,b in dislikes:\\n            out[a-1].append(b-1)\\n            out[b-1].append(a-1)\\n\\n        def rec(i,c):\\n            # DFS, enforce constraints eagerly. returns true iff graph can be colored\\n            # i is the current node\\n            # c is the required color\\n\\n            if d[i]==None:\\n                # not yet colored, assign color c\\n                d[i]=c\\n                for ii in out[i]:\\n                    # assign the opposite color to all neighbors\\n                    if not rec(ii,1-c):\\n                        # not possible\\n                        return False\\n                return True\\n            else:\\n                # already colored. ensure no mismatch\\n                return d[i]==c\\n\\n        # loop through all nodes to ensure disconnected subgraphs can be colored\\n        for i in range(N):\\n            if d[i]==None and not rec(i,0):\\n                    return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\n\\n        d=[None]*N # the color of each node\\n\\n        out=[[] for _ in range(N)] # out-edges for each node\\n\\n        for a,b in dislikes:\\n            out[a-1].append(b-1)\\n            out[b-1].append(a-1)\\n\\n        def rec(i,c):\\n            # DFS, enforce constraints eagerly. returns true iff graph can be colored\\n            # i is the current node\\n            # c is the required color\\n\\n            if d[i]==None:\\n                # not yet colored, assign color c\\n                d[i]=c\\n                for ii in out[i]:\\n                    # assign the opposite color to all neighbors\\n                    if not rec(ii,1-c):\\n                        # not possible\\n                        return False\\n                return True\\n            else:\\n                # already colored. ensure no mismatch\\n                return d[i]==c\\n\\n        # loop through all nodes to ensure disconnected subgraphs can be colored\\n        for i in range(N):\\n            if d[i]==None and not rec(i,0):\\n                    return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541884,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool ans=1;\\n    vector<int> color;\\n    void bfs(int i, vector<vector<int>>& adj){\\n        queue<int> q;\\n        q.push(i);\\n        color[i]=1;\\n        while(!q.empty()){\\n            int k=q.front();\\n            q.pop();\\n            for(int j: adj[k]){\\n                int c=color[j];\\n                int c_k=color[k];\\n                if (c==-1){\\n                    color[j]=(c_k+1)&1;\\n                    q.push(j);\\n                }\\n                else if( c==c_k){\\n                    ans=0;\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n       color.assign(n+1, -1); \\n       vector<vector<int>> adj(n+1);\\n       for(vector<int>& d: dislikes){\\n            int i=d[0], j=d[1];\\n            adj[i].push_back(j);\\n            adj[j].push_back(i);\\n       }\\n       for (int i=1; i<=n; i++)\\n            if (color[i]==-1)\\n                bfs(i, adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans=1;\\n    vector<int> color;\\n    void bfs(int i, vector<vector<int>>& adj){\\n        queue<int> q;\\n        q.push(i);\\n        color[i]=1;\\n        while(!q.empty()){\\n            int k=q.front();\\n            q.pop();\\n            for(int j: adj[k]){\\n                int c=color[j];\\n                int c_k=color[k];\\n                if (c==-1){\\n                    color[j]=(c_k+1)&1;\\n                    q.push(j);\\n                }\\n                else if( c==c_k){\\n                    ans=0;\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n       color.assign(n+1, -1); \\n       vector<vector<int>> adj(n+1);\\n       for(vector<int>& d: dislikes){\\n            int i=d[0], j=d[1];\\n            adj[i].push_back(j);\\n            adj[j].push_back(i);\\n       }\\n       for (int i=1; i<=n; i++)\\n            if (color[i]==-1)\\n                bfs(i, adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224239,
                "title": "java-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity: O(E+V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(E+V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        \\n        int color[] = new int[n+1];\\n        // 0: not visit, -1: blue, 1: red\\n        Arrays.fill(color, 0); \\n        List<Integer> adj[] = new ArrayList[n+1];\\n        for(int i = 1; i<= n;i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        for(int dislike[]: dislikes){\\n            adj[dislike[0]].add(dislike[1]);\\n            adj[dislike[1]].add(dislike[0]);\\n        }\\n\\n        for(int i = 1; i<= n;i++){\\n            if(color[i] == 0 && !dfs(color, adj, i, 1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean dfs(int colors[], List<Integer> adj[], int curr, int color){\\n        colors[curr] = color;\\n        for(int neighbor: adj[curr]){\\n            if(colors[curr] == colors[neighbor]){\\n                return false;\\n            }\\n            if(colors[neighbor] == 0 && !dfs(colors, adj, neighbor, color * -1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        \\n        int color[] = new int[n+1];\\n        // 0: not visit, -1: blue, 1: red\\n        Arrays.fill(color, 0); \\n        List<Integer> adj[] = new ArrayList[n+1];\\n        for(int i = 1; i<= n;i++){\\n            adj[i] = new ArrayList<>();\\n        }\\n        for(int dislike[]: dislikes){\\n            adj[dislike[0]].add(dislike[1]);\\n            adj[dislike[1]].add(dislike[0]);\\n        }\\n\\n        for(int i = 1; i<= n;i++){\\n            if(color[i] == 0 && !dfs(color, adj, i, 1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean dfs(int colors[], List<Integer> adj[], int curr, int color){\\n        colors[curr] = color;\\n        for(int neighbor: adj[curr]){\\n            if(colors[curr] == colors[neighbor]){\\n                return false;\\n            }\\n            if(colors[neighbor] == 0 && !dfs(colors, adj, neighbor, color * -1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190587,
                "title": "simple-c-bfs-basic-bipartite-graph",
                "content": "# Intuition\\nHere, we just need to find whether the graph is bipartite or not. Similar to finding if a graph is bipartite graph or not. \\n\\n# Approach\\nTo determine whether a graph is bipartite or not, we can use the concept of coloring child nodes with opposite color. In the process of coloring, if we find any two nodes with the same color then the graph will be not be bipartite graph.\\n\\n# Complexity\\n- Time complexity:\\nO(n+E)\\n\\n- Space complexity:\\nO(n+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> adj[n+1];\\n        vector<int> vis(n+1,-1);\\n        \\n        for(auto it:dislikes){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n       \\n       for(int i=1;i<=n;i++){\\n           if(vis[i]!=-1) continue;\\n            queue<int> q;\\n           q.push(i);\\n       vis[i]=0;\\n        while(!q.empty()){\\n            int node=q.front();\\n           q.pop();\\n            for(auto child:adj[node]){\\n                if(vis[child]==-1){\\n                   vis[child]=!vis[node];\\n                   q.push(child);\\n                }\\n                else if(vis[child]==vis[node]){\\n                    cout<<child<<endl;\\n                    return false;\\n                }\\n            }\\n        }\\n       }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> adj[n+1];\\n        vector<int> vis(n+1,-1);\\n        \\n        for(auto it:dislikes){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n       \\n       for(int i=1;i<=n;i++){\\n           if(vis[i]!=-1) continue;\\n            queue<int> q;\\n           q.push(i);\\n       vis[i]=0;\\n        while(!q.empty()){\\n            int node=q.front();\\n           q.pop();\\n            for(auto child:adj[node]){\\n                if(vis[child]==-1){\\n                   vis[child]=!vis[node];\\n                   q.push(child);\\n                }\\n                else if(vis[child]==vis[node]){\\n                    cout<<child<<endl;\\n                    return false;\\n                }\\n            }\\n        }\\n       }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2937577,
                "title": "c-simple-bfs-bipartite-super-easy-to-understand",
                "content": "# Intuition\\nwe want to divide the likes and dislikes in such a way that they are not in the same group.\\n\\n# Approach\\nWe are using bipartite graph to separate the inputs in two groups of likes and dislikes with two colors such that no same colors are together like we check the bipartitie graph, if two vertices of same color are adjacent then we can say that this graph is non bipartite hence cannot be separated in two groups so we can return false, else we can return true.\\n\\n\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\no(n^2 + n+1 + n)  ~ o(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    bool check_bipartite(vector<int> adj[], int src, int color[]) {\\n        queue<int> q;\\n        q.push(src);\\n        color[src] = 1;\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto adj_node : adj[node]) {\\n                if(color[adj_node] == -1) {\\n                    color[adj_node] = 1 - color[node];\\n                    q.push(adj_node);\\n                }\\n                else if(color[adj_node] == color[node]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n  \\n    bool biPartite(vector<int> adj[], int n) {\\n        int color[n+1];\\n\\n        memset(color, -1, sizeof(color));\\n\\n        for(int i=1;i<=n;i++) {\\n            if(color[i] == -1) {\\n                if(!check_bipartite(adj, i, color)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n\\n        vector<int> adj[n+1];\\n\\n        int N = dislikes.size();\\n        \\n        for(int i=0;i<N;i++) {\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        return biPartite(adj,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    bool check_bipartite(vector<int> adj[], int src, int color[]) {\\n        queue<int> q;\\n        q.push(src);\\n        color[src] = 1;\\n\\n        while(!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto adj_node : adj[node]) {\\n                if(color[adj_node] == -1) {\\n                    color[adj_node] = 1 - color[node];\\n                    q.push(adj_node);\\n                }\\n                else if(color[adj_node] == color[node]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n  \\n    bool biPartite(vector<int> adj[], int n) {\\n        int color[n+1];\\n\\n        memset(color, -1, sizeof(color));\\n\\n        for(int i=1;i<=n;i++) {\\n            if(color[i] == -1) {\\n                if(!check_bipartite(adj, i, color)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n\\n        vector<int> adj[n+1];\\n\\n        int N = dislikes.size();\\n        \\n        for(int i=0;i<N;i++) {\\n            int u = dislikes[i][0];\\n            int v = dislikes[i][1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        return biPartite(adj,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936809,
                "title": "video",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/akg18XkBGqo\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+e)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+e)\\n# Code\\n```\\nvar possibleBipartition = function(n, dislikes) {\\n    let adj = new Array(n+1);\\n    for (let i = 0; i < n+1; i++) {\\n        adj[i] = new Array()\\n    }\\n\\n    for (let d of dislikes) {\\n        adj[d[0]].push(d[1])\\n        adj[d[1]].push(d[0])\\n    }\\n\\n    let color = new Array(n+1).fill(-1);\\n    let dfs = function(i) {\\n        for (let c of adj[i]) {\\n            if (color[c] == color[i]) return false;\\n            if (color[c] == -1) {\\n                color[c] = 1 - color[i]\\n                if (!dfs(c)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (color[i] == -1) {\\n            color[i] = 0\\n            if (!dfs(i)) return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar possibleBipartition = function(n, dislikes) {\\n    let adj = new Array(n+1);\\n    for (let i = 0; i < n+1; i++) {\\n        adj[i] = new Array()\\n    }\\n\\n    for (let d of dislikes) {\\n        adj[d[0]].push(d[1])\\n        adj[d[1]].push(d[0])\\n    }\\n\\n    let color = new Array(n+1).fill(-1);\\n    let dfs = function(i) {\\n        for (let c of adj[i]) {\\n            if (color[c] == color[i]) return false;\\n            if (color[c] == -1) {\\n                color[c] = 1 - color[i]\\n                if (!dfs(c)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (color[i] == -1) {\\n            color[i] = 0\\n            if (!dfs(i)) return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2936772,
                "title": "a-terrible-iterative-python-solution-using-far-too-many-parallel-data-structures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI immediately recognized this as a Union-Find problem, then wasted a bunch of time trying to code that from memory. I am trying blind challenges, so not allowing myself to look things up  while coming up with a solution. Failing that, I decided to attemp a BFS solution, but iterative instead of just writing a recursive one like I should have. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSpaghetti. Its pretty logical, but I have $$way$$ too many copies of data: there is an adjacency map for the dislikes, an array for storing which group each node was assigned, a set for each of our two potential groups, $$another$$ set for the union of the dislikes for each member of each group... \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNo idea. We process each node in the for loop, so thats O(n), and for each of those we touch every neighbor, so O(n**2) worst case?\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTecnically O(n), but too many copies of len(n).  \\n\\n\\n# Code\\n```\\n\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        if not dislikes:\\n            return True\\n\\n        hate_dict = collections.defaultdict(list)\\n        for x,y in dislikes:\\n            hate_dict[x].append(y) \\n            hate_dict[y].append(x)         \\n        \\n        group = [\"x\"]*(n+1)\\n\\n        for curr in range(1,n+1):\\n            if group[curr] != \"x\":\\n                continue\\n            group[curr] = \"a\"\\n            b_queue = set(hate_dict[curr])\\n            a_hates = set(hate_dict[curr])\\n            a_queue = set()\\n            b_hates = set()\\n            while a_queue or b_queue:\\n                while b_queue:\\n                    adj = b_queue.pop()\\n                    if group[adj] == group[curr] or adj in b_hates:\\n                        return False\\n                    elif group[adj] == \"x\":\\n                        group[adj] = \"b\"\\n                        a_queue |= set([x for x in hate_dict[adj] if group[x] == \"x\"])\\n                        b_hates |=  set(hate_dict[adj])\\n                while a_queue:\\n                    adj = a_queue.pop()\\n                    if group[adj] == group[curr] or adj in a_hates:\\n                        return False\\n                    elif group[adj] == \"x\":\\n                        group[adj] = \"a\"\\n                        b_queue |= set([x for x in hate_dict[adj] if group[x] == \"x\"])\\n                        a_hates |=  set(hate_dict[adj])\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        if not dislikes:\\n            return True\\n\\n        hate_dict = collections.defaultdict(list)\\n        for x,y in dislikes:\\n            hate_dict[x].append(y) \\n            hate_dict[y].append(x)         \\n        \\n        group = [\"x\"]*(n+1)\\n\\n        for curr in range(1,n+1):\\n            if group[curr] != \"x\":\\n                continue\\n            group[curr] = \"a\"\\n            b_queue = set(hate_dict[curr])\\n            a_hates = set(hate_dict[curr])\\n            a_queue = set()\\n            b_hates = set()\\n            while a_queue or b_queue:\\n                while b_queue:\\n                    adj = b_queue.pop()\\n                    if group[adj] == group[curr] or adj in b_hates:\\n                        return False\\n                    elif group[adj] == \"x\":\\n                        group[adj] = \"b\"\\n                        a_queue |= set([x for x in hate_dict[adj] if group[x] == \"x\"])\\n                        b_hates |=  set(hate_dict[adj])\\n                while a_queue:\\n                    adj = a_queue.pop()\\n                    if group[adj] == group[curr] or adj in a_hates:\\n                        return False\\n                    elif group[adj] == \"x\":\\n                        group[adj] = \"a\"\\n                        b_queue |= set([x for x in hate_dict[adj] if group[x] == \"x\"])\\n                        a_hates |=  set(hate_dict[adj])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936644,
                "title": "possible-bipartition",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int node,int c,vector<int>arr[],vector<int>&col){\\n    // vis[node]=1;\\n    col[node]=c;\\n    for(int child:arr[node]){\\n        if(col[child]==-1){\\n            if(dfs(child,c^1,arr,col)==false)\\n            return false;\\n        }\\n        else \\n        if(col[node]==col[child])\\n         return false;\\n    }\\n    return true;\\n     \\n}\\n    bool possibleBipartition(int n, vector<vector<int>>&edges) {\\n        vector<int>arr[2001];\\n        // vector<int>vis(2001,0);\\n        vector<int>col(2001,-1);\\n        for(int i=0;i<edges.size();i++){\\n            arr[edges[i][0]].push_back(edges[i][1]);\\n\\t\\t    arr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        bool ans;\\n        for(int i=1;i<=n;i++){\\n            if(col[i]==-1){\\n             ans=dfs(i,0,arr,col);\\n            }\\n            if(ans==false) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\nbool dfs(int node,int c,vector<int>arr[],vector<int>&col){\\n    // vis[node]=1;\\n    col[node]=c;\\n    for(int child:arr[node]){\\n        if(col[child]==-1){\\n            if(dfs(child,c^1,arr,col)==false)\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2936413,
                "title": "c-using-union-find-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, int> UF, pre;\\n    int Find(int i){\\n        while(UF[i]!=i){\\n            i = UF[i];\\n        }\\n        return i;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        if(dislikes.size()==0) return true;\\n\\n        for(auto &dislike:dislikes){\\n            // initialize root & leaf\\n            if(UF.find(dislike[0])==UF.end()){\\n                UF[dislike[0]] = dislike[0];\\n            }\\n            if(UF.find(dislike[1])==UF.end()){\\n                UF[dislike[1]] = dislike[1];\\n            }\\n            // if we seen dislike[1] before, set the root of UF[dislike[0]] to a different group than dislike[1]\\n            if(UF[dislike[0]] == dislike[0] && pre.find(dislike[1])!=pre.end()){\\n                UF[dislike[0]] = Find(pre[dislike[1]]);\\n            }\\n            // if we seen dislike[0] before, set the root of UF[dislike[1]] to a different group than dislike[0]\\n            if(UF[dislike[1]] == dislike[1] && pre.find(dislike[0])!=pre.end()){\\n                UF[dislike[1]] = Find(pre[dislike[0]]);\\n            }\\n\\n            // find root of dislike\\n            int root1 = Find(dislike[0]);\\n            int root2 = Find(dislike[1]);\\n            \\n            // if root of dislikes are same, return false!!\\n            if(root1==root2){\\n                return false;\\n            }\\n\\n            // record another group dislike belong to\\n            pre[dislike[0]] = dislike[1];\\n            pre[dislike[1]] = dislike[0];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> UF, pre;\\n    int Find(int i){\\n        while(UF[i]!=i){\\n            i = UF[i];\\n        }\\n        return i;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        if(dislikes.size()==0) return true;\\n\\n        for(auto &dislike:dislikes){\\n            // initialize root & leaf\\n            if(UF.find(dislike[0])==UF.end()){\\n                UF[dislike[0]] = dislike[0];\\n            }\\n            if(UF.find(dislike[1])==UF.end()){\\n                UF[dislike[1]] = dislike[1];\\n            }\\n            // if we seen dislike[1] before, set the root of UF[dislike[0]] to a different group than dislike[1]\\n            if(UF[dislike[0]] == dislike[0] && pre.find(dislike[1])!=pre.end()){\\n                UF[dislike[0]] = Find(pre[dislike[1]]);\\n            }\\n            // if we seen dislike[0] before, set the root of UF[dislike[1]] to a different group than dislike[0]\\n            if(UF[dislike[1]] == dislike[1] && pre.find(dislike[0])!=pre.end()){\\n                UF[dislike[1]] = Find(pre[dislike[0]]);\\n            }\\n\\n            // find root of dislike\\n            int root1 = Find(dislike[0]);\\n            int root2 = Find(dislike[1]);\\n            \\n            // if root of dislikes are same, return false!!\\n            if(root1==root2){\\n                return false;\\n            }\\n\\n            // record another group dislike belong to\\n            pre[dislike[0]] = dislike[1];\\n            pre[dislike[1]] = dislike[0];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936192,
                "title": "c-graph-best-first-search-depth-first-search-easy-to-understand-easy-to-code",
                "content": "# Intuition\\nIt is similar to famous graph coloring vertex problem.\\n\\n# Approach\\nIn this parent and child should not contain same group. If it happens then return false.\\n\\n# Complexity\\n- Time complexity:\\nO(V) --> V is the vertex of the graph.\\n\\n- Space complexity:\\nO(V^2) ---> V is the vertex of the graph.\\n\\n# Code\\n```\\nbool bfs(unordered_map<int, vector<int>> neighbour, vector<int> &groups, int src)\\n{\\n    queue<int> q;\\n    q.push(src);\\n    groups[src] = 1;\\n\\n    while (!q.empty())\\n    {\\n        int element = q.front();\\n        q.pop();\\n\\n        for (auto neigh : neighbour[element])\\n        {\\n            if (groups[neigh] == groups[element])\\n            {\\n                return false;\\n            }\\n            if (groups[neigh] == -1)\\n            {\\n                q.push(neigh);\\n                groups[neigh] = abs(1 - groups[element]);\\n            }\\n        }\\n    }\\n    for (auto element : groups)\\n    {\\n        cout << element << \" \";\\n    }\\n    cout << endl;\\n    return true;\\n}\\n\\nbool possibleBipartition(int n, vector<vector<int>> &dislikes)\\n{\\n    unordered_map<int, vector<int>> neighbour;\\n\\n    for (int i = 0; i < dislikes.size(); i++)\\n    {\\n        neighbour[dislikes[i][0]].push_back(dislikes[i][1]);\\n        neighbour[dislikes[i][1]].push_back(dislikes[i][0]);\\n    }\\n\\n    for (auto element : neighbour)\\n    {\\n        cout << element.first << \" --> \";\\n        for (auto j : element.second)\\n        {\\n            cout << j << \" \";\\n        }\\n        cout << endl;\\n    }\\n\\n    vector<int> groups(n + 1, -1);\\n    vector<bool> visited(n + 1, false);\\n\\n    for (int i = 1; i <= n; i++)\\n    {\\n        if (groups[i] == -1)\\n        {\\n            if (!bfs(neighbour, groups, i))\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nbool bfs(unordered_map<int, vector<int>> neighbour, vector<int> &groups, int src)\\n{\\n    queue<int> q;\\n    q.push(src);\\n    groups[src] = 1;\\n\\n    while (!q.empty())\\n    {\\n        int element = q.front();\\n        q.pop();\\n\\n        for (auto neigh : neighbour[element])\\n        {\\n            if (groups[neigh] == groups[element])\\n            {\\n                return false;\\n            }\\n            if (groups[neigh] == -1)\\n            {\\n                q.push(neigh);\\n                groups[neigh] = abs(1 - groups[element]);\\n            }\\n        }\\n    }\\n    for (auto element : groups)\\n    {\\n        cout << element << \" \";\\n    }\\n    cout << endl;\\n    return true;\\n}\\n\\nbool possibleBipartition(int n, vector<vector<int>> &dislikes)\\n{\\n    unordered_map<int, vector<int>> neighbour;\\n\\n    for (int i = 0; i < dislikes.size(); i++)\\n    {\\n        neighbour[dislikes[i][0]].push_back(dislikes[i][1]);\\n        neighbour[dislikes[i][1]].push_back(dislikes[i][0]);\\n    }\\n\\n    for (auto element : neighbour)\\n    {\\n        cout << element.first << \" --> \";\\n        for (auto j : element.second)\\n        {\\n            cout << j << \" \";\\n        }\\n        cout << endl;\\n    }\\n\\n    vector<int> groups(n + 1, -1);\\n    vector<bool> visited(n + 1, false);\\n\\n    for (int i = 1; i <= n; i++)\\n    {\\n        if (groups[i] == -1)\\n        {\\n            if (!bfs(neighbour, groups, i))\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2935148,
                "title": "python-faster-than-96-bfs-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/e14ece7e-87b7-417e-89ab-b85c386573af_1671617901.9141054.png)\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        def bfs(i):     \\n            q = deque([i])\\n            color[i] = -1\\n            while q:\\n                node = q.popleft()\\n                for neighbor in adjList[node]:\\n                    if color[node] == color[neighbor]:\\n                        return False\\n\\n                    if color[neighbor] == 0:\\n                        q.append(neighbor)\\n\\n                    if color[node] == -1:\\n                        color[neighbor] = 1\\n\\n                    else:\\n                        color[neighbor] = -1\\n\\n            return True\\n\\n        adjList = [[] for _ in range(n + 1)]\\n        for n1, n2 in dislikes:\\n            adjList[n1].append(n2)\\n            adjList[n2].append(n1)\\n\\n        color = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            if color[i] == 0:\\n                if not bfs(i):\\n                    return False\\n\\n        return True\\n```\\n# Please upvote if you find this helpful",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        def bfs(i):     \\n            q = deque([i])\\n            color[i] = -1\\n            while q:\\n                node = q.popleft()\\n                for neighbor in adjList[node]:\\n                    if color[node] == color[neighbor]:\\n                        return False\\n\\n                    if color[neighbor] == 0:\\n                        q.append(neighbor)\\n\\n                    if color[node] == -1:\\n                        color[neighbor] = 1\\n\\n                    else:\\n                        color[neighbor] = -1\\n\\n            return True\\n\\n        adjList = [[] for _ in range(n + 1)]\\n        for n1, n2 in dislikes:\\n            adjList[n1].append(n2)\\n            adjList[n2].append(n1)\\n\\n        color = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            if color[i] == 0:\\n                if not bfs(i):\\n                    return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934970,
                "title": "check-adjacent-nodes-c",
                "content": "### ***Intution***:\\n\\t[1,2],[2,3],[3,4]\\n\\t\\n\\t       G1                      G2 \\n\\t\\t\\t1 --------------------- 2\\n\\t\\t\\t3 --------------------- 4\\n\\t\\n\\tThe above graph is biparitie graph\\n\\t\\n\\t[1,2],[1,3],[2,3]\\n\\t\\n\\t\\t\\tG1                      G2 \\n\\t\\t\\t1 --------------------- 2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t1 --------------------- 3\\n\\t\\t\\t\\n\\t\\tHere in above graph we can see there is edge between 2,3 in G2 then it is not bipartite graph.\\n\\n### ***Approach***:\\n\\n* First we generate the adjecency list. (for example [1,2],[2,3],[3,4])\\n\\t```\\n\\t1 -> 2,3\\n\\t2 -> 4\\n\\t3 -> 1\\n\\t4 -> 2\\n\\t```\\n* For checking bipartition we will use colouring.\\n```\\n\\tindex     1  2  3  4\\n\\tcolour   -1 -1 -1 -1\\n\\t\\n\\tqueue : 1\\n\\t\\n\\tfrom adjacency list for node = 1\\n\\tindex     1  2  3  4\\n\\tcolour    1 -1 -1 -1\\n\\t\\n\\tthen add all 1\\'s adjacent nodes into queue and pop 1\\n\\t\\n\\tqueue : 2,3\\n\\t\\n\\tfor 2,   colour[2] = 1-colour[curr] (here colour[2] = 1 - 1 = 0) (here curr is from which node 2 is inserted means here it is 1)\\n\\tindex     1  2  3  4\\n\\tcolour    1  0 -1 -1\\n\\t\\n\\tthen add all 2\\'s adjacent nodes into queue and pop 2\\n\\t\\n\\tqueue : 3,4\\n\\t\\n\\tfor 3,   colour[3] = 1-colour[curr] (curr = 1)\\n\\tindex     1  2  3  4\\n\\tcolour    1  0  0 -1\\n\\t\\n\\tthen add all 3\\'s adjacent nodes into queue and pop 3\\n\\t\\n\\tqueue : 4,1\\n\\t\\n\\tfor 4,   colour[4] = 1-colour[curr] (here curr = 2) (colour[4] = 1-0 = 1)\\n\\tindex     1  2  3  4\\n\\tcolour    1  0  0  1\\n\\t\\n\\tall nodes are visited hence it returns true\\n\\t\\n\\tif any node is having same colour as from which node it is inserted then it will return false\\n```\\n\\n### ***Code:***\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>&adj,int n,int node,vector<int>&color)\\n    {\\n        queue<int>q;\\n        q.push(node);\\n        color[node] = 1;\\n        \\n        while(!q.empty())\\n        {\\n            int cur = q.front();\\n            q.pop();\\n            \\n\\t\\t\\t// traversing all adjacent nodes of cur node\\n            for(auto i:adj[cur])\\n            {\\n\\t\\t\\t\\t// if cur node color and adjacent node color is same then biparitition is not possible\\n                if(color[cur] == color[i])\\n                    return false;\\n                \\n\\t\\t\\t\\t// assign color and add node into queue\\n                if(color[i] == -1)\\n                {\\n                    color[i] = 1-color[cur];\\n                    q.push(i);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if all traversed then return true\\n        return true;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dl) \\n    {\\n\\t\\t// generating adjacency list\\n        vector<vector<int>>adj(n+1);\\n        for(auto i:dl)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int>color(n+1,-1);\\n        \\n        for(int i = 1;i<=n;i++)\\n        {\\n            if(color[i] == -1)\\n            {\\n\\t\\t\\t\\t// if bipartition is not possible then return false\\n                if(not isBipartite(adj,n,i,color))\\n                    return false;\\n            }\\n        }\\n\\t\\t// else return true\\n        return true;\\n    }\\n};\\n```\\n\\t\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\t1 -> 2,3\\n\\t2 -> 4\\n\\t3 -> 1\\n\\t4 -> 2\\n\\t```\n```\\n\\tindex     1  2  3  4\\n\\tcolour   -1 -1 -1 -1\\n\\t\\n\\tqueue : 1\\n\\t\\n\\tfrom adjacency list for node = 1\\n\\tindex     1  2  3  4\\n\\tcolour    1 -1 -1 -1\\n\\t\\n\\tthen add all 1\\'s adjacent nodes into queue and pop 1\\n\\t\\n\\tqueue : 2,3\\n\\t\\n\\tfor 2,   colour[2] = 1-colour[curr] (here colour[2] = 1 - 1 = 0) (here curr is from which node 2 is inserted means here it is 1)\\n\\tindex     1  2  3  4\\n\\tcolour    1  0 -1 -1\\n\\t\\n\\tthen add all 2\\'s adjacent nodes into queue and pop 2\\n\\t\\n\\tqueue : 3,4\\n\\t\\n\\tfor 3,   colour[3] = 1-colour[curr] (curr = 1)\\n\\tindex     1  2  3  4\\n\\tcolour    1  0  0 -1\\n\\t\\n\\tthen add all 3\\'s adjacent nodes into queue and pop 3\\n\\t\\n\\tqueue : 4,1\\n\\t\\n\\tfor 4,   colour[4] = 1-colour[curr] (here curr = 2) (colour[4] = 1-0 = 1)\\n\\tindex     1  2  3  4\\n\\tcolour    1  0  0  1\\n\\t\\n\\tall nodes are visited hence it returns true\\n\\t\\n\\tif any node is having same colour as from which node it is inserted then it will return false\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>&adj,int n,int node,vector<int>&color)\\n    {\\n        queue<int>q;\\n        q.push(node);\\n        color[node] = 1;\\n        \\n        while(!q.empty())\\n        {\\n            int cur = q.front();\\n            q.pop();\\n            \\n\\t\\t\\t// traversing all adjacent nodes of cur node\\n            for(auto i:adj[cur])\\n            {\\n\\t\\t\\t\\t// if cur node color and adjacent node color is same then biparitition is not possible\\n                if(color[cur] == color[i])\\n                    return false;\\n                \\n\\t\\t\\t\\t// assign color and add node into queue\\n                if(color[i] == -1)\\n                {\\n                    color[i] = 1-color[cur];\\n                    q.push(i);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if all traversed then return true\\n        return true;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dl) \\n    {\\n\\t\\t// generating adjacency list\\n        vector<vector<int>>adj(n+1);\\n        for(auto i:dl)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int>color(n+1,-1);\\n        \\n        for(int i = 1;i<=n;i++)\\n        {\\n            if(color[i] == -1)\\n            {\\n\\t\\t\\t\\t// if bipartition is not possible then return false\\n                if(not isBipartite(adj,n,i,color))\\n                    return false;\\n            }\\n        }\\n\\t\\t// else return true\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934649,
                "title": "c-solution-with-detailed-approach",
                "content": "# Approach\\n1. Create a graph with the given dislikes\\n2. Use DFS to traverse the graph\\n3. If the node is not colored, color it with the given color\\n4. If the node is colored, check if the color is the same as the given color\\n5. If the color is different, return false\\n6. If the color is the same, return true\\n7. If all the nodes are colored, return true\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the number of dislikes\\n\\n- Space complexity:\\nO(n) where n is the number of dislikes\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool PossibleBipartition(int N, int[][] dislikes)\\n    {\\n        var graph = new List<int>[N + 1];\\n        for (var i = 1; i <= N; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n\\n        foreach (var dislike in dislikes)\\n        {\\n            graph[dislike[0]].Add(dislike[1]);\\n            graph[dislike[1]].Add(dislike[0]);\\n        }\\n\\n        var colors = new int[N + 1];\\n        for (var i = 1; i <= N; i++)\\n        {\\n            if (colors[i] == 0 && !DFS(graph, colors, i, 1))\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool DFS(List<int>[] graph, int[] colors, int node, int color)\\n    {\\n        if (colors[node] != 0)\\n        {\\n            return colors[node] == color;\\n        }\\n\\n        colors[node] = color;\\n        foreach (var neighbor in graph[node])\\n        {\\n            if (!DFS(graph, colors, neighbor, -color))\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool PossibleBipartition(int N, int[][] dislikes)\\n    {\\n        var graph = new List<int>[N + 1];\\n        for (var i = 1; i <= N; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n\\n        foreach (var dislike in dislikes)\\n        {\\n            graph[dislike[0]].Add(dislike[1]);\\n            graph[dislike[1]].Add(dislike[0]);\\n        }\\n\\n        var colors = new int[N + 1];\\n        for (var i = 1; i <= N; i++)\\n        {\\n            if (colors[i] == 0 && !DFS(graph, colors, i, 1))\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool DFS(List<int>[] graph, int[] colors, int node, int color)\\n    {\\n        if (colors[node] != 0)\\n        {\\n            return colors[node] == color;\\n        }\\n\\n        colors[node] = color;\\n        foreach (var neighbor in graph[node])\\n        {\\n            if (!DFS(graph, colors, neighbor, -color))\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934578,
                "title": "java-o-v-e-dfs",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\nDFS with assuming 0 as not visited. 1 or -1 for one group or other\\n# Complexity\\n- Time complexity:\\nO(V+E) where v is the number of verticies and E - number of edges\\n\\n- Space complexity:\\nStack space\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    Map<Integer,List<Integer>> graph;\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if (dislikes == null || dislikes.length == 0)\\n            return true;\\n\\n        graph = new HashMap<>();\\n        for(int[] dislik: dislikes){\\n            int hater = dislik[0];\\n            int hatee = dislik[1];\\n            graph.putIfAbsent(hatee, new ArrayList<>());\\n            graph.putIfAbsent(hater, new ArrayList<>());\\n            graph.get(hater).add(hatee);\\n            graph.get(hatee).add(hater);\\n        }\\n\\n        int[] color = new int[1+n];\\n        for(int i = 1; i <= n; i++){\\n            if (color[i] == 0){\\n                if (!dfs(i, color, color[i]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int u, int[] color, int curColor){\\n        if (curColor == 0){\\n            color[u] = 1;\\n        } else {\\n            color[u] = curColor;\\n        }\\n\\n        if (!graph.containsKey(u))\\n            return true;\\n        for(int adjVert: graph.get(u)){\\n            if (color[adjVert] == color[u]){\\n                return false;\\n            }\\n            if (color[adjVert] != 0)\\n                continue;\\n            if (!dfs(adjVert, color, -1*color[u]))\\n                return false;\\n        }\\n        return true; \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    Map<Integer,List<Integer>> graph;\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if (dislikes == null || dislikes.length == 0)\\n            return true;\\n\\n        graph = new HashMap<>();\\n        for(int[] dislik: dislikes){\\n            int hater = dislik[0];\\n            int hatee = dislik[1];\\n            graph.putIfAbsent(hatee, new ArrayList<>());\\n            graph.putIfAbsent(hater, new ArrayList<>());\\n            graph.get(hater).add(hatee);\\n            graph.get(hatee).add(hater);\\n        }\\n\\n        int[] color = new int[1+n];\\n        for(int i = 1; i <= n; i++){\\n            if (color[i] == 0){\\n                if (!dfs(i, color, color[i]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int u, int[] color, int curColor){\\n        if (curColor == 0){\\n            color[u] = 1;\\n        } else {\\n            color[u] = curColor;\\n        }\\n\\n        if (!graph.containsKey(u))\\n            return true;\\n        for(int adjVert: graph.get(u)){\\n            if (color[adjVert] == color[u]){\\n                return false;\\n            }\\n            if (color[adjVert] != 0)\\n                continue;\\n            if (!dfs(adjVert, color, -1*color[u]))\\n                return false;\\n        }\\n        return true; \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934507,
                "title": "easy-depth-first-search-solution-golang",
                "content": "# Intuition\\nIf we allot a person with group 1 than all of its neighbour should be alloted with group 2. (Check if graph is Bipatite or not)\\n# Approach\\nDo DFS in such a way that if we allot group 1 to given person than all of its neighbour would be alloted with group 2.If at any point neighbour and current element are in same group that means we can\\'t distribute the persons in different groups.\\n\\n# Complexity\\n- Time complexity: O(N+M)\\n\\n- Space complexity:O(N)\\n# Code\\n```\\nfunc dfs(arr [][]int,s int,f bool, vis map[int]bool) bool{\\n    vis[s] = f\\n    for _,ele := range arr[s] {\\n        if _,ok := vis[ele]; !ok{\\n            if dfs(arr,ele,!f,vis) {\\n                return true\\n            }\\n        } else if f1,_ := vis[ele]; f1==f{\\n            return true\\n        }\\n    }\\n    return false\\n}\\nfunc possibleBipartition(n int, dislikes [][]int) bool {\\n    vis := make(map[int]bool)\\n    arr := make([][]int,n+1)\\n    for _,dis := range dislikes {\\n        var person1 int = dis[0]\\n        var person2 int = dis[1]\\n        arr[person1] = append(arr[person1],person2)\\n        arr[person2] = append(arr[person2],person1)\\n    }\\n\\n    for i := 1; i<=n ; i++ {\\n        if _,ok := vis[i] ; !ok {\\n            if(dfs(arr,i,false,vis)){\\n                return false;\\n            }\\n        }\\n    }\\n    return true \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc dfs(arr [][]int,s int,f bool, vis map[int]bool) bool{\\n    vis[s] = f\\n    for _,ele := range arr[s] {\\n        if _,ok := vis[ele]; !ok{\\n            if dfs(arr,ele,!f,vis) {\\n                return true\\n            }\\n        } else if f1,_ := vis[ele]; f1==f{\\n            return true\\n        }\\n    }\\n    return false\\n}\\nfunc possibleBipartition(n int, dislikes [][]int) bool {\\n    vis := make(map[int]bool)\\n    arr := make([][]int,n+1)\\n    for _,dis := range dislikes {\\n        var person1 int = dis[0]\\n        var person2 int = dis[1]\\n        arr[person1] = append(arr[person1],person2)\\n        arr[person2] = append(arr[person2],person1)\\n    }\\n\\n    for i := 1; i<=n ; i++ {\\n        if _,ok := vis[i] ; !ok {\\n            if(dfs(arr,i,false,vis)){\\n                return false;\\n            }\\n        }\\n    }\\n    return true \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2934423,
                "title": "python-color-solution-video-solution",
                "content": "I have explained this [here](https://youtu.be/Zqvdg0TmAnE).\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        \\n        g = defaultdict(list)\\n        for x,y in dislikes:\\n            g[x].append(y)\\n            g[y].append(x)\\n        \\n        color = {}\\n        \\n        def dfs(i, c):\\n            color[i] = c\\n            for enemy in g[i]:\\n                if enemy in color:\\n                    # if enemy has same color, then return False directly\\n                    if color[enemy]==c:\\n                        return False\\n                else:\\n                    # assign inverted color to enemy and check for anomalies\\n                    if not dfs(enemy, 1-c):\\n                        return False\\n            return True\\n            \\n        for i in range(1, n+1):\\n            if i not in color:\\n                # assign color 1 and check for anomalies\\n                if not dfs(i, 1):\\n                    return False\\n         \\n\\t\\t # We found no anomaly, so return True\\n        return True",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        \\n        g = defaultdict(list)\\n        for x,y in dislikes:\\n            g[x].append(y)\\n            g[y].append(x)\\n        \\n        color = {}",
                "codeTag": "Java"
            },
            {
                "id": 2934346,
                "title": "c-easy-bfs-graph-coloring",
                "content": "# Intuition\\nLets understand the problem first, and think in terms of graph. Then you will understand that the adjacent nodes should not have the same group. Thus we must place them in different groups.\\n    If we observed carefully, and think that we can assign them some  colors like 0 or 1 and check all constraints are satisfied or not. Like if a node is already assigned 1 then we should not give it 0 as color. \\n\\n# Approach\\n    Here we need to deal with the adjacent nodes, a bfs will be very easy approach towards this problem. \\n    For each connected component we will give it a color and try bfs and check for the constraints recursively\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        if(dislikes.empty()) return true;\\n        //lets understand the problem, if we connect the nodes based on dislikes,\\n        //then we will not be able to place two adjacent nodes in a same group,\\n        //thus we need to place adjacent nodes in different two groups\\n        //we can mark them with 1 or 0 as colors assigned to them and then easily check;\\n\\n        unordered_map<int,vector<int>> g;\\n        for(vector<int>&a: dislikes){\\n            g[a[0]].push_back(a[1]);\\n            g[a[1]].push_back(a[0]);\\n\\n        }\\n\\n        vector<int> cols(1+n, -1);\\n        queue<int> q;\\n    \\n        bool ans = true;\\n\\n        //we will recursively go through the loop because disjoint components may occur\\n        int i = 1;\\n        while(i <= n){\\n            if(cols[i]==-1){\\n                q.push(i);\\n                cols[i] = 1; // initializing the colour of first element with 1\\n                ans &= checkbfs(cols, g, q);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n    bool checkbfs(vector<int> &cols, unordered_map<int,vector<int>> &g, queue<int> &q){\\n    \\n        int curr=1;\\n        while(!q.empty()){\\n\\n            int size = q.size();\\n\\n            for(int k = 0;k<size; k++){\\n\\n                vector<int> &a = g[q.front()];\\n                q.pop();\\n                for(int i: a){\\n                    \\n                    if(cols[i]!=-1){\\n                        if(cols[i]==abs(curr-1)){\\n                            //its okay\\n                            continue;\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                    }else{\\n                        cols[i] = abs(curr-1);\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n            curr  = abs(curr-1);\\n        }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        if(dislikes.empty()) return true;\\n        //lets understand the problem, if we connect the nodes based on dislikes,\\n        //then we will not be able to place two adjacent nodes in a same group,\\n        //thus we need to place adjacent nodes in different two groups\\n        //we can mark them with 1 or 0 as colors assigned to them and then easily check;\\n\\n        unordered_map<int,vector<int>> g;\\n        for(vector<int>&a: dislikes){\\n            g[a[0]].push_back(a[1]);\\n            g[a[1]].push_back(a[0]);\\n\\n        }\\n\\n        vector<int> cols(1+n, -1);\\n        queue<int> q;\\n    \\n        bool ans = true;\\n\\n        //we will recursively go through the loop because disjoint components may occur\\n        int i = 1;\\n        while(i <= n){\\n            if(cols[i]==-1){\\n                q.push(i);\\n                cols[i] = 1; // initializing the colour of first element with 1\\n                ans &= checkbfs(cols, g, q);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n    bool checkbfs(vector<int> &cols, unordered_map<int,vector<int>> &g, queue<int> &q){\\n    \\n        int curr=1;\\n        while(!q.empty()){\\n\\n            int size = q.size();\\n\\n            for(int k = 0;k<size; k++){\\n\\n                vector<int> &a = g[q.front()];\\n                q.pop();\\n                for(int i: a){\\n                    \\n                    if(cols[i]!=-1){\\n                        if(cols[i]==abs(curr-1)){\\n                            //its okay\\n                            continue;\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                    }else{\\n                        cols[i] = abs(curr-1);\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n            curr  = abs(curr-1);\\n        }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934223,
                "title": "easy-dfs-solution-bipartite-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPartition into two sets means bipartite graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the DFS approach to check the bipartition\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCycle(int src,vector <int> adj[],vector <int> &col){\\n\\n        if(col[src]==-1){\\n            col[src]=1;\\n        }\\n\\n        for(int x: adj[src]){\\n           if(col[x]==-1){\\n               col[x]=1-col[src];\\n               if(!isCycle(x,adj,col)){\\n                   return false;\\n               }\\n           }\\n           else if(col[x]==col[src]){\\n               return false;\\n           }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n\\n        vector <int> adj[n+1];\\n\\n        for(int i=0;i<dislikes.size();i++){\\n            int u=dislikes[i][0];\\n            int v=dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector <int> col(n+1,-1);\\n        for(int i=1;i<=n;i++){\\n\\n            if(col[i]==-1){\\n                if(!isCycle(i,adj,col)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int src,vector <int> adj[],vector <int> &col){\\n\\n        if(col[src]==-1){\\n            col[src]=1;\\n        }\\n\\n        for(int x: adj[src]){\\n           if(col[x]==-1){\\n               col[x]=1-col[src];\\n               if(!isCycle(x,adj,col)){\\n                   return false;\\n               }\\n           }\\n           else if(col[x]==col[src]){\\n               return false;\\n           }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n\\n        vector <int> adj[n+1];\\n\\n        for(int i=0;i<dislikes.size();i++){\\n            int u=dislikes[i][0];\\n            int v=dislikes[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector <int> col(n+1,-1);\\n        for(int i=1;i<=n;i++){\\n\\n            if(col[i]==-1){\\n                if(!isCycle(i,adj,col)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933873,
                "title": "daily-leetcoding-challenge-december-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/possible-bipartition/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/possible-bipartition/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2901401,
                "title": "c-easy-to-understand-solution-human-readable-dfs-bfs",
                "content": "### Descriptive Variable Names\\nJust follow the variable names to understand the algorithm, if you have any idea how can I improve further the readability just tell me \\uD83D\\uDE0A\\n\\n#### DFS\\n```\\nclass Solution {\\npublic:\\n    const int LIKE = 1;\\n    const int DISLIKE = -1;\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(n + 1);\\n        for(vector<int> person : dislikes) {\\n            graph[person[0]].push_back(person[1]);\\n            graph[person[1]].push_back(person[0]);\\n        }\\n        vector<int> likes(n + 1, 0);\\n        for(int person = 1; person <= n; person++) {\\n            if(likes[person]) continue;\\n            likes[person] = LIKE;\\n            if(hasMatchingLike(person, graph, likes)) \\n                return false;\\n        }\\n        return true;\\n    }\\n    bool hasMatchingLike(int person, vector<vector<int>> &graph, vector<int> &likes) {\\n        for(int neighbor_person : graph[person]) {\\n            if(!likes[neighbor_person]) {\\n                likes[neighbor_person] = likes[person] == LIKE ? DISLIKE : LIKE;\\n                if(hasMatchingLike(neighbor_person, graph, likes)) \\n                    return true;\\n            } else if(likes[neighbor_person] == likes[person]) \\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n#### BFS \\n```\\nclass Solution {\\npublic:\\n    const int LIKE = 1;\\n    const int DISLIKE = -1;\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(n + 1);\\n        for(vector<int> person : dislikes) {\\n            graph[person[0]].push_back(person[1]);\\n            graph[person[1]].push_back(person[0]);\\n        }\\n        vector<int> likes(n + 1, 0);\\n        queue<int> people_queue;\\n        for(int person = 1; person <= n; person++) {\\n            if(likes[person]) continue;\\n            people_queue.push(person);\\n            likes[person] = LIKE;\\n            while(!people_queue.empty()) {\\n                int current_person = people_queue.front();\\n                people_queue.pop();\\n                for(int neighbor_person : graph[current_person]) {\\n                    if(!likes[neighbor_person]) {\\n                        likes[neighbor_person] = likes[current_person] == LIKE ? DISLIKE : LIKE;\\n                        people_queue.push(neighbor_person);\\n                    } else if(likes[neighbor_person] == likes[current_person]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int LIKE = 1;\\n    const int DISLIKE = -1;\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(n + 1);\\n        for(vector<int> person : dislikes) {\\n            graph[person[0]].push_back(person[1]);\\n            graph[person[1]].push_back(person[0]);\\n        }\\n        vector<int> likes(n + 1, 0);\\n        for(int person = 1; person <= n; person++) {\\n            if(likes[person]) continue;\\n            likes[person] = LIKE;\\n            if(hasMatchingLike(person, graph, likes)) \\n                return false;\\n        }\\n        return true;\\n    }\\n    bool hasMatchingLike(int person, vector<vector<int>> &graph, vector<int> &likes) {\\n        for(int neighbor_person : graph[person]) {\\n            if(!likes[neighbor_person]) {\\n                likes[neighbor_person] = likes[person] == LIKE ? DISLIKE : LIKE;\\n                if(hasMatchingLike(neighbor_person, graph, likes)) \\n                    return true;\\n            } else if(likes[neighbor_person] == likes[person]) \\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    const int LIKE = 1;\\n    const int DISLIKE = -1;\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> graph(n + 1);\\n        for(vector<int> person : dislikes) {\\n            graph[person[0]].push_back(person[1]);\\n            graph[person[1]].push_back(person[0]);\\n        }\\n        vector<int> likes(n + 1, 0);\\n        queue<int> people_queue;\\n        for(int person = 1; person <= n; person++) {\\n            if(likes[person]) continue;\\n            people_queue.push(person);\\n            likes[person] = LIKE;\\n            while(!people_queue.empty()) {\\n                int current_person = people_queue.front();\\n                people_queue.pop();\\n                for(int neighbor_person : graph[current_person]) {\\n                    if(!likes[neighbor_person]) {\\n                        likes[neighbor_person] = likes[current_person] == LIKE ? DISLIKE : LIKE;\\n                        people_queue.push(neighbor_person);\\n                    } else if(likes[neighbor_person] == likes[current_person]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593419,
                "title": "clean-python3-bipartite-graph-w-bfs-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/86fd86f7-c0fe-4364-a34b-bbb02ba365a4_1663513377.4575992.png)\\nPlease upvote if it helps!\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        dislike = [[] for _ in range(n)]\\n        for a, b in dislikes:\\n            dislike[a-1].append(b-1)\\n            dislike[b-1].append(a-1)\\n\\n        groups = [0] * n\\n        for p in range(n):\\n            if groups[p] == 0:\\n                groups[p] = 1\\n                q = deque([p])\\n                while q: # bfs\\n                    a = q.pop()\\n                    for b in dislike[a]:\\n                        if groups[b] == 0:\\n                            groups[b] = 1 if groups[a] == 2 else 2\\n                            q.appendleft(b)\\n                        elif groups[a] == groups[b]:\\n                            return False\\n        return True",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/86fd86f7-c0fe-4364-a34b-bbb02ba365a4_1663513377.4575992.png)\\nPlease upvote if it helps!\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        dislike = [[] for _ in range(n)]\\n        for a, b in dislikes:\\n            dislike[a-1].append(b-1)\\n            dislike[b-1].append(a-1)\\n\\n        groups = [0] * n\\n        for p in range(n):\\n            if groups[p] == 0:\\n                groups[p] = 1\\n                q = deque([p])\\n                while q: # bfs\\n                    a = q.pop()\\n                    for b in dislike[a]:\\n                        if groups[b] == 0:\\n                            groups[b] = 1 if groups[a] == 2 else 2\\n                            q.appendleft(b)\\n                        elif groups[a] == groups[b]:\\n                            return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2478498,
                "title": "c-dfs-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs( vector<int> adj[],vector<int> &color,int node){\\n        bool ans=true;\\n        for(auto i: adj[node]){\\n            if(color[i]==-1){\\n                color[i]=1-color[node];\\n                ans=ans and dfs(adj,color,i);\\n            }\\n            else{\\n                if(color[i]==color[node]) return false;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        vector<int> color(n+1,-1);\\n        bool b=true;\\n        for(int i=1;i<=n;i++){\\n            if(color[i]==-1){\\n                color[i]=1;\\n                b=b and dfs(adj,color,i);\\n            }\\n        }\\n        return b;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs( vector<int> adj[],vector<int> &color,int node){\\n        bool ans=true;\\n        for(auto i: adj[node]){\\n            if(color[i]==-1){\\n                color[i]=1-color[node];\\n                ans=ans and dfs(adj,color,i);\\n            }\\n            else{\\n                if(color[i]==color[node]) return false;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        vector<int> color(n+1,-1);\\n        bool b=true;\\n        for(int i=1;i<=n;i++){\\n            if(color[i]==-1){\\n                color[i]=1;\\n                b=b and dfs(adj,color,i);\\n            }\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446014,
                "title": "simple-approach-with-comments-java",
                "content": "class Solution {\\n     public static boolean bfsCheck(ArrayList<ArrayList<Integer>> al,int color[],int src){\\n\\n         \\n         Queue<Integer> q= new LinkedList<>();\\n         q.add(src);\\n         \\n         //initalizing color[src]=1 so that other adjacent index can be different\\n         color[src] =1;\\n         \\n         while(!q.isEmpty())\\n         {\\n                Integer cur = q.poll();\\n              for(Integer i:al.get(cur))\\n              {\\n                \\n                  if(color[i]==-1)\\n                  {\\n                      color[i] = 1-color[cur];\\n                      q.add(i);\\n                  }\\n                  \\n                  //if color of index and adjacent index is same then return false\\n                  else if(color[i]==color[cur]){\\n                      return false;\\n                  }\\n              }    \\n         }\\n         return true;\\n        \\n     }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        //creating a color matrix\\n        int color[] = new int[n+1];\\n        \\n        //initializing all with -1\\n        for(int i=1;i<=n;i++)\\n            color[i]=-1;\\n        \\n        \\n        //converting matrix to adjacency list\\n        ArrayList<ArrayList<Integer>> al = new ArrayList<>();\\n        \\n        for(int i=1;i<=n+1;i++)\\n            al.add(new ArrayList());\\n        \\n        for(int i=0;i<dislikes.length;i++)\\n        {\\n           int a =  dislikes[i][0];\\n           int b =  dislikes[i][1];\\n           \\n          al.get(a).add(b); \\n        al.get(b).add(a);\\n        }\\n        //conversion completed\\n        \\n        \\n      //cheching with each index if it is bipartite or not\\n         for(int i=1;i<=n;i++)\\n         {\\n             if(color[i]==-1)\\n             {\\n                 if(bfsCheck(al,color,i)==false){\\n                    return false;}\\n             }\\n         }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n     public static boolean bfsCheck(ArrayList<ArrayList<Integer>> al,int color[],int src){\\n\\n         \\n         Queue<Integer> q= new LinkedList<>();\\n         q.add(src);\\n         \\n         //initalizing color[src]=1 so that other adjacent index can be different\\n         color[src] =1;\\n         \\n         while(!q.isEmpty())\\n         {\\n                Integer cur = q.poll();\\n              for(Integer i:al.get(cur))\\n              {\\n                \\n                  if(color[i]==-1)\\n                  {\\n                      color[i] = 1-color[cur];\\n                      q.add(i);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 2407658,
                "title": "c-graph-coloring-bfs",
                "content": "```\\n bool possibleBipartition(int n, vector<vector<int>>& d) {\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<d.size();i++){\\n            adj[d[i][0]-1].push_back(d[i][1]-1);\\n            adj[d[i][1]-1].push_back(d[i][0]-1);\\n        }\\n        vector<int>color(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                queue<int>q;\\n                q.push(i);\\n                color[i]=1;\\n                while(!q.empty()){\\n                    int x=q.front();\\n                    q.pop();\\n                    for(auto i:adj[x]){\\n                        if(color[i]==color[x])\\n                            return false;\\n                        else if(color[i]==-1){\\n                            color[i]=1-color[x];\\n                            q.push(i);\\n                        }\\n                    }\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n bool possibleBipartition(int n, vector<vector<int>>& d) {\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<d.size();i++){\\n            adj[d[i][0]-1].push_back(d[i][1]-1);\\n            adj[d[i][1]-1].push_back(d[i][0]-1);\\n        }\\n        vector<int>color(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                queue<int>q;\\n                q.push(i);\\n                color[i]=1;\\n                while(!q.empty()){\\n                    int x=q.front();\\n                    q.pop();\\n                    for(auto i:adj[x]){\\n                        if(color[i]==color[x])\\n                            return false;\\n                        else if(color[i]==-1){\\n                            color[i]=1-color[x];\\n                            q.push(i);\\n                        }\\n                    }\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2199247,
                "title": "using-concept-of-bipartite-graph-bfs",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def isBipartite(self, i, graph, color):\\n        color[i] = 1\\n        queue = deque([(i)])\\n        \\n        while queue:\\n            vertex = queue.popleft()\\n            for neighbour in graph[vertex]:\\n                if color[neighbour] == color[vertex]:\\n                    return False\\n                if color[neighbour] == -1:\\n                    color[neighbour] = 1 - color[vertex]\\n                    queue.append((neighbour))\\n        return True\\n        \\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        color = [-1]*(n+1)\\n        graph = {i:[] for i in range(1, n + 1)}\\n        \\n        for dislike in dislikes:\\n            graph[dislike[0]].append(dislike[1])\\n            graph[dislike[1]].append(dislike[0])\\n        \\n        \\n        for i in range(1, n + 1):\\n            if color[i] == -1:\\n                if not self.isBipartite(i, graph, color):\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def isBipartite(self, i, graph, color):\\n        color[i] = 1\\n        queue = deque([(i)])\\n        \\n        while queue:\\n            vertex = queue.popleft()\\n            for neighbour in graph[vertex]:\\n                if color[neighbour] == color[vertex]:\\n                    return False\\n                if color[neighbour] == -1:\\n                    color[neighbour] = 1 - color[vertex]\\n                    queue.append((neighbour))\\n        return True\\n        \\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        color = [-1]*(n+1)\\n        graph = {i:[] for i in range(1, n + 1)}\\n        \\n        for dislike in dislikes:\\n            graph[dislike[0]].append(dislike[1])\\n            graph[dislike[1]].append(dislike[0])\\n        \\n        \\n        for i in range(1, n + 1):\\n            if color[i] == -1:\\n                if not self.isBipartite(i, graph, color):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075916,
                "title": "python-bfs-simple-solution-with-explanation",
                "content": "#### This problem is same as [Is Graph Bipartite](https://leetcode.com/problems/is-graph-bipartite/)\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        graph = {_:[] for _ in range(1,n+1)}\\n        \\n        for person1, person2 in dislikes:\\n            graph[person1].append(person2)\\n            graph[person2].append(person1)\\n        \\n        # Initially no groups have been assigned to any person\\n        # Let their be two groups group#0 and group#1\\n        groups = {_:None for _ in range(1,n+1)}\\n        \\n        for person in range(1, n+1):\\n            if groups[person] == None:\\n                # If a person doesn\\'t have a group, assign group #1\\n                groups[person] = 1\\n                queue = deque([person])\\n                while queue:\\n                    currentPerson = queue.popleft()\\n                    for dislikedPerson in graph[currentPerson]:\\n                        if groups[dislikedPerson] == None:\\n                            # Since these two persons dislikes each other so put the second person(dislikedPerson) in another group.\\n                            groups[dislikedPerson] = 1 - groups[currentPerson]\\n                            queue.append(dislikedPerson)\\n                        elif groups[dislikedPerson] == groups[currentPerson]:\\n                            # Two persons in which one dislikes other can\\'t be in same group\\n                            return False\\n        \\n        return True\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        graph = {_:[] for _ in range(1,n+1)}\\n        \\n        for person1, person2 in dislikes:\\n            graph[person1].append(person2)\\n            graph[person2].append(person1)\\n        \\n        # Initially no groups have been assigned to any person\\n        # Let their be two groups group#0 and group#1\\n        groups = {_:None for _ in range(1,n+1)}\\n        \\n        for person in range(1, n+1):\\n            if groups[person] == None:\\n                # If a person doesn\\'t have a group, assign group #1\\n                groups[person] = 1\\n                queue = deque([person])\\n                while queue:\\n                    currentPerson = queue.popleft()\\n                    for dislikedPerson in graph[currentPerson]:\\n                        if groups[dislikedPerson] == None:\\n                            # Since these two persons dislikes each other so put the second person(dislikedPerson) in another group.\\n                            groups[dislikedPerson] = 1 - groups[currentPerson]\\n                            queue.append(dislikedPerson)\\n                        elif groups[dislikedPerson] == groups[currentPerson]:\\n                            # Two persons in which one dislikes other can\\'t be in same group\\n                            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046663,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        def dfs(i, color):\\n            if i in colors:\\n                return colors[i] == color\\n            colors[i] = color\\n            \\n            for neighbor in graph[i]:\\n                if not dfs(neighbor, 1-color):\\n                    return False\\n            return True\\n        \\n        graph = collections.defaultdict(list)\\n        colors = {}\\n        \\n        for u,v in dislikes:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        for i in range(1,n+1):\\n            if i not in colors and not dfs(i, 0):\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        def dfs(i, color):\\n            if i in colors:\\n                return colors[i] == color\\n            colors[i] = color\\n            \\n            for neighbor in graph[i]:\\n                if not dfs(neighbor, 1-color):\\n                    return False\\n            return True\\n        \\n        graph = collections.defaultdict(list)\\n        colors = {}\\n        \\n        for u,v in dislikes:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        for i in range(1,n+1):\\n            if i not in colors and not dfs(i, 0):\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038580,
                "title": "java-bfs-graph-coloring",
                "content": "```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n         Map<Integer, List<Integer>> mp = new HashMap<>();\\n    \\n        int[] color = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=1;i<=n;i++){\\n          mp.put(i, new ArrayList<>());\\n          \\n        }\\n        for(int i=0;i<dislikes.length;i++){\\n          mp.get(dislikes[i][0]).add(dislikes[i][1]);\\n          mp.get(dislikes[i][1]).add(dislikes[i][0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n          if(color[i]==-1){\\n            if(!bfs(mp, n, i, color)){\\n              return false;\\n            }\\n          }\\n        }\\n      return true;\\n        \\n    }\\n  \\n   public boolean bfs(Map<Integer, List<Integer>> adj, int n, int i, int[] color){\\n      Queue<Integer> q = new LinkedList<>();\\n      q.add(i);\\n      color[i]= 1;\\n      \\n     while(!q.isEmpty()){\\n       int curr = q.poll();\\n       for(int j : adj.get(curr)){\\n         if(color[j]==color[curr])return false;\\n         if(color[j]==-1){\\n           color[j] = color[curr]==1?0:1;\\n           q.add(j);\\n         }\\n       }\\n     }\\n     return true;\\n   }\\n  \\n  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n         Map<Integer, List<Integer>> mp = new HashMap<>();\\n    \\n        int[] color = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=1;i<=n;i++){\\n          mp.put(i, new ArrayList<>());\\n          \\n        }\\n        for(int i=0;i<dislikes.length;i++){\\n          mp.get(dislikes[i][0]).add(dislikes[i][1]);\\n          mp.get(dislikes[i][1]).add(dislikes[i][0]);\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n          if(color[i]==-1){\\n            if(!bfs(mp, n, i, color)){\\n              return false;\\n            }\\n          }\\n        }\\n      return true;\\n        \\n    }\\n  \\n   public boolean bfs(Map<Integer, List<Integer>> adj, int n, int i, int[] color){\\n      Queue<Integer> q = new LinkedList<>();\\n      q.add(i);\\n      color[i]= 1;\\n      \\n     while(!q.isEmpty()){\\n       int curr = q.poll();\\n       for(int j : adj.get(curr)){\\n         if(color[j]==color[curr])return false;\\n         if(color[j]==-1){\\n           color[j] = color[curr]==1?0:1;\\n           q.add(j);\\n         }\\n       }\\n     }\\n     return true;\\n   }\\n  \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989382,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] d){\\n        List<Integer>[] nm=new List[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            nm[i]=new ArrayList<>();\\n        }\\n        for(int k[]:d)\\n        {\\n            nm[k[0]].add(k[1]);\\n            nm[k[1]].add(k[0]);\\n        }\\n        int a[]=new int[n+1];\\n        Arrays.fill(a,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==-1)\\n            {\\n                Queue<Integer> kk=new LinkedList<>();\\n                kk.offer(i);\\n                a[i]=1;\\n                while(!(kk.isEmpty()))\\n                {\\n                    int p=kk.poll();\\n                    for(int f:nm[p])\\n                    {\\n                        if(a[f]==-1)\\n                        {\\n                            a[f]=1-a[p];\\n                            kk.offer(f);\\n                        }\\n                        else if(a[p]==a[f])\\n                            return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public boolean possibleBipartition(int n, int[][] d){\\n        List<Integer>[] nm=new List[n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            nm[i]=new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1900185,
                "title": "python-bfs-solution-using-graph-coloring",
                "content": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        \\n        \\n        adj=defaultdict(list)\\n        for x,y in dislikes:\\n            adj[x].append(y)\\n            adj[y].append(x)\\n        \\n        colors=[-1]*(n+1)\\n        \\n        def bfs(start):\\n            colors[start]=0\\n            q=[]\\n            q.append(start)\\n            \\n            while q:\\n                s=q.pop(0)\\n                for node in adj[s]:\\n                    if colors[node]==-1:\\n                        colors[node]=1-colors[s]\\n                        q.append(node)\\n                    else:\\n                        if colors[node]==colors[s]:\\n                            return False\\n            return True\\n        \\n        for i in range(1,n+1):\\n            if colors[i]==-1:\\n                if bfs(i)==False:\\n                    return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        \\n        \\n        adj=defaultdict(list)\\n        for x,y in dislikes:\\n            adj[x].append(y)\\n            adj[y].append(x)\\n        \\n        colors=[-1]*(n+1)\\n        \\n        def bfs(start):\\n            colors[start]=0\\n            q=[]\\n            q.append(start)\\n            \\n            while q:\\n                s=q.pop(0)\\n                for node in adj[s]:\\n                    if colors[node]==-1:\\n                        colors[node]=1-colors[s]\\n                        q.append(node)\\n                    else:\\n                        if colors[node]==colors[s]:\\n                            return False\\n            return True\\n        \\n        for i in range(1,n+1):\\n            if colors[i]==-1:\\n                if bfs(i)==False:\\n                    return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881504,
                "title": "a-bipartite-graph-should-not-have-an-odd-length-cycle-bfs-dfs",
                "content": "\\t\\n\\t// BFS \\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] visited = new int[n+1];\\n\\n        // construct adjList\\n        List<Integer>[] adjList = new List[n+1];\\n        for(int i=1; i<=n; i++) {\\n            adjList[i] = new LinkedList<>();\\n        }\\n\\n        for(int[] edge : dislikes) {\\n            adjList[edge[0]].add(edge[1]);\\n            adjList[edge[1]].add(edge[0]);\\n        }\\n\\n        for(int vertex=1; vertex<=n; vertex++) {\\n            if(visited[vertex] == 0 && !bfs(vertex, adjList, visited)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean bfs(int src, List<Integer>[] adjList, int[] visited) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(src);\\n        visited[src] = 1;\\n\\n        while(!queue.isEmpty()) {\\n            int vertex = queue.poll();\\n            for(int neighbor : adjList[vertex]) {\\n                if(visited[neighbor] == 0) {\\n                    queue.add(neighbor);\\n                    visited[neighbor] = visited[vertex]+1;\\n                } else if(visited[neighbor] == visited[vertex]) {\\n                    // detect cross edge and an odd length cycle\\n\\t\\t\\t\\t\\t// A cross edge betwee two vertices wich are of same distace from soruce vertex forms an odd length cycle\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t// DFS \\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] visited = new int[n+1];\\n\\n        // pre-process/ construct the graph\\n        List<Integer>[] adjList = new List[n+1];\\n        for(int vertex=1; vertex<=n; vertex++) {\\n            adjList[vertex] = new LinkedList<>();\\n        }\\n\\n        for(int[] edge : dislikes) {\\n            adjList[edge[0]].add(edge[1]);\\n            adjList[edge[1]].add(edge[0]);\\n        }\\n\\n        for(int vertex=1; vertex<=n; vertex++) {\\n            if(visited[vertex] == 0 && !dfs(vertex, adjList, 0, visited)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean dfs(int vertex, List<Integer>[] adjList, int distanceFromSrc, int[] visited) {\\n        visited[vertex] = distanceFromSrc;\\n        for(int neighbor : adjList[vertex]) {\\n            if(visited[neighbor] == 0) {\\n                if(!dfs(neighbor, adjList, distanceFromSrc+1, visited)) {\\n                    return false;\\n                }\\n            } else if((visited[vertex]-visited[neighbor]+1)%2 == 1){\\n                // detected a back edge and an odd legth cycle\\n\\t\\t\\t\\t// A back edge is dected first from a descedent to its ancestor for the first time,\\n\\t\\t\\t\\t// at this point we check the difference in depth and add 1 to the lenght of the cycle\\n\\t\\t\\t\\t// if the cycle lenght is odd return false\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\t\\n\\t// BFS \\n\\tpublic boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] visited = new int[n+1];\\n\\n        // construct adjList\\n        List<Integer>[] adjList = new List[n+1];\\n        for(int i=1; i<=n; i++) {\\n            adjList[i] = new LinkedList<>();\\n        }\\n\\n        for(int[] edge : dislikes) {\\n            adjList[edge[0]].add(edge[1]);\\n            adjList[edge[1]].add(edge[0]);\\n        }\\n\\n        for(int vertex=1; vertex<=n; vertex++) {\\n            if(visited[vertex] == 0 && !bfs(vertex, adjList, visited)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean bfs(int src, List<Integer>[] adjList, int[] visited) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(src);\\n        visited[src] = 1;\\n\\n        while(!queue.isEmpty()) {\\n            int vertex = queue.poll();\\n            for(int neighbor : adjList[vertex]) {\\n                if(visited[neighbor] == 0) {\\n                    queue.add(neighbor);\\n                    visited[neighbor] = visited[vertex]+1;\\n                } else if(visited[neighbor] == visited[vertex]) {\\n                    // detect cross edge and an odd length cycle\\n\\t\\t\\t\\t\\t// A cross edge betwee two vertices wich are of same distace from soruce vertex forms an odd length cycle\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t// DFS \\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] visited = new int[n+1];\\n\\n        // pre-process/ construct the graph\\n        List<Integer>[] adjList = new List[n+1];\\n        for(int vertex=1; vertex<=n; vertex++) {\\n            adjList[vertex] = new LinkedList<>();\\n        }\\n\\n        for(int[] edge : dislikes) {\\n            adjList[edge[0]].add(edge[1]);\\n            adjList[edge[1]].add(edge[0]);\\n        }\\n\\n        for(int vertex=1; vertex<=n; vertex++) {\\n            if(visited[vertex] == 0 && !dfs(vertex, adjList, 0, visited)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean dfs(int vertex, List<Integer>[] adjList, int distanceFromSrc, int[] visited) {\\n        visited[vertex] = distanceFromSrc;\\n        for(int neighbor : adjList[vertex]) {\\n            if(visited[neighbor] == 0) {\\n                if(!dfs(neighbor, adjList, distanceFromSrc+1, visited)) {\\n                    return false;\\n                }\\n            } else if((visited[vertex]-visited[neighbor]+1)%2 == 1){\\n                // detected a back edge and an odd legth cycle\\n\\t\\t\\t\\t// A back edge is dected first from a descedent to its ancestor for the first time,\\n\\t\\t\\t\\t// at this point we check the difference in depth and add 1 to the lenght of the cycle\\n\\t\\t\\t\\t// if the cycle lenght is odd return false\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1739660,
                "title": "python-union-find",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        #build graph, mapping x to a set of disliked people\\n        #union find each disliked people for each person, with the first person\\'s root as root\\n        #check if there is contradict between the person x and disliked people\\n        \\n        dsu = DSU(n + 1)\\n        \\n        graph = defaultdict(list)\\n                                     \\n        for x, y in dislikes:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        for i in graph:\\n            group = graph[i]\\n            y = group[0]\\n            for x in group:\\n                dsu.union(x, y)\\n            if dsu.find(i) == dsu.find(y):\\n                return False\\n        \\n        return True\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        #build graph, mapping x to a set of disliked people\\n        #union find each disliked people for each person, with the first person\\'s root as root\\n        #check if there is contradict between the person x and disliked people\\n        \\n        dsu = DSU(n + 1)\\n        \\n        graph = defaultdict(list)\\n                                     \\n        for x, y in dislikes:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        for i in graph:\\n            group = graph[i]\\n            y = group[0]\\n            for x in group:\\n                dsu.union(x, y)\\n            if dsu.find(i) == dsu.find(y):\\n                return False\\n        \\n        return True\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641753,
                "title": "2-coloring-make-into-an-undirected-graph",
                "content": "The key to this problem is knowing to make the graph into an undirected graph instead of keeping it as a directed graph. If you keep it as a directed graph and run the two coloring dfs technique, you will get a scenario like the image below where you won\\'t know whether to color vertex 1 as red or blue.\\n![image](https://assets.leetcode.com/users/images/7ff138d1-557b-4c41-89d5-017deaee693f_1640194282.3798587.png)\\nTurning the graph into an undirected graph has no negative effect since nodes that are connected will have to be different colors anyway regardless if they both mutually dislike each other since if at least 1 of them dislikes the other, they have to be colored different.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int u, int color, vector<vector<int>> &g, vector<int> &colors){\\n        colors[u] = color;\\n        for(auto &v : g[u]){\\n            if(colors[v] == 0){\\n                if(!dfs(v, color * -1, g, colors))\\n                    return false;\\n            }\\n            else if (colors[v] == color)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> g(n);\\n        for(auto &edge : dislikes){\\n            int u = edge[0], v = edge[1];\\n            u--; v--;\\n            g[v].push_back(u);\\n            g[u].push_back(v);\\n        }\\n        vector<int> colors(n);\\n        for(int i = 0; i < n; i++){\\n            if(colors[i] == 0){\\n                if(!dfs(i, -1, g, colors)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int u, int color, vector<vector<int>> &g, vector<int> &colors){\\n        colors[u] = color;\\n        for(auto &v : g[u]){\\n            if(colors[v] == 0){\\n                if(!dfs(v, color * -1, g, colors))\\n                    return false;\\n            }\\n            else if (colors[v] == color)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> g(n);\\n        for(auto &edge : dislikes){\\n            int u = edge[0], v = edge[1];\\n            u--; v--;\\n            g[v].push_back(u);\\n            g[u].push_back(v);\\n        }\\n        vector<int> colors(n);\\n        for(int i = 0; i < n; i++){\\n            if(colors[i] == 0){\\n                if(!dfs(i, -1, g, colors)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522896,
                "title": "c-easy-solution-using-dfs-bipartite-concept-graph-coloring",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,int parent,int &f,vector<int>&vis,vector<int>adj[],int color){\\n        vis[node]=color;\\n        for(auto nbr:adj[node]){\\n            if(vis[nbr]==-1){\\n                dfs(nbr,node,f,vis,adj,3-color);\\n            }\\n            else if(nbr!=parent and vis[nbr]==color){\\n                f=1;\\n                break;\\n            }\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        for(int i{0};i<dislikes.size();i++){\\n            int x=dislikes[i][0];\\n            int y=dislikes[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>vis(n+1,-1);\\n        int f=0;\\n        for(int i{0};i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,-1,f,vis,adj,1);\\n            }\\n        }\\n        if(f==1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,int parent,int &f,vector<int>&vis,vector<int>adj[],int color){\\n        vis[node]=color;\\n        for(auto nbr:adj[node]){\\n            if(vis[nbr]==-1){\\n                dfs(nbr,node,f,vis,adj,3-color);\\n            }\\n            else if(nbr!=parent and vis[nbr]==color){\\n                f=1;\\n                break;\\n            }\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        for(int i{0};i<dislikes.size();i++){\\n            int x=dislikes[i][0];\\n            int y=dislikes[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>vis(n+1,-1);\\n        int f=0;\\n        for(int i{0};i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,-1,f,vis,adj,1);\\n            }\\n        }\\n        if(f==1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494141,
                "title": "java-bfs-explanation-with-diagram",
                "content": "**Logic**\\nThe logic is simple, assume the two groups are denoted as `0` and `1`, we can just assign a member `a` as either one of them,e.g. `0`, then all the members he/she dislikes has to be in the other group, it can be represented as `1 - group of(a)`. To do this, we can build a tree structure, where for a node, all its children are the member he dislikes. There maybe multiple seprate trees for the inputs\\n\\nThen we just iterate the tree, make sure there is no conflict in the group, e.g. if a member is going to be in group `0`, but it has been assigned to group `1` before. Then it is a conflict, we cannot do bipartition, just `return false`. It can be done using **BFS Queue** data strucure. Refer an example blow. \\n\\n![image](https://assets.leetcode.com/users/images/20010603-25e4-4358-a9a4-9bfd91566a24_1632947741.135317.jpeg)\\n\\n**Others**\\n( I do not know why some posts used **coloring** for the explanation. It\\'s like we have 2 group here, they interpret this to 2 **colors** , they when implementing the code, they transfer **color** to group again? It is unnessary)\\n\\n---\\n**Code**\\n```java\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if(dislikes == null || dislikes.length == 0) return true;\\n        \\n        Map<Integer, List<Integer>> neighbors = new HashMap<>();\\n        for(int i = 1; i < n + 1; i++){\\n            neighbors.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] dislike : dislikes){\\n            neighbors.get(dislike[0]).add(dislike[1]);\\n            neighbors.get(dislike[1]).add(dislike[0]);\\n        }\\n        \\n        // key is the node, value is the group\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 1; i < n + 1; i++){\\n            if(!map.containsKey(i)){\\n                if(checkBiPartition(i, map, neighbors) == false) return false;\\n            }    \\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean checkBiPartition(int cur, Map<Integer, Integer> map, Map<Integer, List<Integer>> neighbors){\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(cur);\\n        map.put(cur, 0); // put first node in group 0\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n\\t\\t\\tint curGroup = map.get(queue.peek());\\n\\t\\t\\tint nextGroup = 1 - curGroup;\\n            for(int i = 0; i < size; i++){\\n                int tmp = queue.poll();\\n                // all its neighbors, either not visisted, we put into the other group or \\n                // visited: it is in the expected group\\n                for(int neighbor : neighbors.getOrDefault(tmp, new ArrayList<Integer>())){\\n                    if(!map.containsKey(neighbor)){\\n                        // never visted, put it into another group\\n                        map.put(neighbor, nextGroup));\\n                        queue.offer(neighbor);\\n                    }\\n                    // if it is already visited, then make sure it is the expected group \\n                    if(map.get(neighbor) != nextGroup) return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\n---\\n**Complexity**\\nTC: O(n)\\nSC: O(n)\\nAssuming `n` is the number of nodes",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        if(dislikes == null || dislikes.length == 0) return true;\\n        \\n        Map<Integer, List<Integer>> neighbors = new HashMap<>();\\n        for(int i = 1; i < n + 1; i++){\\n            neighbors.put(i, new ArrayList<Integer>());\\n        }\\n        \\n        for(int[] dislike : dislikes){\\n            neighbors.get(dislike[0]).add(dislike[1]);\\n            neighbors.get(dislike[1]).add(dislike[0]);\\n        }\\n        \\n        // key is the node, value is the group\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i = 1; i < n + 1; i++){\\n            if(!map.containsKey(i)){\\n                if(checkBiPartition(i, map, neighbors) == false) return false;\\n            }    \\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean checkBiPartition(int cur, Map<Integer, Integer> map, Map<Integer, List<Integer>> neighbors){\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(cur);\\n        map.put(cur, 0); // put first node in group 0\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n\\t\\t\\tint curGroup = map.get(queue.peek());\\n\\t\\t\\tint nextGroup = 1 - curGroup;\\n            for(int i = 0; i < size; i++){\\n                int tmp = queue.poll();\\n                // all its neighbors, either not visisted, we put into the other group or \\n                // visited: it is in the expected group\\n                for(int neighbor : neighbors.getOrDefault(tmp, new ArrayList<Integer>())){\\n                    if(!map.containsKey(neighbor)){\\n                        // never visted, put it into another group\\n                        map.put(neighbor, nextGroup));\\n                        queue.offer(neighbor);\\n                    }\\n                    // if it is already visited, then make sure it is the expected group \\n                    if(map.get(neighbor) != nextGroup) return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455620,
                "title": "python-bipartite-bfs",
                "content": "- Create adjecency list\\n- Confirm if each component is a Bipartite Graph by checking for odd cycle length using coloring. \\n```\\nfrom collections import defaultdict\\nfrom queue import Queue\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        # Create adjecency list \\n        adj = defaultdict(list)\\n        for a, b in dislikes:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        # Check if graph is Bipartite graph\\n        colors = [-1]*(n+1)\\n        for i in range(1, n):\\n            if colors[i] == -1:\\n                # check if component with this node is bipartite graph\\n                if not self.isBipartite(i, adj, colors):\\n                    return False\\n        return True\\n                \\n    def isBipartite(self, v: int, adj: dict, colors: list) -> bool:\\n        colors[v] = 0\\n        neighbour_queue = Queue()\\n        neighbour_queue.put(v)\\n        while not neighbour_queue.empty():\\n            curr = neighbour_queue.get()\\n            for neighbour in adj[curr]:\\n                # Odd cycle\\n                if colors[neighbour] == colors[curr]:\\n                    return False\\n                # Unvisited \\n                if colors[neighbour] == -1:\\n                    colors[neighbour] = 1 - colors[curr]\\n                    neighbour_queue.put(neighbour)\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom queue import Queue\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        # Create adjecency list \\n        adj = defaultdict(list)\\n        for a, b in dislikes:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        # Check if graph is Bipartite graph\\n        colors = [-1]*(n+1)\\n        for i in range(1, n):\\n            if colors[i] == -1:\\n                # check if component with this node is bipartite graph\\n                if not self.isBipartite(i, adj, colors):\\n                    return False\\n        return True\\n                \\n    def isBipartite(self, v: int, adj: dict, colors: list) -> bool:\\n        colors[v] = 0\\n        neighbour_queue = Queue()\\n        neighbour_queue.put(v)\\n        while not neighbour_queue.empty():\\n            curr = neighbour_queue.get()\\n            for neighbour in adj[curr]:\\n                # Odd cycle\\n                if colors[neighbour] == colors[curr]:\\n                    return False\\n                # Unvisited \\n                if colors[neighbour] == -1:\\n                    colors[neighbour] = 1 - colors[curr]\\n                    neighbour_queue.put(neighbour)\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336958,
                "title": "java-simple-queue",
                "content": "class Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] vis = new int[n+1];\\n        Arrays.fill(vis, -1);\\n\\n         List<Integer>[] graph = new ArrayList[n+1];\\n              for (int i = 0; i <= n; i++) {\\n                graph[i] = new ArrayList<>();\\n              }\\n\\n              for (int i=0;i<dislikes.length;i++) {\\n                graph[dislikes[i][0]].add(dislikes[i][1]);\\n                graph[dislikes[i][1]].add(dislikes[i][0]);\\n              }\\n              for(int i=0;i<=n;i++){\\n                if(vis[i]==-1){\\n                    if(isBipartite(graph,i,vis)==false){\\n                        return false;\\n                    }\\n                }\\n              }\\n        return true;\\n    }\\n    \\n    public  boolean isBipartite(List<Integer>[] graph, int src, int[] vis) {\\n        LinkedList<Integer> que = new LinkedList<>();\\n        int color = 0; // 0 : red, 1 : green\\n\\n        que.add(src);\\n        boolean isCycle = false, isBipartite = true;\\n\\n        while (que.size() != 0) {\\n            int size = que.size();\\n            while (size-- > 0) {\\n                int rvtx = que.removeFirst();\\n                if (vis[rvtx] != -1) {\\n                    isCycle = true;\\n                    if (vis[rvtx] != color) {\\n                        isBipartite = false;\\n                        break;\\n                    }\\n\\n                    continue;\\n                }\\n\\n                vis[rvtx] = color;\\n                for (int e : graph[rvtx]) {\\n                    if (vis[e] == -1) {\\n                        que.addLast(e);\\n                    }\\n                }\\n            }\\n            color = (color + 1) % 2;\\n            if(!isBipartite) break;\\n        }\\n\\n        \\n\\n        return isBipartite;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int[] vis = new int[n+1];\\n        Arrays.fill(vis, -1);\\n\\n         List<Integer>[] graph = new ArrayList[n+1];\\n              for (int i = 0; i <= n; i++) {\\n                graph[i] = new ArrayList<>();\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1290670,
                "title": "c-faster-than-100-bfs-queue",
                "content": "BFS solution using queue!!\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<int>adj[],vector<int>&color,int node,int n){\\n        queue<int>q;\\n        q.push(node);\\n        color[node]=1;\\n        while(q.size()){\\n            int curr=q.front();\\n            q.pop();\\n            for(int ele:adj[curr]){\\n                if(color[curr]==color[ele])return false;\\n                if(color[ele]==-1){\\n                    color[ele]=1-color[curr];\\n                    q.push(ele);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n            if(color[i]==-1)\\n                if(!isBipartite(adj,color,i,n))\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<int>adj[],vector<int>&color,int node,int n){\\n        queue<int>q;\\n        q.push(node);\\n        color[node]=1;\\n        while(q.size()){\\n            int curr=q.front();\\n            q.pop();\\n            for(int ele:adj[curr]){\\n                if(color[curr]==color[ele])return false;\\n                if(color[ele]==-1){\\n                    color[ele]=1-color[curr];\\n                    q.push(ele);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<int>adj[n+1];\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        vector<int> color(n+1,-1);\\n        for(int i=1;i<=n;i++)\\n            if(color[i]==-1)\\n                if(!isBipartite(adj,color,i,n))\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204300,
                "title": "c-simple-bfs-graph-colouring",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkbfs(vector<vector<int>>&g,int src,vector<int>&color)\\n    {\\n        color[src]=1;\\n        queue<int>q;\\n        q.push(src);\\n        while(!q.empty())\\n        {\\n            auto cur=q.front();\\n            q.pop();\\n            for(auto it:g[cur])\\n            {\\n                if(color[it]==color[cur])\\n                    return false;\\n                else if(color[it]==-1)\\n                {\\n                    color[it]=1-color[cur];\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \\n    {\\n      //Creating graphs \\n      vector<vector<int> >g(n+1);\\n      for(auto v:dislikes)\\n      {\\n        g[v[0]].push_back(v[1]);\\n        g[v[1]].push_back(v[0]);\\n      }\\n      vector<int>color(n+1,-1);\\n      for(int i=1;i<=n;i++)\\n      {\\n        if(color[i]==-1)\\n        {\\n            if(!checkbfs(g,i,color))\\n                return false;\\n        }\\n      }\\n      return true;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkbfs(vector<vector<int>>&g,int src,vector<int>&color)\\n    {\\n        color[src]=1;\\n        queue<int>q;\\n        q.push(src);\\n        while(!q.empty())\\n        {\\n            auto cur=q.front();\\n            q.pop();\\n            for(auto it:g[cur])\\n            {\\n                if(color[it]==color[cur])\\n                    return false;\\n                else if(color[it]==-1)\\n                {\\n                    color[it]=1-color[cur];\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \\n    {\\n      //Creating graphs \\n      vector<vector<int> >g(n+1);\\n      for(auto v:dislikes)\\n      {\\n        g[v[0]].push_back(v[1]);\\n        g[v[1]].push_back(v[0]);\\n      }\\n      vector<int>color(n+1,-1);\\n      for(int i=1;i<=n;i++)\\n      {\\n        if(color[i]==-1)\\n        {\\n            if(!checkbfs(g,i,color))\\n                return false;\\n        }\\n      }\\n      return true;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 780205,
                "title": "python-easy-bfs-detailed-explanation-and-comments",
                "content": "We treat the input \"dislikes\" list as edges and use that to build a graph.\\n\\nTo parition people into two different groups:\\n1. We first initialize two groups. One group with the starting person (source) of BFS\\n2. Then as we do BFS, we put all neighbors of the current person into the other group since the person and all people he/she dislike (i.e. neighbors) need to be in different groups. Thus, we are partitioning people into two groups when we do BFS. Anyone in one group cannot be put into the other group (where people he/she dislike exist).\\n3. If at any point, we find a neighbor is already in the same group as this person, we know the partition fails because we cannot put this person into the other group (and that\\'s also why we put this neighbor in his/her current gorup at first place).\\n\\nWe repeat this process for each connected component. If we successfully partition people in each connected components, return True.\\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        # build adjacency list\\n        adjList = {p : [] for p in range(1, N + 1)}\\n        for p1, p2 in dislikes:\\n            adjList[p1].append(p2)\\n            adjList[p2].append(p1)\\n        \\n        visited = set()\\n        # for each connected component, try to partition perople into two groups\\n        for person in range(1, N + 1):\\n            if person not in visited:\\n                # BFS\\n                # initialize two groups \\n                groups = [set([person]), set()]\\n                curList = [person]\\n                level = 0\\n                while curList:\\n                    next = []\\n                    curGroup = groups[level % 2]\\n                    theOtherGroup = groups[(level + 1) % 2]\\n                    for p in curList:\\n                        visited.add(p)\\n                        for neighbor in adjList[p]:\\n                            # if the neighbor is already in the same group of this person\\n                            if neighbor in curGroup:\\n                                return False\\n                            if neighbor not in theOtherGroup:\\n                                theOtherGroup.add(neighbor)\\n                                next.append(neighbor)\\n\\n                    curList = next\\n                    level += 1\\n            \\n        return True\\n```\\n\\nShould be O(V + E) time and space : )",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        # build adjacency list\\n        adjList = {p : [] for p in range(1, N + 1)}\\n        for p1, p2 in dislikes:\\n            adjList[p1].append(p2)\\n            adjList[p2].append(p1)\\n        \\n        visited = set()\\n        # for each connected component, try to partition perople into two groups\\n        for person in range(1, N + 1):\\n            if person not in visited:\\n                # BFS\\n                # initialize two groups \\n                groups = [set([person]), set()]\\n                curList = [person]\\n                level = 0\\n                while curList:\\n                    next = []\\n                    curGroup = groups[level % 2]\\n                    theOtherGroup = groups[(level + 1) % 2]\\n                    for p in curList:\\n                        visited.add(p)\\n                        for neighbor in adjList[p]:\\n                            # if the neighbor is already in the same group of this person\\n                            if neighbor in curGroup:\\n                                return False\\n                            if neighbor not in theOtherGroup:\\n                                theOtherGroup.add(neighbor)\\n                                next.append(neighbor)\\n\\n                    curList = next\\n                    level += 1\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727018,
                "title": "simple-bfs-and-dfs-solutions-in-c",
                "content": "This question is similar to ->is graph bipartite.\\n1) BFS\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int>color(N+1,0);\\n        vector<vector<int>>adj(N+1);\\n        for(auto e:dislikes){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue<int>q;\\n        for(int i=1;i<=N;i++){\\n            if(color[i]==0){\\n                q.push(i);\\n                color[i]=1;\\n            }\\n            else continue;\\n            while(!q.empty()){\\n                int u=q.front();q.pop();\\n                for(int i=0;i<adj[u].size();i++){\\n                    if(color[adj[u][i]]==0){\\n                        q.push(adj[u][i]);\\n                        color[adj[u][i]]=~color[u];\\n                    }\\n                    else if(color[u]==color[adj[u][i]]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n2)DFS\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int>color(N+1,0);\\n        vector<vector<int>>adj(N+1);\\n        for(auto e:dislikes){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(int i=1;i<=N;i++){\\n            if(color[i]==0){\\n                if(!dfs(i,color,adj,-1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool dfs(int u,vector<int>&color,vector<vector<int>>&adj,int par){\\n        if(par==-1) color[u]=1;\\n        else color[u]=~color[par];\\n        for(int nei:adj[u]){\\n            if(nei==par) continue;\\n            if(color[nei]==color[u]) return false;\\n            else if(color[nei]==0){\\n                if(!dfs(nei,color,adj,u)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nThank You.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int>color(N+1,0);\\n        vector<vector<int>>adj(N+1);\\n        for(auto e:dislikes){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue<int>q;\\n        for(int i=1;i<=N;i++){\\n            if(color[i]==0){\\n                q.push(i);\\n                color[i]=1;\\n            }\\n            else continue;\\n            while(!q.empty()){\\n                int u=q.front();q.pop();\\n                for(int i=0;i<adj[u].size();i++){\\n                    if(color[adj[u][i]]==0){\\n                        q.push(adj[u][i]);\\n                        color[adj[u][i]]=~color[u];\\n                    }\\n                    else if(color[u]==color[adj[u][i]]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int>color(N+1,0);\\n        vector<vector<int>>adj(N+1);\\n        for(auto e:dislikes){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(int i=1;i<=N;i++){\\n            if(color[i]==0){\\n                if(!dfs(i,color,adj,-1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool dfs(int u,vector<int>&color,vector<vector<int>>&adj,int par){\\n        if(par==-1) color[u]=1;\\n        else color[u]=~color[par];\\n        for(int nei:adj[u]){\\n            if(nei==par) continue;\\n            if(color[nei]==color[u]) return false;\\n            else if(color[nei]==0){\\n                if(!dfs(nei,color,adj,u)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664867,
                "title": "java-bfs-solution-with-explanation",
                "content": "//Approach \\n// if a graph is bipartite it can be fully colored using 2 colors\\n//one colour for each disjoint set\\n//0->color 1 ,1->color 2\\n// you can also use three states like 0,1,2 \\n\\nclass Solution {\\n    List<Integer> [] adj=null;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        adj=new ArrayList[N];\\n        for(int i=0;i<N;i++)\\n        {\\n            adj[i]=new ArrayList<>();\\n        }\\n        //construct an adjacency list representation of undirected graph\\n        for(int [] arr:dislikes)\\n        {\\n            adj[arr[0]-1].add(arr[1]-1);// i have used zero based indexing\\n            adj[arr[1]-1].add(arr[0]-1);\\n        }\\n        \\n        //construction ends\\n        int [] colors=new int[N];\\n        Arrays.fill(colors,-1);\\n        for(int i=0;i<N;i++)\\n        {\\n            //for all node whose colour has not been assigned yet\\n           if(colors[i]==-1)\\n           {\\n            if(!util(colors,i))\\n                return false;\\n           }\\n        }\\n        return true;\\n    }\\n    boolean util(int [] colors,int src)\\n    {\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(src);\\n        while(!q.isEmpty())\\n        {\\n            Integer curr=q.poll();\\n            for(Integer nei:adj[curr])\\n            {\\n                //if neigbour node is not processed yet\\n                if(colors[nei]==-1 )\\n                {\\n                    colors[nei]=1-colors[curr];// this ensures that a different colour will be assigned to neighbour\\n                    q.add(nei);\\n                }\\n                // if prcossed and neighbour has same colour as that of parent return false\\n                else if(colors[nei]==colors[curr])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n//i hope this of some help to someone\\n//if any queries or suggestions kindly provide them in comments section\\nmore than happy to get some contstructive feedback!!!",
                "solutionTags": [],
                "code": "class Solution {\\n    List<Integer> [] adj=null;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        adj=new ArrayList[N];\\n        for(int i=0;i<N;i++)\\n        {\\n            adj[i]=new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 656767,
                "title": "rust-o-n-dislikes-union-find-with-explanations-16-ms-faster-than-100",
                "content": "#### Solution\\n\\n```rust\\nconst A: usize = 0;\\nconst B: usize = 1;\\n\\nimpl Solution {\\n    /**\\n     * Approach: \\xE0-l\\xE0 \"union-find\", i.e. form & check groups as we iterate over \"dislike\" relationships.\\n     * Runtime complexity: O(n + dislikes.len())\\n     * Space complexity: O(n) -- allocated once, and allowing direct access.\\n     */\\n    pub fn possible_bipartition(n: i32, dislikes: Vec<Vec<i32>>) -> bool {\\n        let n = (n + 1) as usize; // Thank you Leetcode, for these rubbish method signatures!\\n\\n        // Initially, each node dislikes itself:\\n        let mut disliked_by = Vec::with_capacity(n);\\n        for i in 0..n {\\n            disliked_by.push(i);\\n        }\\n\\n        for dislike in dislikes.iter() {\\n            let (a, b) = (dislike[A] as usize, dislike[B] as usize);\\n            if disliked_by[a] == a && disliked_by[b] == b {\\n                // Initial case, mark \"b\" as disliked by \"a\", and vice-versa:\\n                disliked_by[a] = b;\\n                disliked_by[b] = a;\\n            } else if disliked_by[a] == a && disliked_by[b] != b {\\n                // Initial case for \"a\" only, we mark \"b\" as disliked by \"a\" by:\\n                // - finding who is disliked by \"b\", let\\'s call it \"c\",\\n                // - finding who is disliked by \"c\", and\\n                // - disliking them.\\n                // I.e.: \"The enemy of my enemy is my friend.\"\\n                disliked_by[a] = disliked_by[disliked_by[b]];\\n            } else if disliked_by[b] == b && disliked_by[a] != a {\\n                // Initial case for \"b\" only -- same as above:\\n                disliked_by[b] = disliked_by[disliked_by[a]];\\n            } else if disliked_by[b] == disliked_by[a] {\\n                // If someone dislikes both \"a\" and \"b\", then there is no bi-partition of the graph:\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```\\n\\n#### Performance\\n\\n> Runtime: 16 ms, faster than 100.00% of Rust online submissions for Possible Bipartition.\\n> Memory Usage: 2.6 MB, less than 100.00% of Rust online submissions for Possible Bipartition.\\n\\nN.B.: [that other solution](https://leetcode.com/problems/possible-bipartition/discuss/654915/Rust-O(orVor%2BorEor)-graph-colouring-using-recursive-DFS-with-explanations.) should be optimal for very large graphs, but appears slower given the current Leetcode benchmark. The above solution currently performs best as it only uses direct access on a `vec` and doesn\\'t suffer from the overhead of `HashMap`s.\\n",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```rust\\nconst A: usize = 0;\\nconst B: usize = 1;\\n\\nimpl Solution {\\n    /**\\n     * Approach: \\xE0-l\\xE0 \"union-find\", i.e. form & check groups as we iterate over \"dislike\" relationships.\\n     * Runtime complexity: O(n + dislikes.len())\\n     * Space complexity: O(n) -- allocated once, and allowing direct access.\\n     */\\n    pub fn possible_bipartition(n: i32, dislikes: Vec<Vec<i32>>) -> bool {\\n        let n = (n + 1) as usize; // Thank you Leetcode, for these rubbish method signatures!\\n\\n        // Initially, each node dislikes itself:\\n        let mut disliked_by = Vec::with_capacity(n);\\n        for i in 0..n {\\n            disliked_by.push(i);\\n        }\\n\\n        for dislike in dislikes.iter() {\\n            let (a, b) = (dislike[A] as usize, dislike[B] as usize);\\n            if disliked_by[a] == a && disliked_by[b] == b {\\n                // Initial case, mark \"b\" as disliked by \"a\", and vice-versa:\\n                disliked_by[a] = b;\\n                disliked_by[b] = a;\\n            } else if disliked_by[a] == a && disliked_by[b] != b {\\n                // Initial case for \"a\" only, we mark \"b\" as disliked by \"a\" by:\\n                // - finding who is disliked by \"b\", let\\'s call it \"c\",\\n                // - finding who is disliked by \"c\", and\\n                // - disliking them.\\n                // I.e.: \"The enemy of my enemy is my friend.\"\\n                disliked_by[a] = disliked_by[disliked_by[b]];\\n            } else if disliked_by[b] == b && disliked_by[a] != a {\\n                // Initial case for \"b\" only -- same as above:\\n                disliked_by[b] = disliked_by[disliked_by[a]];\\n            } else if disliked_by[b] == disliked_by[a] {\\n                // If someone dislikes both \"a\" and \"b\", then there is no bi-partition of the graph:\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656178,
                "title": "c-using-bfs-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> setNumber(N+1,0);\\n        vector<int> adj[N+1]; \\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        for(int k=1;k<=N;k++)\\n{\\n        if(!setNumber[k])\\n    {   \\n       queue<int> q1;\\n        q1.push(k);\\n        while(!q1.empty())\\n        {  \\n           int current=q1.front();\\n                       q1.pop();\\n            for(auto i:adj[current])\\n            {  \\n                if(setNumber[i]!=0)\\n                { \\n                    if(setNumber[i]==setNumber[current])\\n                    {\\n                        return false;\\n                    }    \\n                }\\n                else{\\n                    q1.push(i); \\n                    if(setNumber[current]==1)setNumber[i]=2;\\n                    else setNumber[i]=1;\\n                    }\\n             }\\n            \\n         } \\n     }\\n }\\n        return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> setNumber(N+1,0);\\n        vector<int> adj[N+1]; \\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        for(int k=1;k<=N;k++)\\n{\\n        if(!setNumber[k])\\n    {   \\n       queue<int> q1;\\n        q1.push(k);\\n        while(!q1.empty())\\n        {  \\n           int current=q1.front();\\n                       q1.pop();\\n            for(auto i:adj[current])\\n            {  \\n                if(setNumber[i]!=0)\\n                { \\n                    if(setNumber[i]==setNumber[current])\\n                    {\\n                        return false;\\n                    }    \\n                }\\n                else{\\n                    q1.push(i); \\n                    if(setNumber[current]==1)setNumber[i]=2;\\n                    else setNumber[i]=1;\\n                    }\\n             }\\n            \\n         } \\n     }\\n }\\n        return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656126,
                "title": "javascript-iterative-dfs",
                "content": "```\\nvar possibleBipartition = function(N, dislikes) {\\n    if(!dislikes.length) return true;\\n    const graph = new Map();\\n    const marked = Array(N+1).fill(0);\\n    const stack = [];\\n    \\n\\t// create adjacency list\\n    for(let [a, b] of dislikes) {\\n        graph.set(a, (graph.get(a) || new Set()).add(b));\\n        graph.set(b, (graph.get(b) || new Set()).add(a));\\n    }\\n    \\n    marked[0] = 1;\\n    stack.push([dislikes[0][0], 1]);\\n    \\n    while(stack.length) {\\n        const [node, mark] = stack.pop();\\n        marked[node] = mark;\\n        \\n        if(graph.has(node)) {\\n            const neighbors = graph.get(node);\\n            \\n            for(let vertex of neighbors) {\\n                if(marked[vertex] === mark) return false;\\n                if(marked[vertex] === 0) stack.push([vertex, ~mark]);\\n            }\\n        }\\n        \\n        if(stack.length === 0 && marked.includes(0)) {\\n            for(let i = 1; i < marked.length; i++) {\\n                if(graph.has(i) && marked[i] === 0) {\\n                    stack.push([i, 1]);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar possibleBipartition = function(N, dislikes) {\\n    if(!dislikes.length) return true;\\n    const graph = new Map();\\n    const marked = Array(N+1).fill(0);\\n    const stack = [];\\n    \\n\\t// create adjacency list\\n    for(let [a, b] of dislikes) {\\n        graph.set(a, (graph.get(a) || new Set()).add(b));\\n        graph.set(b, (graph.get(b) || new Set()).add(a));\\n    }\\n    \\n    marked[0] = 1;\\n    stack.push([dislikes[0][0], 1]);\\n    \\n    while(stack.length) {\\n        const [node, mark] = stack.pop();\\n        marked[node] = mark;\\n        \\n        if(graph.has(node)) {\\n            const neighbors = graph.get(node);\\n            \\n            for(let vertex of neighbors) {\\n                if(marked[vertex] === mark) return false;\\n                if(marked[vertex] === 0) stack.push([vertex, ~mark]);\\n            }\\n        }\\n        \\n        if(stack.length === 0 && marked.includes(0)) {\\n            for(let i = 1; i < marked.length; i++) {\\n                if(graph.has(i) && marked[i] === 0) {\\n                    stack.push([i, 1]);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 655973,
                "title": "python-unionfind-26lines",
                "content": "```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n)]\\n        \\n    def find(self, i):\\n        if self.parents[i] == i:\\n            return i\\n        self.parents[i] = self.find(self.parents[i])\\n        return self.parents[i]\\n    def unite(self, a, b):\\n        pa = self.find(a)\\n        pb = self.find(b)\\n        self.parents[pb] = pa\\n        return\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        # dubplicates\\n        M = 2 * (N+1)\\n        tree = UnionFind(M)\\n        for dis in dislikes:\\n            tree.unite(dis[0], dis[1]+N+1 )\\n            tree.unite(dis[0]+N+1, dis[1])\\n        for i in range(1,N+1):\\n            if tree.find(i) == tree.find(i+N+1):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n)]\\n        \\n    def find(self, i):\\n        if self.parents[i] == i:\\n            return i\\n        self.parents[i] = self.find(self.parents[i])\\n        return self.parents[i]\\n    def unite(self, a, b):\\n        pa = self.find(a)\\n        pb = self.find(b)\\n        self.parents[pb] = pa\\n        return\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        # dubplicates\\n        M = 2 * (N+1)\\n        tree = UnionFind(M)\\n        for dis in dislikes:\\n            tree.unite(dis[0], dis[1]+N+1 )\\n            tree.unite(dis[0]+N+1, dis[1])\\n        for i in range(1,N+1):\\n            if tree.find(i) == tree.find(i+N+1):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655609,
                "title": "python-set-operations-99",
                "content": "```\\ndef possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n\\tdisSets = defaultdict(set)\\n\\tfor i, j in dislikes:\\n\\t\\tdisSets[i].add(j)\\n\\t\\t#disSets[j].add(i)\\n\\n\\tA, B = set(), set()\\n\\twhile disSets:\\n\\t\\tif A:\\n\\t\\t\\ttoRemove = []\\n\\t\\t\\tfor i, js in disSets.items():\\n\\t\\t\\t\\tif i in A or js.intersection(B):\\n\\t\\t\\t\\t\\tA.add(i)\\n\\t\\t\\t\\t\\tB.update(js)\\n\\t\\t\\t\\telif i in B or js.intersection(A):\\n\\t\\t\\t\\t\\tB.add(i)\\n\\t\\t\\t\\t\\tA.update(js)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttoRemove.append(i)\\n\\t\\t\\tif A.intersection(B):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif toRemove:\\n\\t\\t\\t\\tfor i in toRemove:\\n\\t\\t\\t\\t\\tdisSets.pop(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tA, B = set(), set()\\n\\t\\telse:\\n\\t\\t\\ti = list(disSets.keys())[0]\\n\\t\\t\\tA.add(i)\\n\\t\\t\\tB.update(disSets[i])\\n\\t\\t\\tdisSets.pop(i)\\n\\treturn True\\n```",
                "solutionTags": [],
                "code": "```\\ndef possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n\\tdisSets = defaultdict(set)\\n\\tfor i, j in dislikes:\\n\\t\\tdisSets[i].add(j)\\n\\t\\t#disSets[j].add(i)\\n\\n\\tA, B = set(), set()\\n\\twhile disSets:\\n\\t\\tif A:\\n\\t\\t\\ttoRemove = []\\n\\t\\t\\tfor i, js in disSets.items():\\n\\t\\t\\t\\tif i in A or js.intersection(B):\\n\\t\\t\\t\\t\\tA.add(i)\\n\\t\\t\\t\\t\\tB.update(js)\\n\\t\\t\\t\\telif i in B or js.intersection(A):\\n\\t\\t\\t\\t\\tB.add(i)\\n\\t\\t\\t\\t\\tA.update(js)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttoRemove.append(i)\\n\\t\\t\\tif A.intersection(B):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif toRemove:\\n\\t\\t\\t\\tfor i in toRemove:\\n\\t\\t\\t\\t\\tdisSets.pop(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tA, B = set(), set()\\n\\t\\telse:\\n\\t\\t\\ti = list(disSets.keys())[0]\\n\\t\\t\\tA.add(i)\\n\\t\\t\\tB.update(disSets[i])\\n\\t\\t\\tdisSets.pop(i)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 655488,
                "title": "c-straightforward-union-find-solution",
                "content": "If both A and B hate C then put A and B in the same disjoint set.\\nIf A hates B and they are in the same set then return false.\\nThe code is straightforward:\\n```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> graph[N+1];\\n        for(auto& dislike : dislikes){\\n            graph[dislike[0]].push_back(dislike[1]);\\n            graph[dislike[1]].push_back(dislike[0]);\\n        }\\n        \\n        DisjointSet ds;\\n        for(int i = 1; i <= N; ++i){\\n            ds.makeSet(i);\\n        }\\n        // if both A and B hate C, then put A and B in the same disjoint set\\n        for(int i = 1; i <=N; ++i) {\\n            for(int j = 1; j < graph[i].size(); j++){\\n                ds.unionSets(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        // If A hates B and they are in the same disjoint set, return false\\n        for(auto& dislike : dislikes){\\n            if(ds.findSet(dislike[0]) == ds.findSet(dislike[1])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nHere is a standard Union-Find data structure:\\n```\\nclass DisjointSet {\\nprivate:    \\n    struct Node {\\n        int key;\\n        int rank;\\n        Node* parent;\\n        \\n        Node(int key){\\n            this->key = key;\\n            rank = 0;\\n            parent = this;\\n        }\\n    };\\n\\n    unordered_map<int, Node*> keyToNode;\\n    \\npublic:\\n    \\n    ~DisjointSet() {\\n        for(auto it = keyToNode.begin(); it != keyToNode.end(); ++it){\\n            delete it->second;\\n        }\\n    }\\n    \\n    void makeSet(int key){\\n        if(keyToNode.find(key) != keyToNode.end()){\\n            return;\\n        }\\n        keyToNode[key] = new Node(key);\\n    }\\n    \\n    int findSet(int key){\\n        return findSet(keyToNode[key])->key;\\n    }\\n    \\n    bool unionSets(int key1, int key2){\\n        Node* node1 = keyToNode[key1];\\n        Node* node2 = keyToNode[key2];\\n        \\n        Node* rep1 = findSet(node1);\\n        Node* rep2 = findSet(node2);\\n        \\n        if(rep1 == rep2) {\\n            return false;\\n        }\\n        \\n        if(rep1->rank > rep2->rank){\\n            rep2->parent = rep1;\\n        } else if (rep1->rank < rep2->rank){\\n            rep1->parent = rep2;\\n        } else {\\n            rep2->parent = rep1;\\n            rep1->rank++;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    Node* findSet(Node* node){\\n        if(node->parent == node){\\n            return node;\\n        }\\n        // path compression\\n        node->parent = findSet(node->parent);\\n        return node->parent;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        vector<int> graph[N+1];\\n        for(auto& dislike : dislikes){\\n            graph[dislike[0]].push_back(dislike[1]);\\n            graph[dislike[1]].push_back(dislike[0]);\\n        }\\n        \\n        DisjointSet ds;\\n        for(int i = 1; i <= N; ++i){\\n            ds.makeSet(i);\\n        }\\n        // if both A and B hate C, then put A and B in the same disjoint set\\n        for(int i = 1; i <=N; ++i) {\\n            for(int j = 1; j < graph[i].size(); j++){\\n                ds.unionSets(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        // If A hates B and they are in the same disjoint set, return false\\n        for(auto& dislike : dislikes){\\n            if(ds.findSet(dislike[0]) == ds.findSet(dislike[1])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass DisjointSet {\\nprivate:    \\n    struct Node {\\n        int key;\\n        int rank;\\n        Node* parent;\\n        \\n        Node(int key){\\n            this->key = key;\\n            rank = 0;\\n            parent = this;\\n        }\\n    };\\n\\n    unordered_map<int, Node*> keyToNode;\\n    \\npublic:\\n    \\n    ~DisjointSet() {\\n        for(auto it = keyToNode.begin(); it != keyToNode.end(); ++it){\\n            delete it->second;\\n        }\\n    }\\n    \\n    void makeSet(int key){\\n        if(keyToNode.find(key) != keyToNode.end()){\\n            return;\\n        }\\n        keyToNode[key] = new Node(key);\\n    }\\n    \\n    int findSet(int key){\\n        return findSet(keyToNode[key])->key;\\n    }\\n    \\n    bool unionSets(int key1, int key2){\\n        Node* node1 = keyToNode[key1];\\n        Node* node2 = keyToNode[key2];\\n        \\n        Node* rep1 = findSet(node1);\\n        Node* rep2 = findSet(node2);\\n        \\n        if(rep1 == rep2) {\\n            return false;\\n        }\\n        \\n        if(rep1->rank > rep2->rank){\\n            rep2->parent = rep1;\\n        } else if (rep1->rank < rep2->rank){\\n            rep1->parent = rep2;\\n        } else {\\n            rep2->parent = rep1;\\n            rep1->rank++;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    Node* findSet(Node* node){\\n        if(node->parent == node){\\n            return node;\\n        }\\n        // path compression\\n        node->parent = findSet(node->parent);\\n        return node->parent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655267,
                "title": "c-dfs-with-comments",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> color; // unknown 0, 1 and -1 represent two groups\\n\\n\\t\\tbool dfs( vector<vector<int>>& graph, int col, int cur)\\n\\t\\t{\\n\\t\\t\\tcolor[cur]=col;\\n\\t\\t\\tfor(auto& x:graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(color[x]==color[cur]) return false; // has same color with neighbor\\n\\t\\t\\t\\tif(color[x]==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!dfs(graph,-col,x)) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n\\t\\t\\tcolor.assign(N+1,0);\\n\\t\\t\\tvector<vector<int>> graph(N+1);\\n\\t\\t\\tfor(auto& x:dislikes) // build graph\\n\\t\\t\\t{\\n\\t\\t\\t\\tgraph[x[0]].push_back(x[1]); \\n\\t\\t\\t\\tgraph[x[1]].push_back(x[0]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=1;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(color[i]==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// the graph may have many connected components\\n\\t\\t\\t\\t\\t// do dfs with any of two colors\\n\\t\\t\\t\\t\\tif(!dfs(graph,1,i)) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> color; // unknown 0, 1 and -1 represent two groups\\n\\n\\t\\tbool dfs( vector<vector<int>>& graph, int col, int cur)\\n\\t\\t{\\n\\t\\t\\tcolor[cur]=col;\\n\\t\\t\\tfor(auto& x:graph[cur])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(color[x]==color[cur]) return false; // has same color with neighbor\\n\\t\\t\\t\\tif(color[x]==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!dfs(graph,-col,x)) return false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 655206,
                "title": "clean-simple-c-bfs-with-comments",
                "content": "```cpp\\nenum Groups {\\n    kGroup1 = 1,\\n    kGroup2 = 2\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        // Build adjacency list \\n        vector<vector<int>> graph(n + 1);\\n        for (const auto& dislike : dislikes) {\\n            graph[dislike[0]].emplace_back(dislike[1]);\\n            graph[dislike[1]].emplace_back(dislike[0]);\\n        }\\n\\n        vector<bool> visited(n + 1, false);\\n        vector<int> groups(n + 1, 0);\\n        \\n        // Iterate through all people\\n        for (int i = 1; i <= n; ++i) {\\n            // We only need to process people once\\n            if (!visited[i]) {\\n                // Assign to any group\\n                groups[i] = kGroup1;\\n                \\n                queue<int> to_process;\\n                to_process.emplace(i);\\n                // Breadth-first search\\n                while (!to_process.empty()) {\\n                    auto person = to_process.front();\\n                    to_process.pop();\\n                    \\n                    if (visited[person]) continue;\\n                    visited[person] = true;\\n                    \\n                    // Iterate through adjacent people\\n                    // (all the people this person dislike)\\n                    for (auto next_person : graph[person]) {\\n                        // If they are in the same group, it\\'s\\n                        // not possible to split the graph into two\\n                        if (groups[person] == groups[next_person]) {\\n                            return false;\\n                        }\\n                        // Otherwise, assign them to the opposite group\\n                        groups[next_person] = groups[person] == kGroup1 ? kGroup2 : kGroup1;\\n                        to_process.emplace(next_person);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nenum Groups {\\n    kGroup1 = 1,\\n    kGroup2 = 2\\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        // Build adjacency list \\n        vector<vector<int>> graph(n + 1);\\n        for (const auto& dislike : dislikes) {\\n            graph[dislike[0]].emplace_back(dislike[1]);\\n            graph[dislike[1]].emplace_back(dislike[0]);\\n        }\\n\\n        vector<bool> visited(n + 1, false);\\n        vector<int> groups(n + 1, 0);\\n        \\n        // Iterate through all people\\n        for (int i = 1; i <= n; ++i) {\\n            // We only need to process people once\\n            if (!visited[i]) {\\n                // Assign to any group\\n                groups[i] = kGroup1;\\n                \\n                queue<int> to_process;\\n                to_process.emplace(i);\\n                // Breadth-first search\\n                while (!to_process.empty()) {\\n                    auto person = to_process.front();\\n                    to_process.pop();\\n                    \\n                    if (visited[person]) continue;\\n                    visited[person] = true;\\n                    \\n                    // Iterate through adjacent people\\n                    // (all the people this person dislike)\\n                    for (auto next_person : graph[person]) {\\n                        // If they are in the same group, it\\'s\\n                        // not possible to split the graph into two\\n                        if (groups[person] == groups[next_person]) {\\n                            return false;\\n                        }\\n                        // Otherwise, assign them to the opposite group\\n                        groups[next_person] = groups[person] == kGroup1 ? kGroup2 : kGroup1;\\n                        to_process.emplace(next_person);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654918,
                "title": "c-check-graph-for-bipartiteness",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        int i,m = dislikes.size();\\n        vector<vector<int>> adj(N+1);\\n        for(i=0;i<m;i++)\\n        {\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        } \\n        vector<int> side(N+1, -1);\\n        bool is_bipartite = true;\\n        queue<int> q;\\n        for (int st = 0; st < N; ++st) \\n        {\\n            if (side[st] == -1) \\n            {\\n                q.push(st);\\n                side[st] = 0;\\n                while (!q.empty()) \\n                {\\n                    int v = q.front();\\n                    q.pop();\\n                    for (int u : adj[v]) \\n                    {\\n                        if (side[u] == -1) \\n                        {\\n                            side[u] = side[v]^1;\\n                            q.push(u);\\n                        } \\n                        else \\n                            is_bipartite &= side[u] != side[v];\\n                    }\\n                }\\n            }\\n        }\\n        return is_bipartite;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        int i,m = dislikes.size();\\n        vector<vector<int>> adj(N+1);\\n        for(i=0;i<m;i++)\\n        {\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n            adj[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 654915,
                "title": "rust-o-v-e-graph-colouring-using-recursive-dfs-with-explanations",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nconst FROM: usize = 0;\\nconst TO: usize = 1;\\nconst DEFAULT_FACTION: bool = true;\\n\\nimpl Solution {\\n    /**\\n     * Approach: model the \"dislikes\" as a graph; it is possible to create a\\n     *           bi-partition iff there is no cycle in the graph.\\n     * Runtime complexity: O(|V|+|E|)\\n     * Space complexity:  O(|V|+|E|)\\n     * N.B.: approach doesn\\'t depend on `n`, but purely on the number of \"dislikes\".\\n     */\\n    pub fn possible_bipartition(n: i32, dislikes: Vec<Vec<i32>>) -> bool {\\n        if dislikes.is_empty() {\\n            // If no one dislikes any one, we can create any arbitrary bi-partition.\\n            return true;\\n        }\\n        // Create an undirected graph with all \"dislike\" relationships (a.k.a. edges).\\n        // The graph may be sparse, so we use an adjacency list:\\n        let mut graph = HashMap::new();\\n        for edge in dislikes.iter() {\\n            graph.entry(edge[FROM]).or_insert(Vec::new()).push(edge[TO]);\\n            graph.entry(edge[TO]).or_insert(Vec::new()).push(edge[FROM]);\\n        }\\n        // For all nodes involved in a \"dislike\" relationship, heck if there is a cycle in the graph -- a.k.a. conflict among factions:\\n        let mut factions = HashMap::new();\\n        graph.keys().all(|&u| if factions.contains_key(&u) {\\n            true\\n        } else {\\n            no_conflict(u, DEFAULT_FACTION, &mut factions, &graph)\\n        })\\n    }\\n}\\n\\n/**\\n * Run a depth-first search, recursively, and either:\\n * - check if there is any conflict with known factions, or\\n * - set the faction and recurse, flipping the faction at every step along the way.\\n */\\nfn no_conflict(u: i32, faction: bool, factions: &mut HashMap<i32, bool>, graph: &HashMap<i32, Vec<i32>>) -> bool {\\n    if let Some(&actual_faction) = factions.get(&u) {\\n        return actual_faction == faction;\\n    }\\n    factions.insert(u, faction);\\n    graph.get(&u).unwrap().iter().all(|&v| no_conflict(v, !faction, factions, &graph))\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nconst FROM: usize = 0;\\nconst TO: usize = 1;\\nconst DEFAULT_FACTION: bool = true;\\n\\nimpl Solution {\\n    /**\\n     * Approach: model the \"dislikes\" as a graph; it is possible to create a\\n     *           bi-partition iff there is no cycle in the graph.\\n     * Runtime complexity: O(|V|+|E|)\\n     * Space complexity:  O(|V|+|E|)\\n     * N.B.: approach doesn\\'t depend on `n`, but purely on the number of \"dislikes\".\\n     */\\n    pub fn possible_bipartition(n: i32, dislikes: Vec<Vec<i32>>) -> bool {\\n        if dislikes.is_empty() {\\n            // If no one dislikes any one, we can create any arbitrary bi-partition.\\n            return true;\\n        }\\n        // Create an undirected graph with all \"dislike\" relationships (a.k.a. edges).\\n        // The graph may be sparse, so we use an adjacency list:\\n        let mut graph = HashMap::new();\\n        for edge in dislikes.iter() {\\n            graph.entry(edge[FROM]).or_insert(Vec::new()).push(edge[TO]);\\n            graph.entry(edge[TO]).or_insert(Vec::new()).push(edge[FROM]);\\n        }\\n        // For all nodes involved in a \"dislike\" relationship, heck if there is a cycle in the graph -- a.k.a. conflict among factions:\\n        let mut factions = HashMap::new();\\n        graph.keys().all(|&u| if factions.contains_key(&u) {\\n            true\\n        } else {\\n            no_conflict(u, DEFAULT_FACTION, &mut factions, &graph)\\n        })\\n    }\\n}\\n\\n/**\\n * Run a depth-first search, recursively, and either:\\n * - check if there is any conflict with known factions, or\\n * - set the faction and recurse, flipping the faction at every step along the way.\\n */\\nfn no_conflict(u: i32, faction: bool, factions: &mut HashMap<i32, bool>, graph: &HashMap<i32, Vec<i32>>) -> bool {\\n    if let Some(&actual_faction) = factions.get(&u) {\\n        return actual_faction == faction;\\n    }\\n    factions.insert(u, faction);\\n    graph.get(&u).unwrap().iter().all(|&v| no_conflict(v, !faction, factions, &graph))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654912,
                "title": "bfs-graph-coloring-c",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    vector<int> v[10001];\\n    bool vis[10001];\\n    int col[10001];\\n    bool bfs(int node,int c)\\n    {\\n        queue<int> q;\\n        vis[node] = true;\\n        col[node] = c;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            int par = q.front();\\n            q.pop();\\n            for(auto child : v[par])\\n            {\\n                if(!vis[child])\\n                {\\n                    vis[child] = true;\\n                    col[child] = col[par]^c;\\n                    q.push(child);\\n                }\\n                else if(col[child]==col[par])return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int N, vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v[d[i][0]].push_back(d[i][1]);\\n            v[d[i][1]].push_back(d[i][0]);\\n        }\\n        bool k = true;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(!vis[i])\\n            {\\n               k = bfs(i,1);\\n                if(k==false)\\n                    break;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    vector<int> v[10001];\\n    bool vis[10001];\\n    int col[10001];\\n    bool bfs(int node,int c)\\n    {\\n        queue<int> q;\\n        vis[node] = true;\\n        col[node] = c;\\n        q.push(node);\\n        while(!q.empty())\\n        {\\n            int par = q.front();\\n            q.pop();\\n            for(auto child : v[par])\\n            {\\n                if(!vis[child])\\n                {\\n                    vis[child] = true;\\n                    col[child] = col[par]^c;\\n                    q.push(child);\\n                }\\n                else if(col[child]==col[par])return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int N, vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v[d[i][0]].push_back(d[i][1]);\\n            v[d[i][1]].push_back(d[i][0]);\\n        }\\n        bool k = true;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(!vis[i])\\n            {\\n               k = bfs(i,1);\\n                if(k==false)\\n                    break;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654875,
                "title": "java-clean-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        Node[] nodes = new Node[N+1];\\n        for (int i = 1; i <= N; i++)\\n            nodes[i] = new Node();\\n        \\n        for (int[] edge : dislikes) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            \\n            nodes[from].addEdge(nodes[to]);\\n            nodes[to].addEdge(nodes[from]);\\n        }\\n        \\n        for (int idx = 1; idx <= N; idx++) {\\n            if (!nodes[idx].isColored() && !nodes[idx].dfs(Color.BLACK))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private static enum Color { UNCOLORED, BLACK, WHITE };\\n    \\n    private static class Node {\\n        private Color color;\\n        private List<Node> neighbours;\\n        \\n        public Node() {\\n            color = Color.UNCOLORED;\\n            this.neighbours = new ArrayList<>();\\n        }\\n        \\n        public boolean isColored() {\\n            return this.color != Color.UNCOLORED;\\n        }\\n        \\n        public void addEdge(Node node) {\\n            this.neighbours.add(node);\\n        }\\n        \\n        public boolean dfs(Color color) {\\n            if (isColored()) {\\n                return this.color == color;\\n            }\\n            \\n            this.color = color;\\n            for (Node neighbour : neighbours) {\\n                if (!neighbour.dfs(color == Color.BLACK ? Color.WHITE : Color.BLACK))\\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        Node[] nodes = new Node[N+1];\\n        for (int i = 1; i <= N; i++)\\n            nodes[i] = new Node();\\n        \\n        for (int[] edge : dislikes) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            \\n            nodes[from].addEdge(nodes[to]);\\n            nodes[to].addEdge(nodes[from]);\\n        }\\n        \\n        for (int idx = 1; idx <= N; idx++) {\\n            if (!nodes[idx].isColored() && !nodes[idx].dfs(Color.BLACK))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private static enum Color { UNCOLORED, BLACK, WHITE };\\n    \\n    private static class Node {\\n        private Color color;\\n        private List<Node> neighbours;\\n        \\n        public Node() {\\n            color = Color.UNCOLORED;\\n            this.neighbours = new ArrayList<>();\\n        }\\n        \\n        public boolean isColored() {\\n            return this.color != Color.UNCOLORED;\\n        }\\n        \\n        public void addEdge(Node node) {\\n            this.neighbours.add(node);\\n        }\\n        \\n        public boolean dfs(Color color) {\\n            if (isColored()) {\\n                return this.color == color;\\n            }\\n            \\n            this.color = color;\\n            for (Node neighbour : neighbours) {\\n                if (!neighbour.dfs(color == Color.BLACK ? Color.WHITE : Color.BLACK))\\n                    return false;\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654859,
                "title": "c-bipartite-graph-approach",
                "content": "```\\nbool possibleBipartition(int n, const std::vector<std::vector<int>>& dislikes) {\\n  using graph = std::vector<std::vector<int>>;\\n  graph g(n);\\n  for (const auto& vec : dislikes) {\\n    g[vec[0] - 1].push_back(vec[1] - 1);\\n    g[vec[1] - 1].push_back(vec[0] - 1);\\n  }\\n\\n  enum class Color { red, black, not_set };\\n  std::vector<Color> colors(n, Color::not_set);\\n  std::vector<char> processed(n, 0);\\n  std::function<bool(int, Color)> dfs;\\n  dfs = [&](int to, Color color) {\\n    processed[to] = true;\\n    colors[to] = color;\\n    const auto new_color = color == Color::black ? Color::red : Color::black;\\n    for (int v : g[to]) {\\n      if (colors[v] != Color::not_set && colors[v] != new_color)\\n        return false;\\n      if (!processed[v] && !dfs(v, new_color))\\n        return false;\\n    }\\n    return true;\\n  };\\n\\n  for (int i = 0; i < n; ++i) {\\n    if (!processed[i] && !dfs(i, Color::red))\\n      return false;\\n  }\\n  return true;\\n}",
                "solutionTags": [],
                "code": "```\\nbool possibleBipartition(int n, const std::vector<std::vector<int>>& dislikes) {\\n  using graph = std::vector<std::vector<int>>;\\n  graph g(n);\\n  for (const auto& vec : dislikes) {\\n    g[vec[0] - 1].push_back(vec[1] - 1);\\n    g[vec[1] - 1].push_back(vec[0] - 1);\\n  }\\n\\n  enum class Color { red, black, not_set };\\n  std::vector<Color> colors(n, Color::not_set);\\n  std::vector<char> processed(n, 0);\\n  std::function<bool(int, Color)> dfs;\\n  dfs = [&](int to, Color color) {\\n    processed[to] = true;\\n    colors[to] = color;\\n    const auto new_color = color == Color::black ? Color::red : Color::black;\\n    for (int v : g[to]) {\\n      if (colors[v] != Color::not_set && colors[v] != new_color)\\n        return false;\\n      if (!processed[v] && !dfs(v, new_color))\\n        return false;\\n    }\\n    return true;\\n  };\\n\\n  for (int i = 0; i < n; ++i) {\\n    if (!processed[i] && !dfs(i, Color::red))\\n      return false;\\n  }\\n  return true;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 654833,
                "title": "simple-c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        bool ret = false;\\n        if (dislikes.size() == 0)   return true;\\n        \\n        unordered_map<int, vector<int>> vmap;\\n        for (int i = 0; i < dislikes.size(); i++) {\\n            vmap[dislikes[i][0]].push_back(dislikes[i][1]);\\n            vmap[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        unordered_map<int, int> visited;\\n        \\n        for (int i = 1; i <+N; i++) {\\n            if (visited.find(i) == visited.end()) {\\n                list<pair<int, int>> ver;\\n                ver.push_back(make_pair(i, 1));\\n                while (!ver.empty()) {\\n                    int u = ver.front().first;\\n                    int color = ver.front().second;\\n                    ver.pop_front();\\n                    if (visited.find(u) != visited.end()) {\\n                        if (visited[u] != color)    return false;\\n                        continue;\\n                    }\\n                    visited[u] = color;\\n                    for (int j = 0; j < vmap[u].size(); j++) {\\n                        ver.push_back(make_pair(vmap[u][j], -color));\\n                    }\\n                } \\n            }   \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\\n        bool ret = false;\\n        if (dislikes.size() == 0)   return true;\\n        \\n        unordered_map<int, vector<int>> vmap;\\n        for (int i = 0; i < dislikes.size(); i++) {\\n            vmap[dislikes[i][0]].push_back(dislikes[i][1]);\\n            vmap[dislikes[i][1]].push_back(dislikes[i][0]);\\n        }\\n        unordered_map<int, int> visited;\\n        \\n        for (int i = 1; i <+N; i++) {\\n            if (visited.find(i) == visited.end()) {\\n                list<pair<int, int>> ver;\\n                ver.push_back(make_pair(i, 1));\\n                while (!ver.empty()) {\\n                    int u = ver.front().first;\\n                    int color = ver.front().second;\\n                    ver.pop_front();\\n                    if (visited.find(u) != visited.end()) {\\n                        if (visited[u] != color)    return false;\\n                        continue;\\n                    }\\n                    visited[u] = color;\\n                    for (int j = 0; j < vmap[u].size(); j++) {\\n                        ver.push_back(make_pair(vmap[u][j], -color));\\n                    }\\n                } \\n            }   \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654828,
                "title": "fastest-solution-with-python-no-dfs-or-bfs-beats-100",
                "content": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:   \\n        if len(dislikes) == 0:\\n            return True\\n        lst = [None] * N\\n        lst[dislikes[0][0] - 1] = 1\\n        lst[dislikes[0][1] - 1] = 2\\n        ok = 1\\n        remaining = []\\n        while True:\\n            length = len(dislikes)\\n            for i in dislikes:\\n                if ok == 0:\\n                    if lst[i[0] - 1] is None:\\n                        if lst[i[1] - 1] is None:\\n                            remaining.append(i)\\n\\n                        elif lst[i[1] - 1] == 1:\\n                            lst[i[0] - 1] = 2\\n                        else:\\n                            lst[i[0] - 1] = 1\\n                    elif lst[i[0] - 1] == 1:\\n                        if lst[i[1] - 1] is None:\\n                            lst[i[1] - 1] = 2\\n                        elif lst[i[1] - 1] == 1:\\n                            return False\\n                    else:\\n                        if lst[i[1] - 1] is None:\\n                            lst[i[1] - 1] = 1\\n                        elif lst[i[1] - 1] == 2:\\n                            return False\\n                else:\\n                    ok = 0\\n            if len(dislikes) == 0:\\n                break\\n            if length == len(remaining) and len(remaining) > 0:\\n                lst[remaining[0][0] - 1] = 1\\n                lst[remaining[0][1] - 1] = 2\\n                remaining.pop(0)\\n            dislikes = remaining\\n            remaining = []\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:   \\n        if len(dislikes) == 0:\\n            return True\\n        lst = [None] * N\\n        lst[dislikes[0][0] - 1] = 1\\n        lst[dislikes[0][1] - 1] = 2\\n        ok = 1\\n        remaining = []\\n        while True:\\n            length = len(dislikes)\\n            for i in dislikes:\\n                if ok == 0:\\n                    if lst[i[0] - 1] is None:\\n                        if lst[i[1] - 1] is None:\\n                            remaining.append(i)\\n\\n                        elif lst[i[1] - 1] == 1:\\n                            lst[i[0] - 1] = 2\\n                        else:\\n                            lst[i[0] - 1] = 1\\n                    elif lst[i[0] - 1] == 1:\\n                        if lst[i[1] - 1] is None:\\n                            lst[i[1] - 1] = 2\\n                        elif lst[i[1] - 1] == 1:\\n                            return False\\n                    else:\\n                        if lst[i[1] - 1] is None:\\n                            lst[i[1] - 1] = 1\\n                        elif lst[i[1] - 1] == 2:\\n                            return False\\n                else:\\n                    ok = 0\\n            if len(dislikes) == 0:\\n                break\\n            if length == len(remaining) and len(remaining) > 0:\\n                lst[remaining[0][0] - 1] = 1\\n                lst[remaining[0][1] - 1] = 2\\n                remaining.pop(0)\\n            dislikes = remaining\\n            remaining = []\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654813,
                "title": "c-solution-bipartite-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> &v,vector<int> adj[],int s,bool &flag,vector<int> &type)\\n    {\\n        v[s] = 1;\\n        for(int i:adj[s])\\n        {\\n            if(v[i]==0)\\n            {\\n                type[i] = !(type[s]);\\n                dfs(v,adj,i,flag,type);\\n            }\\n            else\\n            {\\n                if(type[i] ==  type[s])\\n                {\\n                    flag=false;\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& d) {\\n        if(d.size()==0)\\n            return true;\\n        vector<int> adj[N+1];\\n        for(int i=0;i<d.size();i++)\\n            adj[d[i][0]].push_back(d[i][1]),adj[d[i][1]].push_back(d[i][0]);\\n        vector<int> v(N+1,0),type(N+1,0);\\n        bool flag;\\n        \\n        type[1] = 0;\\n        \\n        for(int i=1;i<=N;i++)\\n        {\\n            flag=true;\\n            if(v[i]==0)\\n            {\\n                dfs(v,adj,i,flag,type);\\n                if(!flag)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> &v,vector<int> adj[],int s,bool &flag,vector<int> &type)\\n    {\\n        v[s] = 1;\\n        for(int i:adj[s])\\n        {\\n            if(v[i]==0)\\n            {\\n                type[i] = !(type[s]);\\n                dfs(v,adj,i,flag,type);\\n            }\\n            else\\n            {\\n                if(type[i] ==  type[s])\\n                {\\n                    flag=false;\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool possibleBipartition(int N, vector<vector<int>>& d) {\\n        if(d.size()==0)\\n            return true;\\n        vector<int> adj[N+1];\\n        for(int i=0;i<d.size();i++)\\n            adj[d[i][0]].push_back(d[i][1]),adj[d[i][1]].push_back(d[i][0]);\\n        vector<int> v(N+1,0),type(N+1,0);\\n        bool flag;\\n        \\n        type[1] = 0;\\n        \\n        for(int i=1;i<=N;i++)\\n        {\\n            flag=true;\\n            if(v[i]==0)\\n            {\\n                dfs(v,adj,i,flag,type);\\n                if(!flag)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654803,
                "title": "python-bfs-and-dfs",
                "content": "\\'\\'\\'\\nsolution 1 use DFS\\nfrom collections import defaultdict\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        nonlike = defaultdict(list)\\n        \\n        for item in dislikes:\\n            nonlike[item[0]-1].append(item[1]-1)\\n            nonlike[item[1]-1].append(item[0]-1)\\n            \\n        colors = [0] * N\\n        # 0 for unknown,1 for red,-1 for blue [node,color] added to stack\\n        \\n        \\n        def dfs(curr,color):\\n            colors[curr] = color\\n            for item in nonlike[curr]:\\n                if colors[item] == color: return False\\n                if (colors[item] ==0) and not dfs(item,-color): return False\\n            return True\\n        \\n        for i in range(N):\\n            if colors[i] == 0 and not dfs(i,1): return False\\n        return True\\n        \\n        \\n            \\n            \\n            \\n solution 2 use BFS\\nfrom collections import defaultdict\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        nonlike = defaultdict(list)\\n        \\n        for item in dislikes:\\n            nonlike[item[0]-1].append(item[1]-1)\\n            nonlike[item[1]-1].append(item[0]-1)\\n            \\n        color = [0] * N\\n        # 0 for unknown,1 for red,-1 for blue [node,color] added to stack\\n        \\n        \\n        for i in range(N):\\n            if color[i] != 0:\\n                continue\\n            stack = [i]\\n            color[i] = 1\\n            while stack:\\n                curr = stack.pop()\\n                for item in nonlike[curr]:\\n                    if color[item] == color[curr]: return False\\n                    if color[item] == 0:\\n                        color[item] = -color[curr]\\n                        stack.append(item)\\n            \\n        return True\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nsolution 1 use DFS\\nfrom collections import defaultdict\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        nonlike = defaultdict(list)\\n        \\n        for item in dislikes:\\n            nonlike[item[0]-1].append(item[1]-1)\\n            nonlike[item[1]-1].append(item[0]-1)\\n            \\n        colors = [0] * N\\n        # 0 for unknown,1 for red,-1 for blue [node,color] added to stack\\n        \\n        \\n        def dfs(curr,color):\\n            colors[curr] = color\\n            for item in nonlike[curr]:\\n                if colors[item] == color: return False\\n                if (colors[item] ==0) and not dfs(item,-color): return False\\n            return True\\n        \\n        for i in range(N):\\n            if colors[i] == 0 and not dfs(i,1): return False\\n        return True\\n        \\n        \\n            \\n            \\n            \\n solution 2 use BFS\\nfrom collections import defaultdict\\nclass Solution:\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        nonlike = defaultdict(list)\\n        \\n        for item in dislikes:\\n            nonlike[item[0]-1].append(item[1]-1)\\n            nonlike[item[1]-1].append(item[0]-1)\\n            \\n        color = [0] * N\\n        # 0 for unknown,1 for red,-1 for blue [node,color] added to stack\\n        \\n        \\n        for i in range(N):\\n            if color[i] != 0:\\n                continue\\n            stack = [i]\\n            color[i] = 1\\n            while stack:\\n                curr = stack.pop()\\n                for item in nonlike[curr]:\\n                    if color[item] == color[curr]: return False\\n                    if color[item] == 0:\\n                        color[item] = -color[curr]\\n                        stack.append(item)\\n            \\n        return True\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 545805,
                "title": "javascript-dfs",
                "content": "Idea is to have everyone possibly in two group.\\n\\n```\\n/**\\n * @param {number} N\\n * @param {number[][]} dislikes\\n * @return {boolean}\\n */\\nvar possibleBipartition = function(N, dislikes) {\\n  let map = {};\\n  let group = new Array(N).fill(0);\\n\\n  for (let [a, b] of dislikes) {\\n    if (map.hasOwnProperty(a)) {\\n      map[a].push(b);\\n    } else {\\n      map[a] = [b];\\n    }\\n\\n    if (map.hasOwnProperty(b)) {\\n      map[b].push(a);\\n    } else {\\n      map[b] = [a];\\n    }\\n  }\\n\\n  for (let i = 1; i <= N; i++) {\\n    if (group[i - 1] === 0 && !helper(i, map, group, 1)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nlet helper = (person, map, group, belong) => {\\n  if (group[person - 1] !== 0) {\\n    if (group[person - 1] !== belong) {\\n      return false;\\n    } else\\n      return true;\\n  }\\n\\n  if (!map.hasOwnProperty(person)) {\\n    group[person - 1] = belong;\\n    return true;\\n  }\\n\\n  group[person - 1] = belong;\\n\\n  for (let val of map[person]) {\\n    if (!helper(val, map, group, -1 * belong)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @param {number[][]} dislikes\\n * @return {boolean}\\n */\\nvar possibleBipartition = function(N, dislikes) {\\n  let map = {};\\n  let group = new Array(N).fill(0);\\n\\n  for (let [a, b] of dislikes) {\\n    if (map.hasOwnProperty(a)) {\\n      map[a].push(b);\\n    } else {\\n      map[a] = [b];\\n    }\\n\\n    if (map.hasOwnProperty(b)) {\\n      map[b].push(a);\\n    } else {\\n      map[b] = [a];\\n    }\\n  }\\n\\n  for (let i = 1; i <= N; i++) {\\n    if (group[i - 1] === 0 && !helper(i, map, group, 1)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nlet helper = (person, map, group, belong) => {\\n  if (group[person - 1] !== 0) {\\n    if (group[person - 1] !== belong) {\\n      return false;\\n    } else\\n      return true;\\n  }\\n\\n  if (!map.hasOwnProperty(person)) {\\n    group[person - 1] = belong;\\n    return true;\\n  }\\n\\n  group[person - 1] = belong;\\n\\n  for (let val of map[person]) {\\n    if (!helper(val, map, group, -1 * belong)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521743,
                "title": "swift-dfs-bfs-solution",
                "content": "```\\nclass Solution {\\n    func possibleBipartition(_ N: Int, _ dislikes: [[Int]]) -> Bool {\\n        var graph:[[Int]] = []\\n        for i in 0..<N{\\n            graph.append([])\\n        }\\n        for i in dislikes{\\n            let from = i[0]-1\\n            let to = i[1]-1\\n            graph[from].append(to)\\n            graph[to].append(from)\\n        }\\n        var visited = Array(repeating: 0, count: graph.count)\\n        for i in 0..<N{\\n            if 0 == visited[i]{\\n                //let res = dfs(i ,graph, &visited)\\n                let res = bfs(i ,graph, &visited)\\n                if !res{\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n    \\n    func bfs(_ node:Int, _ graph:[[Int]], _ visited:inout[Int])->Bool{\\n        var queue:[Int] = []\\n        queue.append(node)\\n        visited[node] = 1\\n\\n        while !queue.isEmpty{\\n            let item = queue.removeFirst()\\n            for child in graph[item]{\\n                if visited[child] == 0{\\n                    visited[child] = visited[item] == 1 ? 2 : 1\\n                    queue.append(child)\\n                }else{\\n                    if visited[child] == visited[item] { return false }\\n                }\\n            }\\n        }\\n        return true\\n    }\\n    \\n    func dfs(_ node:Int, _ graph:[[Int]], _ visited:inout[Int],_ parent:Int? = nil)->Bool{\\n        if parent == nil {\\n            visited[node] = 1\\n        }\\n        for child in graph[node]{\\n            if visited[child] == 0{\\n                visited[child] = visited[node] == 1 ? 2 : 1\\n                if !dfs(child, graph, &visited, node){\\n                    return false\\n                }\\n            }else{\\n                if visited[child] == visited[node] { return false }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func possibleBipartition(_ N: Int, _ dislikes: [[Int]]) -> Bool {\\n        var graph:[[Int]] = []\\n        for i in 0..<N{\\n            graph.append([])\\n        }\\n        for i in dislikes{\\n            let from = i[0]-1\\n            let to = i[1]-1\\n            graph[from].append(to)\\n            graph[to].append(from)\\n        }\\n        var visited = Array(repeating: 0, count: graph.count)\\n        for i in 0..<N{\\n            if 0 == visited[i]{\\n                //let res = dfs(i ,graph, &visited)\\n                let res = bfs(i ,graph, &visited)\\n                if !res{\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n    \\n    func bfs(_ node:Int, _ graph:[[Int]], _ visited:inout[Int])->Bool{\\n        var queue:[Int] = []\\n        queue.append(node)\\n        visited[node] = 1\\n\\n        while !queue.isEmpty{\\n            let item = queue.removeFirst()\\n            for child in graph[item]{\\n                if visited[child] == 0{\\n                    visited[child] = visited[item] == 1 ? 2 : 1\\n                    queue.append(child)\\n                }else{\\n                    if visited[child] == visited[item] { return false }\\n                }\\n            }\\n        }\\n        return true\\n    }\\n    \\n    func dfs(_ node:Int, _ graph:[[Int]], _ visited:inout[Int],_ parent:Int? = nil)->Bool{\\n        if parent == nil {\\n            visited[node] = 1\\n        }\\n        for child in graph[node]{\\n            if visited[child] == 0{\\n                visited[child] = visited[node] == 1 ? 2 : 1\\n                if !dfs(child, graph, &visited, node){\\n                    return false\\n                }\\n            }else{\\n                if visited[child] == visited[node] { return false }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477332,
                "title": "c-readable-and-heavily-commented-dfs",
                "content": "```csharp\\npublic class Solution {\\n    enum Colour { Uncoloured, Red, Blue }\\n    \\n    public bool PossibleBipartition(int N, int[][] dislikes) \\n    {\\n        //Given a graph, can we colour all nodes: {red, blue} s.t all red neighbours are blue\\n        //and vice-versa\\n        var graphColour = Enumerable.Range(1,N).ToDictionary(x => x, x => Colour.Uncoloured);\\n        \\n        //rearrange the dislikes Array. \\n        //[[1,2],[1,3],[2,4]] =>\\n        //dislikeLookup[1]: [2,3]\\n        //dislikeLookup[2]: [1,4]\\n        //dislikeLookup[3]: [1]\\n        //dislikeLookup[4]: [2]\\n        var dislikeLookup = dislikes.Concat(dislikes.Select(x => new[] { x[1], x[0] })).ToLookup(x => x[0], x => x[1]);\\n        \\n        \\n        IEnumerable<int> GetDislikes(int k) => dislikeLookup[k];\\n        Colour SetColour(int i, Colour colour) => graphColour[i] = colour;\\n        Colour GetColour(int i) => graphColour[i];\\n        bool IsColoured(int i) => GetColour(i) != Colour.Uncoloured;\\n        Colour Swap(Colour colour) => colour == Colour.Blue ? Colour.Red : Colour.Blue;\\n        \\n        bool DFS(int k, Colour colour)\\n        {\\n            //By performing DFS, we will have coloured all nodes in the connected component from some root k.\\n            //Therefore if we reached a node previously, we\\'ve already considered all of its neighbours and it was successful.\\n\\t\\t\\t//Note: At this point, we may be considred a root, so the vaue of colour does not matter.\\n            if(IsColoured(k)) { return true; }\\n            \\n            SetColour(k, colour);\\n            foreach(var d in GetDislikes(k))\\n            {\\n                if(GetColour(d) == colour)\\n                {\\n                    //We\\'ve already coloured a neighbour and it\\'s the wrong colour, \\n                    //We can\\'t do a bipartite colouring\\n                    return false;\\n                }\\n                \\n                //Valid colouring already performed, try the next one.\\n                if(GetColour(d) == Swap(colour)) { continue; }\\n                \\n                //We haven\\'t coloured d, it can only be the opposite colour of the current node.\\n                //Try a colouring, if it fails we can\\'t backtrack, so fail the procedure.\\n\\t\\t\\t\\t//Note that if we\\'re successful, we want to continue with the next dislike, not return true.\\n                if(!DFS(d, Swap(colour))) { return false; }\\n            }\\n            //All colourings were successful\\n            return true;\\n        }\\n        \\n        //If we have a fully connected graph, we only need to colour once from a \\'root\\'\\n        //We likely don\\'t have a root, so we work through each connected component starting from an arbitrary root.\\n\\t\\t//DFS will terminate quickly if the root has already been coloured.\\n        foreach(var k in graphColour.Keys.ToList())\\n        {\\n            if(!DFS(k, Colour.Blue)) { return false; }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    enum Colour { Uncoloured, Red, Blue }\\n    \\n    public bool PossibleBipartition(int N, int[][] dislikes) \\n    {\\n        //Given a graph, can we colour all nodes: {red, blue} s.t all red neighbours are blue\\n        //and vice-versa\\n        var graphColour = Enumerable.Range(1,N).ToDictionary(x => x, x => Colour.Uncoloured);\\n        \\n        //rearrange the dislikes Array. \\n        //[[1,2],[1,3],[2,4]] =>\\n        //dislikeLookup[1]: [2,3]\\n        //dislikeLookup[2]: [1,4]\\n        //dislikeLookup[3]: [1]\\n        //dislikeLookup[4]: [2]\\n        var dislikeLookup = dislikes.Concat(dislikes.Select(x => new[] { x[1], x[0] })).ToLookup(x => x[0], x => x[1]);\\n        \\n        \\n        IEnumerable<int> GetDislikes(int k) => dislikeLookup[k];\\n        Colour SetColour(int i, Colour colour) => graphColour[i] = colour;\\n        Colour GetColour(int i) => graphColour[i];\\n        bool IsColoured(int i) => GetColour(i) != Colour.Uncoloured;\\n        Colour Swap(Colour colour) => colour == Colour.Blue ? Colour.Red : Colour.Blue;\\n        \\n        bool DFS(int k, Colour colour)\\n        {\\n            //By performing DFS, we will have coloured all nodes in the connected component from some root k.\\n            //Therefore if we reached a node previously, we\\'ve already considered all of its neighbours and it was successful.\\n\\t\\t\\t//Note: At this point, we may be considred a root, so the vaue of colour does not matter.\\n            if(IsColoured(k)) { return true; }\\n            \\n            SetColour(k, colour);\\n            foreach(var d in GetDislikes(k))\\n            {\\n                if(GetColour(d) == colour)\\n                {\\n                    //We\\'ve already coloured a neighbour and it\\'s the wrong colour, \\n                    //We can\\'t do a bipartite colouring\\n                    return false;\\n                }\\n                \\n                //Valid colouring already performed, try the next one.\\n                if(GetColour(d) == Swap(colour)) { continue; }\\n                \\n                //We haven\\'t coloured d, it can only be the opposite colour of the current node.\\n                //Try a colouring, if it fails we can\\'t backtrack, so fail the procedure.\\n\\t\\t\\t\\t//Note that if we\\'re successful, we want to continue with the next dislike, not return true.\\n                if(!DFS(d, Swap(colour))) { return false; }\\n            }\\n            //All colourings were successful\\n            return true;\\n        }\\n        \\n        //If we have a fully connected graph, we only need to colour once from a \\'root\\'\\n        //We likely don\\'t have a root, so we work through each connected component starting from an arbitrary root.\\n\\t\\t//DFS will terminate quickly if the root has already been coloured.\\n        foreach(var k in graphColour.Keys.ToList())\\n        {\\n            if(!DFS(k, Colour.Blue)) { return false; }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338877,
                "title": "java-bfs",
                "content": "```\\n//BFS \\n    //Time: O(E + N) E:num(edges) N:num(people)\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        //build graph\\n        List<Integer>[] graph = new ArrayList[N + 1];\\n        for(int i = 0; i <= N; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int i = 0; i < dislikes.length; i++){\\n            graph[dislikes[i][0]].add(dislikes[i][1]);\\n            graph[dislikes[i][1]].add(dislikes[i][0]);\\n        }\\n        int[] color = new int[N + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n        //BFS, add all people to two groups\\n        for(int i = 1; i <= N; i++){\\n            if(color[i] != 0) continue; //human already added to one group\\n            color[i] = 1;//assign human to a group\\n            q.add(i);\\n            while(!q.isEmpty()){\\n                int human = q.poll();\\n                for(int hater : graph[human]){\\n                    if(color[hater] == 0){// hater not added to any group\\n                        q.add(hater);\\n                        color[hater] = -color[human];\\n                    }else if(color[hater] + color[human] != 0){ //haters belong to same group\\n                        return false;\\n                    }\\n                }\\n            }\\n        }  \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//BFS \\n    //Time: O(E + N) E:num(edges) N:num(people)\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        //build graph\\n        List<Integer>[] graph = new ArrayList[N + 1];\\n        for(int i = 0; i <= N; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int i = 0; i < dislikes.length; i++){\\n            graph[dislikes[i][0]].add(dislikes[i][1]);\\n            graph[dislikes[i][1]].add(dislikes[i][0]);\\n        }\\n        int[] color = new int[N + 1];\\n        Queue<Integer> q = new LinkedList<>();\\n        //BFS, add all people to two groups\\n        for(int i = 1; i <= N; i++){\\n            if(color[i] != 0) continue; //human already added to one group\\n            color[i] = 1;//assign human to a group\\n            q.add(i);\\n            while(!q.isEmpty()){\\n                int human = q.poll();\\n                for(int hater : graph[human]){\\n                    if(color[hater] == 0){// hater not added to any group\\n                        q.add(hater);\\n                        color[hater] = -color[human];\\n                    }else if(color[hater] + color[human] != 0){ //haters belong to same group\\n                        return false;\\n                    }\\n                }\\n            }\\n        }  \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258595,
                "title": "non-graph-5ms-java-solution-beats-100-single-array-n-allocated",
                "content": "This is very straightforward with no complicated graphs to navigate - just assign a pair into 2 groups, then iteratively search the array of dislikes to:\\n- verify no pairs were already assigned to the same group\\n- propagate existing group assignments to new pairs\\n- only retain pairs that have no assignments yet for the next pass\\n- if there is a pass with no additional assignments propagated, then grab the next pair and manually assign them.\\n\\nThis was just my initial attempt and potentially has O(N^2) run-time, but its simplicity makes it outperform all existing Java submissions. Also, it could very well have O(N) complexity depending on how much duplication is in the pairs and how they are ordered so the good performance may simply be a by-product of how the test cases were constructed.\\n\\n```\\nclass Solution {\\n    static final int UNKNOWN = 0;\\n    static final int ODD = 1;\\n    static final int EVEN = 2;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int group[] = new int[N];\\n        boolean needSeed = true;\\n        int remain = dislikes.length;\\n        while (remain > 0) {\\n            int i = 0;\\n            if (needSeed) {\\n                int dislike[] = dislikes[0];\\n                group[dislike[0] - 1] = ODD;\\n                group[dislike[1] - 1] = EVEN;\\n                i = 1;\\n            } else {\\n                needSeed = true;\\n            }\\n            int keep = 0;\\n            while (i < remain) {\\n                int dislike[] = dislikes[i++];\\n                int p = dislike[0];\\n                int d = dislike[1];\\n                int pg = group[p - 1];\\n                int dg = group[d - 1];\\n                if (pg != UNKNOWN) {\\n                    if (dg != UNKNOWN) {\\n                        if (dg == pg) {\\n                            return false;\\n                        }\\n                    } else {\\n                        group[d - 1] = (EVEN + ODD) - pg;\\n                        needSeed = false;\\n                    }\\n                } else if (dg != UNKNOWN) {\\n                    group[p - 1] = (EVEN + ODD) - dg;\\n                    needSeed = false;\\n                } else {\\n                    dislikes[keep++] = dislike;\\n                }\\n            }\\n            remain = keep;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static final int UNKNOWN = 0;\\n    static final int ODD = 1;\\n    static final int EVEN = 2;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        int group[] = new int[N];\\n        boolean needSeed = true;\\n        int remain = dislikes.length;\\n        while (remain > 0) {\\n            int i = 0;\\n            if (needSeed) {\\n                int dislike[] = dislikes[0];\\n                group[dislike[0] - 1] = ODD;\\n                group[dislike[1] - 1] = EVEN;\\n                i = 1;\\n            } else {\\n                needSeed = true;\\n            }\\n            int keep = 0;\\n            while (i < remain) {\\n                int dislike[] = dislikes[i++];\\n                int p = dislike[0];\\n                int d = dislike[1];\\n                int pg = group[p - 1];\\n                int dg = group[d - 1];\\n                if (pg != UNKNOWN) {\\n                    if (dg != UNKNOWN) {\\n                        if (dg == pg) {\\n                            return false;\\n                        }\\n                    } else {\\n                        group[d - 1] = (EVEN + ODD) - pg;\\n                        needSeed = false;\\n                    }\\n                } else if (dg != UNKNOWN) {\\n                    group[p - 1] = (EVEN + ODD) - dg;\\n                    needSeed = false;\\n                } else {\\n                    dislikes[keep++] = dislike;\\n                }\\n            }\\n            remain = keep;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220700,
                "title": "python-faster-than-100-192ms",
                "content": "We can treat this problem as a graph coloring problem and we have just 2 colors\\n```\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(dislikes)<=1:\\n            return True\\n        color=[-1]*(N+1)\\n        neighbour=[[] for _ in range(N+1)]\\n        visited=[False]*(N+1)\\n        \\n        for i in dislikes:\\n            neighbour[i[0]].append(i[1])\\n            neighbour[i[1]].append(i[0])\\n            \\n        start=dislikes[0][0]\\n        color[start]=1\\n        queue=[]\\n        queue.append(start)\\n        \\n        \\n        for i in range(N+1):\\n            if not visited[i]:\\n                queue.append(i)\\n            while queue:\\n                element=queue.pop()\\n                if not visited[element]:\\n                    visited[element]=True\\n                    for v in neighbour[element]:\\n                        if color[v]==-1:\\n                            color[v]=1-color[element]\\n                            queue.append(v)\\n\\n                        if color[element]==color[v]:\\n                            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(dislikes)<=1:\\n            return True\\n        color=[-1]*(N+1)\\n        neighbour=[[] for _ in range(N+1)]\\n        visited=[False]*(N+1)\\n        \\n        for i in dislikes:\\n            neighbour[i[0]].append(i[1])\\n            neighbour[i[1]].append(i[0])\\n            \\n        start=dislikes[0][0]\\n        color[start]=1\\n        queue=[]\\n        queue.append(start)\\n        \\n        \\n        for i in range(N+1):\\n            if not visited[i]:\\n                queue.append(i)\\n            while queue:\\n                element=queue.pop()\\n                if not visited[element]:\\n                    visited[element]=True\\n                    for v in neighbour[element]:\\n                        if color[v]==-1:\\n                            color[v]=1-color[element]\\n                            queue.append(v)\\n\\n                        if color[element]==color[v]:\\n                            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213114,
                "title": "the-classical-graph-problem-2-coloring-problem-solved-using-dfs",
                "content": "For this problem, we can view the dislike pair as the edge in the graph with node 1,2,...,N. So it can be converted to determine whether the graph can be colored with 2 colors such that no two adjacent vertices of the graph are colored with same color. \\n\\nGenerally, the m Coloring Problem\\'s solution is as following link:\\nhttps://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/\\n\\nFor m=2, the DFS solution is as following:\\n```\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\n        def dfs(v, color):\\n            if colors[v] != 0:\\n                return colors[v] == color\\n            colors[v] = color\\n            for nei in graph[v]:\\n                if not dfs(nei, -color):\\n                    return False\\n            return True\\n\\n        graph = [[] for _ in range(N + 1)]\\n        for edge in dislikes:\\n            if edge:\\n                graph[edge[0]].append(edge[1])\\n                graph[edge[1]].append(edge[0])\\n\\n        colors = [0 for _ in range(N + 1)]\\n        for i in range(1, N + 1):\\n            if colors[i] == 0 and not dfs(i, 1):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def possibleBipartition(self, N, dislikes):\\n        \"\"\"\\n        :type N: int\\n        :type dislikes: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\n        def dfs(v, color):\\n            if colors[v] != 0:\\n                return colors[v] == color\\n            colors[v] = color\\n            for nei in graph[v]:\\n                if not dfs(nei, -color):\\n                    return False\\n            return True\\n\\n        graph = [[] for _ in range(N + 1)]\\n        for edge in dislikes:\\n            if edge:\\n                graph[edge[0]].append(edge[1])\\n                graph[edge[1]].append(edge[0])\\n\\n        colors = [0 for _ in range(N + 1)]\\n        for i in range(1, N + 1):\\n            if colors[i] == 0 and not dfs(i, 1):\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3868941,
                "title": "simple-dfs-approach",
                "content": "# Intuition\\n Color the whole graph in two different color such that no two adjacent nodes get same color.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n0(N+E) \\n\\n- Space complexity:\\n worst case 0(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void solve(vector<vector<int>>& adj ,int src, vector<int>& vis,bool &ans , int color){\\n        vis[src] = color;\\n        for(auto a : adj[src]){\\n            if(vis[a]==-1){\\n                solve(adj,a,vis,ans,1-color);\\n            }\\n            else{\\n                if(vis[a]==color){\\n                    ans=false;\\n                    return;\\n                }\\n            }\\n        }\\n\\n    }\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n       vector<vector<int>> adj(n+1);\\n       for(int i=0; i<dislikes.size(); i++){\\n           int u = dislikes[i][0];\\n           int v = dislikes[i][1];\\n           adj[u].push_back(v);\\n           adj[v].push_back(u);\\n       }\\n\\n       vector<int>vis(n+1,-1);\\n       bool ans = true;\\n       for(int i=1;i<=n;i++){\\n           if(vis[i]==-1){\\n               solve(adj,i,vis,ans,0);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void solve(vector<vector<int>>& adj ,int src, vector<int>& vis,bool &ans , int color){\\n        vis[src] = color;\\n        for(auto a : adj[src]){\\n            if(vis[a]==-1){\\n                solve(adj,a,vis,ans,1-color);\\n            }\\n            else{\\n                if(vis[a]==color){\\n                    ans=false;\\n                    return;\\n                }\\n            }\\n        }\\n\\n    }\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n       vector<vector<int>> adj(n+1);\\n       for(int i=0; i<dislikes.size(); i++){\\n           int u = dislikes[i][0];\\n           int v = dislikes[i][1];\\n           adj[u].push_back(v);\\n           adj[v].push_back(u);\\n       }\\n\\n       vector<int>vis(n+1,-1);\\n       bool ans = true;\\n       for(int i=1;i<=n;i++){\\n           if(vis[i]==-1){\\n               solve(adj,i,vis,ans,0);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528292,
                "title": "go-dfs-solution-beats-100",
                "content": "```\\nfunc possibleBipartition(n int, dislikes [][]int) bool {\\n    graph := make([][]int, n+1)\\n    for _, edge := range dislikes {\\n        graph[edge[0]] = append(graph[edge[0]], edge[1])\\n        graph[edge[1]] = append(graph[edge[1]], edge[0])\\n    }\\n    vis := make([]int, n+1)\\n    var dfs func (v, color int) bool\\n    dfs = func (v, color int) bool {\\n        vis[v] = color\\n        ret := true\\n        for _, u := range graph[v] {\\n            if vis[u] == 0 {\\n                ret = ret && dfs(u, 3 - color)\\n            } else if vis[u] != 3 - color {\\n                ret = false\\n            }\\n        }\\n        return ret\\n    }\\n    for i := 1; i <= n; i++ {\\n        if vis[i] == 0 {\\n            if chk := dfs(i, 1); !chk {\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc possibleBipartition(n int, dislikes [][]int) bool {\\n    graph := make([][]int, n+1)\\n    for _, edge := range dislikes {\\n        graph[edge[0]] = append(graph[edge[0]], edge[1])\\n        graph[edge[1]] = append(graph[edge[1]], edge[0])\\n    }\\n    vis := make([]int, n+1)\\n    var dfs func (v, color int) bool\\n    dfs = func (v, color int) bool {\\n        vis[v] = color\\n        ret := true\\n        for _, u := range graph[v] {\\n            if vis[u] == 0 {\\n                ret = ret && dfs(u, 3 - color)\\n            } else if vis[u] != 3 - color {\\n                ret = false\\n            }\\n        }\\n        return ret\\n    }\\n    for i := 1; i <= n; i++ {\\n        if vis[i] == 0 {\\n            if chk := dfs(i, 1); !chk {\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3507867,
                "title": "solution",
                "content": "```C++ []\\nvoid make(int n,int size[],int par[]){\\n    for(int i=0;i<n;i++){\\n        size[i] = 1;\\n        par[i] = i;\\n    }\\n}\\nint find(int a,int par[]){\\n    if(par[a]==a){\\n        return a;\\n    }\\n    par[a] = find(par[a],par);\\n    return par[a];\\n}\\nvoid Union(int a,int b,int size[],int par[]){\\n    a = find(a,par);\\n    b = find(b,par);\\n    if(a!=b){\\n        if(size[a]<size[b]){\\n            swap(a,b);\\n        }\\n        size[a]+=size[b];\\n        par[b] = a;\\n    }\\n}\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n       int size[n+2];\\n       int par[n+2];\\n       make(n+2,size,par);\\n       int exchange[n];\\n       for(int i=0;i<n;i++){\\n           exchange[i] = -1;\\n       }\\n       for(int i=0;i<dislikes.size();i++){\\n               int aa = dislikes[i][0];\\n               int bb = dislikes[i][1];\\n               aa--;\\n               bb--;\\n               if(exchange[aa]==-1 and exchange[bb]==-1){\\n                   exchange[aa] = bb;\\n                   exchange[bb] = aa;\\n               }\\n               else if(exchange[aa]==-1){\\n                   exchange[aa] = bb;\\n                   Union(exchange[bb],aa,size,par);\\n               }\\n               else if(exchange[bb]==-1){\\n                   exchange[bb] = aa;\\n                   Union(exchange[aa],bb,size,par);\\n               }\\n               else{\\n                   if(find(aa,par)==find(bb,par)){\\n                       return 0;\\n                   }\\n                   Union(exchange[aa],bb,size,par);\\n                   Union(exchange[bb],aa,size,par);\\n               }\\n       }\\n       return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        adj = [[] for _ in range(n+1)]\\n\\n        for p1, p2 in dislikes:\\n            adj[p1].append(p2)\\n            adj[p2].append(p1)\\n        \\n        colors = [-1] * (n+1)\\n\\n        def bfs(color_idx):\\n            q = collections.deque([color_idx])\\n            colors[color_idx] = 0\\n\\n            while q:\\n                person = q.popleft()\\n                for neighbor in adj[person]:\\n                    if colors[neighbor] == colors[person]:\\n                        return False\\n                    if colors[neighbor] == -1:\\n                        colors[neighbor] = 1 - colors[person]\\n                        q.append(neighbor)\\n            \\n            return True\\n\\n        for idx in range(1, len(colors)):\\n            if colors[idx] == -1:\\n                if not bfs(idx):\\n                    return False\\n        \\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int len = dislikes.length;\\n        boolean[] check = new boolean[len];\\n        int[] arr = new int[n + 1];\\n        boolean foundNew;\\n        for(int i = 0; i < len; i++){\\n            if(check[i]) continue;\\n            arr[dislikes[i][0]] = 1;\\n            arr[dislikes[i][1]] = 2;\\n            foundNew = true;\\n            while(foundNew){\\n                foundNew = false;\\n                for(int j = i + 1; j < len; j++){\\n                    if(check[j]) continue;\\n                    int x = arr[dislikes[j][0]];\\n                    int y = arr[dislikes[j][1]];\\n                    if(x == 0 && y == 0) continue;\\n                    if(x > 0 && y > 0){\\n                        if((x - y) % 2 == 0) return false;\\n                    }\\n                    else if(x > 0) arr[dislikes[j][1]] = x + 1;\\n                    else arr[dislikes[j][0]] = y + 1;\\n                    foundNew = true;\\n                    check[j] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nvoid make(int n,int size[],int par[]){\\n    for(int i=0;i<n;i++){\\n        size[i] = 1;\\n        par[i] = i;\\n    }\\n}\\nint find(int a,int par[]){\\n    if(par[a]==a){\\n        return a;\\n    }\\n    par[a] = find(par[a],par);\\n    return par[a];\\n}\\nvoid Union(int a,int b,int size[],int par[]){\\n    a = find(a,par);\\n    b = find(b,par);\\n    if(a!=b){\\n        if(size[a]<size[b]){\\n            swap(a,b);\\n        }\\n        size[a]+=size[b];\\n        par[b] = a;\\n    }\\n}\\nclass Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n       int size[n+2];\\n       int par[n+2];\\n       make(n+2,size,par);\\n       int exchange[n];\\n       for(int i=0;i<n;i++){\\n           exchange[i] = -1;\\n       }\\n       for(int i=0;i<dislikes.size();i++){\\n               int aa = dislikes[i][0];\\n               int bb = dislikes[i][1];\\n               aa--;\\n               bb--;\\n               if(exchange[aa]==-1 and exchange[bb]==-1){\\n                   exchange[aa] = bb;\\n                   exchange[bb] = aa;\\n               }\\n               else if(exchange[aa]==-1){\\n                   exchange[aa] = bb;\\n                   Union(exchange[bb],aa,size,par);\\n               }\\n               else if(exchange[bb]==-1){\\n                   exchange[bb] = aa;\\n                   Union(exchange[aa],bb,size,par);\\n               }\\n               else{\\n                   if(find(aa,par)==find(bb,par)){\\n                       return 0;\\n                   }\\n                   Union(exchange[aa],bb,size,par);\\n                   Union(exchange[bb],aa,size,par);\\n               }\\n       }\\n       return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        adj = [[] for _ in range(n+1)]\\n\\n        for p1, p2 in dislikes:\\n            adj[p1].append(p2)\\n            adj[p2].append(p1)\\n        \\n        colors = [-1] * (n+1)\\n\\n        def bfs(color_idx):\\n            q = collections.deque([color_idx])\\n            colors[color_idx] = 0\\n\\n            while q:\\n                person = q.popleft()\\n                for neighbor in adj[person]:\\n                    if colors[neighbor] == colors[person]:\\n                        return False\\n                    if colors[neighbor] == -1:\\n                        colors[neighbor] = 1 - colors[person]\\n                        q.append(neighbor)\\n            \\n            return True\\n\\n        for idx in range(1, len(colors)):\\n            if colors[idx] == -1:\\n                if not bfs(idx):\\n                    return False\\n        \\n        return True\\n```\n```Java []\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int len = dislikes.length;\\n        boolean[] check = new boolean[len];\\n        int[] arr = new int[n + 1];\\n        boolean foundNew;\\n        for(int i = 0; i < len; i++){\\n            if(check[i]) continue;\\n            arr[dislikes[i][0]] = 1;\\n            arr[dislikes[i][1]] = 2;\\n            foundNew = true;\\n            while(foundNew){\\n                foundNew = false;\\n                for(int j = i + 1; j < len; j++){\\n                    if(check[j]) continue;\\n                    int x = arr[dislikes[j][0]];\\n                    int y = arr[dislikes[j][1]];\\n                    if(x == 0 && y == 0) continue;\\n                    if(x > 0 && y > 0){\\n                        if((x - y) % 2 == 0) return false;\\n                    }\\n                    else if(x > 0) arr[dislikes[j][1]] = x + 1;\\n                    else arr[dislikes[j][0]] = y + 1;\\n                    foundNew = true;\\n                    check[j] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465190,
                "title": "java-very-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<dislikes.length;i++){\\n            adj.get(dislikes[i][0]).add(dislikes[i][1]);\\n             adj.get(dislikes[i][1]).add(dislikes[i][0]);\\n        }\\n\\n        int color[]=new int[n+1];\\n        Arrays.fill(color,-1);\\n\\n        for(int i=1;i<=n;i++){\\n            if(color[i]==-1){\\n                if(bfs(i,adj,color)==false) return false;\\n            }\\n        }\\n        return true;\\n  \\n    }\\n\\n    public boolean bfs(int i,ArrayList<ArrayList<Integer>>adj,int color[]){\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(i);\\n        color[i]=1;\\n\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n\\n            for(int e:adj.get(node)){\\n                if(color[e]==-1){\\n                    color[e]=1-color[node];\\n                    q.add(e);\\n                }\\n\\n                else if(color[e]==color[node]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<dislikes.length;i++){\\n            adj.get(dislikes[i][0]).add(dislikes[i][1]);\\n             adj.get(dislikes[i][1]).add(dislikes[i][0]);\\n        }\\n\\n        int color[]=new int[n+1];\\n        Arrays.fill(color,-1);\\n\\n        for(int i=1;i<=n;i++){\\n            if(color[i]==-1){\\n                if(bfs(i,adj,color)==false) return false;\\n            }\\n        }\\n        return true;\\n  \\n    }\\n\\n    public boolean bfs(int i,ArrayList<ArrayList<Integer>>adj,int color[]){\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(i);\\n        color[i]=1;\\n\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n\\n            for(int e:adj.get(node)){\\n                if(color[e]==-1){\\n                    color[e]=1-color[node];\\n                    q.add(e);\\n                }\\n\\n                else if(color[e]==color[node]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303985,
                "title": "c-bipartite-graph-solution",
                "content": "We can represent this problem in a graph form where the nodes represent person and edge between two nodes(persons) means that one of the two persons dislike the other. So they have to be in separate sets. \\n\\nThis can be solved by forming a **Bipartite graph**, in which two adjacent nodes are always colored in two different colors. Since we are supposed to separate the persons into two groups, we will take two colors and try to color all the adjacent nodes in different colors. If two adjacent nodes are colored with the same color, we can return true (Those two persons will be in the same group).\\n\\n> 0. Uncolored\\n> 1. Red - Set 1\\n> 2. Blue - Set 2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    #define uncolored 0\\n    #define red 1\\n    #define blue 2\\n\\n    vector<vector<int>>adjList;\\n    vector<int>visited,colors;\\n\\n    bool coloringDfs(int person,int color){\\n        visited[person]=1;\\n\\n        //coloring the person\\n        if(color==uncolored || color==blue) colors[person]=red;\\n        else colors[person]=blue;\\n\\n        for(int &disliked:adjList[person]){\\n            //if two disliking persons in same set (color) \\n            if(visited[disliked] && colors[disliked]==colors[person]) return true;\\n            \\n            //if the dfs call for coloring returns true (somewhere two disliking persons are in same set) \\n            if(!visited[disliked] && coloringDfs(disliked,colors[person])) return true;\\n        }\\n\\n        // all disliking persons are in separate sets in this component\\n        return false;\\n    }\\n\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        colors.resize(n),visited.resize(n),adjList.resize(n);\\n\\n        for(auto &it:dislikes){\\n            adjList[it[0]-1].push_back(it[1]-1);\\n            adjList[it[1]-1].push_back(it[0]-1);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            //checking for all components\\n            if(!visited[i] && coloringDfs(i,uncolored)) return false;   \\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V+E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define uncolored 0\\n    #define red 1\\n    #define blue 2\\n\\n    vector<vector<int>>adjList;\\n    vector<int>visited,colors;\\n\\n    bool coloringDfs(int person,int color){\\n        visited[person]=1;\\n\\n        //coloring the person\\n        if(color==uncolored || color==blue) colors[person]=red;\\n        else colors[person]=blue;\\n\\n        for(int &disliked:adjList[person]){\\n            //if two disliking persons in same set (color) \\n            if(visited[disliked] && colors[disliked]==colors[person]) return true;\\n            \\n            //if the dfs call for coloring returns true (somewhere two disliking persons are in same set) \\n            if(!visited[disliked] && coloringDfs(disliked,colors[person])) return true;\\n        }\\n\\n        // all disliking persons are in separate sets in this component\\n        return false;\\n    }\\n\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        colors.resize(n),visited.resize(n),adjList.resize(n);\\n\\n        for(auto &it:dislikes){\\n            adjList[it[0]-1].push_back(it[1]-1);\\n            adjList[it[1]-1].push_back(it[0]-1);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            //checking for all components\\n            if(!visited[i] && coloringDfs(i,uncolored)) return false;   \\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249803,
                "title": "simple-c-solution-bfs-and-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to split them in two groups so we can think of bipartite graphs i.e. sipliting graph into two based on two color, where no two adjacent nodes have same color\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use the same approach of bipartite graph and apply BFS or DFS\\n\\n# BFS Solution\\n```\\nclass Solution {\\npublic:\\n    bool bfs(vector<int> adj[],int node,vector<int> &color,int currColor){\\n        color[node]=currColor;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int currNode=q.front();\\n            q.pop();\\n            for(auto adjNode:adj[currNode]){\\n                if(color[adjNode]==-1){\\n                    q.push(adjNode);\\n                    color[adjNode]=!color[currNode];\\n                }\\n                else if(color[adjNode]==color[currNode]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        // Creating Graph\\n        vector<int> adj[n+1];\\n        for(auto dislike:dislikes){\\n            adj[dislike[0]].push_back(dislike[1]);\\n            adj[dislike[1]].push_back(dislike[0]);\\n        }\\n        vector<int> color(n+1,-1);\\n        for(int i=0;i<=n;i++){\\n            if(color[i]==-1){\\n                if(bfs(adj,i,color,0)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n# DFS Solution\\n```\\nclass Solution {\\npublic: \\n    bool dfs(vector<int> adj[],int node,vector<int> &color,int currColor){\\n        color[node]=currColor;\\n        for(auto adjNode:adj[node]){\\n            if(color[adjNode]==-1){\\n                if(dfs(adj,adjNode,color,!currColor)==false){\\n                    return false;\\n                }\\n            }\\n            else if(color[adjNode]==currColor){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        // [a,b] -> a does not like b and vice-versa\\n        vector<int> adj[n+1];\\n        for(auto dislike:dislikes){\\n            adj[dislike[0]].push_back(dislike[1]);\\n            adj[dislike[1]].push_back(dislike[0]);\\n        }\\n        vector<int> color(n+1,-1);// indexing from 1 to n\\n        for(int i=0;i<=n;i++){\\n            if(color[i]==-1){\\n                if(dfs(adj,i,color,0)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(vector<int> adj[],int node,vector<int> &color,int currColor){\\n        color[node]=currColor;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int currNode=q.front();\\n            q.pop();\\n            for(auto adjNode:adj[currNode]){\\n                if(color[adjNode]==-1){\\n                    q.push(adjNode);\\n                    color[adjNode]=!color[currNode];\\n                }\\n                else if(color[adjNode]==color[currNode]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        // Creating Graph\\n        vector<int> adj[n+1];\\n        for(auto dislike:dislikes){\\n            adj[dislike[0]].push_back(dislike[1]);\\n            adj[dislike[1]].push_back(dislike[0]);\\n        }\\n        vector<int> color(n+1,-1);\\n        for(int i=0;i<=n;i++){\\n            if(color[i]==-1){\\n                if(bfs(adj,i,color,0)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    bool dfs(vector<int> adj[],int node,vector<int> &color,int currColor){\\n        color[node]=currColor;\\n        for(auto adjNode:adj[node]){\\n            if(color[adjNode]==-1){\\n                if(dfs(adj,adjNode,color,!currColor)==false){\\n                    return false;\\n                }\\n            }\\n            else if(color[adjNode]==currColor){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        // [a,b] -> a does not like b and vice-versa\\n        vector<int> adj[n+1];\\n        for(auto dislike:dislikes){\\n            adj[dislike[0]].push_back(dislike[1]);\\n            adj[dislike[1]].push_back(dislike[0]);\\n        }\\n        vector<int> color(n+1,-1);// indexing from 1 to n\\n        for(int i=0;i<=n;i++){\\n            if(color[i]==-1){\\n                if(dfs(adj,i,color,0)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151449,
                "title": "union-find-super-fast-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n\\n    private int union(int p1, int p2) {\\n        int find1 = find(p1);\\n        int find2 = find(p2);\\n        if (find1 == find2) return find1;\\n        if (rank[find1] > rank[find2]) {\\n            parent[find2] = find1;\\n            return find1;\\n        } else if (rank[find1] < rank[find2]) {\\n            parent[find1] = find2;\\n            return find2;\\n        } else {\\n            parent[find2] = find1;\\n            rank[find1]++;\\n            return find1;\\n        }\\n    }\\n\\n    private int find(int p) {\\n        if (parent[p] != p) {\\n            return parent[p] = find(parent[p]);\\n        }\\n        return p;\\n    }\\n\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        parent = new int[n + 1];\\n        rank = new int[n + 1];\\n        int[] map = new int[n + 1];\\n        for (int i = 0; i < parent.length; i++) {\\n            parent[i] = i;\\n        }\\n        for (int[] dislike : dislikes) {\\n            int dis1 = dislike[0];\\n            int dis2 = dislike[1];\\n            if (map[dis1] == 0) map[dis1] = dis2;\\n            else map[dis1] = union(dis2, map[dis1]);\\n\\n            if (map[dis2] == 0) map[dis2] = dis1;\\n            else map[dis2] = union(dis1, map[dis2]);\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (map[i] != 0 && find(i) == find(map[i])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n\\n    private int union(int p1, int p2) {\\n        int find1 = find(p1);\\n        int find2 = find(p2);\\n        if (find1 == find2) return find1;\\n        if (rank[find1] > rank[find2]) {\\n            parent[find2] = find1;\\n            return find1;\\n        } else if (rank[find1] < rank[find2]) {\\n            parent[find1] = find2;\\n            return find2;\\n        } else {\\n            parent[find2] = find1;\\n            rank[find1]++;\\n            return find1;\\n        }\\n    }\\n\\n    private int find(int p) {\\n        if (parent[p] != p) {\\n            return parent[p] = find(parent[p]);\\n        }\\n        return p;\\n    }\\n\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        parent = new int[n + 1];\\n        rank = new int[n + 1];\\n        int[] map = new int[n + 1];\\n        for (int i = 0; i < parent.length; i++) {\\n            parent[i] = i;\\n        }\\n        for (int[] dislike : dislikes) {\\n            int dis1 = dislike[0];\\n            int dis2 = dislike[1];\\n            if (map[dis1] == 0) map[dis1] = dis2;\\n            else map[dis1] = union(dis2, map[dis1]);\\n\\n            if (map[dis2] == 0) map[dis2] = dis1;\\n            else map[dis2] = union(dis1, map[dis2]);\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (map[i] != 0 && find(i) == find(map[i])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096335,
                "title": "java-solution-2-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int len = dislikes.length;\\n        boolean[] check = new boolean[len];\\n        int[] arr = new int[n + 1];\\n        boolean foundNew;\\n        for(int i = 0; i < len; i++){\\n            if(check[i]) continue;\\n            arr[dislikes[i][0]] = 1;\\n            arr[dislikes[i][1]] = 2;\\n            foundNew = true;\\n            while(foundNew){\\n                foundNew = false;\\n                for(int j = i + 1; j < len; j++){\\n                   if(check[j]) continue;\\n                   int x = arr[dislikes[j][0]], y = arr[dislikes[j][1]];\\n                   if(x == 0 && y == 0) continue;\\n                   if(x > 0 && y > 0){\\n                       if((x - y) % 2 == 0) return false;\\n                   } \\n                   else if(x > 0) arr[dislikes[j][1]] = x + 1;\\n                   else arr[dislikes[j][0]] = y + 1;\\n                   foundNew = true;\\n                   check[j] = true;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        int len = dislikes.length;\\n        boolean[] check = new boolean[len];\\n        int[] arr = new int[n + 1];\\n        boolean foundNew;\\n        for(int i = 0; i < len; i++){\\n            if(check[i]) continue;\\n            arr[dislikes[i][0]] = 1;\\n            arr[dislikes[i][1]] = 2;\\n            foundNew = true;\\n            while(foundNew){\\n                foundNew = false;\\n                for(int j = i + 1; j < len; j++){\\n                   if(check[j]) continue;\\n                   int x = arr[dislikes[j][0]], y = arr[dislikes[j][1]];\\n                   if(x == 0 && y == 0) continue;\\n                   if(x > 0 && y > 0){\\n                       if((x - y) % 2 == 0) return false;\\n                   } \\n                   else if(x > 0) arr[dislikes[j][1]] = x + 1;\\n                   else arr[dislikes[j][0]] = y + 1;\\n                   foundNew = true;\\n                   check[j] = true;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1723407,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1573823,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723063,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723373,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723115,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723495,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723439,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723278,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723224,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1826689,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723407,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1573823,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723063,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723373,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723115,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723495,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723439,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723278,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1723224,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1826689,
                "content": [
                    {
                        "username": "DeltaLF",
                        "content": "Should we return false if people hate themselves?"
                    },
                    {
                        "username": "Contone",
                        "content": "[@mandeep200](/mandeep200) Ya, pretending to be happy is the best life advice XD"
                    },
                    {
                        "username": "prasflames16",
                        "content": "This comment cracked me up lol"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@mandeep200](/mandeep200) \\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "ichbinmandeep",
                        "content": "We don\\'t need to handle that case as per the question description."
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "If you\\'re like me and don\\'t like looking at solutions when stuck here\\'s a hint:\\n\\nRephrase the problem as a *graph*. Now, the [2-coloring problem](http://https://en.wikipedia.org/wiki/Graph_coloring) seems quite familiar to choosing two groups...\\n\\n### Further hint/spoilers:\\n\\nLet the numbers 1-N be vertices/nodes in a graph, and \\'dislikes\\' represent edges between them. Use DFS."
                    },
                    {
                        "username": "Joald",
                        "content": "[@xr_wan](/xr_wan) run the procedure for each connected component"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Thank you for the hint!\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "What to do with disjoint graph?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@nirutgupta78](/nirutgupta78) bro how did you got into cloudera ? off campus (if so how did you apply) , on campus ?"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Why why why, it didn\\'t came to my mind."
                    },
                    {
                        "username": "kaleen_981",
                        "content": "The above question is an application of checking bipartite graph.I can be visualise easily by drawing the graph using given nodes ( n ) and edges ( dislikes ) value. The testcase where the answer is true in that case the graph is bipartite or vice-versa.So before approaching this problem , it will be good if you have a basic idea of bfs/dfs approach alongwith bipartite graph checking algorithm. \\n\\nHope this will help you.If you like this then upvote :))"
                    },
                    {
                        "username": "anau99",
                        "content": "If two nodes are adjacent, color them differently. We use DFS/BFS to solve it, when they are same a color return false. However we should note Nodes without adjacency list"
                    },
                    {
                        "username": "gabhinav",
                        "content": "[@skvengi](/skvengi) yes, you will have to run a loop, run the bipartite algorithm for all the nodes which havent been visited in particular cycle. For eg. in your case, you run a loop for 1 to n. and in each loop you run the bipartite if visited[i] = false."
                    },
                    {
                        "username": "skvengi",
                        "content": "In graph it is joint, where as in this question it can be disjoint like [[1,2],[3,4],[5,6],[6,7],[8,9],[7,8]] here if we assume 1 as parent node, we don\\'t have any relation bw 1 and other node apart from 2, so many graph will be formed, I am really confused."
                    },
                    {
                        "username": "qiushile",
                        "content": " you should realize it is a bi-directional graph, after that, it becomes easy"
                    },
                    {
                        "username": "thezenblogger",
                        "content": "The question however doesn\\'t clearly mention it, other than that it\\'s simple"
                    },
                    {
                        "username": "onkardighe",
                        "content": "You saved me \\xA0"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "If you can\\'t solve it search about (Bipartite graph)\\n\\n\\nthe idea of Bipartite graph is you color node with white and its children with black, then at any\\ntime if you want to color node and it is having a color that different\\nfrom the color you want now return false"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@Abdelmohaymn](/abdelmohaymn) Do you know how to use Union Find to solve this? It has Union Find in the tag. "
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "[@DaEpicR](/DaEpicR) happy to hear this"
                    },
                    {
                        "username": "DaEpicR",
                        "content": "This tip actually helped me a little bit"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "I suggest adding this test case on the judge:\n`n = 4`\n`[ [1,2], [2,3], [3,4], [2,4] ]`\nMy earlier submission passed all of the test cases on the judge. So, I got accepted.\nBut it failed in this corner case ( I made this test case ). So, please add such cases so that people have to be more accurate of their solutions."
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I tried ```contribute a testcase```. They resolved the issue. :)"
                    },
                    {
                        "username": "jakariyabd",
                        "content": "[@zebra-f](/zebra-f) I didn\\'t notice that. Thank you. :)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "When you `Run` your code there is `Contribute a testcase` under each Case, although I don\\'t know what it does, try to use it.  "
                    },
                    {
                        "username": "santanusen",
                        "content": "Though I could ultimately come up with the solution, it took me so long; around a couple of hours.\\nInterviews last only for 40 mins or so. :("
                    },
                    {
                        "username": "amanchandna",
                        "content": "For intuition : \\n1 - Build an adjacency matrix first compulsory,\\n2 - Think of filling adjacent vertex with different colors,\\n3 - Use only two colors\\n4 - Question1 , what is color?\\nAnswer : 2 color can be any two number (1,-1),(1,0),(0,1) use as per language compatibility.\\n5 - Question 2, How to fill colors?\\nAnswer : Any traversal technique : BFS,DFS"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am confused ,this is a directed graph ,so why when implementing coloring algo it is showing wrong ans for directed graph but when I use it as a undirected graph it is all correct?"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nitin987](/nitin987) out of all reasoning I was given,yours was crystal clear thanks"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@nrip_saggu](/nrip_saggu) no you cannot just say it will be true vice versa also but because its given \" they should not go into the same group.\" the second person is forced to dislike the first person.\\n\\n"
                    },
                    {
                        "username": "nrip_saggu",
                        "content": "it will undirected because if one person does not like other it same for other other person does not like first person, so directed graph does not make any sense."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@nitin987](/nitin987) \\nyes man !! If you draw directed graph instead of undirected graph then it will fail at test cast 79 !! "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "If \\'a\\' does not like \\'b\\' then there is an edge from \\'a\\' to \\'b\\'.\\n\\nNow there is no edge from \\'b\\' to \\'a\\', which means from \\'b\\' perspective it is ok to put \\'b\\' and \\'a\\' in same group but from \\'a\\' perspective it is not. \\n\\nFurther \\'a\\' and \\'b\\' can never be in same group so an edge between \\'b\\' to \\'a\\' is self-implied.\\nThis becomes an undirected graph now.\\n"
                    },
                    {
                        "username": "RagingCorgi",
                        "content": "The question needs to clearly state the dislike is bi-directional"
                    },
                    {
                        "username": "Karunika",
                        "content": "i agree, it is because of that it took me an eternity to solve"
                    }
                ]
            },
            {
                "id": 1728344,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1727541,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1981317,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1980382,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1899060,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1898683,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1819455,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1815091,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1750685,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1725372,
                "content": [
                    {
                        "username": "adityadeore1979",
                        "content": "Tried this using recursion but got a TLE at test 40 itself. Learnt something new with Bipartite graphs. Below is a great video\\nhttps://www.youtube.com/watch?v=1aZ55OvewvI"
                    },
                    {
                        "username": "Dharun_Bharathi",
                        "content": "Can anyone help me with this code, here? It shows wrong answer for a test case with 50 nodes in the graph. I\\'ve gone through the solutions too. But similar answer is only available there and I can\\'t figure out what is wrong with mine..!\\n\\n class Solution {\\n    public boolean check(ArrayList<ArrayList<Integer>> adj, int[] color, int node){\\n        if(color[node] == -1) color[node] = 1;\\n        for(Integer it : adj.get(node)){\\n            if(color[it] == -1){\\n                color[it] = 1 - color[node];\\n                if(check(adj, color, it) == false) return false;\\n            }\\n            else if(color[it] == color[node]) return false;\\n        }\\n        return true;\\n    }\\n    public boolean possibleBipartition(int n, int[][] dislikes) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        int color[] = new int[n+1];\\n        Arrays.fill(color, -1);\\n        for(int i=0; i<n+1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int[] a : dislikes){\\n            adj.get(a[0]).add(a[1]);\\n        }\\n        for(int i=1; i<n+1; i++){\\n            if(check(adj, color, i) == false) return false;\\n        }\\n        return true;\\n}\\n}"
                    },
                    {
                        "username": "mm541145",
                        "content": "it\\'s same as LC 785"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "do https://leetcode.com/problems/is-graph-bipartite/ before attempting this one, same code"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Same method as in https://leetcode.com/problems/is-graph-bipartite/description/\\nSolve it!"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "How is it bi-directional graph?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "How we will find out that given graph is ```Bi-Directional``` 🙂"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/is-graph-bipartite/description/"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "class Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        disjointSet=list()\\n\\n        for i in range(n+1):\\n            disjointSet.append(i)\\n        \\n        for sets in dislikes:\\n            a=sets[0]\\n            b=sets[1]\\n\\n            if(disjointSet[a]==a and disjointSet[b]==b):\\n                disjointSet[a]=b \\n                disjointSet[b]=a \\n            \\n            elif(disjointSet[a]!=a and disjointSet[b]==b):\\n                disjointSet[b]=disjointSet[disjointSet[a]]\\n            elif(disjointSet[a]==a and disjointSet[b]!=b):\\n                disjointSet[a]=disjointSet[disjointSet[b]]\\n            elif disjointSet[a]==disjointSet[b]:\\n                return False \\n        \\n        return True\\n\\n\\ncan anyone tell me please why it is not working for \\nn=4\\n[[1,2],[3,4],[1,3],[1,4]]\\nreturning true "
                    },
                    {
                        "username": "cheetha_lc",
                        "content": "tip if you are stuck in corner cases - there can be more than one connected components in the graph and the the graph is bidirectional "
                    }
                ]
            },
            {
                "id": 1725084,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1724370,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1724230,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1724030,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723966,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723946,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723882,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723859,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723838,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723757,
                "content": [
                    {
                        "username": "supriya199",
                        "content": "Java Code :\\nclass Solution {\\n    private Map<Integer, List<Integer>> graph;\\n    private int[] visited;\\n    public boolean possibleBipartition(int N, int[][] dislikes) {\\n        if(N == 0 || dislikes.length == 0) return true;\\n        graph = new HashMap<>();\\n        for(int[] dislike : dislikes){\\n            List<Integer> temp = graph.containsKey(dislike[0]) ? graph.get(dislike[0]): new ArrayList<>();\\n            temp.add(dislike[1]);\\n            graph.put(dislike[0], temp);\\n            temp = graph.containsKey(dislike[1]) ? graph.get(dislike[1]): new ArrayList<>();\\n            temp.add(dislike[0]);\\n            graph.put(dislike[1], temp);\\n        }\\n        visited = new int[N + 1];\\n        for(int i = 0; i < N; i++){\\n            if(visited[i] == 0){\\n                if(!dfs(i, 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean dfs(int node, int color){\\n        if(visited[node] != 0 && visited[node] != color) return false;\\n        if(visited[node] == color) return true;\\n        visited[node] = color;\\n        List<Integer> neighbours = graph.get(node);\\n        if(neighbours == null) return true;\\n        for(Integer neighbour : neighbours){\\n            if(!dfs(neighbour, -color)) return false;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "krishna2510",
                        "content": "Hey whats wrong in this solution....its a simple implementation to check if a graph is bipartie or not....help...!!!\\n\\n\\n\\nclass Solution {\\npublic:\\n    void dfs(int i,vector<vector<int>>& adj,vector<int>& grp,vector<int>& vis,int g,bool& ans){\\n        if(vis[i]!=-1){\\n            if(g!=grp[i]){\\n                cout<<\"at i=\"<<i<<\" and grp[i]=\"<<grp[i]<<\" and g=\"<<g<<endl;\\n                ans=false;\\n                return;\\n            }\\n        }\\n        vis[i]=1;\\n        grp[i]=g;\\n        int ng=(g==1)?0:1;\\n        for(int j=0;j<adj[i].size();j++){\\n            dfs(adj[i][j],adj,grp,vis,ng,ans);\\n        }\\n    }\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        vector<vector<int>> adj(n+1);\\n        for(int i=0;i<dislikes.size();i++){\\n            adj[dislikes[i][0]].push_back(dislikes[i][1]);\\n        }\\n        vector<int> vis(n+1,-1);\\n        vector<int> grp(n+1);\\n        bool ans=true;\\n        for(int i=1;i<=n;i++){\\n            if(vis[i]==-1){\\n                dfs(i,adj,grp,vis,0,ans);\\n            }\\n        }\\n        return ans; \\n\\n    }\\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "This problem is similar with [Satisfiability of equality equations](https://leetcode.com/problems/satisfiability-of-equality-equations/submissions/863191969/)\n\"a==b\", \"b==c\", \"a!=c\" two groups, equality and inequality.\nThe 1st example:\nInput: n = 4, dislikes = [[1,2],[1,3],[2,4]]\n->  a!=b, a!=c, b!=d => a=d, b=c => True"
                    },
                    {
                        "username": "lovely08",
                        "content": "```class Solution {\\npublic:\\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\\n        \\n        vector<int> jk[n];\\n        vector<int> op(n+1, -1);\\n        if(dislikes.empty()){\\n            return true;\\n        }\\n        set<int> yu;\\n        for(auto gh : dislikes)\\n        {\\n        int v = gh[0];\\n        int v2= gh[1];\\n        jk[v].push_back(gh[1]);\\n        \\n        yu.insert(v);\\n       \\n\\n        }\\n       \\n        int k=1;\\n        for(auto j : yu){\\n            if(op[j] == -1)\\n           { \\n              op[j] = 1;\\n           }  \\n         vector<int> bn = jk[j];\\n        if(!bn.empty())\\n       {\\n           \\n        for(auto x : bn){\\n         \\n        if(op[x]==-1){\\n        op[x]=1-op[j];\\n\\n        }\\n        \\n        else if(op[x]==op[j]){\\n            return false;\\n        }   \\n               \\n        }\\n       \\n       }\\n       \\n        } \\n        if(op.size()==0){\\n            return true;\\n        }\\n        map<int,int> mp1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(op[i]==-1)\\n            continue;\\n            mp1[op[i]]++;\\n            cout<<op[i]<<\" \";\\n        }\\n     return mp1.size()==2;\\n\\n    }\\n};```"
                    },
                    {
                        "username": "imsanjaybisht",
                        "content": "can we solve this question using HashMap/HashSet ?\\nTrying for so long but no luck"
                    },
                    {
                        "username": "natnael_tadele",
                        "content": "Do  [is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) and comeback to solve this one."
                    },
                    {
                        "username": "mellamanelpoeta",
                        "content": "Is being acyclic sufficient and necessary for getting a bipartition?"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "However, having no odd-length cycle subgraphs is sufficient to figure out if a bipartition exists."
                    },
                    {
                        "username": "serhankars",
                        "content": "No it is not. Lets assume x->y  is the notation of x dislikes y. \\nFor a case like:\\nNodes =  [a,b,c,d] \\na->b->c->d->a  : is a cycle \\n\\nBut you can depart it like [a,c] [ b,d] "
                    },
                    {
                        "username": "Pecchi7",
                        "content": "C++ Specific Doubt:\\n\\nIf I have defined mhy bfs method without & like below, I got TLE for 15 test cases.\\n bool bfs(int source, vector<vector<int>> adj, vector<int> color) \\n\\nWhen I added & to vector declarations as below, my solution was accepted. \\n bool bfs(int source, vector<vector<int>>& adj, vector<int>& color) \\n\\nI am very curious to understand what is the reason behind it. Both didnt throw any exception but apparently there is a lot of time gap in execution. Someone please help me understand what is the reason behind this behavior. \\nThank you."
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "without & it is actually creating a new vector and copying all the values which is taking time. "
                    },
                    {
                        "username": "patilabhay679",
                        "content": "can someone tell what condition went wrong? 64/70 passed, \\n\\n```\\nclass Solution:\\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\\n        ct = {}\\n        for x,y in dislikes:\\n            if x not in d:\\n                d[x] = set([y])\\n            else:\\n                d[x].add(y)\\n            \\n            if y not in d:\\n                d[y] = set([x])\\n            else:\\n                d[y].add(x)\\n\\n        group_left= set()\\n        group_right =set()\\n\\n        for person,cant_stand_with in ct.items():\\n            if person in group_left:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        return False\\n                    group_right.add(other_person)\\n\\n            elif person in group_right:\\n                for other_person in cant_stand_with:\\n                    if other_person in group_right:\\n                        return False\\n                    group_left.add(other_person)\\n                    \\n            else:\\n                left_count = 0\\n                right_count  = 0 \\n                for other_person in cant_stand_with:\\n                    if other_person in group_left:\\n                        left_count +=1\\n\\n                    if other_person in group_right:\\n                        right_count +=1\\n\\n                if left_count or right_count:\\n                    if left_count and right_count:\\n                        return False\\n                    \\n                    elif left_count:\\n                        group_right.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_left.add(other_person)\\n                    \\n                    else:\\n                        group_left.add(person)\\n                        for other_person in cant_stand_with:\\n                            group_right.add(other_person)\\n                else:\\n                    group_left.add(person)\\n                    for other_person in cant_stand_with:\\n                        group_right.add(other_person)\\n                    \\n        return True\\n```\\n\\n64/70 test case:\\nn= 1000\\n# please provide feedback. cannot put dislikes data here as it is too large for comment."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Dislike is bi-directional?\\nno-one told that \\uD83D\\uDE11"
                    },
                    {
                        "username": "user8293Xb",
                        "content": "It comes from noticing that if 1 dislikes 2, it doesn\\'t matter if 2 dislikes 1 or not; they still can\\'t be in the same partition. So, we can treat the edges as undirected since we don\\'t care who dislikes who between two people."
                    },
                    {
                        "username": "stst3",
                        "content": "I think the idea is if the graph is 2->1, if we first assign default Red to node 1 the traversal stops. We go to node 2, assign it default Red and this leads to contradiction but we could have easily divided graph into to 2 groups. So if want to use the Bipartite algorithm we should make it undirected."
                    }
                ]
            },
            {
                "id": 1723730,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723706,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723701,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723606,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723585,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723576,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723573,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723559,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723558,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            },
            {
                "id": 1723536,
                "content": [
                    {
                        "username": "AK-aShH",
                        "content": "Can anyone please help me out with this error, what exactly is the source of such kind of error, I searched the web as well but didnt find any relevant workaround?\\n`Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9 `your inline code...your inline code...`"
                    },
                    {
                        "username": "l_9",
                        "content": "[@Akash Yadav](/akash_36437) I was also getting the same error, when I was trying to iterate a for loop from 0 to n instead of 0 to the length of the dislikes array."
                    },
                    {
                        "username": "AK-aShH",
                        "content": "[@vivekjoshi556](/vivekjoshi556) Thanks, spotted my problem where it was going wrong"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Can you provide some code as well. Maybe you are trying to access some memory location that isn\\'t available, such as some out of bound index in a vector."
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "why its showing me that time limit exceeded>??\\n\\n"
                    },
                    {
                        "username": "avishkarpandit",
                        "content": "[@vivekjoshi556](/vivekjoshi556) I got the help thank you\\uD83D\\uDE0A"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Without your code no one can specifically help you with anything. But your code is taking is more time than is provided to execute your solution."
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "try to give hint only in one line it will be more helpful\\n"
                    },
                    {
                        "username": "vivekjoshi556",
                        "content": "Think about assigning different values to adjacent nodes (2 different values) if they don\\'t already belong to a group. "
                    },
                    {
                        "username": "Gurugi01",
                        "content": "Can someone explain. what is the intution behind creating graph as undirected ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "\"a cannot be in the same group as b\" also means that \"b cannot be in the same group as a\"."
                    },
                    {
                        "username": "lavlesh_15",
                        "content": "Hint : Check Graph Bipartiteness.\\n\\nSimple DFS Approach Explanation : https://leetcode.com/problems/possible-bipartition/solutions/2935695/java-dfs-graph-coloring-approach/"
                    },
                    {
                        "username": "vchhabra949",
                        "content": "is it possible to do it with sets??\\n"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "can this question be solved using the logic of cycle detection in graph?"
                    },
                    {
                        "username": "msoni00005",
                        "content": "if a graph has odd length cycle then it is not bipartite but if the graph doesn\\'t contain a cycle or has even length cycle then it is bipartite.\\nyou can check these conditions to determine if given graph is bipartite or not."
                    },
                    {
                        "username": "deydhananjoy",
                        "content": "HELP ME DEBUG MY C++ CODE [DSU]\\nhttps://leetcode.com/problems/possible-bipartition/submissions/863239746/"
                    },
                    {
                        "username": "math3846",
                        "content": "Let's generalize the problem. If I want to divide into three or more groups(NOT two groups), how can I solve it?"
                    },
                    {
                        "username": "sushilbajpai",
                        "content": "how to know which data structure is to be applied ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "question_content": "Given an integer number <code>n</code>, return the difference between the product of its digits and the sum of its digits.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 234\n<strong>Output:</strong> 15 \n<b>Explanation:</b> \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4421\n<strong>Output:</strong> 21\n<b>Explanation: \n</b>Product of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 446372,
                "title": "java-c-python-straight-forward-solution",
                "content": "## **Complexity**\\nTime `O(logN)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        while (n > 0) {\\n            sum += n % 10;\\n            product *= n % 10;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        for (; n > 0; n /= 10) {\\n            sum += n % 10;\\n            product *= n % 10;\\n        }\\n        return product - sum;\\n    }\\n```\\n\\n**Python:**\\nSpace `O(logN)`\\n```python\\n    def subtractProductAndSum(self, n):\\n        A = map(int, str(n))\\n        return reduce(operator.mul, A) - sum(A)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        while (n > 0) {\\n            sum += n % 10;\\n            product *= n % 10;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n```\n```cpp\\n    int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        for (; n > 0; n /= 10) {\\n            sum += n % 10;\\n            product *= n % 10;\\n        }\\n        return product - sum;\\n    }\\n```\n```python\\n    def subtractProductAndSum(self, n):\\n        A = map(int, str(n))\\n        return reduce(operator.mul, A) - sum(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 812200,
                "title": "python-one-liner-using-eval-function-28ms-14mb",
                "content": "Solution is relatively straightforward. You just have to make sure to cast `n` to be a string.\\n\\n```Python\\ndef subtractProductAndSum(n)t:\\n    return eval(\\'*\\'.join(str(n))) - eval(\\'+\\'.join(str(n)))\\n```\\n\\nThe time complexity of this solution is O(n) due to the two `join` operations.\\n\\n### Edit\\nAs somebody said in the comments section, it\\'s worth noting that the `eval` function of Python isn\\'t safe. For those of you curious why, there\\'s a great [Stack Overflow question](https://stackoverflow.com/questions/35804961/python-eval-is-it-still-dangerous-if-i-disable-builtins-and-attribute-access) and also an [in-depth blog post](https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).\\n\\nIt\\'s worth noting that if you use the `eval` function during an interview, the interviewers may ask you if you\\'re aware of the security implications.\\n\\nHappy coding!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\ndef subtractProductAndSum(n)t:\\n    return eval(\\'*\\'.join(str(n))) - eval(\\'+\\'.join(str(n)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 446348,
                "title": "java-python-3-straight-forword-code-w-analysis",
                "content": "\\n```java\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0, prod = 1;\\n        while (n > 0) {\\n            int digit = n % 10;\\n            sum += digit;\\n            prod *= digit;\\n            n /= 10;\\n        } \\n        return prod - sum;       \\n    }\\n```\\n```python\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sum, prod = 0, 1\\n        while n:\\n            digit = n % 10\\n            sum += digit\\n            prod *= digit\\n            n //= 10\\n        return prod - sum\\n```\\nsimplification using `divmod`, credit to **@ajc2001**\\n```python\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sum, prod = 0, 1\\n        while n:\\n            n, digit = divmod(n, 10)\\n            sum += digit\\n            prod *= digit\\n        return prod - sum\\n```\\n**Analysis:**\\nTime: `O(logn)`, space: `O(1)`.",
                "solutionTags": [],
                "code": "```java\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0, prod = 1;\\n        while (n > 0) {\\n            int digit = n % 10;\\n            sum += digit;\\n            prod *= digit;\\n            n /= 10;\\n        } \\n        return prod - sum;       \\n    }\\n```\n```python\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sum, prod = 0, 1\\n        while n:\\n            digit = n % 10\\n            sum += digit\\n            prod *= digit\\n            n //= 10\\n        return prod - sum\\n```\n```python\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sum, prod = 0, 1\\n        while n:\\n            n, digit = divmod(n, 10)\\n            sum += digit\\n            prod *= digit\\n        return prod - sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 450728,
                "title": "javascript-efficient-and-easy-to-read-44ms-98",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    const digits = Array.from(String(n), Number)\\n    const sum = digits.reduce((a,b) => a+b)\\n    const product = digits.reduce((a,b) => a*b)\\n    return product-sum\\n};\\n```\\n\\n[Array.from -- MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    const digits = Array.from(String(n), Number)\\n    const sum = digits.reduce((a,b) => a+b)\\n    const product = digits.reduce((a,b) => a*b)\\n    return product-sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801418,
                "title": "simple-python-learned-about-builtin-divmod",
                "content": "Didn\\'t know about the divmod() function until this problem. It\\'s an alternative way to iterate through the digits of an integer. By dividing by 10, we iterate backwards through the integer. \\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        my_prod = 1\\n        my_sum = 0\\n        \\n        while n:\\n            n, remainder = divmod(n, 10)\\n            my_prod *= remainder            \\n            my_sum += remainder\\n            \\n        return my_prod - my_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        my_prod = 1\\n        my_sum = 0\\n        \\n        while n:\\n            n, remainder = divmod(n, 10)\\n            my_prod *= remainder            \\n            my_sum += remainder\\n            \\n        return my_prod - my_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482873,
                "title": "python-easy-solution",
                "content": "```\\ndef subtractProductAndSum(self, n: int) -> int:\\n        prod = 1        # n =234\\n        sums = 0\\n        while n != 0:       #           1st loop     2nd loop    3rd loop \\n            last = n % 10   # last =    4            3           2\\n            prod *= last    # prod =    1*4 = 4      4*3 = 12    12*2 = 24\\n            sums += last    # sums =    0+4 = 4      4+3 = 7     7+2 = 9\\n            n =n//10        # n    =    23           2           0\\n        return prod - sums  # 24 - 9 = 15\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef subtractProductAndSum(self, n: int) -> int:\\n        prod = 1        # n =234\\n        sums = 0\\n        while n != 0:       #           1st loop     2nd loop    3rd loop \\n            last = n % 10   # last =    4            3           2\\n            prod *= last    # prod =    1*4 = 4      4*3 = 12    12*2 = 24\\n            sums += last    # sums =    0+4 = 4      4+3 = 7     7+2 = 9\\n            n =n//10        # n    =    23           2           0\\n        return prod - sums  # 24 - 9 = 15\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 447853,
                "title": "javascript-easy-to-understand",
                "content": "I think this strategy is pretty straight forward.\\n\\n```js\\nconst subtractProductAndSum = n => {\\n  let sum = 0;\\n  let prod = 1;\\n  while (n > 0) {\\n    const mod = n % 10;\\n    sum += mod;\\n    prod *= mod;\\n    n = Math.floor(n / 10);\\n  }\\n  return prod - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst subtractProductAndSum = n => {\\n  let sum = 0;\\n  let prod = 1;\\n  while (n > 0) {\\n    const mod = n % 10;\\n    sum += mod;\\n    prod *= mod;\\n    n = Math.floor(n / 10);\\n  }\\n  return prod - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 714994,
                "title": "c-100-time-80-space-time-linear-to-number-of-digits-space-constant",
                "content": "I just produce slicing the last digit off `n` until it boils down to `0`, all the while updating the product `p` and the sum `s` of the digits.\\n\\nNote - I am pretty sure interviewers seeing you convert the number to string, splitting it into `char`s, converting them back to numbers, etc won\\'t be that impressed.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int p = 1, s = 0, t;\\n        while (n) {\\n            t = n % 10;\\n            p *= t;\\n            s += t;\\n            n /= 10;\\n        }\\n        return p - s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int p = 1, s = 0, t;\\n        while (n) {\\n            t = n % 10;\\n            p *= t;\\n            s += t;\\n            n /= 10;\\n        }\\n        return p - s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157584,
                "title": "swift-subtract-the-product-and-sum-of-digits-of-an-integer",
                "content": "```swift\\nclass Solution {\\n    func subtractProductAndSum(_ n: Int) -> Int {\\n        if 1 <= n && n <= 10^5 { return 0 }\\n        var cp = n, products = [Int]()\\n        while cp > 0 {\\n            products.insert(cp % 10, at: 0)\\n            cp /= 10\\n        }\\n        let product = products.reduce(1, *)\\n        let sum = products.reduce(0, +)\\n        return product - sum\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    \\n    func testExample1() {\\n        XCTAssert(s.subtractProductAndSum(234) == 15) // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.subtractProductAndSum(4421) == 21) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func subtractProductAndSum(_ n: Int) -> Int {\\n        if 1 <= n && n <= 10^5 { return 0 }\\n        var cp = n, products = [Int]()\\n        while cp > 0 {\\n            products.insert(cp % 10, at: 0)\\n            cp /= 10\\n        }\\n        let product = products.reduce(1, *)\\n        let sum = products.reduce(0, +)\\n        return product - sum\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    \\n    func testExample1() {\\n        XCTAssert(s.subtractProductAndSum(234) == 15) // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.subtractProductAndSum(4421) == 21) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468188,
                "title": "python-3-two-solutions-faster-than-95-91-of-all-python3-submissions",
                "content": "Using numpy:\\n\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a = [int(x) for x in str(n)]\\n        return np.prod(a) - np.sum(a)\\n```\\n\\nUsing lambda functions:\\n\\n```python\\nfrom functools import reduce\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a = [int(x) for x in str(n)]\\n        return reduce((lambda x, y: x * y), a) - reduce((lambda x, y: x + y), a)\\n```\\n\\nLast one is faster than 95.91% of Python3 submissions and uses less than 100.00% of memory.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport numpy as np\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a = [int(x) for x in str(n)]\\n        return np.prod(a) - np.sum(a)\\n```\n```python\\nfrom functools import reduce\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a = [int(x) for x in str(n)]\\n        return reduce((lambda x, y: x * y), a) - reduce((lambda x, y: x + y), a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713663,
                "title": "python-3-20ms-3-solutions-fastest-iterative-one-liners-super-easy",
                "content": "***1 - Normal Iterative Solution ( 25ms ) :-***\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        p,s=1,0\\n        while n!=0:\\n            p*=(n%10)\\n            s+=(n%10)\\n            n//=10\\n        return p-s\\n```\\n\\n***2 - Using Prod & Sum function [One-Liner] ( 20ms ) :-***\\n*\"prod\" method from the math standard library was added in Python 3.8 onwards.*\\n\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return prod(list(map(int, str(n))))-sum(list(map(int, str(n))))\\n```\\n*Same in 2 Lines:-*\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        arr = list(map(int, str(n)))\\n        return prod(arr)-sum(arr)\\n```\\n\\n***3 - Using Reduce & Multiplication Function ( Takes 30ms ) :-***\\n\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        arr = list(map(int, str(n)))\\n        return reduce(operator.mul, arr) - sum(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        p,s=1,0\\n        while n!=0:\\n            p*=(n%10)\\n            s+=(n%10)\\n            n//=10\\n        return p-s\\n```\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return prod(list(map(int, str(n))))-sum(list(map(int, str(n))))\\n```\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        arr = list(map(int, str(n)))\\n        return prod(arr)-sum(arr)\\n```\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        arr = list(map(int, str(n)))\\n        return reduce(operator.mul, arr) - sum(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577888,
                "title": "java-faster-than-100-00-of-java-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n       \\n        int sum = 0;\\n        int product = 1;\\n       \\n        while (n!=0){\\n           \\n            product *= n%10;\\n            sum += n%10;\\n            n = n/10;\\n        }\\n        \\n        return product-sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n       \\n        int sum = 0;\\n        int product = 1;\\n       \\n        while (n!=0){\\n           \\n            product *= n%10;\\n            sum += n%10;\\n            n = n/10;\\n        }\\n        \\n        return product-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446315,
                "title": "java-short-easy",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        \\n        int prod = 1;\\n        int sum = 0;\\n        while(n > 0){\\n            prod *= n %10;\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        \\n        return prod - sum;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        \\n        int prod = 1;\\n        int sum = 0;\\n        while(n > 0){\\n            prod *= n %10;\\n            sum += n % 10;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3457223,
                "title": "beats-100-best-c-java-python-and-javascript-solution-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*The problem simply asks to find the product and sum of the digits of the input integer, and then return the difference between the product and sum.*\\n\\n---\\n\\n# Approach : *Using Modulo (%)*\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize prod to 1 and sum to 0, which will be used to accumulate the product and sum of digits, respectively.\\n\\n1. Use a while loop to iterate through the digits of the input integer n. The loop continues as long as n is not equal to zero.\\n\\n1. In each iteration, extract the last digit of n by taking the modulus of n with 10, and assign it to a variable lastDigit.\\n\\n1. Multiply prod by lastDigit to accumulate the product of digits, and add lastDigit to sum to accumulate the sum of digits.\\n\\n1. Divide n by 10 to remove the last digit and move on to the next digit.\\n\\n1. Once the loop completes, return the difference between prod and sum.\\n\\n> This approach uses a simple iterative process to extract the digits of n, compute their product and sum, and then return the difference between the two.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1;\\n        int sum = 0;\\n        while(n != 0){\\n            int lastDigit = n%10;\\n            prod = prod * lastDigit;\\n            sum = sum + lastDigit;\\n            n = n/10;\\n        }\\n        return prod - sum;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod = 1;\\n        int sum = 0;\\n        while(n != 0){\\n            int lastDigit = n%10;\\n            prod = prod * lastDigit;\\n            sum = sum + lastDigit;\\n            n = n/10;\\n        }\\n        return prod - sum;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        prod = 1\\n        sum = 0\\n        while n != 0:\\n            lastDigit = n % 10\\n            prod *= lastDigit\\n            sum += lastDigit\\n            n = n // 10\\n        return prod - sum\\n```\\n```JavaScript []\\nvar subtractProductAndSum = function(n) {\\n    let prod = 1;\\n    let sum = 0;\\n    while(n !== 0){\\n        let lastDigit = n % 10;\\n        prod *= lastDigit;\\n        sum += lastDigit;\\n        n = Math.floor(n / 10);\\n    }\\n    return prod - sum;\\n};\\n```\\n\\uD83D\\uDE80 Try it out for yourself and see how it performs!\\n\\n\\n---\\n\\n\\n# Approach : *Using String*\\n<!-- Describe your approach to solving the problem. -->\\n- The optimized solution converts the input integer to a string using the to_string() function. This makes it easy to iterate over each digit of the number using a for loop.\\n\\n- In the for loop, we iterate over each character in the string and convert it to an integer by subtracting the character \\'0\\'. This works because in the ASCII table, the character \\'0\\' has a value of 48, and the characters \\'1\\' to \\'9\\' have consecutive values from 49 to 57.\\n\\n- We then update the product and sum variables by multiplying and adding the current digit to them respectively.\\n\\n- Finally, we return the difference between the product and sum.\\n\\n> This approach avoids the expensive modulo and division operations used in the previous solution, which can be slow for large integers.\\n\\n# Complexity\\n- Time complexity: O(d)\\n> d -> Number of Digits \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(d)\\n> Since here we have used a string of length d\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        string s = to_string(n);\\n        for (char c : s) {\\n            int digit = c - \\'0\\';\\n            prod *= digit;\\n            sum += digit;\\n        }\\n        return prod - sum;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        String s = Integer.toString(n);\\n        for (char c : s.toCharArray()) {\\n            int digit = c - \\'0\\';\\n            prod *= digit;\\n            sum += digit;\\n        }\\n        return prod - sum;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        prod = 1\\n        sum = 0\\n        s = str(n)\\n        for c in s:\\n            digit = int(c)\\n            prod *= digit\\n            sum += digit\\n        return prod - sum\\n```\\n```JavaScript []\\nvar subtractProductAndSum = function(n) {\\n    let prod = 1;\\n    let sum = 0;\\n    let s = n.toString();\\n    for (let i = 0; i < s.length; i++) {\\n        let digit = parseInt(s[i]);\\n        prod *= digit;\\n        sum += digit;\\n    }\\n    return prod - sum;\\n};\\n```\\n\\uD83D\\uDE80 Try it out for yourself and see how it performs!\\n\\n---\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/2dca81a7-0747-4f57-8360-eb7c021b3626_1682509277.815069.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1;\\n        int sum = 0;\\n        while(n != 0){\\n            int lastDigit = n%10;\\n            prod = prod * lastDigit;\\n            sum = sum + lastDigit;\\n            n = n/10;\\n        }\\n        return prod - sum;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod = 1;\\n        int sum = 0;\\n        while(n != 0){\\n            int lastDigit = n%10;\\n            prod = prod * lastDigit;\\n            sum = sum + lastDigit;\\n            n = n/10;\\n        }\\n        return prod - sum;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        prod = 1\\n        sum = 0\\n        while n != 0:\\n            lastDigit = n % 10\\n            prod *= lastDigit\\n            sum += lastDigit\\n            n = n // 10\\n        return prod - sum\\n```\n```JavaScript []\\nvar subtractProductAndSum = function(n) {\\n    let prod = 1;\\n    let sum = 0;\\n    while(n !== 0){\\n        let lastDigit = n % 10;\\n        prod *= lastDigit;\\n        sum += lastDigit;\\n        n = Math.floor(n / 10);\\n    }\\n    return prod - sum;\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        string s = to_string(n);\\n        for (char c : s) {\\n            int digit = c - \\'0\\';\\n            prod *= digit;\\n            sum += digit;\\n        }\\n        return prod - sum;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        String s = Integer.toString(n);\\n        for (char c : s.toCharArray()) {\\n            int digit = c - \\'0\\';\\n            prod *= digit;\\n            sum += digit;\\n        }\\n        return prod - sum;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        prod = 1\\n        sum = 0\\n        s = str(n)\\n        for c in s:\\n            digit = int(c)\\n            prod *= digit\\n            sum += digit\\n        return prod - sum\\n```\n```JavaScript []\\nvar subtractProductAndSum = function(n) {\\n    let prod = 1;\\n    let sum = 0;\\n    let s = n.toString();\\n    for (let i = 0; i < s.length; i++) {\\n        let digit = parseInt(s[i]);\\n        prod *= digit;\\n        sum += digit;\\n    }\\n    return prod - sum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450218,
                "title": "python-2-line",
                "content": "```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        lis=map(int,list(str(n)))\\n        return reduce(lambda x,y:x*y,lis)-sum(lis)\\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        lis=map(int,list(str(n)))\\n        return reduce(lambda x,y:x*y,lis)-sum(lis)\\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 449080,
                "title": "python3-lambda",
                "content": "\\n```\\ns = lambda n: n if n < 10 else n % 10 + s(n//10)\\np = lambda n: n if n < 10 else (n%10) * p(n//10) \\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return p(n) - s(n)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ns = lambda n: n if n < 10 else n % 10 + s(n//10)\\np = lambda n: n if n < 10 else (n%10) * p(n//10) \\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return p(n) - s(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026442,
                "title": "python-easiest-solution",
                "content": "\\n\\n# Code\\n```py\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        l1 = [int(i) for i in str(n)]\\n        product = 1\\n        sum1 = 0\\n        for i in l1:\\n            product *= i\\n            sum1 += i\\n        return product-sum1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        l1 = [int(i) for i in str(n)]\\n        product = 1\\n        sum1 = 0\\n        for i in l1:\\n            product *= i\\n            sum1 += i\\n        return product-sum1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446730,
                "title": "short-1-liner-ruby",
                "content": "```\\ndef subtract_product_and_sum(n)\\n  n.digits.reduce(:*) - n.digits.sum\\nend\\n```\\nSadly `product` is something else...\\n\\nShorter and more efficient and uglier:\\n```\\ndef subtract_product_and_sum(n)\\n  (d = n.digits).reduce(:*) - d.sum\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef subtract_product_and_sum(n)\\n  n.digits.reduce(:*) - n.digits.sum\\nend\\n```\n```\\ndef subtract_product_and_sum(n)\\n  (d = n.digits).reduce(:*) - d.sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2215978,
                "title": "python3-simple-solution-one-pass-using-divmod",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        plus = 0\\n        product = 1\\n        n = str(n)\\n        for i in n:\\n            plus = plus + int(i)\\n            product = product * int(i)\\n        return product - plus\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        plus = 0\\n        product = 1\\n        n = str(n)\\n        for i in n:\\n            plus = plus + int(i)\\n            product = product * int(i)\\n        return product - plus\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484500,
                "title": "easy-to-understand-c-solution-faster-than-100",
                "content": "**Explanation**\\nFirst of all we convert the number to a string for easy iteration through its digits. Then we store the values of multiplication and addition in variables prod and add respectively and finally return the difference of the two.\\n\\nPlease upvote the answer if you find it helpful and comment down if you have any questions!\\n\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n       int prod=1,add=0; \\n        string s=to_string(n);\\n        for(auto c:s){\\n            prod*=c-\\'0\\';\\n            add+=c-\\'0\\';\\n        }\\n        return prod-add;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n       int prod=1,add=0; \\n        string s=to_string(n);\\n        for(auto c:s){\\n            prod*=c-\\'0\\';\\n            add+=c-\\'0\\';\\n        }\\n        return prod-add;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694646,
                "title": "java-simple-while",
                "content": "```\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0, mult = 1;\\n        while (n > 0) {\\n            sum += n % 10;\\n            mult *= n % 10;\\n            n /= 10;\\n        }\\n        return mult - sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0, mult = 1;\\n        while (n > 0) {\\n            sum += n % 10;\\n            mult *= n % 10;\\n            n /= 10;\\n        }\\n        return mult - sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473997,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int SubtractProductAndSum(int n)\\n    {\\n        int prod = 1;\\n        int sum = 0;\\n\\n        while (n != 0)\\n        {\\n            int digit = n % 10;\\n            prod *= digit;\\n            sum += digit;\\n            n = n / 10;\\n        }\\n\\n        return prod - sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int SubtractProductAndSum(int n)\\n    {\\n        int prod = 1;\\n        int sum = 0;\\n\\n        while (n != 0)\\n        {\\n            int digit = n % 10;\\n            prod *= digit;\\n            sum += digit;\\n            n = n / 10;\\n        }\\n\\n        return prod - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469042,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n  pub fn subtract_product_and_sum(n: i32) -> i32 {\\n    let string = n.to_string();\\n    let digits = string.chars().map(|c| c.to_digit(10).unwrap() as i32);\\n    let product: i32 = digits.clone().product();\\n    let sum: i32 = digits.sum();\\n    product - sum\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn subtract_product_and_sum(n: i32) -> i32 {\\n    let string = n.to_string();\\n    let digits = string.chars().map(|c| c.to_digit(10).unwrap() as i32);\\n    let product: i32 = digits.clone().product();\\n    let sum: i32 = digits.sum();\\n    product - sum\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3193783,
                "title": "java-python-0ms-100-faster-iteration-recursion",
                "content": "**Java Recurive Solution :**\\n\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        return (RecPro (n, 1) - RecSum (n, 0));\\n    }\\n     static int RecSum(int n, int sum) {\\n\\n        if (n == 0) {\\n            return sum;\\n        }\\n        \\n        return RecSum(n / 10 , sum += n % 10);\\n    }\\n\\n    static int RecPro(int n, int pro) {\\n\\n        if (n == 0) {\\n            return pro;\\n        }\\n        \\n        return RecPro(n / 10 , pro *= n % 10);\\n    }\\n}\\n```\\n\\n**Python Iterative Solution :**\\n\\n```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n\\t\\n        Sum = 0\\n        Product = 1;\\n        while n > 0:\\n            rem = n % 10;\\n            Sum += rem;\\n            Product *= rem;\\n            n /= 10;\\n            \\n        return Product - Sum    \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        return (RecPro (n, 1) - RecSum (n, 0));\\n    }\\n     static int RecSum(int n, int sum) {\\n\\n        if (n == 0) {\\n            return sum;\\n        }\\n        \\n        return RecSum(n / 10 , sum += n % 10);\\n    }\\n\\n    static int RecPro(int n, int pro) {\\n\\n        if (n == 0) {\\n            return pro;\\n        }\\n        \\n        return RecPro(n / 10 , pro *= n % 10);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n\\t\\n        Sum = 0\\n        Product = 1;\\n        while n > 0:\\n            rem = n % 10;\\n            Sum += rem;\\n            Product *= rem;\\n            n /= 10;\\n            \\n        return Product - Sum    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581086,
                "title": "python3-solution-few-line",
                "content": "```\\ndef subtractProductAndSum(self, n: int) -> int:\\n    digit_list = list(map(int,str(n)))\\n    digit_product = 1\\n    for i in digit_list:\\n        digit_product *= i\\n    return digit_product - sum(digit_list)\\n```",
                "solutionTags": [],
                "code": "```\\ndef subtractProductAndSum(self, n: int) -> int:\\n    digit_list = list(map(int,str(n)))\\n    digit_product = 1\\n    for i in digit_list:\\n        digit_product *= i\\n    return digit_product - sum(digit_list)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1811987,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int temp = n, a = temp % 10, b = temp % 10;\\n        temp /= 10;\\n        while (temp > 0) {\\n            int res = temp % 10;\\n            a *= res;\\n            b += res;\\n            temp /= 10;\\n        }\\n        return a - b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int temp = n, a = temp % 10, b = temp % 10;\\n        temp /= 10;\\n        while (temp > 0) {\\n            int res = temp % 10;\\n            a *= res;\\n            b += res;\\n            temp /= 10;\\n        }\\n        return a - b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756359,
                "title": "similar-java-c-c-c-easy-solution-100-0ms",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n\\n        int sum = 0;\\n        int product = 1;\\n\\n        while (n > 0) {\\n            int temp = n % 10; // for example  n = 1223 then after n % 10 we get last digit \\'3\\'\\n            sum += temp; // (sum = sum + temp;) so then sum = 0 + 3 => sum = 3; \\n            product *= temp;// (product = product * temp;) product = 1 * 3 => 3;\\n            n /= 10; // (n = n / 10;) then we divide n = 1223 / 10 => 122, n = 122\\n        }\\n\\n        return product - sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n\\n        int sum = 0;\\n        int product = 1;\\n\\n        while (n > 0) {\\n            int temp = n % 10; // for example  n = 1223 then after n % 10 we get last digit \\'3\\'\\n            sum += temp; // (sum = sum + temp;) so then sum = 0 + 3 => sum = 3; \\n            product *= temp;// (product = product * temp;) product = 1 * 3 => 3;\\n            n /= 10; // (n = n / 10;) then we divide n = 1223 / 10 => 122, n = 122\\n        }\\n\\n        return product - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316065,
                "title": "c-3-liner-recursive-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int prod(int n)\\n    {\\n        return (n < 10) ? n : n%10 * prod(n/10);\\n    }\\n    \\n    int sum(int n)\\n    {\\n        return (n < 10) ? n : n%10 + sum(n/10);\\n    }\\n    \\n    int subtractProductAndSum(int n) \\n    {\\n        return prod(n) - sum(n);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prod(int n)\\n    {\\n        return (n < 10) ? n : n%10 * prod(n/10);\\n    }\\n    \\n    int sum(int n)\\n    {\\n        return (n < 10) ? n : n%10 + sum(n/10);\\n    }\\n    \\n    int subtractProductAndSum(int n) \\n    {\\n        return prod(n) - sum(n);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165706,
                "title": "simple-java-recursive-approach",
                "content": "A recursive approach. Beats 100%\\n\\n\\tclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        return prodDigits(n) - sumDigits(n);\\n    }\\n    \\n    public int sumDigits(int N){\\n        if(N < 10)return N;\\n        return sumDigits(N/10)+(N%10);\\n    }\\n    \\n    public int prodDigits(int N){\\n        if(N < 10)return N;\\n        return prodDigits(N/10)*(N%10);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        return prodDigits(n) - sumDigits(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 483456,
                "title": "golang-0ms-o-n-time-o-1-space-no-strconv",
                "content": "```\\nfunc subtractProductAndSum(n int) int {\\n  sum, product := 0, 1\\n  \\n  for n > 0 {\\n    mod := n % 10\\n    sum += mod\\n    product *= mod\\n    \\n    n /= 10\\n  }\\n  \\n  return product - sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc subtractProductAndSum(n int) int {\\n  sum, product := 0, 1\\n  \\n  for n > 0 {\\n    mod := n % 10\\n    sum += mod\\n    product *= mod\\n    \\n    n /= 10\\n  }\\n  \\n  return product - sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534138,
                "title": "best-o-logn-solution",
                "content": "# Approach\\nUsing Math\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        while (n > 0) {\\n            int digit = n % 10;\\n            sum += digit;\\n            prod *= digit;\\n            n = n / 10;\\n        }\\n        return (prod - sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        while (n > 0) {\\n            int digit = n % 10;\\n            sum += digit;\\n            prod *= digit;\\n            n = n / 10;\\n        }\\n        return (prod - sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468810,
                "title": "simple-java-solution-beat-100-num-10",
                "content": "# Intuition\\nWe know that to get the last digit of a number we do (number%10). \\nSo, from this knowledge we can easily find sum and product of digits of a number.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        int a = n;\\n        while(a>0) {\\n            sum += a%10;\\n            a /= 10;\\n        }\\n        a = n;\\n        while(a>0) {\\n            product *= a%10;\\n            a /= 10;\\n        }\\n        return product-sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        int a = n;\\n        while(a>0) {\\n            sum += a%10;\\n            a /= 10;\\n        }\\n        a = n;\\n        while(a>0) {\\n            product *= a%10;\\n            a /= 10;\\n        }\\n        return product-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975008,
                "title": "easy-and-simple-solution-using-array",
                "content": "```\\npublic class Solution {\\n    public int SubtractProductAndSum(int n) {\\n        string s = n.ToString();\\n        char[] c = s.ToCharArray();\\n        int prod = 1;\\n        int sum = 0;\\n        for(int i = 0; i < c.Length; i++)\\n        {\\n            int y = Convert.ToInt32(c[i].ToString());\\n            prod *= y;\\n            sum += y;\\n        } \\n        return prod-sum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int SubtractProductAndSum(int n) {\\n        string s = n.ToString();\\n        char[] c = s.ToCharArray();\\n        int prod = 1;\\n        int sum = 0;\\n        for(int i = 0; i < c.Length; i++)\\n        {\\n            int y = Convert.ToInt32(c[i].ToString());\\n            prod *= y;\\n            sum += y;\\n        } \\n        return prod-sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752896,
                "title": "1281-product-sum-of-an-int",
                "content": "```\\nclass Solution(object):\\n    \\n    def subtractProductAndSum(self, n):\\n        sumOfInts = 0\\n        productOfInts = 1\\n        while(n>0):\\n          remainder1 = n % 10\\n          sumOfInts += remainder1\\n          productOfInts *= remainder1\\n          n -= remainder1 \\n          n /= 10\\n          \\n        return productOfInts - sumOfInts\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def subtractProductAndSum(self, n):\\n        sumOfInts = 0\\n        productOfInts = 1\\n        while(n>0):\\n          remainder1 = n % 10\\n          sumOfInts += remainder1\\n          productOfInts *= remainder1\\n          n -= remainder1 \\n          n /= 10\\n          \\n        return productOfInts - sumOfInts\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 917386,
                "title": "easy-js-solution",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let product = 1, sum = 0;\\n    while (n > 0) {\\n        let lastDigit = n % 10;\\n        product *= lastDigit;\\n        sum += lastDigit;\\n        n = Math.floor(n / 10);\\n    }\\n    return product - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let product = 1, sum = 0;\\n    while (n > 0) {\\n        let lastDigit = n % 10;\\n        product *= lastDigit;\\n        sum += lastDigit;\\n        n = Math.floor(n / 10);\\n    }\\n    return product - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779521,
                "title": "python-solution-using-eval",
                "content": "```\\n    def subtractProductAndSum(self, n: int) -> int:\\n        s=str(n)\\n        m=s.replace(\\'\\',\\'*\\')[1:-1]\\n        a=s.replace(\\'\\',\\'+\\')[1:-1]\\n        return eval(m)-eval(a)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def subtractProductAndSum(self, n: int) -> int:\\n        s=str(n)\\n        m=s.replace(\\'\\',\\'*\\')[1:-1]\\n        a=s.replace(\\'\\',\\'+\\')[1:-1]\\n        return eval(m)-eval(a)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 692286,
                "title": "python-3-faster-than-98-48",
                "content": "The `prod` method method from the math standard library was added in Python 3.8 onwards.\\n\\n```\\nfrom math import prod\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        nums = [int(x) for x in str(n)]\\n        return prod(nums)-sum(nums)\\n```\\n\\nhttps://docs.python.org/3.8/library/math.html#math.prod",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import prod\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        nums = [int(x) for x in str(n)]\\n        return prod(nums)-sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563573,
                "title": "javascript-80-100",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let result = (n + \\'\\').split(\\'\\').reduce((a,b)=>{\\n        return [a[0] * b, a[1] + +b];\\n    }, [1, 0]);\\n    return result[0] - result[1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let result = (n + \\'\\').split(\\'\\').reduce((a,b)=>{\\n        return [a[0] * b, a[1] + +b];\\n    }, [1, 0]);\\n    return result[0] - result[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488562,
                "title": "python-3-8-math-prod",
                "content": "Now that we have Python 3.8, we can use its `math.prod`:\\n```\\ndef subtractProductAndSum(self, n):\\n    digits = list(map(int, str(n)))\\n    return math.prod(digits) - sum(digits)\\n```",
                "solutionTags": [],
                "code": "```\\ndef subtractProductAndSum(self, n):\\n    digits = list(map(int, str(n)))\\n    return math.prod(digits) - sum(digits)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478850,
                "title": "c-solution",
                "content": "beginner problem\\n```C\\nint subtractProductAndSum(int n){\\n    int sum = 0, product = 1, x;\\n    while(n>0){\\n        x = n%10;\\n        sum += x;\\n        product *= x;\\n        n /= 10;\\n    }\\n    return product - sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```C\\nint subtractProductAndSum(int n){\\n    int sum = 0, product = 1, x;\\n    while(n>0){\\n        x = n%10;\\n        sum += x;\\n        product *= x;\\n        n /= 10;\\n    }\\n    return product - sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463109,
                "title": "c",
                "content": "```\\npublic int SubtractProductAndSum(int n) {\\n\\tvar digits = GetDigits(n);\\n\\tvar product = digits.Aggregate(1, (x, y) => x * y);\\n\\tvar sum = digits.Aggregate(0, (x, y) => x + y);\\n\\n\\treturn product - sum;\\n\\n\\tList<int> GetDigits(int i) {\\n\\t\\tif (i == 0) return new List<int> { 0 };\\n\\t\\tvar list = new List<int>();\\n\\t\\twhile (i > 0) { list.Add(i % 10); i /= 10; }\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int SubtractProductAndSum(int n) {\\n\\tvar digits = GetDigits(n);\\n\\tvar product = digits.Aggregate(1, (x, y) => x * y);\\n\\tvar sum = digits.Aggregate(0, (x, y) => x + y);\\n\\n\\treturn product - sum;\\n\\n\\tList<int> GetDigits(int i) {\\n\\t\\tif (i == 0) return new List<int> { 0 };\\n\\t\\tvar list = new List<int>();\\n\\t\\twhile (i > 0) { list.Add(i % 10); i /= 10; }\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 448550,
                "title": "javascript-and-c-solutions",
                "content": "*Javascript: using toString().split(\\'\\') to create the Array to reduce*\\n```\\nvar subtractProductAndSum = n => \\n    n.toString().split(\\'\\').map(Number).reduce((a, b) => a * b) -\\n    n.toString().split(\\'\\').map(Number).reduce((a, b) => a + b);\\n```\\n\\n*Javascript: using Array.from() to create the Array to reduce*\\n```\\nvar subtractProductAndSum = n =>\\n    Array.from(String(n), Number).reduce((a, b) => a * b) -\\n    Array.from(String(n), Number).reduce((a, b) => a + b);\\n```\\n\\n*C++: the old-fashioned way*\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n, int p = 1, int s = 0) {\\n        while (n)\\n            p *= n % 10,\\n            s += n % 10,\\n            n /= 10;\\n        return p - s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar subtractProductAndSum = n => \\n    n.toString().split(\\'\\').map(Number).reduce((a, b) => a * b) -\\n    n.toString().split(\\'\\').map(Number).reduce((a, b) => a + b);\\n```\n```\\nvar subtractProductAndSum = n =>\\n    Array.from(String(n), Number).reduce((a, b) => a * b) -\\n    Array.from(String(n), Number).reduce((a, b) => a + b);\\n```\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n, int p = 1, int s = 0) {\\n        while (n)\\n            p *= n % 10,\\n            s += n % 10,\\n            n /= 10;\\n        return p - s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886028,
                "title": "easy-c-solution",
                "content": "\\n\\n# Approach\\nInitialization: Initialize two variables, sum and product, both initially set to 0 and 1 respectively. These variables will be used to accumulate the sum and product of the digits.\\n\\nDigit Extraction and Calculation: Enter a loop that continues as long as n is greater than 0. In each iteration of the loop:\\n\\nCalculate the last digit of n by using the modulo operator (n % 10). This gives you the rightmost digit of n.\\nUpdate n by removing its last digit (rightmost digit) using integer division (n / 10). This effectively shifts the digits of n to the right.\\nAdd the extracted digit to the sum variable.\\nMultiply the extracted digit with the product variable.\\nCalculation of Result: After the loop ends, you will have calculated the sum of the digits and the product of the digits of the original number n.\\n\\nReturn the Difference: Calculate the difference between the product and sum variables and return this difference as the final result.\\n\\nHere\\'s how the code works with an example:\\nSuppose n = 123.\\n\\nIteration 1: a = 3, n = 12, sum = 3, product = 3\\nIteration 2: a = 2, n = 1, sum = 5, product = 6\\nIteration 3: a = 1, n = 0, sum = 6, product = 6\\nThe final result is 6 - 6 = 0.\\nIn the end, the function returns 0.\\n\\nThis approach efficiently extracts the digits of the number and accumulates both the sum and the product in a single loop, making it a straightforward solution to the given problem.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum =0;\\n        int product=1;\\n        while(n>0)\\n        {\\n            int a = n % 10;\\n            n = n / 10;\\n            sum+=a;\\n            product = product*a;\\n        }\\n        return product-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum =0;\\n        int product=1;\\n        while(n>0)\\n        {\\n            int a = n % 10;\\n            n = n / 10;\\n            sum+=a;\\n            product = product*a;\\n        }\\n        return product-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482156,
                "title": "simple-explained-solution-using-java",
                "content": "\\n# Simple Code Using Java\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int rem,prod=1,sum=0;\\n        while(n!=0)\\n        {\\n        rem=n%10;\\n        prod=prod*rem;\\n        sum=sum+rem;\\n        n=n/10;\\n    }\\n    return prod-sum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int rem,prod=1,sum=0;\\n        while(n!=0)\\n        {\\n        rem=n%10;\\n        prod=prod*rem;\\n        sum=sum+rem;\\n        n=n/10;\\n    }\\n    return prod-sum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482147,
                "title": "using-c-language-super-logic",
                "content": "\\n\\n# Super Logic Through C\\n```\\nint subtractProductAndSum(int n){\\nint rem,prod=1,sum=0;\\n       while(n!=0)\\n       {\\n        rem=n%10;\\n        prod=prod*rem;\\n        sum=sum+rem;\\n        n=n/10;\\n       }\\n    return prod-sum;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint subtractProductAndSum(int n){\\nint rem,prod=1,sum=0;\\n       while(n!=0)\\n       {\\n        rem=n%10;\\n        prod=prod*rem;\\n        sum=sum+rem;\\n        n=n/10;\\n       }\\n    return prod-sum;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447504,
                "title": "my-subtractproductandsum",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function (n) {\\n  let pro = 1;\\n  let sum = 0;\\n\\n  while (n > 0) {\\n    const dig = n % 10;\\n    pro *= dig;\\n    sum += dig;\\n    n = Math.floor(n / 10);\\n  }\\n\\n  return pro - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function (n) {\\n  let pro = 1;\\n  let sum = 0;\\n\\n  while (n > 0) {\\n    const dig = n % 10;\\n    pro *= dig;\\n    sum += dig;\\n    n = Math.floor(n / 10);\\n  }\\n\\n  return pro - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2856344,
                "title": "js-solution-runtime-beats-96-80",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function(n) {\\n    let s = n.toString(); \\n    let sum = 0;\\n    let digit = 1; \\n    for (let i = 0; i < s.length; i++){\\n        sum += Number(s[i]);\\n        digit *= Number(s[i]);\\n    }\\n    return digit-sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function(n) {\\n    let s = n.toString(); \\n    let sum = 0;\\n    let digit = 1; \\n    for (let i = 0; i < s.length; i++){\\n        sum += Number(s[i]);\\n        digit *= Number(s[i]);\\n    }\\n    return digit-sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541215,
                "title": "scala-solution",
                "content": "```\\n    def subtractProductAndSum(n: Int): Int = {\\n        val list = n.toString.split(\"\").map(_.toInt)\\n        list.product - list.sum\\n    }",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n    def subtractProductAndSum(n: Int): Int = {\\n        val list = n.toString.split(\"\").map(_.toInt)\\n        list.product - list.sum\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1930463,
                "title": "python-one-liner",
                "content": "We define a function called `prod`, using `reduce`. We use list comprehension to convert our list of strings to a list of ints.\\n\\n**Note**: In Python 2, `reduce` is a built-in function. In Python 3, we need to import the `functools` library. However, in the LeetCode environment, the `functools` library is already included (see: [supported libraries](https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-)).\\n\\n**Solution**:\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n):\\n        def prod(arr): return reduce(lambda a,b: a * b, arr)\\n        x = [int(i) for i in str(n)]\\n        return prod(x) - sum(x)\\n```\\n\\nInstead of using `reduce`, we can use prod from the `math` library, and we do not have to define our own `prod` method. This library is automatically included in the LeetCode environment (see: [supported libraries](https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-)).\\n\\n**Solution**:\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n):\\n        x = [int(i) for i in str(n)]\\n        return prod(x) - sum(x)\\n```\\n\\nFor our one-liner, we can use the walrus operator to define `x` and use it on the same line (see: [walrus operator](https://realpython.com/python-walrus-operator/)).\\n\\n**Solution**:\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n):\\n        return prod(x := [int(i) for i in str(n)]) - sum(x)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n):\\n        def prod(arr): return reduce(lambda a,b: a * b, arr)\\n        x = [int(i) for i in str(n)]\\n        return prod(x) - sum(x)\\n```\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n):\\n        x = [int(i) for i in str(n)]\\n        return prod(x) - sum(x)\\n```\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n):\\n        return prod(x := [int(i) for i in str(n)]) - sum(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858861,
                "title": "0-ms-solution-easy-to-understand",
                "content": "```\\n int subtractProductAndSum(int n) {\\n       int t1=0,t2=1;\\n        while(n){\\n             t1+=n%10;\\n             t2*=n%10;\\n            n/=10;\\n        }\\n        return t2-t1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int subtractProductAndSum(int n) {\\n       int t1=0,t2=1;\\n        while(n){\\n             t1+=n%10;\\n             t2*=n%10;\\n            n/=10;\\n        }\\n        return t2-t1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1812109,
                "title": "rust-simple-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n        let (p, s) = std::iter::successors(Some(n), |&x| Some(x/10))\\n            .take_while(|&x| x > 0)\\n            .map(|x| x%10)\\n            .fold((1, 0), |(p, s), x| (p*x, s+x));\\n        p - s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n        let (p, s) = std::iter::successors(Some(n), |&x| Some(x/10))\\n            .take_while(|&x| x > 0)\\n            .map(|x| x%10)\\n            .fold((1, 0), |(p, s), x| (p*x, s+x));\\n        p - s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1746683,
                "title": "c-100-fast-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod=1,sum=0,ans=0;\\n        while(n!=0){\\n            sum+=n%10;\\n            prod*=n%10;\\n            n/=10;\\n        }\\n        ans=prod-sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod=1,sum=0,ans=0;\\n        while(n!=0){\\n            sum+=n%10;\\n            prod*=n%10;\\n            n/=10;\\n        }\\n        ans=prod-sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699640,
                "title": "python3-easy-to-understand-code-faster-than-100-one-liner",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a,b=1,0\\n        for i in list(str(n)):\\n            a*=int(i)\\n            b+=int(i)\\n        return (a-b)\\n```\\nAnother more optimized code | One line code\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n\\t\\treturn prod(list(map(int,str(n))))-sum(list(map(int,str(n))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a,b=1,0\\n        for i in list(str(n)):\\n            a*=int(i)\\n            b+=int(i)\\n        return (a-b)\\n```\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n\\t\\treturn prod(list(map(int,str(n))))-sum(list(map(int,str(n))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589691,
                "title": "java-simple-solution",
                "content": "```\\npublic int subtractProductAndSum(int n) {\\n\\tint m = 1;\\n\\tint p = 0;\\n\\n\\twhile (n!= 0) {\\n\\t\\tm *= n % 10;\\n\\t\\tp += n % 10;\\n\\n\\t\\tn /= 10;\\n\\t}\\n\\n\\treturn m - p;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int subtractProductAndSum(int n) {\\n\\tint m = 1;\\n\\tint p = 0;\\n\\n\\twhile (n!= 0) {\\n\\t\\tm *= n % 10;\\n\\t\\tp += n % 10;\\n\\n\\t\\tn /= 10;\\n\\t}\\n\\n\\treturn m - p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221511,
                "title": "easy-python-solution",
                "content": "class Solution:\\n\\n    def subtractProductAndSum(self, n: int) -> int:\\n        product = 1\\n        add = 0\\n        while (n != 0):\\n            product = product * (n % 10)\\n            add = add + (n % 10)\\n            n = n // 10\\n        return product - add",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def subtractProductAndSum(self, n: int) -> int:\\n        product = 1\\n        add = 0\\n        while (n != 0):\\n            product = product * (n % 10)\\n            add = add + (n % 10)\\n            n = n // 10\\n        return product - add",
                "codeTag": "Java"
            },
            {
                "id": 1203246,
                "title": "much-simple-and-readable",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        mult,add=1,0\\n        for i in str(n):\\n            mult*=int(i)\\n            add+=int(i)\\n        return mult-add\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        mult,add=1,0\\n        for i in str(n):\\n            mult*=int(i)\\n            add+=int(i)\\n        return mult-add\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116751,
                "title": "simple-c-solution-for-newbie-c",
                "content": "This is a very basic approach and efficient using **C++**.\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n,int sum = 0,int prod = 1) {\\n        while(n>0)\\n        {\\n            prod*=n%10;\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n,int sum = 0,int prod = 1) {\\n        while(n>0)\\n        {\\n            prod*=n%10;\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937340,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn subtract_product_and_sum(mut n: i32) -> i32 {\\n        let mut sum = 0;\\n        let mut product = 1;\\n        \\n        while n > 0 {\\n            let d = n % 10;\\n            sum += d;\\n            product *= d;\\n            n /= 10;\\n        }\\n        \\n        product - sum\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn subtract_product_and_sum(mut n: i32) -> i32 {\\n        let mut sum = 0;\\n        let mut product = 1;\\n        \\n        while n > 0 {\\n            let d = n % 10;\\n            sum += d;\\n            product *= d;\\n            n /= 10;\\n        }\\n        \\n        product - sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851346,
                "title": "o-n-96-faster-no-array-no-parse-explanation",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let sum = 0;\\n    let multiply = 1;\\n    while (n >= 1) {\\n        const mod = (n % 10)\\n        sum += mod\\n        multiply *= mod\\n        n = parseInt(n / 10);\\n    }\\n    \\n    return multiply - sum;\\n};\\n```\\n\\nYou can iterate over an integer using division by 10 and mod, this will give to you the reverse integer, but for the test purposes, it doesn\\'t matter if we revert the number, because all we need to do is sum and multiply each number.\\nconst multiply starts in 1 because n * 1 = n. If I started to multiply with 0, the result of all multiply would be 0 because n * 0 = 0",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let sum = 0;\\n    let multiply = 1;\\n    while (n >= 1) {\\n        const mod = (n % 10)\\n        sum += mod\\n        multiply *= mod\\n        n = parseInt(n / 10);\\n    }\\n    \\n    return multiply - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772656,
                "title": "native-python-solution-o-n",
                "content": "```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        product = 1\\n        sums = 0\\n        for x in str(n):\\n            digit = int(x)\\n            product *= digit\\n            sums += digit\\n            \\n        return product - sums",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        product = 1\\n        sums = 0\\n        for x in str(n):\\n            digit = int(x)\\n            product *= digit\\n            sums += digit\\n            \\n        return product - sums",
                "codeTag": "Java"
            },
            {
                "id": 562978,
                "title": "rust-without-strings",
                "content": "```\\nfn digits(mut n: i32) -> impl Iterator<Item = i32> {\\n    std::iter::from_fn(move || {\\n        if n <= 0 {\\n            None\\n        } else {\\n            let digit = n % 10;\\n            n = n / 10;\\n            Some(digit)\\n        }\\n    })\\n}\\n\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n          digits(n).fold(1, |acc, d| acc * d)\\n        - digits(n).fold(0, |acc, d| acc + d)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn digits(mut n: i32) -> impl Iterator<Item = i32> {\\n    std::iter::from_fn(move || {\\n        if n <= 0 {\\n            None\\n        } else {\\n            let digit = n % 10;\\n            n = n / 10;\\n            Some(digit)\\n        }\\n    })\\n}\\n\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n          digits(n).fold(1, |acc, d| acc * d)\\n        - digits(n).fold(0, |acc, d| acc + d)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 513130,
                "title": "python-8ms-faster-than-97-7",
                "content": "```\\ndef subtractProductAndSum(self, n):\\n        dm = {\\'0\\': 0, \\'1\\': 1, \\'2\\': 2, \\'3\\': 3, \\'4\\': 4, \\'5\\': 5, \\'6\\': 6, \\'7\\': 7, \\'8\\': 8, \\'9\\': 9}\\n        s = repr(n)\\n        sm, pr = 0, 1\\n        for c in s:\\n            pr *= dm[c]\\n            sm += dm[c]\\n        return pr-sm\\n```",
                "solutionTags": [],
                "code": "```\\ndef subtractProductAndSum(self, n):\\n        dm = {\\'0\\': 0, \\'1\\': 1, \\'2\\': 2, \\'3\\': 3, \\'4\\': 4, \\'5\\': 5, \\'6\\': 6, \\'7\\': 7, \\'8\\': 8, \\'9\\': 9}\\n        s = repr(n)\\n        sm, pr = 0, 1\\n        for c in s:\\n            pr *= dm[c]\\n            sm += dm[c]\\n        return pr-sm\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 447954,
                "title": "swift-clean-functional-programming-solution",
                "content": "We can use the functional programming concept of [reduce](http://iandundas.com/blog/2016/6/14/swift-basics-reduce) to do this quickly and cleanly:\\n\\n```\\nfunc subtractProductAndSum(_ n: Int) -> Int {\\n    // Attempts to convert every character in this string (a digit) to an int.\\n\\t// `compactMap` removes failed conversions which would return `nil`.\\n\\t// If the number is well-formatted, this shouldn\\'t be a problem.\\n\\tlet digits = String(n).compactMap { digitAsCharacter in\\n\\t\\tInt(String(digitAsCharacter)\\n\\t}\\n\\t\\n\\t// Start at a value of 1 and multiply every digit to get the product.\\n\\tlet product = digits.reduce(1) { x, y in x * y }\\n\\t\\n\\t// Start at a value of 0 and add every number to get the sum.\\n\\tlet sum = digits.reduce(0) { x, y in x + y }\\n\\n\\treturn product - sum\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc subtractProductAndSum(_ n: Int) -> Int {\\n    // Attempts to convert every character in this string (a digit) to an int.\\n\\t// `compactMap` removes failed conversions which would return `nil`.\\n\\t// If the number is well-formatted, this shouldn\\'t be a problem.\\n\\tlet digits = String(n).compactMap { digitAsCharacter in\\n\\t\\tInt(String(digitAsCharacter)\\n\\t}\\n\\t\\n\\t// Start at a value of 1 and multiply every digit to get the product.\\n\\tlet product = digits.reduce(1) { x, y in x * y }\\n\\t\\n\\t// Start at a value of 0 and add every number to get the sum.\\n\\tlet sum = digits.reduce(0) { x, y in x + y }\\n\\n\\treturn product - sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446430,
                "title": "python-3-one-line-beats-100",
                "content": "_Three Line Version:_ (20 ms) (beats 100%)\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        s, p = 0, 1\\n        for i in str(n): s += int(i); p *= int(i)\\n        return p - s\\n\\t\\t\\n```\\n_One-Line Version:_ (beats 100%)\\n```\\nfrom numpy import prod\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return (lambda n: prod(n) - sum(n))(list(map(int,str(n))))\\n\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        s, p = 0, 1\\n        for i in str(n): s += int(i); p *= int(i)\\n        return p - s\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277280,
                "title": "beats-runtime-0-ms-c-easiest-solution",
                "content": "![Screenshot from 2023-03-10 15-26-51.png](https://assets.leetcode.com/users/images/ad3a5c6f-0692-417d-a673-e29d19b69de9_1678454850.904554.png)\\n\\n\\n# Approach\\nThe approach used in the code is to iterate through each digit of **\\'n\\'** using a while loop. In each iteration, the code extracts the last digit of **\\'n\\'** using the modulus operator **\\'%\\'**, and adds it to the **\\'sum\\'** variable while multiplying it with the **\\'product\\'** variable. Then, the last digit of n is removed by dividing n by 10.\\n\\nOnce all digits of **\\'n\\'** have been processed in this manner, the code returns the difference between the **\\'product\\'** and **\\'sum\\'** variables, which represents the result of the operation.\\n\\nThis approach is simple and efficient, as it requires only a constant amount of memory and time proportional to the number of digits in the input integer **\\'n\\'**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        while (n){\\n            sum += n % 10;\\n            product *= n % 10;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n};\\n```\\n![fabf8b98-b984-4510-b551-a6b972c155b5_1677603180.1534393.png](https://assets.leetcode.com/users/images/982f1435-193c-4fd1-b364-2c0f7e0f563d_1678372044.172249.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        while (n){\\n            sum += n % 10;\\n            product *= n % 10;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267052,
                "title": "o-log-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        int result;\\n        while (n != 0) {\\n            sum += n % 10;\\n            product *= n % 10;\\n            n /= 10 ;\\n        }\\n        result = product - sum;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        int result;\\n        while (n != 0) {\\n            sum += n % 10;\\n            product *= n % 10;\\n            n /= 10 ;\\n        }\\n        result = product - sum;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233034,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint subtractProductAndSum(int n){\\n    int sum=0,pro=1;\\n    while(n!=0)\\n    {\\n        sum+=n%10;\\n        pro*=n%10;\\n        n/=10;\\n    }\\n    return(pro-sum);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint subtractProductAndSum(int n){\\n    int sum=0,pro=1;\\n    while(n!=0)\\n    {\\n        sum+=n%10;\\n        pro*=n%10;\\n        n/=10;\\n    }\\n    return(pro-sum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205030,
                "title": "rust-fast-simple-solution-0ms",
                "content": "\\n```\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n        let (sum ,  mult) = n.to_string().chars()\\n        .map(|c| c.to_digit(10).unwrap())\\n        .fold((0,1), |(sum,mult), c| {\\n            (sum + c ,mult * c)\\n        });\\n        (mult - sum) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n        let (sum ,  mult) = n.to_string().chars()\\n        .map(|c| c.to_digit(10).unwrap())\\n        .fold((0,1), |(sum,mult), c| {\\n            (sum + c ,mult * c)\\n        });\\n        (mult - sum) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160803,
                "title": "simple-c-java-solution-o-n-time-complexity-100-faster-0ms",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will iterate from n to 1 and calculate the sum and product of the digit.After that we return the difference between them.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int digit,prod = 1,sum=0;\\n        while(n!=0)\\n        {\\n            digit = n % 10;\\n            sum += digit;\\n            prod *= digit;\\n            n = n/10;\\n        }\\n        int res = prod - sum;\\n        return res;        \\n    }\\n};\\n```\\n# Code Java\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int res;\\n        int sum=0; int prod=1;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        while(n != 0){\\n            res = n%10;\\n            n /= 10;\\n            arr.add(res);\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            sum += arr.get(i);\\n            prod *= arr.get(i);\\n        }\\n        return prod-sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int digit,prod = 1,sum=0;\\n        while(n!=0)\\n        {\\n            digit = n % 10;\\n            sum += digit;\\n            prod *= digit;\\n            n = n/10;\\n        }\\n        int res = prod - sum;\\n        return res;        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int res;\\n        int sum=0; int prod=1;\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        while(n != 0){\\n            res = n%10;\\n            n /= 10;\\n            arr.add(res);\\n        }\\n        for(int i=0; i<arr.size(); i++){\\n            sum += arr.get(i);\\n            prod *= arr.get(i);\\n        }\\n        return prod-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142850,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n\\n     int product=1;\\n    int sum=0;\\n     while(n>0)\\n     {\\n         int rem=n%10;\\n        product*=rem;\\n        sum+=rem;\\n        n=n/10;\\n     }\\n     return product-sum;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n\\n     int product=1;\\n    int sum=0;\\n     while(n>0)\\n     {\\n         int rem=n%10;\\n        product*=rem;\\n        sum+=rem;\\n        n=n/10;\\n     }\\n     return product-sum;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138125,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n        int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        for (; n > 0; n /= 10) {\\n            sum += n % 10;\\n            product *= n % 10;\\n        }\\n        return product - sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Kotlin",
                    "Rust"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int subtractProductAndSum(int n) {\\n        int sum = 0, product = 1;\\n        for (; n > 0; n /= 10) {\\n            sum += n % 10;\\n            product *= n % 10;\\n        }\\n        return product - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119985,
                "title": "easy-java-solution-very-easy-approach-0ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int prod=1;\\n        while(n!=0)\\n        {\\n            int lastdigit=n%10;\\n            prod*=lastdigit;\\n            sum+=lastdigit;\\n            n=n/10;\\n        }\\n        int result=prod-sum;\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int prod=1;\\n        while(n!=0)\\n        {\\n            int lastdigit=n%10;\\n            prod*=lastdigit;\\n            sum+=lastdigit;\\n            n=n/10;\\n        }\\n        int result=prod-sum;\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117305,
                "title": "c-easy-solution-like-literaly-easy",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        while(n) {\\n            sum += n % 10;\\n            prod *= n % 10;\\n            n /= 10;\\n        }\\n        return prod - sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod = 1, sum = 0;\\n        while(n) {\\n            sum += n % 10;\\n            prod *= n % 10;\\n            n /= 10;\\n        }\\n        return prod - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116709,
                "title": "easy-java-solution-beats-100-0ms",
                "content": "# Using 2 loops and functions\\n# Code\\n```\\nclass Solution {\\n    int product(int n)\\n    {\\n        int prod=1;\\n        while(n>0)\\n        {\\n            prod=prod*(n%10);\\n            n=n/10;\\n        }\\n        return prod;\\n    }\\n    int sum(int n)\\n    {\\n        int add=0;\\n        while(n>0)\\n        {\\n            add=add+(n%10);\\n            n=n/10;\\n        }\\n        return add;\\n    }\\n    public int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n}\\n```\\n# Using only 1 loop\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            product=product*(n%10);\\n            sum=sum+(n%10);\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int product(int n)\\n    {\\n        int prod=1;\\n        while(n>0)\\n        {\\n            prod=prod*(n%10);\\n            n=n/10;\\n        }\\n        return prod;\\n    }\\n    int sum(int n)\\n    {\\n        int add=0;\\n        while(n>0)\\n        {\\n            add=add+(n%10);\\n            n=n/10;\\n        }\\n        return add;\\n    }\\n    public int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            product=product*(n%10);\\n            sum=sum+(n%10);\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097724,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int t=n,sum=0,pro=1;\\n        while(t>0){\\n            sum=sum+t%10;\\n            pro=pro*(t%10);\\n            t=t/10;\\n        }\\n        return pro-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int t=n,sum=0,pro=1;\\n        while(t>0){\\n            sum=sum+t%10;\\n            pro=pro*(t%10);\\n            t=t/10;\\n        }\\n        return pro-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095930,
                "title": "solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function (n) {\\n  let sum = 0;\\n  let product = 1;\\n  while (n > 0) {\\n    let digit = n % 10;\\n    sum += digit;\\n    product *= digit;\\n    n = Math.floor(n / 10);\\n  }\\n  return product - sum;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function (n) {\\n  let sum = 0;\\n  let product = 1;\\n  while (n > 0) {\\n    let digit = n % 10;\\n    sum += digit;\\n    product *= digit;\\n    n = Math.floor(n / 10);\\n  }\\n  return product - sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083607,
                "title": "c-simple-maths-beats-100-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum_of_digits = 0, product_of_digits = 1;\\n        string num = to_string(n);\\n        \\n        for(char ch : num){\\n            int digit = ch-\\'0\\';\\n            sum_of_digits += digit;\\n            product_of_digits *= digit;\\n        }\\n        \\n        return product_of_digits-sum_of_digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum_of_digits = 0, product_of_digits = 1;\\n        string num = to_string(n);\\n        \\n        for(char ch : num){\\n            int digit = ch-\\'0\\';\\n            sum_of_digits += digit;\\n            product_of_digits *= digit;\\n        }\\n        \\n        return product_of_digits-sum_of_digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071142,
                "title": "easy-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        pro =1\\n        sum1 = 0\\n        while(n>0):\\n            pro = pro * (n%10)\\n            sum1 = sum1 + (n%10)\\n            n = n//10\\n            print(pro)\\n            print(sum1)\\n            print(n)\\n        \\n        return pro -sum1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        pro =1\\n        sum1 = 0\\n        while(n>0):\\n            pro = pro * (n%10)\\n            sum1 = sum1 + (n%10)\\n            n = n//10\\n            print(pro)\\n            print(sum1)\\n            print(n)\\n        \\n        return pro -sum1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050443,
                "title": "0-ms-5-7-mb-solution-in-c-using-while-loop",
                "content": "# Intuition\\nMy first thought on how to solve this problem is to extract the digits of the input integer, n, and calculate the product and sum of those digits. Then, I will subtract the sum from the product to get the final result.\\n\\n# Approach\\nMy approach is to use ```while loop``` to extract digits from right to left of ```n``` and calcuate sum and product of digits.\\n\\nAfter the while loop, I will return the difference between the product and sum.\\n\\n# Complexity\\n- Time complexity:\\n```O(d)``` where ```d``` is the number of digits in the input number ```n```.\\n\\n- Space complexity:\\n```O(1)```\\n\\n# Code\\n```\\nint subtractProductAndSum(int n)\\n{\\n    int r, p = 1, s = 0;\\n    while (n != 0)\\n    {\\n        r = n % 10;\\n        p = p * r;\\n        s = s + r;\\n        n = n / 10;\\n    }\\n    return (p - s);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#",
                    "Math"
                ],
                "code": "```while loop```\n```n```\n```O(d)```\n```d```\n```n```\n```O(1)```\n```\\nint subtractProductAndSum(int n)\\n{\\n    int r, p = 1, s = 0;\\n    while (n != 0)\\n    {\\n        r = n % 10;\\n        p = p * r;\\n        s = s + r;\\n        n = n / 10;\\n    }\\n    return (p - s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035478,
                "title": "beats-100-solution-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int s=0,p=1;\\n        while(n){\\n            int last = n%10;\\n            s += last;\\n            p*= last;\\n            n/=10;\\n        }\\n        return p-s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int s=0,p=1;\\n        while(n){\\n            int last = n%10;\\n            s += last;\\n            p*= last;\\n            n/=10;\\n        }\\n        return p-s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990321,
                "title": "java-simple-runtime-0-ms-beats-100-memory-39-5-mb-beats-61-98",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n\\n        int product = 1;\\n        int sum = 0;\\n\\n        while(n != 0){\\n            int lastDigit = n % 10;\\n            sum += lastDigit;\\n            product *= lastDigit;\\n            n /= 10;\\n        }\\n\\n        return product - sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n\\n        int product = 1;\\n        int sum = 0;\\n\\n        while(n != 0){\\n            int lastDigit = n % 10;\\n            sum += lastDigit;\\n            product *= lastDigit;\\n            n /= 10;\\n        }\\n\\n        return product - sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972109,
                "title": "c-solution-with-comment-and-tc",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        // initialise sum equals to zero and product= 1\\n        int sum = 0;\\n        int product = 1;\\n        \\n        // run a loop until the digit is 0\\n        while(n>0){\\n            // update sum by adding its last digit\\n            sum += n%10;\\n            // update product by mutiplying its last digit\\n            product *= n%10;\\n            // update n\\n            n /= 10;\\n        }\\n        // return the difference between the product of its digits and the sum of its digits.\\n        return product - sum;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\n How can we derive the runtime?\\n\\n1000 / 10 = 100\\n100 / 10  = 10\\n10 / 10   = 1\\n1/ 10     = 0\\n\\nit takes 4 steps\\n\\n10^(4-1) = 1000\\n\\n10^(n-1) is equivalent to log (n-1) # base 10\\n\\n log(n-1) ~= log n\\n\\n->TC = O(log n) # base 10\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        // initialise sum equals to zero and product= 1\\n        int sum = 0;\\n        int product = 1;\\n        \\n        // run a loop until the digit is 0\\n        while(n>0){\\n            // update sum by adding its last digit\\n            sum += n%10;\\n            // update product by mutiplying its last digit\\n            product *= n%10;\\n            // update n\\n            n /= 10;\\n        }\\n        // return the difference between the product of its digits and the sum of its digits.\\n        return product - sum;\\n    }\\n};\\n```\n```\\n How can we derive the runtime?\\n\\n1000 / 10 = 100\\n100 / 10  = 10\\n10 / 10   = 1\\n1/ 10     = 0\\n\\nit takes 4 steps\\n\\n10^(4-1) = 1000\\n\\n10^(n-1) is equivalent to log (n-1) # base 10\\n\\n log(n-1) ~= log n\\n\\n->TC = O(log n) # base 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936753,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        string s = to_string(n);\\n        int mul = 1, sum = 0;\\n        for(auto x: s) {\\n            int v = x - \\'0\\';\\n            mul *= v;\\n            sum += v;\\n        }\\n        return mul - sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        string s = to_string(n);\\n        int mul = 1, sum = 0;\\n        for(auto x: s) {\\n            int v = x - \\'0\\';\\n            mul *= v;\\n            sum += v;\\n        }\\n        return mul - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920537,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem\\n\\n# Complexity\\n- Time complexity:O(logn +1)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long long int prod=1, sum=0;\\n        while(n){\\n            int temp=n%10;\\n            prod*=temp;\\n            sum+=temp;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long long int prod=1, sum=0;\\n        while(n){\\n            int temp=n%10;\\n            prod*=temp;\\n            sum+=temp;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865870,
                "title": "java-faster-than-100",
                "content": "First get all the digit by modulo operator . After that decrement the number by dividing it to 10. perform the operations with the digits.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nConstant\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n      return Answer(n);\\n    }\\n    static int Answer(int n){\\n        int ans1 = 1;\\n        int ans2 = 0;\\n        while(n != 0){\\n            int digit = n%10;  //use modulo operator to get the digits\\n            n = n/10; //decrement the number by 10.\\n            ans1 = ans1*digit;\\n            ans2 = ans2 + digit;\\n        }\\n        return ans1 - ans2;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n      return Answer(n);\\n    }\\n    static int Answer(int n){\\n        int ans1 = 1;\\n        int ans2 = 0;\\n        while(n != 0){\\n            int digit = n%10;  //use modulo operator to get the digits\\n            n = n/10; //decrement the number by 10.\\n            ans1 = ans1*digit;\\n            ans2 = ans2 + digit;\\n        }\\n        return ans1 - ans2;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830595,
                "title": "100-fastest-c-solution-easy",
                "content": "Easy C++ Solution : (100% Fast 0ms runtime) :-\\n```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0; int prod=1;\\n        while (n!=0){\\n            int dig= n%10; n/=10;\\n            sum+= dig; prod*=dig;\\n        }\\n        return prod-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0; int prod=1;\\n        while (n!=0){\\n            int dig= n%10; n/=10;\\n            sum+= dig; prod*=dig;\\n        }\\n        return prod-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814647,
                "title": "cpp-for-newbies",
                "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod =1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n               int digit =n%10;\\n            prod= prod*digit;\\n            sum=sum+digit;\\n            n=n/10;\\n            \\n        }\\n        return prod-sum;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int prod =1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n               int digit =n%10;\\n            prod= prod*digit;\\n            sum=sum+digit;\\n            n=n/10;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2743687,
                "title": "0ms-explained-easy-solution-c",
                "content": "0ms runtime C++ solution with explanation:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        // initializing sum as s and product as p\\n        int s{0}, p{1};\\n        \\n        // while n isn\\'t 0, this loop will go on [values other than 0 are true]\\n        while (n) {\\n            // we calculate the and store the digit at unit\\'s place in r\\n            int r=n%10;\\n            // we add the digit at one\\'s place to sum and multiply it to product\\n            s+=r;\\n            p*=r;\\n            // we divide the number by 10 and now the 10\\'s digit has moved to 1\\'s place\\n            // now we can operate on the next digit, and if n becomes 0, the loop stops\\n            n/=10;\\n        }\\n        \\n        return p-s;\\n    }\\n};\\n```\\n\\n\\u2B06\\uFE0F *Upvote solution if you learned how to approach the question*\\n*Happy coding* \\uD83D\\uDE00",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        // initializing sum as s and product as p\\n        int s{0}, p{1};\\n        \\n        // while n isn\\'t 0, this loop will go on [values other than 0 are true]\\n        while (n) {\\n            // we calculate the and store the digit at unit\\'s place in r\\n            int r=n%10;\\n            // we add the digit at one\\'s place to sum and multiply it to product\\n            s+=r;\\n            p*=r;\\n            // we divide the number by 10 and now the 10\\'s digit has moved to 1\\'s place\\n            // now we can operate on the next digit, and if n becomes 0, the loop stops\\n            n/=10;\\n        }\\n        \\n        return p-s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715261,
                "title": "without-using-string-methods",
                "content": "```/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function(n) {\\n    if(n <= 1) {\\n        return 0\\n    }\\n    \\n    var numbers = splitIntoDigits(n)\\n    let sum = 0\\n    let product = 1\\n    \\n    for(const number of numbers) {\\n        sum += number\\n        product *= number\\n    }\\n    \\n    return product - sum\\n};\\n\\nvar splitIntoDigits = function(n) {\\n    var digits = []\\n    \\n    while(n >= 1) {\\n        n = n / 10\\n        \\n        const digit = parseInt((n - parseInt(n)).toFixed(1) * 10)\\n    \\n        digits.push(digit)\\n        n = parseInt(n)\\n    }\\n    \\n    return digits\\n}```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function(n) {\\n    if(n <= 1) {\\n        return 0\\n    }\\n    \\n    var numbers = splitIntoDigits(n)\\n    let sum = 0\\n    let product = 1\\n    \\n    for(const number of numbers) {\\n        sum += number\\n        product *= number\\n    }\\n    \\n    return product - sum\\n};\\n\\nvar splitIntoDigits = function(n) {\\n    var digits = []\\n    \\n    while(n >= 1) {\\n        n = n / 10\\n        \\n        const digit = parseInt((n - parseInt(n)).toFixed(1) * 10)\\n    \\n        digits.push(digit)\\n        n = parseInt(n)\\n    }\\n    \\n    return digits\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658290,
                "title": "js-very-easy-and-very-fast",
                "content": "![image](https://assets.leetcode.com/users/images/8c630d89-1b99-4bff-821d-cb027b3476b9_1664859735.1416926.png)\\n\\n```\\nvar subtractProductAndSum = function(n) {\\n    n = String(n);\\n    let sum = 0;\\n    let product = 1;\\n\\n    for (let i = 0; i < n.length; i++) {\\n        sum += Number(n[i]);\\n        product *= Number(n[i]);\\n    }\\n    \\n    return product - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    n = String(n);\\n    let sum = 0;\\n    let product = 1;\\n\\n    for (let i = 0; i < n.length; i++) {\\n        sum += Number(n[i]);\\n        product *= Number(n[i]);\\n    }\\n    \\n    return product - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630729,
                "title": "faster-than-96-python",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        list_digits = [int(x) for x in list(str(n))]\\n        summ = sum(list_digits)\\n        multiplication = 1\\n        for x in list_digits:\\n            multiplication *= x\\n            \\n        return multiplication - summ\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        list_digits = [int(x) for x in list(str(n))]\\n        summ = sum(list_digits)\\n        multiplication = 1\\n        for x in list_digits:\\n            multiplication *= x\\n            \\n        return multiplication - summ\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580822,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0,pro=1;\\n        while(n){\\n            sum+=(n%10);\\n            pro*=(n%10);\\n            n/=10;\\n        }\\n        \\n        return pro-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0,pro=1;\\n        while(n){\\n            sum+=(n%10);\\n            pro*=(n%10);\\n            n/=10;\\n        }\\n        \\n        return pro-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579713,
                "title": "the-ultimate-c-solution",
                "content": "**Solution:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n```class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int ans = 0;\\n        int pro = 1;\\n        int sum = 0;\\n        \\n        while(n!=0)\\n        {\\n            int rem = n%10;      // Find the last digit\\n            pro = pro * rem;     // calculate the product\\n            sum = sum + rem;     // calculate the addition(sum)\\n            n = n / 10;          // Update the number\\n        }\\n        \\n        ans = pro - sum;\\n        return ans;\\n    }\\n};\\n```\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n\\n**Analysis:**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n**Time Complexity** : `O(n)`  ---> As we iterate throught the all the digits of the number.\\n**Space Complexity** : `O(1)`  ----> As we don\\'t used the extra space.\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nIf this solution, helps you, then please` upvote.`\\n\\n*Thank You!!*\\n\\n**Keep Learing, Keep Growing!!!**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int ans = 0;\\n        int pro = 1;\\n        int sum = 0;\\n        \\n        while(n!=0)\\n        {\\n            int rem = n%10;      // Find the last digit\\n            pro = pro * rem;     // calculate the product\\n            sum = sum + rem;     // calculate the addition(sum)\\n            n = n / 10;          // Update the number\\n        }\\n        \\n        ans = pro - sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459985,
                "title": "easy-javascript-solution-without-converting-number-to-string",
                "content": "```\\nconst subtractProductAndSum = function(n) {\\n  let sum = 0;\\n  let product = 1;\\n\\n  while (n > 0) {\\n    const lastDigit = n % 10;\\n    sum += lastDigit;\\n    product *= lastDigit;\\n\\n    n = Math.floor(n / 10);\\n  }\\n\\n  return product - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst subtractProductAndSum = function(n) {\\n  let sum = 0;\\n  let product = 1;\\n\\n  while (n > 0) {\\n    const lastDigit = n % 10;\\n    sum += lastDigit;\\n    product *= lastDigit;\\n\\n    n = Math.floor(n / 10);\\n  }\\n\\n  return product - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450039,
                "title": "runtime-0-ms-faster-than-100-00-recursive-solution",
                "content": "```\\n/*** 1281. Subtract the Product and Sum of Digits of an Integer - CPP17 ***/\\nclass Solution {\\npublic:\\n    //find product of digits using recursion\\n    int product(int n){\\n        //base case\\n        if(n<10){\\n            return n;\\n        }\\n        //recursive case\\n        int smallProduct = product(n/10);\\n        return (n%10)*smallProduct;\\n    }\\n    \\n    //find sum of digits using recursion\\n    int sum(int n){\\n        //base case\\n        if(n<10){\\n            return n;\\n        }\\n        //recursive case\\n        int smallSum = sum(n/10);\\n        return (n%10)+smallSum;\\n    }\\n    \\n    int subtractProductAndSum(int n) {\\n        int temp = product(n);\\n        int temp1 = sum(n);\\n        return temp-temp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*** 1281. Subtract the Product and Sum of Digits of an Integer - CPP17 ***/\\nclass Solution {\\npublic:\\n    //find product of digits using recursion\\n    int product(int n){\\n        //base case\\n        if(n<10){\\n            return n;\\n        }\\n        //recursive case\\n        int smallProduct = product(n/10);\\n        return (n%10)*smallProduct;\\n    }\\n    \\n    //find sum of digits using recursion\\n    int sum(int n){\\n        //base case\\n        if(n<10){\\n            return n;\\n        }\\n        //recursive case\\n        int smallSum = sum(n/10);\\n        return (n%10)+smallSum;\\n    }\\n    \\n    int subtractProductAndSum(int n) {\\n        int temp = product(n);\\n        int temp1 = sum(n);\\n        return temp-temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420984,
                "title": "simple-java-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int p = 1;\\n        while(n>0){\\n            int ans = n%10;\\n            sum = sum + ans;\\n            p = p * ans;           \\n            n = n/10;\\n        }\\n        return p - sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int p = 1;\\n        while(n>0){\\n            int ans = n%10;\\n            sum = sum + ans;\\n            p = p * ans;           \\n            n = n/10;\\n        }\\n        return p - sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388295,
                "title": "python-two-liner-90",
                "content": "```\\nimport math\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        num = [int(x) for x in str(n)]\\n        return math.prod(num) - sum(num)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        num = [int(x) for x in str(n)]\\n        return math.prod(num) - sum(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202743,
                "title": "c",
                "content": "public int SubtractProductAndSum(int n) {\\n        \\n            int SubtractProAndSum = 0, sum=0, mul=1;\\n            string dd = n.ToString();\\n\\n            for (int i = 0; i < dd.Length; i++)\\n            {\\n                 sum =sum + Convert.ToInt32(dd[i].ToString());\\n                 mul = mul * Convert.ToInt32(dd[i].ToString());\\n                \\n            }\\n            SubtractProAndSum = mul - sum;\\n            return SubtractProAndSum;\\n    }",
                "solutionTags": [],
                "code": "public int SubtractProductAndSum(int n) {\\n        \\n            int SubtractProAndSum = 0, sum=0, mul=1;\\n            string dd = n.ToString();\\n\\n            for (int i = 0; i < dd.Length; i++)\\n            {\\n                 sum =sum + Convert.ToInt32(dd[i].ToString());\\n                 mul = mul * Convert.ToInt32(dd[i].ToString());\\n                \\n            }\\n            SubtractProAndSum = mul - sum;\\n            return SubtractProAndSum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2177890,
                "title": "c-100-fast-0ms-easy-to-understand",
                "content": "```\\nint subtractProductAndSum(int n) {\\n        int sum=0;\\n        int prod=1;\\n        int num=n;\\n        while(num)\\n        {\\n            int last=num%10;\\n            sum+=last;\\n            prod*=last;\\n            num/=10;\\n        }\\n        return prod-sum;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint subtractProductAndSum(int n) {\\n        int sum=0;\\n        int prod=1;\\n        int num=n;\\n        while(num)\\n        {\\n            int last=num%10;\\n            sum+=last;\\n            prod*=last;\\n            num/=10;\\n        }\\n        return prod-sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2135783,
                "title": "simple-c-solution-time-complexity-o-n-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum = 0, pro = 1,diff;                     // The variable sum for the sum of all digit and pro for the product of all digit of number\\n        while(n>0)                                     // Run the loop until it becomes less than 0\\n        {\\n            int rem = n % 10;                          // find the last digit\\n            sum = sum + rem;                           // update sum and pro\\n            pro = pro * rem;\\n            n = n / 10;                                // update n\\n        }\\n        \\n        diff = pro - sum;                              // calculate difference\\n        \\n        return diff;                                   // return difference\\n    }\\n};\\n\\nThe time complexity is O(n)\\n\\nIf you undestand this simple solution then please upvote.\\n\\nHappy learning , happy coding .....",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum = 0, pro = 1,diff;                     // The variable sum for the sum of all digit and pro for the product of all digit of number\\n        while(n>0)                                     // Run the loop until it becomes less than 0\\n        {\\n            int rem = n % 10;                          // find the last digit\\n            sum = sum + rem;                           // update sum and pro\\n            pro = pro * rem;\\n            n = n / 10;                                // update n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2066916,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "\\t\\t\\t class Solution {\\n\\t\\t\\t\\tpublic int subtractProductAndSum(int n) {\\n\\t\\t\\t\\t\\tint prod = 1;\\n\\t\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\t\\twhile(n!= 0){\\n\\t\\t\\t\\t\\t  int rem = n%10;\\n\\t\\t\\t\\t\\t\\tprod *=rem;\\n\\t\\t\\t\\t\\t\\tsum += rem;    \\n\\t\\t\\t\\t\\t   n= n/10;\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\treturn prod - sum ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int subtractProductAndSum(int n) {\\n\\t\\t\\t\\t\\tint prod = 1;\\n\\t\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\t\\twhile(n!= 0){\\n\\t\\t\\t\\t\\t  int rem = n%10;\\n\\t\\t\\t\\t\\t\\tprod *=rem;\\n\\t\\t\\t\\t\\t\\tsum += rem;    \\n\\t\\t\\t\\t\\t   n= n/10;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1914533,
                "title": "java-beats-100-easy-way",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum  = 0;\\n        int product = 1;\\n        while(n>0){\\n            sum += n%10;\\n            product *= n%10;\\n            n/=10;\\n        }\\n        return product - sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum  = 0;\\n        int product = 1;\\n        while(n>0){\\n            sum += n%10;\\n            product *= n%10;\\n            n/=10;\\n        }\\n        return product - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904593,
                "title": "faster-than-96-easy-python",
                "content": "class Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sum1=0\\n        pro=1\\n        num=0\\n        while n>0:\\n            num=n%10\\n            sum1 = sum1 + num\\n            pro = pro * num\\n            n = n//10\\n        return pro-sum1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sum1=0\\n        pro=1\\n        num=0\\n        while n>0:\\n            num=n%10\\n            sum1 = sum1 + num\\n            pro = pro * num\\n            n = n//10\\n        return pro-sum1",
                "codeTag": "Java"
            },
            {
                "id": 1879949,
                "title": "runtime-0-ms-faster-than-100-00-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\n    public int subtractProductAndSum(int n) \\n    {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            product*=(n%10);\\n            sum+=(n%10);\\n            n/=10;\\n        }\\n        return product-sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int subtractProductAndSum(int n) \\n    {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            product*=(n%10);\\n            sum+=(n%10);\\n            n/=10;\\n        }\\n        return product-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869730,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int p = 1, s = 0;\\n        while(n){\\n            int x = n % 10;\\n            p *= x;\\n            s += x;\\n            n /= 10;\\n        }\\n        return p - s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int p = 1, s = 0;\\n        while(n){\\n            int x = n % 10;\\n            p *= x;\\n            s += x;\\n            n /= 10;\\n        }\\n        return p - s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754370,
                "title": "c-easy-understanding",
                "content": "```\\n int subtractProductAndSum(int n) {\\n        long long prod=1;\\n        long long sum =0;\\n        \\n        while(n>0){\\n            int dig=n % 10;\\n            \\n            sum += dig;\\n            prod *= dig;\\n            \\n            n /= 10;\\n        }\\n        return prod-sum;\\n    }\\n```\\n# Do Upvote, If you find this solution helpful!",
                "solutionTags": [],
                "code": "```\\n int subtractProductAndSum(int n) {\\n        long long prod=1;\\n        long long sum =0;\\n        \\n        while(n>0){\\n            int dig=n % 10;\\n            \\n            sum += dig;\\n            prod *= dig;\\n            \\n            n /= 10;\\n        }\\n        return prod-sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591601,
                "title": "c-solution-0ms-faster-than-100-c-user-memory-usage-5-8-mb",
                "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int digit=0; int prod=1, sum=0;\\n        while(n){\\n            digit = n%10;\\n            prod *= digit;\\n            sum += digit;\\n            n /= 10;\\n        }\\n        return (prod-sum);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int digit=0; int prod=1, sum=0;\\n        while(n){\\n            digit = n%10;\\n            prod *= digit;\\n            sum += digit;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1508427,
                "title": "100-faster-c-submission",
                "content": "Self explainatory\\n```\\n    int subtractProductAndSum(int n) {\\n        int summ=0;\\n        long prod=1;\\n        while(n>0){\\n            int d=n%10;\\n            summ+=d;\\n            prod*=d;\\n            n/=10;\\n        }\\n        int sub=prod-summ;\\n        return sub;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int subtractProductAndSum(int n) {\\n        int summ=0;\\n        long prod=1;\\n        while(n>0){\\n            int d=n%10;\\n            summ+=d;\\n            prod*=d;\\n            n/=10;\\n        }\\n        int sub=prod-summ;\\n        return sub;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499711,
                "title": "java-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1, sum = 0;\\n        while(n > 0) { \\n            int rem = n % 10;\\n            product *= rem;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1, sum = 0;\\n        while(n > 0) { \\n            int rem = n % 10;\\n            product *= rem;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263827,
                "title": "javascript-solution-faster-than-92-21",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let sum = 0;\\n    let product = 1;\\n    let nums = Array.from(n.toString()).map(Number);\\n    nums.forEach(number => {\\n        sum += number;\\n        product *= number;\\n    });\\n    return product - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let sum = 0;\\n    let product = 1;\\n    let nums = Array.from(n.toString()).map(Number);\\n    nums.forEach(number => {\\n        sum += number;\\n        product *= number;\\n    });\\n    return product - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249542,
                "title": "swift-solution",
                "content": "\\n```\\nclass Solution {\\n    func subtractProductAndSum(_ n: Int) -> Int {\\n\\t\\t//Split the integer into each individual digit in an array (converting to string, because that seems to be the best method in Swift right now)\\n        let digits = String(describing: n).compactMap { Int(String($0)) }\\n        \\n\\t\\t//Get the sum, product and finally the difference\\n\\t\\tlet product = digits.reduce(1, *)\\n\\t\\tlet sum = digits.reduce(0, +)\\n        let ans = product - sum\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func subtractProductAndSum(_ n: Int) -> Int {\\n\\t\\t//Split the integer into each individual digit in an array (converting to string, because that seems to be the best method in Swift right now)\\n        let digits = String(describing: n).compactMap { Int(String($0)) }\\n        \\n\\t\\t//Get the sum, product and finally the difference\\n\\t\\tlet product = digits.reduce(1, *)\\n\\t\\tlet sum = digits.reduce(0, +)\\n        let ans = product - sum\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229275,
                "title": "readable-java-code",
                "content": "\\n    public int subtractProductAndSum(int n) {\\n    String s = String.valueOf(n);\\n    int product=1;\\n    int sum=0;\\n    for(int i=0;i<s.length();i++){\\n        product*= s.charAt(i)-\\'0\\';\\n        sum+= s.charAt(i)-\\'0\\';\\n    }  \\n    return product - sum;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int subtractProductAndSum(int n) {\\n    String s = String.valueOf(n);\\n    int product=1;\\n    int sum=0;\\n    for(int i=0;i<s.length();i++){\\n        product*= s.charAt(i)-\\'0\\';\\n        sum+= s.charAt(i)-\\'0\\';\\n    }  \\n    return product - sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1204888,
                "title": "swift-in-two-lines-with-compactmap",
                "content": "```\\nclass Solution {\\n    func subtractProductAndSum(_ n: Int) -> Int {\\n        let arrayInt = String(n).compactMap { Int(String($0)) }\\n        return arrayInt.reduce(1, *) - arrayInt.reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subtractProductAndSum(_ n: Int) -> Int {\\n        let arrayInt = String(n).compactMap { Int(String($0)) }\\n        return arrayInt.reduce(1, *) - arrayInt.reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180000,
                "title": "faster-than-76-77-and-70-is-passing-boissss",
                "content": "Runtime: 76 ms, faster than 76.77% of JavaScript online submissions for Subtract the Product and Sum of Digits of an Integer.\\nMemory Usage: 38.5 MB, less than 87.68% of JavaScript online submissions for Subtract the Product and Sum of Digits of an Integer.\\n\\n```\\nvar subtractProductAndSum = function(n) {\\n    let p = 1;\\n    let s = 0;\\n    n =  n.toString();\\n    for(let i =0; i< n.length; i++)\\n        {\\n            p*=Number(n.charAt(i));\\n            s+=Number(n.charAt(i));\\n        }\\n    return p-s;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let p = 1;\\n    let s = 0;\\n    n =  n.toString();\\n    for(let i =0; i< n.length; i++)\\n        {\\n            p*=Number(n.charAt(i));\\n            s+=Number(n.charAt(i));\\n        }\\n    return p-s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147346,
                "title": "simple-scala-by-converting-to-string",
                "content": "```\\nobject Solution {\\n    def subtractProductAndSum(n: Int): Int = {\\n        val s = n.toString\\n        val prod = s.foldLeft(1)(_ * _.asDigit)\\n        val sm = s.foldLeft(0)(_ + _.asDigit)\\n        prod - sm\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def subtractProductAndSum(n: Int): Int = {\\n        val s = n.toString\\n        val prod = s.foldLeft(1)(_ * _.asDigit)\\n        val sm = s.foldLeft(0)(_ + _.asDigit)\\n        prod - sm\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1101632,
                "title": "javascript-simple-solution-faster-than-83",
                "content": "```\\nvar subtractProductAndSum = (n) => {\\n    const nums =  n.toString().split(\"\").map(e=>parseInt(e))\\n    return nums.reduce((m,e)=>m*e,1) - nums.reduce((s,e)=>s+e,0)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar subtractProductAndSum = (n) => {\\n    const nums =  n.toString().split(\"\").map(e=>parseInt(e))\\n    return nums.reduce((m,e)=>m*e,1) - nums.reduce((s,e)=>s+e,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049032,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int prod = 1;\\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            sum += rem;\\n            prod *= rem;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int prod = 1;\\n        \\n        while(n>0)\\n        {\\n            int rem = n%10;\\n            sum += rem;\\n            prod *= rem;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014868,
                "title": "another-c-solution",
                "content": "```\\npublic class Solution {\\n    public int SubtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        int difference = 0;\\n        var digits = n.ToString().Select(t=>int.Parse(t.ToString())).ToArray();\\n\\n        foreach(int i in digits){\\n            sum += i;\\n            product *= i;\\n        }\\n        difference = product -sum;\\n        \\n        return difference;\\n    }\\n}\\n```\\nRuntime: 44 ms, faster than 23.43% of C# online submissions for Subtract the Product and Sum of Digits of an Integer.\\nMemory Usage: 16.4 MB, less than 5.61% of C# online submissions for Subtract the Product and Sum of Digits of an Integer.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SubtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        int difference = 0;\\n        var digits = n.ToString().Select(t=>int.Parse(t.ToString())).ToArray();\\n\\n        foreach(int i in digits){\\n            sum += i;\\n            product *= i;\\n        }\\n        difference = product -sum;\\n        \\n        return difference;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976347,
                "title": "easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        n = list(str(n))\\n        sum1 = 0\\n        p = 1\\n        for i in n:\\n            sum1 = sum1 + int(i)\\n            p = p * int(i)\\n        return p-sum1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        n = list(str(n))\\n        sum1 = 0\\n        p = 1\\n        for i in n:\\n            sum1 = sum1 + int(i)\\n            p = p * int(i)\\n        return p-sum1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956089,
                "title": "java-100-faster",
                "content": "* `O(n)` time\\n* `O(1)` space\\n```\\npublic int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n > 0){\\n            product *= n % 10;\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n > 0){\\n            product *= n % 10;\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        return product - sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950601,
                "title": "python-solution-by-iterating-on-str-n",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a,b = 1,0\\n        for i in str(n):\\n            a *= int(i)\\n            b += int(i)\\n        return a-b\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        a,b = 1,0\\n        for i in str(n):\\n            a *= int(i)\\n            b += int(i)\\n        return a-b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944179,
                "title": "simply-python-solution-after-transformation",
                "content": "class Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n\\t\\n        product,sum_digits = 1, 0\\n\\t\\t\\n        for i in str(n):\\n            product *=int(i)\\n            sum_digits +=int(i)\\n\\t\\t\\t\\n        return(product-sum_digits)\\n\\t\\n~~~\\n- integers are not iterable; so, we need to transform integers into strings using str(). \\n- use int() to turn strings back into integers, so we can add and multiply.",
                "solutionTags": [],
                "code": "class Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n\\t\\n        product,sum_digits = 1, 0\\n\\t\\t\\n        for i in str(n):\\n            product *=int(i)\\n            sum_digits +=int(i)\\n\\t\\t\\t\\n        return(product-sum_digits)\\n\\t\\n~~~\\n- integers are not iterable; so, we need to transform integers into strings using str(). \\n- use int() to turn strings back into integers, so we can add and multiply.",
                "codeTag": "Java"
            },
            {
                "id": 912838,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(N) space O(1)\\nvar subtractProductAndSum = function(n) {\\n    const str = n.toString()\\n    let product = 1\\n    let sum = 0\\n    \\n    for(const item of str) {\\n        product *= Number(item)\\n        sum += Number(item)\\n    }\\n    \\n    return product - sum\\n};\\n```\\n\\n```\\n// (Edition) Better space complexity\\n// time O(n) space O(1)\\nvar subtractProductAndSum = function(n) {\\n    let sum = 0\\n    let product = 1\\n    \\n    while(n) {\\n        const remainder = n % 10\\n        \\n        sum += remainder\\n        product *= remainder\\n        \\n        n = Math.floor(n / 10)\\n    }\\n    \\n    return product - sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(N) space O(1)\\nvar subtractProductAndSum = function(n) {\\n    const str = n.toString()\\n    let product = 1\\n    let sum = 0\\n    \\n    for(const item of str) {\\n        product *= Number(item)\\n        sum += Number(item)\\n    }\\n    \\n    return product - sum\\n};\\n```\n```\\n// (Edition) Better space complexity\\n// time O(n) space O(1)\\nvar subtractProductAndSum = function(n) {\\n    let sum = 0\\n    let product = 1\\n    \\n    while(n) {\\n        const remainder = n % 10\\n        \\n        sum += remainder\\n        product *= remainder\\n        \\n        n = Math.floor(n / 10)\\n    }\\n    \\n    return product - sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 909835,
                "title": "python3-while-loop",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        new = []\\n        while (n != 0):\\n            i = n%10\\n            n = int(n/10)\\n            new.append(i)\\n        return (prod(new) - sum(new))\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        new = []\\n        while (n != 0):\\n            i = n%10\\n            n = int(n/10)\\n            new.append(i)\\n        return (prod(new) - sum(new))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 849657,
                "title": "python-1-liner-solution",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        \\n        return math.prod([int(i) for i in str(n)])- sum([int(i) for i in str(n)])\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        \\n        return math.prod([int(i) for i in str(n)])- sum([int(i) for i in str(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762551,
                "title": "basic-typescript",
                "content": "```\\nfunction subtractProductAndSum(n: number): number {\\n    const arr = n.toString().split(\\'\\').map(s => +s);\\n    return arr.reduce((a, b) => a * b) -  arr.reduce((a, b) => a + b);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction subtractProductAndSum(n: number): number {\\n    const arr = n.toString().split(\\'\\').map(s => +s);\\n    return arr.reduce((a, b) => a * b) -  arr.reduce((a, b) => a + b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749814,
                "title": "python-easy-to-understand-solution-w-comments",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        s = str(n) #to iterate this int we will convert this to string\\n        product = 1 #product\\n        summ = 0 #sum \\n        for i in s:\\n            product *= int(i) #so we just multiply each other (start with 1 cause anything * 1 = anything)\\n            summ += int(i)  #so we just summing each other (start with 0 cause anything + 0 = anything)\\n        return product - summ #retrun what you need\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        s = str(n) #to iterate this int we will convert this to string\\n        product = 1 #product\\n        summ = 0 #sum \\n        for i in s:\\n            product *= int(i) #so we just multiply each other (start with 1 cause anything * 1 = anything)\\n            summ += int(i)  #so we just summing each other (start with 0 cause anything + 0 = anything)\\n        return product - summ #retrun what you need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712442,
                "title": "javascript-solution-using-reduce-method",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let x = n.toString().split(\\'\\');\\n    let y = x.reduce((a,b) => parseInt(a) * parseInt(b));\\n    let z = x.reduce((a,b) => parseInt(a) + parseInt(b));\\n    \\n    return y - z;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let x = n.toString().split(\\'\\');\\n    let y = x.reduce((a,b) => parseInt(a) * parseInt(b));\\n    let z = x.reduce((a,b) => parseInt(a) + parseInt(b));\\n    \\n    return y - z;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699120,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        \\n           \\n        st=[int(x) for x in str(n)]\\n        \\n        result=reduce(lambda x,y:x*y,st)-sum(st)\\n        \\n        return result",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subtractProductAndSum(self, n):\\n        \\n           \\n        st=[int(x) for x in str(n)]\\n        \\n        result=reduce(lambda x,y:x*y,st)-sum(st)\\n        \\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 639908,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        digits = []\\n        mult = 1\\n        sum1 = 0\\n        while(n > 0):\\n            digits.append(n%10)\\n            n = int(n/10)\\n        for digit in digits:\\n            mult = mult*digit\\n            sum1 = sum1+digit\\n        return mult-sum1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        digits = []\\n        mult = 1\\n        sum1 = 0\\n        while(n > 0):\\n            digits.append(n%10)\\n            n = int(n/10)\\n        for digit in digits:\\n            mult = mult*digit\\n            sum1 = sum1+digit\\n        return mult-sum1",
                "codeTag": "Java"
            },
            {
                "id": 635488,
                "title": "java-100-100",
                "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n      int prod = 1;\\n        int sum = 0;\\n        \\n        while(n > 0) {\\n            prod *= n % 10;\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        \\n        \\n        return prod - sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n      int prod = 1;\\n        int sum = 0;\\n        \\n        while(n > 0) {\\n            prod *= n % 10;\\n            sum += n % 10;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 578244,
                "title": "rust-binary-to-bcd",
                "content": "```rust\\n//! # Subtract the Product and Sum of Digits of an Integer\\n//! https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/\\n//!\\n// pub struct Solution;\\n\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n        use std::convert::TryInto;\\n        _subtract_product_and_sum(n.try_into().unwrap())\\n    }\\n}\\n\\n/// Idiomatic entry point.\\npub fn _subtract_product_and_sum(n: u32) -> i32 {\\n    // since n <= 100_000,\\n    // max product is 9^5 = 59_049,\\n    // which fits in an i32::MAX\\n    let digits = binary_to_bcd(n).map(i32::from);\\n    digits.clone().product::<i32>() - digits.sum::<i32>()\\n}\\n\\n/// https://my.eng.utah.edu/~nmcdonal/Tutorials/BCDTutorial/BCDConversion.html\\npub fn binary_to_bcd(n: u32) -> impl Clone + Iterator<Item = u8> {\\n    // u32 max = 4_294_967_295 = 10 digits\\n    // bcd requires 4 bits for each digit,\\n    // so the result requires 40 bits in total\\n    //\\n    // if the input is inlined (32 bits),\\n    // the left shift could make space for freeing the input\\n    //\\n    // but for simplicity, using a u128 is enought space\\n    // for both the result (40 bits) and the input (32 bits)\\n    // (128 > 72 bits)\\n    //\\n\\n    let offset = 32;\\n    let mut conv: u128 = n.into();\\n    // 32 left shifts\\n    for _ in 0..offset {\\n        // step 1: verify all decimal columns; if >= 5, sum with 3\\n        for col in 0..10 {\\n            let shift = offset + 4 * col;\\n            let window = (conv >> shift) & 0xF;\\n            if window >= 5 {\\n                conv += 3 << shift;\\n            }\\n        }\\n        // step 2: left rotation\\n        conv = conv.rotate_left(1);\\n    }\\n\\n    // erases the input\\n    conv >>= offset;\\n    (0..10)\\n        .map(move |c| (conv >> c * 4 & 0xF) as u8)\\n        // skip trailing zeroes\\n        .rev()\\n        .skip_while(|d| *d == 0)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n//! # Subtract the Product and Sum of Digits of an Integer\\n//! https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/\\n//!\\n// pub struct Solution;\\n\\nimpl Solution {\\n    pub fn subtract_product_and_sum(n: i32) -> i32 {\\n        use std::convert::TryInto;\\n        _subtract_product_and_sum(n.try_into().unwrap())\\n    }\\n}\\n\\n/// Idiomatic entry point.\\npub fn _subtract_product_and_sum(n: u32) -> i32 {\\n    // since n <= 100_000,\\n    // max product is 9^5 = 59_049,\\n    // which fits in an i32::MAX\\n    let digits = binary_to_bcd(n).map(i32::from);\\n    digits.clone().product::<i32>() - digits.sum::<i32>()\\n}\\n\\n/// https://my.eng.utah.edu/~nmcdonal/Tutorials/BCDTutorial/BCDConversion.html\\npub fn binary_to_bcd(n: u32) -> impl Clone + Iterator<Item = u8> {\\n    // u32 max = 4_294_967_295 = 10 digits\\n    // bcd requires 4 bits for each digit,\\n    // so the result requires 40 bits in total\\n    //\\n    // if the input is inlined (32 bits),\\n    // the left shift could make space for freeing the input\\n    //\\n    // but for simplicity, using a u128 is enought space\\n    // for both the result (40 bits) and the input (32 bits)\\n    // (128 > 72 bits)\\n    //\\n\\n    let offset = 32;\\n    let mut conv: u128 = n.into();\\n    // 32 left shifts\\n    for _ in 0..offset {\\n        // step 1: verify all decimal columns; if >= 5, sum with 3\\n        for col in 0..10 {\\n            let shift = offset + 4 * col;\\n            let window = (conv >> shift) & 0xF;\\n            if window >= 5 {\\n                conv += 3 << shift;\\n            }\\n        }\\n        // step 2: left rotation\\n        conv = conv.rotate_left(1);\\n    }\\n\\n    // erases the input\\n    conv >>= offset;\\n    (0..10)\\n        .map(move |c| (conv >> c * 4 & 0xF) as u8)\\n        // skip trailing zeroes\\n        .rev()\\n        .skip_while(|d| *d == 0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562771,
                "title": "java-100-memory-usage-100-speed-very-easy",
                "content": "It\\'s self explaining:\\nMain Calculation is done by modulo and division.\\n\\n````\\npublic int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n != 0) {\\n            product *= (n % 10);\\n            sum += (n % 10);\\n            n /= 10;\\n        }\\n        return product - sum;\\n    } \\n\\t\\n\\t",
                "solutionTags": [],
                "code": "It\\'s self explaining:\\nMain Calculation is done by modulo and division.\\n\\n````\\npublic int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n != 0) {\\n            product *= (n % 10);\\n            sum += (n % 10);\\n            n /= 10;\\n        }\\n        return product - sum;\\n    } \\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 525464,
                "title": "python-solution-without-using-str-or-numpy-functions",
                "content": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sumD=0\\n        prod=1\\n        \\n        while(n>0):\\n            digit=n%10\\n            sumD=sumD+digit\\n            prod=prod*digit\\n            n=n//10\\n        return prod-sumD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        sumD=0\\n        prod=1\\n        \\n        while(n>0):\\n            digit=n%10\\n            sumD=sumD+digit\\n            prod=prod*digit\\n            n=n//10\\n        return prod-sumD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523834,
                "title": "concise-javascript-solution-w-reduce",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let sum = `${n}`.split``.reduce((a,c) => a + +c, 0)\\n    let product = `${n}`.split``.reduce((a,c) => a * c, 1)\\n    return product - sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let sum = `${n}`.split``.reduce((a,c) => a + +c, 0)\\n    let product = `${n}`.split``.reduce((a,c) => a * c, 1)\\n    return product - sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508749,
                "title": "python3-why-not-try-eval-one-line-eval-20ms-96-18",
                "content": "Do not use eval?\\n20ms?\\n```\\nclass mySolution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return eval(str(n).replace(\\'\\', \\'*\\')[1:-1])-eval(str(n).replace(\\'\\', \\'+\\')[1:-1])\\n```\\neval is bad?",
                "solutionTags": [],
                "code": "```\\nclass mySolution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        return eval(str(n).replace(\\'\\', \\'*\\')[1:-1])-eval(str(n).replace(\\'\\', \\'+\\')[1:-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498202,
                "title": "javascript-solution",
                "content": "Runtime: 52 ms, faster than 82.54% of JavaScript online submissions for Subtract the Product and Sum of Digits of an Integer.\\nMemory Usage: 34.1 MB, less than 100.00% of JavaScript online submissions for Subtract the Product and Sum of Digits of an Integer.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function(n) {\\n    const values = n.toString()\\n    let sum = 0, product = 1\\n    for (const val of values) {\\n        sum += Number(val)\\n        product *= Number(val)\\n    }\\n    return product - sum\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar subtractProductAndSum = function(n) {\\n    const values = n.toString()\\n    let sum = 0, product = 1\\n    for (const val of values) {\\n        sum += Number(val)\\n        product *= Number(val)\\n    }\\n    return product - sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485011,
                "title": "javascript-100-time-100-memory-simple-solution",
                "content": "```\\nvar subtractProductAndSum = function(n) {\\n    let productOfDigits = 1;\\n    let sumOfDigits = 0;\\n    while(n > 0) {\\n        let pulledDigit = n % 10;\\n        productOfDigits *= pulledDigit;\\n        sumOfDigits += pulledDigit;\\n        n = parseInt(n / 10);\\n    }\\n    return productOfDigits - sumOfDigits;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar subtractProductAndSum = function(n) {\\n    let productOfDigits = 1;\\n    let sumOfDigits = 0;\\n    while(n > 0) {\\n        let pulledDigit = n % 10;\\n        productOfDigits *= pulledDigit;\\n        sumOfDigits += pulledDigit;\\n        n = parseInt(n / 10);\\n    }\\n    return productOfDigits - sumOfDigits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482166,
                "title": "javascript-solution",
                "content": "const subtractProductAndSum = n => {\\n    let product = 1\\n    let sum = 0\\n    let copy = n\\n    \\n    while (copy > 0) {\\n        let digit = copy % 10\\n        product = product * digit\\n        sum = sum + digit\\n        copy = Math.floor(copy / 10)\\n    }\\n    \\n    return product - sum\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "const subtractProductAndSum = n => {\\n    let product = 1\\n    let sum = 0\\n    let copy = n\\n    \\n    while (copy > 0) {\\n        let digit = copy % 10\\n        product = product * digit\\n        sum = sum + digit\\n        copy = Math.floor(copy / 10)\\n    }\\n    \\n    return product - sum\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 465639,
                "title": "cool-100-memory-one-line-solution",
                "content": "```\\n\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n \\n /* I would prefer to not do .split().join() twice, let me know if you can improve that without a variable */\\n \\nvar subtractProductAndSum = n => eval((\"\"+n).split(\\'\\').join(\\'*\\')) - eval((\"\"+n).split(\\'\\').join(\\'+\\'))\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n \\n /* I would prefer to not do .split().join() twice, let me know if you can improve that without a variable */\\n \\nvar subtractProductAndSum = n => eval((\"\"+n).split(\\'\\').join(\\'*\\')) - eval((\"\"+n).split(\\'\\').join(\\'+\\'))\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 465363,
                "title": "simple-0ms-solution-in-java",
                "content": "```\\nclass Solution {\\n    \\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int prod = 1;\\n        while(n != 0){\\n            sum += n%10;\\n            prod *= n%10;\\n            n /= 10;\\n        }\\n        \\n        return prod - sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int prod = 1;\\n        while(n != 0){\\n            sum += n%10;\\n            prod *= n%10;\\n            n /= 10;\\n        }\\n        \\n        return prod - sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460233,
                "title": "kotlin-solution-using-extension-functions",
                "content": "Converts the digit to string and then reduces the list. I should probably move the logic that produces the list of digits to its own function.\\n\\n```\\nclass Solution {\\n    fun subtractProductAndSum(n: Int): Int {\\n        val productOfDigits = n.productOfDigits()\\n        val productOfSums = n.sumOfDigits()\\n        return productOfDigits - productOfSums\\n    }\\n    \\n    fun Int.productOfDigits() : Int{\\n        return this.toString()\\n            .map { it.toString().toInt() }\\n            .reduce { product, element -> product * element }\\n    }\\n    \\n    fun Int.sumOfDigits() : Int{\\n        return this.toString()\\n            .map { it.toString().toInt() }\\n            .reduce { sum, element -> sum + element }\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    fun subtractProductAndSum(n: Int): Int {\\n        val productOfDigits = n.productOfDigits()\\n        val productOfSums = n.sumOfDigits()\\n        return productOfDigits - productOfSums\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 459125,
                "title": "c-simple-code-one-pass-beats-100-time-and-space",
                "content": "```\\npublic class Solution \\n{\\n    public int SubtractProductAndSum(int n)\\n    {\\n        int sum;\\n        int prod = ProdAndSum(n, out sum);\\n        return prod - sum;\\n    }\\n    \\n    private int ProdAndSum(int n, out int sum)\\n    {\\n        sum = 0;\\n        int prod = 1;\\n        \\n        while(n > 0)\\n        {\\n            int digit = n % 10;\\n            \\n            sum += digit;\\n            \\n            prod *= digit;\\n            \\n            n = n / 10;\\n        }\\n        \\n        return prod;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int SubtractProductAndSum(int n)\\n    {\\n        int sum;\\n        int prod = ProdAndSum(n, out sum);\\n        return prod - sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 457173,
                "title": "simple-easy-solution",
                "content": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        while(n>0){\\n            sum += n%10;\\n            product *= n%10;\\n            n = n/10;   \\n        }\\n        return product - sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int product = 1;\\n        while(n>0){\\n            sum += n%10;\\n            product *= n%10;\\n            n = n/10;   \\n        }\\n        return product - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455071,
                "title": "c-solution-100-better",
                "content": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        string num = to_string(n);\\n        int mult,add,solution;\\n        mult=1;\\n        add=0;\\n        solution=0;\\n        for(int i = 0; i<num.length();i++)\\n        {\\n            mult*=(num[i]-\\'0\\');\\n            add+=(num[i]-\\'0\\');\\n        }\\n        solution = mult-add;\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        string num = to_string(n);\\n        int mult,add,solution;\\n        mult=1;\\n        add=0;\\n        solution=0;\\n        for(int i = 0; i<num.length();i++)\\n        {\\n            mult*=(num[i]-\\'0\\');\\n            add+=(num[i]-\\'0\\');\\n        }\\n        solution = mult-add;\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453322,
                "title": "extremely-easy-php-solution-4ms-15mb",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function subtractProductAndSum($n) {\\n        $arr = str_split ($n);\\n        return array_product ($arr) - array_sum ($arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function subtractProductAndSum($n) {\\n        $arr = str_split ($n);\\n        return array_product ($arr) - array_sum ($arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452988,
                "title": "java-easy-readable-solution-beats-100",
                "content": "```\\npublic int subtractProductAndSum(int n) {\\n\\tint num = n, sum = 0, prod = 1;\\n\\twhile(num!=0) {\\n\\t\\tint currDigit = num%10;\\n\\t\\tsum += currDigit;\\n\\t\\tprod *= currDigit;\\n\\t\\tnum /= 10;\\n\\t}\\n\\treturn prod-sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int subtractProductAndSum(int n) {\\n\\tint num = n, sum = 0, prod = 1;\\n\\twhile(num!=0) {\\n\\t\\tint currDigit = num%10;\\n\\t\\tsum += currDigit;\\n\\t\\tprod *= currDigit;\\n\\t\\tnum /= 10;\\n\\t}\\n\\treturn prod-sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450743,
                "title": "ruby-easy-and-efficient-28ms-and-100-faster",
                "content": "```\\ndef subtract_product_and_sum(n)\\n   digits = n.to_s.chars.map(&:to_i)\\n   sum = digits.sum\\n   product = digits.reduce(&:*)\\n   product-sum \\nend\\n```\\n\\n**refactored 2-liner**\\n\\n```\\ndef subtract_product_and_sum(n)\\n   digits = n.to_s.chars.map(&:to_i)\\n   digits.reduce(&:*) - digits.sum\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef subtract_product_and_sum(n)\\n   digits = n.to_s.chars.map(&:to_i)\\n   sum = digits.sum\\n   product = digits.reduce(&:*)\\n   product-sum \\nend\\n```\n```\\ndef subtract_product_and_sum(n)\\n   digits = n.to_s.chars.map(&:to_i)\\n   digits.reduce(&:*) - digits.sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 446900,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int SubtractProductAndSum(int n)\\n    {\\n        int sum = 0, product = 1;\\n        while(n > 0)\\n        {\\n            int lastDigit = n % 10;\\n            sum += lastDigit;\\n            product *= lastDigit;\\n            n = n / 10;\\n        }\\n        \\n        return product - sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int SubtractProductAndSum(int n)\\n    {\\n        int sum = 0, product = 1;\\n        while(n > 0)\\n        {\\n            int lastDigit = n % 10;\\n            sum += lastDigit;\\n            product *= lastDigit;\\n            n = n / 10;\\n        }\\n        \\n        return product - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446393,
                "title": "python3-two-line-solution",
                "content": "Algorithm:\\nConvert number into list of digits, and compute the difference of their product and sum. \\n\\nImplementation (28ms, 100%): \\n```\\nfrom functools import reduce\\nfrom operator import mul\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        digits = [int(x) for x in str(n)]\\n        return reduce(mul, digits) - sum(digits)\\n```\\nAnalysis:\\nTime complexity `O(logN)`\\nSpace complexity `O(logN)`\\n\\nOne caveat is that `digits` cannot be generator i.e. `(int(x) for x in str(n))` as it is later used twice.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nfrom operator import mul\\n\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        digits = [int(x) for x in str(n)]\\n        return reduce(mul, digits) - sum(digits)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569813,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1745388,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1573248,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1574110,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1704369,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1948509,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1754746,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1575823,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 2009220,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1999458,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1569813,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1745388,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1573248,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1574110,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1704369,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1948509,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1754746,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1575823,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 2009220,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1999458,
                "content": [
                    {
                        "username": "doggo28",
                        "content": "\\tint sum(int n)\\n\\t{\\n\\t\\treturn n < 2 ? n : n % 10 + sum(n / 10);\\n\\t}\\n\\n\\tint product(int n)\\n\\t{\\n\\t\\treturn n < 2 ? 1 : n % 10 * product(n / 10);\\n\\t}\\n\\n\\tint subtractProductAndSum(int n)\\n\\t{\\n\\t\\treturn product(n) - sum(n);\\n\\t}"
                    },
                    {
                        "username": "yoconn",
                        "content": "Oooooof, protip make sure your product total starts with 1 and not 0...\\n\\nI was so confused until it dawned on me."
                    },
                    {
                        "username": "WhatdidIdo",
                        "content": "same lmao"
                    },
                    {
                        "username": "zahid555681",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "nimish007",
                        "content": "Shouldn\\'t the question state to return the result of substraction of sum from product? Difference is ideally always positive by definition."
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "How to deal with that?"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\\nOne for sum and one for product.\\nEx; int sum=0,product=1;\\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\\nCODE:\\nclass Solution {\\npublic:\\nint subtractProductAndSum(int n) {\\nint sum=0,pro=1;\\nwhile(n>0){\\npro*=n%10;\\nsum+=n%10;\\nn/=10;\\n}\\nreturn (pro-sum);\\n}\\n}"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@ahjimomo](/ahjimomo) For the first approach, I think its O(str(n)), since iterate through the string is constant, because the maximum number is 10^5 and the string will has as length in worst case 5. The problem her is the function str(). I don\\'t know how it is implement and its Big-o."
                    },
                    {
                        "username": "ahjimomo",
                        "content": "You can consider either converting the input as string, and iterate through the string character by character. This should be a $O(N)$ algorithm. \\n\\nAlternatively, you can apply modulus through each digit for optimization and it should be a $O(Log10N)$ algorithm"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "why are know it alls posting solutions in the discussion section"
                    },
                    {
                        "username": "shru20",
                        "content": "   def subtractProductAndSum(self, n):\\n       \\n        product=1\\n        sum=0\\n        num=str(n)\\n        for i in num:\\n            product= product*int(i)\\n            sum=sum+int(i)\\n        return product-sum"
                    },
                    {
                        "username": "mylitvinov",
                        "content": "let subtractProductAndSum = (n) => {\\n  let multN = String(n).split(\"\")\\n    .reduce((mult, num) => (mult *= +num), 1);\\n    let sumN = String(n).split(\"\")\\n    .reduce((sum, num) => (sum += +num), 0);\\n  return multN - sumN;\\n};"
                    },
                    {
                        "username": "es21btech11025",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        long product =1;\\n        long sum=0;\\n        while(n>0){\\n            int last_digit =n%10;\\n            sum=sum+last_digit;\\n            product=product*last_digit;\\n            n=n/10;\\n\\n        }\\n    return (product-sum);\\n    }\\n};"
                    },
                    {
                        "username": "Adarsh_k9",
                        "content": "import java.util.Scanner;\\nclass Leetcode1281 \\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tScanner sc=new Scanner(System.in);\\n\\t\\tint n=sc.nextInt();\\n\\t\\tint sum=0;\\n\\t\\tint mul=1;\\n\\t\\twhile(n>0)\\n\\t\\t{\\n\\t\\t\\tint r=n%10;\\n\\t\\t\\tsum=sum+r;\\n\\t\\t\\tmul=mul*r;\\n\\t\\t\\tn=n/10;\\n\\t\\t}\\n\\t\\tint answer=mul-sum;\\n\\t\\tSystem.out.println(answer);\\n\\t}\\n}\\n\\nWhy it is giving compilation error in Line 7?"
                    }
                ]
            },
            {
                "id": 1882506,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1853705,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1822195,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1817448,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1805386,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1805220,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1795665,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1794039,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774073,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1763389,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "No tests for negative numbers?"
                    },
                    {
                        "username": "el_luisito",
                        "content": "The question is misleading: it states the return should be \"the difference\" yet the result wants the subtraction. The name of the problem also hints at the second option"
                    },
                    {
                        "username": "Karan_kumar19",
                        "content": "The Problem can be solved simply by initializing two variables.\nOne for sum and one for product.\nEx; int sum=0,product=1;\nTraverse the loop untill number stays more than zero and apply the mod and division operator to reduce the number.\nCODE:\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum=0,pro=1;\n        while(n>0){\n            pro*=n%10;\n            sum+=n%10;\n            n/=10;\n        }\n        return (pro-sum);\n    }\n}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can it be done in constant time"
                    },
                    {
                        "username": "rasikaviba_cse",
                        "content": "how to solve this problem with 1<=Number<=1000"
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "Easiest question of leetCode"
                    },
                    {
                        "username": "Qiu-IT",
                        "content": "I am JSer, this case is not difficult and we can say it is easy. Just convert to string or array then looop, you can get the result. Only when I saw here in discussion some Leetcoder who did it with n%10 (remainder) and Math.floor(n%10), it is so fantastic. Nothing to convert to string or array, but you can solve it. Thanks everyone!"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int sum=0,s=0,d=0,p=0,prod=1;\\n\\n        while(n>0){\\n            s = n%10;\\n            prod = prod * s;\\n            sum = sum + s;\\n            n = n/10;\\n        }\\n        return prod-sum;\\n    }\\n}"
                    },
                    {
                        "username": "Abhicodes55",
                        "content": "int subtractProductAndSum(int n) {\\n        int sum=0,product=1;\\n        int num=0;\\n        while(n >0){\\n            num=n%10;\\n            sum+=num;\\n            product*=num;\\n            n=n/10;\\n        }\\n        return product-sum;\\n    }"
                    },
                    {
                        "username": "deeppanda5500",
                        "content": "why in last we wrote n=n/10 \\n"
                    },
                    {
                        "username": "M_Aasim",
                        "content": "class Solution {\\npublic:\\n    int product(int n){\\n        int product = 1;\\n        while(n>0){\\n            int rem = n%10;\\n            product *= rem;\\n            n /= 10;\\n        }\\n        return product;\\n    }\\n    int sum(int n){\\n        int sum = 0;\\n        while(n>0){\\n            int rem = n%10;\\n            sum += rem;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    int subtractProductAndSum(int n) {\\n        return product(n)-sum(n);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1763328,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1738429,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1734709,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1718392,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1714334,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1712888,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1711936,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1708927,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1704371,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            },
            {
                "id": 1697627,
                "content": [
                    {
                        "username": "kumarshubhamiitp",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        int answer,digit;\\n        while(n!=0){\\n            digit=n%10;\\n            product = product * digit;\\n            sum = sum + digit;\\n            n = n/10;\\n        }\\n        answer = product - sum;\\n        return answer;\\n    }\\n};"
                    },
                    {
                        "username": "jahidulhossainmekat",
                        "content": "super easy"
                    },
                    {
                        "username": "souravkumarpanda54",
                        "content": "class Solution {\\n    public int subtractProductAndSum(int n) {\\n        int product = 1;\\n        int sum = 0;\\n        while (n>0){\\n            int reminder = n%10;\\n            product *= reminder;\\n            sum += reminder;\\n            n = n /10;\\n        }\\n        int subtract = product - sum;\\n        return subtract;\\n    }\\n"
                    },
                    {
                        "username": "user_elsa",
                        "content": "class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int rem;\\n        int product=1,sum=0,result=0;\\n        cin>>n;\\n        while(n!=0){\\n            rem=n%10;\\n            product*=rem;\\n            sum+=rem;\\n            n/10;\\n        }\\n        result=product-sum;\\n        return result;\\n        \\n    }\\n};\\n\\n\\nThis solution is giving me,\\nRuntime Error\\nLine 10: Char 16: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:16\\ncould anyone please tell me why?"
                    },
                    {
                        "username": "willydlw",
                        "content": "The value of n is not changing in the loop due to the statement n/10. This should be n = n / 10."
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "hiwjfp\\'ks[f"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "BEST SOLUTION\\n\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product =1;\\n        int sum=0;\\n        while(n!=0){\\n            int num = n%10;\\n            product*=num;\\n            sum=sum+num;\\n            n=n/10;\\n\\n        }\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "srbtiwary",
                        "content": "Best C++ Solution \\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int product=1;\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            int num=n%10;\\n            product=product*num;\\n            sum=sum+num;\\n\\n            n=n/10;\\n\\n            \\n        }int answer = product-sum;\\n        return answer;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "Shivani_30",
                        "content": "Simple C++ code || Faster || 100% beats\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum=0;\\n        int product=1;\\n        int y;\\n        while(n){\\n            int x=n%10;\\n            sum = sum + x;\\n            product=product*x;\\n            n=n/10;\\n        }\\n\\n        return product-sum;\\n    }\\n};"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "The question should clearly mention \"Subtract the sum of digits from sum of products\". \\nBut the question here is stating that the difference which means the \"absolute difference\".\\nSo change the question or accept the testcases for the absolute difference."
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "it will be simple if we take two variables for sum and product  iterating over the loop until n>0\\nreturn the difference"
                    }
                ]
            }
        ]
    },
    {
        "title": "Average Waiting Time",
        "question_content": "<p>There is a restaurant with a single chef. You are given an array <code>customers</code>, where <code>customers[i] = [arrival<sub>i</sub>, time<sub>i</sub>]:</code></p>\n\n<ul>\n\t<li><code>arrival<sub>i</sub></code> is the arrival time of the <code>i<sup>th</sup></code> customer. The arrival times are sorted in <strong>non-decreasing</strong> order.</li>\n\t<li><code>time<sub>i</sub></code> is the time needed to prepare the order of the <code>i<sup>th</sup></code> customer.</li>\n</ul>\n\n<p>When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers <strong>in the order they were given in the input</strong>.</p>\n\n<p>Return <em>the <strong>average</strong> waiting time of all customers</em>. Solutions within <code>10<sup>-5</sup></code> from the actual answer are considered accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> customers = [[1,2],[2,5],[4,3]]\n<strong>Output:</strong> 5.00000\n<strong>Explanation:\n</strong>1) The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n2) The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n3) The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\nSo the average waiting time = (2 + 6 + 7) / 3 = 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> customers = [[5,2],[5,4],[10,3],[20,1]]\n<strong>Output:</strong> 3.25000\n<strong>Explanation:\n</strong>1) The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.\n2) The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6.\n3) The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4.\n4) The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.\nSo the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= customers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival<sub>i</sub>, time<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>arrival<sub>i&nbsp;</sub>&lt;= arrival<sub>i+1</sub></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 987328,
                "title": "java-c-python-straight-forward",
                "content": "# **Explanation**\\n`cur` means the current time.\\nfor each custom arriving at `t` with his order needing `d`,\\nwe start preparing his order at `max(cur, t)`,\\nwe finish his order at `max(cur, t) + d`,\\nand he waits for `max(cur, t) + d - t`,\\n\\nWe need to sum up the waiting time,\\nand also update the `cur` time after sever each custom.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public double averageWaitingTime(int[][] A) {\\n        double wait = 0, cur = 0;\\n        for (int[] a: A) {\\n            cur = Math.max(cur, 1.0 * a[0]) + a[1];\\n            wait += cur - a[0];\\n        }\\n        return 1.0 * wait / A.length;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    double averageWaitingTime(vector<vector<int>>& A) {\\n        double wait = 0, cur = 0;\\n        for (auto& a: A) {\\n            cur = max(cur, 1.0 * a[0]) + a[1];\\n            wait += cur - a[0];\\n        }\\n        return 1.0 * wait / A.size();\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def averageWaitingTime(self, A):\\n        wait = cur = 0.\\n        for t, d in A:\\n            cur = max(cur, t) + d\\n            wait += cur - t\\n        return wait / len(A)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public double averageWaitingTime(int[][] A) {\\n        double wait = 0, cur = 0;\\n        for (int[] a: A) {\\n            cur = Math.max(cur, 1.0 * a[0]) + a[1];\\n            wait += cur - a[0];\\n        }\\n        return 1.0 * wait / A.length;\\n    }\\n```\n```cpp\\n    double averageWaitingTime(vector<vector<int>>& A) {\\n        double wait = 0, cur = 0;\\n        for (auto& a: A) {\\n            cur = max(cur, 1.0 * a[0]) + a[1];\\n            wait += cur - a[0];\\n        }\\n        return 1.0 * wait / A.size();\\n    }\\n```\n```py\\n    def averageWaitingTime(self, A):\\n        wait = cur = 0.\\n        for t, d in A:\\n            cur = max(cur, t) + d\\n            wait += cur - t\\n        return wait / len(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 989238,
                "title": "java-python-3-track-the-chef-s-available-time-w-analysis",
                "content": "\\n**Analysis:**\\nTime: O(n), space: O(1), where n = customers.length.\\n\\n```java\\n    public double averageWaitingTime(int[][] customers) {\\n        double wait = 0, nextAvailableTime = 0;\\n        for (int[] c : customers) {\\n            nextAvailableTime = c[1] + Math.max(c[0], nextAvailableTime);\\n            wait += nextAvailableTime - c[0];\\n        }\\n        return wait / customers.length;\\n    }\\n```\\n```python\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        wait = next_available_time = 0\\n        for arrival, time in customers:\\n            next_available_time = time + max(next_available_time, arrival)\\n            wait += next_available_time - arrival\\n        return wait / len(customers)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public double averageWaitingTime(int[][] customers) {\\n        double wait = 0, nextAvailableTime = 0;\\n        for (int[] c : customers) {\\n            nextAvailableTime = c[1] + Math.max(c[0], nextAvailableTime);\\n            wait += nextAvailableTime - c[0];\\n        }\\n        return wait / customers.length;\\n    }\\n```\n```python\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        wait = next_available_time = 0\\n        for arrival, time in customers:\\n            next_available_time = time + max(next_available_time, arrival)\\n            wait += next_available_time - arrival\\n        return wait / len(customers)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1236349,
                "title": "python3-simple-and-fast-solution",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        arr = []\\n        \\n        time = 0\\n        \\n        for i , j in customers:\\n            if(i > time):\\n                time = i + j\\n            else:\\n                time += j\\n            arr.append(time - i)\\n        \\n        return sum(arr) / len(arr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        arr = []\\n        \\n        time = 0\\n        \\n        for i , j in customers:\\n            if(i > time):\\n                time = i + j\\n            else:\\n                time += j\\n            arr.append(time - i)\\n        \\n        return sum(arr) / len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092226,
                "title": "java-100-short-and-easy-to-understand",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double totalTime = 0;\\n        \\n        int passedTime = customers[0][0];\\n        \\n        for(int i = 0; i < customers.length;i++){\\n            passedTime = Math.max(passedTime , customers[i][0]);\\n            passedTime += customers[i][1];\\n            totalTime += passedTime - customers[i][0];\\n        }\\n        \\n        return totalTime / customers.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double totalTime = 0;\\n        \\n        int passedTime = customers[0][0];\\n        \\n        for(int i = 0; i < customers.length;i++){\\n            passedTime = Math.max(passedTime , customers[i][0]);\\n            passedTime += customers[i][1];\\n            totalTime += passedTime - customers[i][0];\\n        }\\n        \\n        return totalTime / customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987743,
                "title": "java-easy-solution-time-o-n-space-o-1",
                "content": "**Approach**\\n1. Keep a track of the current time `time` and total wait time `waitingTime`.\\n2. If the time of arrival of the next customer is greater than the current time, fast forward to that time `time = Math.max(cust[0],time)`\\n3. Increament the time with the time required to prepare the dish `time = time + cust[1]`\\n4. Calculate the total time `customer[i]` had to wait and add it to total time.\\n5. Divide by the total no. of customers to get average.\\n\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double time = 0;\\n        double waitingTime = 0;\\n        \\n        for(int[] cust : customers){\\n            time = Math.max(cust[0],time);            \\n            time = time + cust[1];\\n            waitingTime += (time - cust[0]);\\n        }\\n                \\n        return waitingTime/customers.length;\\n    }\\n}\\n```\\n\\nHope the solution helps.\\n**Happy Coding :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double time = 0;\\n        double waitingTime = 0;\\n        \\n        for(int[] cust : customers){\\n            time = Math.max(cust[0],time);            \\n            time = time + cust[1];\\n            waitingTime += (time - cust[0]);\\n        }\\n                \\n        return waitingTime/customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987321,
                "title": "easy-python-solution-accepted",
                "content": "**Explanation**\\nFirstly, we get the initial customer arrival time as actual time, then go through all customers one by one with special logic. We add waiting to time to actual time. If the next arrival time is bigger than the current actual time, it means that customer ordered it when chef is free.\\n**Complexity**\\n\\nTime ```O(N)```\\nSpace ```O(1)```\\n\\n**Python:**\\n```\\ndef averageWaitingTime(self, customers: List[List[int]]) -> float:\\n\\xA0 \\xA0 \\xA0 \\xA0 act = customers[0][0]\\n\\xA0 \\xA0 \\xA0 \\xA0 wait = 0\\n\\xA0 \\xA0 \\xA0 \\xA0 for item in customers:\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if act<item[0]:\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 act = item[0]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 act += item[1]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 wait +=(act - item[0])\\n\\xA0 \\xA0 \\xA0 \\xA0 return wait/len(customers)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```O(N)```\n```O(1)```\n```\\ndef averageWaitingTime(self, customers: List[List[int]]) -> float:\\n\\xA0 \\xA0 \\xA0 \\xA0 act = customers[0][0]\\n\\xA0 \\xA0 \\xA0 \\xA0 wait = 0\\n\\xA0 \\xA0 \\xA0 \\xA0 for item in customers:\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if act<item[0]:\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 act = item[0]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 act += item[1]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 wait +=(act - item[0])\\n\\xA0 \\xA0 \\xA0 \\xA0 return wait/len(customers)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2373319,
                "title": "c-simple-for-loop-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double ans=0;\\n        int c=0;\\n        for(int i=0;i<customers.size();i++){\\n            c=max(c,customers[i][0]);\\n            ans+=c+customers[i][1]-customers[i][0];\\n            c+=customers[i][1];\\n        }\\n        return ans/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double ans=0;\\n        int c=0;\\n        for(int i=0;i<customers.size();i++){\\n            c=max(c,customers[i][0]);\\n            ans+=c+customers[i][1]-customers[i][0];\\n            c+=customers[i][1];\\n        }\\n        return ans/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414818,
                "title": "c-solution-easy-to-understand-straight-forward-simulation-explained",
                "content": "we need to keep track of couple of things:\\n1 . current time\\n2. total wait time\\n\\ncurrent time = max(arrivalTime[i], currentTime) + TimeToCook[i];\\nwaitTime += currentTime - arrivalTime[i];\\nthen just return the waitTime / number of customers (average)\\n\\n**Thats all**\\n\\n\\tdouble averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        if(n == 0){\\n            return n;\\n        }\\n        \\n\\t\\t//customers[i][0] = arrivalTime\\n\\t\\t//customers[i][1] = timeToCook\\n\\t\\t\\n        int time = 0;\\n        double wait = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            time = max(customers[i][0], time) + customers[i][1];\\n            wait += time - customers[i][0];\\n        }\\n        \\n        return wait / (double)n;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "we need to keep track of couple of things:\\n1 . current time\\n2. total wait time\\n\\ncurrent time = max(arrivalTime[i], currentTime) + TimeToCook[i];\\nwaitTime += currentTime - arrivalTime[i];\\nthen just return the waitTime / number of customers (average)\\n\\n**Thats all**\\n\\n\\tdouble averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        if(n == 0){\\n            return n;\\n        }\\n        \\n\\t\\t//customers[i][0] = arrivalTime\\n\\t\\t//customers[i][1] = timeToCook\\n\\t\\t\\n        int time = 0;\\n        double wait = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            time = max(customers[i][0], time) + customers[i][1];\\n            wait += time - customers[i][0];\\n        }\\n        \\n        return wait / (double)n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 993382,
                "title": "c-o-n-solution-hopefully-easy-to-understand",
                "content": "There are 2 scenarios we need to handle,\\n\\nInitially Last Dish Completed Time = 0;\\nwt = Total Waiting Time\\nlct = Last Dish Completed Time\\n\\n1. If Last Dish Completed Time  > Current Customer Arrival Time, \\n\\t\\tthen Include the Current Dish Preparing Time + (Last Dish Completed Time  - Current Customer Arrival Time);\\n\\t\\tAnd  Update Last Dish Completed Time += Current Dish Preparing Time;\\n2.  If Last Dish Completed Time  <= Current Customer Arrival Time, \\n\\t\\tthen Include the Current Preparing Time;\\n\\t\\tAnd  Update Last Dish Completed Time = Current Dish Preparing Time + Current Customer Arrival Time;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        int lct = 0;\\n        double wt = 0;\\n        for(int  i = 0; i < c.size(); i++){\\n            if(lct > c[i][0]){\\n                wt += lct + c[i][1]  - c[i][0] ;\\n                lct += c[i][1];\\n            } \\n            else {\\n                wt += c[i][1] ;\\n                lct = c[i][1] + c[i][0];\\n            }\\n        }\\n        return wt/c.size();\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        int lct = 0;\\n        double wt = 0;\\n        for(int  i = 0; i < c.size(); i++){\\n            if(lct > c[i][0]){\\n                wt += lct + c[i][1]  - c[i][0] ;\\n                lct += c[i][1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3693432,
                "title": "best-c-solution-beginner-friendly-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        double ans = 0, totalTime = c[0][0], waitTime = 0; // totalTime is initialised with arrival time of first customer\\n        for(int i=0; i<c.size(); i++)\\n        {\\n            if(c[i][0]<totalTime){  // Case when the chef is busy making other orders\\n                totalTime += c[i][1];\\n                waitTime += totalTime - c[i][0];\\n            }\\n            else{ // case when chef is already free \\n                totalTime = c[i][0] + c[i][1];\\n                waitTime += c[i][1];\\n            }\\n        }\\n        return waitTime/(c.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        double ans = 0, totalTime = c[0][0], waitTime = 0; // totalTime is initialised with arrival time of first customer\\n        for(int i=0; i<c.size(); i++)\\n        {\\n            if(c[i][0]<totalTime){  // Case when the chef is busy making other orders\\n                totalTime += c[i][1];\\n                waitTime += totalTime - c[i][0];\\n            }\\n            else{ // case when chef is already free \\n                totalTime = c[i][0] + c[i][1];\\n                waitTime += c[i][1];\\n            }\\n        }\\n        return waitTime/(c.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404291,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        a=customers[0][0]\\n        wait=0\\n        for i in customers:\\n            \\n            if(a<i[0]):\\n                wait+=((i[0]+i[1])-i[0])\\n                a=i[0]+i[1]\\n            else:\\n                a+=i[1]\\n                wait+=(a-i[0])\\n            print(wait,a)\\n        return(wait/len(customers))\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        a=customers[0][0]\\n        wait=0\\n        for i in customers:\\n            \\n            if(a<i[0]):\\n                wait+=((i[0]+i[1])-i[0])\\n                a=i[0]+i[1]\\n            else:\\n                a+=i[1]\\n                wait+=(a-i[0])\\n            print(wait,a)\\n        return(wait/len(customers))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192471,
                "title": "python-short-solution",
                "content": "```python\\nclass Solution:\\n    def averageWaitingTime(self, customers):\\n        ans = cur = 0\\n        for x, y in customers:\\n            cur = max(cur, x) + y\\n            ans += (cur - x) / len(customers)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def averageWaitingTime(self, customers):\\n        ans = cur = 0\\n        for x, y in customers:\\n            cur = max(cur, x) + y\\n            ans += (cur - x) / len(customers)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991633,
                "title": "java-100-faster-easy-understanding-o-n",
                "content": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int totalTime = customers[0][0]+customers[0][1];\\n        double time = totalTime-customers[0][0];\\n        for(int i = 1;i<customers.length;i++){\\n            if(customers[i][0] < totalTime){\\n            totalTime += customers[i][1];//1 2   3\\n            time +=totalTime - customers[i][0];\\n            }else{\\n                totalTime = customers[i][0]+customers[i][1];\\n                time+=totalTime - customers[i][0];\\n            }\\n        }\\n        return time/customers.length;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int totalTime = customers[0][0]+customers[0][1];\\n        double time = totalTime-customers[0][0];\\n        for(int i = 1;i<customers.length;i++){\\n            if(customers[i][0] < totalTime){\\n            totalTime += customers[i][1];//1 2   3\\n            time +=totalTime - customers[i][0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 987530,
                "title": "easiest-java-solution-to-understand",
                "content": "class Solution {\\n    public double averageWaitingTime(int[][] customers) \\n    {\\n      double prep= customers[0][0]+customers[0][1];double sum=customers[0][1], diff=0;\\n        double ans=0;\\n          \\n        for(int i=1;i<customers.length;i++)\\n          {\\n            \\n                  if(prep-customers[i][0]>0)\\n                  {\\n                      diff= prep-customers[i][0];\\n                      prep=prep+customers[i][1];\\n                      sum+=diff+customers[i][1];\\n                  }\\n                  \\n                  if(prep-customers[i][0]<=0)\\n                  {\\n                 diff= prep-customers[i][0];\\n                      prep=customers[i][0]+customers[i][1];\\n                      sum+=customers[i][1];\\n                  }\\n              \\n              \\n          }\\n           ans=sum/customers.length;\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double averageWaitingTime(int[][] customers) \\n    {\\n      double prep= customers[0][0]+customers[0][1];double sum=customers[0][1], diff=0;\\n        double ans=0;\\n          \\n        for(int i=1;i<customers.length;i++)\\n          {\\n            \\n                  if(prep-customers[i][0]>0)\\n                  {\\n                      diff= prep-customers[i][0];\\n                      prep=prep+customers[i][1];\\n                      sum+=diff+customers[i][1];\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 987475,
                "title": "c-formula-based-o-n-solution-easy-worst-time-space-lol",
                "content": "\\n***Formula:***  \\n``` \\nans = prev_cust\\'s (arrival time + cooking time) - curr_cust\\'s arrival time + waiting time of previous dish.\\n```\\n```\\n\\nExample Test-Case:\\n\\n[[5,2],[5,4],[10,3],[20,1]]\\n\\nArr.T     Cook.T   Total/Answer (prev_dishes_time + curr_dish_wait _time +  curr_dish_cook_time)\\n 5          2          2  \\n 5          4       (2+2+4)   5+2-5    = 2(current dish waiting time) \\n 10         3       (8+1+3)   5+4-10+2(prev_dish_wait.t) = 1(current dish waiting time) \\n 20         1       (12+0+1)  10+3-20+1 = -6 (no wait time, hence 0)\\n                    \\n                    13/4 = 3.25\\n```\\n\\n```\\nclass Solution\\n{\\npublic:\\n    double averageWaitingTime(vector<vector<int>> customers)\\n    {\\n        int curTime = 0;\\n        double ans = customers[0][1];\\n\\n        int check = 0, waitTime = 0;\\n        for (int i = 1; i < customers.size(); i++)\\n        {\\n\\t\\t    waitTime = customers[i - 1][0] + customers[i - 1][1] - customers[i][0] + waitTime;\\n            if (waitTime > 0)\\n                ans += waitTime;\\n            else\\n                waitTime = 0;       // If previous dish/customer had no waiting time\\n            ans += customers[i][1]; // Time Required to cook current customer\\'s food\\n        }\\n        ans = ans / customers.size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nans = prev_cust\\'s (arrival time + cooking time) - curr_cust\\'s arrival time + waiting time of previous dish.\\n```\n```\\n\\nExample Test-Case:\\n\\n[[5,2],[5,4],[10,3],[20,1]]\\n\\nArr.T     Cook.T   Total/Answer (prev_dishes_time + curr_dish_wait _time +  curr_dish_cook_time)\\n 5          2          2  \\n 5          4       (2+2+4)   5+2-5    = 2(current dish waiting time) \\n 10         3       (8+1+3)   5+4-10+2(prev_dish_wait.t) = 1(current dish waiting time) \\n 20         1       (12+0+1)  10+3-20+1 = -6 (no wait time, hence 0)\\n                    \\n                    13/4 = 3.25\\n```\n```\\nclass Solution\\n{\\npublic:\\n    double averageWaitingTime(vector<vector<int>> customers)\\n    {\\n        int curTime = 0;\\n        double ans = customers[0][1];\\n\\n        int check = 0, waitTime = 0;\\n        for (int i = 1; i < customers.size(); i++)\\n        {\\n\\t\\t    waitTime = customers[i - 1][0] + customers[i - 1][1] - customers[i][0] + waitTime;\\n            if (waitTime > 0)\\n                ans += waitTime;\\n            else\\n                waitTime = 0;       // If previous dish/customer had no waiting time\\n            ans += customers[i][1]; // Time Required to cook current customer\\'s food\\n        }\\n        ans = ans / customers.size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987418,
                "title": "beginner-friendly-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int start=0;\\n        double wait=0;\\n        for(vector<int> customer :customers){\\n            start=max(start,customer[0])+customer[1];\\n            wait+=(start-customer[0]);\\n        }\\n        return wait/customers.size();\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int start=0;\\n        double wait=0;\\n        for(vector<int> customer :customers){\\n            start=max(start,customer[0])+customer[1];\\n            wait+=(start-customer[0]);\\n        }\\n        return wait/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987398,
                "title": "java-simulation-keep-tracking-current-time",
                "content": "To get the total waiting time, we need to calculate all customers\\' waiting time. To calculate each customer\\'s waiting time, we need to know his/her **enter time** and **current time when he/she gets the order**.\\n\\n```\\n    public double averageWaitingTime(int[][] c) {\\n        long waitingSum = 0;\\n        int len = c.length, currentTime = 0;\\n        for (int i=0; i<len; i++) {\\n            int startTime = Math.max(currentTime, c[i][0]);\\n            currentTime = startTime + c[i][1];\\n            waitingSum += currentTime - c[i][0];\\n        }\\n        return waitingSum * 1.0 / len;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double averageWaitingTime(int[][] c) {\\n        long waitingSum = 0;\\n        int len = c.length, currentTime = 0;\\n        for (int i=0; i<len; i++) {\\n            int startTime = Math.max(currentTime, c[i][0]);\\n            currentTime = startTime + c[i][1];\\n            waitingSum += currentTime - c[i][0];\\n        }\\n        return waitingSum * 1.0 / len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863596,
                "title": "c-pure-implementation",
                "content": "# Code\\n```\\n#define i64 long long\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double res = 0.0;\\n        i64 now = 0;\\n        i64 total_time = 0;\\n        i64 c = 0;\\n        for (int i = 0; i < (int)customers.size(); i++) {\\n            i64 come = customers[i][0];\\n            i64 time = customers[i][1];\\n            if (i == 0) {\\n                total_time = come + time;\\n                c += total_time - come;\\n            }\\n            else {\\n                i64 a = max(total_time, come);\\n                total_time = (a + time);\\n                c += total_time - come;\\n            }\\n        }\\n        res = (double)c / (int)customers.size();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\n#define i64 long long\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double res = 0.0;\\n        i64 now = 0;\\n        i64 total_time = 0;\\n        i64 c = 0;\\n        for (int i = 0; i < (int)customers.size(); i++) {\\n            i64 come = customers[i][0];\\n            i64 time = customers[i][1];\\n            if (i == 0) {\\n                total_time = come + time;\\n                c += total_time - come;\\n            }\\n            else {\\n                i64 a = max(total_time, come);\\n                total_time = (a + time);\\n                c += total_time - come;\\n            }\\n        }\\n        res = (double)c / (int)customers.size();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440643,
                "title": "java-simple-and-intuitive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe wait time for each customer must be greater or equal to the time taken to prepare the dish depending on how busy the chef is.\\n\\nTo check whether the chef is currently occupied, we can use a variable to store the time at which the chef would be finished with all previous orders, and compare that with the arrival time of the customer. \\n\\nSince the chef is idle when no orders are active, we want to update chef time to be the maximum of the current chef time and the arrival time of the customer. Once we have the current chef time we know it will take the chef $$time_i$$ seconds to prepare the dish, and so we should add $$time_i$$ to the chef time. From there we can calculate how long this customer will wait by simply taking the difference between the chef time and the arrival time of the customer.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int n = customers.length;\\n        long chefTime = customers[0][1] + customers[0][0];\\n        long waitTime = customers[0][1];\\n\\n        for(int i=1; i<n; i++){\\n            int arrival = customers[i][0];\\n            int timeRequired = customers[i][1];\\n            chefTime = Math.max(chefTime, arrival);\\n            chefTime += timeRequired;\\n            waitTime += chefTime - arrival;\\n        }\\n        return (double) waitTime/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int n = customers.length;\\n        long chefTime = customers[0][1] + customers[0][0];\\n        long waitTime = customers[0][1];\\n\\n        for(int i=1; i<n; i++){\\n            int arrival = customers[i][0];\\n            int timeRequired = customers[i][1];\\n            chefTime = Math.max(chefTime, arrival);\\n            chefTime += timeRequired;\\n            waitTime += chefTime - arrival;\\n        }\\n        return (double) waitTime/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049062,
                "title": "java-easy-solution-explained",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double waitingTime = 0;     // to store our total waiting time\\n        int totalTime = 0;          // to store our time for which our chef would be busy\\n        for (int[] c : customers) {\\n            // means our chef is busy and customer has to wait\\n            if (c[0] < totalTime) {\\n                // add the order preparation time to chef\\'s time \\n                // (chef won\\'t start cooking the ordered food instantly)\\n                totalTime += c[1];\\n            } else {   // means our chef is idle\\n                // add the arrival time and preparation time to chef\\'s time\\n                // (chef will instantly start cooking for the order)\\n                totalTime = c[0] + c[1];\\n            }\\n            // chef will start to cook for an order only after the previous orders are completed cooking for\\n            // if a customer arrives at time x and chef takes time y, \\n            // customer has to wait for time x-y and after that chef will take his order\\n            waitingTime += (totalTime - c[0]);\\n        }\\n\\n        return waitingTime / customers.length * 1.0;    // return the average as a double\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double waitingTime = 0;     // to store our total waiting time\\n        int totalTime = 0;          // to store our time for which our chef would be busy\\n        for (int[] c : customers) {\\n            // means our chef is busy and customer has to wait\\n            if (c[0] < totalTime) {\\n                // add the order preparation time to chef\\'s time \\n                // (chef won\\'t start cooking the ordered food instantly)\\n                totalTime += c[1];\\n            } else {   // means our chef is idle\\n                // add the arrival time and preparation time to chef\\'s time\\n                // (chef will instantly start cooking for the order)\\n                totalTime = c[0] + c[1];\\n            }\\n            // chef will start to cook for an order only after the previous orders are completed cooking for\\n            // if a customer arrives at time x and chef takes time y, \\n            // customer has to wait for time x-y and after that chef will take his order\\n            waitingTime += (totalTime - c[0]);\\n        }\\n\\n        return waitingTime / customers.length * 1.0;    // return the average as a double\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925909,
                "title": "beats-100-0ms-3-lines-easy-proof",
                "content": "# UPVOTE please\\n![image.png](https://assets.leetcode.com/users/images/6fce2597-704a-4079-916e-924110b7b0b7_1671379155.9872167.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] C) {\\n        double an=0;\\n        int st=C[0][0];\\n        for (var v:C){\\n             st = (st>=v[0])? st+v[1] : v[0]+v[1];\\n            an+=(st-v[0]);\\n        }return an/C.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] C) {\\n        double an=0;\\n        int st=C[0][0];\\n        for (var v:C){\\n             st = (st>=v[0])? st+v[1] : v[0]+v[1];\\n            an+=(st-v[0]);\\n        }return an/C.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373310,
                "title": "c-easy-solution-noob-logic",
                "content": "Let me know if you have any doubts on the comments!\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int start=customers[0][0]+customers[0][1];\\n        vector<int>v; \\n        int temp=start-customers[0][0];\\n        v.push_back(temp);\\n        for(int i=1;i<customers.size();i++){\\n            if(start>=customers[i][0]){\\n                start+=customers[i][1]; \\n                int temp=start-customers[i][0]; \\n                v.push_back(temp); \\n            }\\n            else{\\n                start=customers[i][0]+customers[i][1]; \\n                int temp=start-customers[i][0];\\n                v.push_back(temp); \\n            }\\n        }\\n        double res=0.0;\\n        for(int i=0;i<v.size();i++){\\n            res+=v[i]; \\n        }\\n        return res/v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int start=customers[0][0]+customers[0][1];\\n        vector<int>v; \\n        int temp=start-customers[0][0];\\n        v.push_back(temp);\\n        for(int i=1;i<customers.size();i++){\\n            if(start>=customers[i][0]){\\n                start+=customers[i][1]; \\n                int temp=start-customers[i][0]; \\n                v.push_back(temp); \\n            }\\n            else{\\n                start=customers[i][0]+customers[i][1]; \\n                int temp=start-customers[i][0];\\n                v.push_back(temp); \\n            }\\n        }\\n        double res=0.0;\\n        for(int i=0;i<v.size();i++){\\n            res+=v[i]; \\n        }\\n        return res/v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134993,
                "title": "c-might-help-you-dry-run-once",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        long long start=0;\\n        long long sum=0;\\n       \\n        \\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i][0]>start)\\n                start=customers[i][0];\\n            \\n            int finish=start + customers[i][1];\\n            \\n            sum+=(finish-customers[i][0]);\\n\\n            start=finish;\\n           \\n        }\\n        \\n        \\n            \\n        return (double)sum/customers.size();\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        long long start=0;\\n        long long sum=0;\\n       \\n        \\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i][0]>start)\\n                start=customers[i][0];\\n            \\n            int finish=start + customers[i][1];\\n            \\n            sum+=(finish-customers[i][0]);\\n\\n            start=finish;\\n           \\n        }\\n        \\n        \\n            \\n        return (double)sum/customers.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377537,
                "title": "c-no-queue-easy-naive-eaisily-understandable",
                "content": "\\nI\\'m not a very good coder, I\\'m trying to be one.\\nPlease suggest if any optimization possible in the same approach\\n\\n\\n     double averageWaitingTime(vector<vector<int>>&c)\\n\\t {\\n\\t long n = c.size();\\n\\t ////since the values may exceed integer range i\\'ve used long here\\n        vector<vector<long>>customers(n,vector<long> (2));\\n       \\n      //cloning the c vector\\n\\t  for(int i =0;i<n;i++){\\n            customers[i][0]=c[i][0];\\n            customers[i][1]=c[i][1];\\n        }\\n        \\n       \\n        \\n        //wt-->waiting time \\n\\t\\t//initialize it with the waiting time of first customer\\n\\t\\tlong wt = customers[0][1];\\n        \\n        customers[0][1]= customers[0][0]+customers[0][1];\\n        \\n       //iterate in the customers vector to calculate the waiting time\\n\\t   for(long i=1;i<n;i++)\\n        {\\n            int prev_time = max(customers[i-1][1],customers[i][0]);\\n            customers[i][1]=prev_time+customers[i][1];\\n            wt+=abs(customers[i][1]-customers[i][0]);\\n        }\\n        \\n  \\n        return (double)wt/n;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\nI\\'m not a very good coder, I\\'m trying to be one.\\nPlease suggest if any optimization possible in the same approach\\n\\n\\n     double averageWaitingTime(vector<vector<int>>&c)\\n\\t {\\n\\t long n = c.size();\\n\\t ////since the values may exceed integer range i\\'ve used long here\\n        vector<vector<long>>customers(n,vector<long> (2));\\n       \\n      //cloning the c vector\\n\\t  for(int i =0;i<n;i++){\\n            customers[i][0]=c[i][0];\\n            customers[i][1]=c[i][1];\\n        }\\n        \\n       \\n        \\n        //wt-->waiting time \\n\\t\\t//initialize it with the waiting time of first customer\\n\\t\\tlong wt = customers[0][1];\\n        \\n        customers[0][1]= customers[0][0]+customers[0][1];\\n        \\n       //iterate in the customers vector to calculate the waiting time\\n\\t   for(long i=1;i<n;i++)\\n        {\\n            int prev_time = max(customers[i-1][1],customers[i][0]);\\n            customers[i][1]=prev_time+customers[i][1];\\n            wt+=abs(customers[i][1]-customers[i][0]);\\n        }\\n        \\n  \\n        return (double)wt/n;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1204136,
                "title": "soluton",
                "content": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n=customers.size(),m;\\n    double a,b,sum=0,k=customers[0][0];\\n    for(int i=0;i<n;i++){\\n        a=customers[i][0];\\n        b=customers[i][1];\\n        if(k>=customers[i][0]) k=k+b;\\n        else k=a+b;\\n        m=(k-a);\\n        sum+=m;\\n    }\\n    return sum/n;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n=customers.size(),m;\\n    double a,b,sum=0,k=customers[0][0];\\n    for(int i=0;i<n;i++){\\n        a=customers[i][0];\\n        b=customers[i][1];\\n        if(k>=customers[i][0]) k=k+b;\\n        else k=a+b;\\n        m=(k-a);\\n        sum+=m;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1151351,
                "title": "javascript-solution",
                "content": "```\\nvar averageWaitingTime = function (customers) {\\n  var start = customers[0][0],\\n    sum = 0;\\n\\n  customers.map(([arrival, time]) => {\\n    start = Math.max(start, arrival) + time;\\n    sum += start - arrival;\\n  });\\n\\n  return sum / customers.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar averageWaitingTime = function (customers) {\\n  var start = customers[0][0],\\n    sum = 0;\\n\\n  customers.map(([arrival, time]) => {\\n    start = Math.max(start, arrival) + time;\\n    sum += start - arrival;\\n  });\\n\\n  return sum / customers.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036304,
                "title": "go-mathematical-solution-with-explanation",
                "content": "* `sum` is the wait time of the customers\\n* `time` is the current time \\n* `subract` is for overlap time\\n\\n`time - customer[0] <= 0` means there is no overlaping so the code does `time - customer[0] > 0` and makes the overlapping time `time - customer[0]`. If no overlap then we can set `time = customer[0]` but `time += customer[0] - time`\\n\\n`time += customer[1]` is for adding the chefs cook time.\\n\\n`sum += customer[1] + subtract` is adding the chefs cook time with the overlap time and then adding it to the total wait time.\\n\\n```\\nfunc averageWaitingTime(customers [][]int) float64 {\\n\\ttime := 0\\n\\tsum := 0\\n\\tfor _, customer := range customers {\\n\\t\\tsubtract := 0\\n\\t\\tif time-customer[0] > 0 {\\n\\t\\t\\tsubtract = time - customer[0]\\n\\t\\t} else {\\n\\t\\t\\ttime = customer[0]\\n\\t\\t}\\n\\t\\ttime += customer[1]\\n\\t\\tsum += customer[1] + subtract\\n\\t}\\n\\treturn float64(sum) / float64(len(customers))\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc averageWaitingTime(customers [][]int) float64 {\\n\\ttime := 0\\n\\tsum := 0\\n\\tfor _, customer := range customers {\\n\\t\\tsubtract := 0\\n\\t\\tif time-customer[0] > 0 {\\n\\t\\t\\tsubtract = time - customer[0]\\n\\t\\t} else {\\n\\t\\t\\ttime = customer[0]\\n\\t\\t}\\n\\t\\ttime += customer[1]\\n\\t\\tsum += customer[1] + subtract\\n\\t}\\n\\treturn float64(sum) / float64(len(customers))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995966,
                "title": "easy-to-understand-python-solution-faster-than-98",
                "content": "Initialize the start and end using the first customer\\'s order. Then accumulate the wait time that each customer experiences. \\n\\nThere are two possibilities,\\n1. Upon order arrival, the kitchen is able to work on the order starting from arrival time\\n2. The kitchen is working on previous order and we need to add the time spent waiting for kitchen to finish previous order plus the time spent on the actual order.\\n\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        start = customers[0][0]\\n        end = start + customers[0][1]\\n        total_wait = end - start\\n        for c in customers[1:]:\\n            start = c[0]\\n            if start <= end:\\n                end += c[1]\\n                total_wait = total_wait + end - start\\n            else:\\n                end = c[0]+c[1]\\n                total_wait += c[1]\\n        return total_wait/len(customers)\\n            \\n    \\n    \\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        start = customers[0][0]\\n        end = start + customers[0][1]\\n        total_wait = end - start\\n        for c in customers[1:]:\\n            start = c[0]\\n            if start <= end:\\n                end += c[1]\\n                total_wait = total_wait + end - start\\n            else:\\n                end = c[0]+c[1]\\n                total_wait += c[1]\\n        return total_wait/len(customers)\\n            \\n    \\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 987699,
                "title": "c-linear-solution-explained-20-time-40-space",
                "content": "This one was pretty straightforward and I am not sure why was ranked as a medium, since I can think of several \"easy\" on a similar level.\\n\\nTo solve it, we will first of all declare a couple of variables:\\n* `currTime` will store the current point in time we are considering a the moment, initialised to be `0`;\\n* `total` will store our ongoing sum of delays and it will be initialised to `0` too.\\n\\nWe will then loop through each item in `customers` and:\\n* update `currTime` to be the higher value between its previous value or the starting point of the client, plus his inherent waiting time;\\n* update `total`, increasing it by `currTime - c[0]` at each iteration.\\n\\nOnce done, we can just return `total / customers.size()`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        // support variables\\n        int currTime = 0;\\n        double total = 0;\\n        // parsing the input\\n        for (auto c: customers) {\\n            // updating currTime and total\\n            currTime = max(currTime, c[0]) + c[1];;\\n            total += currTime - c[0];\\n        }\\n        return total / customers.size();\\n    }\\n};\\n```\\n\\nAlternative version where we convert `total` only at the end and that seems to go marginally faster:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        // support variables\\n        int currTime = 0;\\n        long total = 0;\\n        // parsing the input\\n        for (auto c: customers) {\\n            // updating currTime and total\\n            currTime = max(currTime, c[0]) + c[1];;\\n            total += currTime - c[0];\\n        }\\n        return (double)total / customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        // support variables\\n        int currTime = 0;\\n        double total = 0;\\n        // parsing the input\\n        for (auto c: customers) {\\n            // updating currTime and total\\n            currTime = max(currTime, c[0]) + c[1];;\\n            total += currTime - c[0];\\n        }\\n        return total / customers.size();\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        // support variables\\n        int currTime = 0;\\n        long total = 0;\\n        // parsing the input\\n        for (auto c: customers) {\\n            // updating currTime and total\\n            currTime = max(currTime, c[0]) + c[1];;\\n            total += currTime - c[0];\\n        }\\n        return (double)total / customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987400,
                "title": "simple-java-solution-average-waiting-time",
                "content": "1. Chef start time for a customer i would be maximum of customer arrival time or when the chef is done finishing order of previous order.\\n2. Wait time for a customer is time required for his order to be prepared  + difference of chefStartTime and his arrival time.\\n \\n ```\\n public double averageWaitingTime(int[][] customers) {\\n        double sumWait = 0;\\n        int[] wait = new int[customers.length];\\n        int chefStart = customers[0][0];\\n        \\n        for (int i = 0 ; i < customers.length ; i++) {\\n            if (chefStart < customers[i][0])\\n                chefStart = customers[i][0];\\n            wait[i] =  customers[i][1] + chefStart - customers[i][0] ;\\n            chefStart = customers[i][0] + wait[i];\\n        }\\n        \\n        for (int j = 0 ; j < wait.length ; j++) {\\n            sumWait += wait[j];\\n        }\\n        \\n        return (double) sumWait/wait.length;\\n    }",
                "solutionTags": [],
                "code": "1. Chef start time for a customer i would be maximum of customer arrival time or when the chef is done finishing order of previous order.\\n2. Wait time for a customer is time required for his order to be prepared  + difference of chefStartTime and his arrival time.\\n \\n ```\\n public double averageWaitingTime(int[][] customers) {\\n        double sumWait = 0;\\n        int[] wait = new int[customers.length];\\n        int chefStart = customers[0][0];\\n        \\n        for (int i = 0 ; i < customers.length ; i++) {\\n            if (chefStart < customers[i][0])\\n                chefStart = customers[i][0];\\n            wait[i] =  customers[i][1] + chefStart - customers[i][0] ;\\n            chefStart = customers[i][0] + wait[i];\\n        }\\n        \\n        for (int j = 0 ; j < wait.length ; j++) {\\n            sumWait += wait[j];\\n        }\\n        \\n        return (double) sumWait/wait.length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 987334,
                "title": "simple-elegant",
                "content": "```\\n    public double averageWaitingTime(int[][] cus) {\\n        double wait = 0, t = 1;\\n        for(int i[] :  cus){\\n            t = Math.max(t, i[0]) + i[1];\\n            wait += t - i[0];\\n        }\\n        return wait/cus.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double averageWaitingTime(int[][] cus) {\\n        double wait = 0, t = 1;\\n        for(int i[] :  cus){\\n            t = Math.max(t, i[0]) + i[1];\\n            wait += t - i[0];\\n        }\\n        return wait/cus.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3405243,
                "title": "beginner-friendly-easy-understandable-solution-python-3",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, arr: List[List[int]]) -> float:\\n        a=[[arr[0][0],arr[0][0]+arr[0][1]]]\\n        for i in range(1,len(arr)):\\n            if arr[i][0]>a[-1][1]:\\n                a.append([arr[i][0],arr[i][0]+arr[i][1]])\\n            else:\\n                a.append([a[-1][1],a[-1][1]+arr[i][1]])\\n        s=arr[0][1]\\n        \\n        for i in range(1,len(a)):\\n            s+=abs(arr[i][0]-a[i][1])\\n            \\n        return (s)/len(a)\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, arr: List[List[int]]) -> float:\\n        a=[[arr[0][0],arr[0][0]+arr[0][1]]]\\n        for i in range(1,len(arr)):\\n            if arr[i][0]>a[-1][1]:\\n                a.append([arr[i][0],arr[i][0]+arr[i][1]])\\n            else:\\n                a.append([a[-1][1],a[-1][1]+arr[i][1]])\\n        s=arr[0][1]\\n        \\n        for i in range(1,len(a)):\\n            s+=abs(arr[i][0]-a[i][1])\\n            \\n        return (s)/len(a)\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362965,
                "title": "python-elegant-short-one-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        finish_time = -maxsize\\n        total_wait_time = 0\\n\\n        for time, duration in customers:\\n            if time < finish_time:\\n                total_wait_time += finish_time - time + duration\\n                finish_time += duration\\n            else:\\n                total_wait_time += duration\\n                finish_time = time + duration\\n\\n        return total_wait_time / len(customers)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        finish_time = -maxsize\\n        total_wait_time = 0\\n\\n        for time, duration in customers:\\n            if time < finish_time:\\n                total_wait_time += finish_time - time + duration\\n                finish_time += duration\\n            else:\\n                total_wait_time += duration\\n                finish_time = time + duration\\n\\n        return total_wait_time / len(customers)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909528,
                "title": "operating-system-knowledge-2-ms-runtime",
                "content": "\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] c) {\\n     int n=c.length;\\n     int ct[]=new int[n];\\n     ct[0]=c[0][0]+c[0][1];\\n     for(int i=1;i<n;i++){\\n     ct[i]=ct[i-1]+c[i][1];\\n     if(c[i][0]>ct[i-1]){\\n         ct[i]=c[i][0]+c[i][1];\\n     }\\n     }   \\n      double d=0;\\n     int wt[]=new int[n];\\n     for(int i=0;i<n;i++){\\n         wt[i]=ct[i]-c[i][0];\\n         d+=wt[i];\\n     }\\n     return d/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] c) {\\n     int n=c.length;\\n     int ct[]=new int[n];\\n     ct[0]=c[0][0]+c[0][1];\\n     for(int i=1;i<n;i++){\\n     ct[i]=ct[i-1]+c[i][1];\\n     if(c[i][0]>ct[i-1]){\\n         ct[i]=c[i][0]+c[i][1];\\n     }\\n     }   \\n      double d=0;\\n     int wt[]=new int[n];\\n     for(int i=0;i<n;i++){\\n         wt[i]=ct[i]-c[i][0];\\n         d+=wt[i];\\n     }\\n     return d/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896671,
                "title": "easy-and-readable-solution-using-for-loop-100-both-typescript-js",
                "content": "\\n\\n# Code\\n```\\nfunction averageWaitingTime(customers: number[][]): number {\\n    let startMakingOrder: number = customers[0][0];\\n    let totalWaitingTime: number = 0;\\n    for (let customer of customers){\\n        // let arrived: number = customer[0];\\n        // customer[0] customer arrived\\n        // customer[1] the waiting time for an order for the specific customer to complete\\n        if (customer[0] > startMakingOrder){\\n            startMakingOrder = customer[0] + customer[1];\\n        }else{\\n            startMakingOrder += customer[1];\\n        }\\n        totalWaitingTime += (startMakingOrder-customer[0]);\\n    }\\n    return totalWaitingTime/customers.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction averageWaitingTime(customers: number[][]): number {\\n    let startMakingOrder: number = customers[0][0];\\n    let totalWaitingTime: number = 0;\\n    for (let customer of customers){\\n        // let arrived: number = customer[0];\\n        // customer[0] customer arrived\\n        // customer[1] the waiting time for an order for the specific customer to complete\\n        if (customer[0] > startMakingOrder){\\n            startMakingOrder = customer[0] + customer[1];\\n        }else{\\n            startMakingOrder += customer[1];\\n        }\\n        totalWaitingTime += (startMakingOrder-customer[0]);\\n    }\\n    return totalWaitingTime/customers.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2876576,
                "title": "c-simple-solution",
                "content": "**Solution**\\n\\t\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int startTime , endTime = 0 , n = customers.size();\\n        long sum = 0;\\n        for(auto v : customers){\\n            startTime = max(endTime , v[0]);\\n            endTime = startTime + v[1]; \\n            int waitTime = endTime - v[0];\\n            sum += waitTime;\\n        }\\n        return sum/double(n);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Solution**\\n\\t\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int startTime , endTime = 0 , n = customers.size();\\n        long sum = 0;\\n        for(auto v : customers){\\n            startTime = max(endTime , v[0]);\\n            endTime = startTime + v[1]; \\n            int waitTime = endTime - v[0];\\n            sum += waitTime;\\n        }\\n        return sum/double(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2622788,
                "title": "python-faster-than-98-cleanest-code",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        z=0\\n        coun=0\\n        for x,y in customers:\\n            z=max(x,z)+y\\n            coun+=(z-x)            \\n        return coun/len(customers)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        z=0\\n        coun=0\\n        for x,y in customers:\\n            z=max(x,z)+y\\n            coun+=(z-x)            \\n        return coun/len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371338,
                "title": "c-straight-forward",
                "content": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& matrix) {\\n        \\n        int time = 1;        \\n        vector<int> wt;\\n        \\n        for(int i = 0; i < matrix.size(); i++){\\n            if(time < matrix[i][0]) time = matrix[i][0];\\n            time += matrix[i][1];\\n            wt.push_back(time - matrix[i][0]);\\n        }\\n        \\n        long long avg = 0;\\n        for(int i = 0; i < wt.size(); i++){\\n            avg += wt[i];\\n        }\\n        \\n        return ((1.0 * avg )/ wt.size());        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& matrix) {\\n        \\n        int time = 1;        \\n        vector<int> wt;\\n        \\n        for(int i = 0; i < matrix.size(); i++){\\n            if(time < matrix[i][0]) time = matrix[i][0];\\n            time += matrix[i][1];\\n            wt.push_back(time - matrix[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1966393,
                "title": "c-o-n-solution-small-and-easy-code",
                "content": "class Solution {\\npublic:\\n\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        int chefTime = c[0][0];\\n        double ans = 0;\\n        \\n        for(auto i:c){\\n            if(chefTime < i[0]) chefTime = i[0];\\n            \\n            chefTime += i[1];\\n            ans += chefTime - i[0];\\n        }\\n        \\n        ans = ans/c.size();\\n        return ans;\\n    }\\n\\t\\n\\tvoid if_like(){\\n        cout << \"Hit Up Vote\" << endl;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        int chefTime = c[0][0];\\n        double ans = 0;\\n        \\n        for(auto i:c){\\n            if(chefTime < i[0]) chefTime = i[0];\\n            \\n            chefTime += i[1];\\n            ans += chefTime - i[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1805916,
                "title": "average-waiting-time",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        vector<int>v(customers.size(),0);\\n        if(customers.size()==1){\\n            return customers[0][1];\\n        }\\n        long long int ans=customers[0][0]+customers[0][1];\\n        v[0]=customers[0][1];\\n        long long int total=v[0];\\n        for(int i=1;i<customers.size();i++){\\n              long long int ans1;\\n            if(ans>customers[i][0])\\n            ans1=ans+customers[i][1];\\n            else\\n                ans1=customers[i][0]+customers[i][1];\\n            ans=ans1;\\n            if(ans1<customers[i][0]){\\n                v[i]=customers[i][1];\\n            }\\n            else\\n            v[i]=ans1-customers[i][0];\\n            total+=v[i];\\n        }\\n        return total*(1.0)/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        vector<int>v(customers.size(),0);\\n        if(customers.size()==1){\\n            return customers[0][1];\\n        }\\n        long long int ans=customers[0][0]+customers[0][1];\\n        v[0]=customers[0][1];\\n        long long int total=v[0];\\n        for(int i=1;i<customers.size();i++){\\n              long long int ans1;\\n            if(ans>customers[i][0])\\n            ans1=ans+customers[i][1];\\n            else\\n                ans1=customers[i][0]+customers[i][1];\\n            ans=ans1;\\n            if(ans1<customers[i][0]){\\n                v[i]=customers[i][1];\\n            }\\n            else\\n            v[i]=ans1-customers[i][0];\\n            total+=v[i];\\n        }\\n        return total*(1.0)/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746447,
                "title": "java-simple-implementation",
                "content": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int cur_time = customers[0][0];\\n        double ans = 0;\\n        int n = customers.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(cur_time>=customers[i][0])\\n                cur_time+=customers[i][1];\\n            else\\n                cur_time=(customers[i][0]+customers[i][1]);\\n            ans+=(cur_time-customers[i][0]);\\n            //System.out.println(cur_time);\\n        }\\n        return ans/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int cur_time = customers[0][0];\\n        double ans = 0;\\n        int n = customers.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(cur_time>=customers[i][0])\\n                cur_time+=customers[i][1];\\n            else\\n                cur_time=(customers[i][0]+customers[i][1]);\\n            ans+=(cur_time-customers[i][0]);\\n            //System.out.println(cur_time);\\n        }\\n        return ans/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601356,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        prevFinishTime = customers[0][0] + customers[0][1]\\n        totalWaitTime = customers[0][1]\\n        \\n        for c in customers[1:]:\\n            totalWaitTime += max(prevFinishTime - c[0] + c[1], c[1])\\n            prevFinishTime = max(prevFinishTime + c[1], c[0] + c[1])\\n        \\n        return (totalWaitTime) / len(customers)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        prevFinishTime = customers[0][0] + customers[0][1]\\n        totalWaitTime = customers[0][1]\\n        \\n        for c in customers[1:]:\\n            totalWaitTime += max(prevFinishTime - c[0] + c[1], c[1])\\n            prevFinishTime = max(prevFinishTime + c[1], c[0] + c[1])\\n        \\n        return (totalWaitTime) / len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569787,
                "title": "c-amazing-easy-solution",
                "content": "\\n\\n\\t\\tdouble lasttime = customers[0][0] + customers[0][1];\\n        double count = customers[0][1];\\n        \\n        for(int i = 1 ; i < customers.size() ; i++)\\n        {\\n            if(lasttime > customers[i][0])\\n            {\\n                count += lasttime - customers[i][0] + customers[i][1];\\n                lasttime = lasttime + customers[i][1];\\n            }\\n            else\\n            {\\n                count += customers[i][1];\\n                lasttime = customers[i][0] + customers[i][1];;\\n            }\\n        }\\n        \\n        return count / (customers.size());",
                "solutionTags": [],
                "code": "\\n\\n\\t\\tdouble lasttime = customers[0][0] + customers[0][1];\\n        double count = customers[0][1];\\n        \\n        for(int i = 1 ; i < customers.size() ; i++)\\n        {\\n            if(lasttime > customers[i][0])\\n            {\\n                count += lasttime - customers[i][0] + customers[i][1];\\n                lasttime = lasttime + customers[i][1];\\n            }\\n            else\\n            {\\n                count += customers[i][1];\\n                lasttime = customers[i][0] + customers[i][1];;\\n            }\\n        }\\n        \\n        return count / (customers.size());",
                "codeTag": "Unknown"
            },
            {
                "id": 1566273,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double ans=0;\\n        ans+=(double)customers[0][1];\\n        double finishing_time=(double)customers[0][0]+customers[0][1];\\n        for(int i=1; i<customers.size(); i++){\\n            if(finishing_time > customers[i][0]){\\n                ans+=(double)(finishing_time - customers[i][0]) + customers[i][1];\\n                finishing_time += (double)customers[i][1];\\n            }\\n              else {\\n                  ans+=(double) customers[i][1];\\n                    finishing_time = (double)customers[i][0]  + customers[i][1];\\n              }\\n        }\\n            ans = (double) ans / customers.size();\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double ans=0;\\n        ans+=(double)customers[0][1];\\n        double finishing_time=(double)customers[0][0]+customers[0][1];\\n        for(int i=1; i<customers.size(); i++){\\n            if(finishing_time > customers[i][0]){\\n                ans+=(double)(finishing_time - customers[i][0]) + customers[i][1];\\n                finishing_time += (double)customers[i][1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1396099,
                "title": "java-o-n-easy-solution",
                "content": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int len = customers.length;\\n        int start_time = customers[0][0];\\n        customers[0][1] += customers[0][0];\\n        double diff = customers[0][1]-start_time;\\n        for(int i=1;i<len;i++){\\n            start_time=customers[i][0];\\n            if(customers[i][0]<customers[i-1][1]){\\n                customers[i][0] = customers[i-1][1];\\n            }\\n            customers[i][1] += customers[i][0];\\n            diff += customers[i][1]-start_time;\\n        }\\n        return diff/len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int len = customers.length;\\n        int start_time = customers[0][0];\\n        customers[0][1] += customers[0][0];\\n        double diff = customers[0][1]-start_time;\\n        for(int i=1;i<len;i++){\\n            start_time=customers[i][0];\\n            if(customers[i][0]<customers[i-1][1]){\\n                customers[i][0] = customers[i-1][1];\\n            }\\n            customers[i][1] += customers[i][0];\\n            diff += customers[i][1]-start_time;\\n        }\\n        return diff/len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243745,
                "title": "python3-solution-tc-o-n-and-sc-o-1",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        sum = customers[0][1]\\n        for i in range(1,len(customers)):\\n            \\n            if (customers[i-1][0] + customers[i-1][1]) > customers[i][0]:\\n                customers[i][1] += (customers[i-1][1]+customers[i-1][0] - customers[i][0])\\n  \\n            sum += customers[i][1]\\n        return sum/len(customers)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        sum = customers[0][1]\\n        for i in range(1,len(customers)):\\n            \\n            if (customers[i-1][0] + customers[i-1][1]) > customers[i][0]:\\n                customers[i][1] += (customers[i-1][1]+customers[i-1][0] - customers[i][0])\\n  \\n            sum += customers[i][1]\\n        return sum/len(customers)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201619,
                "title": "simple-100-java-simulation",
                "content": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int customerCount = customers.length;\\n        int[] waitTimes = new int[customerCount];\\n        int timeCurrent = 0;\\n        \\n        for (int i = 0; i < customerCount; i++) {\\n            int arrivalTime = customers[i][0];\\n            int orderPrepTime = customers[i][1];\\n            timeCurrent = Math.max(timeCurrent, arrivalTime);\\n            timeCurrent += orderPrepTime;\\n            waitTimes[i] = timeCurrent - arrivalTime;\\n        }\\n        \\n        double averageWaitTime = 0.0;\\n        for (int waitTime : waitTimes) {\\n            averageWaitTime += (double) waitTime;\\n        }\\n        averageWaitTime /= customerCount;\\n        return averageWaitTime;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int customerCount = customers.length;\\n        int[] waitTimes = new int[customerCount];\\n        int timeCurrent = 0;\\n        \\n        for (int i = 0; i < customerCount; i++) {\\n            int arrivalTime = customers[i][0];\\n            int orderPrepTime = customers[i][1];\\n            timeCurrent = Math.max(timeCurrent, arrivalTime);\\n            timeCurrent += orderPrepTime;\\n            waitTimes[i] = timeCurrent - arrivalTime;\\n        }\\n        \\n        double averageWaitTime = 0.0;\\n        for (int waitTime : waitTimes) {\\n            averageWaitTime += (double) waitTime;\\n        }\\n        averageWaitTime /= customerCount;\\n        return averageWaitTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183852,
                "title": "faster-than-99-c-solution-easy-and-simple",
                "content": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n      double n=customers.size();\\n      double time=customers[0][1];\\n      int complete=customers[0][0]+customers[0][1];\\n      for(int i=1;i<customers.size();i++)\\n      {\\n        if(complete>=customers[i][0])\\n        {\\n          time+=customers[i][1]+(complete-customers[i][0]);\\n          complete+=customers[i][1];\\n        }\\n        else\\n        {\\n           time+=customers[i][1];\\n           complete=customers[i][0]+customers[i][1];\\n        }\\n      }return ((time)/(n));\\n    }\\n};\\n        do upvote if you find it useful............\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n      double n=customers.size();\\n      double time=customers[0][1];\\n      int complete=customers[0][0]+customers[0][1];\\n      for(int i=1;i<customers.size();i++)\\n      {\\n        if(complete>=customers[i][0])\\n        {\\n          time+=customers[i][1]+(complete-customers[i][0]);\\n          complete+=customers[i][1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1181524,
                "title": "easy-python-solution",
                "content": "```\\n\\t\\ttemp = customers[0][1] + customers[0][0]\\n        ans = customers[0][1] \\n        for i in range(1,len(customers)):\\n            if customers[i][0] < temp:\\n                temp += customers[i][1]\\n            else:\\n                temp = customers[i][0]+customers[i][1]\\n            ans += temp - customers[i][0]\\n        return ans/len(customers)\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\ttemp = customers[0][1] + customers[0][0]\\n        ans = customers[0][1] \\n        for i in range(1,len(customers)):\\n            if customers[i][0] < temp:\\n                temp += customers[i][1]\\n            else:\\n                temp = customers[i][0]+customers[i][1]\\n            ans += temp - customers[i][0]\\n        return ans/len(customers)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178683,
                "title": "easy-to-understand-python-with-proper-comments",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        #process the first customer\\n        startTime = customers[0][0]\\n        \\n        #calculate till when the chef will be busy\\n        endTill = startTime + customers[0][1]\\n        \\n        #calculate the waiting time for 1st customer\\n        totalWait =  endTill - startTime\\n        \\n        #iterate from the 2nd customer\\n        for cus in customers[1:]:\\n            startTime = cus[0]\\n            \\n            #check if chef is busy or free\\n            if startTime <= endTill:\\n                endTill += cus[1]\\n                totalWait = totalWait + endTill - startTime\\n            else:\\n                endTill = startTime + cus[1]\\n                totalWait += cus[1]\\n        \\n        return totalWait / len(customers)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        #process the first customer\\n        startTime = customers[0][0]\\n        \\n        #calculate till when the chef will be busy\\n        endTill = startTime + customers[0][1]\\n        \\n        #calculate the waiting time for 1st customer\\n        totalWait =  endTill - startTime\\n        \\n        #iterate from the 2nd customer\\n        for cus in customers[1:]:\\n            startTime = cus[0]\\n            \\n            #check if chef is busy or free\\n            if startTime <= endTill:\\n                endTill += cus[1]\\n                totalWait = totalWait + endTill - startTime\\n            else:\\n                endTill = startTime + cus[1]\\n                totalWait += cus[1]\\n        \\n        return totalWait / len(customers)",
                "codeTag": "Java"
            },
            {
                "id": 1059891,
                "title": "python-3-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        total_wait = customers[0][1]\\n        wait_temp = sum(customers[0])\\n        for i in customers[1:]:\\n            if i[0] >= wait_temp:\\n                wait_temp = sum(customers[customers.index(i)])\\n                total_wait += i[1]\\n            else:\\n                wait_temp += i[1]\\n                total_wait += wait_temp - i[0]\\n        return total_wait/len(customers)\\n```\\n* ```total_wait``` is the total wait time of all customers. \\n* ```wait_temp``` is the wait time after each customer\\'s order gets ready.\\n* The approach is to subtract each customer\\'s arrival time from the ```wait_temp``` in that iteration to find how long the customer waited altogether till his order arrived.\\n\\nTwo situations are possible:\\n1) A customer B arrives during the time when the previous customer A\\'s order is being made:\\n* Here, we have to add the \\'extra time\\' that B has to wait until A\\'s order is ready, and then add his own time to ```total_wait```\\n2) A customer B arrives after the previous customer A\\'s order is ready:\\n* Now, the customer B does not have to wait any extra time, because when he arrives at the restaurant, no other orders are being made.\\n* Hence, I\\'m setting the ```wait_temp``` to be the time taken for B\\'s order only (because now, we can treat the situation as a sub-problem wherein customer B is the first customer of the restaurant), and then the process of calculation is the same as we had started off with.\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        total_wait = customers[0][1]\\n        wait_temp = sum(customers[0])\\n        for i in customers[1:]:\\n            if i[0] >= wait_temp:\\n                wait_temp = sum(customers[customers.index(i)])\\n                total_wait += i[1]\\n            else:\\n                wait_temp += i[1]\\n                total_wait += wait_temp - i[0]\\n        return total_wait/len(customers)\\n```\n```total_wait```\n```wait_temp```\n```wait_temp```\n```total_wait```\n```wait_temp```",
                "codeTag": "Java"
            },
            {
                "id": 1047160,
                "title": "easy-python-high-speed-o-1-space-complexity",
                "content": "**Easy Python | High Speed | O(1) Space Complexity**\\n\\n```\\nclass Solution:\\n    def averageWaitingTime(self, A):\\n        \\n        x    =  0\\n        res  =  0\\n        \\n        for a,t in A:\\n            x     =  max(x,a) + t\\n            res  +=  x - a\\n        \\n        return res/float(len(A))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, A):\\n        \\n        x    =  0\\n        res  =  0\\n        \\n        for a,t in A:\\n            x     =  max(x,a) + t\\n            res  +=  x - a\\n        \\n        return res/float(len(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015846,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} customers\\n * @return {number}\\n */\\nvar averageWaitingTime = function(customers) {\\n    let waitingTimes = 0;\\n    let time = customers[0][0];\\n\\n    customers.forEach((c) => {\\n\\t\\t// Handle the case where the customer arrives and \\n\\t   // after the last order was completed\\n        if(c[0] > time) {\\n            time = c[0];\\n        } \\n\\t\\t\\n\\t\\t// Advance time to when the order is completed\\n        time+=c[1];   \\n\\t\\t\\n\\t\\t// Keep running total of the waiting times\\n        waitingTimes+=(time-c[0]); \\n    })\\n\\n    return waitingTimes / customers.length;\\n};\\n\\n\\n// Runtime: 156 ms (Beats 83.23 % of Javascript submissions )\\n// Memory Usage: 63.9 MB ( Beats 37.89 % of javascript submissions )\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} customers\\n * @return {number}\\n */\\nvar averageWaitingTime = function(customers) {\\n    let waitingTimes = 0;\\n    let time = customers[0][0];\\n\\n    customers.forEach((c) => {\\n\\t\\t// Handle the case where the customer arrives and \\n\\t   // after the last order was completed\\n        if(c[0] > time) {\\n            time = c[0];\\n        } \\n\\t\\t\\n\\t\\t// Advance time to when the order is completed\\n        time+=c[1];   \\n\\t\\t\\n\\t\\t// Keep running total of the waiting times\\n        waitingTimes+=(time-c[0]); \\n    })\\n\\n    return waitingTimes / customers.length;\\n};\\n\\n\\n// Runtime: 156 ms (Beats 83.23 % of Javascript submissions )\\n// Memory Usage: 63.9 MB ( Beats 37.89 % of javascript submissions )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005203,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        arrival = customers[0][0]\\n        time = customers[0][1]\\n        tt = arrival + time\\n        avg = tt - arrival\\n        for i in range(1, len(customers)):\\n            if tt > customers[i][0]:\\n                tt += customers[i][1]\\n                avg += tt - customers[i][0]\\n            else: \\n                avg += customers[i][1]\\n                tt = customers[i][0] + customers[i][1]\\n        return avg/len(customers)\\n```\\nFor more questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        arrival = customers[0][0]\\n        time = customers[0][1]\\n        tt = arrival + time\\n        avg = tt - arrival\\n        for i in range(1, len(customers)):\\n            if tt > customers[i][0]:\\n                tt += customers[i][1]\\n                avg += tt - customers[i][0]\\n            else: \\n                avg += customers[i][1]\\n                tt = customers[i][0] + customers[i][1]\\n        return avg/len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991046,
                "title": "simple-c",
                "content": "```\\npublic class Solution \\n{\\n    public double AverageWaitingTime(int[][] customers) \\n    {\\n        int end = 0;\\n        double averageWaitingTime = 0;\\n        \\n        for (int i=0; i<customers.Length; i++)\\n        {\\n            int arrival = customers[i][0], timeToCook = customers[i][1];\\n            \\n            if (end < arrival) end = arrival + timeToCook;\\n            else end += timeToCook;\\n            \\n            averageWaitingTime += (end-arrival);\\n        }\\n        \\n        return (averageWaitingTime)/customers.Length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public double AverageWaitingTime(int[][] customers) \\n    {\\n        int end = 0;\\n        double averageWaitingTime = 0;\\n        \\n        for (int i=0; i<customers.Length; i++)\\n        {\\n            int arrival = customers[i][0], timeToCook = customers[i][1];\\n            \\n            if (end < arrival) end = arrival + timeToCook;\\n            else end += timeToCook;\\n            \\n            averageWaitingTime += (end-arrival);\\n        }\\n        \\n        return (averageWaitingTime)/customers.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988907,
                "title": "c-easy-solution-o-n-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& v) {\\n        int n= v.size();\\n        \\n        long long int time1=0;\\n        long long int ang=0;\\n        time1=v[0][0]+v[0][1];\\n        ang+=time1-v[0][0];\\n        for(int i=1;i<n;i++){\\n           \\n            if(time1>v[i][0])\\n            {\\n            time1+=v[i][1];\\n            ang+=(time1-v[i][0]);\\n            }\\n            else{\\n                \\n                ang+=v[i][1];\\n                time1=v[i][0]+v[i][1];\\n            } \\n           \\n        }\\n        long double g=ang/(n*1.0);\\n        return g;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& v) {\\n        int n= v.size();\\n        \\n        long long int time1=0;\\n        long long int ang=0;\\n        time1=v[0][0]+v[0][1];\\n        ang+=time1-v[0][0];\\n        for(int i=1;i<n;i++){\\n           \\n            if(time1>v[i][0])\\n            {\\n            time1+=v[i][1];\\n            ang+=(time1-v[i][0]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 988510,
                "title": "java-simple-o-n-time-and-o-1-space",
                "content": "```\\n    public double averageWaitingTime(int[][] customers) {\\n        double queue = 0, sum = 0;  //queue is current finish time in queue, sum is the total wait time;\\n        for (int[] c : customers) {\\n            if (queue <= c[0]) queue = c[0];  // if nobody waiting;\\n            queue += c[1];  // added to waiting queue;\\n            sum += queue - c[0];  // the wait time for this customer;\\n        }\\n        return customers.length == 0 ? 0 : sum / customers.length;  // avoid divide by zero exception.\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public double averageWaitingTime(int[][] customers) {\\n        double queue = 0, sum = 0;  //queue is current finish time in queue, sum is the total wait time;\\n        for (int[] c : customers) {\\n            if (queue <= c[0]) queue = c[0];  // if nobody waiting;\\n            queue += c[1];  // added to waiting queue;\\n            sum += queue - c[0];  // the wait time for this customer;\\n        }\\n        return customers.length == 0 ? 0 : sum / customers.length;  // avoid divide by zero exception.\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987672,
                "title": "javascript-100",
                "content": "```\\nvar averageWaitingTime = function(customers) {\\n    \\n    let ended = customers[0][0]+customers[0][1]\\n    let sum=customers[0][1]\\n    let waited = customers[0][1]\\n    \\n    for(let i=1; i<customers.length; i++){\\n        if (ended <= customers[i][0]){\\n            waited = customers[i][1]\\n            ended = customers[i][0]+customers[i][1]            \\n            sum += waited\\n            \\n        } else {\\n            waited = ended - customers[i][0] + customers[i][1]\\n            ended = ended + customers[i][1]\\n            sum += waited\\n        }  \\n    }\\n    return sum / customers.length\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar averageWaitingTime = function(customers) {\\n    \\n    let ended = customers[0][0]+customers[0][1]\\n    let sum=customers[0][1]\\n    let waited = customers[0][1]\\n    \\n    for(let i=1; i<customers.length; i++){\\n        if (ended <= customers[i][0]){\\n            waited = customers[i][1]\\n            ended = customers[i][0]+customers[i][1]            \\n            sum += waited\\n            \\n        } else {\\n            waited = ended - customers[i][0] + customers[i][1]\\n            ended = ended + customers[i][1]\\n            sum += waited\\n        }  \\n    }\\n    return sum / customers.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987482,
                "title": "simple-c-solution-easy",
                "content": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        double sum = customers[0][0]+customers[0][1]; \\n         vector<double> waiting_array;\\n        waiting_array.push_back(customers[0][1]);\\n        double res;\\n       \\n        \\n        \\n        for(int i=1;i<customers.size();i++)\\n        {   \\n            \\n            \\n            \\n            if(customers[i][0]>sum)\\n            {\\n                sum=customers[i][0]+customers[i][1];\\n                waiting_array.push_back(customers[i][1]);\\n            }\\n                \\n                   else\\n                   {  sum=sum+customers[i][1];    \\n                    waiting_array.push_back(sum-customers[i][0]); }\\n            \\n            \\n        }\\n        \\n        sum=0;\\n        double n=waiting_array.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=waiting_array[i];\\n        }\\n        \\n        res= (double)sum/(double)n;\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        double sum = customers[0][0]+customers[0][1]; \\n         vector<double> waiting_array;\\n        waiting_array.push_back(customers[0][1]);\\n        double res;\\n       \\n        \\n        \\n        for(int i=1;i<customers.size();i++)\\n        {   \\n            \\n            \\n            \\n            if(customers[i][0]>sum)\\n            {\\n                sum=customers[i][0]+customers[i][1];\\n                waiting_array.push_back(customers[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 987395,
                "title": "easy-c",
                "content": "The solution require track of current time and wait time. \\n  \\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int i,n = customers.size();\\n        double waitTime = customers[0][1];\\n        int timeNow = customers[0][0] + waitTime;\\n        for(i=1; i<n; i++){\\n          if(customers[i][0] < timeNow)\\n            waitTime += (timeNow - customers[i][0]);\\n          else\\n            timeNow = customers[i][0];\\n          waitTime += customers[i][1];\\n          timeNow += customers[i][1];\\n        }\\n      double avgTime = waitTime/n; \\n      return avgTime;\\n    }",
                "solutionTags": [],
                "code": "The solution require track of current time and wait time. \\n  \\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int i,n = customers.size();\\n        double waitTime = customers[0][1];\\n        int timeNow = customers[0][0] + waitTime;\\n        for(i=1; i<n; i++){\\n          if(customers[i][0] < timeNow)\\n            waitTime += (timeNow - customers[i][0]);\\n          else\\n            timeNow = customers[i][0];\\n          waitTime += customers[i][1];\\n          timeNow += customers[i][1];\\n        }\\n      double avgTime = waitTime/n; \\n      return avgTime;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 987356,
                "title": "easy-python-solution-o-n",
                "content": "Problem is very easy to understand. We need to maintain Chef\\'s timeline to solve this problem.\\n\\n```\\ndef averageWaitingTime(customers):\\n        chef_timeline = 0\\n        waiting_time = 0\\n        \\n        for customer in customers:\\n            if chef_timeline < customer[0]:\\n                chef_timeline = customer[0]\\n            \\n            waiting_time += chef_timeline - customer[0] + customer[1]\\n            chef_timeline += customer[1]\\n            \\n        return waiting_time*1.0 / len(customers)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef averageWaitingTime(customers):\\n        chef_timeline = 0\\n        waiting_time = 0\\n        \\n        for customer in customers:\\n            if chef_timeline < customer[0]:\\n                chef_timeline = customer[0]\\n            \\n            waiting_time += chef_timeline - customer[0] + customer[1]\\n            chef_timeline += customer[1]\\n            \\n        return waiting_time*1.0 / len(customers)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 987343,
                "title": "java-simple-self-explanatory-code",
                "content": "```\\npublic double averageWaitingTime(int[][] customers) {\\n        if(customers.length == 0){\\n            return 0.0;\\n        }\\n        double ans=0;\\n        int start = customers[0][0];\\n        int end = start;\\n        for(int[] cus:customers){\\n            if(cus[0]<end){\\n            start = cus[0];\\n            end += cus[1];\\n            ans+=(end-start);}\\n            else{\\n                ans+=(cus[1]);\\n                end=(cus[0]+cus[1]);\\n            }\\n        }\\n        return ans/customers.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double averageWaitingTime(int[][] customers) {\\n        if(customers.length == 0){\\n            return 0.0;\\n        }\\n        double ans=0;\\n        int start = customers[0][0];\\n        int end = start;\\n        for(int[] cus:customers){\\n            if(cus[0]<end){\\n            start = cus[0];\\n            end += cus[1];\\n            ans+=(end-start);}\\n            else{\\n                ans+=(cus[1]);\\n                end=(cus[0]+cus[1]);\\n            }\\n        }\\n        return ans/customers.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987309,
                "title": "kt-js-py3-cpp-average-wait-time",
                "content": "**Synopsis:**\\n\\nTrack each customer\\'s wait time based upon the `last` customer\\'s job completion time and the current customer\\'s job start time `i` and job length `j`.  Return the average wait time, ie. the accumulated sum of `wait` times divided by the cardinality of the `wait` times.\\n\\n---\\n\\n**Bi-Weekly Contest 42 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/39e17532-4994-4600-9fbc-baf4a2585828_1609000229.6503932.png)\\n\\nhttps://www.youtube.com/watch?v=h5V7ybR-vps\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun averageWaitingTime(A: Array<IntArray>): Double {\\n        var time = 0\\n        var last = 0\\n        var wait = mutableListOf<Double>()\\n        A.forEach { (i, j) ->\\n            time = Math.max(i, last)\\n            last = time + j\\n            wait.add(last - i.toDouble())\\n        }\\n        return wait.sum() / wait.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet averageWaitingTime = (A, time = 0, last = 0, wait = []) => {\\n    for (let [i, j] of A) {\\n        time = Math.max(i, last);\\n        last = time + j;\\n        wait.push(last - i);\\n    }\\n    return _.sum(wait) / wait.length;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def averageWaitingTime(self, A: List[List[int]], time = 0, last = 0) -> float:\\n        wait = []\\n        for i, j in A:\\n            time = max(i, last)\\n            last = time + j\\n            wait.append(last - i)\\n        return sum(wait) / len(wait)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    double averageWaitingTime(VVI& A, int time = 0, int last = 0, VI wait = {}) {\\n        for (auto& customer: A) {\\n            auto [i, j] = tie(customer[0], customer[1]);\\n            time = max(i, last);\\n            last = time + j;\\n            wait.push_back(last - i);\\n        }\\n        return accumulate(wait.begin(), wait.end(), 0.0) / wait.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun averageWaitingTime(A: Array<IntArray>): Double {\\n        var time = 0\\n        var last = 0\\n        var wait = mutableListOf<Double>()\\n        A.forEach { (i, j) ->\\n            time = Math.max(i, last)\\n            last = time + j\\n            wait.add(last - i.toDouble())\\n        }\\n        return wait.sum() / wait.size\\n    }\\n}\\n```\n```\\nlet averageWaitingTime = (A, time = 0, last = 0, wait = []) => {\\n    for (let [i, j] of A) {\\n        time = Math.max(i, last);\\n        last = time + j;\\n        wait.push(last - i);\\n    }\\n    return _.sum(wait) / wait.length;\\n};\\n```\n```\\nclass Solution:\\n    def averageWaitingTime(self, A: List[List[int]], time = 0, last = 0) -> float:\\n        wait = []\\n        for i, j in A:\\n            time = max(i, last)\\n            last = time + j\\n            wait.append(last - i)\\n        return sum(wait) / len(wait)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    double averageWaitingTime(VVI& A, int time = 0, int last = 0, VI wait = {}) {\\n        for (auto& customer: A) {\\n            auto [i, j] = tie(customer[0], customer[1]);\\n            time = max(i, last);\\n            last = time + j;\\n            wait.push_back(last - i);\\n        }\\n        return accumulate(wait.begin(), wait.end(), 0.0) / wait.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106471,
                "title": "simple-and-clear-python3-solution-1-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        n = len(customers)\\n        result = 0\\n\\n        current_time = 0\\n        for arrival, time in customers:\\n            if current_time <= arrival:\\n                result += time\\n                current_time = arrival + time\\n            else:\\n                result += (current_time - arrival) + time\\n                current_time += time\\n        \\n        return result / n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Simulation"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        n = len(customers)\\n        result = 0\\n\\n        current_time = 0\\n        for arrival, time in customers:\\n            if current_time <= arrival:\\n                result += time\\n                current_time = arrival + time\\n            else:\\n                result += (current_time - arrival) + time\\n                current_time += time\\n        \\n        return result / n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074439,
                "title": "easy-short-o-n-c-solution",
                "content": "# Approach\\nWe will keep track of the time the previous customer ended through prevEndTime variable declared prior to traversal. We will update this in each iteration.\\n\\nFor each customer:\\n1) Calculate the time taken for a customer which should be time time taken to prepare his food + any waiting time.\\nWe can break down \"waiting time\":\\nthe wait time of customer i = end time of previous customer - entry time of customer i.\\nNote that if there is no overlap between when the previous customer finishes and this new customer starts, this wait time will be negative.\\nSo we can write wait time of i = food prep time[i] + max (0, prevEndTime - startTime[i]);\\nWe can add this to the total wait time variable, which is used just for the average.\\n\\n2) Set prevEndTime = startTime + waitTime.\\n\\nReturn total wait time / number of customers.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1) auxiliary space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int prevEndTime = 0;\\n        double totalTimeWaited = 0;\\n        for (int i = 0; i < customers.size(); ++i)\\n        {\\n            // If there is an overlap between last customer\\'s end time and i\\'s start time, add that \\n            // overlap to wait time of i.\\n            int startTime = customers[i][0];\\n            int timeWaited = customers[i][1] + max (0, prevEndTime - startTime);\\n            // Set previous end time for next customer to the time when i finishes.\\n            prevEndTime = startTime + timeWaited;\\n            totalTimeWaited += timeWaited;\\n        }\\n        return totalTimeWaited/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int prevEndTime = 0;\\n        double totalTimeWaited = 0;\\n        for (int i = 0; i < customers.size(); ++i)\\n        {\\n            // If there is an overlap between last customer\\'s end time and i\\'s start time, add that \\n            // overlap to wait time of i.\\n            int startTime = customers[i][0];\\n            int timeWaited = customers[i][1] + max (0, prevEndTime - startTime);\\n            // Set previous end time for next customer to the time when i finishes.\\n            prevEndTime = startTime + timeWaited;\\n            totalTimeWaited += timeWaited;\\n        }\\n        return totalTimeWaited/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058690,
                "title": "c-easy-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& cust) {\\n        double sum=0;\\n         int timetaken=cust[0][0]+cust[0][1];\\n         int prevtime=timetaken;\\n         sum=prevtime-cust[0][0];\\n        prevtime=timetaken;\\n       // cout<<sum<<\" \";\\n        int sz=cust.size();\\n         for(int i=1;i<cust.size();i++) \\n          {\\n            \\n                  \\n                   if(prevtime<cust[i][0])\\n                       prevtime=cust[i][0];\\n              //timetaken=cust[i][0]+cust[i][1];\\n                prevtime=prevtime+(cust[i][1]);\\n                // cout<<prevtime<<\" \";\\n             //   cout<<prevtime<<\" \";\\n              int t=(prevtime-cust[i][0]);\\n                //prevtime=timetaken;\\n                sum+=t;\\n              cout<<t<<\" \";\\n          }\\n        double res=(sum*1.0)/sz;\\n           return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& cust) {\\n        double sum=0;\\n         int timetaken=cust[0][0]+cust[0][1];\\n         int prevtime=timetaken;\\n         sum=prevtime-cust[0][0];\\n        prevtime=timetaken;\\n       // cout<<sum<<\" \";\\n        int sz=cust.size();\\n         for(int i=1;i<cust.size();i++) \\n          {\\n            \\n                  \\n                   if(prevtime<cust[i][0])\\n                       prevtime=cust[i][0];\\n              //timetaken=cust[i][0]+cust[i][1];\\n                prevtime=prevtime+(cust[i][1]);\\n                // cout<<prevtime<<\" \";\\n             //   cout<<prevtime<<\" \";\\n              int t=(prevtime-cust[i][0]);\\n                //prevtime=timetaken;\\n                sum+=t;\\n              cout<<t<<\" \";\\n          }\\n        double res=(sum*1.0)/sz;\\n           return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4049081,
                "title": "easy-to-understand-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to first focus on finding just how long each customer is waiting. \\nThe logical way to think of it is to see what time they finished getting their order and subtract that by when they got there. \\nTo find when they finished getting their order, it firsts starts with the initilize time the order gets started plus the length of how long it will take to complete the order. Then we subtract the time they came to find the total time waited. \\n\\nMost of the time the chef can be busy, and since the chef can only do one order at a time, the times may overlap, hence why we must take into account when the CHEF is ready to start the order, and not when the CUSTOMER is ready to order. \\n\\nSometimes business might be slow and the chef may have no orders to do, in those cases, the arrival time of the guest is GREATER than the time the chef is ready to start the next order. \\nFor example, the chef may finish an order at time 10 but not have any customers until time 15 therefore in these scenarios, the next customer only has to wait the total length of their order, without worrying about any preceeding customer wait times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst start off by initiizing the start of the first order, which will be when the first customer arrives. \\nThen initilize a sum variable in which we will add the total wait times for each customer.\\nNow we start a for loop, to iterate through the matrix. We only need a single loop since we already know there are only two possible indexes for the \"columns\" of the matrix. \\nin the loop we can store the arrival time of the current guest and the length of their order.\\nThen we will make an if statement to see if the chef is free right now or not. If the chef is available to start the order BEFORE the arrival of the next guest, then we will go inside of the for loop where:\\n\\nWe simply add the order length into our sum vairable and set the start order variable to whenever chef finishes this order.\\n\\nIn the else portion:\\nWe will find out what time the chef will finish the current order by adding the next available time chef can start the order (startOrder) to the total amount of time it takes to complete the order.\\nThen we subtract this final time finished by what time the guests arrived to find the total time they had to wait.\\nThen we set the startOrder variable to the time chef finished the current order, as that is the next available time chef is to start the next order, and add on the time waited for the customer to the sum variable.\\n\\nFinally we divide the sum by total number of customers to find the answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        \\n\\n\\n        // time finished = start preparing order time + order length in time \\n        //time waited = time finished - arrival time\\n        int startOrder = customers[0][0]; \\n        double sum = 0;\\n        for(int i = 0; i< customers.length; i++){\\n            int arrivalTime = customers[i][0]; \\n            int orderLength = customers[i][1]; \\n            if(startOrder < arrivalTime){\\n                sum+= orderLength;\\n                startOrder = arrivalTime + orderLength;;\\n\\n            }\\n            else{\\n            int timeFinished = startOrder + orderLength; \\n            int timeWaited = timeFinished - arrivalTime; \\n            startOrder = timeFinished; \\n            \\n            sum += timeWaited; \\n            }\\n        }\\n        double ans = sum / customers.length;\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        \\n\\n\\n        // time finished = start preparing order time + order length in time \\n        //time waited = time finished - arrival time\\n        int startOrder = customers[0][0]; \\n        double sum = 0;\\n        for(int i = 0; i< customers.length; i++){\\n            int arrivalTime = customers[i][0]; \\n            int orderLength = customers[i][1]; \\n            if(startOrder < arrivalTime){\\n                sum+= orderLength;\\n                startOrder = arrivalTime + orderLength;;\\n\\n            }\\n            else{\\n            int timeFinished = startOrder + orderLength; \\n            int timeWaited = timeFinished - arrivalTime; \\n            startOrder = timeFinished; \\n            \\n            sum += timeWaited; \\n            }\\n        }\\n        double ans = sum / customers.length;\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042680,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  double averageWaitingTime(List<List<int>> customers) {\\n      var endingTime = customers[0][0] + customers[0][1];\\n      var totalTime = customers[0][1];\\n      var prevEnding = endingTime;\\n      for (int i = 1; i < customers.length; i++) {\\n          if (prevEnding >= customers[i][0]) {\\n            endingTime = prevEnding + customers[i][1];\\n            totalTime += (prevEnding - customers[i][0]) + customers[i][1];\\n            prevEnding = endingTime;\\n          } else {\\n            endingTime = customers[i][0] + customers[i][1];\\n            totalTime += (customers[i][1]);\\n            prevEnding = endingTime;\\n          }\\n\\n      }\\n      return totalTime / customers.length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  double averageWaitingTime(List<List<int>> customers) {\\n      var endingTime = customers[0][0] + customers[0][1];\\n      var totalTime = customers[0][1];\\n      var prevEnding = endingTime;\\n      for (int i = 1; i < customers.length; i++) {\\n          if (prevEnding >= customers[i][0]) {\\n            endingTime = prevEnding + customers[i][1];\\n            totalTime += (prevEnding - customers[i][0]) + customers[i][1];\\n            prevEnding = endingTime;\\n          } else {\\n            endingTime = customers[i][0] + customers[i][1];\\n            totalTime += (customers[i][1]);\\n            prevEnding = endingTime;\\n          }\\n\\n      }\\n      return totalTime / customers.length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030415,
                "title": "java-short-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double end = 0 , res= 0  ;\\n        for( var el : customers){\\n            if( el[0] > end) end = el[0];\\n            end = end + el[1];\\n            res = res + (end - el[0]);\\n        }\\n        return res  /  customers.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double end = 0 , res= 0  ;\\n        for( var el : customers){\\n            if( el[0] > end) end = el[0];\\n            end = end + el[1];\\n            res = res + (end - el[0]);\\n        }\\n        return res  /  customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016979,
                "title": "average-waiting-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int runtime =0;\\n        double ans = 0;\\n        for(int i=0;i<customers.length;i++)\\n        {\\n            runtime = Math.max(runtime,customers[i][0])+customers[i][1];\\n            ans = ans+runtime-customers[i][0];\\n            System.out.print(ans+\" \");\\n        }\\n        return ans/customers.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int runtime =0;\\n        double ans = 0;\\n        for(int i=0;i<customers.length;i++)\\n        {\\n            runtime = Math.max(runtime,customers[i][0])+customers[i][1];\\n            ans = ans+runtime-customers[i][0];\\n            System.out.print(ans+\" \");\\n        }\\n        return ans/customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003986,
                "title": "python-very-easy-and-intiutive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        last=-1\\n        n=len(customers)\\n\\n        total=0\\n        for customer in customers:\\n\\n            cur=customer[0]+customer[1]\\n            cur+=max(last-customer[0], 0)\\n            total+=cur-customer[0]\\n            last=cur\\n        \\n        return (total/n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        last=-1\\n        n=len(customers)\\n\\n        total=0\\n        for customer in customers:\\n\\n            cur=customer[0]+customer[1]\\n            cur+=max(last-customer[0], 0)\\n            total+=cur-customer[0]\\n            last=cur\\n        \\n        return (total/n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956864,
                "title": "c-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int t = 0;\\n        double sum = 0;\\n        for (auto& v : customers){\\n            sum += t <= v[0] ? v[1] : v[1] + t - v[0];\\n            t = max(t + v[1], v[0] + v[1]);\\n        }\\n        return sum /= customers.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int t = 0;\\n        double sum = 0;\\n        for (auto& v : customers){\\n            sum += t <= v[0] ? v[1] : v[1] + t - v[0];\\n            t = max(t + v[1], v[0] + v[1]);\\n        }\\n        return sum /= customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950448,
                "title": "beginer-friendly-classical-simulation-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntime means time stamp. wait mean total waiting time.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int[][] nums = customers;\\n        double time = customers[0][1] + customers[0][0];\\n        double wait = customers[0][1];\\n\\n        for (int i = 1; i < nums.length; i++){\\n            if (nums[i][0] < time){\\n                wait += time - nums[i][0];\\n            }\\n            else{\\n                time += nums[i][0] - time;\\n            }\\n            wait += nums[i][1];\\n\\n            time += nums[i][1];\\n        }\\n        return (wait / nums.length);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "class Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int[][] nums = customers;\\n        double time = customers[0][1] + customers[0][0];\\n        double wait = customers[0][1];\\n\\n        for (int i = 1; i < nums.length; i++){\\n            if (nums[i][0] < time){\\n                wait += time - nums[i][0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3947954,
                "title": "java-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] c) {\\n        long timeOrderFinishes = c[0][0], timeWaited = 0;\\n        for (int i = 0; i < c.length; i++) {\\n            int ar = c[i][0], t = c[i][1];\\n            if (ar > timeOrderFinishes) timeOrderFinishes = ar;\\n            timeOrderFinishes += t;\\n            timeWaited += Math.max(timeOrderFinishes - ar, 0);\\n        }\\n        return 1.0 * timeWaited / c.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] c) {\\n        long timeOrderFinishes = c[0][0], timeWaited = 0;\\n        for (int i = 0; i < c.length; i++) {\\n            int ar = c[i][0], t = c[i][1];\\n            if (ar > timeOrderFinishes) timeOrderFinishes = ar;\\n            timeOrderFinishes += t;\\n            timeWaited += Math.max(timeOrderFinishes - ar, 0);\\n        }\\n        return 1.0 * timeWaited / c.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941215,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the completion time.\\nWaiting time = completion time-arrival time;\\nComputer the average\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int completion[]=new int[customers.length];\\n        completion[0]=customers[0][0]+customers[0][1];\\n        for(int i=1;i<customers.length;i++)\\n        {\\n            if(customers[i][0]<completion[i-1])\\n            {\\n                completion[i]=completion[i-1]+customers[i][1];\\n            }\\n            else{\\n                completion[i]=customers[i][0]+customers[i][1];\\n            }\\n        }\\n        \\n        double avg=0.0;\\n        for(int j=0;j<customers.length;j++)\\n        {\\n            avg+=completion[j]-customers[j][0];\\n        }\\n\\n        return avg/(double)(customers.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int completion[]=new int[customers.length];\\n        completion[0]=customers[0][0]+customers[0][1];\\n        for(int i=1;i<customers.length;i++)\\n        {\\n            if(customers[i][0]<completion[i-1])\\n            {\\n                completion[i]=completion[i-1]+customers[i][1];\\n            }\\n            else{\\n                completion[i]=customers[i][0]+customers[i][1];\\n            }\\n        }\\n        \\n        double avg=0.0;\\n        for(int j=0;j<customers.length;j++)\\n        {\\n            avg+=completion[j]-customers[j][0];\\n        }\\n\\n        return avg/(double)(customers.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921723,
                "title": "python-5-lines-simple-o-n-greedy",
                "content": "# Intuition\\nSince they are already sorted, for every customer it is enough to find maximum of last time reached and arrival plus time for processing, wait time is diference between those.\\nThis si kind of greedy simulation.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers):        \\n        wait = curr_time = 0\\n        for a, t in customers:\\n            curr_time = max(curr_time, a) + t\\n            wait += curr_time - a        \\n        return wait / len(customers)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers):        \\n        wait = curr_time = 0\\n        for a, t in customers:\\n            curr_time = max(curr_time, a) + t\\n            wait += curr_time - a        \\n        return wait / len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892454,
                "title": "simple-solution-one-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double c=0;\\n        int lt=0;\\n        for(auto x:customers){\\n            if(lt<x[0]){\\n                c=c+x[1];\\n                lt=x[0]+x[1];\\n            }\\n            else{\\n                lt=lt+x[1];\\n                c=c+lt-x[0];\\n            }\\n        }\\n        return c/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double c=0;\\n        int lt=0;\\n        for(auto x:customers){\\n            if(lt<x[0]){\\n                c=c+x[1];\\n                lt=x[0]+x[1];\\n            }\\n            else{\\n                lt=lt+x[1];\\n                c=c+lt-x[0];\\n            }\\n        }\\n        return c/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875191,
                "title": "basic-solution-using-os-concept",
                "content": "Consider variable t to be the time currently and waitingTime is the sum of all the times that each customer waits. Initially, the time will be the sum of the arrival time of the customer and the time taken for the chef to finish the order. The waitingTime will be the customer\\'s arrival time subtracted from the time.\\n\\nFor the next customers, the time will be the sum of the previous time and the next customer\\'s order preparation time. The waiting time will be similar to the initial case.\\n\\nIn the exceptional case that the time is less than the next customer\\'s arrival time (the customer has not arrived yet) , then change time to accomodate it.\\n\\nBasically, this is an implementation of the **FCFS scheduling algorithm in OS** where the customer\\'s arrival time is the arrival time and the preparation time for the order is the burst time.\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        int t = customers[0][0] + customers[0][1];\\n        double waitingTime = (double)t - (double)customers[0][0];\\n        for(int i = 1; i<n; i++) {\\n            if(t<customers[i][0]) {\\n                t = customers[i][0];\\n            }\\n            t += customers[i][1];\\n            waitingTime += (double)(t-customers[i][0]);\\n        }\\n        return waitingTime/(double)n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        int t = customers[0][0] + customers[0][1];\\n        double waitingTime = (double)t - (double)customers[0][0];\\n        for(int i = 1; i<n; i++) {\\n            if(t<customers[i][0]) {\\n                t = customers[i][0];\\n            }\\n            t += customers[i][1];\\n            waitingTime += (double)(t-customers[i][0]);\\n        }\\n        return waitingTime/(double)n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872687,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] arr){\\n\\n        long t = arr[0][0]+arr[0][1];\\n\\n        int n = arr.length;\\n        long ans = arr[0][1];\\n\\n        for(int i=1; i<n; i++){\\n            if((long)arr[i][0]<t){\\n                ans+=(long)arr[i][1]+t-(long)arr[i][0];\\n                t=t+(long)arr[i][1];\\n            }\\n            else{\\n                t=(long)arr[i][0]+(long)arr[i][1];\\n                ans+=(long)arr[i][1];\\n            } \\n        }\\n        double a = (double)ans/n;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] arr){\\n\\n        long t = arr[0][0]+arr[0][1];\\n\\n        int n = arr.length;\\n        long ans = arr[0][1];\\n\\n        for(int i=1; i<n; i++){\\n            if((long)arr[i][0]<t){\\n                ans+=(long)arr[i][1]+t-(long)arr[i][0];\\n                t=t+(long)arr[i][1];\\n            }\\n            else{\\n                t=(long)arr[i][0]+(long)arr[i][1];\\n                ans+=(long)arr[i][1];\\n            } \\n        }\\n        double a = (double)ans/n;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853272,
                "title": "c-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) \\n    {\\n        long long last=customers[0][0]+customers[0][1];\\n        long long ans=customers[0][1];\\n        for (int i=1;i<customers.size();i++)\\n        {  \\n            if (customers[i][0]>last) last=customers[i][0];\\n            last=last+customers[i][1];\\n            ans+=(last-customers[i][0]);\\n        }\\n        long long n=customers.size();\\n        return ans/(double)n;\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) \\n    {\\n        long long last=customers[0][0]+customers[0][1];\\n        long long ans=customers[0][1];\\n        for (int i=1;i<customers.size();i++)\\n        {  \\n            if (customers[i][0]>last) last=customers[i][0];\\n            last=last+customers[i][1];\\n            ans+=(last-customers[i][0]);\\n        }\\n        long long n=customers.size();\\n        return ans/(double)n;\\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844061,
                "title": "c-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n0(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double val=0;\\n        int s=0;\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(s<customers[i][0])\\n            {\\n                s=customers[i][0]+customers[i][1];\\n            }\\n            else{\\n                s=s+customers[i][1];\\n            }\\n            val+=(s-customers[i][0]);\\n        }\\n        return val/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double val=0;\\n        int s=0;\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(s<customers[i][0])\\n            {\\n                s=customers[i][0]+customers[i][1];\\n            }\\n            else{\\n                s=s+customers[i][1];\\n            }\\n            val+=(s-customers[i][0]);\\n        }\\n        return val/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828124,
                "title": "python-o-n-one-pass",
                "content": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        waiting = 0\\n        current_time = 0\\n        for arrival, time in customers:\\n            if arrival >= current_time:\\n                current_time = arrival+time\\n                waiting += time\\n            else:\\n                waiting += current_time-arrival+time\\n                current_time += time\\n\\n        return waiting/len(customers)\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        waiting = 0\\n        current_time = 0\\n        for arrival, time in customers:\\n            if arrival >= current_time:\\n                current_time = arrival+time\\n                waiting += time\\n            else:\\n                waiting += current_time-arrival+time\\n                current_time += time\\n\\n        return waiting/len(customers)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3827122,
                "title": "we-can-get-a-answer-from-a-single-for-loop-no-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   we need to calculate each customers waiting time and take average.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    we start the chef start time at 1 and each customer arrival he takes the order and finish and second customer the start time is finish time of the first customer we need to aware the one edge case if the chef is free and the start time of the customer is the arrival time of the customer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int st=1;\\n        double ans=0;\\n        for(int i=0;i<customers.length;i++)\\n        {\\n            int at=customers[i][0];\\n            int t=customers[i][1];\\n            if(st<at) st=at;\\n            st+=t;\\n            ans+=(st-at);    \\n        }\\n    return ans/customers.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int st=1;\\n        double ans=0;\\n        for(int i=0;i<customers.length;i++)\\n        {\\n            int at=customers[i][0];\\n            int t=customers[i][1];\\n            if(st<at) st=at;\\n            st+=t;\\n            ans+=(st-at);    \\n        }\\n    return ans/customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827109,
                "title": "c-beats-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers)\\n    {\\n        long tim = 0;\\n        int curr = 0;\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i][0]>=curr){curr = customers[i][0];}\\n            int nxt = curr+customers[i][1];\\n            tim+=(nxt-customers[i][0]);\\n            curr = nxt;\\n        }\\n        return (double)(tim)/(customers.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers)\\n    {\\n        long tim = 0;\\n        int curr = 0;\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i][0]>=curr){curr = customers[i][0];}\\n            int nxt = curr+customers[i][1];\\n            tim+=(nxt-customers[i][0]);\\n            curr = nxt;\\n        }\\n        return (double)(tim)/(customers.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797033,
                "title": "just-calculate-the-previous-end-time",
                "content": "# Intuition\\nSince the values are given sorted, we can just create a previous end time and check if its greater than the current start. If it is, we just add the difference to the wait, else we dont.\\nThen we just update the previous end for the next customer value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n\\n        #previous end value\\n        pEnd = 0\\n        #total wait\\n        total = 0\\n\\n        for s,w  in customers:\\n            \\n            #if the previous end value exceed the current start\\n            #we add the difference to the wait\\n            if pEnd > s:\\n                w += pEnd - s\\n            total += w\\n            #we update the previous end for the next customer\\n            pEnd = s + w    \\n        \\n        return total / len(customers)\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n\\n        #previous end value\\n        pEnd = 0\\n        #total wait\\n        total = 0\\n\\n        for s,w  in customers:\\n            \\n            #if the previous end value exceed the current start\\n            #we add the difference to the wait\\n            if pEnd > s:\\n                w += pEnd - s\\n            total += w\\n            #we update the previous end for the next customer\\n            pEnd = s + w    \\n        \\n        return total / len(customers)\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755398,
                "title": "simple-and-easy-solution-using-python",
                "content": "Simple and easy solution using python\\n\\n# Code\\n```\\nclass Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \"\"\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        if customers:\\n            totalTime,currentTime=0,customers[0][0]\\n        else:\\n            return 0\\n        for thisCustomer in customers:\\n            if currentTime >= thisCustomer[0]:\\n                currentTime+=thisCustomer[1]\\n            else:\\n                currentTime=thisCustomer[1]+thisCustomer[0]\\n            totalTime+=(currentTime-thisCustomer[0])\\n        \\n        return totalTime/float(len(customers))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \"\"\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        if customers:\\n            totalTime,currentTime=0,customers[0][0]\\n        else:\\n            return 0\\n        for thisCustomer in customers:\\n            if currentTime >= thisCustomer[0]:\\n                currentTime+=thisCustomer[1]\\n            else:\\n                currentTime=thisCustomer[1]+thisCustomer[0]\\n            totalTime+=(currentTime-thisCustomer[0])\\n        \\n        return totalTime/float(len(customers))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744410,
                "title": "python-easy-brute-force-with-o-n-time-and-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        currTime = 1\\n        ans = 0\\n        for arrival, time in customers:\\n            if arrival >= currTime:\\n                currTime = arrival\\n            ans += currTime - arrival + time\\n            currTime += time \\n        return ans / len(customers)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        currTime = 1\\n        ans = 0\\n        for arrival, time in customers:\\n            if arrival >= currTime:\\n                currTime = arrival\\n            ans += currTime - arrival + time\\n            currTime += time \\n        return ans / len(customers)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716854,
                "title": "simple-c-solution-by-tracking-the-minimum-time-to-deliver-the-order",
                "content": "# Intuition\\nWe need to track the customers timeline, at what time customer came, if two customers timeline overlap, it means we need to extend the timeline. But if the timeline does not overlap, we start the timeline from there.\\n# Approach\\nExample: [[5,2],[5,4],[10,3],[20,1]]\\nTimeline starts when the first order arrive. so\\ntimeline = 5\\nwait_time = 0;\\nFirst Order: while chef is preparing the order which takes 2 unit time, so \\ntimeline = 5 + 2\\nwait_time = timeline - arrival_time of order1 = 7 - 5 = 2\\n\\nSecond Order:\\nAs second order arrived when first order was being prepared, so we will extend the timeline as 5 < 7, as we can\\'t deliver the order before 7 + time to prepare order 2 which is 11. so:\\ntimeline = 7 + 4 = 11\\nwait_time += timeline - arrival_time of order 2 = 11 - 5 = 6\\n\\nThird Order:\\nThird order arrived at 10, chef is busy preparing last order yet, as its time to complete is 11. so we extend our timeline with its preparation time.\\ntimeline = 11 + 3 = 14\\nwait_time = timeline - arrival_time of order3 = 14 - 10 = 4\\n\\nForuth Order:\\nSee this order at 20 our chef would be free since 14, so chef can simply start making it because its not overlapping, and timeline starts from here we discard the old one.\\n\\ntimeline = arrival_time of order 4 + preparation time = 20 + 1 = 21;\\nwait_time = timeline - arrival_time or order 4 = 21 - 20 = 1;\\n\\nso 2 + 6 + 4 + 1 = 3.25.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double total_wait = 0;\\n        int timeline = customers[0][0];\\n        for(int i = 0; i < customers.size(); i++) {\\n\\n            if(customers[i][0] <= timeline)\\n            timeline += customers[i][1];\\n            else timeline = customers[i][0] + customers[i][1];\\n\\n            total_wait += timeline - customers[i][0];\\n        }\\n\\n        return total_wait /customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double total_wait = 0;\\n        int timeline = customers[0][0];\\n        for(int i = 0; i < customers.size(); i++) {\\n\\n            if(customers[i][0] <= timeline)\\n            timeline += customers[i][1];\\n            else timeline = customers[i][0] + customers[i][1];\\n\\n            total_wait += timeline - customers[i][0];\\n        }\\n\\n        return total_wait /customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709730,
                "title": "very-easy-java-solution-beats-100-solution",
                "content": "Keep a track of the total time happening. If the current customer comes after the total time then the new updated time is the sum of the time when the customer comes goes else if the customer incoming time is less than than the current total time then we simply add the prep time and subtract the coming time from the new total time. Lastly we convert it to double and return the result. Make sure to take long for res and time to avoid overflow.\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] c) {\\n        long res=c[0][1];\\n        int st=c[0][0];\\n        long tt=c[0][0]+c[0][1];\\n        for(int i=1;i<c.length;i++){\\n            int x[]=c[i];\\n            if(x[0]<=tt){\\n                tt=tt+x[1];\\n                res+=tt-x[0];\\n            }\\n            else {\\n                tt=x[0]+x[1];\\n                res+=x[1];\\n            }\\n        }\\n        return (double)res/(double)c.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] c) {\\n        long res=c[0][1];\\n        int st=c[0][0];\\n        long tt=c[0][0]+c[0][1];\\n        for(int i=1;i<c.length;i++){\\n            int x[]=c[i];\\n            if(x[0]<=tt){\\n                tt=tt+x[1];\\n                res+=tt-x[0];\\n            }\\n            else {\\n                tt=x[0]+x[1];\\n                res+=x[1];\\n            }\\n        }\\n        return (double)res/(double)c.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658009,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        time=customers[0][0]\\n        total_time = 0 \\n        for item in customers :\\n            time = max(time , item[0])\\n            time = time + item[-1]\\n            k= time-item [0]\\n            total_time += k \\n        return (total_time/len(customers))    \\n               \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        time=customers[0][0]\\n        total_time = 0 \\n        for item in customers :\\n            time = max(time , item[0])\\n            time = time + item[-1]\\n            k= time-item [0]\\n            total_time += k \\n        return (total_time/len(customers))    \\n               \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654165,
                "title": "simple-easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        totalSum=0\\n        prevWaitTime = customers[0][0]\\n\\n        for arrive, timetake in customers:\\n            if prevWaitTime < arrive:\\n                prevWaitTime = arrive\\n            \\n            currentWaitTime = prevWaitTime+timetake\\n            totalSum = totalSum + (currentWaitTime-arrive)\\n            prevWaitTime = currentWaitTime\\n        \\n        return totalSum/len(customers)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        totalSum=0\\n        prevWaitTime = customers[0][0]\\n\\n        for arrive, timetake in customers:\\n            if prevWaitTime < arrive:\\n                prevWaitTime = arrive\\n            \\n            currentWaitTime = prevWaitTime+timetake\\n            totalSum = totalSum + (currentWaitTime-arrive)\\n            prevWaitTime = currentWaitTime\\n        \\n        return totalSum/len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627570,
                "title": "easy-greedy-python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        cur =0\\n        wt =0\\n        for i in customers:\\n            if i[0]>=cur:\\n                cur = i[0]+i[1]\\n                wt+= i[1]\\n            else:\\n                wt += cur-i[0]+i[1]\\n                cur = cur+i[1]\\n        return round(wt/len(customers),5)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        cur =0\\n        wt =0\\n        for i in customers:\\n            if i[0]>=cur:\\n                cur = i[0]+i[1]\\n                wt+= i[1]\\n            else:\\n                wt += cur-i[0]+i[1]\\n                cur = cur+i[1]\\n        return round(wt/len(customers),5)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597791,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        wait = []\\n        wait.append(customers[0][1])\\n        t = sum(customers[0])\\n        for i in range(1, len(customers)):\\n            if t<customers[i][0]:\\n                t = customers[i][0]\\n                \\n            t += customers[i][1]\\n            wait.append(t-customers[i][0])\\n                \\n        return sum(wait)/len(wait)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        wait = []\\n        wait.append(customers[0][1])\\n        t = sum(customers[0])\\n        for i in range(1, len(customers)):\\n            if t<customers[i][0]:\\n                t = customers[i][0]\\n                \\n            t += customers[i][1]\\n            wait.append(t-customers[i][0])\\n                \\n        return sum(wait)/len(wait)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575421,
                "title": "5-line-easy-python-solution-85-faster",
                "content": "# **PLEASE DO UPVOTE (\\u25CF\\'\\u25E1\\'\\u25CF)\\uD83D\\uDC96**\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        ans=0\\n        st=customers[0][0]\\n        for i,j in customers:\\n            if st>=i:\\n                st+=j\\n            else:\\n                st=i+j\\n            ans+=(st-i)\\n        \\n        return ans/len(customers)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        ans=0\\n        st=customers[0][0]\\n        for i,j in customers:\\n            if st>=i:\\n                st+=j\\n            else:\\n                st=i+j\\n            ans+=(st-i)\\n        \\n        return ans/len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574552,
                "title": "java-clean-and-readable",
                "content": "```\\n    public double averageWaitingTime(int[][] customers) {\\n        var sum=0.;\\n        int prev=0; //end of the previous order preparation\\n        for (var customer:customers){\\n            int arrival  = customer[0], prep = customer[1];\\n            var idle     = prev<=arrival?0:prev-arrival; //time the customer waits before giving the order to the chef\\n            var awaiting = idle+prep;                    //total time of waiting before giving the order + time for its preparation\\n            prev = arrival+awaiting;\\n            sum +=awaiting;\\n        }\\n        return sum/customers.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double averageWaitingTime(int[][] customers) {\\n        var sum=0.;\\n        int prev=0; //end of the previous order preparation\\n        for (var customer:customers){\\n            int arrival  = customer[0], prep = customer[1];\\n            var idle     = prev<=arrival?0:prev-arrival; //time the customer waits before giving the order to the chef\\n            var awaiting = idle+prep;                    //total time of waiting before giving the order + time for its preparation\\n            prev = arrival+awaiting;\\n            sum +=awaiting;\\n        }\\n        return sum/customers.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553909,
                "title": "simple-explanation-in-the-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \"\"\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n\\n\\n         formula for when costomer has been waiting (timeNow - time arrvied) + time needed\\n         time waiting for order to start: (timeNow - time arrvied)\\n         add to his the time itl now take to finish the order\\n\\n         if costomer has not been waiting; the wait time will be how long it takes to make the meal\\n         and the time is set to the arv time + time taken to make meal\\n\\n\\n\\n        if  arive time > curr time :\\n            wait time is just the time it takes\\n            new time gets set to arive time + time this order took\\n\\n        else \\n            wait time is (timeNow - time arrvied) + time needed\\n            new time is time now + time needed\\n\\n        \"\"\"\\n\\n        avg = 0.0\\n\\n        time = 0\\n\\n\\n        for arv,time_needed in customers:\\n            \\n\\n            # costomer has been waiting\\n            if time > arv:\\n                avg += ( (time - arv) + time_needed)\\n                time +=time_needed\\n\\n            else:\\n                avg += time_needed\\n                time = arv+time_needed\\n\\n\\n        return avg / len(customers)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \"\"\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n\\n\\n         formula for when costomer has been waiting (timeNow - time arrvied) + time needed\\n         time waiting for order to start: (timeNow - time arrvied)\\n         add to his the time itl now take to finish the order\\n\\n         if costomer has not been waiting; the wait time will be how long it takes to make the meal\\n         and the time is set to the arv time + time taken to make meal\\n\\n\\n\\n        if  arive time > curr time :\\n            wait time is just the time it takes\\n            new time gets set to arive time + time this order took\\n\\n        else \\n            wait time is (timeNow - time arrvied) + time needed\\n            new time is time now + time needed\\n\\n        \"\"\"\\n\\n        avg = 0.0\\n\\n        time = 0\\n\\n\\n        for arv,time_needed in customers:\\n            \\n\\n            # costomer has been waiting\\n            if time > arv:\\n                avg += ( (time - arv) + time_needed)\\n                time +=time_needed\\n\\n            else:\\n                avg += time_needed\\n                time = arv+time_needed\\n\\n\\n        return avg / len(customers)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542678,
                "title": "python3-simulation",
                "content": "# Intuition\\nThe problem can be solved by simulation: Process the order in order, keep track of:\\n1. The time when last order was finished;\\n2. The number of customers seen so far;\\n3. The running average.\\n# Complexity\\n- Time complexity: $$O(N)$$ where $$N$$ is the number of customer.\\n- Space complexity: $$O(1)$$ as no extra space is needed (running average).\\n\\n# Code\\n```python\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        last = 0 # the time when the last order finish\\n        num = 0 # current number of visiting customers\\n        avg = 0 # running average; the new average will be: (avg * num + new_val)/(num+1)\\n\\n        for customer in customers:\\n            # my order begins at..\\n            begin = max(last, customer[0])\\n            # my order is finishing at..\\n            finish = begin + customer[1]\\n            # wait time for me is my order\\'s finishing time - my arrival time\\n            wait = finish - customer[0]\\n            # compute running average..\\n            avg = (avg * num + wait) / (num+1)\\n            # This is the earliest time when the next customer\\'s order can be processed\\n            last = finish\\n            # increment number of served customers\\n            num += 1\\n        \\n        return avg\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        last = 0 # the time when the last order finish\\n        num = 0 # current number of visiting customers\\n        avg = 0 # running average; the new average will be: (avg * num + new_val)/(num+1)\\n\\n        for customer in customers:\\n            # my order begins at..\\n            begin = max(last, customer[0])\\n            # my order is finishing at..\\n            finish = begin + customer[1]\\n            # wait time for me is my order\\'s finishing time - my arrival time\\n            wait = finish - customer[0]\\n            # compute running average..\\n            avg = (avg * num + wait) / (num+1)\\n            # This is the earliest time when the next customer\\'s order can be processed\\n            last = finish\\n            # increment number of served customers\\n            num += 1\\n        \\n        return avg\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537436,
                "title": "java-solution-0-n-time-complexity-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double ans = 0;\\n        double t = customers[0][0] + customers[0][1];\\n        double w = customers[0][1];\\n       for(int i = 1; i < customers.length; i++){\\n           if(customers[i][0]<=t){\\n               t = t+customers[i][1];\\n               w = w + (t-customers[i][0]);\\n           }\\n           else if(customers[i][0]>t){\\n               w = w + customers[i][1];\\n               t = customers[i][1] + customers[i][0];\\n           }\\n       }\\n        \\n        ans = (double)w/customers.length;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double ans = 0;\\n        double t = customers[0][0] + customers[0][1];\\n        double w = customers[0][1];\\n       for(int i = 1; i < customers.length; i++){\\n           if(customers[i][0]<=t){\\n               t = t+customers[i][1];\\n               w = w + (t-customers[i][0]);\\n           }\\n           else if(customers[i][0]>t){\\n               w = w + customers[i][1];\\n               t = customers[i][1] + customers[i][0];\\n           }\\n       }\\n        \\n        ans = (double)w/customers.length;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534259,
                "title": "brute-force-approach-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        a=customers[0][0]\\n        ans=[]\\n        for i in range(len(customers)):\\n            if a>customers[i][0]:\\n                a=a+customers[i][1]\\n                time=a-customers[i][0]\\n                ans.append(time)\\n            else:\\n                a=customers[i][0]+customers[i][1]\\n                time=a-customers[i][0]\\n                ans.append(time)\\n                \\n\\n\\n        avg=sum(ans)/len(ans)\\n        return avg\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        a=customers[0][0]\\n        ans=[]\\n        for i in range(len(customers)):\\n            if a>customers[i][0]:\\n                a=a+customers[i][1]\\n                time=a-customers[i][0]\\n                ans.append(time)\\n            else:\\n                a=customers[i][0]+customers[i][1]\\n                time=a-customers[i][0]\\n                ans.append(time)\\n                \\n\\n\\n        avg=sum(ans)/len(ans)\\n        return avg\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522610,
                "title": "c-code-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n=customers.size();\\n        int start=customers[0][0], finish=customers[0][1]+start;\\n        double waitingTime=finish-start, avg=0.00;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            start=max(finish, customers[i][0]);          \\n            finish=(start+customers[i][1]);  \\n            waitingTime+=(finish-customers[i][0]);\\n        }\\n        avg=waitingTime/n;\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n=customers.size();\\n        int start=customers[0][0], finish=customers[0][1]+start;\\n        double waitingTime=finish-start, avg=0.00;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            start=max(finish, customers[i][0]);          \\n            finish=(start+customers[i][1]);  \\n            waitingTime+=(finish-customers[i][0]);\\n        }\\n        avg=waitingTime/n;\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521530,
                "title": "swift-math",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n        var sum = customers[0][1]\\n\\n        var currTime = customers[0][0] + customers[0][1]\\n\\n        for i in 1..<customers.count {\\n            let arrival = customers[i][0]\\n            let time = customers[i][1]\\n\\n            if arrival >= currTime {\\n                currTime = arrival + time\\n                sum += time\\n            } else {\\n                sum += currTime - arrival + time \\n                currTime += time \\n            }\\n        }\\n\\n        return Double(sum) / Double(customers.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n        var sum = customers[0][1]\\n\\n        var currTime = customers[0][0] + customers[0][1]\\n\\n        for i in 1..<customers.count {\\n            let arrival = customers[i][0]\\n            let time = customers[i][1]\\n\\n            if arrival >= currTime {\\n                currTime = arrival + time\\n                sum += time\\n            } else {\\n                sum += currTime - arrival + time \\n                currTime += time \\n            }\\n        }\\n\\n        return Double(sum) / Double(customers.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515201,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double timeCurrent = 0;\\n        double totalWaitTime = 0;\\n        for(int i = 0 ; i < customers.length ; i++){\\n            double waitTime = customers[i][1];\\n            if(customers[i][0] < timeCurrent){\\n                waitTime += timeCurrent -  customers[i][0];\\n            }\\n            timeCurrent = customers[i][0] + waitTime;\\n            totalWaitTime += (double)waitTime/customers.length;\\n\\n        }\\n        return totalWaitTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double timeCurrent = 0;\\n        double totalWaitTime = 0;\\n        for(int i = 0 ; i < customers.length ; i++){\\n            double waitTime = customers[i][1];\\n            if(customers[i][0] < timeCurrent){\\n                waitTime += timeCurrent -  customers[i][0];\\n            }\\n            timeCurrent = customers[i][0] + waitTime;\\n            totalWaitTime += (double)waitTime/customers.length;\\n\\n        }\\n        return totalWaitTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484946,
                "title": "python-solution-with-simple-approach",
                "content": "# Approach\\nI have created a variable called realTime and used that as a clock.\\nIt simply finds the time difference between the initial time and clients\\' arrival time.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \"\"\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        realTime=customers[0][0]\\n        total=0\\n        for ele in customers:\\n          if realTime==ele[0]:\\n            total+=ele[1]\\n            realTime+=ele[1]\\n          elif realTime>ele[0]:\\n            realTime+=ele[1]\\n            total+=(realTime-ele[0])\\n          else:\\n            total+=ele[1]\\n            realTime=ele[0]+ele[1]            \\n        return float(total)/len(customers)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def averageWaitingTime(self, customers):\\n        \"\"\"\\n        :type customers: List[List[int]]\\n        :rtype: float\\n        \"\"\"\\n        realTime=customers[0][0]\\n        total=0\\n        for ele in customers:\\n          if realTime==ele[0]:\\n            total+=ele[1]\\n            realTime+=ele[1]\\n          elif realTime>ele[0]:\\n            realTime+=ele[1]\\n            total+=(realTime-ele[0])\\n          else:\\n            total+=ele[1]\\n            realTime=ele[0]+ele[1]            \\n        return float(total)/len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484754,
                "title": "constant-space-o-n-time-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double ans = 0;\\n        int currTime = 1;\\n        for(int i = 0; i < customers.size(); i++) {\\n            currTime = max(currTime, customers[i][0]);\\n            currTime += customers[i][1];\\n            ans += 1.0* (currTime - customers[i][0]);\\n        }\\n        return ans/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double ans = 0;\\n        int currTime = 1;\\n        for(int i = 0; i < customers.size(); i++) {\\n            currTime = max(currTime, customers[i][0]);\\n            currTime += customers[i][1];\\n            ans += 1.0* (currTime - customers[i][0]);\\n        }\\n        return ans/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480614,
                "title": "map-entry-solution-java",
                "content": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        LinkedList<Map.Entry<Integer, Integer>> lastTime = new LinkedList<>();\\n        for (int i = 0; i < customers.length; i++) {\\n            if (lastTime.isEmpty()) {\\n                lastTime.add(Map.entry(customers[i][0] + customers[i][1], 0));\\n                var key = lastTime.get(i).getKey();\\n                lastTime.set(i, Map.entry(key, key - customers[i][0]));\\n            } else if (customers[i][0] > lastTime.peekLast().getKey()) {\\n                lastTime.add(Map.entry(customers[i][0] + customers[i][1], 0));\\n                var key = lastTime.get(i).getKey();\\n                lastTime.set(i, Map.entry(key, key - customers[i][0]));\\n            } else {\\n                lastTime.add(Map.entry(lastTime.peekLast().getKey() + customers[i][1], 0));\\n                var key = lastTime.get(i).getKey();\\n                lastTime.set(i, Map.entry(key, key - customers[i][0]));\\n            }\\n        }\\n\\n        return lastTime.stream().map(x -> (double) x.getValue()).reduce(0.0, (x, y) -> x + y) / lastTime.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        LinkedList<Map.Entry<Integer, Integer>> lastTime = new LinkedList<>();\\n        for (int i = 0; i < customers.length; i++) {\\n            if (lastTime.isEmpty()) {\\n                lastTime.add(Map.entry(customers[i][0] + customers[i][1], 0));\\n                var key = lastTime.get(i).getKey();\\n                lastTime.set(i, Map.entry(key, key - customers[i][0]));\\n            } else if (customers[i][0] > lastTime.peekLast().getKey()) {\\n                lastTime.add(Map.entry(customers[i][0] + customers[i][1], 0));\\n                var key = lastTime.get(i).getKey();\\n                lastTime.set(i, Map.entry(key, key - customers[i][0]));\\n            } else {\\n                lastTime.add(Map.entry(lastTime.peekLast().getKey() + customers[i][1], 0));\\n                var key = lastTime.get(i).getKey();\\n                lastTime.set(i, Map.entry(key, key - customers[i][0]));\\n            }\\n        }\\n\\n        return lastTime.stream().map(x -> (double) x.getValue()).reduce(0.0, (x, y) -> x + y) / lastTime.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473236,
                "title": "few-lines-code-t-c-o-n-s-c-o-1-cpp",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double Arrival=customers[0][0],sum=0,time=0,cnt=0;\\n        for(auto x:customers){\\n            if(x[0]>Arrival)Arrival=x[0];\\n            time=Arrival+x[1];\\n            sum+=(time-x[0]);\\n            Arrival=time;\\n            cnt++;\\n        }\\n        return sum/cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double Arrival=customers[0][0],sum=0,time=0,cnt=0;\\n        for(auto x:customers){\\n            if(x[0]>Arrival)Arrival=x[0];\\n            time=Arrival+x[1];\\n            sum+=(time-x[0]);\\n            Arrival=time;\\n            cnt++;\\n        }\\n        return sum/cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467575,
                "title": "using-stacks",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        double ans = 0;\\n        stack<pair<int,int>> st;\\n\\n        pair<int,int> firstp;\\n\\n        firstp.first = c[0][0];\\n        firstp.second = c[0][0] + c[0][1];\\n        st.push(firstp);\\n\\n        for(int i=1;i<c.size();i++){\\n            int timec = c[i][0];\\n\\n            if(timec<=st.top().second){\\n                pair<int,int> localp;\\n                localp.first = st.top().second;\\n                localp.second = c[i][1]+localp.first;\\n                st.push(localp);\\n            }else{\\n                pair<int,int> localp;\\n                localp.first = timec;\\n                localp.second = c[i][1]+localp.first;\\n                st.push(localp);\\n            }\\n\\n        }\\n        int k = c.size()-1;\\n        long long sum = 0;\\n        while(!st.empty()){\\n            //cout<<abs(c[k][0] - st.top().second)<<endl;\\n            sum+=abs(c[k][0] - st.top().second);\\n      //  cout<<st.top().second<<endl;\\n            k--;\\n            st.pop();\\n        }\\n\\n       // cout<<firstp.second;\\n       ans = (double)sum/c.size();\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n        double ans = 0;\\n        stack<pair<int,int>> st;\\n\\n        pair<int,int> firstp;\\n\\n        firstp.first = c[0][0];\\n        firstp.second = c[0][0] + c[0][1];\\n        st.push(firstp);\\n\\n        for(int i=1;i<c.size();i++){\\n            int timec = c[i][0];\\n\\n            if(timec<=st.top().second){\\n                pair<int,int> localp;\\n                localp.first = st.top().second;\\n                localp.second = c[i][1]+localp.first;\\n                st.push(localp);\\n            }else{\\n                pair<int,int> localp;\\n                localp.first = timec;\\n                localp.second = c[i][1]+localp.first;\\n                st.push(localp);\\n            }\\n\\n        }\\n        int k = c.size()-1;\\n        long long sum = 0;\\n        while(!st.empty()){\\n            //cout<<abs(c[k][0] - st.top().second)<<endl;\\n            sum+=abs(c[k][0] - st.top().second);\\n      //  cout<<st.top().second<<endl;\\n            k--;\\n            st.pop();\\n        }\\n\\n       // cout<<firstp.second;\\n       ans = (double)sum/c.size();\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3465949,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    for each order just need to count waiting time and next avaialble time\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    for each order waitint time is lastAvaialble time + time \\n    to prepare the current order\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double totalWaiting = 0;\\n        double size = customers.size();\\n        int available = 1;\\n        for (auto& c : customers) {\\n            if (c[0] >= available) {\\n                totalWaiting += c[1];\\n                available = c[0] + c[1];\\n            } else {\\n                int finishTime = available + c[1];\\n                totalWaiting += finishTime - c[0];\\n                available = finishTime;\\n            }\\n        }\\n        return totalWaiting / size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double totalWaiting = 0;\\n        double size = customers.size();\\n        int available = 1;\\n        for (auto& c : customers) {\\n            if (c[0] >= available) {\\n                totalWaiting += c[1];\\n                available = c[0] + c[1];\\n            } else {\\n                int finishTime = available + c[1];\\n                totalWaiting += finishTime - c[0];\\n                available = finishTime;\\n            }\\n        }\\n        return totalWaiting / size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450003,
                "title": "easy-swift-solutions-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n         var avgs = [Int]()\\n    var finish = 0\\n    for i in 0..<customers.count {\\n       \\n        var carry = max(customers[i][0], finish)\\n        \\n        finish = carry + customers[i][1]\\n       \\n        let wait = finish - customers[i][0]\\n        avgs.append(wait)\\n       \\n        \\n        \\n    }\\n    var sum = 0.0000\\n    for i in 0..<avgs.count {\\n        sum += Double(avgs[i])\\n    }\\n\\n    return sum/Double(avgs.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n         var avgs = [Int]()\\n    var finish = 0\\n    for i in 0..<customers.count {\\n       \\n        var carry = max(customers[i][0], finish)\\n        \\n        finish = carry + customers[i][1]\\n       \\n        let wait = finish - customers[i][0]\\n        avgs.append(wait)\\n       \\n        \\n        \\n    }\\n    var sum = 0.0000\\n    for i in 0..<avgs.count {\\n        sum += Double(avgs[i])\\n    }\\n\\n    return sum/Double(avgs.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450000,
                "title": "easy-swift-solution-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n         var avgs = [Int]()\\n    var finish = 0\\n    for i in 0..<customers.count {\\n       \\n        var carry = max(customers[i][0], finish)\\n        \\n        finish = carry + customers[i][1]\\n        \\n        let wait = finish - customers[i][0]\\n        avgs.append(wait)\\n      \\n        \\n        \\n    }\\n    var sum = 0.0000\\n    for i in 0..<avgs.count {\\n        sum += Double(avgs[i])\\n    }\\n\\n    return sum/Double(avgs.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n         var avgs = [Int]()\\n    var finish = 0\\n    for i in 0..<customers.count {\\n       \\n        var carry = max(customers[i][0], finish)\\n        \\n        finish = carry + customers[i][1]\\n        \\n        let wait = finish - customers[i][0]\\n        avgs.append(wait)\\n      \\n        \\n        \\n    }\\n    var sum = 0.0000\\n    for i in 0..<avgs.count {\\n        sum += Double(avgs[i])\\n    }\\n\\n    return sum/Double(avgs.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431631,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        temp = []\\n        time = 0\\n        for i,j in customers:\\n            if i > time:\\n                time = i + j\\n            else:\\n                time += j\\n            temp.append(time - i)\\n        return sum(temp)/len(temp)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        temp = []\\n        time = 0\\n        for i,j in customers:\\n            if i > time:\\n                time = i + j\\n            else:\\n                time += j\\n            temp.append(time - i)\\n        return sum(temp)/len(temp)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400562,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double sum1=0;\\n        double wait=0;\\n        for(int i=0;i<customers.size();i++){\\n            if(i==0){\\n                sum1+=(customers[i][0])*(1.0);\\n            }\\n            else{\\n                if(sum1>=customers[i][0]){\\n                    sum1+=0;\\n                }\\n                else{\\n                    sum1=customers[i][0];\\n                }\\n            }\\n            sum1+=(customers[i][1])*(1.0);\\n            wait+=(sum1-customers[i][0]);\\n        }\\n        double val=customers.size()*(1.0);\\n        return wait/val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double sum1=0;\\n        double wait=0;\\n        for(int i=0;i<customers.size();i++){\\n            if(i==0){\\n                sum1+=(customers[i][0])*(1.0);\\n            }\\n            else{\\n                if(sum1>=customers[i][0]){\\n                    sum1+=0;\\n                }\\n                else{\\n                    sum1=customers[i][0];\\n                }\\n            }\\n            sum1+=(customers[i][1])*(1.0);\\n            wait+=(sum1-customers[i][0]);\\n        }\\n        double val=customers.size()*(1.0);\\n        return wait/val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389175,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        long long timer = customers[0][0]+customers[0][1];\\n        long long sum = customers[0][1];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(customers[i][0]>timer)\\n            {\\n                timer = customers[i][0]+customers[i][1];\\n            }\\n            else\\n            timer+=customers[i][1];\\n            sum+=timer-customers[i][0];\\n        }\\n        double ans = ((double)sum)/n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        long long timer = customers[0][0]+customers[0][1];\\n        long long sum = customers[0][1];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(customers[i][0]>timer)\\n            {\\n                timer = customers[i][0]+customers[i][1];\\n            }\\n            else\\n            timer+=customers[i][1];\\n            sum+=timer-customers[i][0];\\n        }\\n        double ans = ((double)sum)/n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386212,
                "title": "python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        waitingTime, start = 0.0, customers[0][0]\\n        for i in customers:\\n            waitingTime += max(0,start-i[0])+i[1]\\n            start = max(start,i[0]) + i[1]\\n        return waitingTime/len(customers)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        waitingTime, start = 0.0, customers[0][0]\\n        for i in customers:\\n            waitingTime += max(0,start-i[0])+i[1]\\n            start = max(start,i[0]) + i[1]\\n        return waitingTime/len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383894,
                "title": "java-soln",
                "content": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double n = customers.length;\\n        double sumWaitingTime = 0;\\n        double prevTime = customers[0][0];\\n        for(int i = 0; i < n; i++) {\\n            int[] customer = customers[i];\\n            int arrivalTime = customer[0];\\n            int time = customer[1];\\n            prevTime = arrivalTime > prevTime ? arrivalTime + time : prevTime + time;\\n            sumWaitingTime += (prevTime - arrivalTime);\\n        }\\n        return sumWaitingTime/n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double n = customers.length;\\n        double sumWaitingTime = 0;\\n        double prevTime = customers[0][0];\\n        for(int i = 0; i < n; i++) {\\n            int[] customer = customers[i];\\n            int arrivalTime = customer[0];\\n            int time = customer[1];\\n            prevTime = arrivalTime > prevTime ? arrivalTime + time : prevTime + time;\\n            sumWaitingTime += (prevTime - arrivalTime);\\n        }\\n        return sumWaitingTime/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379035,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        wait_time = []\\n        last_finish_time = 0\\n        for i in range(len(customers)):\\n            start_time = max(last_finish_time, customers[i][0])\\n            serve_time = start_time + customers[i][1]\\n            wait_time.append(serve_time - customers[i][0]) \\n            last_finish_time = serve_time\\n        total_wait_time = 0\\n        for time in wait_time:\\n            total_wait_time += time\\n        return total_wait_time / len(wait_time)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        wait_time = []\\n        last_finish_time = 0\\n        for i in range(len(customers)):\\n            start_time = max(last_finish_time, customers[i][0])\\n            serve_time = start_time + customers[i][1]\\n            wait_time.append(serve_time - customers[i][0]) \\n            last_finish_time = serve_time\\n        total_wait_time = 0\\n        for time in wait_time:\\n            total_wait_time += time\\n        return total_wait_time / len(wait_time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374641,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        \\n        ans=0\\n        prev=customers[0][0]\\n        \\n        for a,b in customers:\\n            \\n            waiting_time = max(prev-a,0)\\n            ans+=waiting_time+b\\n            prev=a+b+waiting_time\\n        \\n        return ans/len(customers)\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        \\n        ans=0\\n        prev=customers[0][0]\\n        \\n        for a,b in customers:\\n            \\n            waiting_time = max(prev-a,0)\\n            ans+=waiting_time+b\\n            prev=a+b+waiting_time\\n        \\n        return ans/len(customers)\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373348,
                "title": "simple-c-intuitive-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& arr) {\\n        double n = arr.size();\\n\\n        double ans = 0;\\n\\n        int t = arr[0][0] + arr[0][1];\\n        ans += arr[0][1];\\n        for(int i=1 ; i<n ;i++){\\n            int wait = (arr[i][0]<t ? t-arr[i][0] : 0);\\n            ans += wait+arr[i][1];\\n            t = max(arr[i][0] , t)+arr[i][1];\\n        }\\n\\n        return ans/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& arr) {\\n        double n = arr.size();\\n\\n        double ans = 0;\\n\\n        int t = arr[0][0] + arr[0][1];\\n        ans += arr[0][1];\\n        for(int i=1 ; i<n ;i++){\\n            int wait = (arr[i][0]<t ? t-arr[i][0] : 0);\\n            ans += wait+arr[i][1];\\n            t = max(arr[i][0] , t)+arr[i][1];\\n        }\\n\\n        return ans/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365561,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) \\n    {\\n        long long start=0;\\n        long long sum=0;\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i][0]>start)\\n                start=customers[i][0];\\n            int finish=start + customers[i][1]; \\n            sum+=(finish-customers[i][0]);\\n            start=finish;\\n        }  \\n        return (double)sum/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) \\n    {\\n        long long start=0;\\n        long long sum=0;\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(customers[i][0]>start)\\n                start=customers[i][0];\\n            int finish=start + customers[i][1]; \\n            sum+=(finish-customers[i][0]);\\n            start=finish;\\n        }  \\n        return (double)sum/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365320,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double final_waiting_time=0;\\n        int current_time=0;\\n        \\n        int arrival_time,cooking_time,temp_waiting_time;\\n        for (int i=0;i<customers.length;i++){\\n\\n            arrival_time=customers[i][0];\\n            cooking_time=customers[i][1];\\n\\n            current_time=Math.max(current_time,arrival_time);\\n            current_time+=cooking_time;\\n            temp_waiting_time=current_time-arrival_time;\\n            final_waiting_time+=temp_waiting_time;\\n        }\\n        double number=final_waiting_time/customers.length;\\n        System.out.println(\"number = \"+number);\\n        double result=Math.round(number * Math.pow(10, 5))\\n                / Math.pow(10, 5);\\n        return result;\\n        \\n    }\\n}\\n```\\n![90f09615-d42d-402c-897e-8d81a9fb5f37_1677988379.954136.jpeg](https://assets.leetcode.com/users/images/2b827f66-bbb0-4435-8cc5-d42caea70abc_1680343171.688653.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double final_waiting_time=0;\\n        int current_time=0;\\n        \\n        int arrival_time,cooking_time,temp_waiting_time;\\n        for (int i=0;i<customers.length;i++){\\n\\n            arrival_time=customers[i][0];\\n            cooking_time=customers[i][1];\\n\\n            current_time=Math.max(current_time,arrival_time);\\n            current_time+=cooking_time;\\n            temp_waiting_time=current_time-arrival_time;\\n            final_waiting_time+=temp_waiting_time;\\n        }\\n        double number=final_waiting_time/customers.length;\\n        System.out.println(\"number = \"+number);\\n        double result=Math.round(number * Math.pow(10, 5))\\n                / Math.pow(10, 5);\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346594,
                "title": "easy-beginner-friendly-solution-c",
                "content": "# Intuition :\\nTo calculate the average waiting time, we need to know the waiting time for each customer. The waiting time for a customer is the time they start being served minus the time they arrived at the restaurant. We can calculate the waiting time for each customer by keeping track of the current time and updating it as we process each customer\\'s order.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n1. Set the current time to the arrival time of the first customer plus the time to process their order.\\n1. Loop through the remaining customers:\\n  - If the current time is greater than or equal to the customer\\'s arrival time, add the time to process their order to the current time and calculate their waiting time.\\n - If the current time is less than the customer\\'s arrival time, set the current time to the customer\\'s arrival time plus the time to process their order, and calculate their waiting time.\\n3. Add each customer\\'s waiting time to a vector.\\n4. Calculate the average waiting time by summing up all the waiting times and dividing by the number of customers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : The time complexity of this algorithm is $$O(n)$$, where N is the number of customers. This is because we loop through each customer once and perform constant-time operations (adding and subtracting integers) for each customer. Therefore, the time complexity is linear in the number of customers.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : The space complexity of this algorithm is $$O(n)$$, where N is the number of customers. This is because we are storing the waiting time for each customer in a vector of size N.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        // Set the initial time to the arrival time of the first customer plus the time to process their order\\n        int currentTime = customers[0][0] + customers[0][1];\\n        \\n        // Create a vector to store the waiting times for each customer\\n        vector<int> waitTimes; \\n        \\n        // Calculate the waiting time for the first customer and add it to the vector\\n        int currentWaitTime = currentTime - customers[0][0];\\n        waitTimes.push_back(currentWaitTime);\\n        \\n        // Loop through the remaining customers and calculate their waiting times\\n        for(int i=1; i<customers.size(); i++){\\n            if(currentTime >= customers[i][0]){\\n                // If the customer arrives while the restaurant is still processing the previous order,\\n                // add the time to process their order to the current time and calculate their waiting time\\n                currentTime += customers[i][1]; \\n                int currentWaitTime = currentTime - customers[i][0]; \\n                waitTimes.push_back(currentWaitTime); \\n            }\\n            else{\\n                // If the customer arrives after the previous order has been completed,\\n                // set the current time to their arrival time plus the time to process their order,\\n                // and calculate their waiting time\\n                currentTime = customers[i][0] + customers[i][1]; \\n                int currentWaitTime = currentTime - customers[i][0];\\n                waitTimes.push_back(currentWaitTime); \\n            }\\n        }\\n        \\n        // Calculate the average waiting time by summing up all the waiting times and dividing by the number of customers\\n        double totalWaitTime = 0.0;\\n        for(int i=0; i<waitTimes.size(); i++){\\n            totalWaitTime += waitTimes[i]; \\n        }\\n        return totalWaitTime / waitTimes.size();\\n    }\\n};\\n\\n```\\n\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\nFeel free to ask any question in the comment section.\\nI hope that you\\'ve found the solution useful.\\nHappy Coding :)\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/cf1d6a3d-5254-4ed7-95fd-db7f6ef4cf23_1679899136.302753.gif)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        // Set the initial time to the arrival time of the first customer plus the time to process their order\\n        int currentTime = customers[0][0] + customers[0][1];\\n        \\n        // Create a vector to store the waiting times for each customer\\n        vector<int> waitTimes; \\n        \\n        // Calculate the waiting time for the first customer and add it to the vector\\n        int currentWaitTime = currentTime - customers[0][0];\\n        waitTimes.push_back(currentWaitTime);\\n        \\n        // Loop through the remaining customers and calculate their waiting times\\n        for(int i=1; i<customers.size(); i++){\\n            if(currentTime >= customers[i][0]){\\n                // If the customer arrives while the restaurant is still processing the previous order,\\n                // add the time to process their order to the current time and calculate their waiting time\\n                currentTime += customers[i][1]; \\n                int currentWaitTime = currentTime - customers[i][0]; \\n                waitTimes.push_back(currentWaitTime); \\n            }\\n            else{\\n                // If the customer arrives after the previous order has been completed,\\n                // set the current time to their arrival time plus the time to process their order,\\n                // and calculate their waiting time\\n                currentTime = customers[i][0] + customers[i][1]; \\n                int currentWaitTime = currentTime - customers[i][0];\\n                waitTimes.push_back(currentWaitTime); \\n            }\\n        }\\n        \\n        // Calculate the average waiting time by summing up all the waiting times and dividing by the number of customers\\n        double totalWaitTime = 0.0;\\n        for(int i=0; i<waitTimes.size(); i++){\\n            totalWaitTime += waitTimes[i]; \\n        }\\n        return totalWaitTime / waitTimes.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343728,
                "title": "easy-o-n-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        \\n        endtime = 0\\n        total = 0\\n        for a, t in customers:\\n            if endtime < a:\\n                total += t\\n                endtime = a + t\\n            else:\\n                total += (endtime - a) + t\\n                endtime = (endtime - a) + a + t\\n            print(total, endtime)\\n        return total / len(customers)\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        \\n        \\n        endtime = 0\\n        total = 0\\n        for a, t in customers:\\n            if endtime < a:\\n                total += t\\n                endtime = a + t\\n            else:\\n                total += (endtime - a) + t\\n                endtime = (endtime - a) + a + t\\n            print(total, endtime)\\n        return total / len(customers)\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341585,
                "title": "c-easy-understanding-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        double ans=0;\\n        long long time=0;\\n        vector<int> v;\\n        for(int i=0;i<customers.size();i++){\\n            int start=customers[i][0];\\n            int prep=customers[i][1];\\n            if(time<start){\\n                time=start;\\n                time=time+prep;\\n                v.push_back(time-start);\\n            }\\n            else{\\n                time=time+prep;\\n                v.push_back(time-start);\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            ans=ans+v[i];\\n        }\\n        ans=ans/v.size();\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        double ans=0;\\n        long long time=0;\\n        vector<int> v;\\n        for(int i=0;i<customers.size();i++){\\n            int start=customers[i][0];\\n            int prep=customers[i][1];\\n            if(time<start){\\n                time=start;\\n                time=time+prep;\\n                v.push_back(time-start);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3340972,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n       double sol = 0; \\n       int chef = 0;\\n       for(int i = 0;i<c.size();i++){\\n           chef = max(chef,c[i][0]);\\n           sol += chef+c[i][1]-c[i][0];\\n           chef+=c[i][1];\\n        }\\n        return sol/c.size();\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& c) {\\n       double sol = 0; \\n       int chef = 0;\\n       for(int i = 0;i<c.size();i++){\\n           chef = max(chef,c[i][0]);\\n           sol += chef+c[i][1]-c[i][0];\\n           chef+=c[i][1];\\n        }\\n        return sol/c.size();\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334530,
                "title": "c-concise-code-with-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWait time of a customer is the finish time minus the arrival time for the customer. But this happens if the chef starts preparing food upon arrival of the customer which is definitely not the case. Chef starts preparing food for the customer when it finishes preparing for the previous customer. The new cutomer needs to wait more if it arrives before the chef finish preparing food for earlier customer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom the above intuition the start time for a customer is the max of arrival time of the customer or the finish time of earlier customer. the finish time if current customer is the start time plus the preparation time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double wait_t = 0;\\n        int finish_t = 0;\\n        for(int i=0; i<customers.size(); i++) {\\n            int arr_t = customers[i][0];\\n            int start_t = arr_t >= finish_t ? arr_t : finish_t;\\n            finish_t = start_t + customers[i][1];\\n            wait_t += finish_t - arr_t;\\n        }\\n        return wait_t/customers.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        double wait_t = 0;\\n        int finish_t = 0;\\n        for(int i=0; i<customers.size(); i++) {\\n            int arr_t = customers[i][0];\\n            int start_t = arr_t >= finish_t ? arr_t : finish_t;\\n            finish_t = start_t + customers[i][1];\\n            wait_t += finish_t - arr_t;\\n        }\\n        return wait_t/customers.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333882,
                "title": "python-faster-than-96-beginners-pov",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        waiting = 0  # variable to store the total waiting time of all customers\\n        time = customers[0][0]  # set the current time to the first customer\\'s arrival time\\n        custo = 0  # counter to keep track of the number of customers\\n        \\n        for arrival, prep in customers:  # loop through all customers\\n            if arrival < time:  # if customer arrives before the previous customer\\'s order is ready\\n                time = (time - arrival) + prep + arrival  # add the waiting time, preparation time and arrival time\\n                waiting += (time - arrival)  # add the waiting time of this customer to the total waiting time\\n                \\n            if arrival >= time:  # if customer arrives after the previous customer\\'s order is ready\\n                time = arrival + prep  # set the current time to the arrival time plus the preparation time\\n                waiting += (time - arrival)  # add the waiting time of this customer to the total waiting time\\n            custo += 1  # increment the customer counter\\n\\n        return (waiting) / custo  # calculate and return the average waiting time of all customers\\n\\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        waiting = 0  # variable to store the total waiting time of all customers\\n        time = customers[0][0]  # set the current time to the first customer\\'s arrival time\\n        custo = 0  # counter to keep track of the number of customers\\n        \\n        for arrival, prep in customers:  # loop through all customers\\n            if arrival < time:  # if customer arrives before the previous customer\\'s order is ready\\n                time = (time - arrival) + prep + arrival  # add the waiting time, preparation time and arrival time\\n                waiting += (time - arrival)  # add the waiting time of this customer to the total waiting time\\n                \\n            if arrival >= time:  # if customer arrives after the previous customer\\'s order is ready\\n                time = arrival + prep  # set the current time to the arrival time plus the preparation time\\n                waiting += (time - arrival)  # add the waiting time of this customer to the total waiting time\\n            custo += 1  # increment the customer counter\\n\\n        return (waiting) / custo  # calculate and return the average waiting time of all customers\\n\\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319509,
                "title": "time-o-n-space-o-1",
                "content": "# Intuition\\nScan left to right and carry over the time when the chef can start again.\\nAccumulate the total waiting times along with the number of customers, so that it could compute a running average.\\nJust compute the average at the end.\\nOne caveat: will need to convert to longs to avoid an overflow\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nobject Solution {\\n    def averageWaitingTime(customers: Array[Array[Int]]): Double = {\\n        val (w, c, _) = customers.foldLeft((0L, 0L, 0L)) {\\n            case ((totalWait, totalCustomers, readyAt), a) =>\\n                val customerArrivesAt = a.head.toLong\\n                val timeToPrepare = a.last.toLong\\n                val startAt = Math.max(readyAt, customerArrivesAt)\\n                val nextReadyAt = startAt + timeToPrepare\\n                val customerWaits = nextReadyAt - customerArrivesAt\\n                (totalWait + customerWaits, totalCustomers + 1, nextReadyAt)\\n        }\\n        w.toDouble / c\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def averageWaitingTime(customers: Array[Array[Int]]): Double = {\\n        val (w, c, _) = customers.foldLeft((0L, 0L, 0L)) {\\n            case ((totalWait, totalCustomers, readyAt), a) =>\\n                val customerArrivesAt = a.head.toLong\\n                val timeToPrepare = a.last.toLong\\n                val startAt = Math.max(readyAt, customerArrivesAt)\\n                val nextReadyAt = startAt + timeToPrepare\\n                val customerWaits = nextReadyAt - customerArrivesAt\\n                (totalWait + customerWaits, totalCustomers + 1, nextReadyAt)\\n        }\\n        w.toDouble / c\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3306372,
                "title": "2ms-bets-100-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n\\n    long sum=0;\\n\\n    int currentTime=0;\\n\\n    for(int i=0;i<customers.length;i++){\\n\\n    if(customers[i][0]>currentTime){\\n        currentTime=customers[i][0];\\n    }\\n\\n    currentTime+=customers[i][1];\\n\\n    sum+=(currentTime-customers[i][0]);\\n    \\n    }\\n\\n    double ans=(double)sum/customers.length;\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n\\n    long sum=0;\\n\\n    int currentTime=0;\\n\\n    for(int i=0;i<customers.length;i++){\\n\\n    if(customers[i][0]>currentTime){\\n        currentTime=customers[i][0];\\n    }\\n\\n    currentTime+=customers[i][1];\\n\\n    sum+=(currentTime-customers[i][0]);\\n    \\n    }\\n\\n    double ans=(double)sum/customers.length;\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293281,
                "title": "python3-short-and-readable-solution-in-o-n-time-o-1-space",
                "content": "# Approach\\nWe loop from customer to customer and calculate the passed time between their arrivals. This time delta is subtracted from the remaining time required to process all pending orders. If we now add the necessary time for the new order to this result, we end up with the waiting time for the current customer. Ultimately, The sum of the waiting times is then divided by the number of customers, which is then returned.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: list[list[int]]) -> float:\\n        def calculate_elapsed_time(time_point1, time_point2):\\n            return abs(time_point1 - time_point2)\\n\\n        sum_of_waiting_times = customers[0][1]\\n        pending_execution_time = customers[0][1]\\n\\n        for i in range(1, len(customers)):\\n            pending_execution_time = max(\\n                pending_execution_time - calculate_elapsed_time(customers[i][0], customers[i - 1][0]), 0) + \\\\\\n                                     customers[i][1]\\n            sum_of_waiting_times += pending_execution_time\\n\\n        return sum_of_waiting_times / len(customers)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: list[list[int]]) -> float:\\n        def calculate_elapsed_time(time_point1, time_point2):\\n            return abs(time_point1 - time_point2)\\n\\n        sum_of_waiting_times = customers[0][1]\\n        pending_execution_time = customers[0][1]\\n\\n        for i in range(1, len(customers)):\\n            pending_execution_time = max(\\n                pending_execution_time - calculate_elapsed_time(customers[i][0], customers[i - 1][0]), 0) + \\\\\\n                                     customers[i][1]\\n            sum_of_waiting_times += pending_execution_time\\n\\n        return sum_of_waiting_times / len(customers)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278798,
                "title": "math-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int n = customers.length;\\n        double waitingTime = customers[0][1];\\n        int currentTime=customers[0][0]+customers[0][1];\\n        for(int i=1;i<n;i++){\\n           if(currentTime>=customers[i][0]){\\n               waitingTime += currentTime - customers[i][0] + customers[i][1];\\n               currentTime += customers[i][1];\\n           }\\n           else{\\n               waitingTime += customers[i][1];\\n               currentTime = customers[i][0]+customers[i][1];\\n           }\\n        }\\n        waitingTime/=(n/1.0);\\n        return waitingTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int n = customers.length;\\n        double waitingTime = customers[0][1];\\n        int currentTime=customers[0][0]+customers[0][1];\\n        for(int i=1;i<n;i++){\\n           if(currentTime>=customers[i][0]){\\n               waitingTime += currentTime - customers[i][0] + customers[i][1];\\n               currentTime += customers[i][1];\\n           }\\n           else{\\n               waitingTime += customers[i][1];\\n               currentTime = customers[i][0]+customers[i][1];\\n           }\\n        }\\n        waitingTime/=(n/1.0);\\n        return waitingTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277424,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int curr = 0;\\n        double totalWaitTime = 0;\\n        int n = customers.length;\\n        for(int[] customer: customers) {\\n            curr = Math.max(curr, customer[0]);\\n            curr += customer[1];\\n            totalWaitTime += (curr - customer[0]);\\n        }\\n        return totalWaitTime/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        int curr = 0;\\n        double totalWaitTime = 0;\\n        int n = customers.length;\\n        for(int[] customer: customers) {\\n            curr = Math.max(curr, customer[0]);\\n            curr += customer[1];\\n            totalWaitTime += (curr - customer[0]);\\n        }\\n        return totalWaitTime/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272488,
                "title": "very-easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:  \\n    double averageWaitingTime(vector<vector<int>>& customers) \\n    {\\n        double totalWait=0;\\n        int currTime=0;\\n        int n=customers.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            currTime=max(currTime,customers[x][0]);\\n            currTime+=customers[x][1];\\n            totalWait+=currTime-customers[x][0];\\n        }\\n        return totalWait/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:  \\n    double averageWaitingTime(vector<vector<int>>& customers) \\n    {\\n        double totalWait=0;\\n        int currTime=0;\\n        int n=customers.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            currTime=max(currTime,customers[x][0]);\\n            currTime+=customers[x][1];\\n            totalWait+=currTime-customers[x][0];\\n        }\\n        return totalWait/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263582,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n        \\n        var free = 0\\n        var wait = 0\\n\\n        for c in customers {\\n            wait += max(0, free - c[0]) + c[1]\\n            free = max(free, c[0]) + c[1]\\n        }\\n\\n        return Double(wait) / Double(customers.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n        \\n        var free = 0\\n        var wait = 0\\n\\n        for c in customers {\\n            wait += max(0, free - c[0]) + c[1]\\n            free = max(free, c[0]) + c[1]\\n        }\\n\\n        return Double(wait) / Double(customers.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261692,
                "title": "wrost-solution-ever-cant-believe-i-solved-it-hahahaha",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$          \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] a) {\\n        int duration=a[0][0]+a[0][1];\\n        double wt=a[0][1];\\n        double sum=wt;\\n        System.out.printf(\"%f\\\\n\",wt);\\n        for(int i=1;i<a.length;i++){\\n            if(a[i][0]<duration){\\n                duration=duration+a[i][1];\\n                wt=(duration-a[i][0]);\\n                sum+=wt;\\n            }\\n            else{\\n                duration=a[i][0]+a[i][1];\\n                wt=a[i][1];\\n                sum+=wt;\\n            }\\n            System.out.printf(\"%f %d\\\\n\",wt,duration);\\n        }\\n        System.out.printf(\"%d\\\\n%f\",a.length,sum);\\n        return (sum/a.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] a) {\\n        int duration=a[0][0]+a[0][1];\\n        double wt=a[0][1];\\n        double sum=wt;\\n        System.out.printf(\"%f\\\\n\",wt);\\n        for(int i=1;i<a.length;i++){\\n            if(a[i][0]<duration){\\n                duration=duration+a[i][1];\\n                wt=(duration-a[i][0]);\\n                sum+=wt;\\n            }\\n            else{\\n                duration=a[i][0]+a[i][1];\\n                wt=a[i][1];\\n                sum+=wt;\\n            }\\n            System.out.printf(\"%f %d\\\\n\",wt,duration);\\n        }\\n        System.out.printf(\"%d\\\\n%f\",a.length,sum);\\n        return (sum/a.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239859,
                "title": "easily-explained-simple-js-solution-129ms-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will solve the probem iteratively\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-Store the first customer\\'s totalFinishtime by adding arrival and prepare time.\\n-We will use an array to store all the waiting time.\\n-Start from index 1 to length-1.\\n-if the arrival time is greater than current totalFinishtime we will change totalFinishtime to addition of arrival and preperation time.\\n-else we will update the totalFinishtime by adding prepareTime to it.\\n-Now we will calculate the waiting time which is substraction of totalFinishtime and arrival time.\\n-Store the new waiting time to an array.\\n-Lastly return the average of elements in an array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} customers\\n * @return {number}\\n */\\nvar averageWaitingTime = function(customers) {\\n    let totalFinishTime = customers[0][0] + customers[0][1];\\n    let waitingTimeArr = [totalFinishTime - customers[0][0]];\\n    let waitingTime = 0;\\n    let arrivalTime = 0;\\n    let prepareTime = 0;\\n    for(let i=1; i<customers.length; i++)\\n    {\\n        arrivalTime = customers[i][0];\\n        prepareTime = customers[i][1]\\n        \\n        if(arrivalTime > totalFinishTime)\\n        {\\n            totalFinishTime = arrivalTime + prepareTime;\\n        }\\n        else\\n        {\\n            totalFinishTime += prepareTime;\\n        }\\n        waitingTime = totalFinishTime - arrivalTime;\\n        waitingTimeArr.push(waitingTime);\\n    }\\n    return (waitingTimeArr.reduce((a,b)=> a+b , 0) / waitingTimeArr.length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} customers\\n * @return {number}\\n */\\nvar averageWaitingTime = function(customers) {\\n    let totalFinishTime = customers[0][0] + customers[0][1];\\n    let waitingTimeArr = [totalFinishTime - customers[0][0]];\\n    let waitingTime = 0;\\n    let arrivalTime = 0;\\n    let prepareTime = 0;\\n    for(let i=1; i<customers.length; i++)\\n    {\\n        arrivalTime = customers[i][0];\\n        prepareTime = customers[i][1]\\n        \\n        if(arrivalTime > totalFinishTime)\\n        {\\n            totalFinishTime = arrivalTime + prepareTime;\\n        }\\n        else\\n        {\\n            totalFinishTime += prepareTime;\\n        }\\n        waitingTime = totalFinishTime - arrivalTime;\\n        waitingTimeArr.push(waitingTime);\\n    }\\n    return (waitingTimeArr.reduce((a,b)=> a+b , 0) / waitingTimeArr.length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227299,
                "title": "kotlin-lambda-solution",
                "content": "# Intuition\\n\\nKeep accumulating the waittime and then divide it by the number of `customers`.\\n\\nNote waittime needs to be `Long`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  fun averageWaitingTime(customers: Array<IntArray>): Double {\\n    var waittime = 0L\\n    return customers.fold(0) { chefReady, customer ->\\n      val finishtime = maxOf(chefReady, customer[0]) + customer[1]\\n      waittime += finishtime - customer[0]\\n      finishtime\\n    }.let { waittime.toDouble() / customers.size }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun averageWaitingTime(customers: Array<IntArray>): Double {\\n    var waittime = 0L\\n    return customers.fold(0) { chefReady, customer ->\\n      val finishtime = maxOf(chefReady, customer[0]) + customer[1]\\n      waittime += finishtime - customer[0]\\n      finishtime\\n    }.let { waittime.toDouble() / customers.size }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220558,
                "title": "python-two-cases-explained",
                "content": "Just two cases: (1) current_time > arrive time; (2) current_time <= arrive time\\n\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        total_waiting_time, cur_time = 0, 0\\n        for arr, cost in customers:\\n            if arr >= cur_time:\\n                total_waiting_time += cost\\n                cur_time = arr + cost\\n            else:\\n                total_waiting_time += cur_time - arr + cost\\n                cur_time += cost\\n        return total_waiting_time / len(customers)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        total_waiting_time, cur_time = 0, 0\\n        for arr, cost in customers:\\n            if arr >= cur_time:\\n                total_waiting_time += cost\\n                cur_time = arr + cost\\n            else:\\n                total_waiting_time += cur_time - arr + cost\\n                cur_time += cost\\n        return total_waiting_time / len(customers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214941,
                "title": "easy-and-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        long totalWaitingTime = 0;\\n        long startTime = 0;\\n        for(int i = 0; i < customers.length;i++)\\n        {\\n            if(startTime < customers[i][0])\\n            startTime = customers[i][0];\\n            startTime = startTime + customers[i][1];\\n            totalWaitingTime = totalWaitingTime + (startTime - customers[i][0]);\\n        }\\n        return totalWaitingTime*1.0/customers.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        long totalWaitingTime = 0;\\n        long startTime = 0;\\n        for(int i = 0; i < customers.length;i++)\\n        {\\n            if(startTime < customers[i][0])\\n            startTime = customers[i][0];\\n            startTime = startTime + customers[i][1];\\n            totalWaitingTime = totalWaitingTime + (startTime - customers[i][0]);\\n        }\\n        return totalWaitingTime*1.0/customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171381,
                "title": "concept-of-operating-system-non-preemptive-job-scheduling",
                "content": "# Approach\\nConcept of operating system // Non - Preemptive Scheduling \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] arr) {\\n        \\n        \\n        double timespan=0.0;\\n        double totalwait=0.0;\\n              \\n\\n        for(int i =0;i<arr.length;i++)\\n        {\\n            int at=arr[i][0];    //arrival time\\n            int bt=arr[i][1];    //burst time (time needed to complete)\\n                  \\n            if(timespan<at)\\n               timespan=at;\\n\\n             timespan+=bt;\\n\\n            // int wait=timespan-at;\\n            totalwait+=timespan-at;\\n        }\\n\\n       return totalwait/arr.length;\\n\\n     \\n    }\\n}\\n\\n// at (arival time );\\n// bt (burst time );\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "class Solution {\\n    public double averageWaitingTime(int[][] arr) {\\n        \\n        \\n        double timespan=0.0;\\n        double totalwait=0.0;\\n              \\n\\n        for(int i =0;i<arr.length;i++)\\n        {\\n            int at=arr[i][0];    //arrival time\\n            int bt=arr[i][1];    //burst time (time needed to complete)\\n                  \\n            if(timespan<at)\\n               timespan=at;\\n\\n             timespan+=bt;\\n\\n            // int wait=timespan-at;\\n            totalwait+=timespan-at;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3168617,
                "title": "98-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        int currTime = customers[0][0];\\n        double vals = customers[0][0] + customers[0][1] - currTime; \\n        currTime = customers[0][0] + customers[0][1];\\n        for(int i=1;i<customers.size();i++){\\n            if(currTime < customers[i][0]){\\n                currTime += (customers[i][0] + customers[i][1] - currTime);\\n            }else{\\n                currTime += customers[i][1];\\n            }\\n            vals += currTime - customers[i][0];\\n            \\n        }\\n        return vals / customers.size();\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        \\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        int currTime = customers[0][0];\\n        double vals = customers[0][0] + customers[0][1] - currTime; \\n        currTime = customers[0][0] + customers[0][1];\\n        for(int i=1;i<customers.size();i++){\\n            if(currTime < customers[i][0]){\\n                currTime += (customers[i][0] + customers[i][1] - currTime);\\n            }else{\\n                currTime += customers[i][1];\\n            }\\n            vals += currTime - customers[i][0];\\n            \\n        }\\n        return vals / customers.size();\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162463,
                "title": "java-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double sum = 0.0,time = 0.0,n = customers.length;\\n        for(int i = 0;i<customers.length;i++){\\n            if(time < customers[i][0])\\n                time = customers[i][0];\\n            time += customers[i][1];\\n            sum += time - customers[i][0];\\n        }\\n        return sum/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n        double sum = 0.0,time = 0.0,n = customers.length;\\n        for(int i = 0;i<customers.length;i++){\\n            if(time < customers[i][0])\\n                time = customers[i][0];\\n            time += customers[i][1];\\n            sum += time - customers[i][0];\\n        }\\n        return sum/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156815,
                "title": "easiest-python-solution",
                "content": "# Intuition\\nPython Solution in the easiest way possible\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        prev=0\\n        ans=0\\n        n=len(customers)\\n        for i in range(n):\\n            if prev and prev>customers[i][0]:\\n                a=prev-customers[i][0]+customers[i][1]\\n                ans+=a\\n                prev=customers[i][0]+a\\n            else:\\n                b=customers[i][0]+customers[i][1]\\n                ans+=customers[i][1]\\n                prev=b\\n        return ans/n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        prev=0\\n        ans=0\\n        n=len(customers)\\n        for i in range(n):\\n            if prev and prev>customers[i][0]:\\n                a=prev-customers[i][0]+customers[i][1]\\n                ans+=a\\n                prev=customers[i][0]+a\\n            else:\\n                b=customers[i][0]+customers[i][1]\\n                ans+=customers[i][1]\\n                prev=b\\n        return ans/n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130262,
                "title": "simple-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int a = customers[0][0] , n = customers.size();\\n\\n        for( int i =0; i< customers.size(); i++){\\n            customers[i][0]= customers[i][0]-a;\\n        }\\n        int curTime =0;\\n\\n        vector<int> comt;\\n        for( int i=0; i< customers.size(); i++){\\n            if( customers[i][0] < curTime){\\n                comt.push_back(curTime + customers[i][1]);\\n                curTime += customers[i][1];\\n            }\\n            else if( customers[i][0] == curTime){\\n                curTime += customers[i][1];\\n                comt.push_back(curTime);\\n\\n\\n            }\\n            else{\\n                comt.push_back(customers[i][0]+customers[i][1]);\\n                curTime =customers[i][0]+customers[i][1];\\n\\n            }\\n\\n\\n        }\\n\\n        // for(int i=0; i< n; i++){\\n        //     cout<<comt[i]<<\" \";\\n        // }\\n\\n        double ans =0;\\n        for( int i=0; i< n; i++){\\n            ans += comt[i]-customers[i][0];\\n        }\\n        return ans/n;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int a = customers[0][0] , n = customers.size();\\n\\n        for( int i =0; i< customers.size(); i++){\\n            customers[i][0]= customers[i][0]-a;\\n        }\\n        int curTime =0;\\n\\n        vector<int> comt;\\n        for( int i=0; i< customers.size(); i++){\\n            if( customers[i][0] < curTime){\\n                comt.push_back(curTime + customers[i][1]);\\n                curTime += customers[i][1];\\n            }\\n            else if( customers[i][0] == curTime){\\n                curTime += customers[i][1];\\n                comt.push_back(curTime);\\n\\n\\n            }\\n            else{\\n                comt.push_back(customers[i][0]+customers[i][1]);\\n                curTime =customers[i][0]+customers[i][1];\\n\\n            }\\n\\n\\n        }\\n\\n        // for(int i=0; i< n; i++){\\n        //     cout<<comt[i]<<\" \";\\n        // }\\n\\n        double ans =0;\\n        for( int i=0; i< n; i++){\\n            ans += comt[i]-customers[i][0];\\n        }\\n        return ans/n;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3091309,
                "title": "understandable-solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n       double sum=0;\\n        double currTime=customers[0][0];\\n        for(int i=0;i<customers.length;i++){\\n            if(currTime<customers[i][0]){\\n                currTime=customers[i][0];\\n            }\\n            currTime=currTime +customers[i][1];\\n            sum=sum+(currTime-customers[i][0]);\\n        }\\n        return sum/customers.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) {\\n       double sum=0;\\n        double currTime=customers[0][0];\\n        for(int i=0;i<customers.length;i++){\\n            if(currTime<customers[i][0]){\\n                currTime=customers[i][0];\\n            }\\n            currTime=currTime +customers[i][1];\\n            sum=sum+(currTime-customers[i][0]);\\n        }\\n        return sum/customers.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069680,
                "title": "simple-python-solution-o-n-o-1",
                "content": "\\n\\n# Approach\\nCurrent elapsed time is stored in variable time. For each customer time becomes either \"arrival time (arr) + preparation time (t)\" (if customer arrives when cook is idle) or time increases by \"preparation time (t)\" (if cook is busy). We count how many minutes each customer waited by comparing time after dish is served to the arrival time.\\nFinally average is calculated as: waited / len(customers).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n\\n        time, waited = 0,0\\n        for arr,t in customers:\\n            time = max(arr+t,time+t)\\n            waited += time-arr\\n\\n        return waited / len(customers)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n\\n        time, waited = 0,0\\n        for arr,t in customers:\\n            time = max(arr+t,time+t)\\n            waited += time-arr\\n\\n        return waited / len(customers)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067530,
                "title": "python-simple-intuitive-solution-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### Idea: we prepare the meal one by one.\\nWe have to look at each customer at least once to calculate the average waiting time. Consequently, the best time complexity we can get is at least linear O(n). \\nTherefore, preparing the meal one by one, which is also linear, is likely an optimal solution considering time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the arrival time is sorted, we serve customers by the order of the index (a loop iterating through each customer). We will keep track of the current time `time`, advance the time to when the customer gets served, and derive the waiting time from it. \\nWe will store the waiting time into a total sum `total`, and calculate the average from the sum `total / len(customers)`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, every customer is looked at once, linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$, we only store constant space of information.\\n\\n# Code\\n```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        total = 0\\n        time = 0\\n        for arrival, t in customers:\\n            time = max(arrival, time) # advance to the time we start preparing the meal\\n            time += t # the meal is finished at this new time\\n            total += time - arrival # store the waiting time\\n        return total / len(customers)\\n            \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def averageWaitingTime(self, customers: List[List[int]]) -> float:\\n        total = 0\\n        time = 0\\n        for arrival, t in customers:\\n            time = max(arrival, time) # advance to the time we start preparing the meal\\n            time += t # the meal is finished at this new time\\n            total += time - arrival # store the waiting time\\n        return total / len(customers)\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065559,
                "title": "java-100-faster-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) \\n    {\\n        int tt = customers[0][0] + customers[0][1];\\n        double sum=customers[0][1];\\n\\n        for(int i=1;i<customers.length;i++)\\n        {\\n            if(customers[i][0]>tt)\\n            {\\n                tt = customers[i][0]+customers[i][1];\\n            }\\n            else tt = customers[i][1] +tt;\\n            sum = sum+ tt-customers[i][0];\\n        }   \\n\\n        return sum/customers.length;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double averageWaitingTime(int[][] customers) \\n    {\\n        int tt = customers[0][0] + customers[0][1];\\n        double sum=customers[0][1];\\n\\n        for(int i=1;i<customers.length;i++)\\n        {\\n            if(customers[i][0]>tt)\\n            {\\n                tt = customers[i][0]+customers[i][1];\\n            }\\n            else tt = customers[i][1] +tt;\\n            sum = sum+ tt-customers[i][0];\\n        }   \\n\\n        return sum/customers.length;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058014,
                "title": "easy-c-solution-runtime-221-ms-beats-90-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe attend to each customer as they enter in, ```time += customers[i][1];```\\nplease bear in mind the time they enter maybe greater then the total time we have spent so far. Hence we handle that.\\n```\\nif(customers[i][0] + customers[i][1] > time)\\n        time = customers[i][0] + customers[i][1];\\n```\\nThen we add up the waiting time for that customer ```waitingTime += (time - customers[i][0]);``` Then take the average at the end.\\n\\n\\n# Complexity\\n- Time complexity:** O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        long long time = customers[0][0], waitingTime = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            time += customers[i][1];\\n            if(customers[i][0] + customers[i][1] > time)\\n                time = customers[i][0] + customers[i][1];\\n            waitingTime += (time - customers[i][0]);\\n        }\\n        return static_cast<double>(waitingTime)/n;\\n    }\\n};\\n```\\n**Please upvote if you find it helpful in anyway!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```time += customers[i][1];```\n```\\nif(customers[i][0] + customers[i][1] > time)\\n        time = customers[i][0] + customers[i][1];\\n```\n```waitingTime += (time - customers[i][0]);```\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& customers) {\\n        int n = customers.size();\\n        long long time = customers[0][0], waitingTime = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            time += customers[i][1];\\n            if(customers[i][0] + customers[i][1] > time)\\n                time = customers[i][0] + customers[i][1];\\n            waitingTime += (time - customers[i][0]);\\n        }\\n        return static_cast<double>(waitingTime)/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046693,
                "title": "very-simple-math-problem-c",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& cou) {\\n        double ans = cou[0][1];\\n        int ltime = cou[0][0] + cou[0][1];\\n        for(int i=1;i<cou.size();i++){\\n            // we have to calculate for next meal to prepare\\n            ans += (cou[i][0] >= ltime ? 0 : ltime - cou[i][0]) + cou[i][1];\\n            if(ltime < cou[i][0]) ltime = cou[i][0];\\n            ltime += cou[i][1]; \\n        }\\n        return (ans/cou.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double averageWaitingTime(vector<vector<int>>& cou) {\\n        double ans = cou[0][1];\\n        int ltime = cou[0][0] + cou[0][1];\\n        for(int i=1;i<cou.size();i++){\\n            // we have to calculate for next meal to prepare\\n            ans += (cou[i][0] >= ltime ? 0 : ltime - cou[i][0]) + cou[i][1];\\n            if(ltime < cou[i][0]) ltime = cou[i][0];\\n            ltime += cou[i][1]; \\n        }\\n        return (ans/cou.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036932,
                "title": "swift-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n        var currentTime = 0\\n        var totalWaitingTime = 0\\n\\n        customers.map {\\n            if currentTime == 0 {\\n                 currentTime = $0[0] + $0[1]\\n                 totalWaitingTime = currentTime - $0[0]\\n            } else {\\n                if currentTime >= $0[0]\\xA0{\\n                    currentTime += $0[1]\\n                    totalWaitingTime += currentTime - $0[0]\\n                } else {\\n                    currentTime = $0[0] + $0[1] \\n                    totalWaitingTime += $0[1]  \\n                }\\n            }\\n            \\n        }\\n        return Double(totalWaitingTime)/Double(customers.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func averageWaitingTime(_ customers: [[Int]]) -> Double {\\n        var currentTime = 0\\n        var totalWaitingTime = 0\\n\\n        customers.map {\\n            if currentTime == 0 {\\n                 currentTime = $0[0] + $0[1]\\n                 totalWaitingTime = currentTime - $0[0]\\n            } else {\\n                if currentTime >= $0[0]\\xA0{\\n                    currentTime += $0[1]\\n                    totalWaitingTime += currentTime - $0[0]\\n                } else {\\n                    currentTime = $0[0] + $0[1] \\n                    totalWaitingTime += $0[1]  \\n                }\\n            }\\n            \\n        }\\n        return Double(totalWaitingTime)/Double(customers.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1830734,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "This reminds me of Process Scheduling in Operating Systems course. FCFS protocol"
                    },
                    {
                        "username": "vivekup3424",
                        "content": "Yeah I also studied about it in my second year."
                    }
                ]
            }
        ]
    }
]