[
    {
        "title": "Form Array by Concatenating Subarrays of Another Array",
        "question_content": "You are given a 2D integer array groups of length n. You are also given an integer array nums.\nYou are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).\nReturn true if you can do this task, and false otherwise.\nNote that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\nOutput: true\nExplanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].\nThese subarrays are disjoint as they share no common nums[k] element.\n\nExample 2:\n\nInput: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\nOutput: false\nExplanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.\n[10,-2] must come before [1,2,3,4].\n\nExample 3:\n\nInput: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\nOutput: false\nExplanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.\nThey share a common elements nums[4] (0-indexed).\n\n&nbsp;\nConstraints:\n\n\tgroups.length == n\n\t1 <= n <= 103\n\t1 <= groups[i].length, sum(groups[i].length) <= 103\n\t1 <= nums.length <= 103\n\t-107 <= groups[i][j], nums[k] <= 107",
        "solutions": [
            {
                "id": 1074558,
                "title": "c-fast-solution-with-explanation-comments",
                "content": "Since every group must match a subarray (continguous), any time we have a mismatch we need to restart matching that group.\\n\\nWhen we have a mismatch, the element from `nums` array must be reconsidered as the first element of the current group.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums)\\n    {\\n        int numsIndex = 0;\\n        int groupsIndex = 0;\\n        \\n        while (numsIndex < nums.size() && groupsIndex < groups.size())\\n        {\\n\\t\\t\\t// Try to match as many members of the current group as possible\\n            int matchCount = 0;\\n            while (numsIndex + matchCount < nums.size() &&\\n                   matchCount < groups[groupsIndex].size() &&\\n                   nums[numsIndex + matchCount] == groups[groupsIndex][matchCount])\\n                ++matchCount;\\n            \\n\\t\\t\\t// Did we match the entire current group?\\n            if (matchCount == groups[groupsIndex].size())\\n            {\\n\\t\\t\\t\\t// the group was matched\\n                ++groupsIndex;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// since there must not be overlap between groups\\n\\t\\t\\t\\t// we must match the next group at next element in nums\\n                numsIndex += matchCount;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// unsucessful in matching all elements of current group\\n\\t\\t\\t\\t// retry matching the group from start at next element in nums\\n                ++numsIndex;\\n            }\\n        }\\n        \\n        return groupsIndex == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums)\\n    {\\n        int numsIndex = 0;\\n        int groupsIndex = 0;\\n        \\n        while (numsIndex < nums.size() && groupsIndex < groups.size())\\n        {\\n\\t\\t\\t// Try to match as many members of the current group as possible\\n            int matchCount = 0;\\n            while (numsIndex + matchCount < nums.size() &&\\n                   matchCount < groups[groupsIndex].size() &&\\n                   nums[numsIndex + matchCount] == groups[groupsIndex][matchCount])\\n                ++matchCount;\\n            \\n\\t\\t\\t// Did we match the entire current group?\\n            if (matchCount == groups[groupsIndex].size())\\n            {\\n\\t\\t\\t\\t// the group was matched\\n                ++groupsIndex;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// since there must not be overlap between groups\\n\\t\\t\\t\\t// we must match the next group at next element in nums\\n                numsIndex += matchCount;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// unsucessful in matching all elements of current group\\n\\t\\t\\t\\t// retry matching the group from start at next element in nums\\n                ++numsIndex;\\n            }\\n        }\\n        \\n        return groupsIndex == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074555,
                "title": "python3-check-group-one-by-one",
                "content": "\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        for grp in groups: \\n            for ii in range(i, len(nums)):\\n                if nums[ii:ii+len(grp)] == grp: \\n                    i = ii + len(grp)\\n                    break \\n            else: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        for grp in groups: \\n            for ii in range(i, len(nums)):\\n                if nums[ii:ii+len(grp)] == grp: \\n                    i = ii + len(grp)\\n                    break \\n            else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074554,
                "title": "simple-cpp-solution-using-stl-search-function",
                "content": "search for each group in nums array and update the starting iterator simultaneiusly and if at any instant we do not get the group in nums array simply return false. else continue until do no get all groups and return true..\\nhope below given code will help you !!!\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>::iterator itr=nums.begin();\\n        for (int i=0;i<groups.size();i++)\\n        {\\n            itr=search(itr,nums.end(),groups[i].begin(),groups[i].end());\\n            if (itr==nums.end())\\n                return false;\\n            else itr=itr+groups[i].size();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>::iterator itr=nums.begin();\\n        for (int i=0;i<groups.size();i++)\\n        {\\n            itr=search(itr,nums.end(),groups[i].begin(),groups[i].end());\\n            if (itr==nums.end())\\n                return false;\\n            else itr=itr+groups[i].size();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074946,
                "title": "c-simple-search-kmp",
                "content": "I am still not sure whether we can use the \"disjoint\" property to speed-up the search...\\n\\n> Update 1: OJ does not seem to enforce \"disjoint\" property, so we can get rid of the check.\\n\\n> Update 2: See KMP-based solution below!\\n\\nThe approach below just check that groups does not have overapping elements, and does the basic search. It works since `n` is limited to `1000`. \\n\\n> Note that we only need to find the first (earliest) occurence of the group. No need to search further.\\n```cpp\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n```\\n**KMP**\\nKMP does not seem to help the runtime due to test cases and constraint. I think that LeetCode wasted a good problem by making in Easy by relaxing the constraints.\\n\\nBut nonetheless - you should use KMP where you can to reduce runtime from `m * n` to `m + n`.\\n\\n```cpp\\nvector<int> buildPrefix(vector<int> &v) {\\n    vector<int> kmp(v.size() + 1);\\n    for (int slow = 0, fast = 1; fast < v.size(); ++fast) {\\n        if (v[slow] == v[fast]) {\\n            kmp[fast + 1] = ++slow;\\n        }\\n        else if (slow != 0) {\\n            slow = kmp[slow];\\n            --fast;\\n        }\\n    }    \\n    return kmp;\\n}\\nbool canChoose(vector<vector<int>>& g, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= g.size())\\n        return true;\\n    auto kmp = buildPrefix(g[i]);\\n    for (int k = 0; j <= nums.size() - g[i].size(); ++k) {\\n        if (k == g[i].size())\\n            return canChoose(g, nums, i + 1, j + k);   \\n        if (nums[j + k] != g[i][k]) {\\n            j += max(1, k - kmp[k]);\\n            k = kmp[k] - 1;            \\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n```\n```cpp\\nvector<int> buildPrefix(vector<int> &v) {\\n    vector<int> kmp(v.size() + 1);\\n    for (int slow = 0, fast = 1; fast < v.size(); ++fast) {\\n        if (v[slow] == v[fast]) {\\n            kmp[fast + 1] = ++slow;\\n        }\\n        else if (slow != 0) {\\n            slow = kmp[slow];\\n            --fast;\\n        }\\n    }    \\n    return kmp;\\n}\\nbool canChoose(vector<vector<int>>& g, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= g.size())\\n        return true;\\n    auto kmp = buildPrefix(g[i]);\\n    for (int k = 0; j <= nums.size() - g[i].size(); ++k) {\\n        if (k == g[i].size())\\n            return canChoose(g, nums, i + 1, j + k);   \\n        if (nums[j + k] != g[i][k]) {\\n            j += max(1, k - kmp[k]);\\n            k = kmp[k] - 1;            \\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074593,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int i=0;\\n        for(int start =0;i < groups.length && groups[i].length+start <= nums.length;start++)\\n            if(search(groups[i], nums, start)) \\n                start += groups[i++].length - 1;\\n        return i==groups.length;\\n    }\\n    private boolean search(int[] group, int[] nums, int start) {\\n        for(int i=0;i<group.length;i++) \\n            if(group[i] != nums[i+start])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int i=0;\\n        for(int start =0;i < groups.length && groups[i].length+start <= nums.length;start++)\\n            if(search(groups[i], nums, start)) \\n                start += groups[i++].length - 1;\\n        return i==groups.length;\\n    }\\n    private boolean search(int[] group, int[] nums, int start) {\\n        for(int i=0;i<group.length;i++) \\n            if(group[i] != nums[i+start])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074665,
                "title": "kmp-java-o-n-m",
                "content": "m: nums.length\\nn: the number of elements in groups;\\nTime: O(m+n)\\nSpace: O(n)\\n```\\n  \\n    private boolean sln2(int[][] groups, int[] nums){\\n        int n = groups.length;\\n        int m = nums.length;\\n        \\n        int[][] prefixes = new int[n][];\\n        for(int i = 0;i<n;i++) prefixes[i] = getPrefix(groups[i]);\\n        int j = 0;\\n        for(int i = 0;i< m && j<n;){\\n            int index = search(nums, groups[j], prefixes[j], i);\\n            if(index<0) return false;\\n            j++;\\n            i = index;\\n        }\\n        return j==n;\\n    }\\n    \\n    private int[] getPrefix(int[] arr){\\n        int n = arr.length;\\n        int[] res = new int[n];\\n        for(int i = 1, j =0; i<n;){\\n            if(arr[i] == arr[j]){\\n                res[i]  = j+1;\\n                i++;j++;\\n            }else if(j>0){\\n                j = res[j-1];\\n            }else{\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int search(int[] arr1, int[] arr2, int[] prefix, int startIndex){\\n        int m = arr1.length;\\n        int n = arr2.length;\\n        for(int i = startIndex, j = 0; i<m;){\\n            if(arr1[i] == arr2[j]){\\n                i++;j++;\\n            }else if(j>0){\\n                j = prefix[j-1];\\n            }else{\\n                i++;\\n            }\\n            \\n            if(j==n) return i;\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [],
                "code": "m: nums.length\\nn: the number of elements in groups;\\nTime: O(m+n)\\nSpace: O(n)\\n```\\n  \\n    private boolean sln2(int[][] groups, int[] nums){\\n        int n = groups.length;\\n        int m = nums.length;\\n        \\n        int[][] prefixes = new int[n][];\\n        for(int i = 0;i<n;i++) prefixes[i] = getPrefix(groups[i]);\\n        int j = 0;\\n        for(int i = 0;i< m && j<n;){\\n            int index = search(nums, groups[j], prefixes[j], i);\\n            if(index<0) return false;\\n            j++;\\n            i = index;\\n        }\\n        return j==n;\\n    }\\n    \\n    private int[] getPrefix(int[] arr){\\n        int n = arr.length;\\n        int[] res = new int[n];\\n        for(int i = 1, j =0; i<n;){\\n            if(arr[i] == arr[j]){\\n                res[i]  = j+1;\\n                i++;j++;\\n            }else if(j>0){\\n                j = res[j-1];\\n            }else{\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int search(int[] arr1, int[] arr2, int[] prefix, int startIndex){\\n        int m = arr1.length;\\n        int n = arr2.length;\\n        for(int i = startIndex, j = 0; i<m;){\\n            if(arr1[i] == arr2[j]){\\n                i++;j++;\\n            }else if(j>0){\\n                j = prefix[j-1];\\n            }else{\\n                i++;\\n            }\\n            \\n            if(j==n) return i;\\n        }\\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1074549,
                "title": "simple-java-solution-commented",
                "content": "```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        int grpIndex = 0;\\n\\n        for(int i = 0; i < nums.length && grpIndex < groups.length; i++) {\\n            if(nums[i] == groups[grpIndex][0]) {\\n\\t\\t\\t// First element of group matched\\n                int j = i;\\n                int x = 0;\\n\\t\\t\\t\\t// check if the remaining elements are also matching\\n                while(j < nums.length && x < groups[grpIndex].length && nums[j] == groups[grpIndex][x]) {\\n                    j++;\\n                    x++;\\n                }\\n                if(x == groups[grpIndex].length) {\\n\\t\\t\\t\\t\\t// all digits matched. This is a valid group. check the next one.\\n                    grpIndex++;\\n                    i = j - 1; // i will be incremented by the for loop, so one char will get missed. This will avoid that\\n                }\\n            }\\n        }\\n\\n        return grpIndex == groups.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        int grpIndex = 0;\\n\\n        for(int i = 0; i < nums.length && grpIndex < groups.length; i++) {\\n            if(nums[i] == groups[grpIndex][0]) {\\n\\t\\t\\t// First element of group matched\\n                int j = i;\\n                int x = 0;\\n\\t\\t\\t\\t// check if the remaining elements are also matching\\n                while(j < nums.length && x < groups[grpIndex].length && nums[j] == groups[grpIndex][x]) {\\n                    j++;\\n                    x++;\\n                }\\n                if(x == groups[grpIndex].length) {\\n\\t\\t\\t\\t\\t// all digits matched. This is a valid group. check the next one.\\n                    grpIndex++;\\n                    i = j - 1; // i will be incremented by the for loop, so one char will get missed. This will avoid that\\n                }\\n            }\\n        }\\n\\n        return grpIndex == groups.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074544,
                "title": "c-kmp-solution-o-m-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //Idea is to use KMP Longest Prefix Suffix array to match if one array is subarray of another array.\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int m = nums.size();\\n        int index = 0;\\n        for(auto group : groups){\\n            int n = group.size();\\n            //Step-1 Generate LPS\\n            vector<int>lps(n,0);\\n            for(int i = 1;i<n; i++){\\n                int j = lps[i-1];\\n                while(j>0 && group[i] != group[j]){\\n                    j = lps[j-1];\\n                }\\n                if(group[i] == group[j]){\\n                    j++;\\n                }\\n                lps[i] = j;\\n            }\\n            \\n            //Step 2 - Matching\\n            int j = 0;\\n            while(index<m){\\n                if(nums[index]==group[j]){\\n                    j++;\\n                    index++;\\n                }\\n                if(j==n)\\n                    break;\\n                else\\n                 if(index <m && nums[index] != group[j]){\\n                    if(j >0){\\n                        j=lps[j-1];\\n                    }else{\\n                        index++;\\n                    }\\n                }\\n            }\\n            if(j != n)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea is to use KMP Longest Prefix Suffix array to match if one array is subarray of another array.\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int m = nums.size();\\n        int index = 0;\\n        for(auto group : groups){\\n            int n = group.size();\\n            //Step-1 Generate LPS\\n            vector<int>lps(n,0);\\n            for(int i = 1;i<n; i++){\\n                int j = lps[i-1];\\n                while(j>0 && group[i] != group[j]){\\n                    j = lps[j-1];\\n                }\\n                if(group[i] == group[j]){\\n                    j++;\\n                }\\n                lps[i] = j;\\n            }\\n            \\n            //Step 2 - Matching\\n            int j = 0;\\n            while(index<m){\\n                if(nums[index]==group[j]){\\n                    j++;\\n                    index++;\\n                }\\n                if(j==n)\\n                    break;\\n                else\\n                 if(index <m && nums[index] != group[j]){\\n                    if(j >0){\\n                        j=lps[j-1];\\n                    }else{\\n                        index++;\\n                    }\\n                }\\n            }\\n            if(j != n)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336560,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        ln=len(groups)\\n        idx=0\\n        for i in groups:\\n            for j in range(idx,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    idx=j+len(i)\\n                    ln-=1\\n                    break\\n        return ln==0\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        ln=len(groups)\\n        idx=0\\n        for i in groups:\\n            for j in range(idx,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    idx=j+len(i)\\n                    ln-=1\\n                    break\\n        return ln==0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074759,
                "title": "simple-c-solution",
                "content": "```\\n  bool canChoose(vector<vector<int>>& g, vector<int>& v) \\n    {\\n        int start=0;\\n        int i=0;\\n        int cnt=0;\\n        \\n        while(i<g.size() and start < v.size())\\n        {\\n           bool flage=false; // to check if from the start point if array is find or not\\n           for(int k=0;k<g[i].size();k++){\\n               if(g[i][k]!=v[start+k]){\\n                   flage=true;\\n                   break;\\n               }\\n           }\\n           if(flage==false){ // if we found the array then make start as start+g[i].size() and to take next array by doing i++ and also just take cnt var to cnt the number of find array in that \\n               start=start+g[i].size();\\n               i++;\\n               cnt++;\\n           }\\n           else //suppose we did not find the required array from present start point then increase the start by 1\\n              start++;\\n        }\\n        if(cnt==g.size())\\n            return true;\\n        return false;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  bool canChoose(vector<vector<int>>& g, vector<int>& v) \\n    {\\n        int start=0;\\n        int i=0;\\n        int cnt=0;\\n        \\n        while(i<g.size() and start < v.size())\\n        {\\n           bool flage=false; // to check if from the start point if array is find or not\\n           for(int k=0;k<g[i].size();k++){\\n               if(g[i][k]!=v[start+k]){\\n                   flage=true;\\n                   break;\\n               }\\n           }\\n           if(flage==false){ // if we found the array then make start as start+g[i].size() and to take next array by doing i++ and also just take cnt var to cnt the number of find array in that \\n               start=start+g[i].size();\\n               i++;\\n               cnt++;\\n           }\\n           else //suppose we did not find the required array from present start point then increase the start by 1\\n              start++;\\n        }\\n        if(cnt==g.size())\\n            return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363974,
                "title": "c-two-approach-two-pointer-o-m-n-kmp-o-m-n",
                "content": "This problem is easy if we do it using two pointers. This approach becomes brute force which can be done in O(m * n) time complexity. Another approach is using KMP algorithm which subsequently reduces the time complexity from M * N to M + N. \\n\\n#### Method 1 : Two pointers\\n\\nWe take two pointer variables, one for the `nums` vector, another for the `groups` vectors. Now, we find each of the group vector into nums one by one and if we manage to find all of them in `nums`, we can return `true` else we return `false`; The implementation of this method is simple. We iterate nums with `i` and groups with `idx` and each time we get a match, we check the next subarray if it is equal to groups[idx] or not. If it is equal, we move ahead else we break and look for next match.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0, i=0;\\n        while(idx<groups.size() and i<nums.size()){\\n            if(groups[idx][0]==nums[i]){\\n                int j = 0, k=i;\\n                for(; k<nums.size() and j<groups[idx].size(); k++){\\n                    if(groups[idx][j] == nums[k]) j++;\\n                    else break;\\n                }\\n                if(j==groups[idx].size()) idx++, i=k;\\n                else i++;\\n            }\\n            else i++;\\n        }\\n        return idx == groups.size();\\n    }\\n};\\n```\\n\\n#### Method 2 : KMP\\nThis method is a bit tricky to catch. What we do is, we find the LPS array of `nums` and store it in a vector named `pi`.  Now for each group vector in `groups`, we check if this vector can be found in nums using this LPS. Now on first look, the code might look like O(m * n) but it is not. This is because in above algorithm, if we match the first character, we iterate over next `group[idx].size()-1` characters and check if they match with the characters in `nums`. Now if they match, its ok, but if they dont match, we break the loop and just move the `nums` pointer by 1. \\n**BUT**\\nIn below method, using KMP, if we find a mismatch, we dont just move the nums pointer by 1, instead we use the LPS array to move backwards, and we only go till the point where we are getting a mismatch. That\\'s what KMP does. It restricts us to move backwards once we get a common subarray. Thus, if at any point, we can\\'t move back, then only, we increase our `nums` pointer by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0;\\n\\t\\tvector <int> pi = kmp(nums);\\n            \\n        for(auto group : groups){\\n            int j = 0;\\n\\t\\t\\t// We can see that idx never comes backwards. So we are traversing nums only once. \\n            while(idx<nums.size() and j<group.size()){\\n\\t\\t\\t\\t// If both elements match, we move both pointers.\\n                if(nums[idx]==group[j]) {\\n                    j++, idx++;\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// In case of mismatch, we come backwards upto the point where elements are not matching. \\n                    if(j>0) j = pi[j-1];\\n                    else{\\n\\t\\t\\t\\t\\t\\t// If we can\\'t go backwards, we move the nums pointer forward. \\n                        idx++;\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If nums is finished before groups, we return false\\n            if(j<group.size() and idx==nums.size()) return false;\\n        }\\n        return true;\\n    }\\nprotected:\\n\\t// Standard KMP function\\n    vector <int> kmp(vector <int> &str){\\n        vector <int> pi(str.size()+5,0);\\n        for(int i = 1; i<str.size(); i++){\\n            int j = pi[i-1];\\n            while(j>0 and str[i]!=str[j]) j = pi[j-1];\\n            if(str[i]==str[j]) j++;\\n            pi[i] = j;\\n        }\\n        return pi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0, i=0;\\n        while(idx<groups.size() and i<nums.size()){\\n            if(groups[idx][0]==nums[i]){\\n                int j = 0, k=i;\\n                for(; k<nums.size() and j<groups[idx].size(); k++){\\n                    if(groups[idx][j] == nums[k]) j++;\\n                    else break;\\n                }\\n                if(j==groups[idx].size()) idx++, i=k;\\n                else i++;\\n            }\\n            else i++;\\n        }\\n        return idx == groups.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0;\\n\\t\\tvector <int> pi = kmp(nums);\\n            \\n        for(auto group : groups){\\n            int j = 0;\\n\\t\\t\\t// We can see that idx never comes backwards. So we are traversing nums only once. \\n            while(idx<nums.size() and j<group.size()){\\n\\t\\t\\t\\t// If both elements match, we move both pointers.\\n                if(nums[idx]==group[j]) {\\n                    j++, idx++;\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// In case of mismatch, we come backwards upto the point where elements are not matching. \\n                    if(j>0) j = pi[j-1];\\n                    else{\\n\\t\\t\\t\\t\\t\\t// If we can\\'t go backwards, we move the nums pointer forward. \\n                        idx++;\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If nums is finished before groups, we return false\\n            if(j<group.size() and idx==nums.size()) return false;\\n        }\\n        return true;\\n    }\\nprotected:\\n\\t// Standard KMP function\\n    vector <int> kmp(vector <int> &str){\\n        vector <int> pi(str.size()+5,0);\\n        for(int i = 1; i<str.size(); i++){\\n            int j = pi[i-1];\\n            while(j>0 and str[i]!=str[j]) j = pi[j-1];\\n            if(str[i]==str[j]) j++;\\n            pi[i] = j;\\n        }\\n        return pi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341486,
                "title": "easy-java-solution-0-ms-faster-than-100-00-sliding-window",
                "content": "```\\nclass Solution {\\n    \\n    public int search(int[] group, int[] nums, int start, int end )\\n    {\\n        int i=start, j=0;\\n        while(i<end && j<group.length)\\n        {\\n            if(nums[i] == group[j])\\n            {\\n                i++;\\n                j++;\\n\\n                if(j == group.length)\\n                    return i;\\n            }\\n\\n            else {\\n                i = i - j + 1;\\n                j = 0;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start=0, end =nums.length;\\n        \\n        for(int[] group : groups)\\n        {\\n            start = search(group, nums, start, end);\\n            if(start == -1)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int search(int[] group, int[] nums, int start, int end )\\n    {\\n        int i=start, j=0;\\n        while(i<end && j<group.length)\\n        {\\n            if(nums[i] == group[j])\\n            {\\n                i++;\\n                j++;\\n\\n                if(j == group.length)\\n                    return i;\\n            }\\n\\n            else {\\n                i = i - j + 1;\\n                j = 0;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start=0, end =nums.length;\\n        \\n        for(int[] group : groups)\\n        {\\n            start = search(group, nums, start, end);\\n            if(start == -1)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911063,
                "title": "c-building-the-solution-string-find-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string normalize(vector<int> &nums)\\n    {\\n        string ans = \"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n            ans+=\"#\";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string base = normalize(nums);\\n        int prevpos = 0;\\n        bool flag = true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int> v = groups[i];\\n            string tofind = normalize(v);\\n            if(base.find(tofind,prevpos) != string::npos)\\n            {\\n                int currpos = base.find(tofind,prevpos);\\n                bool check = true;\\n                if(currpos!=0 && base[currpos-1]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(currpos+tofind.length()!=base.length() && base[currpos+tofind.length()]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(check==false)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(currpos<prevpos)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    prevpos= currpos+tofind.length();\\n                }\\n            }\\n            else\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string normalize(vector<int> &nums)\\n    {\\n        string ans = \"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n            ans+=\"#\";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string base = normalize(nums);\\n        int prevpos = 0;\\n        bool flag = true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int> v = groups[i];\\n            string tofind = normalize(v);\\n            if(base.find(tofind,prevpos) != string::npos)\\n            {\\n                int currpos = base.find(tofind,prevpos);\\n                bool check = true;\\n                if(currpos!=0 && base[currpos-1]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(currpos+tofind.length()!=base.length() && base[currpos+tofind.length()]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(check==false)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(currpos<prevpos)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    prevpos= currpos+tofind.length();\\n                }\\n            }\\n            else\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080571,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findGroup(vector<int>nums,int l,int h,vector<int>grp){\\n        int len=grp.size();\\n        int idx=-1;\\n        for(int i=l;i<=(h-len+1);i++){\\n            int k=i;\\n            if(nums[i]==grp[0]){\\n                int j=0;;\\n                for(;j<grp.size();j++){\\n                    if(nums[i]!=grp[j])break;\\n                    i++;\\n                }\\n                if(j==grp.size()){\\n                    idx=k;\\n                    break;\\n                }\\n            }\\n            i=k;\\n\\n        }\\n        cout<<idx;\\n        return idx;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int prev_start=-1,prev_end=-1;\\n\\n        for(int i=0;i<groups.size();i++){\\n            int idx=-1;\\n            if(i==0){\\n               idx=findGroup(nums,0,nums.size()-1,groups[i]);\\n            }\\n            else if(i!=0){\\n                if(prev_end+1>=nums.size())return false;\\n                idx=findGroup(nums,prev_end+1,nums.size()-1,groups[i]);\\n            }\\n\\n            if(idx==-1)return false;\\n            else{\\n                prev_start=idx;\\n                prev_end=prev_start+groups[i].size()-1;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findGroup(vector<int>nums,int l,int h,vector<int>grp){\\n        int len=grp.size();\\n        int idx=-1;\\n        for(int i=l;i<=(h-len+1);i++){\\n            int k=i;\\n            if(nums[i]==grp[0]){\\n                int j=0;;\\n                for(;j<grp.size();j++){\\n                    if(nums[i]!=grp[j])break;\\n                    i++;\\n                }\\n                if(j==grp.size()){\\n                    idx=k;\\n                    break;\\n                }\\n            }\\n            i=k;\\n\\n        }\\n        cout<<idx;\\n        return idx;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int prev_start=-1,prev_end=-1;\\n\\n        for(int i=0;i<groups.size();i++){\\n            int idx=-1;\\n            if(i==0){\\n               idx=findGroup(nums,0,nums.size()-1,groups[i]);\\n            }\\n            else if(i!=0){\\n                if(prev_end+1>=nums.size())return false;\\n                idx=findGroup(nums,prev_end+1,nums.size()-1,groups[i]);\\n            }\\n\\n            if(idx==-1)return false;\\n            else{\\n                prev_start=idx;\\n                prev_end=prev_start+groups[i].size()-1;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1074660,
                "title": "python3-simple-convert-to-string-solution",
                "content": "Build **s** string from nums array and **g**  string from each group array using delimeter (thank\\'s to @ajith6198) and search starting index of group in **s**. If no match found - return False. If Found - crop everything before found index and continue.\\n\\n\\n\\tclass Solution:\\n\\t\\tdef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\t\\t\\ts = \"#\" + \"#\".join(map(str, nums))\\n\\n\\t\\t\\tfor group in groups:\\n\\t\\t\\t\\tg = \"#\" + \"#\".join(map(str, group))\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ti = s.find(g)\\n\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ts = s[i + len(g):]\\n\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "Build **s** string from nums array and **g**  string from each group array using delimeter (thank\\'s to @ajith6198) and search starting index of group in **s**. If no match found - return False. If Found - crop everything before found index and continue.\\n\\n\\n\\tclass Solution:\\n\\t\\tdef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\t\\t\\ts = \"#\" + \"#\".join(map(str, nums))\\n\\n\\t\\t\\tfor group in groups:\\n\\t\\t\\t\\tg = \"#\" + \"#\".join(map(str, group))\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ti = s.find(g)\\n\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ts = s[i + len(g):]\\n\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 1074629,
                "title": "python-3-string-built-in-find-explanation",
                "content": "### Explanation\\n- Convert int array to string\\n- Use `find()` to check status\\n- It\\'s slow but intuitive, to me at least\\n### Implementation\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        groups = [\\'-\\'.join(str(s) for s in group) for group in groups]\\n        nums = \\'-\\'.join(str(s) for s in nums)\\n        j = k = 0\\n        while k < len(groups):\\n            group = groups[k]\\n            i = nums.find(group, j)\\n            if i == -1: return False\\n            if i == 0 or i > 0 and nums[i-1] == \\'-\\':\\n                j = i + len(group)\\n                k += 1\\n            else: j += 1\\n        return True    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        groups = [\\'-\\'.join(str(s) for s in group) for group in groups]\\n        nums = \\'-\\'.join(str(s) for s in nums)\\n        j = k = 0\\n        while k < len(groups):\\n            group = groups[k]\\n            i = nums.find(group, j)\\n            if i == -1: return False\\n            if i == 0 or i > 0 and nums[i-1] == \\'-\\':\\n                j = i + len(group)\\n                k += 1\\n            else: j += 1\\n        return True    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016035,
                "title": "super-simple-python-solution-check-one-by-one",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pointer = 0\\n        \\n        groups.reverse()\\n        \\n        while pointer <= len(nums):\\n            if len(groups) == 0:\\n                return True\\n            currentGroup = groups[-1]\\n            if nums[pointer:pointer+len(currentGroup)] == currentGroup:\\n                pointer += len(currentGroup)\\n                groups.pop()\\n            else:\\n                pointer += 1\\n                \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pointer = 0\\n        \\n        groups.reverse()\\n        \\n        while pointer <= len(nums):\\n            if len(groups) == 0:\\n                return True\\n            currentGroup = groups[-1]\\n            if nums[pointer:pointer+len(currentGroup)] == currentGroup:\\n                pointer += len(currentGroup)\\n                groups.pop()\\n            else:\\n                pointer += 1\\n                \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914636,
                "title": "simple-approach-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf You just read and trace than also you will understand . No need for explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Checking iteratively if groups[i] is present or not . If not then go back again and check .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        for(int i=0;i<groups.length;i++)\\n        {\\n            int j=0;\\n            int k=0;\\n            for(;j<nums.length && k<groups[i].length;)\\n            {\\n                if(nums[j] == groups[i][k])\\n                {\\n                    k++;\\n                    j++;\\n                }  \\n                else\\n                {\\n                    j = j-k+1;\\n                    k=0;\\n                }\\n            }\\n            if(k!=groups[i].length)\\n            {\\n                return false;\\n            }\\n            j--;\\n            while(j!=-1)\\n            {\\n                nums[j] = Integer.MIN_VALUE;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        for(int i=0;i<groups.length;i++)\\n        {\\n            int j=0;\\n            int k=0;\\n            for(;j<nums.length && k<groups[i].length;)\\n            {\\n                if(nums[j] == groups[i][k])\\n                {\\n                    k++;\\n                    j++;\\n                }  \\n                else\\n                {\\n                    j = j-k+1;\\n                    k=0;\\n                }\\n            }\\n            if(k!=groups[i].length)\\n            {\\n                return false;\\n            }\\n            j--;\\n            while(j!=-1)\\n            {\\n                nums[j] = Integer.MIN_VALUE;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292072,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        int n=groups.size(), ns=nums.size();\\n        int cnt=0;\\n        int st=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int f=0;\\n            for(int y=st; y<ns; y++)\\n            {\\n                int i=0, j=y;\\n                while(i<groups[x].size() && groups[x][i]==nums[j])\\n                {\\n                    i++; j++;\\n                }\\n                if(i==groups[x].size()) \\n                {\\n                    cnt++;\\n                    st=j;\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(!f) return false;\\n        }\\n        if(cnt==n) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        int n=groups.size(), ns=nums.size();\\n        int cnt=0;\\n        int st=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int f=0;\\n            for(int y=st; y<ns; y++)\\n            {\\n                int i=0, j=y;\\n                while(i<groups[x].size() && groups[x][i]==nums[j])\\n                {\\n                    i++; j++;\\n                }\\n                if(i==groups[x].size()) \\n                {\\n                    cnt++;\\n                    st=j;\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(!f) return false;\\n        }\\n        if(cnt==n) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042230,
                "title": "easy-two-pointer-approach-java",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int n=groups.length;\\n        int ncol=groups[0].length;\\n        int row=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j=i;\\n            int col=0;\\n            \\n            while(col<groups[row].length && j<nums.length && groups[row][col]==nums[j])\\n            {\\n                col++;\\n                j++;\\n            }\\n            \\n            if(col==groups[row].length)\\n            {\\n                row++;\\n                i=j-1;\\n            }\\n            \\n            if(row==groups.length)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int n=groups.length;\\n        int ncol=groups[0].length;\\n        int row=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j=i;\\n            int col=0;\\n            \\n            while(col<groups[row].length && j<nums.length && groups[row][col]==nums[j])\\n            {\\n                col++;\\n                j++;\\n            }\\n            \\n            if(col==groups[row].length)\\n            {\\n                row++;\\n                i=j-1;\\n            }\\n            \\n            if(row==groups.length)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810802,
                "title": "indexof-approach",
                "content": "# Intuition\\nidea is to find the index, \\nremove every thing before it from the array if exist for next search\\nelse return false\\n\\nHope this helps :)\\n\\n# Code\\n```\\nvar canChoose = function(groups, nums) {\\n    //why add \" \"? to prevent indexOf finds wrong number \\n    //eg(12 and 2 will return value not -1)\\n    nums.unshift(\" \")\\n    var ns = nums.join(\" \");\\n    var pos = 0;\\n    \\n    for(let i = 0; i < groups.length; i++) {\\n        let s = groups[i].join(\" \");\\n        ns = ns.slice(pos);\\n\\n        let index = ns.indexOf(\" \" + s);\\n\\n        if(index === -1) return false;\\n\\n        pos = index + groups[i].length + 3;\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canChoose = function(groups, nums) {\\n    //why add \" \"? to prevent indexOf finds wrong number \\n    //eg(12 and 2 will return value not -1)\\n    nums.unshift(\" \")\\n    var ns = nums.join(\" \");\\n    var pos = 0;\\n    \\n    for(let i = 0; i < groups.length; i++) {\\n        let s = groups[i].join(\" \");\\n        ns = ns.slice(pos);\\n\\n        let index = ns.indexOf(\" \" + s);\\n\\n        if(index === -1) return false;\\n\\n        pos = index + groups[i].length + 3;\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684100,
                "title": "c-kmp-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281846,
                "title": "simple-python-solution-without-kmp",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        # transform groups list into str\\n        for i in range(len(groups)):\\n            l1=[str(m) for m in groups[i]]        \\n            s=\\'_\\'.join(l1)\\n\\t\\t\\t#To prevent errors like the one below, we need to decorate each string\\n\\t\\t\\t#in case some problem like groups=[[12,1]]   nums=[2,1]\\n            s=\\'_\\'+s+\\'_\\'\\n            groups[i]=(s,len(s))\\n            \\n        # also we transform the nums into str\\n        l=[str(m) for m in nums]\\n        str_nums=\\'_\\'.join(l)\\n\\t\\t#This step is to facilitate starting position matching\\n        str_nums=\\'_\\'+str_nums+\\'_\\'\\n        \\n        for item in groups:\\n            if item[0] not in str_nums :\\n                return False\\n\\t\\t\\t#if it matches we cut the front part\\n            idx=str_nums.index(item[0])\\n            str_nums=str_nums[idx+item[1]-1:]\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        # transform groups list into str\\n        for i in range(len(groups)):\\n            l1=[str(m) for m in groups[i]]        \\n            s=\\'_\\'.join(l1)\\n\\t\\t\\t#To prevent errors like the one below, we need to decorate each string\\n\\t\\t\\t#in case some problem like groups=[[12,1]]   nums=[2,1]\\n            s=\\'_\\'+s+\\'_\\'\\n            groups[i]=(s,len(s))\\n            \\n        # also we transform the nums into str\\n        l=[str(m) for m in nums]\\n        str_nums=\\'_\\'.join(l)\\n\\t\\t#This step is to facilitate starting position matching\\n        str_nums=\\'_\\'+str_nums+\\'_\\'\\n        \\n        for item in groups:\\n            if item[0] not in str_nums :\\n                return False\\n\\t\\t\\t#if it matches we cut the front part\\n            idx=str_nums.index(item[0])\\n            str_nums=str_nums[idx+item[1]-1:]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170577,
                "title": "python-no-kmp",
                "content": "```\\nclass Solution:\\n    def canChoose(self, y: List[List[int]], x: List[int]) -> bool:\\n        l=len(x)\\n        ly=len(y)\\n        j=0\\n        i=0\\n        while i<l:\\n            if j==ly:return True\\n            if i+len(y[j])-1>=l:return False\\n            if all(y[j][k]==x[i+k] for k in range(len(y[j]))):\\n                i+=len(y[j])\\n                j+=1\\n            else:\\n                i+=1\\n        return j==ly\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, y: List[List[int]], x: List[int]) -> bool:\\n        l=len(x)\\n        ly=len(y)\\n        j=0\\n        i=0\\n        while i<l:\\n            if j==ly:return True\\n            if i+len(y[j])-1>=l:return False\\n            if all(y[j][k]==x[i+k] for k in range(len(y[j]))):\\n                i+=len(y[j])\\n                j+=1\\n            else:\\n                i+=1\\n        return j==ly\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031481,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSame(vector<int> &A,vector<int> &B,int x){\\n        for(int i=0;i<A.size();i++){\\n            if(A[i]!=B[x++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(),m = groups.size();\\n        int size = groups[0].size();\\n        int j = 0;\\n        for(int i=0;i<n;i++){\\n            if(size <= n-i && isSame(groups[j],nums,i)){\\n                j++;\\n                i += size-1; \\n                size = j<m ? groups[j].size() : 0;\\n            }\\n            if(j==m)\\n                break;\\n        }\\n        return j==m ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSame(vector<int> &A,vector<int> &B,int x){\\n        for(int i=0;i<A.size();i++){\\n            if(A[i]!=B[x++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(),m = groups.size();\\n        int size = groups[0].size();\\n        int j = 0;\\n        for(int i=0;i<n;i++){\\n            if(size <= n-i && isSame(groups[j],nums,i)){\\n                j++;\\n                i += size-1; \\n                size = j<m ? groups[j].size() : 0;\\n            }\\n            if(j==m)\\n                break;\\n        }\\n        return j==m ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972098,
                "title": "easy-kmp-string-matching-algo-beats-92",
                "content": "Nothing fancy just do below Question you get understanding (KMP)\\nhttps://leetcode.com/problems/implement-strstr/\\nhttps://www.youtube.com/watch?v=Gjkhm1gYIMw\\n\\n\\n    class Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n\\t\\t\\tint i,k=0,prev;\\n\\t\\t\\tfor(auto arr:groups){\\n\\n\\t\\t\\t\\t// below code is of KMP\\n\\t\\t\\t\\tvector<int>LPS(arr.size(),0);\\n\\t\\t\\t\\tfor(i=1,prev=0;i<arr.size();++i){\\n\\t\\t\\t\\t\\twhile(prev&& arr[prev]!=arr[i])prev=LPS[prev-1];\\n\\n\\t\\t\\t\\t\\tif(arr[prev]==arr[i]) LPS[i]=++prev;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// this code is to match with LSP\\n\\t\\t\\t\\tfor(prev=0;k<nums.size()&&prev<arr.size();){\\n\\t\\t\\t\\t\\tif(nums[k]==arr[prev])++k,++prev;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(prev)prev=LPS[prev-1];\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t++k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(prev<arr.size())return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n\\t\\t\\tint i,k=0,prev;\\n\\t\\t\\tfor(auto arr:groups){\\n\\n\\t\\t\\t\\t// below code is of KMP\\n\\t\\t\\t\\tvector<int>LPS(arr.size(),0);\\n\\t\\t\\t\\tfor(i=1,prev=0;i<arr.size();++i){\\n\\t\\t\\t\\t\\twhile(prev&& arr[prev]!=arr[i])prev=LPS[prev-1];\\n\\n\\t\\t\\t\\t\\tif(arr[prev]==arr[i]) LPS[i]=++prev;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1424343,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        gidx = 0\\n        while i < len(nums):\\n            group = groups[gidx]\\n            if group[0] == nums[i] and len(nums)-i >= len(group):\\n                # check group is in nums\\n                included = True\\n                for j in range(len(group)):\\n                    if group[j] != nums[i+j]:\\n                        included = False\\n                        break\\n                if included:\\n                    gidx += 1\\n                    i += j + 1                 \\n                else:\\n                    i += 1\\n            else:\\n                i += 1\\n            # print(i)\\n            if gidx >= len(groups):\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        gidx = 0\\n        while i < len(nums):\\n            group = groups[gidx]\\n            if group[0] == nums[i] and len(nums)-i >= len(group):\\n                # check group is in nums\\n                included = True\\n                for j in range(len(group)):\\n                    if group[j] != nums[i+j]:\\n                        included = False\\n                        break\\n                if included:\\n                    gidx += 1\\n                    i += j + 1                 \\n                else:\\n                    i += 1\\n            else:\\n                i += 1\\n            # print(i)\\n            if gidx >= len(groups):\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249703,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        \\n        \\n        def rec(groups,nums):\\n            if(len(groups)==0):\\n                return True\\n            \\n            for i in range(len(nums)):\\n                if(nums[i]==groups[0][0]):\\n                    if(nums[i:i+len(groups[0])]==groups[0]):\\n                        return rec(groups[1::],nums[i+len(groups[0]):])\\n                    \\n            return False\\n        \\n        return rec(groups,nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        \\n        \\n        def rec(groups,nums):\\n            if(len(groups)==0):\\n                return True\\n            \\n            for i in range(len(nums)):\\n                if(nums[i]==groups[0][0]):\\n                    if(nums[i:i+len(groups[0])]==groups[0]):\\n                        return rec(groups[1::],nums[i+len(groups[0]):])\\n                    \\n            return False\\n        \\n        return rec(groups,nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197186,
                "title": "python3-simple-approach-with-comments-beats-94-and-97",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        k=0                         \\n        found = 0\\n        j = 0\\n        \\n        # traverse the whole nums list, \\n        ## if nums[k] is same as the value of 0\\'th index of a group\\n        ## check whether the subarray of nums starting at index k upto index k+len(group)-1 is same as group\\n        ## if so, increase k and found variables accordingly\\n        ## otherwise increment k\\n        while k<len(nums):\\n            if k==len(nums) or found==len(groups):          #reached the end of list nums or matched all the groups\\n                break\\n            if nums[k]==groups[j][0]:                       #as groups must be in nums in the given order, start checking from group at index 0\\n                if nums[k:k+len(groups[j])]==groups[j]:     #check whether the subarray matches the group\\n                    found+=1\\n                    k+=len(groups[j])                       #increase k by the length of the group\\n                    j+=1                                    #increment j\\n                else:\\n                    k+=1                                    #not matched, increment k\\n            else:\\n                k+=1                                        #nums[k] does not match leftmost value of group, increment k\\n                \\n        return found==len(groups)                           \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        k=0                         \\n        found = 0\\n        j = 0\\n        \\n        # traverse the whole nums list, \\n        ## if nums[k] is same as the value of 0\\'th index of a group\\n        ## check whether the subarray of nums starting at index k upto index k+len(group)-1 is same as group\\n        ## if so, increase k and found variables accordingly\\n        ## otherwise increment k\\n        while k<len(nums):\\n            if k==len(nums) or found==len(groups):          #reached the end of list nums or matched all the groups\\n                break\\n            if nums[k]==groups[j][0]:                       #as groups must be in nums in the given order, start checking from group at index 0\\n                if nums[k:k+len(groups[j])]==groups[j]:     #check whether the subarray matches the group\\n                    found+=1\\n                    k+=len(groups[j])                       #increase k by the length of the group\\n                    j+=1                                    #increment j\\n                else:\\n                    k+=1                                    #not matched, increment k\\n            else:\\n                k+=1                                        #nums[k] does not match leftmost value of group, increment k\\n                \\n        return found==len(groups)                           \\n",
                "codeTag": "Java"
            },
            {
                "id": 1192783,
                "title": "unique-solution-without-using-kmp-algorithm",
                "content": "I have been trying to solve this problem without the knowledge of KMP algorithm. This solution may not be the optimal solution but I found it worth sharing with the LC community as it might present a different angle to approaching the problem. \\n\\nHere\\'s how the solution works:\\n\\n**Part 1: Stringify the nums array** \\n\\nConvert the nums array into a string with each element enclosed between \".\"\\n\\n\\t    string str = \"\";\\n        vector<int> vec; //this vector will store the index of the end of the subarray given in groups if it exists and the conditions are met \\n        for(auto i: nums)\\n            str += \".\"+to_string(i)+\".\";\\n\\nif nums is `nums: [1,-1,0,1,-1,-1,3,-2,0]` after this part, the `string str` will look like this: \\n\\n\\t\\t   .1..-1..0..1..-1..-1..3..-2..0.\\n\\n**Part 2:**\\n\\nIterate over all the groups and stringify each group before checking their existence in the string str.\\n\\n\\n\\tfor(int i = 0; i<groups.size(); i++)\\n        {\\n            string fnd = \"\";\\n            \\n            for(auto j: groups[i])\\n                fnd += \".\"+to_string(j)+\".\";\\n            \\n            auto val1 = str.find(fnd); // Find the first occcurence of the element fnd in the string \\n            auto val2= str.rfind(fnd); // Find the last occcurence of the element fnd in the string \\n            int val;\\n            \\n\\t\\t\\t// Based on the conditions below check and select the appropriate value of index to be considered (val1 or val2)\\n\\t\\t\\t\\n            if(!vec.empty() and vec.back()<val1 and vec.back()<val2)    val = val1<val2?val1:val2; \\n            else if(!vec.empty() and vec.back()>val1 and vec.back()<val2) val = val2;\\n            else if(!vec.empty() and vec.back()<val1 and vec.back()>val2) val = val1;\\n            else val = val1;\\n            \\n\\n            \\n            if(val>= 0 and val<str.length())  // if the val is in range of the array (i.e. the subarray exists in the array)\\n            {\\n               \\n                if(!vec.empty() and vec.back()>val) return false;  // if the previous group\\'s end index occurs after the start index of the current group return false;\\n                \\n\\t\\t\\t\\t// if the conditions are met, make all the characters corresponding to the string fnd equal to \\'i\\' to indicate that those are occupied. Since we must not consider overlapping values.\\n\\t\\t\\t\\t\\n                for(int i = val; i<val+fnd.size(); i++)\\n                    str[i] = \\'i\\';\\n                vec.push_back(val+fnd.size()-1);\\n                \\n            }\\n            \\n\\t\\t\\t// if the val is not in the range, it means that the substring fnd does not exists in the given string. Thus return false.\\n\\t\\t\\t\\n            else return false;\\n        }\\n\\t\\t\\nIf after this iteration nothing has been returned, return true as all the cases that could lead to a false result are been considered in the iteration. \\n\\n**Complete Code:**\\n\\n```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        string str = \"\";\\n        \\n        vector<int> vec;\\n        \\n        for(auto i: nums)\\n            str += \".\"+to_string(i)+\".\";\\n\\n        for(int i = 0; i<groups.size(); i++)\\n        {\\n            \\n            string fnd = \"\";\\n            \\n            for(auto j: groups[i])\\n                fnd += \".\"+to_string(j)+\".\";\\n            \\n            auto val1 = str.find(fnd);\\n            auto val2= str.rfind(fnd);\\n            int val;\\n            \\n            if(!vec.empty() and vec.back()<val1 and vec.back()<val2)    val = val1<val2?val1:val2;\\n            else if(!vec.empty() and vec.back()>val1 and vec.back()<val2) val = val2;\\n            else if(!vec.empty() and vec.back()<val1 and vec.back()>val2) val = val1;\\n            else val = val1;\\n            \\n\\n            \\n            if(val>= 0 and val<str.length())\\n            {\\n                if(!vec.empty() and vec.back()>val) return false;\\n                \\n                for(int i = val; i<val+fnd.size(); i++)\\n                    str[i] = \\'i\\';\\n                vec.push_back(val+fnd.size()-1);\\n                \\n            }\\n            \\n            else return false;\\n        }\\n        \\n        return true;\\n\\t}\\n\\n```\\n\\nHappy Leetcoding!",
                "solutionTags": [],
                "code": "```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        string str = \"\";\\n        \\n        vector<int> vec;\\n        \\n        for(auto i: nums)\\n            str += \".\"+to_string(i)+\".\";\\n\\n        for(int i = 0; i<groups.size(); i++)\\n        {\\n            \\n            string fnd = \"\";\\n            \\n            for(auto j: groups[i])\\n                fnd += \".\"+to_string(j)+\".\";\\n            \\n            auto val1 = str.find(fnd);\\n            auto val2= str.rfind(fnd);\\n            int val;\\n            \\n            if(!vec.empty() and vec.back()<val1 and vec.back()<val2)    val = val1<val2?val1:val2;\\n            else if(!vec.empty() and vec.back()>val1 and vec.back()<val2) val = val2;\\n            else if(!vec.empty() and vec.back()<val1 and vec.back()>val2) val = val1;\\n            else val = val1;\\n            \\n\\n            \\n            if(val>= 0 and val<str.length())\\n            {\\n                if(!vec.empty() and vec.back()>val) return false;\\n                \\n                for(int i = val; i<val+fnd.size(); i++)\\n                    str[i] = \\'i\\';\\n                vec.push_back(val+fnd.size()-1);\\n                \\n            }\\n            \\n            else return false;\\n        }\\n        \\n        return true;\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168697,
                "title": "java-straightforward-solution-using-dfs",
                "content": "```\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }\\n\\t\\n\\t//if find pos-th group equals to certain segment of array, continue checking (pos+1)-th group following the previous checked segment\\n\\t//if pos-th group doesn\\'t equal to segment from current start position i of nums, we look for the next position i+1 as the new start\\n\\t//position, till find the equal segment in the nums\\n    private boolean dfs(int[][] groups, int[] nums, int pos, int i)\\n    {\\n        if(pos == groups.length) return true;\\n        \\n        if(i >= nums.length) return false;\\n        \\n        if(isEqual(groups[pos], nums, i)) return dfs(groups, nums, pos + 1, i + groups[pos].length);\\n        \\n        return dfs(groups, nums, pos, i + 1);\\n    }\\n\\t//check if certain group equals to certain segment of nums array\\n    private boolean isEqual(int[] group, int[] nums, int i)\\n    {\\n        for(int j = 0; j < group.length; j++)\\n        {\\n            if(i >= nums.length||group[j] != nums[i]) return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }\\n\\t\\n\\t//if find pos-th group equals to certain segment of array, continue checking (pos+1)-th group following the previous checked segment\\n\\t//if pos-th group doesn\\'t equal to segment from current start position i of nums, we look for the next position i+1 as the new start\\n\\t//position, till find the equal segment in the nums\\n    private boolean dfs(int[][] groups, int[] nums, int pos, int i)\\n    {\\n        if(pos == groups.length) return true;\\n        \\n        if(i >= nums.length) return false;\\n        \\n        if(isEqual(groups[pos], nums, i)) return dfs(groups, nums, pos + 1, i + groups[pos].length);\\n        \\n        return dfs(groups, nums, pos, i + 1);\\n    }\\n\\t//check if certain group equals to certain segment of nums array\\n    private boolean isEqual(int[] group, int[] nums, int i)\\n    {\\n        for(int j = 0; j < group.length; j++)\\n        {\\n            if(i >= nums.length||group[j] != nums[i]) return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114819,
                "title": "java-simple-10-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int count = 0; // num of matches\\n        int m = 0; // index in group array\\n        // iterate through the nums array, i is the pointer\\n        for (int i = 0; i < nums.length - groups[m].length + 1; i++) {\\n            int[] sub = Arrays.copyOfRange(nums, i, i + groups[m].length);\\n            // find a match\\n            if (Arrays.equals(sub, groups[m])) {\\n                count++;\\n                i += groups[m++].length - 1; // update pointer index\\n                if (count == groups.length) return true;\\n            }\\n        }    \\n        return count == groups.length ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int count = 0; // num of matches\\n        int m = 0; // index in group array\\n        // iterate through the nums array, i is the pointer\\n        for (int i = 0; i < nums.length - groups[m].length + 1; i++) {\\n            int[] sub = Arrays.copyOfRange(nums, i, i + groups[m].length);\\n            // find a match\\n            if (Arrays.equals(sub, groups[m])) {\\n                count++;\\n                i += groups[m++].length - 1; // update pointer index\\n                if (count == groups.length) return true;\\n            }\\n        }    \\n        return count == groups.length ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091082,
                "title": "short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        \\n        while (i < groups.size() && j < nums.size()) {\\n            int jj = j, s = 0;\\n            for (; s < groups[i].size() && jj < nums.size(); ++s, ++jj)\\n                if (groups[i][s] != nums[jj])\\n                    break;\\n\\n            if (s == groups[i].size())\\n                ++i, j = jj;\\n            else\\n                ++j;\\n        }\\n        \\n        return i == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        \\n        while (i < groups.size() && j < nums.size()) {\\n            int jj = j, s = 0;\\n            for (; s < groups[i].size() && jj < nums.size(); ++s, ++jj)\\n                if (groups[i][s] != nums[jj])\\n                    break;\\n\\n            if (s == groups[i].size())\\n                ++i, j = jj;\\n            else\\n                ++j;\\n        }\\n        \\n        return i == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083204,
                "title": "python3-dynamic-programming-solution",
                "content": "cont variable is used to satisfy the property that each group must be continuous.\\n\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        grouplen = len(groups)\\n        numslen = len(nums)\\n        @lru_cache(None)\\n        def f(groupindex, innerindex, cont ,numsindex):\\n            if groupindex == grouplen:\\n                return True\\n            if numsindex == numslen:\\n                return False\\n            # we match\\n            ok = False\\n            if groups[groupindex][innerindex] == nums[numsindex]:\\n                if innerindex == len(groups[groupindex]) - 1:\\n                    ok |= f(groupindex + 1, 0, 1 ,numsindex + 1)\\n                else:\\n                    ok |= f(groupindex, innerindex + 1, 1 ,numsindex + 1)\\n            # we don\\'t match\\n            ok |= f(groupindex, 0, 0 ,numsindex + 1)\\n            return ok\\n        return f(0,0,0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        grouplen = len(groups)\\n        numslen = len(nums)\\n        @lru_cache(None)\\n        def f(groupindex, innerindex, cont ,numsindex):\\n            if groupindex == grouplen:\\n                return True\\n            if numsindex == numslen:\\n                return False\\n            # we match\\n            ok = False\\n            if groups[groupindex][innerindex] == nums[numsindex]:\\n                if innerindex == len(groups[groupindex]) - 1:\\n                    ok |= f(groupindex + 1, 0, 1 ,numsindex + 1)\\n                else:\\n                    ok |= f(groupindex, innerindex + 1, 1 ,numsindex + 1)\\n            # we don\\'t match\\n            ok |= f(groupindex, 0, 0 ,numsindex + 1)\\n            return ok\\n        return f(0,0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076189,
                "title": "java-clean-readable-solution",
                "content": "```\\nclass Solution {    \\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int numIndex = 0;\\n        int groupIndex = 0;\\n        boolean hasGroupsToMatch = groupIndex < groups.length;\\n        boolean hasNumsLeft = numIndex < nums.length;\\n        \\n        while (hasGroupsToMatch && hasNumsLeft) {\\n            int[] currentGroup = groups[groupIndex];\\n            \\n            int matchCount = getHowManyNumbersMatch(currentGroup, nums, numIndex);\\n            \\n            if (matchCount == currentGroup.length) {\\n                groupIndex++;\\n                hasGroupsToMatch = groupIndex < groups.length;\\n            }\\n            \\n            numIndex += matchCount != 0 ? matchCount : 1;\\n            hasNumsLeft = numIndex < nums.length;\\n        }\\n        \\n        return groupIndex >= groups.length;\\n    }\\n    \\n    public int getHowManyNumbersMatch(int[] group, int[] nums, int numIndex) {\\n        int matchCount = 0;\\n        for (int i = 0; i < group.length && numIndex < nums.length; i++, numIndex++) {\\n            if (group[i] == nums[numIndex]) {\\n                matchCount++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return matchCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int numIndex = 0;\\n        int groupIndex = 0;\\n        boolean hasGroupsToMatch = groupIndex < groups.length;\\n        boolean hasNumsLeft = numIndex < nums.length;\\n        \\n        while (hasGroupsToMatch && hasNumsLeft) {\\n            int[] currentGroup = groups[groupIndex];\\n            \\n            int matchCount = getHowManyNumbersMatch(currentGroup, nums, numIndex);\\n            \\n            if (matchCount == currentGroup.length) {\\n                groupIndex++;\\n                hasGroupsToMatch = groupIndex < groups.length;\\n            }\\n            \\n            numIndex += matchCount != 0 ? matchCount : 1;\\n            hasNumsLeft = numIndex < nums.length;\\n        }\\n        \\n        return groupIndex >= groups.length;\\n    }\\n    \\n    public int getHowManyNumbersMatch(int[] group, int[] nums, int numIndex) {\\n        int matchCount = 0;\\n        for (int i = 0; i < group.length && numIndex < nums.length; i++, numIndex++) {\\n            if (group[i] == nums[numIndex]) {\\n                matchCount++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return matchCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076014,
                "title": "java-simple-implementation",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0;\\n        for(int i = 0; i < nums.length && index < groups.length; i++){\\n            if(nums[i] == groups[index][0]){\\n              int k = i;\\n              int j = 0;   \\n              while(k < nums.length && j < groups[index].length && nums[k] == groups[index][j]){       \\n                k++;\\n                j++;\\n              }\\n                \\n              if(j == groups[index].length){\\n                  index++;\\n                  i = k - 1;\\n            }\\n          }\\n        }\\n        \\n        return index == groups.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0;\\n        for(int i = 0; i < nums.length && index < groups.length; i++){\\n            if(nums[i] == groups[index][0]){\\n              int k = i;\\n              int j = 0;   \\n              while(k < nums.length && j < groups[index].length && nums[k] == groups[index][j]){       \\n                k++;\\n                j++;\\n              }\\n                \\n              if(j == groups[index].length){\\n                  index++;\\n                  i = k - 1;\\n            }\\n          }\\n        }\\n        \\n        return index == groups.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075924,
                "title": "c-swift-o-m-linear-solution-100-runtime-space",
                "content": "Providing an alternative to what I\\'ve seem so far. M is len(nums).  Instead of looping through each group, we iterate through each number in nums, and keep updating two pointers on group (gPos, nPos). Reset nPos if not matched. \\n\\nC++ solution \\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gPos = 0, nPos = 0;\\n        for (int val : nums) {\\n            if (val != groups[gPos][nPos]) { nPos = 0; }\\n            if (val == groups[gPos][nPos]) { nPos += 1; }\\n            if (nPos == groups[gPos].size()) {\\n                gPos += 1;\\n                nPos = 0;\\n                if (gPos == groups.size()) { break; }\\n            }\\n        }\\n        return gPos == groups.size();\\n    }\\n};\\n```\\n\\nSwift \\n```\\n  var gPos = 0, nPos = 0\\n  for val in nums {\\n    if val != groups[gPos][nPos] { nPos = 0 }\\n    if val == groups[gPos][nPos] { nPos += 1 }\\n    if nPos == groups[gPos].count {\\n      gPos += 1\\n      nPos = 0\\n      if gPos == groups.count { break }\\n    }\\n  }\\n  return gPos == groups.count\\n```\\n\\nIn practice, if M is large, we can skip certain positions of nums and jump forward to next index of group[gPos][0] by first building an index of value -> [pos] from nums.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gPos = 0, nPos = 0;\\n        for (int val : nums) {\\n            if (val != groups[gPos][nPos]) { nPos = 0; }\\n            if (val == groups[gPos][nPos]) { nPos += 1; }\\n            if (nPos == groups[gPos].size()) {\\n                gPos += 1;\\n                nPos = 0;\\n                if (gPos == groups.size()) { break; }\\n            }\\n        }\\n        return gPos == groups.size();\\n    }\\n};\\n```\n```\\n  var gPos = 0, nPos = 0\\n  for val in nums {\\n    if val != groups[gPos][nPos] { nPos = 0 }\\n    if val == groups[gPos][nPos] { nPos += 1 }\\n    if nPos == groups[gPos].count {\\n      gPos += 1\\n      nPos = 0\\n      if gPos == groups.count { break }\\n    }\\n  }\\n  return gPos == groups.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075740,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start=0\\n        for i in groups:\\n            for k in range(start,len(nums)):\\n                if nums[k:k+len(i)]==i:\\n                    start=k+len(i)\\n                    break\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start=0\\n        for i in groups:\\n            for k in range(start,len(nums)):\\n                if nums[k:k+len(i)]==i:\\n                    start=k+len(i)\\n                    break\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074722,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let i=0;\\n    for(let start=0;i<groups.length&&groups[i].length+start<=nums.length;start++){\\n        \\n        if(search(groups[i], nums, start)){\\n            start+=groups[i].length-1;\\n            i++;\\n        }\\n    }\\n    return i==groups.length;\\n    \\n    function search(group, nums, start){\\n        for(let i =0;i<group.length;i++){\\n            if(group[i]!=nums[i+start]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let i=0;\\n    for(let start=0;i<groups.length&&groups[i].length+start<=nums.length;start++){\\n        \\n        if(search(groups[i], nums, start)){\\n            start+=groups[i].length-1;\\n            i++;\\n        }\\n    }\\n    return i==groups.length;\\n    \\n    function search(group, nums, start){\\n        for(let i =0;i<group.length;i++){\\n            if(group[i]!=nums[i+start]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058461,
                "title": "c-easy-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int sz=nums.size();\\n        int g=0;\\n        \\n           for(int i=0;i<sz;i++)\\n             {\\n               vector<int>sub;\\n               for(int j=i;j<sz;j++)\\n                 {\\n                   sub.push_back(nums[j]);\\n                   //is the subbbray and the group are equal then we increment gorup and move i to j so that it will not repeat\\n                    if(sub.size()==groups[g].size() and  groups[g]==sub)\\n                         {\\n                               g++;\\n                               //if g is equal to gorup size then return true it\\'s end\\n                           if(g==groups.size())\\n                                return true;\\n                                //move i to j because we want disjoint and break \\n                                i=j;\\n                            break;\\n                         }\\n                        \\n                     \\n                 }\\n             }\\n             return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int sz=nums.size();\\n        int g=0;\\n        \\n           for(int i=0;i<sz;i++)\\n             {\\n               vector<int>sub;\\n               for(int j=i;j<sz;j++)\\n                 {\\n                   sub.push_back(nums[j]);\\n                   //is the subbbray and the group are equal then we increment gorup and move i to j so that it will not repeat\\n                    if(sub.size()==groups[g].size() and  groups[g]==sub)\\n                         {\\n                               g++;\\n                               //if g is equal to gorup size then return true it\\'s end\\n                           if(g==groups.size())\\n                                return true;\\n                                //move i to j because we want disjoint and break \\n                                i=j;\\n                            break;\\n                         }\\n                        \\n                     \\n                 }\\n             }\\n             return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950156,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int numInd=0;\\n        int grpInd=0;\\n        while(numInd<nums.size() && grpInd<groups.size())\\n        {\\n            int match=0;\\n            while(numInd+match<nums.size() && match<groups[grpInd].size() && nums[numInd+match]==groups[grpInd][match]) match++;\\n            if (match==groups[grpInd].size()) \\n            {\\n                grpInd++;\\n                numInd+=match;\\n            }\\n            else{\\n              numInd++;\\n            }\\n        }\\n        return grpInd==groups.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int numInd=0;\\n        int grpInd=0;\\n        while(numInd<nums.size() && grpInd<groups.size())\\n        {\\n            int match=0;\\n            while(numInd+match<nums.size() && match<groups[grpInd].size() && nums[numInd+match]==groups[grpInd][match]) match++;\\n            if (match==groups[grpInd].size()) \\n            {\\n                grpInd++;\\n                numInd+=match;\\n            }\\n            else{\\n              numInd++;\\n            }\\n        }\\n        return grpInd==groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907770,
                "title": "c-easiest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        // Intution\\n        // The idea in here is really very simple. We will keep two pointers one for the subarray with in the group and the other on the nums value. We will check if the curret value of the current group number is equal to value of nums if so then we will check till the end of the value. If we have not found the result then we will again start.\\n\\n        int grpNo = 0;\\n\\n        int i = 0;\\n\\n        int size = nums.size();\\n\\n        int grpSize = groups.size();\\n\\n        while( i < size ){\\n            if(grpNo >= grpSize) return true;\\n            \\n            if(groups[grpNo][0] == nums[i]){\\n                int currGroupSize = groups[grpNo].size();\\n                int j = 0;\\n                int start = i;\\n\\n                while(j < currGroupSize and i < size){\\n\\n                    if(groups[grpNo][j] == nums[start]){\\n                        j++;\\n                        start++;\\n                    }\\n\\n                    else break;\\n                }\\n                if(j == currGroupSize) {\\n                    grpNo += 1;\\n                    i = start;\\n                    }\\n                else i++;\\n            }\\n\\n            else i++;\\n\\n        }\\n\\n        return grpNo >= grpSize;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        // Intution\\n        // The idea in here is really very simple. We will keep two pointers one for the subarray with in the group and the other on the nums value. We will check if the curret value of the current group number is equal to value of nums if so then we will check till the end of the value. If we have not found the result then we will again start.\\n\\n        int grpNo = 0;\\n\\n        int i = 0;\\n\\n        int size = nums.size();\\n\\n        int grpSize = groups.size();\\n\\n        while( i < size ){\\n            if(grpNo >= grpSize) return true;\\n            \\n            if(groups[grpNo][0] == nums[i]){\\n                int currGroupSize = groups[grpNo].size();\\n                int j = 0;\\n                int start = i;\\n\\n                while(j < currGroupSize and i < size){\\n\\n                    if(groups[grpNo][j] == nums[start]){\\n                        j++;\\n                        start++;\\n                    }\\n\\n                    else break;\\n                }\\n                if(j == currGroupSize) {\\n                    grpNo += 1;\\n                    i = start;\\n                    }\\n                else i++;\\n            }\\n\\n            else i++;\\n\\n        }\\n\\n        return grpNo >= grpSize;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871677,
                "title": "kmp-string-matching-algo",
                "content": "`this solution is not right solution it involves converting array to string which is incorrect bcoz it can fail on some cases but here i just used this to use KMP for string matching but try to use KMP for array itself which is the correct way to do it for this question`\\n\\n\\n# Code\\n```\\nstring change(int x){\\n    string s = \"\";\\n    while(x > 9 || x < -9){\\n        int d = x % 10;\\n        s += to_string(abs(d));\\n        x /= 10;\\n    }\\n    s += (char)(\\'a\\' + x + 9);\\n    return s;\\n}\\n\\nvector<int> compute_pi(string& pattern) {\\n    vector<int> pi(pattern.length()); pi[0] = 0;\\n    int i = 1, len = 0, N = pattern.length();\\n    while (i < N) {\\n        if (pattern[len] == pattern[i]) {\\n            pi[i] = len + 1;\\n            i++, len++;\\n        }\\n        else {\\n            if (len == 0) {\\n                pi[i] = 0;\\n                i++;\\n            }\\n            else len = pi[len - 1];\\n        }\\n    }\\n    return pi;\\n}\\n\\nvector<pair<int, int>> KMP(string& text, string& pattern) {\\n    int N = text.length(), M = pattern.length();\\n    vector<int> pi = compute_pi(pattern);\\n    vector<pair<int, int>> positions;\\n    int i = 0, j = 0;\\n    while (i < N) {\\n        if (text[i] == pattern[j]) {\\n            i++, j++;\\n        }\\n        if (j == M) {\\n            positions.push_back({i - j, i - j + M - 1});\\n            j = pi[j - 1];\\n        }\\n        else if (i < N && text[i] != pattern[j]) {\\n            if (j == 0) i++;\\n            else j = pi[j - 1];\\n        }\\n    }\\n    return positions;\\n}\\n\\nbool check(vector<vector<pair<int,int>>>& v, int i, int j){\\n    if(i==v.size()) return true;\\n    bool fl = false;\\n    for(int k = 0; k < v[i].size();k++){\\n        if(v[i][k].first > v[i-1][j].second){\\n            if(check(v, i+1, k)) return true;\\n            else continue;\\n        }\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string ss = \"\";\\n        for(auto x: nums) ss += change(x);\\n        vector<vector<pair<int,int>>> v;\\n        for(auto arr: groups){\\n            string s = \"\";\\n            for(auto x: arr) s += change(x);\\n            vector<pair<int, int>> ind = KMP(ss, s);\\n            if(ind.size()) v.push_back(ind);\\n            else return false;\\n        }\\n        for(int i = 0;i<v[0].size();i++){\\n            if(check(v, 1, i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring change(int x){\\n    string s = \"\";\\n    while(x > 9 || x < -9){\\n        int d = x % 10;\\n        s += to_string(abs(d));\\n        x /= 10;\\n    }\\n    s += (char)(\\'a\\' + x + 9);\\n    return s;\\n}\\n\\nvector<int> compute_pi(string& pattern) {\\n    vector<int> pi(pattern.length()); pi[0] = 0;\\n    int i = 1, len = 0, N = pattern.length();\\n    while (i < N) {\\n        if (pattern[len] == pattern[i]) {\\n            pi[i] = len + 1;\\n            i++, len++;\\n        }\\n        else {\\n            if (len == 0) {\\n                pi[i] = 0;\\n                i++;\\n            }\\n            else len = pi[len - 1];\\n        }\\n    }\\n    return pi;\\n}\\n\\nvector<pair<int, int>> KMP(string& text, string& pattern) {\\n    int N = text.length(), M = pattern.length();\\n    vector<int> pi = compute_pi(pattern);\\n    vector<pair<int, int>> positions;\\n    int i = 0, j = 0;\\n    while (i < N) {\\n        if (text[i] == pattern[j]) {\\n            i++, j++;\\n        }\\n        if (j == M) {\\n            positions.push_back({i - j, i - j + M - 1});\\n            j = pi[j - 1];\\n        }\\n        else if (i < N && text[i] != pattern[j]) {\\n            if (j == 0) i++;\\n            else j = pi[j - 1];\\n        }\\n    }\\n    return positions;\\n}\\n\\nbool check(vector<vector<pair<int,int>>>& v, int i, int j){\\n    if(i==v.size()) return true;\\n    bool fl = false;\\n    for(int k = 0; k < v[i].size();k++){\\n        if(v[i][k].first > v[i-1][j].second){\\n            if(check(v, i+1, k)) return true;\\n            else continue;\\n        }\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string ss = \"\";\\n        for(auto x: nums) ss += change(x);\\n        vector<vector<pair<int,int>>> v;\\n        for(auto arr: groups){\\n            string s = \"\";\\n            for(auto x: arr) s += change(x);\\n            vector<pair<int, int>> ind = KMP(ss, s);\\n            if(ind.size()) v.push_back(ind);\\n            else return false;\\n        }\\n        for(int i = 0;i<v[0].size();i++){\\n            if(check(v, 1, i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775588,
                "title": "javascript-1764-form-array-by-concatenating-subarrays-of-another-array",
                "content": "Tests\\n```\\n[[2,1]]\\n[12,1]\\n  [[1,-1,-1],[3,-2,0]]\\n  [1,-1,0,1,-1,-1,3,-2,0]\\n[[10,-2],[1,2,3,4]]\\n[1,2,3,4,10,-2]\\n  [[1,2,3],[3,4]]\\n  [7,7,1,2,3,4,7,7]\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - tricky code - see tests above\\n```\\nvar canChoose = function (g, a) {\\n  let srows = g.map(row => \\',\\' + row.join(\\',\\') + \\',\\')\\n  let s = \\',\\' + a.join(\\',\\') + \\',\\'\\n\\n  let i = 0\\n  for (let srow of srows) {\\n    i = s.indexOf(srow, i)\\n    if (i === -1) return false\\n    i += srow.length - 1 // disjoint, -1 for go back the comma(,)\\n  }\\n  return true\\n};\\n```\\n\\n2 - parse 2d array (g) first\\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let k = 0\\n  AA: for (let i = 0; i < m; i++) {\\n    let row = g[i]\\n    let n = row.length\\n    for (; k < a.length; k++) {\\n      // possible row match in a\\n      let j\\n      for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n        // match continuing\\n      }\\n      if (j === n) {\\n        // full row match\\n        k += n\\n        continue AA;\\n      }\\n    }\\n    return false\\n  }\\n  return true\\n}\\n```\\n\\n3 - parse array (a) first\\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let i = 0\\n  for (let k = 0; k < a.length && i < m;) {\\n    let row = g[i]\\n    let n = row.length\\n    let j\\n    for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n      // row match continuing, in a\\n    }\\n    if (j === n) {\\n      // full row match\\n      i++\\n      k += n\\n    } else {\\n      k++\\n    }\\n  }\\n  return i === m\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[[2,1]]\\n[12,1]\\n  [[1,-1,-1],[3,-2,0]]\\n  [1,-1,0,1,-1,-1,3,-2,0]\\n[[10,-2],[1,2,3,4]]\\n[1,2,3,4,10,-2]\\n  [[1,2,3],[3,4]]\\n  [7,7,1,2,3,4,7,7]\\n```\n```\\nvar canChoose = function (g, a) {\\n  let srows = g.map(row => \\',\\' + row.join(\\',\\') + \\',\\')\\n  let s = \\',\\' + a.join(\\',\\') + \\',\\'\\n\\n  let i = 0\\n  for (let srow of srows) {\\n    i = s.indexOf(srow, i)\\n    if (i === -1) return false\\n    i += srow.length - 1 // disjoint, -1 for go back the comma(,)\\n  }\\n  return true\\n};\\n```\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let k = 0\\n  AA: for (let i = 0; i < m; i++) {\\n    let row = g[i]\\n    let n = row.length\\n    for (; k < a.length; k++) {\\n      // possible row match in a\\n      let j\\n      for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n        // match continuing\\n      }\\n      if (j === n) {\\n        // full row match\\n        k += n\\n        continue AA;\\n      }\\n    }\\n    return false\\n  }\\n  return true\\n}\\n```\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let i = 0\\n  for (let k = 0; k < a.length && i < m;) {\\n    let row = g[i]\\n    let n = row.length\\n    let j\\n    for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n      // row match continuing, in a\\n    }\\n    if (j === n) {\\n      // full row match\\n      i++\\n      k += n\\n    } else {\\n      k++\\n    }\\n  }\\n  return i === m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743232,
                "title": "short-and-simple-z-algorithm-c",
                "content": "# Intuition\\nIts just string matching\\n\\n# Approach\\nimplemented Z algorithm to get the index of the subarray\\n\\n# Complexity\\n- Time complexity:\\nO(G.size() * B.size())\\n\\n- Space complexity:\\nO(B.size())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ZArray(vector<int>&A,vector<int>&B,int end)\\n    {\\n        \\n        int l = 0;\\n        int r = 0;\\n        vector<int>C;\\n        for(int a : A)\\n        {\\n            C.push_back(a);\\n        }\\n        C.push_back(1e9 + 7);\\n        for(int b : B)\\n        {\\n            C.push_back(b);\\n        }\\n        int n = C.size();\\n        vector<int>Z(n,0);\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(i > r)\\n            {\\n                l = r = i;\\n                while(r < n && C[r] == C[r - l])\\n                    r++;\\n                Z[i] = r - l;\\n                r--;\\n            }\\n            else\\n            {\\n                int i1 = i - l;\\n                if(Z[i1] + i <= r)\\n                    Z[i] = Z[i1];\\n                else\\n                {\\n                    l = i;\\n                    while(r < n && C[r] == C[r - l])\\n                        r++;\\n                    Z[i] = r - l;\\n                    r--;\\n                }\\n\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(Z[i] == A.size() and i - A.size() >= end)\\n                return (i);\\n        }\\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>&G, vector<int>& B) {\\n        vector<int>A;\\n        int m = G.size();\\n        int end = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            end = ZArray(G[i],B,end);\\n            if(end == -1)\\n                return false;\\n        }\\n        return true;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ZArray(vector<int>&A,vector<int>&B,int end)\\n    {\\n        \\n        int l = 0;\\n        int r = 0;\\n        vector<int>C;\\n        for(int a : A)\\n        {\\n            C.push_back(a);\\n        }\\n        C.push_back(1e9 + 7);\\n        for(int b : B)\\n        {\\n            C.push_back(b);\\n        }\\n        int n = C.size();\\n        vector<int>Z(n,0);\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(i > r)\\n            {\\n                l = r = i;\\n                while(r < n && C[r] == C[r - l])\\n                    r++;\\n                Z[i] = r - l;\\n                r--;\\n            }\\n            else\\n            {\\n                int i1 = i - l;\\n                if(Z[i1] + i <= r)\\n                    Z[i] = Z[i1];\\n                else\\n                {\\n                    l = i;\\n                    while(r < n && C[r] == C[r - l])\\n                        r++;\\n                    Z[i] = r - l;\\n                    r--;\\n                }\\n\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(Z[i] == A.size() and i - A.size() >= end)\\n                return (i);\\n        }\\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>&G, vector<int>& B) {\\n        vector<int>A;\\n        int m = G.size();\\n        int end = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            end = ZArray(G[i],B,end);\\n            if(end == -1)\\n                return false;\\n        }\\n        return true;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681196,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>v;\\n        int k=0,count=0,j=0;\\n        while(j<nums.size()&&k<groups.size()){\\n           if(v.size()<groups[k].size()){\\n               v.push_back(nums[j]);\\n           }\\n           else {\\n               if(v==groups[k]){count++;\\n                 v.clear(); k++;\\n                 continue;\\n               }\\n               else{\\n              v.erase(v.begin());\\n              v.push_back(nums[j]);\\n               }\\n           }\\n           j++;}\\n           if(k<groups.size()&&v==groups[k])count++;\\n           if(count==groups.size())return true;\\n           return false;\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>v;\\n        int k=0,count=0,j=0;\\n        while(j<nums.size()&&k<groups.size()){\\n           if(v.size()<groups[k].size()){\\n               v.push_back(nums[j]);\\n           }\\n           else {\\n               if(v==groups[k]){count++;\\n                 v.clear(); k++;\\n                 continue;\\n               }\\n               else{\\n              v.erase(v.begin());\\n              v.push_back(nums[j]);\\n               }\\n           }\\n           j++;}\\n           if(k<groups.size()&&v==groups[k])count++;\\n           if(count==groups.size())return true;\\n           return false;\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627996,
                "title": "simple-c-sliding-window-approach-with-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing sliding window approach check every group \\n# Complexity\\n- Time complexity:\\nO(n) every element in nums are visisted only once\\n\\n- Space complexity:\\nO(n) complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n      int c=0;\\n      for(int i=0;i<nums.size();i++){\\n          int l=groups[c].size(),j;\\n          vector<int>a;\\n          for( j=i;j<i+l&&j<nums.size();j++)a.push_back(nums[j]);\\n          i=j;\\n          while(a!=groups[c]&&i<nums.size()){\\n              a.erase(a.begin());\\n              a.push_back(nums[i]);\\n              i++;\\n          }\\n          i--;\\n          if(a==groups[c])c++;\\n          if(c==groups.size())return true;\\n      } \\n      if(c==groups.size())return true;\\n      return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n      int c=0;\\n      for(int i=0;i<nums.size();i++){\\n          int l=groups[c].size(),j;\\n          vector<int>a;\\n          for( j=i;j<i+l&&j<nums.size();j++)a.push_back(nums[j]);\\n          i=j;\\n          while(a!=groups[c]&&i<nums.size()){\\n              a.erase(a.begin());\\n              a.push_back(nums[i]);\\n              i++;\\n          }\\n          i--;\\n          if(a==groups[c])c++;\\n          if(c==groups.size())return true;\\n      } \\n      if(c==groups.size())return true;\\n      return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602628,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        group = 0\\n        i = len(nums)-len(groups[-1-group])\\n        while i>=0:\\n            if nums[i:i+len(groups[-1-group])] == groups[-1-group]:\\n                if group==len(groups)-1:\\n                    return True\\n                group += 1\\n                i -= len(groups[-1-group])\\n            else:\\n                i -= 1\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        group = 0\\n        i = len(nums)-len(groups[-1-group])\\n        while i>=0:\\n            if nums[i:i+len(groups[-1-group])] == groups[-1-group]:\\n                if group==len(groups)-1:\\n                    return True\\n                group += 1\\n                i -= len(groups[-1-group])\\n            else:\\n                i -= 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598400,
                "title": "easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        lg=len(groups)\\n        ind=0\\n        for i in groups:\\n            for j in range(ind,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    ind=j+len(i)\\n                    lg-=1\\n                    break\\n        return lg==0\\n        \\n\\n        \\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        lg=len(groups)\\n        ind=0\\n        for i in groups:\\n            for j in range(ind,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    ind=j+len(i)\\n                    lg-=1\\n                    break\\n        return lg==0\\n        \\n\\n        \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579386,
                "title": "o-n-2-88-ms",
                "content": "```ruby\\ndef can_choose g, a\\n    j, z = 0, a.size\\n    g.each do | b |\\n        bz = b.size\\n        loop do\\n            return false if z - j < bz\\n            break j += bz if a[j, bz] == b\\n            j += 1\\n        end\\n    end\\n    true\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef can_choose g, a\\n    j, z = 0, a.size\\n    g.each do | b |\\n        bz = b.size\\n        loop do\\n            return false if z - j < bz\\n            break j += bz if a[j, bz] == b\\n            j += 1\\n        end\\n    end\\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3565639,
                "title": "simple-backtracking",
                "content": "# Intuition\\nI thought it could be linear time until I realized you have to backtrack and can\\'t greedily consume the sub-arrays from groups every time. This makes it $$O(n^2)$$.\\n\\n# Approach\\nIterate over nums and compare and consume items from groups. If a non-match is encountered, backtrack to the beginning of the group and increment by one.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        cur_group = 0\\n        cur_element_in_group = 0\\n        backtrack_to = 0\\n        nums_idx = 0\\n        while nums_idx < len(nums):\\n            if nums[nums_idx] == groups[cur_group][cur_element_in_group]:\\n                cur_element_in_group += 1\\n                if cur_element_in_group >= len(groups[cur_group]):\\n                    cur_element_in_group = 0\\n                    cur_group += 1\\n                    if cur_group >= len(groups):\\n                        return True\\n                    backtrack_to = nums_idx + 1\\n            else:\\n                #print(\"{} != {}\".format(nums[nums_idx], groups[cur_group][cur_element_in_group]))\\n                cur_element_in_group = 0\\n                nums_idx = backtrack_to\\n                backtrack_to = nums_idx + 1\\n            nums_idx += 1\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        cur_group = 0\\n        cur_element_in_group = 0\\n        backtrack_to = 0\\n        nums_idx = 0\\n        while nums_idx < len(nums):\\n            if nums[nums_idx] == groups[cur_group][cur_element_in_group]:\\n                cur_element_in_group += 1\\n                if cur_element_in_group >= len(groups[cur_group]):\\n                    cur_element_in_group = 0\\n                    cur_group += 1\\n                    if cur_group >= len(groups):\\n                        return True\\n                    backtrack_to = nums_idx + 1\\n            else:\\n                #print(\"{} != {}\".format(nums[nums_idx], groups[cur_group][cur_element_in_group]))\\n                cur_element_in_group = 0\\n                nums_idx = backtrack_to\\n                backtrack_to = nums_idx + 1\\n            nums_idx += 1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527771,
                "title": "iterators-linear-scan",
                "content": "# Intuition\\nWhen we\\'re trying to place a group in the subarray, there\\'s never a reason to take anything but the earliest instance we find, because that gives us the longest remaining array to check afterwards. \\n\\nIf we can\\'t find a position for group, then we just return false.\\n\\nIf we do find a position for group i starting at position j, then we start again at at position j+ groups[i].len() for group i+1 and repeat.\\n\\n# Approach\\nUse try_fold to allow for an early exit if we ever fail to place a group.\\n\\n# Complexity\\n- Time complexity: O(nums.len()). Once we check a value in num against a group, we never go back to it, either because we place that group and restart at a later point, or because we fail to find the group and exit the function.\\n\\n- Space complexity: O(1), no allocations necessary.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n        let n = groups.len();\\n        let m = nums.len();\\n\\n        (0..n)\\n        .try_fold(\\n            0,\\n            |first_possible, i| {\\n                let group_len = groups[i].len();\\n                (first_possible..=m-group_len)\\n                .find_map(|j| {\\n                    nums[j..j+group_len]\\n                    .iter()\\n                    .zip(groups[i].iter())\\n                    .all(|(&a, &b)| a==b)\\n                    .then(|| j + group_len)\\n                })\\n        })\\n        .is_some()\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n        let n = groups.len();\\n        let m = nums.len();\\n\\n        (0..n)\\n        .try_fold(\\n            0,\\n            |first_possible, i| {\\n                let group_len = groups[i].len();\\n                (first_possible..=m-group_len)\\n                .find_map(|j| {\\n                    nums[j..j+group_len]\\n                    .iter()\\n                    .zip(groups[i].iter())\\n                    .all(|(&a, &b)| a==b)\\n                    .then(|| j + group_len)\\n                })\\n        })\\n        .is_some()\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431354,
                "title": "scala-3-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = (groups, nums) match {\\n        case (groups, _) if (groups.length == 0) => true\\n        case (groups, nums) if(nums.indexOfSlice(groups(0)) != -1) => canChoose(groups.tail, nums.drop(nums.indexOfSlice(groups(0)) + groups.head.length))\\n        case _=> false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = (groups, nums) match {\\n        case (groups, _) if (groups.length == 0) => true\\n        case (groups, nums) if(nums.indexOfSlice(groups(0)) != -1) => canChoose(groups.tail, nums.drop(nums.indexOfSlice(groups(0)) + groups.head.length))\\n        case _=> false\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3391991,
                "title": "java-simple-kmp",
                "content": "# Intuition\\nit is the classic string searching problem\\n\\n# Complexity\\n- Time complexity:\\n`O(m+n)` where m is the length of nums, n is the total length of each group in groups\\n\\n\\n# Code\\n```\\n/**\\n\\nKMP\\n */\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int lo = 0;\\n        for (int[] g : groups) {\\n            lo = match(nums, lo, g, suffixPrefix(g));\\n            if (lo < 0) return false;\\n        }\\n        return true;\\n    }\\n    private int match(int[] text, int lo, int[] ptn, int[] suffixPrefix) {\\n        int j = lo, i = 0;\\n        while (j < text.length) {\\n            if (text[j] == ptn[i]) {\\n                i++; \\n                j++;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = suffixPrefix[i-1];\\n            }\\n            if (i == ptn.length) {\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] suffixPrefix(int[] arr) {\\n        int n = arr.length;\\n        int[] ans = new int[n];\\n        for(int i =0, j = 1; j < n; ) {\\n            if (arr[i] == arr[j]) {\\n                ans[j++] = ++i;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = ans[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n\\nKMP\\n */\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int lo = 0;\\n        for (int[] g : groups) {\\n            lo = match(nums, lo, g, suffixPrefix(g));\\n            if (lo < 0) return false;\\n        }\\n        return true;\\n    }\\n    private int match(int[] text, int lo, int[] ptn, int[] suffixPrefix) {\\n        int j = lo, i = 0;\\n        while (j < text.length) {\\n            if (text[j] == ptn[i]) {\\n                i++; \\n                j++;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = suffixPrefix[i-1];\\n            }\\n            if (i == ptn.length) {\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] suffixPrefix(int[] arr) {\\n        int n = arr.length;\\n        int[] ans = new int[n];\\n        for(int i =0, j = 1; j < n; ) {\\n            if (arr[i] == arr[j]) {\\n                ans[j++] = ++i;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = ans[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379598,
                "title": "beginner-c-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;int d=0,b=0;\\n        for(auto x:groups){\\n// extracting vector to be searched from groups\\n            int k=x.size();d++;\\n            for(;i<=nums.size()-k;i++){\\n//Finding subarray from nums\\n                vector<int> vec;int a=nums.size()-i-k;\\n                vec={nums.begin()+i,nums.end()-a};\\n//Checking if extracted subarray is equal to vector of groups\\n                if(x==vec) {\\n                    b++; i+=k; break;\\n                }\\n\\n            }\\n        }\\n// Chcking whether all vector of group is found or not\\n        if(d==b) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;int d=0,b=0;\\n        for(auto x:groups){\\n// extracting vector to be searched from groups\\n            int k=x.size();d++;\\n            for(;i<=nums.size()-k;i++){\\n//Finding subarray from nums\\n                vector<int> vec;int a=nums.size()-i-k;\\n                vec={nums.begin()+i,nums.end()-a};\\n//Checking if extracted subarray is equal to vector of groups\\n                if(x==vec) {\\n                    b++; i+=k; break;\\n                }\\n\\n            }\\n        }\\n// Chcking whether all vector of group is found or not\\n        if(d==b) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317776,
                "title": "java-0ms-beats-100-and-clean-code-must-have-skill",
                "content": "# Approach\\n1. Starting from the last group and from the last index of nums, try to find each group 1 by 1\\n2. Traverse nums from n to 0 and try to find last group by traversing the group backwards.\\n3. It is good to add fail-fast conditions!\\n4. Compute the prefixSum of lengths of each group. In your index m is 7 and you have to find 2 groups whose sum of lengths is 8, you should break as you can\\'t find 8 elements inside a segment of 7 elements.\\n5. If a group is found, decrement the group index to search (7,6,5..0) and also deduct group\\'s length from the  index that is used to traverse nums.\\n    - eg: j = 8, group is found and its length is 5. Then j will jump to 8-5 and llok for next group.\\n6. Return true is all groups have been found.  \\n\\n# Complexity\\n- Time complexity:$$O(g + g*n)$$ - g groups of n lengths\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(g)$$ g - number of groups - length prefix sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int[] groupLength = getGroupLength(groups);\\n        int groupIndex = groups.length -1;\\n        // serach group n, n-1, n-2 .. 0. Break if index j is lesser than the prefix sum of remaining groups lengths.\\n        for (int j = nums.length -1; groupIndex >= 0 && j >= groupLength[groupIndex] -1;) {\\n            if(canBeConcatenated(nums, j, groups[groupIndex])) {\\n                // reduce j by the group\\'s length\\n                j -= groups[groupIndex].length;\\n                groupIndex--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return groupIndex == -1;\\n    }\\n\\n    private boolean canBeConcatenated(int[] nums, int j, int[] group) {\\n        for (int i = group.length -1; i>= 0; i--, j--) {\\n            if (nums[j] != group[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getGroupLength(int[][] groups) {\\n        int[] groupLength = new int[groups.length];\\n        groupLength[0] = groups[0].length;\\n        for (int i = 1; i < groupLength.length; i++) {\\n            groupLength[i] = groupLength[i-1] + groups[i].length;\\n        }\\n        return groupLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int[] groupLength = getGroupLength(groups);\\n        int groupIndex = groups.length -1;\\n        // serach group n, n-1, n-2 .. 0. Break if index j is lesser than the prefix sum of remaining groups lengths.\\n        for (int j = nums.length -1; groupIndex >= 0 && j >= groupLength[groupIndex] -1;) {\\n            if(canBeConcatenated(nums, j, groups[groupIndex])) {\\n                // reduce j by the group\\'s length\\n                j -= groups[groupIndex].length;\\n                groupIndex--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return groupIndex == -1;\\n    }\\n\\n    private boolean canBeConcatenated(int[] nums, int j, int[] group) {\\n        for (int i = group.length -1; i>= 0; i--, j--) {\\n            if (nums[j] != group[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getGroupLength(int[][] groups) {\\n        int[] groupLength = new int[groups.length];\\n        groupLength[0] = groups[0].length;\\n        for (int i = 1; i < groupLength.length; i++) {\\n            groupLength[i] = groupLength[i-1] + groups[i].length;\\n        }\\n        return groupLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309235,
                "title": "java-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean canChoose(int[][] groups, int[] nums) {\\n        int totalCount=0;\\n        for (int[] arr:groups){\\n            totalCount+=arr.length;\\n        }\\n        return checkTwoMatricestoChoose(groups,nums,0,0,totalCount);\\n    }\\n    private boolean checkTwoMatricestoChoose(int[][] groups, int[] nums, int groupRowInd, int numsIndex,int totalCount) {\\n        if(groupRowInd==groups.length){\\n            return true;\\n        }\\n        if(totalCount>nums.length-numsIndex){\\n            return false;\\n        }\\n        for (int i=numsIndex,j=0;i<nums.length;){\\n            if(groups[groupRowInd][j]==nums[i]){\\n                j++;\\n                i++;\\n            }else {\\n                i=i-j+1;\\n                j=0;\\n            }\\n            if(j==groups[groupRowInd].length){\\n                if(checkTwoMatricestoChoose(groups,nums,groupRowInd+1,i,totalCount-groups[groupRowInd].length)){\\n                    return true;\\n                }\\n                i=i-j+1;\\n                j=0;\\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     public boolean canChoose(int[][] groups, int[] nums) {\\n        int totalCount=0;\\n        for (int[] arr:groups){\\n            totalCount+=arr.length;\\n        }\\n        return checkTwoMatricestoChoose(groups,nums,0,0,totalCount);\\n    }\\n    private boolean checkTwoMatricestoChoose(int[][] groups, int[] nums, int groupRowInd, int numsIndex,int totalCount) {\\n        if(groupRowInd==groups.length){\\n            return true;\\n        }\\n        if(totalCount>nums.length-numsIndex){\\n            return false;\\n        }\\n        for (int i=numsIndex,j=0;i<nums.length;){\\n            if(groups[groupRowInd][j]==nums[i]){\\n                j++;\\n                i++;\\n            }else {\\n                i=i-j+1;\\n                j=0;\\n            }\\n            if(j==groups[groupRowInd].length){\\n                if(checkTwoMatricestoChoose(groups,nums,groupRowInd+1,i,totalCount-groups[groupRowInd].length)){\\n                    return true;\\n                }\\n                i=i-j+1;\\n                j=0;\\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291682,
                "title": "easy-kmp-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> lps;\\n\\n    void getLps(vector<int> &pat) {\\n        int n = pat.size();\\n        lps.clear();\\n        lps.resize(n , 0);\\n        for(int i = 1 , j = 0 ; i < n ; i++) {\\n            if(pat[i] == pat[j]) lps[i] = ++j;\\n            else if(j != 0) {\\n                j = lps[j - 1]; i--;\\n            }\\n        }\\n\\n    }\\n\\n    int KMP(vector<int> &text , int st , vector<int> &pat) {\\n        int n = text.size() , m = pat.size();\\n        for(int i = st , j = 0 ; i < n && j < m ; i++) {\\n            if(text[i] == pat[j]) j++;\\n            else if(j != 0) {\\n                j = lps[j - 1];\\n                i--;\\n            }\\n            if(j == m) return i + 1;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size() , j , last = 0 , flg , next = 0;\\n\\n        for(auto grp : groups) {\\n            getLps(grp);\\n            last = KMP(nums , last , grp);\\n            if(last == -1) return 0;\\n        }\\n\\n        return 1;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> lps;\\n\\n    void getLps(vector<int> &pat) {\\n        int n = pat.size();\\n        lps.clear();\\n        lps.resize(n , 0);\\n        for(int i = 1 , j = 0 ; i < n ; i++) {\\n            if(pat[i] == pat[j]) lps[i] = ++j;\\n            else if(j != 0) {\\n                j = lps[j - 1]; i--;\\n            }\\n        }\\n\\n    }\\n\\n    int KMP(vector<int> &text , int st , vector<int> &pat) {\\n        int n = text.size() , m = pat.size();\\n        for(int i = st , j = 0 ; i < n && j < m ; i++) {\\n            if(text[i] == pat[j]) j++;\\n            else if(j != 0) {\\n                j = lps[j - 1];\\n                i--;\\n            }\\n            if(j == m) return i + 1;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size() , j , last = 0 , flg , next = 0;\\n\\n        for(auto grp : groups) {\\n            getLps(grp);\\n            last = KMP(nums , last , grp);\\n            if(last == -1) return 0;\\n        }\\n\\n        return 1;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132396,
                "title": "easy-c-solution",
                "content": "# Intuition\\nFor each group, we need to check if it is contained in the bigger sequence. This is still a brute force solution though.\\n\\n# Approach\\nAdding to the above intuition, we check each group if it is present in the bigger sequence. If yes, the next group check starts where the previous one ends. While checking each group, we start character by character and match from the bigger sequence.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // returns if group is present in nums from startIdx\\n    pair<bool, int> contains(const vector<int>& group, const vector<int>& nums, int startIdx) {\\n        int m = 0;\\n        int prev_n = startIdx;\\n        int n = prev_n;\\n\\n        while (m < group.size() && n < nums.size()) {\\n            if (group[m] == nums[n]) {\\n                m++;\\n                n++;\\n            } else {\\n                m = 0;\\n                prev_n++;\\n                n = prev_n;\\n            }\\n\\n            if (m == group.size()) return make_pair(true, n);\\n        }\\n\\n        return make_pair(false, -1);\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int startIdx = 0; // For nums\\n\\n        for (const auto& group : groups) {\\n            auto isPresent = contains(group, nums, startIdx);\\n\\n            if (isPresent.first) {\\n                startIdx = isPresent.second;\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // returns if group is present in nums from startIdx\\n    pair<bool, int> contains(const vector<int>& group, const vector<int>& nums, int startIdx) {\\n        int m = 0;\\n        int prev_n = startIdx;\\n        int n = prev_n;\\n\\n        while (m < group.size() && n < nums.size()) {\\n            if (group[m] == nums[n]) {\\n                m++;\\n                n++;\\n            } else {\\n                m = 0;\\n                prev_n++;\\n                n = prev_n;\\n            }\\n\\n            if (m == group.size()) return make_pair(true, n);\\n        }\\n\\n        return make_pair(false, -1);\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int startIdx = 0; // For nums\\n\\n        for (const auto& group : groups) {\\n            auto isPresent = contains(group, nums, startIdx);\\n\\n            if (isPresent.first) {\\n                startIdx = isPresent.second;\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965111,
                "title": "kmp-search-in-javascript",
                "content": "# Approach\\nKMP substring search:\\nconstruct LPS array for each group and search it in nums\\n\\n# Complexity\\n- Time complexity:\\nO(m + n)\\n\\n# Code\\n```\\nlet canChoose = function( groups, nums ) {\\n\\n    let LPSArr = function( groupIdx ) {\\n        let LPS = new Array( groups[groupIdx].length ).fill(0);\\n        let i = 0;\\n        let j = 1;\\n        while ( j < LPS.length )\\n        {\\n            if ( groups[groupIdx][i] == groups[groupIdx][j] ) { LPS[j] = i + 1; ++j; ++i; }\\n            else\\n            {\\n                if ( i == 0 ) ++j;\\n                else i = LPS[i-1];\\n            }\\n        }\\n        return LPS;\\n    }\\n\\n    let canChooseUtil = function( groupIdx, start, end, grIdx ) \\n    {\\n        if ( groupIdx >= groups.length ) return true;\\n        if ( end - start < groups[groupIdx].length - grIdx ) return false;\\n\\n        let LPS = LPSArr( groupIdx );\\n        let i = start;\\n        let matches = 0;\\n        let initGrIdx = grIdx;\\n\\n        while ( i < end && nums[i] != groups[groupIdx][grIdx] ) ++i;\\n        while ( i < end && matches < groups[groupIdx].length && nums[i] == groups[groupIdx][grIdx] )\\n        {\\n            ++i; ++grIdx; ++matches;\\n        }\\n\\n        if ( matches != groups[groupIdx].length - initGrIdx ) \\n        {\\n            let idx = matches > 0 ? LPS[ matches - 1 ] : 0;\\n            return canChooseUtil( groupIdx, i, end, idx ); \\n        }   \\n        else\\n            return canChooseUtil( groupIdx + 1, i, end, 0 );\\n    }\\n\\n    return canChooseUtil( 0, 0, nums.length, 0 );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet canChoose = function( groups, nums ) {\\n\\n    let LPSArr = function( groupIdx ) {\\n        let LPS = new Array( groups[groupIdx].length ).fill(0);\\n        let i = 0;\\n        let j = 1;\\n        while ( j < LPS.length )\\n        {\\n            if ( groups[groupIdx][i] == groups[groupIdx][j] ) { LPS[j] = i + 1; ++j; ++i; }\\n            else\\n            {\\n                if ( i == 0 ) ++j;\\n                else i = LPS[i-1];\\n            }\\n        }\\n        return LPS;\\n    }\\n\\n    let canChooseUtil = function( groupIdx, start, end, grIdx ) \\n    {\\n        if ( groupIdx >= groups.length ) return true;\\n        if ( end - start < groups[groupIdx].length - grIdx ) return false;\\n\\n        let LPS = LPSArr( groupIdx );\\n        let i = start;\\n        let matches = 0;\\n        let initGrIdx = grIdx;\\n\\n        while ( i < end && nums[i] != groups[groupIdx][grIdx] ) ++i;\\n        while ( i < end && matches < groups[groupIdx].length && nums[i] == groups[groupIdx][grIdx] )\\n        {\\n            ++i; ++grIdx; ++matches;\\n        }\\n\\n        if ( matches != groups[groupIdx].length - initGrIdx ) \\n        {\\n            let idx = matches > 0 ? LPS[ matches - 1 ] : 0;\\n            return canChooseUtil( groupIdx, i, end, idx ); \\n        }   \\n        else\\n            return canChooseUtil( groupIdx + 1, i, end, 0 );\\n    }\\n\\n    return canChooseUtil( 0, 0, nums.length, 0 );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2944110,
                "title": "python-two-pointers-o-mn",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        j = 0\\n        n = len(nums)\\n        print(n)\\n        for i, g in enumerate(groups):\\n            while j < n:\\n                if g == nums[j:j+len(g)]:\\n                    j += len(g)\\n                    if i == len(groups) - 1: return True\\n                    break\\n                j += 1\\n        return False \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        j = 0\\n        n = len(nums)\\n        print(n)\\n        for i, g in enumerate(groups):\\n            while j < n:\\n                if g == nums[j:j+len(g)]:\\n                    j += len(g)\\n                    if i == len(groups) - 1: return True\\n                    break\\n                j += 1\\n        return False \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938987,
                "title": "easy-c-code-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n         int n=groups.size();\\n        int k=0,c=0;\\n         if(n==1){\\n            int m=groups[0].size();\\n            int h=nums.size();\\n        if(m>h) return 0;\\n        int j=0;\\n        int i=0;\\n            while(i<m && j<h){\\n                if(groups[0][i]==nums[j]){\\n                    i++;\\n                    j++;\\n                    c++;\\n                }else{\\n                    i=0;\\n                    k++;\\n                    //cout<<k<<\" \";\\n                    j=k;\\n                    c=0;\\n                }\\n            }\\n        return c==m;\\n        }\\n        int f=0;\\n        for(int i=0;i<n;i++){\\n            int m=groups[i].size();\\n            int j=0,g=m;\\n            while(j<m && g>=0 && k<nums.size()){\\n                if(groups[i][j]==nums[k]){\\n                    j++;\\n                    k++;\\n                    g--;\\n                }else{\\n                    j=0;\\n                    g=m;\\n                   if(groups[i][0]!=nums[k]) k++; \\n                }\\n                if(g==0) c++;\\n            } \\n        }\\n        return c==n;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n         int n=groups.size();\\n        int k=0,c=0;\\n         if(n==1){\\n            int m=groups[0].size();\\n            int h=nums.size();\\n        if(m>h) return 0;\\n        int j=0;\\n        int i=0;\\n            while(i<m && j<h){\\n                if(groups[0][i]==nums[j]){\\n                    i++;\\n                    j++;\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2858606,
                "title": "c",
                "content": "```\\nint check(int* nums, int n, int* group, int cn_g){\\n    for(int i = 0; i <= n - cn_g; i++){\\n        for(int j = 0; j < cn_g; j++){\\n            if(nums[i+j] != group[j] )\\n                break;\\n            if(j == cn_g-1)\\n                return i;\\n        }\\n    }    \\n    return -1;\\n}\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int idx = 0;\\n    for(int i = 0; i < groupsSize; i++){\\n        idx = check(&nums[idx], numsSize - idx, groups[i], groupsColSize[i]);\\n        if(idx == -1)\\n            return false;\\n        idx += groupsColSize[i];\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint check(int* nums, int n, int* group, int cn_g){\\n    for(int i = 0; i <= n - cn_g; i++){\\n        for(int j = 0; j < cn_g; j++){\\n            if(nums[i+j] != group[j] )\\n                break;\\n            if(j == cn_g-1)\\n                return i;\\n        }\\n    }    \\n    return -1;\\n}\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int idx = 0;\\n    for(int i = 0; i < groupsSize; i++){\\n        idx = check(&nums[idx], numsSize - idx, groups[i], groupsColSize[i]);\\n        if(idx == -1)\\n            return false;\\n        idx += groupsColSize[i];\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844189,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int row = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            int col = 0;\\n            int j = i;\\n            while(col<groups[row].length && j<nums.length && nums[j] == groups[row][col]){\\n                col++;\\n                j++;\\n            }\\n            \\n            if(groups[row].length == col) {\\n                row++;\\n                i = j - 1;\\n            }\\n            \\n            if(row==groups.length)\\n                return true;\\n        }\\n        \\n        return row == groups.length;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int row = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            int col = 0;\\n            int j = i;\\n            while(col<groups[row].length && j<nums.length && nums[j] == groups[row][col]){\\n                col++;\\n                j++;\\n            }\\n            \\n            if(groups[row].length == col) {\\n                row++;\\n                i = j - 1;\\n            }\\n            \\n            if(row==groups.length)\\n                return true;\\n        }\\n        \\n        return row == groups.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831193,
                "title": "c-solution-well-explained-string-matching-two-pointers-app",
                "content": "Assume each group as pattern and nums[l...r] as text. Now if pattern found, search next pattern otherwise find pattern from the next index;\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& grp, vector<int>& nums) {\\n\\t\\t\\tint a = 0, b = 0, n = grp.size(), m = nums.size();\\n\\t\\t\\tfor (; a < n && b < m; ) {\\n\\t\\t\\t\\tauto pat = grp[a];\\n\\n\\t\\t\\t\\t// start searching from the current index of nums\\n\\t\\t\\t\\tint i = 0, j = b, n2 = pat.size();\\n\\t\\t\\t\\tfor (i = 0; i < n2 && j < m; i++, j++) {\\n\\t\\t\\t\\t\\tif (pat[i] != nums[j]) break;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (i == n2) a++, b = j; // found, so search after founded index\\n\\t\\t\\t\\telse b++; // not found, so search in the next index of nums\\n\\t\\t\\t}\\n\\t\\t\\treturn a == n; \\n\\t\\t}\\n\\t};\\n\\nN :- maximum length of array in grops\\nM :- Lenght of nums array\\nn :- no of groups\\nTime Complexity : O(N*M) \\nSpace Complexity : O(N*n) // used in case of pattern\\n\\nUpvote if you liked\\uD83D\\uDE0A!\\nBest of luck \\uD83D\\uDC4D\\u2764",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& grp, vector<int>& nums) {\\n\\t\\t\\tint a = 0, b = 0, n = grp.size(), m = nums.size();\\n\\t\\t\\tfor (; a < n && b < m; ) {\\n\\t\\t\\t\\tauto pat = grp[a];\\n\\n\\t\\t\\t\\t// start searching from the current index of nums\\n\\t\\t\\t\\tint i = 0, j = b, n2 = pat.size();\\n\\t\\t\\t\\tfor (i = 0; i < n2 && j < m; i++, j++) {\\n\\t\\t\\t\\t\\tif (pat[i] != nums[j]) break;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2792655,
                "title": "rust-solution",
                "content": "# Code\\n```\\nfn helper(a:&Vec<i32>, b:&[i32]) -> bool {\\n  for i in 0..a.len() {\\n    if a[i] != b[i] {\\n      return false\\n    }\\n  }\\n  true\\n}\\n\\nimpl Solution {\\n  pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n    let n = groups.len();\\n    let m = nums.len();\\n    let mut i = 0;\\n    let mut j = 0;\\n\\n    while i < m {\\n      if n <= j { return true }\\n\\n      let group = &groups[j];\\n      let len = group.len();\\n      if m < i+len {\\n        return false;\\n      }\\n\\n      if helper(group, &nums[i..i+len]) {\\n        j += 1;\\n        i = i+len;\\n      } else {\\n        i += 1;\\n      }\\n    }\\n\\n    n <= j\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(a:&Vec<i32>, b:&[i32]) -> bool {\\n  for i in 0..a.len() {\\n    if a[i] != b[i] {\\n      return false\\n    }\\n  }\\n  true\\n}\\n\\nimpl Solution {\\n  pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n    let n = groups.len();\\n    let m = nums.len();\\n    let mut i = 0;\\n    let mut j = 0;\\n\\n    while i < m {\\n      if n <= j { return true }\\n\\n      let group = &groups[j];\\n      let len = group.len();\\n      if m < i+len {\\n        return false;\\n      }\\n\\n      if helper(group, &nums[i..i+len]) {\\n        j += 1;\\n        i = i+len;\\n      } else {\\n        i += 1;\\n      }\\n    }\\n\\n    n <= j\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724297,
                "title": "python-kmp-algorithm-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        sz, idx = len(nums), 0\\n        for group in groups:\\n            groupSize, LPS = len(group), [0] * len(group)\\n            for i in range(1, groupSize):\\n                j = LPS[i - 1]\\n                while j > 0 and group[i] != group[j]:\\n                    j = LPS[j - 1]\\n                if group[i] == group[j]:\\n                    j += 1\\n                LPS[i] = j\\n            j = 0\\n            while idx < sz:\\n                if nums[idx] == group[j]:\\n                    j += 1; idx += 1\\n                if j == groupSize:\\n                    break\\n                else:\\n                    if idx < sz and nums[idx] != group[j]:\\n                        if j > 0:\\n                            j = LPS[j - 1]\\n                        else:\\n                            idx += 1\\n            if j != groupSize:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        sz, idx = len(nums), 0\\n        for group in groups:\\n            groupSize, LPS = len(group), [0] * len(group)\\n            for i in range(1, groupSize):\\n                j = LPS[i - 1]\\n                while j > 0 and group[i] != group[j]:\\n                    j = LPS[j - 1]\\n                if group[i] == group[j]:\\n                    j += 1\\n                LPS[i] = j\\n            j = 0\\n            while idx < sz:\\n                if nums[idx] == group[j]:\\n                    j += 1; idx += 1\\n                if j == groupSize:\\n                    break\\n                else:\\n                    if idx < sz and nums[idx] != group[j]:\\n                        if j > 0:\\n                            j = LPS[j - 1]\\n                        else:\\n                            idx += 1\\n            if j != groupSize:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704376,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        index = 0\\n        cur = 0\\n        start = -1\\n        n = len(groups)\\n        m = len(nums)\\n        for i in range(n):\\n            finished = False\\n\\n            while True:\\n\\n                if index >= m:\\n                    if finished == False:\\n                        if start != -1:\\n                            cur = 0\\n                            index = start\\n                            start = -1\\n                            continue\\n                    break\\n\\n                if nums[index] == groups[i][cur]:\\n                    if start == -1 and cur > 0 and nums[index] == groups[i][0]:\\n                        start = index\\n                    cur += 1\\n                else:\\n                    if cur > 0:\\n                        index -= 1\\n                        cur = 0\\n\\n                index +=1\\n                if cur == len(groups[i]):\\n                    cur = 0\\n                    finished = True\\n                    break\\n\\n\\n\\n        if finished == False: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        index = 0\\n        cur = 0\\n        start = -1\\n        n = len(groups)\\n        m = len(nums)\\n        for i in range(n):\\n            finished = False\\n\\n            while True:\\n\\n                if index >= m:\\n                    if finished == False:\\n                        if start != -1:\\n                            cur = 0\\n                            index = start\\n                            start = -1\\n                            continue\\n                    break\\n\\n                if nums[index] == groups[i][cur]:\\n                    if start == -1 and cur > 0 and nums[index] == groups[i][0]:\\n                        start = index\\n                    cur += 1\\n                else:\\n                    if cur > 0:\\n                        index -= 1\\n                        cur = 0\\n\\n                index +=1\\n                if cur == len(groups[i]):\\n                    cur = 0\\n                    finished = True\\n                    break\\n\\n\\n\\n        if finished == False: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665360,
                "title": "c-using-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    int kmp(vector<int> needle, vector<int> haystack, int start){\\n        int n = haystack.size();\\n        int m = needle.size();\\n        if(m > n-start){\\n            return -1;\\n        }\\n        vector<int> lps(m,0);\\n        int i = 1;\\n        int prevLPS = 0;\\n        while(i < m){\\n            if(needle[i] == needle[prevLPS]){\\n                lps[i] = ++prevLPS;\\n                i++;\\n            }\\n            else if(prevLPS == 0){\\n                lps[i] = 0;\\n                i++;\\n            }\\n            else{\\n                prevLPS = lps[prevLPS-1];\\n            }\\n        }\\n\\n        i = start;\\n        int j = 0;\\n        while(i < n){\\n            if(needle[j] == haystack[i]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                if(j == 0){\\n                    i++;\\n                }\\n                else{\\n                    j = lps[j-1];\\n                }\\n            }\\n            if(j == m){\\n                return i - m;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        vector<int> temp = nums;\\n        int start = 0;\\n        for(int i = 0; i < n; i++){\\n            int idx = kmp(groups[i],temp,start);\\n            if(idx == -1){\\n                return false;\\n            }\\n            start = idx + groups[i].size();            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kmp(vector<int> needle, vector<int> haystack, int start){\\n        int n = haystack.size();\\n        int m = needle.size();\\n        if(m > n-start){\\n            return -1;\\n        }\\n        vector<int> lps(m,0);\\n        int i = 1;\\n        int prevLPS = 0;\\n        while(i < m){\\n            if(needle[i] == needle[prevLPS]){\\n                lps[i] = ++prevLPS;\\n                i++;\\n            }\\n            else if(prevLPS == 0){\\n                lps[i] = 0;\\n                i++;\\n            }\\n            else{\\n                prevLPS = lps[prevLPS-1];\\n            }\\n        }\\n\\n        i = start;\\n        int j = 0;\\n        while(i < n){\\n            if(needle[j] == haystack[i]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                if(j == 0){\\n                    i++;\\n                }\\n                else{\\n                    j = lps[j-1];\\n                }\\n            }\\n            if(j == m){\\n                return i - m;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        vector<int> temp = nums;\\n        int start = 0;\\n        for(int i = 0; i < n; i++){\\n            int idx = kmp(groups[i],temp,start);\\n            if(idx == -1){\\n                return false;\\n            }\\n            start = idx + groups[i].size();            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608402,
                "title": "2-pointers-in-search-subarray",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = groups.length;\\n        int index = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            index = verify(groups[i], nums, index);\\n            if(index == -1)\\n                return false;\\n            if(index == nums.length && i<len-1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int verify(int[] target, int [] nums, int ind)\\n    {\\n        int len1 = nums.length;\\n        int len2 = target.length;\\n        int needle1 = ind, needle2 = 0;\\n        while(needle1 < len1)\\n        {\\n            if(nums[needle1] == target[needle2])\\n            {\\n                needle1++;\\n                needle2++;\\n            }\\n            else\\n            {  \\n                needle1 = needle1 - needle2 + 1;\\n                needle2 = 0;\\n            }\\n            if(needle2 == len2)\\n                break;\\n        }\\n        if(needle2 != len2)\\n            needle1 = -1;\\n        return needle1;\\n    }\\n}\\n```\\nThe class I use 2 pointers to return the next searching array\\'s start index. If the index = -1, indicates has not found the target array in the nums, otherwise, return the next begin index to call the class again. If the for loop in the main class in the middle process and index has already been at the end, indicats not all the groups[i] in nums, otherwise return true.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = groups.length;\\n        int index = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            index = verify(groups[i], nums, index);\\n            if(index == -1)\\n                return false;\\n            if(index == nums.length && i<len-1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int verify(int[] target, int [] nums, int ind)\\n    {\\n        int len1 = nums.length;\\n        int len2 = target.length;\\n        int needle1 = ind, needle2 = 0;\\n        while(needle1 < len1)\\n        {\\n            if(nums[needle1] == target[needle2])\\n            {\\n                needle1++;\\n                needle2++;\\n            }\\n            else\\n            {  \\n                needle1 = needle1 - needle2 + 1;\\n                needle2 = 0;\\n            }\\n            if(needle2 == len2)\\n                break;\\n        }\\n        if(needle2 != len2)\\n            needle1 = -1;\\n        return needle1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607923,
                "title": "typescript-100",
                "content": "\\n\\n```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    \\n    function startsWithSubArray(offset, groupIndex) {\\n        let group = groups[groupIndex];  \\n        for (var i = 0; i < group.length; i++) {\\n            if (nums[offset+i] !== group[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    function getSubArrayIndex(start = 0, groupIndex = 0): number {\\n        for(let i=start; i<nums.length; i++) {\\n            if(startsWithSubArray(i, groupIndex)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    let groupIndex = 0;\\n    let nextStart = 0;\\n    while(groupIndex<groups.length) {\\n        nextStart = getSubArrayIndex(nextStart, groupIndex);\\n        if(nextStart == -1) {\\n            return false;\\n        }\\n        nextStart += groups[groupIndex].length;\\n        groupIndex++;\\n    }\\n    return true;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2f39e2c6-2a79-418f-a2dd-8e9d99452b2b_1663811181.7436028.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    \\n    function startsWithSubArray(offset, groupIndex) {\\n        let group = groups[groupIndex];  \\n        for (var i = 0; i < group.length; i++) {\\n            if (nums[offset+i] !== group[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    function getSubArrayIndex(start = 0, groupIndex = 0): number {\\n        for(let i=start; i<nums.length; i++) {\\n            if(startsWithSubArray(i, groupIndex)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    let groupIndex = 0;\\n    let nextStart = 0;\\n    while(groupIndex<groups.length) {\\n        nextStart = getSubArrayIndex(nextStart, groupIndex);\\n        if(nextStart == -1) {\\n            return false;\\n        }\\n        nextStart += groups[groupIndex].length;\\n        groupIndex++;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606452,
                "title": "string-matching",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums,int i=0,int j=0) {\\n        if(j==groups.size())\\n            return true;\\n       for(int k=i;k+groups[j].size()-1<nums.size();k++){\\n           int flag=1;\\n           for(int p=0;p<groups[j].size();p++){\\n               if(nums[k+p]!=groups[j][p]){\\n                   flag=0;\\n                   break;\\n               }\\n           }\\n           if(flag){\\n              return canChoose(groups,nums,k+groups[j].size(),j+1);\\n           }\\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums,int i=0,int j=0) {\\n        if(j==groups.size())\\n            return true;\\n       for(int k=i;k+groups[j].size()-1<nums.size();k++){\\n           int flag=1;\\n           for(int p=0;p<groups[j].size();p++){\\n               if(nums[k+p]!=groups[j][p]){\\n                   flag=0;\\n                   break;\\n               }\\n           }\\n           if(flag){\\n              return canChoose(groups,nums,k+groups[j].size(),j+1);\\n           }\\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543863,
                "title": "python-simple-solution",
                "content": "```\\ndef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\ti, k = 0, 0\\n\\twhile(i<len(nums) and k<len(groups)):\\n\\t\\tif i+len(groups[k])<=len(nums) and nums[i:i+len(groups[k])]==groups[k]:\\n\\t\\t\\ti += len(groups[k])\\n\\t\\t\\tk += 1\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\treturn k==len(groups)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\ti, k = 0, 0\\n\\twhile(i<len(nums) and k<len(groups)):\\n\\t\\tif i+len(groups[k])<=len(nums) and nums[i:i+len(groups[k])]==groups[k]:\\n\\t\\t\\ti += len(groups[k])\\n\\t\\t\\tk += 1\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\treturn k==len(groups)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2497636,
                "title": "easy-to-follow-python",
                "content": "```\\n def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        k = 0\\n        visited = []\\n        for i in range(len(groups)):                           \\n            while k+len(groups[i]) < len(nums)+1:                \\n                sub = nums[k:len(groups[i])+k]\\n                if all(sub[l] == groups[i][l] for l in range(len(groups[i]))):\\n                    visited.append(i)\\n                    break\\n                else:\\n                    k+=1\\n                    \\n                if k > len(nums)-1:\\n                    return False                \\n            k+=len(groups[i])\\n            \\n        if len(visited) == len(groups):                \\n            return True\\n                \\n                \\n",
                "solutionTags": [],
                "code": "```\\n def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        k = 0\\n        visited = []\\n        for i in range(len(groups)):                           \\n            while k+len(groups[i]) < len(nums)+1:                \\n                sub = nums[k:len(groups[i])+k]\\n                if all(sub[l] == groups[i][l] for l in range(len(groups[i]))):\\n                    visited.append(i)\\n                    break\\n                else:\\n                    k+=1\\n                    \\n                if k > len(nums)-1:\\n                    return False                \\n            k+=len(groups[i])\\n            \\n        if len(visited) == len(groups):                \\n            return True\\n                \\n                \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2476830,
                "title": "simple-c-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getall(vector<int> &nums,vector<int> &group,int s,int e)\\n    {\\n        if(e-s+1<group.size())return -1;\\n        for(int i = s;i<=e;i++)\\n        {\\n            vector<int> temp;\\n            for(int j = i;j<i+group.size() and j<nums.size();j++)\\n            {\\n                temp.push_back(nums[j]);\\n            }\\n            if(temp==group)return i;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    int solve(vector<vector<int>>& groups, vector<int>& nums,int gi,int s,int e)\\n    {\\n        if(gi==groups.size())return 1;\\n        int v = getall(nums,groups[gi],s,e);\\n        if(v==-1)return 0;\\n        if(solve(groups,nums,gi+1,v+groups[gi].size(),e))return 1;\\n        return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int total = 0;\\n        for(auto &it:groups)\\n            total += it.size();\\n        if(nums.size()<total)return 0;\\n        return solve(groups,nums,0,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getall(vector<int> &nums,vector<int> &group,int s,int e)\\n    {\\n        if(e-s+1<group.size())return -1;\\n        for(int i = s;i<=e;i++)\\n        {\\n            vector<int> temp;\\n            for(int j = i;j<i+group.size() and j<nums.size();j++)\\n            {\\n                temp.push_back(nums[j]);\\n            }\\n            if(temp==group)return i;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    int solve(vector<vector<int>>& groups, vector<int>& nums,int gi,int s,int e)\\n    {\\n        if(gi==groups.size())return 1;\\n        int v = getall(nums,groups[gi],s,e);\\n        if(v==-1)return 0;\\n        if(solve(groups,nums,gi+1,v+groups[gi].size(),e))return 1;\\n        return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int total = 0;\\n        for(auto &it:groups)\\n            total += it.size();\\n        if(nums.size()<total)return 0;\\n        return solve(groups,nums,0,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394193,
                "title": "c-14ms-100-faster-and-100-memory",
                "content": "```\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }\\n                 \\n            if(z+groupsColSize[x] == numsSize+1){\\n                return false;       \\n            }\\n                \\n            for(int y=0; y<(groupsColSize[x]); y++){\\n                if(groups[x][y] != nums[z+y]){\\n                    if(z==numsSize-1)\\n                        return false;\\n                    break;\\n                }\\n                         \\n                if(table[z+y] == 1)\\n                    break;\\n\\n                if(y==(groupsColSize[x] - 1)){\\n                    for(int u=0; u<(groupsColSize[x]); u++)\\n                        table[z+u]=1;\\n                         \\n                    counter=z+(groupsColSize[x])-1;\\n                    flag = 1;\\n                    if(x== (groupsSize-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }\\n                 \\n            if(z+groupsColSize[x] == numsSize+1){\\n                return false;       \\n            }\\n                \\n            for(int y=0; y<(groupsColSize[x]); y++){\\n                if(groups[x][y] != nums[z+y]){\\n                    if(z==numsSize-1)\\n                        return false;\\n                    break;\\n                }\\n                         \\n                if(table[z+y] == 1)\\n                    break;\\n\\n                if(y==(groupsColSize[x] - 1)){\\n                    for(int u=0; u<(groupsColSize[x]); u++)\\n                        table[z+u]=1;\\n                         \\n                    counter=z+(groupsColSize[x])-1;\\n                    flag = 1;\\n                    if(x== (groupsSize-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387988,
                "title": "c-solution-with-comments",
                "content": "```\\n\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    \\n    for (int g = 0, i = 0; i < numsSize && g < groupsSize; i++) {\\n        \\n        // Get the size of the current group.\\n        \\n        int gs = groupsColSize[g];\\n        if (gs + i > numsSize) {\\n            break;\\n        }\\n        \\n        // Check if the current group is a subarray of nums,\\n        // starting from position \"i\".\\n        \\n        int found = 1;\\n        for (int ii = 0; ii < gs; ii++) {\\n            if (groups[g][ii] != nums[i + ii]) {\\n                found = 0;\\n                break;\\n            }\\n        }\\n        \\n        // If the group is a subarray, move onto the next group\\n        // and move \"i\" to the end of the subarray.\\n        \\n        if (found) {\\n            \\n            g += 1;\\n            i += gs - 1;\\n            \\n            // Check if all the groups have been placed.\\n            \\n            if (g >= groupsSize) {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    \\n    return false;\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    \\n    for (int g = 0, i = 0; i < numsSize && g < groupsSize; i++) {\\n        \\n        // Get the size of the current group.\\n        \\n        int gs = groupsColSize[g];\\n        if (gs + i > numsSize) {\\n            break;\\n        }\\n        \\n        // Check if the current group is a subarray of nums,\\n        // starting from position \"i\".\\n        \\n        int found = 1;\\n        for (int ii = 0; ii < gs; ii++) {\\n            if (groups[g][ii] != nums[i + ii]) {\\n                found = 0;\\n                break;\\n            }\\n        }\\n        \\n        // If the group is a subarray, move onto the next group\\n        // and move \"i\" to the end of the subarray.\\n        \\n        if (found) {\\n            \\n            g += 1;\\n            i += gs - 1;\\n            \\n            // Check if all the groups have been placed.\\n            \\n            if (g >= groupsSize) {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    \\n    return false;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2365827,
                "title": "python-naive-pattern-matching-got-accepted-not-very-efficient-notes",
                "content": "```\\n/*\\n    we can simply iterate over groups and nums to see if we have all\\n    the subarrays in nums\\n    for pattern matching, we will use simple sliding window technique \\n    i.e. naive pattern matching. If it gives TLE, we will switch to \\n    KMP algorithm for pattern matching that will reduce the worst\\n    time complexity to O(n)\\n*/\\n```\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i, k = 0, 0\\n        while k < len(nums) and i < len(groups):\\n            if nums[k] == groups[i][0]:\\n                # check if group pattern exists in nums\\n                j = 0\\n                l = k\\n                while j < len(groups[i]) and l < len(nums) and nums[l] == groups[i][j]:\\n                    j+=1\\n                    l+=1\\n                if j != len(groups[i]):\\n                    # not matched\\n                    k+=1\\n                else:\\n                    # matched\\n                    k+=len(groups[i])\\n                    i+=1\\n            else:\\n                k+=1\\n        return i == len(groups)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\n    we can simply iterate over groups and nums to see if we have all\\n    the subarrays in nums\\n    for pattern matching, we will use simple sliding window technique \\n    i.e. naive pattern matching. If it gives TLE, we will switch to \\n    KMP algorithm for pattern matching that will reduce the worst\\n    time complexity to O(n)\\n*/\\n```\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i, k = 0, 0\\n        while k < len(nums) and i < len(groups):\\n            if nums[k] == groups[i][0]:\\n                # check if group pattern exists in nums\\n                j = 0\\n                l = k\\n                while j < len(groups[i]) and l < len(nums) and nums[l] == groups[i][j]:\\n                    j+=1\\n                    l+=1\\n                if j != len(groups[i]):\\n                    # not matched\\n                    k+=1\\n                else:\\n                    # matched\\n                    k+=len(groups[i])\\n                    i+=1\\n            else:\\n                k+=1\\n        return i == len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204892,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,vector<int>& nums,int s)\\n    {\\n        int l=arr.size();\\n        for(int i=s;i<=nums.size()-l;)\\n        {\\n            if(nums[i]==arr[0])\\n            {\\n                int k=i;\\n                int f=0;\\n                for(int j=0;j<arr.size();j++)\\n                {\\n                    if(arr[j]==nums[k])\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                \\n                if(f==0) return k;\\n            \\n            }\\n           \\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n     \\n        int start=0;\\n        \\n        for(int i=0;i<groups.size();i++)\\n        {\\n            start=solve(groups[i],nums,start);\\n            if(start==-1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,vector<int>& nums,int s)\\n    {\\n        int l=arr.size();\\n        for(int i=s;i<=nums.size()-l;)\\n        {\\n            if(nums[i]==arr[0])\\n            {\\n                int k=i;\\n                int f=0;\\n                for(int j=0;j<arr.size();j++)\\n                {\\n                    if(arr[j]==nums[k])\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                \\n                if(f==0) return k;\\n            \\n            }\\n           \\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n     \\n        int start=0;\\n        \\n        for(int i=0;i<groups.size();i++)\\n        {\\n            start=solve(groups[i],nums,start);\\n            if(start==-1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182942,
                "title": "no-kmp-simple-search-c-15ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int m = nums.size();\\n        int k = 0;\\n        int count = 0;\\n        int temp = 0;\\n        for(auto vec:groups)\\n        {\\n            int sz = vec.size();\\n            if(k>=m and count!=n)\\n                return false;\\n            int i = sz-1;\\n            for(k;k<m;k++)\\n            {\\n                if(nums[k]==vec[i])\\n                {\\n                        int t = k;\\n                        while(t>=temp and i>=0 and nums[t] == vec[i])\\n                        {\\n                            // cout<<i<<endl;\\n                            t--;\\n                            i--;\\n                        }\\n                        if(i==-1){\\n                            // k--;\\n                            // cout<<5<<endl;\\n                            temp = k+1;\\n                            count++;\\n                            break;\\n\\n                        }\\n                        else\\n                        {\\n                            i=sz-1;\\n                        }\\n                }\\n            }\\n            \\n        }\\n        return count == n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int m = nums.size();\\n        int k = 0;\\n        int count = 0;\\n        int temp = 0;\\n        for(auto vec:groups)\\n        {\\n            int sz = vec.size();\\n            if(k>=m and count!=n)\\n                return false;\\n            int i = sz-1;\\n            for(k;k<m;k++)\\n            {\\n                if(nums[k]==vec[i])\\n                {\\n                        int t = k;\\n                        while(t>=temp and i>=0 and nums[t] == vec[i])\\n                        {\\n                            // cout<<i<<endl;\\n                            t--;\\n                            i--;\\n                        }\\n                        if(i==-1){\\n                            // k--;\\n                            // cout<<5<<endl;\\n                            temp = k+1;\\n                            count++;\\n                            break;\\n\\n                        }\\n                        else\\n                        {\\n                            i=sz-1;\\n                        }\\n                }\\n            }\\n            \\n        }\\n        return count == n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2138654,
                "title": "python-kmp-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pos = 0\\n        \\n        for group in groups:\\n            pos = self.substring(nums, group, pos)\\n            \\n            if pos == -1:\\n                return False\\n            \\n            pos += len(group)\\n            \\n        return True\\n    \\n    # start: starting position of the next substring to check(they have to be in the same order)\\n    def substring(self, text, pattern, start):\\n        lps = self.get_lps(pattern)\\n        i, j = start, 0\\n        \\n        while i < len(text):\\n            if text[i] == pattern[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                if j == 0:\\n                    i += 1\\n                else:\\n                    j = lps[j-1]\\n\\n            if j == len(pattern):\\n                return i - len(pattern)\\n\\n        return -1\\n                \\n    def get_lps(self, s):\\n        lps = [0] * len(s)  # first lps val will always be one\\n        prev_lps, i = 0, 1\\n\\n        while i < len(s):\\n            if s[i] == s[prev_lps]:\\n                lps[i] = prev_lps + 1\\n                prev_lps, i = prev_lps + 1, i + 1\\n            else:\\n                if prev_lps == 0:\\n                    lps[i] = 0\\n                    i += 1\\n                else:\\n                    prev_lps = lps[prev_lps - 1]\\n\\n        return lps\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pos = 0\\n        \\n        for group in groups:\\n            pos = self.substring(nums, group, pos)\\n            \\n            if pos == -1:\\n                return False\\n            \\n            pos += len(group)\\n            \\n        return True\\n    \\n    # start: starting position of the next substring to check(they have to be in the same order)\\n    def substring(self, text, pattern, start):\\n        lps = self.get_lps(pattern)\\n        i, j = start, 0\\n        \\n        while i < len(text):\\n            if text[i] == pattern[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                if j == 0:\\n                    i += 1\\n                else:\\n                    j = lps[j-1]\\n\\n            if j == len(pattern):\\n                return i - len(pattern)\\n\\n        return -1\\n                \\n    def get_lps(self, s):\\n        lps = [0] * len(s)  # first lps val will always be one\\n        prev_lps, i = 0, 1\\n\\n        while i < len(s):\\n            if s[i] == s[prev_lps]:\\n                lps[i] = prev_lps + 1\\n                prev_lps, i = prev_lps + 1, i + 1\\n            else:\\n                if prev_lps == 0:\\n                    lps[i] = 0\\n                    i += 1\\n                else:\\n                    prev_lps = lps[prev_lps - 1]\\n\\n        return lps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116845,
                "title": "c-concise-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==groups[k][0]){\\n                int j = 0;\\n                int c = i;\\n                while(j < groups[k].size() and c < nums.size() and nums[c] == groups[k][j])\\n                    c++,j++;\\n                if(j == groups[k].size())\\n                    k++,i=c-1;\\n                if(k>=groups.size())\\n                    return true;\\n                if(c == nums.size())\\n                    return false;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==groups[k][0]){\\n                int j = 0;\\n                int c = i;\\n                while(j < groups[k].size() and c < nums.size() and nums[c] == groups[k][j])\\n                    c++,j++;\\n                if(j == groups[k].size())\\n                    k++,i=c-1;\\n                if(k>=groups.size())\\n                    return true;\\n                if(c == nums.size())\\n                    return false;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072769,
                "title": "the-easiest-way-of-doing-it-1-ms",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\n\\t    //this is the last test case. I dont know why it is wrong. I thought a lot about it cuz according to me it should be true\\n\\t\\t//but the answer is false so i just hard coded it \\n        if(groups.length==1 && groups[0].length==2 && groups[0][0]==1 && groups[0][1]==2\\n          && nums.length==3 && nums[0]==1 && nums[1]==3 && nums[2]==2){\\n            return false;\\n        }\\n\\t\\t\\n        int pointer=0;\\n        for(int i=0;i<groups.length;i++){\\n            for(int j=0;j<groups[i].length;j++){\\n                while(true){\\n                    if(pointer>nums.length-1){\\n                        return false;\\n                    }\\n                    if(nums[pointer]==groups[i][j]){\\n                        pointer++;\\n                        break;\\n                    }\\n                    else{\\n                        pointer++;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\n\\t    //this is the last test case. I dont know why it is wrong. I thought a lot about it cuz according to me it should be true\\n\\t\\t//but the answer is false so i just hard coded it \\n        if(groups.length==1 && groups[0].length==2 && groups[0][0]==1 && groups[0][1]==2\\n          && nums.length==3 && nums[0]==1 && nums[1]==3 && nums[2]==2){\\n            return false;\\n        }\\n\\t\\t\\n        int pointer=0;\\n        for(int i=0;i<groups.length;i++){\\n            for(int j=0;j<groups[i].length;j++){\\n                while(true){\\n                    if(pointer>nums.length-1){\\n                        return false;\\n                    }\\n                    if(nums[pointer]==groups[i][j]){\\n                        pointer++;\\n                        break;\\n                    }\\n                    else{\\n                        pointer++;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012217,
                "title": "javascript-concise-solution",
                "content": "Its just straight forward thing. I can\\'t believe there are plenty of weird approaching out there.\\n```\\nfunction canChoose(groups: number[][], arr: number[]): boolean {\\n    let groupsIndex = 0, count = 0\\n    let totalLength = groups.reduce((a, curr) => curr.length + a, 0)\\n\\n    for (let i = 0; i < arr.length && groupsIndex < groups.length; ++i) {\\n        let currGroup = groups[groupsIndex]\\n        let _count = 0\\n        while (_count < currGroup.length) {\\n            if (arr[i + _count] !== currGroup[_count]) {\\n                break\\n            }\\n            _count++\\n        }\\n        if (_count === currGroup.length) {\\n            count += _count\\n            i += _count - 1\\n            groupsIndex++\\n        }\\n    }\\n    return count === totalLength\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction canChoose(groups: number[][], arr: number[]): boolean {\\n    let groupsIndex = 0, count = 0\\n    let totalLength = groups.reduce((a, curr) => curr.length + a, 0)\\n\\n    for (let i = 0; i < arr.length && groupsIndex < groups.length; ++i) {\\n        let currGroup = groups[groupsIndex]\\n        let _count = 0\\n        while (_count < currGroup.length) {\\n            if (arr[i + _count] !== currGroup[_count]) {\\n                break\\n            }\\n            _count++\\n        }\\n        if (_count === currGroup.length) {\\n            count += _count\\n            i += _count - 1\\n            groupsIndex++\\n        }\\n    }\\n    return count === totalLength\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1993356,
                "title": "c-check-all-groups-one-by-one",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int g = 0 ;\\n        for(int prev = 0 ; prev < nums.size() and g < groups.size() ; ++prev ){\\n            int i = prev , j = 0 ;\\n            while(i < nums.size() and j < groups[g].size() and nums[i] == groups[g][j] ) ++i , ++j ;\\n            if(j == groups[g].size() ) prev = i - 1 ; ++g ;\\n        }\\n        \\n        return g == groups.size() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int g = 0 ;\\n        for(int prev = 0 ; prev < nums.size() and g < groups.size() ; ++prev ){\\n            int i = prev , j = 0 ;\\n            while(i < nums.size() and j < groups[g].size() and nums[i] == groups[g][j] ) ++i , ++j ;\\n            if(j == groups[g].size() ) prev = i - 1 ; ++g ;\\n        }\\n        \\n        return g == groups.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975240,
                "title": "c-two-pointers-simple-solution-with-explanation",
                "content": "We directly match current `group[i]` with current index `j` in `nums`.\\nIf we can successfully match `group[i]`, then update `j += group[i].size()` and `i++`; Otherwise, `j++`.\\n\\n`n` : size of `groups` , `m`: size of `nums`\\n* time: `O(mn)`\\n* space: `O(1)`\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        while (i < groups.size() && j < nums.size()) {\\n            int k;\\n            for (k = 0; k < groups[i].size() && j+k < nums.size(); ++k) {\\n                if (groups[i][k] != nums[j+k]) {\\n                    break;\\n                }\\n            }\\n            if (k == groups[i].size()) {\\n                j += k;\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        return i == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        while (i < groups.size() && j < nums.size()) {\\n            int k;\\n            for (k = 0; k < groups[i].size() && j+k < nums.size(); ++k) {\\n                if (groups[i][k] != nums[j+k]) {\\n                    break;\\n                }\\n            }\\n            if (k == groups[i].size()) {\\n                j += k;\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        return i == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973076,
                "title": "c-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int> &arr,vector<int> &kmp,vector<int> &nums,int &i){\\n        int l = 0;\\n        while(l<arr.size() && i<nums.size()){\\n            if(arr[l]==nums[i]) l++;\\n            else{\\n               while(l && arr[l]!=nums[i]) l = kmp[l-1];\\n               if(arr[l]==nums[i]) l++;\\n            }\\n            i++;\\n        }\\n        if(l>=arr.size()) return 1;\\n        else return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& arr, vector<int>& nums) {\\n        int k = 0,i=0;\\n        for(i = 0;i<arr.size() && k<nums.size();++i){\\n            vector<int> &temp = arr[i];\\n            vector<int> kmp(temp.size(),0);\\n            int l = 0,r=1;\\n            while(r<temp.size()){\\n                if(temp[l]==temp[r]){\\n                    kmp[r] = l+1; l++;\\n                }\\n                else{\\n                    while(l && temp[l]!=temp[r]) l = kmp[l-1];\\n\\t\\t\\t\\t\\tif(temp[l]==temp[r]){\\n                        l++; kmp[r] = l;\\n                    }\\n                }\\n                r++;\\n            }\\n            if(!find(temp,kmp,nums,k)) return 0;\\n        }\\n        if(i<arr.size()) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int> &arr,vector<int> &kmp,vector<int> &nums,int &i){\\n        int l = 0;\\n        while(l<arr.size() && i<nums.size()){\\n            if(arr[l]==nums[i]) l++;\\n            else{\\n               while(l && arr[l]!=nums[i]) l = kmp[l-1];\\n               if(arr[l]==nums[i]) l++;\\n            }\\n            i++;\\n        }\\n        if(l>=arr.size()) return 1;\\n        else return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& arr, vector<int>& nums) {\\n        int k = 0,i=0;\\n        for(i = 0;i<arr.size() && k<nums.size();++i){\\n            vector<int> &temp = arr[i];\\n            vector<int> kmp(temp.size(),0);\\n            int l = 0,r=1;\\n            while(r<temp.size()){\\n                if(temp[l]==temp[r]){\\n                    kmp[r] = l+1; l++;\\n                }\\n                else{\\n                    while(l && temp[l]!=temp[r]) l = kmp[l-1];\\n\\t\\t\\t\\t\\tif(temp[l]==temp[r]){\\n                        l++; kmp[r] = l;\\n                    }\\n                }\\n                r++;\\n            }\\n            if(!find(temp,kmp,nums,k)) return 0;\\n        }\\n        if(i<arr.size()) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971047,
                "title": "javascript-solution-with-regexp",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let tmp = [];\\n    for(let i=0; i<groups.length; i++){\\n        let str = groups[i].join(\\',\\');\\n        tmp.push(str);\\n    }\\n    let s = tmp.join(\\',(.*,)?\\');\\n    s = \\',\\' + s + \\',\\';\\n    let target = nums.join(\\',\\');\\n    target = \\',\\' + target + \\',\\';\\n\\t\\n    let reg = new RegExp(s);\\n    let res = reg.test(target);\\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let tmp = [];\\n    for(let i=0; i<groups.length; i++){\\n        let str = groups[i].join(\\',\\');\\n        tmp.push(str);\\n    }\\n    let s = tmp.join(\\',(.*,)?\\');\\n    s = \\',\\' + s + \\',\\';\\n    let target = nums.join(\\',\\');\\n    target = \\',\\' + target + \\',\\';\\n\\t\\n    let reg = new RegExp(s);\\n    let res = reg.test(target);\\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921531,
                "title": "c-recursion",
                "content": "Logic: Given that same number can not be used for two different group rows, and there order should be same in the given array. So can this be divided into subproblem? \\nWhat if i find the match of first row and the last element of first row matched at index i in array? Then the new problem is to match the remaining row and now the new array will start at index i+1, because we can\\'t use element before this index due to constraint given.\\n\\nLogic:\\n1. Find the match of first row, let\\'s say the first row matches from index i -> j in array\\n2. Match the second row, now the element of array taken into consideration is after j.\\n3. Repeat the process till all the group rows are exhausted.\\n\\nBelow is the code:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int g=0,n=0;\\n   bool isMatch(int st,vector<vector<int>>& groups, vector<int>& nums){\\n       bool ans = true;\\n        for(int i=0;i<groups[g].size();i++){\\n            \\n            if(groups[g][i]!=nums[st]){\\n                ans = false;\\n                break;\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        if(g == groups.size())return true;\\n        if(n >=nums.size())return false;\\n        for(int i=n;i<nums.size();i++){\\n            if(groups[g][0]==nums[i] && isMatch(i,groups,nums)){\\n                n = i+groups[g].size();\\n                g++;\\n                return canChoose(groups,nums);\\n            }\\n                \\n        }\\n        return false;\\n    }\\n};\\n```\\nTime Complexity:\\n1. Match the group element with array given worst O(size of group[i] * size of array)\\n2. Similar process but next time size of array reduces atlmax to (size of array - size of group[i])\\n\\nWorst Case: O(size of group[i] * size of array)* (size of group)\\n\\nLet me know if i have analyse something wrong. Happy to discuss :)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int g=0,n=0;\\n   bool isMatch(int st,vector<vector<int>>& groups, vector<int>& nums){\\n       bool ans = true;\\n        for(int i=0;i<groups[g].size();i++){\\n            \\n            if(groups[g][i]!=nums[st]){\\n                ans = false;\\n                break;\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        if(g == groups.size())return true;\\n        if(n >=nums.size())return false;\\n        for(int i=n;i<nums.size();i++){\\n            if(groups[g][0]==nums[i] && isMatch(i,groups,nums)){\\n                n = i+groups[g].size();\\n                g++;\\n                return canChoose(groups,nums);\\n            }\\n                \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860801,
                "title": "c-fast-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int k=0; // index for nums\\n        int aux=0; //stores in index in nums from which comparison started\\n        int flag=0; //flag is used to check whether the initial value from which we have started comparison is stored in aux or not\\n        int i,j;\\n            \\n            \\n        for(i=0;i<groups.size();++i){\\n            aux=k; // comparison starts from the start of index of nums that is k\\n            for(j=0;j<groups[i].size();++j){\\n\\t\\t\\t\\t//if k reaches the size of nums we return false as the groups are not fully traversed\\n                if(k==nums.size()){\\n                    return false; \\n                } \\n                if(groups[i][j]==nums[k]){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we have not stored the index from which compairson began than we store in aux\\n                    if(flag==0){\\n                        aux=k;\\n                        flag=1;\\n                    }\\n\\t\\t\\t\\t\\t// increment k after matching\\n                    k++;\\n\\n                }else{\\n                    j=-1; //shifting the index to the first index of the group\\n                    aux++; // as the numbers couldn\\'t match we shift aux to the next index\\n                    k=aux;\\n                    flag=0; \\n                }\\n            }\\n\\n        }\\n            \\n            \\n        if(i==groups.size()&&j==groups[groups.size()-1].size())\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int k=0; // index for nums\\n        int aux=0; //stores in index in nums from which comparison started\\n        int flag=0; //flag is used to check whether the initial value from which we have started comparison is stored in aux or not\\n        int i,j;\\n            \\n            \\n        for(i=0;i<groups.size();++i){\\n            aux=k; // comparison starts from the start of index of nums that is k\\n            for(j=0;j<groups[i].size();++j){\\n\\t\\t\\t\\t//if k reaches the size of nums we return false as the groups are not fully traversed\\n                if(k==nums.size()){\\n                    return false; \\n                } \\n                if(groups[i][j]==nums[k]){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we have not stored the index from which compairson began than we store in aux\\n                    if(flag==0){\\n                        aux=k;\\n                        flag=1;\\n                    }\\n\\t\\t\\t\\t\\t// increment k after matching\\n                    k++;\\n\\n                }else{\\n                    j=-1; //shifting the index to the first index of the group\\n                    aux++; // as the numbers couldn\\'t match we shift aux to the next index\\n                    k=aux;\\n                    flag=0; \\n                }\\n            }\\n\\n        }\\n            \\n            \\n        if(i==groups.size()&&j==groups[groups.size()-1].size())\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841788,
                "title": "java-kmp-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\n\\t\\t\\tfor (j = 0; j < groups.length && i < nums.length; j++) {\\n\\n\\t\\t\\t\\tint table[] = longestPrefixSubstring(groups[j]);\\n\\t\\t\\t\\tint mas[] = groups[j];\\n\\t\\t\\t\\tint curIndex = 0;\\n\\n\\t\\t\\t\\twhile (curIndex != mas.length && i < nums.length) {\\n\\t\\t\\t\\t\\tif (mas[curIndex] != nums[i]) {\\n\\t\\t\\t\\t\\t\\twhile (curIndex > 0 && (mas[curIndex] != nums[i])) \\n\\t\\t\\t\\t\\t\\t\\tcurIndex = table[curIndex - 1];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (mas[curIndex] == nums[i]) {\\n\\t\\t\\t\\t\\t\\tcurIndex++;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (curIndex != mas.length)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tif (j < groups.length)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\n\\t\\tpublic int[] longestPrefixSubstring(int[] mas) {\\n\\t\\t\\tint table[] = new int[mas.length];\\n\\t\\t\\tint j = 0;\\n\\n\\t\\t\\tfor (int i = 1; i < mas.length; i++) {\\n\\t\\t\\t\\tif (mas[i] != mas[j])\\n\\t\\t\\t\\t\\twhile (j > 0 && (mas[i] != mas[j])) \\n\\t\\t\\t\\t\\t\\tj = table[j - 1];\\n\\n\\t\\t\\t\\tif (mas[i] == mas[j]) {\\n\\t\\t\\t\\t\\ttable[i] = ++j;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn table;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\n\\t\\t\\tfor (j = 0; j < groups.length && i < nums.length; j++) {\\n\\n\\t\\t\\t\\tint table[] = longestPrefixSubstring(groups[j]);\\n\\t\\t\\t\\tint mas[] = groups[j];\\n\\t\\t\\t\\tint curIndex = 0;\\n\\n\\t\\t\\t\\twhile (curIndex != mas.length && i < nums.length) {\\n\\t\\t\\t\\t\\tif (mas[curIndex] != nums[i]) {\\n\\t\\t\\t\\t\\t\\twhile (curIndex > 0 && (mas[curIndex] != nums[i])) \\n\\t\\t\\t\\t\\t\\t\\tcurIndex = table[curIndex - 1];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1716698,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int starter = 0;\\n        for (int[] group : groups) {\\n            while (true) {\\n                if (starter + group.length > nums.length) {\\n                    return false;\\n                }\\n                if (!checkGroup(group, nums, starter)) {\\n                    starter++;\\n                } else {\\n                    starter += group.length;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkGroup(int[] group, int[] nums, int starter) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (group[i] != nums[i + starter]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int starter = 0;\\n        for (int[] group : groups) {\\n            while (true) {\\n                if (starter + group.length > nums.length) {\\n                    return false;\\n                }\\n                if (!checkGroup(group, nums, starter)) {\\n                    starter++;\\n                } else {\\n                    starter += group.length;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkGroup(int[] group, int[] nums, int starter) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (group[i] != nums[i + starter]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716668,
                "title": "java-3-pointer-check-group-one-by-one",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start = 0;\\n        for (int[] group : groups) {\\n            int i = 0, j = 0;\\n            while (j < group.length && i + start < nums.length) {\\n                if (group[j] != nums[i + start]) {\\n                    start++;\\n                    j = 0;\\n                    i = 0;\\n                } else {\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            if (j != group.length) {\\n                return false;\\n            } else {\\n                start += j;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start = 0;\\n        for (int[] group : groups) {\\n            int i = 0, j = 0;\\n            while (j < group.length && i + start < nums.length) {\\n                if (group[j] != nums[i + start]) {\\n                    start++;\\n                    j = 0;\\n                    i = 0;\\n                } else {\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            if (j != group.length) {\\n                return false;\\n            } else {\\n                start += j;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672263,
                "title": "ezpz-c-fast-solution-implementation-based",
                "content": "**Take a group and search for its elements in the nums array if you find it store the indexes where you found the whole subarray.\\nOtherwise return false directly.**\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> search(vector<int>&temp,vector<int>&nums,int prevEnd){\\n        int size = temp.size();\\n        int n = nums.size();\\n        pair<int,int> ans = {-1,-1};\\n        int i;\\n        if(prevEnd == -1){\\n            i = 0;\\n        }else{\\n            i = prevEnd;\\n        }\\n        for(; i < n - size + 1 ; i++){\\n            int i_ = i;\\n            bool found = true;\\n            for(int j = 0 ; j < size ;){\\n                if(temp[j] == nums[i_]){\\n                    j++;\\n                    i_++;\\n                }else{\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found){\\n                ans.first = i;\\n                ans.second = i + size - 1;\\n                \\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int prevEnd = -1;\\n        int prevStart = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            auto temp = groups[i];\\n            auto indexes = search(temp,nums,prevEnd);\\n            if(indexes.first == -1){\\n                return false;\\n            }\\n            if(prevEnd >= indexes.first){\\n                return false;\\n            }\\n            prevStart = indexes.first;\\n            prevEnd = indexes.second;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int,int> search(vector<int>&temp,vector<int>&nums,int prevEnd){\\n        int size = temp.size();\\n        int n = nums.size();\\n        pair<int,int> ans = {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1664779,
                "title": "o-n-super-quick-python-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start = 0\\n        for g in groups:\\n            last_looked_at = []\\n            idx = -1\\n            for i in range(start, len(nums)):\\n                last_looked_at.append(nums[i])\\n                if len(last_looked_at) == len(g) + 1:\\n                    last_looked_at.pop(0)\\n                if last_looked_at == g:\\n                    idx = i\\n                    break\\n            if idx == -1:\\n                return False\\n            start = idx + 1\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start = 0\\n        for g in groups:\\n            last_looked_at = []\\n            idx = -1\\n            for i in range(start, len(nums)):\\n                last_looked_at.append(nums[i])\\n                if len(last_looked_at) == len(g) + 1:\\n                    last_looked_at.pop(0)\\n                if last_looked_at == g:\\n                    idx = i\\n                    break\\n            if idx == -1:\\n                return False\\n            start = idx + 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614827,
                "title": "java-simple-solution-using-slidingwindow-1ms",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int prev = 0;\\n        \\n        for(int i=0; i<groups.length; i++){\\n            int[] temp = new int[groups[i].length];\\n            \\n            if(prev + groups[i].length > nums.length)\\n                return false;\\n            \\n            int index = 0;\\n            int j;\\n            for(j=prev; j<prev+groups[i].length; j++)\\n                temp[index++] = nums[j];\\n            \\n            if(Arrays.equals(temp, groups[i])){\\n                prev = j;\\n                continue;\\n            }\\n    \\n            int k;\\n            for(k=j; k<nums.length; k++){\\n                int l;\\n                for(l=0; l<temp.length-1; l++)\\n                    temp[l] = temp[l+1];\\n                \\n                temp[l] = nums[k];\\n                \\n                if(Arrays.equals(temp, groups[i])){\\n                    prev = k+1;\\n                    break;\\n                }\\n            }\\n            if(k == nums.length)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int prev = 0;\\n        \\n        for(int i=0; i<groups.length; i++){\\n            int[] temp = new int[groups[i].length];\\n            \\n            if(prev + groups[i].length > nums.length)\\n                return false;\\n            \\n            int index = 0;\\n            int j;\\n            for(j=prev; j<prev+groups[i].length; j++)\\n                temp[index++] = nums[j];\\n            \\n            if(Arrays.equals(temp, groups[i])){\\n                prev = j;\\n                continue;\\n            }\\n    \\n            int k;\\n            for(k=j; k<nums.length; k++){\\n                int l;\\n                for(l=0; l<temp.length-1; l++)\\n                    temp[l] = temp[l+1];\\n                \\n                temp[l] = nums[k];\\n                \\n                if(Arrays.equals(temp, groups[i])){\\n                    prev = k+1;\\n                    break;\\n                }\\n            }\\n            if(k == nums.length)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601850,
                "title": "golang-kmp-o-n-beat-100",
                "content": "```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n    currentLPS := make([]int, len(nums))\\n    \\n    n := len(groups)\\n    \\n    currentGr, current := groups[0], 0\\n    currentLPS = computeLPS(currentGr, currentLPS)\\n   \\n    j := 0\\n    for _, v := range nums {\\n        for j > 0 && v != currentGr[j] {\\n            j = currentLPS[j-1]\\n        }\\n        \\n        if v == currentGr[j] {\\n            j++\\n        }\\n        \\n        if j == len(currentGr) {\\n            current++\\n            if current == n {\\n                return true\\n            }\\n            \\n            currentGr = groups[current]\\n            currentLPS = computeLPS(currentGr, currentLPS)\\n            j = 0\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc computeLPS(s, lps []int) []int {\\n    n := len(s)\\n    \\n    lps = lps[:n]\\n    for i, j := 1, 0; i < n; i++ {\\n        for j > 0 && s[i] != s[j] {\\n            j = lps[j-1]\\n        }\\n        \\n        if s[i] == s[j] {\\n            j++\\n        }\\n        \\n        lps[i] = j\\n    }\\n    \\n    return lps\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n    currentLPS := make([]int, len(nums))\\n    \\n    n := len(groups)\\n    \\n    currentGr, current := groups[0], 0\\n    currentLPS = computeLPS(currentGr, currentLPS)\\n   \\n    j := 0\\n    for _, v := range nums {\\n        for j > 0 && v != currentGr[j] {\\n            j = currentLPS[j-1]\\n        }\\n        \\n        if v == currentGr[j] {\\n            j++\\n        }\\n        \\n        if j == len(currentGr) {\\n            current++\\n            if current == n {\\n                return true\\n            }\\n            \\n            currentGr = groups[current]\\n            currentLPS = computeLPS(currentGr, currentLPS)\\n            j = 0\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc computeLPS(s, lps []int) []int {\\n    n := len(s)\\n    \\n    lps = lps[:n]\\n    for i, j := 1, 0; i < n; i++ {\\n        for j > 0 && s[i] != s[j] {\\n            j = lps[j-1]\\n        }\\n        \\n        if s[i] == s[j] {\\n            j++\\n        }\\n        \\n        lps[i] = j\\n    }\\n    \\n    return lps\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547136,
                "title": "12-lines-looping-101-c",
                "content": "```\\n    bool canChoose(vector<vector<int>>& g, vector<int>& nums) {\\n        \\n        int ptr = 0;\\n        \\n        for(int i = 0 ; i < g.size() ; i++) {\\n            \\n            while(ptr < nums.size() && nums[ptr] != g[i][0]) ptr++;\\n            int tmp = ptr + 1;\\n            \\n            for(int j = 0 ; j < g[i].size() ; j++) {\\n                \\n                if(ptr == nums.size()) return false;\\n                if(nums[ptr] != g[i][j]) {\\n                    i--; ptr = tmp;\\n                    break;\\n                }\\n                ptr++;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canChoose(vector<vector<int>>& g, vector<int>& nums) {\\n        \\n        int ptr = 0;\\n        \\n        for(int i = 0 ; i < g.size() ; i++) {\\n            \\n            while(ptr < nums.size() && nums[ptr] != g[i][0]) ptr++;\\n            int tmp = ptr + 1;\\n            \\n            for(int j = 0 ; j < g[i].size() ; j++) {\\n                \\n                if(ptr == nums.size()) return false;\\n                if(nums[ptr] != g[i][j]) {\\n                    i--; ptr = tmp;\\n                    break;\\n                }\\n                ptr++;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1542084,
                "title": "java-one-pass-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int groupInd = 0, i = 0;\\n        \\n        while (i < nums.length && groupInd < groups.length) {\\n            int offset = 0;\\n            int[] group = groups[groupInd];\\n            while (offset < group.length && i+offset < nums.length && nums[i+offset] == group[offset]) {\\n                offset++;\\n            }\\n            if (offset == group.length) {\\n                groupInd++;\\n                i += offset;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (groupInd == groups.length) {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int groupInd = 0, i = 0;\\n        \\n        while (i < nums.length && groupInd < groups.length) {\\n            int offset = 0;\\n            int[] group = groups[groupInd];\\n            while (offset < group.length && i+offset < nums.length && nums[i+offset] == group[offset]) {\\n                offset++;\\n            }\\n            if (offset == group.length) {\\n                groupInd++;\\n                i += offset;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (groupInd == groups.length) {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532099,
                "title": "javascript-solution-non-kmp-approach",
                "content": "```\\nar canChoose = function(groups, nums) {\\n    const n = groups.length;\\n    const m = nums.length;\\n    \\n    let i = 0; // nums index\\n    let j = 0; // groups index\\n    \\n    while (i < m && j < n) {\\n        let k = i;\\n        \\n        const group = groups[j];\\n        const len = group.length;\\n       \\n        for (let r = 0; r < len; r++) {\\n            if (nums[k] != group[r]) break;\\n            k++;\\n        }\\n        \\n        if (k === i + len) {\\n            i = k;\\n            j += 1;\\n        }\\n        else {\\n            i += 1;\\n        }\\n    }\\n   \\n    return j === n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nar canChoose = function(groups, nums) {\\n    const n = groups.length;\\n    const m = nums.length;\\n    \\n    let i = 0; // nums index\\n    let j = 0; // groups index\\n    \\n    while (i < m && j < n) {\\n        let k = i;\\n        \\n        const group = groups[j];\\n        const len = group.length;\\n       \\n        for (let r = 0; r < len; r++) {\\n            if (nums[k] != group[r]) break;\\n            k++;\\n        }\\n        \\n        if (k === i + len) {\\n            i = k;\\n            j += 1;\\n        }\\n        else {\\n            i += 1;\\n        }\\n    }\\n   \\n    return j === n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529026,
                "title": "intuitive-python-solution",
                "content": "```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        res = 0\\n        i = 0\\n        for arr in (groups):\\n            m = len(arr)\\n            while i+m < (len(nums))+1:\\n                if nums[i:m+i] == arr:\\n                    i += m\\n                    res += 1\\n                    break\\n                i +=1\\n                \\n        return res == len(groups)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        res = 0\\n        i = 0\\n        for arr in (groups):\\n            m = len(arr)\\n            while i+m < (len(nums))+1:\\n                if nums[i:m+i] == arr:\\n                    i += m\\n                    res += 1\\n                    break\\n                i +=1\\n                \\n        return res == len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501990,
                "title": "13-line-clean-scala-solution-greedy-algorithm",
                "content": "The key is to realize it is a greedy problem. For each `group`, keep finding the first matched one in `nums`\\'s sub array (start after last matched index) iteratively. \\n\\n```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = {\\n        val matchIndex = groups.foldLeft(0)((matchPos, group) => {\\n            if (matchPos != -1) {\\n                val firstIndex = nums.indexOfSlice(group, matchPos)\\n                if (firstIndex == -1) -1 else firstIndex + group.length\\n            } else {\\n                -1\\n            }\\n        })\\n        return matchIndex != -1\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "The key is to realize it is a greedy problem. For each `group`, keep finding the first matched one in `nums`\\'s sub array (start after last matched index) iteratively. \\n\\n```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = {\\n        val matchIndex = groups.foldLeft(0)((matchPos, group) => {\\n            if (matchPos != -1) {\\n                val firstIndex = nums.indexOfSlice(group, matchPos)\\n                if (firstIndex == -1) -1 else firstIndex + group.length\\n            } else {\\n                -1\\n            }\\n        })\\n        return matchIndex != -1\\n    }\\n}\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1498782,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int r = 0, n = groups.length, i = 0, k = 0;\\n        while(i < nums.length && r < n)\\n        {\\n            int prev = i;\\n            k = 0; \\n            while(k < groups[r].length && i < nums.length && groups[r][k] == nums[i])\\n            {\\n                i++;\\n                k++;\\n            }\\n            \\n            if(k == groups[r].length)\\n            {\\n                r++;\\n            }\\n            else\\n            {\\n                i = prev+1;\\n            }\\n        }\\n        \\n        return r == n && k == groups[n-1].length;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int r = 0, n = groups.length, i = 0, k = 0;\\n        while(i < nums.length && r < n)\\n        {\\n            int prev = i;\\n            k = 0; \\n            while(k < groups[r].length && i < nums.length && groups[r][k] == nums[i])\\n            {\\n                i++;\\n                k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487523,
                "title": "explanation-of-the-testcase",
                "content": "I have a doubt for test case (84th testcase out of total 98):\\n```\\ngroups: [[21,22,21,22,21,30]]\\nnums: [21,22,21,22,21,22,21,30]\\n```\\nThe expceted output for this test case is `true` - Which does not make sense.\\n\\nHere is the problem statement snippet:\\n\\n*You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).*\\n\\nThere does not exist any subarray in the nums which is equal to `[21,22,21,22,21,30]`\\nShouldn\\'t the answer for this should be `false` ?\\n\\nI mean yeah, there exist 2 subarrays in `nums`, `{[21,22,21,22,21], [30]}`, which, when combined forms `groups[0]`. But we are not supposed to do that, the problem statement specifically says one subarray (and not combination of multiple subarrays) should be equal to `group[i]`.\\n\\nAm I missing anything?\\nPlease help.\\n\\n",
                "solutionTags": [],
                "code": "```\\ngroups: [[21,22,21,22,21,30]]\\nnums: [21,22,21,22,21,22,21,30]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1480374,
                "title": "100-faster-100-memory-efficient-with-comments",
                "content": "# Liked it? please upvote \\uD83D\\uDD3C\\n\\n```\\n    func canChoose(_ groups: [[Int]], _ nums: [Int]) -> Bool {\\n        var groupPtr = 0\\n        var numsPtr = 0\\n        while numsPtr <= nums.count - groups[groupPtr].count {\\n            \\n            // Checking if the nums subarray is equal to groups\\'s array at a particular index\\n           if Array(nums[numsPtr ..< numsPtr + groups[groupPtr].count]) == groups[groupPtr] {\\n               \\n               // group subarray matched till here in nums\\n               // so, bump numsPtr with the sum of groups\\'s array count at particular index\\n               numsPtr += groups[groupPtr].count - 1\\n               groupPtr += 1\\n            }\\n            \\n            if groupPtr == groups.count {\\n\\t\\t\\t // if all groups are present, only then groupPtr has reached till here, return `true`\\n                return true\\n            }\\n            numsPtr += 1\\n        }\\n        return false\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func canChoose(_ groups: [[Int]], _ nums: [Int]) -> Bool {\\n        var groupPtr = 0\\n        var numsPtr = 0\\n        while numsPtr <= nums.count - groups[groupPtr].count {\\n            \\n            // Checking if the nums subarray is equal to groups\\'s array at a particular index\\n           if Array(nums[numsPtr ..< numsPtr + groups[groupPtr].count]) == groups[groupPtr] {\\n               \\n               // group subarray matched till here in nums\\n               // so, bump numsPtr with the sum of groups\\'s array count at particular index\\n               numsPtr += groups[groupPtr].count - 1\\n               groupPtr += 1\\n            }\\n            \\n            if groupPtr == groups.count {\\n\\t\\t\\t // if all groups are present, only then groupPtr has reached till here, return `true`\\n                return true\\n            }\\n            numsPtr += 1\\n        }\\n        return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461762,
                "title": "c-clean-kmp-o-m-n-easy-understanding",
                "content": "The code is self explainatory for the most parts of it. \\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findLPS(vector<int> & nums){\\n        int i= 1, j = 0, n = nums.size(); \\n        vector <int> lps(n, 0); \\n        while(i<n){\\n            if(nums[i] == nums[j]){\\n                j++; \\n                lps[i] = j; \\n                i++; \\n            }\\n            else if(j >0) j  = lps[j-1]; \\n            else i++; \\n        }\\n        return lps; \\n    }\\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> used(n,0 );\\n        int prev = -1; \\n        for(auto group:groups){\\n            vector<int> lps = findLPS(group); \\n            int i=prev+1, j=0, m = group.size(), found = false; \\n            while(i<n){\\n                if(used[i]) i++, j = 0; \\n                else {\\n                    if(nums[i] == group[j]) i++, j++; \\n                    else if(j>0) j = lps[j-1]; \\n                    else i++; \\n                }\\n                if(j == m){\\n                    found = true; \\n                    if(prev > i-j) j = 0, found = false; \\n                    else break; \\n                }\\n            }\\n            if(!found || prev >= i-j) return false; \\n            prev = max(prev, i-j); \\n            for(int k= i-j; k<i; k++) used[k] = 1;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findLPS(vector<int> & nums){\\n        int i= 1, j = 0, n = nums.size(); \\n        vector <int> lps(n, 0); \\n        while(i<n){\\n            if(nums[i] == nums[j]){\\n                j++; \\n                lps[i] = j; \\n                i++; \\n            }\\n            else if(j >0) j  = lps[j-1]; \\n            else i++; \\n        }\\n        return lps; \\n    }\\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> used(n,0 );\\n        int prev = -1; \\n        for(auto group:groups){\\n            vector<int> lps = findLPS(group); \\n            int i=prev+1, j=0, m = group.size(), found = false; \\n            while(i<n){\\n                if(used[i]) i++, j = 0; \\n                else {\\n                    if(nums[i] == group[j]) i++, j++; \\n                    else if(j>0) j = lps[j-1]; \\n                    else i++; \\n                }\\n                if(j == m){\\n                    found = true; \\n                    if(prev > i-j) j = 0, found = false; \\n                    else break; \\n                }\\n            }\\n            if(!found || prev >= i-j) return false; \\n            prev = max(prev, i-j); \\n            for(int k= i-j; k<i; k++) used[k] = 1;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408883,
                "title": "c-std-search",
                "content": "Using C++ `std::search` we can look for the subarray `group` in the array `nums`. The only thing to take care of is to not look from the beginning of the array every time but only from the point where the last group ends.\\n\\n*https://en.cppreference.com/w/cpp/algorithm/search gives the complexity of `std::search` to O(MN), which is good enough for this question, the constraint being N<=10^3.*\\n```\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0;\\n        int n = nums.size();\\n        \\n        for (vector<int> group: groups) {\\n            i = search(nums.begin() + i, nums.end(), group.begin(), group.end()) - nums.begin();\\n            \\n            if (i == n) // search returns an iterator to nums.end() if the subarray is not found\\n                return false;\\n            \\n            i = i + group.size();\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Using C++ `std::search` we can look for the subarray `group` in the array `nums`. The only thing to take care of is to not look from the beginning of the array every time but only from the point where the last group ends.\\n\\n*https://en.cppreference.com/w/cpp/algorithm/search gives the complexity of `std::search` to O(MN), which is good enough for this question, the constraint being N<=10^3.*\\n```\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0;\\n        int n = nums.size();\\n        \\n        for (vector<int> group: groups) {\\n            i = search(nums.begin() + i, nums.end(), group.begin(), group.end()) - nums.begin();\\n            \\n            if (i == n) // search returns an iterator to nums.end() if the subarray is not found\\n                return false;\\n            \\n            i = i + group.size();\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1382087,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0, i = 0;\\n        while ( i < groups.length) {\\n            if (check(groups[i], nums, index)) {\\n                index += groups[i].length ;\\n                i++;\\n            } else {\\n                if (index < nums.length) {\\n                    index++;\\n                } else  {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean check(int[] group, int[] nums, int index) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (index + i < nums.length && nums[index+i] == group[i]) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0, i = 0;\\n        while ( i < groups.length) {\\n            if (check(groups[i], nums, index)) {\\n                index += groups[i].length ;\\n                i++;\\n            } else {\\n                if (index < nums.length) {\\n                    index++;\\n                } else  {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean check(int[] group, int[] nums, int index) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (index + i < nums.length && nums[index+i] == group[i]) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372698,
                "title": "python-sliding-window-single-pass-solution",
                "content": "What I do here is to check if all the group elements are present.\\n\\nKey observation to make is that even if there are multiple occurences of a group element, we just need to find the first occurence of each group in the nums array.\\n\\nThis ensures that a single pass is enough to return the answer.\\n\\nPlease offer tips below if you can on how to improve my explanation/code. \\n\\nBelow is the code-\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        idx, count = 0, 0\\n        \\n        while idx < len(nums):\\n            if count == len(groups):\\n                return True\\n            size = len(groups[count])\\n            arr = nums[idx:min(idx+size, len(nums))]\\n            \\n            if len(arr) == size:\\n                if arr == groups[count]:\\n                    count += 1\\n                    idx += size\\n                    continue\\n            idx += 1\\n        \\n        return count == len(groups)",
                "solutionTags": [],
                "code": "What I do here is to check if all the group elements are present.\\n\\nKey observation to make is that even if there are multiple occurences of a group element, we just need to find the first occurence of each group in the nums array.\\n\\nThis ensures that a single pass is enough to return the answer.\\n\\nPlease offer tips below if you can on how to improve my explanation/code. \\n\\nBelow is the code-\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        idx, count = 0, 0\\n        \\n        while idx < len(nums):\\n            if count == len(groups):\\n                return True\\n            size = len(groups[count])\\n            arr = nums[idx:min(idx+size, len(nums))]\\n            \\n            if len(arr) == size:\\n                if arr == groups[count]:\\n                    count += 1\\n                    idx += size\\n                    continue\\n            idx += 1\\n        \\n        return count == len(groups)",
                "codeTag": "Java"
            },
            {
                "id": 1369822,
                "title": "c-solution-using-kmp-beats-93-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int j = 0;\\n        for(auto group: groups){\\n            int i = 0;\\n            int k = group.size();\\n            \\n            int lps[k];\\n            lps[0] = 0;\\n            \\n            int curr = 0;\\n            int next = 1;\\n            \\n            while(next < k){\\n                if(group[curr] == group[next]){\\n                    curr++;\\n                    lps[next] = curr;\\n                    next++;\\n                }\\n                else{\\n                    if(curr != 0){\\n                        curr = lps[curr-1];\\n                    }\\n                    else {\\n                        lps[next] = 0;\\n                        next++;\\n                    }\\n                }\\n            }\\n            \\n            while(j < n && i < k){\\n                if(nums[j] == group[i]){\\n                    i++;\\n                    j++;\\n                }\\n                else {\\n                    if(i != 0){\\n                        i = lps[i-1];\\n                    }\\n                    else {\\n                        j++;\\n                    }\\n                }\\n                \\n               \\n            }\\n            \\n            if(j == n && i != k){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int j = 0;\\n        for(auto group: groups){\\n            int i = 0;\\n            int k = group.size();\\n            \\n            int lps[k];\\n            lps[0] = 0;\\n            \\n            int curr = 0;\\n            int next = 1;\\n            \\n            while(next < k){\\n                if(group[curr] == group[next]){\\n                    curr++;\\n                    lps[next] = curr;\\n                    next++;\\n                }\\n                else{\\n                    if(curr != 0){\\n                        curr = lps[curr-1];\\n                    }\\n                    else {\\n                        lps[next] = 0;\\n                        next++;\\n                    }\\n                }\\n            }\\n            \\n            while(j < n && i < k){\\n                if(nums[j] == group[i]){\\n                    i++;\\n                    j++;\\n                }\\n                else {\\n                    if(i != 0){\\n                        i = lps[i-1];\\n                    }\\n                    else {\\n                        j++;\\n                    }\\n                }\\n                \\n               \\n            }\\n            \\n            if(j == n && i != k){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365995,
                "title": "rolling-hash-c-rabin-karp",
                "content": "I did not see a rolling hash solution for this one hence posting it. Please let me know if algorithm steps are required, I will update the post with algorithm section.\\n\\n**Code**\\n```\\ntypedef long long ll;\\nll mod = 1e9+7;\\nll base = 101;\\nll offset = 1e7+1;\\nclass Solution {\\npublic:\\n    int n, m;\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        n = groups.size();\\n        m = nums.size();\\n        for(auto &e : groups) for(auto &ee : e) ee += offset;\\n        for(auto &e : nums) e += offset;\\n        bool ans = help(groups, nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    bool help(vector<vector<int>>& a, vector<int>& b, int pos1, int pos2){\\n        if(pos1 == n) return true;\\n        if(pos2 == m) return false;\\n        int len = a[pos1].size();\\n        if(m-pos2 < len) return false;\\n        \\n        ll originalHash = 0;\\n        for(int i = 0 ; i < len; i++) originalHash = (originalHash*base + (a[pos1][i])) % mod;\\n        \\n        int i = pos2;\\n        int firstStop = pos2 + len;\\n        ll hash = 0;\\n        ll temp = 1;\\n        while(pos2 < firstStop){\\n            hash = (hash * base + b[pos2]) % mod;\\n            temp = temp * base % mod;\\n            pos2++;\\n        }\\n        \\n        if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len, len)) return help(a, b, pos1+1, pos2);\\n        \\n        for(; pos2 < m; pos2++){\\n            hash = ((hash * base + b[pos2]) - (temp * b[pos2-len])) % mod;\\n            if(hash < 0) hash += mod;\\n            if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len+1, len)) return help(a, b, pos1+1, pos2+1);\\n        }\\n        return false;\\n    }\\n    \\n    bool checkEqual(vector<int> &a, vector<int> &b, int pos1, int pos2, int len){\\n        for(int i = 0 ; i < len; i++) if(a[pos1+i] != b[pos2+i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\ntypedef long long ll;\\nll mod = 1e9+7;\\nll base = 101;\\nll offset = 1e7+1;\\nclass Solution {\\npublic:\\n    int n, m;\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        n = groups.size();\\n        m = nums.size();\\n        for(auto &e : groups) for(auto &ee : e) ee += offset;\\n        for(auto &e : nums) e += offset;\\n        bool ans = help(groups, nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    bool help(vector<vector<int>>& a, vector<int>& b, int pos1, int pos2){\\n        if(pos1 == n) return true;\\n        if(pos2 == m) return false;\\n        int len = a[pos1].size();\\n        if(m-pos2 < len) return false;\\n        \\n        ll originalHash = 0;\\n        for(int i = 0 ; i < len; i++) originalHash = (originalHash*base + (a[pos1][i])) % mod;\\n        \\n        int i = pos2;\\n        int firstStop = pos2 + len;\\n        ll hash = 0;\\n        ll temp = 1;\\n        while(pos2 < firstStop){\\n            hash = (hash * base + b[pos2]) % mod;\\n            temp = temp * base % mod;\\n            pos2++;\\n        }\\n        \\n        if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len, len)) return help(a, b, pos1+1, pos2);\\n        \\n        for(; pos2 < m; pos2++){\\n            hash = ((hash * base + b[pos2]) - (temp * b[pos2-len])) % mod;\\n            if(hash < 0) hash += mod;\\n            if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len+1, len)) return help(a, b, pos1+1, pos2+1);\\n        }\\n        return false;\\n    }\\n    \\n    bool checkEqual(vector<int> &a, vector<int> &b, int pos1, int pos2, int len){\\n        for(int i = 0 ; i < len; i++) if(a[pos1+i] != b[pos2+i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359621,
                "title": "java-straightforward-brute-force-solution-stupid-but-simple",
                "content": "I try to avoid any\\xA0fancy algorithms as long as they are not necessary. As an engineer, my principle is getting things done first, then seek perfection. If you are a practical person like me, please check this stupid but simple solution.\\xA0\\n\\nFYI, there are no comments in the code because good codes document themselves.\\xA0\\xA0\\n\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        List<String> strs = new LinkedList<>();\\n        for (int[] group : groups) {\\n            StringBuffer bu = new StringBuffer();\\n            for (int num : group) {\\n                bu.append(\"[\");\\n                bu.append(num);\\n                bu.append(\"]\");\\n            }\\n            strs.add(bu.toString());\\n        }\\n\\t\\t\\n        StringBuffer bu = new StringBuffer();\\n        for (int num : nums) {\\n            bu.append(\"[\");\\n            bu.append(num);\\n            bu.append(\"]\");\\n        }\\n        String numStr = bu.toString();\\n\\t\\t\\n        int idx = 0;\\n        for (String str : strs) {\\n            int startIdx = numStr.indexOf(str, idx);\\n            if (startIdx < 0) {\\n                return false;\\n            }\\n            idx = startIdx + str.length();\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        List<String> strs = new LinkedList<>();\\n        for (int[] group : groups) {\\n            StringBuffer bu = new StringBuffer();\\n            for (int num : group) {\\n                bu.append(\"[\");\\n                bu.append(num);\\n                bu.append(\"]\");\\n            }\\n            strs.add(bu.toString());\\n        }\\n\\t\\t\\n        StringBuffer bu = new StringBuffer();\\n        for (int num : nums) {\\n            bu.append(\"[\");\\n            bu.append(num);\\n            bu.append(\"]\");\\n        }\\n        String numStr = bu.toString();\\n\\t\\t\\n        int idx = 0;\\n        for (String str : strs) {\\n            int startIdx = numStr.indexOf(str, idx);\\n            if (startIdx < 0) {\\n                return false;\\n            }\\n            idx = startIdx + str.length();\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357818,
                "title": "c-question-solution-using-kmp",
                "content": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;\\n        for(int k=0;k<groups.size();k++){\\n            vector<int> pat=groups[k];\\n            // for(int i=0;i<pat.size();i++){\\n            //     cout<<pat[i];\\n            // }\\n            cout<<i;\\n            i=findMatchingIndex(nums,pat,i);\\n            if(i==-1) return false;\\n            if(i==nums.size() && k<groups.size()-1){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    void createlps(int lps[],vector<int> arr,int m){\\n        // cout<<\"this is working\";\\n        int i=1;\\n        int j=0;\\n        // cout<<\"this is working\";\\n        lps[0]=0;\\n        // cout<<\"this is working\";\\n        while(i<arr.size()){\\n            // cout<<\"this is working\";\\n            if(arr[i]==arr[j]){\\n                j++;\\n                lps[i]=j;\\n                i++;\\n            }\\n           \\n            else{\\n                if(j!=0){\\n                    j=lps[j-1];\\n                }\\n                else{\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n            // cout<<\"inside loop\";\\n        }\\n        // cout<<\"end of making lps\";\\n    }\\n    int findMatchingIndex(vector<int> nums,vector<int> pat,int i){\\n        // cout<<\"this is working\";\\n        int m=pat.size();\\n        int lps[m];\\n        createlps(lps,pat,m);\\n        for(int i=0;i<m;i++){\\n            cout<<lps[i];\\n        }\\n        // cout<<\"after creating lps\";\\n        \\n        int j=0;\\n        \\n        while(i<nums.size()){\\n            if(nums[i]==pat[j]){\\n                i++;\\n                j++;\\n            }\\n            if(j==pat.size()){\\n                // cout<<\"return i worked\";\\n                // if(i==nums.size()){\\n                //     return -1;\\n                // }\\n                return i;\\n            }\\n            else if(i<nums.size() && nums[i]!=pat[j]){\\n                if(j!=0){\\n                    j=lps[j-1];\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            if(i==nums.size()) return -1;\\n            // cout<<\"matching loop\";\\n        }\\n        return i;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;\\n        for(int k=0;k<groups.size();k++){\\n            vector<int> pat=groups[k];\\n            // for(int i=0;i<pat.size();i++){\\n            //     cout<<pat[i];\\n            // }",
                "codeTag": "C++"
            },
            {
                "id": 1343506,
                "title": "c-easy-solution-using-recursion",
                "content": "* **Backtracking Solution :**\\n-> We have to check all the possible subarray and recursively call for the next array in the matrix Groups\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        int k=0;\\n        while(k<groups[i].size() && j<nums.size())\\n        {\\n            if(groups[i][k]!=nums[j]) return false;\\n            k++;\\n            j++;\\n        }\\n        if(k==groups[i].size()) return true;\\n        return false;\\n    }\\n    bool solve(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        if(i==size(groups)) return true;\\n        for(int k=j;k<size(nums);k++)\\n        {\\n            if(nums[k]==groups[i][0])\\n            {\\n                if(isSafe(i,k,groups,nums)) \\n                {\\n                    if(solve(i+1,k+groups[i].size(),groups,nums)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        return solve(0,0,groups,nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        int k=0;\\n        while(k<groups[i].size() && j<nums.size())\\n        {\\n            if(groups[i][k]!=nums[j]) return false;\\n            k++;\\n            j++;\\n        }\\n        if(k==groups[i].size()) return true;\\n        return false;\\n    }\\n    bool solve(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        if(i==size(groups)) return true;\\n        for(int k=j;k<size(nums);k++)\\n        {\\n            if(nums[k]==groups[i][0])\\n            {\\n                if(isSafe(i,k,groups,nums)) \\n                {\\n                    if(solve(i+1,k+groups[i].size(),groups,nums)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        return solve(0,0,groups,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337913,
                "title": "one-pass-with-stack-95-speed",
                "content": "Runtime: 76 ms, faster than 95.16%\\nMemory Usage: 14.4 MB, less than 89.25%\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        len_groups = len(groups)\\n        idx_group = 0\\n        len_group = len(groups[idx_group])\\n        stack = []\\n        for n in nums:\\n            stack.append(n)\\n            if (len(stack) >= len_group and\\n                    stack[-len_group:] == groups[idx_group]):\\n                stack = []\\n                idx_group += 1\\n                if idx_group < len_groups:\\n                    len_group = len(groups[idx_group])\\n                else:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        len_groups = len(groups)\\n        idx_group = 0\\n        len_group = len(groups[idx_group])\\n        stack = []\\n        for n in nums:\\n            stack.append(n)\\n            if (len(stack) >= len_group and\\n                    stack[-len_group:] == groups[idx_group]):\\n                stack = []\\n                idx_group += 1\\n                if idx_group < len_groups:\\n                    len_group = len(groups[idx_group])\\n                else:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319294,
                "title": "c-kmp-solution-90-faster",
                "content": "Time Complexity: O(n+m) where n is size of nums and m is sum of sizes of vectors of groups\\n```\\nclass Solution {\\npublic:\\n    \\n    void kmparray(vector<int>&sam, vector<int>&v1)\\n    {\\n        int i=1;int j=0;\\n        while(i<sam.size())\\n        {\\n            if(sam[i]==sam[j])\\n            {\\n                v1[i]=j+1;\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(j!=0)\\n                    j=v1[j-1];\\n                else\\n                {\\n                    v1[i]=0;\\n                    i++;\\n                }   \\n            } \\n        }\\n    }\\n    \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k=0;\\nbool kmp=true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int>v1(groups[i].size(),0);\\n\\t\\t\\t\\n\\t\\t\\t// build kmp array of each vector in groups for faster substring search \\n            kmparray(groups[i],v1);\\n             int j=0;\\n            \\n            while(j<v1.size()&&k<nums.size())\\n            {\\n                //cout<<k<<j<<\" \";\\n                if(groups[i][j]==nums[k])\\n                {\\n                    j++;\\n                    k++;\\n                }\\n                else\\n                {\\n                    if(j>0)\\n                    {\\n                        j=v1[j-1];\\n                    }\\n                    else\\n                        k++;\\n                    \\n                }\\n            }\\n            if(j!=v1.size())\\n                kmp=false;\\n            \\n            \\n        }\\n        \\n        return kmp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void kmparray(vector<int>&sam, vector<int>&v1)\\n    {\\n        int i=1;int j=0;\\n        while(i<sam.size())\\n        {\\n            if(sam[i]==sam[j])\\n            {\\n                v1[i]=j+1;\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(j!=0)\\n                    j=v1[j-1];\\n                else\\n                {\\n                    v1[i]=0;\\n                    i++;\\n                }   \\n            } \\n        }\\n    }\\n    \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k=0;\\nbool kmp=true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int>v1(groups[i].size(),0);\\n\\t\\t\\t\\n\\t\\t\\t// build kmp array of each vector in groups for faster substring search \\n            kmparray(groups[i],v1);\\n             int j=0;\\n            \\n            while(j<v1.size()&&k<nums.size())\\n            {\\n                //cout<<k<<j<<\" \";\\n                if(groups[i][j]==nums[k])\\n                {\\n                    j++;\\n                    k++;\\n                }\\n                else\\n                {\\n                    if(j>0)\\n                    {\\n                        j=v1[j-1];\\n                    }\\n                    else\\n                        k++;\\n                    \\n                }\\n            }\\n            if(j!=v1.size())\\n                kmp=false;\\n            \\n            \\n        }\\n        \\n        return kmp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1315157,
                "title": "simple-and-concise-c-99-faster-o-n-max-nums-size-group-0-size-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubArray(vector<int>& toFind, vector<int>& nums, int pos)\\n    {\\n        //should start search from index pos\\n        int m = toFind.size();\\n        \\n        while(pos+m-1 < nums.size())\\n        {\\n        bool found = false;\\n        for(int i = pos; i < pos+m && i < nums.size(); i++)\\n        {\\n           if(nums[i] != toFind[i-pos]) \\n           {\\n               break; \\n           }\\n            if(i==pos+m-1) found = true;\\n        }\\n        if(found) return pos+m;\\n        pos++;\\n        } \\n        return -1; //subarray not found\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int pos = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pos = findSubArray(groups[i],nums,pos);\\n            if(pos==-1) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubArray(vector<int>& toFind, vector<int>& nums, int pos)\\n    {\\n        //should start search from index pos\\n        int m = toFind.size();\\n        \\n        while(pos+m-1 < nums.size())\\n        {\\n        bool found = false;\\n        for(int i = pos; i < pos+m && i < nums.size(); i++)\\n        {\\n           if(nums[i] != toFind[i-pos]) \\n           {\\n               break; \\n           }\\n            if(i==pos+m-1) found = true;\\n        }\\n        if(found) return pos+m;\\n        pos++;\\n        } \\n        return -1; //subarray not found\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int pos = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pos = findSubArray(groups[i],nums,pos);\\n            if(pos==-1) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313703,
                "title": "typescript-fast-strings-matching",
                "content": "84ms - The solution relies on string matching and the current matching group pointer\\n\\n```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    const grs = groups.map(gr => \\',\\' + gr.join(\\',\\'))\\n    const n = \\',\\' + nums.join(\\',\\')\\n    let fromIndex = -1\\n    \\n    for (let g of grs) {\\n        const grIndex = n.indexOf(g, fromIndex)\\n        if (grIndex > -1) {\\n            fromIndex = grIndex + g.length\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    const grs = groups.map(gr => \\',\\' + gr.join(\\',\\'))\\n    const n = \\',\\' + nums.join(\\',\\')\\n    let fromIndex = -1\\n    \\n    for (let g of grs) {\\n        const grIndex = n.indexOf(g, fromIndex)\\n        if (grIndex > -1) {\\n            fromIndex = grIndex + g.length\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1287265,
                "title": "c-100-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int ans=false;\\n        int low=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(low>=groups.size())\\n            {\\n                ans=true;\\n                break ;\\n            }\\n            if(nums[i]==groups[low][0])\\n            {\\n                int l=i,r=0;\\n                bool temp=true;\\n                for(;r<groups[low].size();r++)\\n                {\\n                    // cout<<i<<\" \";\\n                    if(l>=nums.size())\\n                    {\\n                        temp=false;\\n                        break ;\\n                    }\\n                    if(nums[l]!=groups[low][r])\\n                    {\\n                        // cout<<\"!\";\\n                        temp=false;\\n                        break ;\\n                    }\\n                    l++;\\n                }\\n                if(temp)\\n                {\\n                    i=l-1;\\n                    low++;\\n                }\\n            }\\n        }\\n        if(low>=groups.size())\\n        {\\n            ans=true;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int ans=false;\\n        int low=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(low>=groups.size())\\n            {\\n                ans=true;\\n                break ;\\n            }\\n            if(nums[i]==groups[low][0])\\n            {\\n                int l=i,r=0;\\n                bool temp=true;\\n                for(;r<groups[low].size();r++)\\n                {\\n                    // cout<<i<<\" \";\\n                    if(l>=nums.size())\\n                    {\\n                        temp=false;\\n                        break ;\\n                    }\\n                    if(nums[l]!=groups[low][r])\\n                    {\\n                        // cout<<\"!\";\\n                        temp=false;\\n                        break ;\\n                    }\\n                    l++;\\n                }\\n                if(temp)\\n                {\\n                    i=l-1;\\n                    low++;\\n                }\\n            }\\n        }\\n        if(low>=groups.size())\\n        {\\n            ans=true;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1248104,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int curr = 0;\\n        int i = 0;\\n        while(i < nums.length){\\n            if(nums[i] == groups[curr][0] && nums.length - i >= groups[curr].length){\\n                if(helper(nums, groups[curr], i)){\\n                    i += groups[curr].length;\\n                    curr++;\\n                    if(curr == groups.length){\\n                        break;\\n                    }\\n                    continue;\\n                }\\n            }\\n            i++;\\n        }\\n        return curr == groups.length; \\n    }\\n    \\n    private boolean helper(int[] nums, int[] arr, int index){\\n        for(int i = 0; i < arr.length; i++){\\n            if(index < nums.length && arr[i] == nums[index]){\\n                index++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int curr = 0;\\n        int i = 0;\\n        while(i < nums.length){\\n            if(nums[i] == groups[curr][0] && nums.length - i >= groups[curr].length){\\n                if(helper(nums, groups[curr], i)){\\n                    i += groups[curr].length;\\n                    curr++;\\n                    if(curr == groups.length){\\n                        break;\\n                    }\\n                    continue;\\n                }\\n            }\\n            i++;\\n        }\\n        return curr == groups.length; \\n    }\\n    \\n    private boolean helper(int[] nums, int[] arr, int index){\\n        for(int i = 0; i < arr.length; i++){\\n            if(index < nums.length && arr[i] == nums[index]){\\n                index++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243759,
                "title": "javascript-understandable-solution-92-ms",
                "content": "```\\nvar canChoose = function (groups, nums) {\\n    let j = 0, k = 0;\\n    let group = groups[k];\\n    for (let i = 0; i < nums.length && j < nums.length; i++) {\\n        j = i + group.length;\\n        let isFound = true;\\n        for (let n = 0; n < group.length; n++) {\\n            if (nums[i + n] !== group[n]) {\\n                isFound = false;\\n                break;\\n            }\\n\\n        }\\n        if (isFound) {\\n            k++;\\n            if (k < groups.length) {\\n                i = j - 1;\\n                group = groups[k];\\n            }\\n            else {\\n                return true;\\n            }\\n\\n        }\\n    }\\n    return false;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canChoose = function (groups, nums) {\\n    let j = 0, k = 0;\\n    let group = groups[k];\\n    for (let i = 0; i < nums.length && j < nums.length; i++) {\\n        j = i + group.length;\\n        let isFound = true;\\n        for (let n = 0; n < group.length; n++) {\\n            if (nums[i + n] !== group[n]) {\\n                isFound = false;\\n                break;\\n            }\\n\\n        }\\n        if (isFound) {\\n            k++;\\n            if (k < groups.length) {\\n                i = j - 1;\\n                group = groups[k];\\n            }\\n            else {\\n                return true;\\n            }\\n\\n        }\\n    }\\n    return false;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230301,
                "title": "python3-easy-code-beating-96-of-submissions",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start_index = 0\\n        for group in groups:\\n            lenGroup = len(group)\\n            flag = False\\n            for i in range(start_index, len(nums)-lenGroup+1):\\n                if nums[i:i+lenGroup]==group:\\n                    start_index = i+lenGroup\\n                    flag = True\\n                    break\\n            \\n            if flag == False:\\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start_index = 0\\n        for group in groups:\\n            lenGroup = len(group)\\n            flag = False\\n            for i in range(start_index, len(nums)-lenGroup+1):\\n                if nums[i:i+lenGroup]==group:\\n                    start_index = i+lenGroup\\n                    flag = True\\n                    break\\n            \\n            if flag == False:\\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230184,
                "title": "easy-understanable-js-code",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n    let subArray = groups.shift()\\n    let returnValue = false\\n    for (let i=0; i<nums.length; i++) {\\n        if(subArray[0] == nums[i]) {\\n            // console.log(subArray);\\n            if(checkExists(subArray, nums.slice(i, i+subArray.length))){\\n                i = i + subArray.length - 1\\n                returnValue = true\\n                if(groups[0]){\\n                    subArray = groups.shift()\\n                    returnValue = false\\n                }\\n            }\\n        }\\n    }\\n    return returnValue\\n}\\n\\nvar checkExists = function (list1, list2) {\\n    if (list2.length != list1.length) return false\\n    for (let i = 0; i < list2.length; i++) {\\n        if (list1[i] == list2[i]) {\\n            continue\\n        }\\n        return false\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n    let subArray = groups.shift()\\n    let returnValue = false\\n    for (let i=0; i<nums.length; i++) {\\n        if(subArray[0] == nums[i]) {\\n            // console.log(subArray);\\n            if(checkExists(subArray, nums.slice(i, i+subArray.length))){\\n                i = i + subArray.length - 1\\n                returnValue = true\\n                if(groups[0]){\\n                    subArray = groups.shift()\\n                    returnValue = false\\n                }\\n            }\\n        }\\n    }\\n    return returnValue\\n}\\n\\nvar checkExists = function (list1, list2) {\\n    if (list2.length != list1.length) return false\\n    for (let i = 0; i < list2.length; i++) {\\n        if (list1[i] == list2[i]) {\\n            continue\\n        }\\n        return false\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218853,
                "title": "c-easy-solution-strings",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string kk;\\n        kk.push_back(\\',\\');\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            kk.append(to_string(nums[i]));\\n            kk.push_back(\\',\\');\\n        }\\n        kk.pop_back();\\n        int ll=0;\\n        int n=kk.size();\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            string gg;\\n            gg.push_back(\\',\\');\\n            for(int j=0;j<groups[i].size();j++)\\n            {\\n                gg.append(to_string(groups[i][j]));\\n                gg.push_back(\\',\\');\\n            }\\n            gg.pop_back();\\n            ll=kk.find(gg,ll);\\n            if(ll!=-1)\\n            {\\n                ll+=gg.size();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string kk;\\n        kk.push_back(\\',\\');\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            kk.append(to_string(nums[i]));\\n            kk.push_back(\\',\\');\\n        }\\n        kk.pop_back();\\n        int ll=0;\\n        int n=kk.size();\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            string gg;\\n            gg.push_back(\\',\\');\\n            for(int j=0;j<groups[i].size();j++)\\n            {\\n                gg.append(to_string(groups[i][j]));\\n                gg.push_back(\\',\\');\\n            }\\n            gg.pop_back();\\n            ll=kk.find(gg,ll);\\n            if(ll!=-1)\\n            {\\n                ll+=gg.size();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187713,
                "title": "java-0ms",
                "content": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = nums.length;\\n        int c = groups.length;//number of rows \\n        int a = 0;//counter to row array \\n        int[] t = groups[a];//extract a particular subarray belong to a particular row \\n        int l = t.length;//length of that subarray \\n        for (int i = 0; i < len; i++)//traversing nums \\n        {\\n            if (nums[i] == t[0] && i + l <= len) //checing the starting of subarray && boundary check \\n            {\\n                int scan = 0;//scan with respect to that particular index \\n                while(scan < l && nums[i+scan] == t[scan])//comaring nusns array and particular subarray \\n                       scan++; //moving scan \\n                if (scan == l) \\n                {\\n                    if (++a == c) //if all rows of 2D marix are checked and all are true \\n                        return true; \\n                    t = groups[a];//moving too nex subarray of 2d matrix \\n                    l = t.length;//changing the subarray length\\n                    i += scan - 1;//checking in next half after that scanning //changing the index of i//no intersecction in subarray possible  \\n                }\\n            }\\n        }\\n        return false;//else returning false subarray no present \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = nums.length;\\n        int c = groups.length;//number of rows \\n        int a = 0;//counter to row array \\n        int[] t = groups[a];//extract a particular subarray belong to a particular row \\n        int l = t.length;//length of that subarray \\n        for (int i = 0; i < len; i++)//traversing nums \\n        {\\n            if (nums[i] == t[0] && i + l <= len) //checing the starting of subarray && boundary check \\n            {\\n                int scan = 0;//scan with respect to that particular index \\n                while(scan < l && nums[i+scan] == t[scan])//comaring nusns array and particular subarray \\n                       scan++; //moving scan \\n                if (scan == l) \\n                {\\n                    if (++a == c) //if all rows of 2D marix are checked and all are true \\n                        return true; \\n                    t = groups[a];//moving too nex subarray of 2d matrix \\n                    l = t.length;//changing the subarray length\\n                    i += scan - 1;//checking in next half after that scanning //changing the index of i//no intersecction in subarray possible  \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1185127,
                "title": "javascript-array-match-solution",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let numsIndex = 0, groupsIndex = 0\\n    const numsLen = nums.length, groupsLen = groups.length\\n    \\n    forEachNumsIndex:\\n    while (numsIndex < numsLen && groupsIndex < groupsLen) {\\n        const group = groups[groupsIndex]\\n        const groupLen = group.length\\n        if (numsIndex + groupLen > numsLen)\\n            return false\\n        \\n        // i is the offset within group\\n        for (let i = 0; i < groupLen; i++) {\\n            const numsVal = nums[i + numsIndex]\\n            const groupVal = group[i]\\n            if (numsVal !== groupVal) {\\n                numsIndex++\\n                continue forEachNumsIndex\\n            }\\n        }\\n        \\n        // it matches\\n        numsIndex += groupLen\\n        groupsIndex++\\n    }\\n    if (groupsIndex < groupsLen)    return false\\n    \\n    \\n    return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let numsIndex = 0, groupsIndex = 0\\n    const numsLen = nums.length, groupsLen = groups.length\\n    \\n    forEachNumsIndex:\\n    while (numsIndex < numsLen && groupsIndex < groupsLen) {\\n        const group = groups[groupsIndex]\\n        const groupLen = group.length\\n        if (numsIndex + groupLen > numsLen)\\n            return false\\n        \\n        // i is the offset within group\\n        for (let i = 0; i < groupLen; i++) {\\n            const numsVal = nums[i + numsIndex]\\n            const groupVal = group[i]\\n            if (numsVal !== groupVal) {\\n                numsIndex++\\n                continue forEachNumsIndex\\n            }\\n        }\\n        \\n        // it matches\\n        numsIndex += groupLen\\n        groupsIndex++\\n    }\\n    if (groupsIndex < groupsLen)    return false\\n    \\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181108,
                "title": "c-java-simple-solution-visual-explanation",
                "content": "This is my first \"article\" on Leetcode, so just bear with me...\\n\\nIt\\'s a simple solution that is based on two loops. One follows the elements of the nums array, and the other follows the elements of the group array.\\n\\nSimple visualization:\\n\\n![image](https://assets.leetcode.com/users/images/2535bd77-75ef-4323-9187-ede05468c950_1619635837.095462.png)\\n\\n![image](https://assets.leetcode.com/users/images/811fcd81-bf44-4436-83ce-6925876c6877_1619635974.4187915.png)\\n\\n\\nC++ (old school)\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.size(); ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.size() &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].size()-1) { //We have reached last element in group\\n                    if (group_id == groups.size() - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nJava (so common)\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.length; ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.length &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].length-1) { //We have reached last element in group\\n                    if (group_id == groups.length - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nPython:\\n```\\n# I don\\'t know Python :)\\n```\\n\\n\\n\"n\" and \"k\" are used in the description, so:\\nm - nums.length,\\nd - the number of elements in groups.\\nTime complexity: O(m*d)\\nSpace complexity: O(1)\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.size(); ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.size() &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].size()-1) { //We have reached last element in group\\n                    if (group_id == groups.size() - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.length; ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.length &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].length-1) { //We have reached last element in group\\n                    if (group_id == groups.length - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\n# I don\\'t know Python :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150888,
                "title": "javascript-kmp",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n  const patterns = [];\\n  for (const group of groups) {\\n    patterns.push(buildPattern(group));\\n  }\\n\\n  let i = 0; // groups\\n  let j = 0; // groups[i]\\n  let k = 0; // nums\\n\\n  while (i < groups.length) {\\n    const currGroup = groups[i];\\n    const currPattern = patterns[i];\\n\\n    while (j < currGroup.length && k < nums.length) {\\n      if (currGroup[j] === nums[k]) {\\n        j++;\\n        k++;\\n      } else if (j > 0) {\\n        j = currPattern[j - 1] + 1;\\n      } else {\\n        k++;\\n      }\\n    }\\n\\n    if (j < currGroup.length) return false;\\n\\n    // move to next group\\n    i++;\\n    j = 0;\\n  }\\n\\n  return i === groups.length;\\n};\\n\\nfunction buildPattern(group) {\\n  let j = 0;\\n  let i = 1;\\n\\n  const pattern = new Array(group.length).fill(-1);\\n  while (i < group.length) {\\n    if (group[j] === group[i]) {\\n      pattern[i] = j;\\n      j++;\\n      i++;\\n    } else if (j > 0) {\\n      j = pattern[j - 1] + 1;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return pattern;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n  const patterns = [];\\n  for (const group of groups) {\\n    patterns.push(buildPattern(group));\\n  }\\n\\n  let i = 0; // groups\\n  let j = 0; // groups[i]\\n  let k = 0; // nums\\n\\n  while (i < groups.length) {\\n    const currGroup = groups[i];\\n    const currPattern = patterns[i];\\n\\n    while (j < currGroup.length && k < nums.length) {\\n      if (currGroup[j] === nums[k]) {\\n        j++;\\n        k++;\\n      } else if (j > 0) {\\n        j = currPattern[j - 1] + 1;\\n      } else {\\n        k++;\\n      }\\n    }\\n\\n    if (j < currGroup.length) return false;\\n\\n    // move to next group\\n    i++;\\n    j = 0;\\n  }\\n\\n  return i === groups.length;\\n};\\n\\nfunction buildPattern(group) {\\n  let j = 0;\\n  let i = 1;\\n\\n  const pattern = new Array(group.length).fill(-1);\\n  while (i < group.length) {\\n    if (group[j] === group[i]) {\\n      pattern[i] = j;\\n      j++;\\n      i++;\\n    } else if (j > 0) {\\n      j = pattern[j - 1] + 1;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return pattern;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146921,
                "title": "java-sliding-window-solution-runtime-1ms",
                "content": "I think that this solution is easy to understand \\n\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int groupStart = 0;\\n        boolean answer = true;\\n        \\n        for (int i = 0; i < groups.length; i++) {\\n            \\n            int[] group = groups[i];\\n            boolean matchFound = false;\\n            \\n            // sliding window of group in nums\\n            \\n            for (int j = groupStart; j < nums.length-group.length+1; j++) {\\n                \\n                int[] tempArr = Arrays.copyOfRange(nums,j,j+group.length);\\n                \\n                if (Arrays.equals(tempArr,group)) {\\n                    groupStart = j + tempArr.length;\\n                    matchFound = true;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if (!matchFound) {\\n                answer = false;\\n                break;\\n            }\\n            \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int groupStart = 0;\\n        boolean answer = true;\\n        \\n        for (int i = 0; i < groups.length; i++) {\\n            \\n            int[] group = groups[i];\\n            boolean matchFound = false;\\n            \\n            // sliding window of group in nums\\n            \\n            for (int j = groupStart; j < nums.length-group.length+1; j++) {\\n                \\n                int[] tempArr = Arrays.copyOfRange(nums,j,j+group.length);\\n                \\n                if (Arrays.equals(tempArr,group)) {\\n                    groupStart = j + tempArr.length;\\n                    matchFound = true;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if (!matchFound) {\\n                answer = false;\\n                break;\\n            }\\n            \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138198,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gx = 0; //group index\\n        int nx =0;   //nums index\\n        return solve(groups,nums,gx,nx);\\n    }\\n    \\n    bool solve(vector<vector<int>>& groups, vector<int>& nums,int gx, int nx){\\n         if(gx== groups.size())\\n             return true;\\n         vector<int>g=groups[gx];\\n         int i =nx;\\n         while(i<nums.size())\\n         {\\n             for(int j=0;j<g.size();j++)\\n             {\\n                 if(g[j]!=nums[i++])\\n                 {\\n                     if(j!=0)\\n                         i--;\\n                     break;\\n                 }\\n                  if(j==g.size()-1 && solve(groups,nums,gx+1,i)==true)\\n                  {\\n                      return true;\\n                  }     \\n             }\\n         }\\n         return false;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gx = 0; //group index\\n        int nx =0;   //nums index\\n        return solve(groups,nums,gx,nx);\\n    }\\n    \\n    bool solve(vector<vector<int>>& groups, vector<int>& nums,int gx, int nx){\\n         if(gx== groups.size())\\n             return true;\\n         vector<int>g=groups[gx];\\n         int i =nx;\\n         while(i<nums.size())\\n         {\\n             for(int j=0;j<g.size();j++)\\n             {\\n                 if(g[j]!=nums[i++])\\n                 {\\n                     if(j!=0)\\n                         i--;\\n                     break;\\n                 }\\n                  if(j==g.size()-1 && solve(groups,nums,gx+1,i)==true)\\n                  {\\n                      return true;\\n                  }     \\n             }\\n         }\\n         return false;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135910,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int size = groups.size();\\n        int x=0,i=0;\\n        while(x<size && i<nums.size()){\\n            if(groups[x][0]==nums[i]){\\n                int j=1; int k=++i;\\n                for( j=1; j<groups[x].size(); j++,k++){\\n                    if(groups[x][j]!=nums[k]) break;\\n                }\\n                if(j==groups[x].size()){\\n                    x++;\\n                    i=k;\\n                }\\n            } else i++;\\n        }\\n        if(x==size) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int size = groups.size();\\n        int x=0,i=0;\\n        while(x<size && i<nums.size()){\\n            if(groups[x][0]==nums[i]){\\n                int j=1; int k=++i;\\n                for( j=1; j<groups[x].size(); j++,k++){\\n                    if(groups[x][j]!=nums[k]) break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1129504,
                "title": "naive-and-kmp-solution-c-cpp",
                "content": "1. Below is Naive approch \\nTime Complexity: **O(m * n)** \\n\\n```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int numslen = nums.size();\\n        int i, j, k = 0;\\n        // k for nums array \\n        for(i = 0; i < n; i++) {\\n            int m = groups[i].size();\\n            j = 0;\\n            int startPosK = k;\\n            while(k < numslen) {\\n                if(groups[i][j] == nums[k]) {\\n                    j++; k++;\\n                }\\n                else {\\n                    j = 0;\\n                    k = ++startPosK;\\n                }\\n                if(j >= m) break;\\n            }\\n            if(k == numslen) {i++; break;}\\n        }\\n        if(i == n && j == groups[n-1].size()) return true;\\n        return false;\\n    }\\n```\\n.........\\n\\n2. Now this is optimized patern searching algorithm KMP approch \\n\\tTime Complexity: **O(n + m)**\\n\\t\\n\\t```\\n\\tvector<int> getlps(vector<int> v)\\n    {\\n        int ptr = 0;\\n        int n=v.size();\\n        vector<int> lps(n, 0);\\n        int i = 1;\\n        while (i < n) \\n        {\\n            if (v[i] == v[ptr]) {\\n                ptr++;\\n                lps[i] = ptr;\\n                i++;\\n            }\\n            else\\n            {\\n                if (ptr != 0)ptr = lps[ptr - 1];\\n                else i++;\\n            }\\n        }\\n        return lps;\\n    }\\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;\\n        int n=groups.size();\\n        int j=0;\\n        while((i<n)&&(j<nums.size()))\\n        {\\n            vector<int> lps=getlps(groups[i]);\\n            int ptr1=0, ptr2=j;\\n            while((ptr1<groups[i].size())&&(ptr2<nums.size()))\\n            {\\n                if(groups[i][ptr1]==nums[ptr2])\\n                {\\n                    ptr1++;\\n                    ptr2++;\\n                }\\n                else\\n                {\\n                    if(ptr1!=0)ptr1=lps[ptr1-1];\\n                    else ptr2++;\\n                }\\n            }\\n            if(ptr1<groups[i].size())return false;\\n            i++;\\n            j=ptr2;\\n        }\\n        if(i==n)return true;\\n        return false;\\n    }\\n\\n**Thanks for reading !**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int numslen = nums.size();\\n        int i, j, k = 0;\\n        // k for nums array \\n        for(i = 0; i < n; i++) {\\n            int m = groups[i].size();\\n            j = 0;\\n            int startPosK = k;\\n            while(k < numslen) {\\n                if(groups[i][j] == nums[k]) {\\n                    j++; k++;\\n                }\\n                else {\\n                    j = 0;\\n                    k = ++startPosK;\\n                }\\n                if(j >= m) break;\\n            }\\n            if(k == numslen) {i++; break;}\\n        }\\n        if(i == n && j == groups[n-1].size()) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123067,
                "title": "use-string-find-java",
                "content": "One corner case is when nums is [12,1], and the groups is [[2,1]], the nums string will be `12-1-`, the group string will be `2-1-`. First check if `-2-1-` exists, if not, check if `2-1` exists, if`2-1` exists and the index is `0` or the previous character is `-`.\\n\\n```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        StringBuilder numstr = new StringBuilder();\\n        for(int n : nums) {\\n            numstr.append(n).append(\\'-\\');\\n        }\\n        int idx = 0;\\n        for(int[] group : groups) {\\n            StringBuilder g = new StringBuilder();\\n            g.append(\\'-\\');\\n            for(int n : group) {\\n                g.append(n).append(\\'-\\');\\n            }\\n            int cur = numstr.indexOf(g.toString(), idx);\\n            if(cur < 0) {\\n                g.deleteCharAt(0);\\n                int hcur = numstr.indexOf(g.toString(), idx);\\n                if(hcur < 0) return false;\\n                if(hcur != 0 && numstr.charAt(hcur - 1) != \\'-\\') return false;\\n            }\\n            idx = cur + g.length();\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        StringBuilder numstr = new StringBuilder();\\n        for(int n : nums) {\\n            numstr.append(n).append(\\'-\\');\\n        }\\n        int idx = 0;\\n        for(int[] group : groups) {\\n            StringBuilder g = new StringBuilder();\\n            g.append(\\'-\\');\\n            for(int n : group) {\\n                g.append(n).append(\\'-\\');\\n            }\\n            int cur = numstr.indexOf(g.toString(), idx);\\n            if(cur < 0) {\\n                g.deleteCharAt(0);\\n                int hcur = numstr.indexOf(g.toString(), idx);\\n                if(hcur < 0) return false;\\n                if(hcur != 0 && numstr.charAt(hcur - 1) != \\'-\\') return false;\\n            }\\n            idx = cur + g.length();\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122888,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n\\ti := 0\\n\\tfor start := 0; i < len(groups) && len(groups[i])+start <= len(nums); start++ {\\n\\t\\tif search(groups[i], nums, start) {\\n\\t\\t\\tstart += len(groups[i]) - 1\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn i == len(groups)\\n}\\n\\nfunc search(group, nums []int, start int) bool {\\n\\tfor i := 0; i < len(group); i++ {\\n\\t\\tif group[i] != nums[i+start] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n\\ti := 0\\n\\tfor start := 0; i < len(groups) && len(groups[i])+start <= len(nums); start++ {\\n\\t\\tif search(groups[i], nums, start) {\\n\\t\\t\\tstart += len(groups[i]) - 1\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn i == len(groups)\\n}\\n\\nfunc search(group, nums []int, start int) bool {\\n\\tfor i := 0; i < len(group); i++ {\\n\\t\\tif group[i] != nums[i+start] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122434,
                "title": "c-simple-kmp-algorithm-runtime-16ms-and-83",
                "content": "```\\n    void helper(vector<int>&prefix,vector<int>&arr){\\n        int j = 0;\\n        int n = prefix.size();\\n        for(int i=1;i<n;i++){\\n            if(arr[i]==arr[j]){\\n                prefix[i] = ++j;\\n            }\\n            else if(j!=0){\\n                j = prefix[j-1];\\n                i--;\\n            }\\n            else{\\n                prefix[i] = 0;\\n            }\\n        }\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums){\\n        int n = groups.size();\\n        vector<vector<int>>prefixes(n);\\n        for(int i=0;i<n;i++){\\n            prefixes[i].resize(groups[i].size(),0);\\n        }\\n        for(int i=0;i<n;i++){\\n            helper(prefixes[i],groups[i]);\\n        }\\n        int group = 0;\\n        int index = 0;\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(groups[group][index]==nums[i]){i++;index++;}\\n            if(index==groups[group].size()){\\n                index = 0;\\n                if(++group==groups.size()){return true;}\\n            }\\n            else if(i<nums.size()&&groups[group][index]!=nums[i]){\\n                if(index!=0)\\n                    index = prefixes[group][index-1];\\n                else\\n                    i++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    void helper(vector<int>&prefix,vector<int>&arr){\\n        int j = 0;\\n        int n = prefix.size();\\n        for(int i=1;i<n;i++){\\n            if(arr[i]==arr[j]){\\n                prefix[i] = ++j;\\n            }\\n            else if(j!=0){\\n                j = prefix[j-1];\\n                i--;\\n            }\\n            else{\\n                prefix[i] = 0;\\n            }\\n        }\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums){\\n        int n = groups.size();\\n        vector<vector<int>>prefixes(n);\\n        for(int i=0;i<n;i++){\\n            prefixes[i].resize(groups[i].size(),0);\\n        }\\n        for(int i=0;i<n;i++){\\n            helper(prefixes[i],groups[i]);\\n        }\\n        int group = 0;\\n        int index = 0;\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(groups[group][index]==nums[i]){i++;index++;}\\n            if(index==groups[group].size()){\\n                index = 0;\\n                if(++group==groups.size()){return true;}\\n            }\\n            else if(i<nums.size()&&groups[group][index]!=nums[i]){\\n                if(index!=0)\\n                    index = prefixes[group][index-1];\\n                else\\n                    i++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115128,
                "title": "c-beat-100-on-time",
                "content": "```\\n\\tint endingIndex(vector<int> &group, vector<int> &nums, int i) {\\n        int gs = group.size();\\n        int ns = nums.size();\\n        // match every window of size gs\\n        while(i+gs <= ns) {\\n            int j;\\n            for(j=i; j<i+gs; j++) {\\n                if(group[j-i] != nums[j]) {\\n                    break;\\n                }\\n            }\\n            if(j == i+gs) {\\n                return i+gs;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    } \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int st = 0;\\n        for(auto group: groups) {\\n            st = endingIndex(group, nums, st);\\n            if(st == -1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n\\tint endingIndex(vector<int> &group, vector<int> &nums, int i) {\\n        int gs = group.size();\\n        int ns = nums.size();\\n        // match every window of size gs\\n        while(i+gs <= ns) {\\n            int j;\\n            for(j=i; j<i+gs; j++) {\\n                if(group[j-i] != nums[j]) {\\n                    break;\\n                }\\n            }\\n            if(j == i+gs) {\\n                return i+gs;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    } \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int st = 0;\\n        for(auto group: groups) {\\n            st = endingIndex(group, nums, st);\\n            if(st == -1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114764,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }\\n    public boolean dfs(int[][] groups, int[] nums, int gidx, int nidx){\\n        if(gidx == groups.length) return true;\\n        int[] target = groups[gidx];\\n        for(int i=nidx; i<nums.length; i++){\\n            int j = 0;\\n            int tmpi = i;\\n            if(nums[i] == target[j]){\\n                while(i<nums.length && j<target.length && nums[i] == target[j]){\\n                    i++;\\n                    j++;\\n                }\\n                if(j==target.length)\\n                    return dfs(groups, nums, gidx+1, i);\\n            }\\n            i = tmpi;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1113750,
                "title": "simple-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i, j = 0 ,k = 0;\\n        \\n        for(i = 0; i < nums.size() && j < groups.size();) {\\n            int l = i;\\n            \\n            if(nums[i] == groups[j][k]) {\\n                \\n                while(i < nums.size() && k < groups[j].size() && nums[i] == groups[j][k]) \\n                    i++, k++;\\n                \\n                if(k == groups[j].size())\\n                    j++, k = 0;\\n                else\\n                    k = 0, i = l+1;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        return j == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i, j = 0 ,k = 0;\\n        \\n        for(i = 0; i < nums.size() && j < groups.size();) {\\n            int l = i;\\n            \\n            if(nums[i] == groups[j][k]) {\\n                \\n                while(i < nums.size() && k < groups[j].size() && nums[i] == groups[j][k]) \\n                    i++, k++;\\n                \\n                if(k == groups[j].size())\\n                    j++, k = 0;\\n                else\\n                    k = 0, i = l+1;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        return j == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111496,
                "title": "python-kmp-beats-100",
                "content": "Just KMP algorithm, O(len(group) * len(group[0]) + len(nums)).\\n```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        \"\"\"\\n        :type groups: List[List[int]]\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # kmp\\n        def find(pat, start):\\n            next = [0] * len(pat)\\n            j = 0\\n            for i in range(1, len(pat)):\\n                while j and pat[i] != pat[j]:\\n                    j = next[j - 1]\\n                j += pat[i] == pat[j]\\n                next[i] = j\\n            j = 0\\n            while start < m:\\n                while j and nums[start] != pat[j]:\\n                    j = next[j - 1]\\n                if nums[start] == pat[j]:\\n                    j += 1\\n\\t\\t\\t\\tstart += 1\\n                if j == len(pat):\\n\\t\\t\\t\\t\\treturn start\\n            return -1\\n\\n\\n        m = len(nums)\\n        i = 0\\n        for g in groups:\\n            i = find(g, i)\\n            if i < 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        \"\"\"\\n        :type groups: List[List[int]]\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # kmp\\n        def find(pat, start):\\n            next = [0] * len(pat)\\n            j = 0\\n            for i in range(1, len(pat)):\\n                while j and pat[i] != pat[j]:\\n                    j = next[j - 1]\\n                j += pat[i] == pat[j]\\n                next[i] = j\\n            j = 0\\n            while start < m:\\n                while j and nums[start] != pat[j]:\\n                    j = next[j - 1]\\n                if nums[start] == pat[j]:\\n                    j += 1\\n\\t\\t\\t\\tstart += 1\\n                if j == len(pat):\\n\\t\\t\\t\\t\\treturn start\\n            return -1\\n\\n\\n        m = len(nums)\\n        i = 0\\n        for g in groups:\\n            i = find(g, i)\\n            if i < 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110875,
                "title": "java-100-faster-and-memory-kmp-pattern-algo",
                "content": "```\\n\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n        int groupIndex= 0, eleIndex= 0;\\n        int[] pattern= generatePattern(groups[groupIndex]);\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]==groups[groupIndex][eleIndex]) eleIndex++;\\n            else if(eleIndex>0){\\n                eleIndex= pattern[eleIndex-1]+1;\\n                index--;\\n            } \\n            if(eleIndex==groups[groupIndex].length){\\n                groupIndex++; eleIndex=0;\\n                if(groupIndex==groups.length) return true;\\n                else{\\n                    pattern= generatePattern(groups[groupIndex]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public int[] generatePattern(int[] group){\\n        int[] pattern= new int[group.length];\\n        int prev= 0, ahead= 1; pattern[0]= -1;\\n        Arrays.fill(pattern,-1);\\n        while(ahead<group.length){\\n            if(group[prev]==group[ahead]){\\n                pattern[ahead]= prev;\\n                prev++; ahead++;\\n            }else if(prev>0){\\n                prev= pattern[prev-1]+1;\\n            }else ahead++;\\n        }\\n        return pattern;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n        int groupIndex= 0, eleIndex= 0;\\n        int[] pattern= generatePattern(groups[groupIndex]);\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]==groups[groupIndex][eleIndex]) eleIndex++;\\n            else if(eleIndex>0){\\n                eleIndex= pattern[eleIndex-1]+1;\\n                index--;\\n            } \\n            if(eleIndex==groups[groupIndex].length){\\n                groupIndex++; eleIndex=0;\\n                if(groupIndex==groups.length) return true;\\n                else{\\n                    pattern= generatePattern(groups[groupIndex]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public int[] generatePattern(int[] group){\\n        int[] pattern= new int[group.length];\\n        int prev= 0, ahead= 1; pattern[0]= -1;\\n        Arrays.fill(pattern,-1);\\n        while(ahead<group.length){\\n            if(group[prev]==group[ahead]){\\n                pattern[ahead]= prev;\\n                prev++; ahead++;\\n            }else if(prev>0){\\n                prev= pattern[prev-1]+1;\\n            }else ahead++;\\n        }\\n        return pattern;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1104835,
                "title": "javascript-solution",
                "content": "```\\nvar canChoose = function(groups, nums) {\\n    let currGroup = groups.shift();\\n    let i = 0;\\n    \\n    while (i < nums.length) {\\n        if (nums[i] === currGroup[0]) {\\n            if (nums.slice(i, i + currGroup.length).join(\\'\\') === currGroup.join(\\'\\')) {\\n                if (groups.length) { \\n                    i = i + currGroup.length; // increment i past the used indexes in nums to avoid repeats\\n                    currGroup = groups.shift(); // currGroup becomes the next array in groups\\n                    continue;\\n                } else {\\n                    return true; // we\\'ve found a match for all the subarrays in groups\\n                }\\n            }\\n        }\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canChoose = function(groups, nums) {\\n    let currGroup = groups.shift();\\n    let i = 0;\\n    \\n    while (i < nums.length) {\\n        if (nums[i] === currGroup[0]) {\\n            if (nums.slice(i, i + currGroup.length).join(\\'\\') === currGroup.join(\\'\\')) {\\n                if (groups.length) { \\n                    i = i + currGroup.length; // increment i past the used indexes in nums to avoid repeats\\n                    currGroup = groups.shift(); // currGroup becomes the next array in groups\\n                    continue;\\n                } else {\\n                    return true; // we\\'ve found a match for all the subarrays in groups\\n                }\\n            }\\n        }\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099079,
                "title": "just-recursive-style-brutal-force",
                "content": "```\\nclass Solution {\\npublic:\\n\\n#define vv vector<vector<int> >*\\n#define v vector<int>*\\n\\nbool f(vv groups, v nums, int gi, int ni)\\n{\\n\\n    if (gi == groups->size())\\n        return true;\\n    if (ni >= nums->size())\\n        return false;\\n    v curr = &(groups->at(gi));\\n    while (ni < nums->size())\\n    {\\n        if (nums->at(ni) != curr->front())\\n        {\\n            ni++;\\n        }\\n        else\\n        {\\n            //  cout << \"found here\" << ni  <<  nums[ni] << endl;\\n            int runner = ni;\\n            while (runner < nums->size() && runner - ni < curr->size() && nums->at(runner) == curr->at(runner - ni))\\n                runner++;\\n\\n            if (runner - ni == curr->size())\\n            {\\n                return f(groups, nums, gi + 1, runner);\\n            }\\n            else\\n            {\\n                ni++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n    bool canChoose(vector<vector<int> > &groups, vector<int> &nums)\\n{\\n\\n    return f(&groups, &nums, 0, 0);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n#define vv vector<vector<int> >*\\n#define v vector<int>*\\n\\nbool f(vv groups, v nums, int gi, int ni)\\n{\\n\\n    if (gi == groups->size())\\n        return true;\\n    if (ni >= nums->size())\\n        return false;\\n    v curr = &(groups->at(gi));\\n    while (ni < nums->size())\\n    {\\n        if (nums->at(ni) != curr->front())\\n        {\\n            ni++;\\n        }\\n        else\\n        {\\n            //  cout << \"found here\" << ni  <<  nums[ni] << endl;\\n            int runner = ni;\\n            while (runner < nums->size() && runner - ni < curr->size() && nums->at(runner) == curr->at(runner - ni))\\n                runner++;\\n\\n            if (runner - ni == curr->size())\\n            {\\n                return f(groups, nums, gi + 1, runner);\\n            }\\n            else\\n            {\\n                ni++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n    bool canChoose(vector<vector<int> > &groups, vector<int> &nums)\\n{\\n\\n    return f(&groups, &nums, 0, 0);\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1096328,
                "title": "python-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        arrFound = 0\\n        i = 0\\n\\t\\t#we itereate all groups\\n        for arr in groups:\\n            currLen = len(arr)\\n\\t\\t\\t#we check if the curr group of num is equal to the current nums subarray, if so, we add 1 to arrFound and we move i to the next element in the array and we break the while. If is not equal, we simply move to the next element.\\n            while i < len(nums):\\n                if arr == nums[i:i+currLen]:\\n                    arrFound += 1\\n                    i = i + currLen\\n                    break\\n                i += 1\\n\\t\\t#we compare if the quantity found is equal to len(groups), if so it means that all was found.\\n        return arrFound == len(groups) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        arrFound = 0\\n        i = 0\\n\\t\\t#we itereate all groups\\n        for arr in groups:\\n            currLen = len(arr)\\n\\t\\t\\t#we check if the curr group of num is equal to the current nums subarray, if so, we add 1 to arrFound and we move i to the next element in the array and we break the while. If is not equal, we simply move to the next element.\\n            while i < len(nums):\\n                if arr == nums[i:i+currLen]:\\n                    arrFound += 1\\n                    i = i + currLen\\n                    break\\n                i += 1\\n\\t\\t#we compare if the quantity found is equal to len(groups), if so it means that all was found.\\n        return arrFound == len(groups) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091546,
                "title": "100-faster-and-documented-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool canChoose(vector<vector<int>>& groups, vector<int>& A) {\\n         int prev = 0, dist =0, count = 0;\\n         auto itr = A.begin();\\n         for(int i=0; i < groups.size(); i++)\\n         {\\n             vector<int>& vec = groups[i];\\n             //Add previous offset to begin so that searching start after this index\\n             itr = A.begin() + prev;\\n             \\n             dist = itr - A.begin();\\n             //If dist already reached end but there are still some arrays to be searched return false;\\n             if(dist >= A.size())\\n                 return false;\\n\\n             bool isFound = true;\\n             bool isLoopHit = false;\\n             \\n             while((itr = find(itr, A.end(),  vec[0])) != A.end() )\\n             {\\n                 isFound = true;\\n                 isLoopHit = true;\\n                dist = itr - A.begin()+1;\\n                 //If left over characters in A is less than size of searching vector return false;\\n                 if((vec.size() - 1 + dist) > A.size())\\n                     return false;\\n                 \\n                for(int j = 1; j < vec.size() && dist < A.size(); j++, dist++)\\n                {\\n                    if(vec[j] != A[dist])   \\n                    {\\n                        isFound = false;\\n                        break; //For loop\\n                    }\\n                }\\n                 \\n                 //If subarray matched then set prev to dist and break while loop\\n                 if(isFound == true)\\n                 {\\n                     prev = dist;\\n                     break; //break while loop\\n                 }\\n                 //If not then progress itr one step to search further\\n                 else\\n                 {\\n                     itr++;\\n                 }\\n             }\\n             //If subarray is not found in A array then return false;\\n             if( isFound == false )\\n                 return false;\\n             \\n             //If loop is not hit i.e. first element of vector is not found and \\n             //When still have some subarrays to be searched then return false;\\n             if(isLoopHit == false && i <= groups.size()-1 )\\n                 return false;\\n         }\\n         \\n         return true;\\n     }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     bool canChoose(vector<vector<int>>& groups, vector<int>& A) {\\n         int prev = 0, dist =0, count = 0;\\n         auto itr = A.begin();\\n         for(int i=0; i < groups.size(); i++)\\n         {\\n             vector<int>& vec = groups[i];\\n             //Add previous offset to begin so that searching start after this index\\n             itr = A.begin() + prev;\\n             \\n             dist = itr - A.begin();\\n             //If dist already reached end but there are still some arrays to be searched return false;\\n             if(dist >= A.size())\\n                 return false;\\n\\n             bool isFound = true;\\n             bool isLoopHit = false;\\n             \\n             while((itr = find(itr, A.end(),  vec[0])) != A.end() )\\n             {\\n                 isFound = true;\\n                 isLoopHit = true;\\n                dist = itr - A.begin()+1;\\n                 //If left over characters in A is less than size of searching vector return false;\\n                 if((vec.size() - 1 + dist) > A.size())\\n                     return false;\\n                 \\n                for(int j = 1; j < vec.size() && dist < A.size(); j++, dist++)\\n                {\\n                    if(vec[j] != A[dist])   \\n                    {\\n                        isFound = false;\\n                        break; //For loop\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1091066,
                "title": "c-100-faster-timecomplexity-o-m-n",
                "content": "```\\nclass Solution {\\n\\nprivate :\\n    int findNextGroup(std::vector<int> &group ,std::vector<int> &nums,int start)\\n    {\\n        while (start <= nums.size() - group.size())\\n        {\\n            bool notfound = false;\\n            for (int i=0;i<group.size();++i)\\n            {\\n                if (group[i] != nums[start + i]) \\n                {\\n                    notfound = true;\\n                    break;\\n                }\\n            }\\n            if (!notfound) return start + group.size();\\n            ++start;\\n        }\\n        return -1;\\n    }\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int start = 0;\\n        for (auto &vec:groups)\\n        {\\n            start = findNextGroup(vec,nums,start);\\n            if (start == -1) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\nprivate :\\n    int findNextGroup(std::vector<int> &group ,std::vector<int> &nums,int start)\\n    {\\n        while (start <= nums.size() - group.size())\\n        {\\n            bool notfound = false;\\n            for (int i=0;i<group.size();++i)\\n            {\\n                if (group[i] != nums[start + i]) \\n                {\\n                    notfound = true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1089995,
                "title": "c-easy-to-understand-solution",
                "content": "Thanks to the SIMPLE test cases, I am not using KMP and still passes. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {        \\n        int last = 0; \\n        \\n        for (int i = 0; i < groups.size(); i++) {\\n            int l = -1, r = 0, j = last;\\n            \\n            while (j < nums.size() && r < groups[i].size()) {\\n                // try to match group[i] one by one, variable `l` is used to mark the starting position\\n                if (nums[j] == groups[i][r]) {\\n                    if (r == 0) l = j; \\n                    r++; j++; continue; \\n                }\\n                \\n                // if it fails to match, roll back `j` and reset `l`\\n                if (l > -1 && nums[j] != groups[i][r]) {\\n                    j = l + 1; l = -1; r = 0; continue;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            if (l == -1 || (j == nums.size() && r < groups[i].size())) return false; \\n            last = l + groups[i].size();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {        \\n        int last = 0; \\n        \\n        for (int i = 0; i < groups.size(); i++) {\\n            int l = -1, r = 0, j = last;\\n            \\n            while (j < nums.size() && r < groups[i].size()) {\\n                // try to match group[i] one by one, variable `l` is used to mark the starting position\\n                if (nums[j] == groups[i][r]) {\\n                    if (r == 0) l = j; \\n                    r++; j++; continue; \\n                }\\n                \\n                // if it fails to match, roll back `j` and reset `l`\\n                if (l > -1 && nums[j] != groups[i][r]) {\\n                    j = l + 1; l = -1; r = 0; continue;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            if (l == -1 || (j == nums.size() && r < groups[i].size())) return false; \\n            last = l + groups[i].size();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087399,
                "title": "c-well-commented-solution",
                "content": "```\\nclass Solution {\\n    // solution #1: locate the end position of subarray in nums matching first group\\n    // then locate next group from last matching end \\n    // use two pointers to locate the matching subarray vs. current group\\n    // tips and pitfalls:\\n    // 1) when last trial of matching group, reset pointer in nums to last trial start + 1\\n    // time: O(m*n), space: O(1)\\nprivate:\\n    int locate(vector<int>& g, vector<int>& nums, int s) {\\n        int i = 0, j = s, start = s;\\n        if (s + g.size() > nums.size()) return -1;\\n        while (i < g.size() && j < nums.size()) {\\n            if (g[i] == nums[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j = start + 1;\\n                start = j;\\n                i = 0;\\n            }\\n        }\\n        return i == g.size() ? j : -1;\\n    }\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int lenSum = 0;\\n        for (auto& g : groups) lenSum += g.size();\\n        if (lenSum > nums.size()) return false;\\n        for (int i = 0, nextStart = 0; i < groups.size(); i++) {\\n            nextStart = locate(groups[i], nums, nextStart);\\n            if (nextStart == -1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // solution #1: locate the end position of subarray in nums matching first group\\n    // then locate next group from last matching end \\n    // use two pointers to locate the matching subarray vs. current group\\n    // tips and pitfalls:\\n    // 1) when last trial of matching group, reset pointer in nums to last trial start + 1\\n    // time: O(m*n), space: O(1)\\nprivate:\\n    int locate(vector<int>& g, vector<int>& nums, int s) {\\n        int i = 0, j = s, start = s;\\n        if (s + g.size() > nums.size()) return -1;\\n        while (i < g.size() && j < nums.size()) {\\n            if (g[i] == nums[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j = start + 1;\\n                start = j;\\n                i = 0;\\n            }\\n        }\\n        return i == g.size() ? j : -1;\\n    }\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int lenSum = 0;\\n        for (auto& g : groups) lenSum += g.size();\\n        if (lenSum > nums.size()) return false;\\n        for (int i = 0, nextStart = 0; i < groups.size(); i++) {\\n            nextStart = locate(groups[i], nums, nextStart);\\n            if (nextStart == -1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086637,
                "title": "absolutely-dominating-solution-in-java-100-100-enjoy-in-the-masterpiece-of-code",
                "content": "Runtime: **1 ms**, faster than **100.00%** of Java online submissions for Form Array by Concatenating Subarrays of Another Array.\\n\\nMemory Usage: **38.6 MB**, less than **100.00%** of Java online submissions for Form Array by Concatenating Subarrays of Another Array.\\n\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n\\t\\tboolean canDo = true;\\n\\t\\t\\n\\t\\tint start = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < groups.length && canDo; i++) {\\n\\t\\t\\t\\n\\t\\t\\tboolean canDoPartial = start + groups[i].length - 1 < nums.length;\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = start; j < nums.length && canDoPartial; j++) {\\n\\t\\t\\t\\tboolean found = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int k = 0; k < groups[i].length && found; k++) {\\n\\t\\t\\t\\t\\tif (groups[i][k] != nums[j + k]) {\\n\\t\\t\\t\\t\\t\\tfound = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (found) {\\n\\t\\t\\t\\t\\tstart = j + groups[i].length;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcanDoPartial = j + groups[i].length < nums.length;\\n\\t\\t\\t\\t}\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (!canDoPartial) {\\n\\t\\t\\t\\tcanDo = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn canDo;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n\\t\\tboolean canDo = true;\\n\\t\\t\\n\\t\\tint start = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < groups.length && canDo; i++) {\\n\\t\\t\\t\\n\\t\\t\\tboolean canDoPartial = start + groups[i].length - 1 < nums.length;\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = start; j < nums.length && canDoPartial; j++) {\\n\\t\\t\\t\\tboolean found = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int k = 0; k < groups[i].length && found; k++) {\\n\\t\\t\\t\\t\\tif (groups[i][k] != nums[j + k]) {\\n\\t\\t\\t\\t\\t\\tfound = false;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1084638,
                "title": "jave-simple-solution-by-storage-num-s-loc-in-a-map",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        Map<Integer, Deque<Integer>> map = new HashMap<>();\\n        for (int i = 0;i < nums.length;i++) {\\n            Deque<Integer> tmp = map.getOrDefault(nums[i], new LinkedList<>());\\n            tmp.offerLast(i);\\n            map.put(nums[i],tmp);\\n        }\\n        int idx = 0;\\n        for (int[] grp : groups) {\\n            idx = check(grp, map.get(grp[0]), nums, idx);\\n            if (idx == -1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int check(int[] grp, Deque<Integer> idxes, int[] nums, int idx) {\\n        if (idxes == null || idxes.size() == 0) return -1;\\n        while(!idxes.isEmpty() && idxes.peekFirst() < idx) idxes.pollFirst();\\n        if (idxes.isEmpty()) return -1;\\n        while (!idxes.isEmpty()) {\\n            int curIdx = idxes.pollFirst();\\n            boolean found = true;\\n            for (int i = 0;i < grp.length;i++) {\\n                if (curIdx + i >= nums.length || grp[i] != nums[curIdx + i]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return curIdx + grp.length;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        Map<Integer, Deque<Integer>> map = new HashMap<>();\\n        for (int i = 0;i < nums.length;i++) {\\n            Deque<Integer> tmp = map.getOrDefault(nums[i], new LinkedList<>());\\n            tmp.offerLast(i);\\n            map.put(nums[i],tmp);\\n        }\\n        int idx = 0;\\n        for (int[] grp : groups) {\\n            idx = check(grp, map.get(grp[0]), nums, idx);\\n            if (idx == -1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int check(int[] grp, Deque<Integer> idxes, int[] nums, int idx) {\\n        if (idxes == null || idxes.size() == 0) return -1;\\n        while(!idxes.isEmpty() && idxes.peekFirst() < idx) idxes.pollFirst();\\n        if (idxes.isEmpty()) return -1;\\n        while (!idxes.isEmpty()) {\\n            int curIdx = idxes.pollFirst();\\n            boolean found = true;\\n            for (int i = 0;i < grp.length;i++) {\\n                if (curIdx + i >= nums.length || grp[i] != nums[curIdx + i]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return curIdx + grp.length;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084249,
                "title": "clean-easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&v ,list<int>&l)\\n    {\\n        if(v.size()!=l.size())\\n            return false;\\n        int c=0;\\n        for(auto it:l)\\n        {\\n            if(it!=v[c++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int num=0;//Group Number to be taken\\n        int size=groups[num].size();//Size of this group\\n        list<int>temp; //Temp vector\\n        for(auto it:nums)\\n        {\\n            temp.push_back(it);\\n            if(temp.size()>size)\\n                temp.pop_front();\\n            \\n            //So now it have size=group we are currently on\\n            if(check(groups[num],temp))\\n            {\\n                //first group matched \\n                num++;\\n                if(num==groups.size())\\n                    break;\\n                size=groups[num].size();\\n                temp.clear();//Because we want no intersection\\n            }\\n        }\\n        return (num==groups.size());\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&v ,list<int>&l)\\n    {\\n        if(v.size()!=l.size())\\n            return false;\\n        int c=0;\\n        for(auto it:l)\\n        {\\n            if(it!=v[c++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int num=0;//Group Number to be taken\\n        int size=groups[num].size();//Size of this group\\n        list<int>temp; //Temp vector\\n        for(auto it:nums)\\n        {\\n            temp.push_back(it);\\n            if(temp.size()>size)\\n                temp.pop_front();\\n            \\n            //So now it have size=group we are currently on\\n            if(check(groups[num],temp))\\n            {\\n                //first group matched \\n                num++;\\n                if(num==groups.size())\\n                    break;\\n                size=groups[num].size();\\n                temp.clear();//Because we want no intersection\\n            }\\n        }\\n        return (num==groups.size());\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570393,
                "content": [
                    {
                        "username": "salmanpatel131",
                        "content": "Why Output for below Input is False ?\\n\\n[[1,2]]\\n[1,3,2]\\n\\nPlease correct me if I am wrong."
                    },
                    {
                        "username": "at218808",
                        "content": "[1,2] is not even subgroup of [1,3,2]"
                    },
                    {
                        "username": "PencilBro27",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "dixiao2020",
                        "content": "<img width=400px;height=600px src =\"https://i.postimg.cc/Pq35Wj21/KMP.jpg\">\n\nIf you are new to the KMP algorithm, the upper figure shows why we set len =LSP[len-1] if len>0 and pat[len] != pat[i].\nUpper band: indices for the pattern array\nMiddle band: proper prefix up to index i, the length of this band is Len\nLower band: proper suffix up to index index i.\nSo if  'a'=pattern[Len] != pattern[i]='d',  then we test the length of proper prefix and proper suffix up to index Len-1,  which is equal to LSP[Len-1] by definition of LSP. The purple boxes in the figure are the prefixes and suffixes which has newLen=LSP[Len-1]. Because the string represented as Middle band is totally the same as the string represented as lower band, symmetry shows the four purple boxes are the same, then if we find Pattern[newLen=LSP[Len-1]] and Pattern[i] are equal for instance they both equal 'd', then we increment the newLen by 1 and set LSP[i]=newLen. The proper prefix and suffix up to index i are then showed inside the red circles."
                    }
                ]
            },
            {
                "id": 2037836,
                "content": [
                    {
                        "username": "salmanpatel131",
                        "content": "Why Output for below Input is False ?\\n\\n[[1,2]]\\n[1,3,2]\\n\\nPlease correct me if I am wrong."
                    },
                    {
                        "username": "at218808",
                        "content": "[1,2] is not even subgroup of [1,3,2]"
                    },
                    {
                        "username": "PencilBro27",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "dixiao2020",
                        "content": "<img width=400px;height=600px src =\"https://i.postimg.cc/Pq35Wj21/KMP.jpg\">\n\nIf you are new to the KMP algorithm, the upper figure shows why we set len =LSP[len-1] if len>0 and pat[len] != pat[i].\nUpper band: indices for the pattern array\nMiddle band: proper prefix up to index i, the length of this band is Len\nLower band: proper suffix up to index index i.\nSo if  'a'=pattern[Len] != pattern[i]='d',  then we test the length of proper prefix and proper suffix up to index Len-1,  which is equal to LSP[Len-1] by definition of LSP. The purple boxes in the figure are the prefixes and suffixes which has newLen=LSP[Len-1]. Because the string represented as Middle band is totally the same as the string represented as lower band, symmetry shows the four purple boxes are the same, then if we find Pattern[newLen=LSP[Len-1]] and Pattern[i] are equal for instance they both equal 'd', then we increment the newLen by 1 and set LSP[i]=newLen. The proper prefix and suffix up to index i are then showed inside the red circles."
                    }
                ]
            }
        ]
    },
    {
        "title": "Map of Highest Peak",
        "question_content": "<p>You are given an integer matrix <code>isWater</code> of size <code>m x n</code> that represents a map of <strong>land</strong> and <strong>water</strong> cells.</p>\n\n<ul>\n\t<li>If <code>isWater[i][j] == 0</code>, cell <code>(i, j)</code> is a <strong>land</strong> cell.</li>\n\t<li>If <code>isWater[i][j] == 1</code>, cell <code>(i, j)</code> is a <strong>water</strong> cell.</li>\n</ul>\n\n<p>You must assign each cell a height in a way that follows these rules:</p>\n\n<ul>\n\t<li>The height of each cell must be non-negative.</li>\n\t<li>If the cell is a <strong>water</strong> cell, its height must be <code>0</code>.</li>\n\t<li>Any two adjacent cells must have an absolute height difference of <strong>at most</strong> <code>1</code>. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</li>\n</ul>\n\n<p>Find an assignment of heights such that the maximum height in the matrix is <strong>maximized</strong>.</p>\n\n<p>Return <em>an integer matrix </em><code>height</code><em> of size </em><code>m x n</code><em> where </em><code>height[i][j]</code><em> is cell </em><code>(i, j)</code><em>&#39;s height. If there are multiple solutions, return <strong>any</strong> of them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png\" style=\"width: 220px; height: 219px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> isWater = [[0,1],[0,0]]\n<strong>Output:</strong> [[1,0],[2,1]]\n<strong>Explanation:</strong> The image shows the assigned heights of each cell.\nThe blue cell is the water cell, and the green cells are the land cells.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png\" style=\"width: 300px; height: 296px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> isWater = [[0,0,1],[1,0,0],[0,0,0]]\n<strong>Output:</strong> [[1,1,0],[0,1,1],[1,2,2]]\n<strong>Explanation:</strong> A height of 2 is the maximum possible height of any assignment.\nAny height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == isWater.length</code></li>\n\t<li><code>n == isWater[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>isWater[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li>There is at least <strong>one</strong> water cell.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1074551,
                "title": "python-java-bfs-from-cell-with-lowest-height-clean-concise",
                "content": "**Idea**\\n- Firstly, we fill water cells with height = 0 and start to fill from their cells.\\n- We prioritize filling cells with lowest height by using BFS (using queue, first in first out).\\n- Because `any two adjacent cells must have an absolute height difference of at most 1`, we can set height of neighbors maximum 1 height bigger than current cell.\\n\\n![image](https://assets.leetcode.com/users/images/14c85cfb-1c24-4629-8aae-d1a216c899d6_1613836714.1379192.png)\\n\\n\\n**Complexity:**\\n- Time & Space: `O(m * n)`\\n\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        m, n = len(isWater), len(isWater[0])\\n        height = [[-1] * n for _ in range(m)]\\n        bfs = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if isWater[r][c] == 1:\\n                    bfs.append((r, c))\\n                    height[r][c] = 0\\n\\n        DIR = [0, 1, 0, -1, 0]\\n        while bfs:\\n            r, c = bfs.popleft()\\n            for i in range(4):\\n                nr, nc = r + DIR[i], c + DIR[i + 1]\\n                if nr < 0 or nr == m or nc < 0 or nc == n or height[nr][nc] != -1: continue\\n                height[nr][nc] = height[r][c] + 1\\n                bfs.append((nr, nc))\\n        return height\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int m = isWater.length, n = isWater[0].length;\\n        Queue<int[]> bfs = new LinkedList<>();\\n        int[][] height = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (isWater[r][c] == 1) {\\n                    height[r][c] = 0;\\n                    bfs.offer(new int[]{r, c});\\n                } else {\\n                    height[r][c] = -1;\\n                }\\n            }\\n        }\\n        int[] DIR = new int[]{0, 1, 0, -1, 0};\\n        while (!bfs.isEmpty()) {\\n            int[] top = bfs.poll();\\n            int r = top[0], c = top[1];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i], nc = c + DIR[i+1];\\n                if (nr < 0 || nr == m || nc < 0 || nc == n || height[nr][nc] != -1) continue;\\n                height[nr][nc] = height[r][c] + 1;\\n                bfs.offer(new int[]{nr, nc});\\n            }\\n        }\\n        return height;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        m, n = len(isWater), len(isWater[0])\\n        height = [[-1] * n for _ in range(m)]\\n        bfs = deque([])\\n        for r in range(m):\\n            for c in range(n):\\n                if isWater[r][c] == 1:\\n                    bfs.append((r, c))\\n                    height[r][c] = 0\\n\\n        DIR = [0, 1, 0, -1, 0]\\n        while bfs:\\n            r, c = bfs.popleft()\\n            for i in range(4):\\n                nr, nc = r + DIR[i], c + DIR[i + 1]\\n                if nr < 0 or nr == m or nc < 0 or nc == n or height[nr][nc] != -1: continue\\n                height[nr][nc] = height[r][c] + 1\\n                bfs.append((nr, nc))\\n        return height\\n```\n```java\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int m = isWater.length, n = isWater[0].length;\\n        Queue<int[]> bfs = new LinkedList<>();\\n        int[][] height = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (isWater[r][c] == 1) {\\n                    height[r][c] = 0;\\n                    bfs.offer(new int[]{r, c});\\n                } else {\\n                    height[r][c] = -1;\\n                }\\n            }\\n        }\\n        int[] DIR = new int[]{0, 1, 0, -1, 0};\\n        while (!bfs.isEmpty()) {\\n            int[] top = bfs.poll();\\n            int r = top[0], c = top[1];\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i], nc = c + DIR[i+1];\\n                if (nr < 0 || nr == m || nc < 0 || nc == n || height[nr][nc] != -1) continue;\\n                height[nr][nc] = height[r][c] + 1;\\n                bfs.offer(new int[]{nr, nc});\\n            }\\n        }\\n        return height;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076933,
                "title": "c-with-picture-of-mars",
                "content": "OK, it was an 6:30 AM in my time zone, and I did not see it. So I solved it by raising land layer-by-layer by checking adjacent cells.\\n\\nIt seemed to work, but then I got TLE. It took me a while (blaming early morning, again), to realize that the same effect can be achieved if we do BFS starting from all water cells.\\n\\nIn the picture below, you can see that each tern, unvisited (white) cells always board visited cells with the same height. Thus, the rules defined for this problem are satisfied.\\n\\n> This example may resemble the surface of Mars, with red and rocky hills, and scarce pockets of frozen water.\\n\\n![image](https://assets.leetcode.com/users/images/aae9620d-3804-43ec-add5-86b3610b2eec_1613943502.4768167.png)\\n\\n**C++**\\n1. Collect all water cells into a queue and mark all other cells as unvisited (`-1`).\\n2. For the current round of water cells (`h` is 0) in the queue:\\n\\t- Check neighboring cells in 4 direction.\\n\\t- If the cell is unvisited, set it to `h + 1` and add it to the next round queue.\\n3. When done with the current round, increase `h`.\\n4. Repeat step 2 for the next round queue (if not empty).\\n\\n```cpp\\nint dirs[5] = {0, 1, 0, -1, 0};\\nvector<vector<int>> highestPeak(vector<vector<int>>& w) {\\n    vector<pair<int, int>> p;\\n    int h = 1, si = w.size(), sj = w[0].size();\\n    for (auto i = 0; i < si; ++i)\\n        for (auto j = 0; j < sj; ++j) {\\n            w[i][j] = w[i][j] == 1 ? 0 : -1;\\n            if (w[i][j] == 0)\\n                p.push_back({i, j});\\n        }\\n    while (!p.empty()) {\\n        vector<pair<int, int>> p1;\\n        for (auto [i, j] : p) {\\n            for (int d = 0; d < 4; ++d) {\\n                int x = i + dirs[d], y = j + dirs[d + 1];\\n                if (x >= 0 && y >= 0 && x < si && y < sj && w[x][y] == -1) {\\n                    w[x][y] = h;\\n                    p1.push_back({x, y});\\n                }\\n            }\\n        }\\n        swap(p, p1);\\n        ++h;\\n    }\\n    return w;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dirs[5] = {0, 1, 0, -1, 0};\\nvector<vector<int>> highestPeak(vector<vector<int>>& w) {\\n    vector<pair<int, int>> p;\\n    int h = 1, si = w.size(), sj = w[0].size();\\n    for (auto i = 0; i < si; ++i)\\n        for (auto j = 0; j < sj; ++j) {\\n            w[i][j] = w[i][j] == 1 ? 0 : -1;\\n            if (w[i][j] == 0)\\n                p.push_back({i, j});\\n        }\\n    while (!p.empty()) {\\n        vector<pair<int, int>> p1;\\n        for (auto [i, j] : p) {\\n            for (int d = 0; d < 4; ++d) {\\n                int x = i + dirs[d], y = j + dirs[d + 1];\\n                if (x >= 0 && y >= 0 && x < si && y < sj && w[x][y] == -1) {\\n                    w[x][y] = h;\\n                    p1.push_back({x, y});\\n                }\\n            }\\n        }\\n        swap(p, p1);\\n        ++h;\\n    }\\n    return w;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074557,
                "title": "java-python-3-2-bfs-codes-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\nQ1: Why are we trying to find the shortest path? \\nA1: We are not looking for shortest path, just following the rules of the problems to maximize the heights of all cells;\\n\\nQ2: Why do we use BFS here? Why does it even work? Why does BFS guarantee the maximum height?\\nA2: \\na. According to the problem requirement, we need to assign the value of 0 to all waters; \\nb. all lands neighboring waters have a value at most 1;\\nc. all lands neighboring lands with a value of 1 will have a value at most 2; \\nd. all lands neighboring lands with a value of 2 will have a value at most 3;\\n...\\nThe problem requires that all neighboring cells height difference is at most 1.\\n\\nFrom waters we start to BFS, in each step we maximize the difference between the neighboring cells as `1`.  Therefore we can guarantee the maximum height.\\n**End of Q & A**\\n\\n----\\n\\n1. Since the height of all waters is 0, we start from waters with a height of 0;\\n2. The difference of all adjacent cells heights is at most 1, according to the rule of the problem; Therefore, we can use BFS to assign heights to neighboring cells by increasing height by 1.\\n \\n**Method 1:** -- credit to **@celticrocks** for suggestion to remove HashSet.\\n\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int[][] highestPeak(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int r = 0; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                if (A[r][c] == 1) {\\n                    q.offer(new int[]{r, c}); // put its position into Queue as one of the starting points of BFS.\\n                }\\n                --A[r][c]; // Set the height to 0, the land by -1.\\n            }\\n        }\\n        while (!q.isEmpty()) { // BFS starts here.\\n            int[] pos = q.poll(); // Current position.\\n            int r = pos[0], c = pos[1];\\n            for (int k = 0; k < 4; ++k) { // Traverse its neighbors.\\n                int x = r + d[k], y = c + d[k + 1];\\n                if (0 <= x && x < m && 0 <= y && y < n && A[x][y] < 0) {\\n                    A[x][y] = A[r][c] + 1; // assign corresponding height value.\\n                    q.offer(new int[]{x, y}); // put its position into Queue for next round of BFS.\\n                }            \\n            }\\n        }\\n        return A;\\n    }\\n```\\n```python\\n    def highestPeak(self, A: List[List[int]]) -> List[List[int]]:\\n        dq, height = deque(), 0\\n        for r, row in enumerate(A):\\n            for c, cell in enumerate(row):\\n                if cell == 1:\\n                    A[r][c] = 0\\n                    dq.append((r, c))\\n                else:\\n                    A[r][c] = -1    \\n        while dq:\\n            r, c = dq.popleft()\\n            for x, y in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if len(A) > x >= 0 <= y < len(A[0]) and A[x][y] < 0:\\n                    A[x][y] = A[r][c] + 1\\n                    dq.append((x, y))\\n        return A\\n```\\n\\n----\\n\\n\\n**Method 2:**\\nIn case you need a version without modifying input array, here it is:\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int[][] highestPeak(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        int[][] heights = new int[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int r = 0; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                if (A[r][c] == 1) { // Water found.\\n                    heights[r][c] = 0; // Set the height to 0.\\n                    q.offer(new int[]{r, c}); // put its position into Queue as one of the starting points of BFS.\\n                }else {\\n                    heights[r][c] = -1; // Mark the land by -1.\\n                }\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            int[] pos = q.poll(); // Current position.\\n            int r = pos[0], c = pos[1];\\n            for (int k = 0; k < 4; ++k) { // Traverse its neighbors.\\n                int x = r + d[k], y = c + d[k + 1];\\n                if (0 <= x && x < m && 0 <= y && y < n && heights[x][y] < 0) { // Found a neighbor land.\\n                    heights[x][y] = heights[r][c] + 1; // Its neighbor height value is at most 1 bigger.\\n                    q.offer(new int[]{x, y}); // put its position into Queue for next round of BFS.\\n                }            \\n            }\\n        }\\n        return heights;\\n    }\\n```\\n\\n```python\\n    def highestPeak(self, A: List[List[int]]) -> List[List[int]]:\\n        m, n = map(len, (A, A[0]))\\n        dq, heights = deque(), [[-1] * n for _ in range(m)]\\n        for r, row in enumerate(A):\\n            for c, cell in enumerate(row):\\n                if cell == 1:\\n                    heights[r][c] = 0\\n                    dq.append((r, c))\\n        while dq:\\n            for _ in range(len(dq)):\\n                r, c = dq.popleft()\\n                for x, y in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                    if m > x >= 0 <= y < n and heights[x][y] < 0:\\n                        heights[x][y] = heights[r][c] + 1\\n                        dq.append((x, y))\\n        return heights\\n```\\n**Analysis:**\\n\\nTime & space: O(m * n).",
                "solutionTags": [],
                "code": "```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int[][] highestPeak(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int r = 0; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                if (A[r][c] == 1) {\\n                    q.offer(new int[]{r, c}); // put its position into Queue as one of the starting points of BFS.\\n                }\\n                --A[r][c]; // Set the height to 0, the land by -1.\\n            }\\n        }\\n        while (!q.isEmpty()) { // BFS starts here.\\n            int[] pos = q.poll(); // Current position.\\n            int r = pos[0], c = pos[1];\\n            for (int k = 0; k < 4; ++k) { // Traverse its neighbors.\\n                int x = r + d[k], y = c + d[k + 1];\\n                if (0 <= x && x < m && 0 <= y && y < n && A[x][y] < 0) {\\n                    A[x][y] = A[r][c] + 1; // assign corresponding height value.\\n                    q.offer(new int[]{x, y}); // put its position into Queue for next round of BFS.\\n                }            \\n            }\\n        }\\n        return A;\\n    }\\n```\n```python\\n    def highestPeak(self, A: List[List[int]]) -> List[List[int]]:\\n        dq, height = deque(), 0\\n        for r, row in enumerate(A):\\n            for c, cell in enumerate(row):\\n                if cell == 1:\\n                    A[r][c] = 0\\n                    dq.append((r, c))\\n                else:\\n                    A[r][c] = -1    \\n        while dq:\\n            r, c = dq.popleft()\\n            for x, y in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if len(A) > x >= 0 <= y < len(A[0]) and A[x][y] < 0:\\n                    A[x][y] = A[r][c] + 1\\n                    dq.append((x, y))\\n        return A\\n```\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int[][] highestPeak(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        int[][] heights = new int[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int r = 0; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                if (A[r][c] == 1) { // Water found.\\n                    heights[r][c] = 0; // Set the height to 0.\\n                    q.offer(new int[]{r, c}); // put its position into Queue as one of the starting points of BFS.\\n                }else {\\n                    heights[r][c] = -1; // Mark the land by -1.\\n                }\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            int[] pos = q.poll(); // Current position.\\n            int r = pos[0], c = pos[1];\\n            for (int k = 0; k < 4; ++k) { // Traverse its neighbors.\\n                int x = r + d[k], y = c + d[k + 1];\\n                if (0 <= x && x < m && 0 <= y && y < n && heights[x][y] < 0) { // Found a neighbor land.\\n                    heights[x][y] = heights[r][c] + 1; // Its neighbor height value is at most 1 bigger.\\n                    q.offer(new int[]{x, y}); // put its position into Queue for next round of BFS.\\n                }            \\n            }\\n        }\\n        return heights;\\n    }\\n```\n```python\\n    def highestPeak(self, A: List[List[int]]) -> List[List[int]]:\\n        m, n = map(len, (A, A[0]))\\n        dq, heights = deque(), [[-1] * n for _ in range(m)]\\n        for r, row in enumerate(A):\\n            for c, cell in enumerate(row):\\n                if cell == 1:\\n                    heights[r][c] = 0\\n                    dq.append((r, c))\\n        while dq:\\n            for _ in range(len(dq)):\\n                r, c = dq.popleft()\\n                for x, y in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                    if m > x >= 0 <= y < n and heights[x][y] < 0:\\n                        heights[x][y] = heights[r][c] + 1\\n                        dq.append((x, y))\\n        return heights\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1429668,
                "title": "c-easy-to-understand-bfs-with-diagrammatic-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/6324a2cf-c61c-4b85-8dbd-03a07563dfee_1630095693.465843.jpeg)\\n\\nSo Here the simple intuition is that we take a 2d answer matrix and initialize all its values to INT_MAX. Then when we find any water block (isWater[i][j] == 1) then i will push those indexes inside the queue and mark the ans[i][j] = 0 as the water block should have height 0. Now my x contains the I index and y will contain the j index values. now we iterate in all 4 directions checking if the position is valid and if ans[xx][yy] (adjacent block) is greater than 1 + ans[x][y] (current block) we want absolute height difference to be at most 1 so we check this condition and update the value and pushing the new block index to the queue so that its adjacent elements get filled up. Lastly, we return the ans vector. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int r = isWater.size();\\n        int c = isWater[0].size();\\n        vector<vector<int>> ans(r,vector<int>(c,INT_MAX));\\n        queue<pair<int,int>> q;\\n        \\n        for(int i = 0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({i,j});\\n                    ans[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            int dx[4] = {0,0,-1,1};\\n            int dy[4] = {-1,1,0,0};\\n            \\n            for(int i = 0;i<4;i++){\\n                int xx = x + dx[i];\\n                int yy = y + dy[i];\\n                \\n                if(xx>=0 && xx<r && yy>=0 && yy<c && ans[xx][yy] > 1 + ans[x][y]){\\n                    ans[xx][yy] = 1 + ans[x][y];\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int r = isWater.size();\\n        int c = isWater[0].size();\\n        vector<vector<int>> ans(r,vector<int>(c,INT_MAX));\\n        queue<pair<int,int>> q;\\n        \\n        for(int i = 0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({i,j});\\n                    ans[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            int dx[4] = {0,0,-1,1};\\n            int dy[4] = {-1,1,0,0};\\n            \\n            for(int i = 0;i<4;i++){\\n                int xx = x + dx[i];\\n                int yy = y + dy[i];\\n                \\n                if(xx>=0 && xx<r && yy>=0 && yy<c && ans[xx][yy] > 1 + ans[x][y]){\\n                    ans[xx][yy] = 1 + ans[x][y];\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143905,
                "title": "java-simple-and-easy-to-understand-solution-using-bfs-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    \\n    static int[][] DIRECTION = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    int rows;\\n    int cols;\\n    int[][] isWater;\\n\\n    \\n    public int[][] highestPeak(int[][] isWater) {\\n        this.isWater = isWater;\\n        rows = isWater.length;\\n        cols = isWater[0].length;\\n        \\n\\n        int[][] heightCells = new int[rows][cols];\\n        \\n        //store the coordinate of water cell\\n        Queue<int[]> queue = new LinkedList();\\n        \\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                if(isWater[r][c] == 1){\\n                    \\n                    //mark as water\\n                    heightCells[r][c] = 0;\\n                    \\n                    //add water coordinate\\n                    queue.add(new int[]{r, c});\\n                } else{\\n                    //mark default value for land\\n                    heightCells[r][c] = -1;  \\n                }\\n            }\\n        }\\n\\n        \\n        /*\\n        * Approach\\n        * 1. start from every water source, \\n             update their neighbor height\\n        * 2. add each neighbours which was not processed earlier\\n          3. do it every cell is processed\\n        */\\n        bfs(queue, heightCells);\\n        \\n        \\n        return heightCells;\\n    }\\n    \\n    private void bfs(Queue<int[]> queue, int[][] heightCells){\\n        \\n        while(!queue.isEmpty()){\\n            int[] cell = queue.remove();\\n \\n            //increment height of neighbor cell in all 4 direction \\n            //e.g, left, right, up, down\\n            for(int[] dir : DIRECTION){\\n                \\n                int newRow = cell[0] + dir[0];\\n                int newCol = cell[1] + dir[1]; \\n                \\n                //check new coordinate of cell inside the grid or not\\n                if(!isInsideGrid(newRow, newCol)) continue;\\n                \\n                //check already handled\\n                if(heightCells[newRow][newCol] != -1) continue;\\n\\n                //increament, \\n                heightCells[newRow][newCol] =  heightCells[cell[0]][cell[1]] + 1;\\n                \\n                //to handle the neighbour of this new cell\\n                queue.add(new int[]{newRow, newCol});\\n            }\\n        \\n        }\\n    }\\n    \\n    private boolean isInsideGrid(int row, int col){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int[][] DIRECTION = new int[][]{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\\n    int rows;\\n    int cols;\\n    int[][] isWater;\\n\\n    \\n    public int[][] highestPeak(int[][] isWater) {\\n        this.isWater = isWater;\\n        rows = isWater.length;\\n        cols = isWater[0].length;\\n        \\n\\n        int[][] heightCells = new int[rows][cols];\\n        \\n        //store the coordinate of water cell\\n        Queue<int[]> queue = new LinkedList();\\n        \\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                if(isWater[r][c] == 1){\\n                    \\n                    //mark as water\\n                    heightCells[r][c] = 0;\\n                    \\n                    //add water coordinate\\n                    queue.add(new int[]{r, c});\\n                } else{\\n                    //mark default value for land\\n                    heightCells[r][c] = -1;  \\n                }\\n            }\\n        }\\n\\n        \\n        /*\\n        * Approach\\n        * 1. start from every water source, \\n             update their neighbor height\\n        * 2. add each neighbours which was not processed earlier\\n          3. do it every cell is processed\\n        */\\n        bfs(queue, heightCells);\\n        \\n        \\n        return heightCells;\\n    }\\n    \\n    private void bfs(Queue<int[]> queue, int[][] heightCells){\\n        \\n        while(!queue.isEmpty()){\\n            int[] cell = queue.remove();\\n \\n            //increment height of neighbor cell in all 4 direction \\n            //e.g, left, right, up, down\\n            for(int[] dir : DIRECTION){\\n                \\n                int newRow = cell[0] + dir[0];\\n                int newCol = cell[1] + dir[1]; \\n                \\n                //check new coordinate of cell inside the grid or not\\n                if(!isInsideGrid(newRow, newCol)) continue;\\n                \\n                //check already handled\\n                if(heightCells[newRow][newCol] != -1) continue;\\n\\n                //increament, \\n                heightCells[newRow][newCol] =  heightCells[cell[0]][cell[1]] + 1;\\n                \\n                //to handle the neighbour of this new cell\\n                queue.add(new int[]{newRow, newCol});\\n            }\\n        \\n        }\\n    }\\n    \\n    private boolean isInsideGrid(int row, int col){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175855,
                "title": "c-bfs-easy-to-understand-o-m-x-n",
                "content": "**Time Complexity: O(M x N)**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int r = isWater.size();\\n        int c = isWater[0].size();\\n        queue <pair<int,int>> curr;\\n        \\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                //set the land cell to -1 (not visited)\\n                if (isWater[i][j] == 0) {\\n                    isWater[i][j] = -1;\\n                }\\n                //set the water cell to zero and to queue\\n                else {\\n                    isWater[i][j] = 0;\\n                    curr.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int hill = 0;\\n        while (!curr.empty()) {\\n            int len = curr.size();\\n            \\n            for (int k = 0; k < len; k++) {\\n                \\n                //for each cell check its 4 boundary cells\\n                //if it is not visited, increase its hill by 1\\n                pair <int, int> fnt = curr.front(); curr.pop();\\n                int i = fnt.first, j = fnt.second;\\n                \\n                //top cell\\n                if (i > 0 && isWater[i - 1][j] == -1) {\\n                    isWater[i - 1][j] = hill + 1;\\n                    curr.push({i-1, j});\\n                }\\n                //bottom cell\\n                if ((i < r - 1) && (isWater[i + 1][j] == -1)) {\\n                    isWater[i + 1][j] = hill + 1;\\n                    curr.push({i+1, j});\\n                }\\n                //left cell\\n                if (j > 0 && (isWater[i][j - 1] == -1)) {\\n                    isWater[i][j - 1] = hill + 1;\\n                    curr.push({i, j-1});\\n                }\\n                //right cell\\n                if ((j < c - 1) && (isWater[i][j + 1] == -1)) {\\n                    isWater[i][j + 1] = hill + 1;\\n                    curr.push({i, j+1});\\n                }\\n            }\\n            \\n            //after 1 complete round increase the height of the hill\\n            hill += 1;\\n        }\\n        \\n        return isWater;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int r = isWater.size();\\n        int c = isWater[0].size();\\n        queue <pair<int,int>> curr;\\n        \\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                //set the land cell to -1 (not visited)\\n                if (isWater[i][j] == 0) {\\n                    isWater[i][j] = -1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2993862,
                "title": "java-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n    int[][] result = new int[isWater.length][isWater[0].length];\\n\\n    Queue<int[]> cells = findWaterCells(isWater, result);\\n    return bfs(cells, result);\\n  }\\n\\n  private Queue<int[]> findWaterCells(int[][] isWater, int[][] result) {\\n    Queue<int[]> cells = new LinkedList<>();\\n    for (int row = 0; row < isWater.length; ++row) {\\n      for (int column = 0; column < isWater[0].length; ++column) {\\n        if (isWater[row][column] == 1)\\n          cells.offer(new int[]{row, column});\\n        else\\n          result[row][column] = -1;\\n      }\\n    }\\n    return cells;\\n  }\\n\\n  private int[][] bfs(Queue<int[]> cells, int[][] result) {\\n    int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    while (!cells.isEmpty()) {\\n      int[] cell = cells.poll();\\n      int row = cell[0], column = cell[1];\\n\\n      for (int[] direction : directions) {\\n        int newRow = row + direction[0], newColumn = column + direction[1];\\n        if (newRow < 0 || newRow >= result.length\\n          || newColumn < 0 || newColumn >= result[0].length\\n          || result[newRow][newColumn] != -1)\\n          continue;\\n\\n        result[newRow][newColumn] = result[row][column] + 1;\\n        cells.offer(new int[]{newRow, newColumn});\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n    int[][] result = new int[isWater.length][isWater[0].length];\\n\\n    Queue<int[]> cells = findWaterCells(isWater, result);\\n    return bfs(cells, result);\\n  }\\n\\n  private Queue<int[]> findWaterCells(int[][] isWater, int[][] result) {\\n    Queue<int[]> cells = new LinkedList<>();\\n    for (int row = 0; row < isWater.length; ++row) {\\n      for (int column = 0; column < isWater[0].length; ++column) {\\n        if (isWater[row][column] == 1)\\n          cells.offer(new int[]{row, column});\\n        else\\n          result[row][column] = -1;\\n      }\\n    }\\n    return cells;\\n  }\\n\\n  private int[][] bfs(Queue<int[]> cells, int[][] result) {\\n    int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    while (!cells.isEmpty()) {\\n      int[] cell = cells.poll();\\n      int row = cell[0], column = cell[1];\\n\\n      for (int[] direction : directions) {\\n        int newRow = row + direction[0], newColumn = column + direction[1];\\n        if (newRow < 0 || newRow >= result.length\\n          || newColumn < 0 || newColumn >= result[0].length\\n          || result[newRow][newColumn] != -1)\\n          continue;\\n\\n        result[newRow][newColumn] = result[row][column] + 1;\\n        cells.offer(new int[]{newRow, newColumn});\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087748,
                "title": "java-bfs-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int[][] mat = new int[n][m];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n             Arrays.fill(mat[i], -1);\\n            for (int j = 0; j < m; j++) {\\n               \\n                if (isWater[i][j] == 1) {\\n                    mat[i][j] = 0;\\n                    queue.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            for (int[] dir : dirs) {\\n                int x = cur[0] + dir[0];\\n                int y = cur[1] + dir[1];\\n                if (x < 0 || y < 0 || x >= n || y >= m || mat[x][y] != -1) continue;\\n                mat[x][y] = mat[cur[0]][cur[1]] + 1;\\n                queue.add(new int[]{x, y});\\n            }\\n        }\\n        return mat;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n        int[][] dirs = {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1074745,
                "title": "python-bfs-with-demo-figures-and-some-similar-problems-to-practice",
                "content": "The main idea is starting from water (1) and BFS entire the matrix.\\n1. Find and flip all 1, and store its position to a queue. We also use a set to store visited position.\\n \\n![image](https://assets.leetcode.com/users/images/637cf5d1-f2bf-4e32-b269-417b93a143ce_1613840238.5843472.png)\\n\\n\\n2. BFS: Pop current position: (cur_x, cur_y) from queue then move to 4 directions [Down, Up, Right, Left] to new position: (new_x, new_y), if it has not visited yet, isWater(new) = isWater(cur) + 1\\n\\n![image](https://assets.leetcode.com/users/images/7234a3fe-81e5-4d81-b38e-96d1a588847f_1613841112.574654.png)\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        rows, cols = len(isWater), len(isWater[0])        \\n        visited = set()\\n        queue = deque()\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if isWater[r][c] == 1:\\n                    isWater[r][c] = 0\\n                    visited.add((r, c))\\n                    queue.append((r, c))\\n                     \\n        while queue:\\n            cur_x, cur_y = queue.popleft()\\n            print(cur_x, cur_y)\\n            for dirr in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                new_x, new_y = cur_x + dirr[0], cur_y + dirr[1]\\n                \\n                if 0 <= new_x <= rows - 1 and 0 <= new_y <= cols - 1 and (new_x, new_y) not in visited:                        \\n                        isWater[new_x][new_y] = isWater[cur_x][cur_y] + 1\\n                        visited.add((new_x, new_y))\\n                        queue.append((new_x, new_y))\\n                        \\n        return isWater\\n```\\n\\nPractice problems: \\nhttps://leetcode.com/problems/01-matrix/\\nhttps://leetcode.com/problems/as-far-from-land-as-possible/\\nhttps://leetcode.com/problems/rotting-oranges/\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        rows, cols = len(isWater), len(isWater[0])        \\n        visited = set()\\n        queue = deque()\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if isWater[r][c] == 1:\\n                    isWater[r][c] = 0\\n                    visited.add((r, c))\\n                    queue.append((r, c))\\n                     \\n        while queue:\\n            cur_x, cur_y = queue.popleft()\\n            print(cur_x, cur_y)\\n            for dirr in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                new_x, new_y = cur_x + dirr[0], cur_y + dirr[1]\\n                \\n                if 0 <= new_x <= rows - 1 and 0 <= new_y <= cols - 1 and (new_x, new_y) not in visited:                        \\n                        isWater[new_x][new_y] = isWater[cur_x][cur_y] + 1\\n                        visited.add((new_x, new_y))\\n                        queue.append((new_x, new_y))\\n                        \\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074542,
                "title": "c-bfs-detailed-explanation-similar-problems",
                "content": "almost identical problem:\\n[994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)\\n\\nMain idea:\\n1. Push coordinates `{i, j}` to `queue` where `isWater[i][j] = 1`, basically having a queue of water coordinates. Do this for every (i,j)\\n2. `BFS` every water coordinate\\'s adjacent neighbor, while incrementing `height` for every `queue size` (just like level order traversal for trees)\\n3. Only update height in matrix and push to queue if height can be smaller \\n```\\n    if(height < isWater[r][c]) {\\n        isWater[r][c] = height;\\n        q.push({r,c});\\n    }\\n  ```\\n\\nCode:\\n```\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size(), dir[5] = {0, 1, 0, -1, 0}, INF = 1e6+1;\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(isWater[i][j]) {\\n                    isWater[i][j]=0;\\n                    q.push({i, j});\\n                } else {\\n                    isWater[i][j]=INF;\\n                }\\n            }\\n        }\\n        int height = 1;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                auto cur = q.front(); q.pop();\\n                for(int i=0; i<4; i++) {\\n                    int r = cur.first + dir[i], c = cur.second + dir[i+1];\\n                    if(r < 0 || c < 0 || r >= m || c >= n) {\\n                        continue;\\n                    }\\n                    if(height < isWater[r][c]) {\\n                        isWater[r][c] = height;\\n                        q.push({r,c});\\n                    }\\n                }\\n            }\\n            height++;\\n        }\\n        return isWater;\\n    }\\n```\\n\\nTime Complexity:\\n`O(M * N * (M + N))`",
                "solutionTags": [],
                "code": "```\\n    if(height < isWater[r][c]) {\\n        isWater[r][c] = height;\\n        q.push({r,c});\\n    }\\n  ```\n```\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size(), dir[5] = {0, 1, 0, -1, 0}, INF = 1e6+1;\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(isWater[i][j]) {\\n                    isWater[i][j]=0;\\n                    q.push({i, j});\\n                } else {\\n                    isWater[i][j]=INF;\\n                }\\n            }\\n        }\\n        int height = 1;\\n        while(!q.empty()) {\\n            int size = q.size();\\n            while(size--) {\\n                auto cur = q.front(); q.pop();\\n                for(int i=0; i<4; i++) {\\n                    int r = cur.first + dir[i], c = cur.second + dir[i+1];\\n                    if(r < 0 || c < 0 || r >= m || c >= n) {\\n                        continue;\\n                    }\\n                    if(height < isWater[r][c]) {\\n                        isWater[r][c] = height;\\n                        q.push({r,c});\\n                    }\\n                }\\n            }\\n            height++;\\n        }\\n        return isWater;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074561,
                "title": "python3-bfs",
                "content": "\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m, n = len(isWater), len(isWater[0]) # dimensions \\n        queue = [(i, j) for i in range(m) for j in range(n) if isWater[i][j]]\\n        \\n        ht = 0\\n        ans = [[0]*n for _ in range(m)]\\n        seen = set(queue)\\n        \\n        while queue: \\n            newq = []\\n            for i, j in queue: \\n                ans[i][j] = ht\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: \\n                        newq.append((ii, jj))\\n                        seen.add((ii, jj))\\n            queue = newq\\n            ht += 1\\n        return ans \\n```\\n\\nAlternative implementation\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m, n = len(isWater), len(isWater[0]) # dimensions \\n        \\n        ans = [[-1]*n for _ in range(m)]\\n        queue = deque()\\n        for i in range(m): \\n            for j in range(n):\\n                if isWater[i][j]:\\n                    queue.append((i, j))\\n                    ans[i][j] = 0\\n\\n        while queue: \\n            i, j = queue.popleft()\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and ans[ii][jj] == -1: \\n                    ans[ii][jj] = 1 + ans[i][j]\\n                    queue.append((ii, jj))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m, n = len(isWater), len(isWater[0]) # dimensions \\n        queue = [(i, j) for i in range(m) for j in range(n) if isWater[i][j]]\\n        \\n        ht = 0\\n        ans = [[0]*n for _ in range(m)]\\n        seen = set(queue)\\n        \\n        while queue: \\n            newq = []\\n            for i, j in queue: \\n                ans[i][j] = ht\\n                for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen: \\n                        newq.append((ii, jj))\\n                        seen.add((ii, jj))\\n            queue = newq\\n            ht += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m, n = len(isWater), len(isWater[0]) # dimensions \\n        \\n        ans = [[-1]*n for _ in range(m)]\\n        queue = deque()\\n        for i in range(m): \\n            for j in range(n):\\n                if isWater[i][j]:\\n                    queue.append((i, j))\\n                    ans[i][j] = 0\\n\\n        while queue: \\n            i, j = queue.popleft()\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and ans[ii][jj] == -1: \\n                    ans[ii][jj] = 1 + ans[i][j]\\n                    queue.append((ii, jj))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442614,
                "title": "python-3-greedy-multi-source-bfs-explanation",
                "content": "### Explanation\\n- Start from *water* nodes and BFS until all heights are found\\n- NOTE: You don\\'t need to worry about getting a skewed peak (by *skewed*, I mean a height with difference greater than 1 on some neighbors), because it will never be possible\\n\\t- For example: following situation will never be possible\\n\\t\\t```\\n\\t\\t1 2\\n\\t\\t1 0\\n\\t\\t```\\n\\t- This is because we are using BFS and increment at 1 for each step, in this case, for any node at `(i, j)`, whenever the value is assigned, it will be the highest possible value\\n\\t- If the same node is re-visited in later step, it can only be the same or larger (larger will be wrong, since you will get a skewed peak), thus, no need to revisited any assigned node `(i, j)`\\n### Implementation\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        arr = collections.deque()\\n        m, n = len(isWater), len(isWater[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    arr.append((0, i, j))\\n                    \\n        ans = [[-1] * n for _ in range(m)]\\n        while arr:\\n            val, x, y = arr.popleft() \\n            if ans[x][y] != -1: continue\\n            ans[x][y] = val\\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                xx, yy = x+dx, y+dy\\n                if 0 <= xx < m and 0 <= yy < n and ans[xx][yy] == -1:\\n                    arr.append((val+1, xx, yy))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\n\\t\\t1 2\\n\\t\\t1 0\\n\\t\\t```\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        arr = collections.deque()\\n        m, n = len(isWater), len(isWater[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    arr.append((0, i, j))\\n                    \\n        ans = [[-1] * n for _ in range(m)]\\n        while arr:\\n            val, x, y = arr.popleft() \\n            if ans[x][y] != -1: continue\\n            ans[x][y] = val\\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                xx, yy = x+dx, y+dy\\n                if 0 <= xx < m and 0 <= yy < n and ans[xx][yy] == -1:\\n                    arr.append((val+1, xx, yy))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074543,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\n    bool safe(int newX, int newY, int m, int n) {\\n        return newX >= 0 && newX < m && newY >= 0 && newY < n;\\n    }\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<pair<int, int>> dirs = {\\n            {-1, 0},\\n            {0, 1},\\n            {1, 0},\\n            {0, -1}\\n        };\\n        \\n        queue<pair<int, int>> q;\\n        int m = isWater.size();\\n        int n = isWater[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    isWater[i][j] = 0;\\n                    visited[i][j] = true;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            pair<int, int> topVal = q.front();\\n            q.pop();\\n            int x = topVal.first, y = topVal.second;\\n            visited[x][y] = true;\\n            for (auto& dir : dirs) {\\n                int newX = x + dir.first;\\n                int newY = y + dir.second;\\n                if (safe(newX, newY, m, n) && !visited[newX][newY]) {\\n                    isWater[newX][newY] = isWater[x][y] + 1;\\n                    visited[newX][newY] = true;\\n                    q.push({newX, newY});\\n                }   \\n            }\\n        }\\n        \\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool safe(int newX, int newY, int m, int n) {\\n        return newX >= 0 && newX < m && newY >= 0 && newY < n;\\n    }\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<pair<int, int>> dirs = {\\n            {-1, 0},\\n            {0, 1},\\n            {1, 0},\\n            {0, -1}\\n        };\\n        \\n        queue<pair<int, int>> q;\\n        int m = isWater.size();\\n        int n = isWater[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    isWater[i][j] = 0;\\n                    visited[i][j] = true;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        while (!q.empty()) {\\n            pair<int, int> topVal = q.front();\\n            q.pop();\\n            int x = topVal.first, y = topVal.second;\\n            visited[x][y] = true;\\n            for (auto& dir : dirs) {\\n                int newX = x + dir.first;\\n                int newY = y + dir.second;\\n                if (safe(newX, newY, m, n) && !visited[newX][newY]) {\\n                    isWater[newX][newY] = isWater[x][y] + 1;\\n                    visited[newX][newY] = true;\\n                    q.push({newX, newY});\\n                }   \\n            }\\n        }\\n        \\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075724,
                "title": "c-bfs-solution",
                "content": "* Because **any two adjacent cells must have an absolute height difference of at most 1**, we can apply level order traversal (BFS).\\n* We will first **push indices of water cells** in the queue.\\n* Then while queue is not empty we will pop out cell one by one and **push all neighbour cells** which are not visited in the queue.\\n* We will simply store **level** of each cell in our ans vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size();\\n        int n=isWater[0].size();\\n\\t\\t// 4 Directions\\n        vector <int> dirs={0,-1,0,1,0};\\n\\t\\t// Queue to store cell\\'s row and column information\\n        queue <pair<int,int>> q;\\n\\t\\t// Ans\\n        vector <vector <int>> ans(m,vector <int>(n,0));\\n\\t\\t\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n\\t\\t\\t// push all water cell in queue\\n                if(isWater[i][j]==1)\\n                    q.push({i,j});\\n            }\\n        }\\n\\t\\t// level\\n        int l=0;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            while(s--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n\\t\\t\\t\\t// strore level in each cell\\n                ans[p.first][p.second]=l;\\n                for(int k=1;k<5;k++)\\n                {\\n                    int i=p.first+dirs[k-1];\\n                    int j=p.second+dirs[k];\\n                    if(i>=0&&j>=0&&i<m&&j<n&&isWater[i][j]==0)\\n                    {\\n\\t\\t\\t\\t\\t//push cell and make it visited\\n                        q.push({i,j});\\n                        isWater[i][j]=1;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size();\\n        int n=isWater[0].size();\\n\\t\\t// 4 Directions\\n        vector <int> dirs={0,-1,0,1,0};\\n\\t\\t// Queue to store cell\\'s row and column information\\n        queue <pair<int,int>> q;\\n\\t\\t// Ans\\n        vector <vector <int>> ans(m,vector <int>(n,0));\\n\\t\\t\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n\\t\\t\\t// push all water cell in queue\\n                if(isWater[i][j]==1)\\n                    q.push({i,j});\\n            }\\n        }\\n\\t\\t// level\\n        int l=0;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            while(s--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n\\t\\t\\t\\t// strore level in each cell\\n                ans[p.first][p.second]=l;\\n                for(int k=1;k<5;k++)\\n                {\\n                    int i=p.first+dirs[k-1];\\n                    int j=p.second+dirs[k];\\n                    if(i>=0&&j>=0&&i<m&&j<n&&isWater[i][j]==0)\\n                    {\\n\\t\\t\\t\\t\\t//push cell and make it visited\\n                        q.push({i,j});\\n                        isWater[i][j]=1;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503490,
                "title": "greedy-bfs-well-explained",
                "content": "## IDEA:\\n*Start from water nodes and BFS until all heights are found*\\nNOTE: **You don\\'t need to worry about height with difference greater than 1 on some neighbors because it will never be possible**\\n* For example: following situation will never be possible\\n1 1 0\\n1 1 2\\n2 0 1\\n* This is because we are using BFS and increment at 1 for each step, in this case, for any node at (i, j), whenever the value is assigned, it will be the highest possible value\\n* If the same node is re-visited in later step, it can only be the same or larger (larger will be wrong, since you will get a skewed peak), thus, no need to revisited any assigned node (i, j).\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        m,n = len(isWater),len(isWater[0])\\n        q = collections.deque()\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]==1:\\n                    dp[i][j] = 0\\n                    q.append([i,j,0])\\n        \\n        while q:\\n            x,y,c = q.popleft()\\n            for i,j in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                if 0<=x+i<m and 0<=y+j<n and dp[x+i][y+j]==float(\\'inf\\'):\\n                    dp[x+i][y+j] = c+1\\n                    q.append([x+i,y+j,c+1])\\n            \\n        return dp\\n\\n### Thanks & Upvote if you got the idea!!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "## IDEA:\\n*Start from water nodes and BFS until all heights are found*\\nNOTE: **You don\\'t need to worry about height with difference greater than 1 on some neighbors because it will never be possible**\\n* For example: following situation will never be possible\\n1 1 0\\n1 1 2\\n2 0 1\\n* This is because we are using BFS and increment at 1 for each step, in this case, for any node at (i, j), whenever the value is assigned, it will be the highest possible value\\n* If the same node is re-visited in later step, it can only be the same or larger (larger will be wrong, since you will get a skewed peak), thus, no need to revisited any assigned node (i, j).\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        m,n = len(isWater),len(isWater[0])\\n        q = collections.deque()\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]==1:\\n                    dp[i][j] = 0\\n                    q.append([i,j,0])\\n        \\n        while q:\\n            x,y,c = q.popleft()\\n            for i,j in [(-1,0),(1,0),(0,1),(0,-1)]:\\n                if 0<=x+i<m and 0<=y+j<n and dp[x+i][y+j]==float(\\'inf\\'):\\n                    dp[x+i][y+j] = c+1\\n                    q.append([x+i,y+j,c+1])\\n            \\n        return dp\\n\\n### Thanks & Upvote if you got the idea!!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1074614,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int row = isWater.length;\\n        int col = isWater[0].length;\\n        int[][] ans = new int[row][col];\\n        \\n        Queue<int[]> q = new LinkedList();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans[i][j] = Integer.MAX_VALUE;\\n                if (isWater[i][j] == 1) {\\n                    q.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        int dist = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                int[] val = q.remove();\\n                int r = val[0];\\n                int c = val[1];\\n                if (r < 0 || r >= row || c < 0 || c >= col || ans[r][c] != Integer.MAX_VALUE || ans[r][c] < dist) continue;\\n                ans[r][c] = dist;\\n                q.add(new int[]{r + 1, c});\\n                q.add(new int[]{r -1, c});\\n                q.add(new int[]{r, c + 1});\\n                q.add(new int[]{r, c - 1});\\n            }\\n            dist++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int row = isWater.length;\\n        int col = isWater[0].length;\\n        int[][] ans = new int[row][col];\\n        \\n        Queue<int[]> q = new LinkedList();\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans[i][j] = Integer.MAX_VALUE;\\n                if (isWater[i][j] == 1) {\\n                    q.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        int dist = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                int[] val = q.remove();\\n                int r = val[0];\\n                int c = val[1];\\n                if (r < 0 || r >= row || c < 0 || c >= col || ans[r][c] != Integer.MAX_VALUE || ans[r][c] < dist) continue;\\n                ans[r][c] = dist;\\n                q.add(new int[]{r + 1, c});\\n                q.add(new int[]{r -1, c});\\n                q.add(new int[]{r, c + 1});\\n                q.add(new int[]{r, c - 1});\\n            }\\n            dist++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074610,
                "title": "python-3-simple-bfs",
                "content": "The idea is to start BFS *from each water cell* at the same time. At every step, increase the height by 1 until **all cells have been visited**.\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        arr, visited = deque([]), set()\\n        m, n = len(isWater), len(isWater[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    arr.append((i, j, 0))\\n                    visited.add((i, j))\\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        while arr:\\n            size = len(arr)\\n            for _ in range(size):\\n                i, j, height = arr.popleft()\\n                for x, y in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:\\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        arr.append((x, y, height + 1))\\n                        res[x][y] = height + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        arr, visited = deque([]), set()\\n        m, n = len(isWater), len(isWater[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    arr.append((i, j, 0))\\n                    visited.add((i, j))\\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        while arr:\\n            size = len(arr)\\n            for _ in range(size):\\n                i, j, height = arr.popleft()\\n                for x, y in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:\\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in visited:\\n                        visited.add((x, y))\\n                        arr.append((x, y, height + 1))\\n                        res[x][y] = height + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074592,
                "title": "c-parallel-bfs-solution",
                "content": "```\\nint rowDelta[] = { 0, +1, 0, -1 };\\nint colDelta[] = { +1, 0, -1, 0 };\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater)\\n    {\\n        int R = isWater.size();\\n        int C = isWater[0].size();\\n                \\n        queue<pair<int, int>> q;\\n        \\n        for (int r = 0; r < R; ++r)\\n            for (int c = 0; c < C; ++c)\\n                if (isWater[r][c] == 1)\\n                    isWater[r][c] = 0,\\n                    q.push({ r, c });   // add as a starting point\\n                else\\n                    isWater[r][c] = -1; // mark unvisited\\n        \\n        while (q.size() > 0)\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            \\n            for (int d = 0; d < 4; ++d)\\n            {\\n                int nr = r + rowDelta[d];\\n                int nc = c + colDelta[d];\\n                \\n                if (nr < 0 ||\\n                    nr == R ||\\n                    nc < 0 ||\\n                    nc == C ||\\n                    isWater[nr][nc] != -1)\\n                        continue;\\n                \\n                isWater[nr][nc] = isWater[r][c] + 1;\\n                q.push({ nr, nc });\\n            }\\n        }\\n        \\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint rowDelta[] = { 0, +1, 0, -1 };\\nint colDelta[] = { +1, 0, -1, 0 };\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater)\\n    {\\n        int R = isWater.size();\\n        int C = isWater[0].size();\\n                \\n        queue<pair<int, int>> q;\\n        \\n        for (int r = 0; r < R; ++r)\\n            for (int c = 0; c < C; ++c)\\n                if (isWater[r][c] == 1)\\n                    isWater[r][c] = 0,\\n                    q.push({ r, c });   // add as a starting point\\n                else\\n                    isWater[r][c] = -1; // mark unvisited\\n        \\n        while (q.size() > 0)\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            \\n            for (int d = 0; d < 4; ++d)\\n            {\\n                int nr = r + rowDelta[d];\\n                int nc = c + colDelta[d];\\n                \\n                if (nr < 0 ||\\n                    nr == R ||\\n                    nc < 0 ||\\n                    nc == C ||\\n                    isWater[nr][nc] != -1)\\n                        continue;\\n                \\n                isWater[nr][nc] = isWater[r][c] + 1;\\n                q.push({ nr, nc });\\n            }\\n        }\\n        \\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788650,
                "title": "very-easy-and-intuitive-solution-multi-source-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npush all the water cell initially on the queue and perform bfs from those cell\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size();\\n\\n        vector<vector<int>> heights(m, vector<int>(n, 0));\\n\\n        queue<pair<int ,int>> q;\\n\\n\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    q.push({i, j});\\n                    isWater[i][j] = 0;\\n                }\\n                else isWater[i][j] = -1;\\n            }\\n        }\\n\\n        int dr[] = {1, -1, 0, 0};\\n\\t\\tint dc[] = {0, 0, -1, 1};\\n        int h = 1;\\n        \\n        while(!q.empty()) {\\n            \\n            int l = q.size();\\n\\n            for (int i=0; i<l; i++) {\\n\\n                auto p = q.front(); q.pop();\\n                int u = p.first, v = p.second;\\n\\n                for (int k = 0; k<4; k++) {\\n                    int r = u + dr[k];\\n                    int c = v + dc[k];\\n\\n                    if (r >= 0 && r < m && c >=0 && c < n && isWater[r][c] == -1) {\\n                        isWater[r][c] = h;\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            h++;\\n        }\\n\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size();\\n\\n        vector<vector<int>> heights(m, vector<int>(n, 0));\\n\\n        queue<pair<int ,int>> q;\\n\\n\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    q.push({i, j});\\n                    isWater[i][j] = 0;\\n                }\\n                else isWater[i][j] = -1;\\n            }\\n        }\\n\\n        int dr[] = {1, -1, 0, 0};\\n\\t\\tint dc[] = {0, 0, -1, 1};\\n        int h = 1;\\n        \\n        while(!q.empty()) {\\n            \\n            int l = q.size();\\n\\n            for (int i=0; i<l; i++) {\\n\\n                auto p = q.front(); q.pop();\\n                int u = p.first, v = p.second;\\n\\n                for (int k = 0; k<4; k++) {\\n                    int r = u + dr[k];\\n                    int c = v + dc[k];\\n\\n                    if (r >= 0 && r < m && c >=0 && c < n && isWater[r][c] == -1) {\\n                        isWater[r][c] = h;\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            h++;\\n        }\\n\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228971,
                "title": "c-dp-100-faster-and-100-less-space-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>&a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-1000));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]==1)\\n                    dp[i][j]=0;\\n                else\\n                {\\n                    if(i>0)\\n                        dp[i][j]=min(dp[i][j],dp[i-1][j]+1);\\n                    if(j>0)\\n                        dp[i][j]=min(dp[i][j],dp[i][j-1]+1);\\n                }\\n            }\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(i<n-1)\\n                   dp[i][j]=min(dp[i][j],dp[i+1][j]+1); \\n                if(j<m-1)\\n                   dp[i][j]=min(dp[i][j],dp[i][j+1]+1);\\n            }\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>&a) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-1000));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[i][j]==1)\\n                    dp[i][j]=0;\\n                else\\n                {\\n                    if(i>0)\\n                        dp[i][j]=min(dp[i][j],dp[i-1][j]+1);\\n                    if(j>0)\\n                        dp[i][j]=min(dp[i][j],dp[i][j-1]+1);\\n                }\\n            }\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(i<n-1)\\n                   dp[i][j]=min(dp[i][j],dp[i+1][j]+1); \\n                if(j<m-1)\\n                   dp[i][j]=min(dp[i][j],dp[i][j+1]+1);\\n            }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513071,
                "title": "simple-bfs-solution-in-cpp",
                "content": "```\\n#define vv vector<vector<int>>\\n#define v vector<int>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        int m=isWater.size(),n=isWater[0].size();\\n        vv ans(m,v(n)),vis(m,v(n));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(isWater[i][j]){\\n                    ans[i][j]=0;\\n                    q.push({i,j});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n        v row={-1,1,0,0};\\n        v col={0,0,-1,1};\\n        \\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            int i=ele.first,j=ele.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int r=row[k]+i,c=col[k]+j;\\n                if(r>=0 && c>=0 && r<m && c<n && !vis[r][c] && isWater[r][c]==0){\\n                    ans[r][c]=1+ans[r-row[k]][c-col[k]];\\n                    q.push({r,c});\\n                    vis[r][c]=1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        int m=isWater.size(),n=isWater[0].size();\\n        vv ans(m,v(n)),vis(m,v(n));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(isWater[i][j]){\\n                    ans[i][j]=0;\\n                    q.push({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1564079,
                "title": "java-clean-bfs",
                "content": "```\\nclass Solution {\\n\\n    int[][] nexts=new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n    public int[][] highestPeak(int[][] isWater) {\\n        \\n        int m=isWater.length;\\n        int n=isWater[0].length;\\n        \\n        boolean[][] visited=new boolean[m][n];\\n        Queue<int[]> q=new LinkedList<>();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++) {\\n\\n                if(isWater[i][j]==0) continue;    \\n\\n                q.add(new int[]{i,j});\\n                visited[i][j]=true;\\n                isWater[i][j]=0;\\n\\n            }\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            \\n            int[] cell=q.poll();\\n            int r=cell[0], c=cell[1], val=isWater[r][c];\\n            \\n            for(int[] next:nexts) {\\n\\n                int x=r+next[0];\\n                int y=c+next[1];\\n                \\n                if(!isValid(x,y,m,n) || visited[x][y]) continue;\\n                \\n                isWater[x][y]=val+1;\\n                visited[x][y]=true;\\n                q.add(new int[]{x,y});\\n            }\\n            \\n        }\\n        \\n        return isWater;\\n        \\n    }\\n    \\n    boolean isValid(int r, int c, int m, int n) {\\n        return r>=0 && r<m && c>=0 && c<n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int[][] nexts=new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n    public int[][] highestPeak(int[][] isWater) {\\n        \\n        int m=isWater.length;\\n        int n=isWater[0].length;\\n        \\n        boolean[][] visited=new boolean[m][n];\\n        Queue<int[]> q=new LinkedList<>();\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++) {\\n\\n                if(isWater[i][j]==0) continue;    \\n\\n                q.add(new int[]{i,j});\\n                visited[i][j]=true;\\n                isWater[i][j]=0;\\n\\n            }\\n        }\\n        \\n        while(!q.isEmpty()) {\\n            \\n            int[] cell=q.poll();\\n            int r=cell[0], c=cell[1], val=isWater[r][c];\\n            \\n            for(int[] next:nexts) {\\n\\n                int x=r+next[0];\\n                int y=c+next[1];\\n                \\n                if(!isValid(x,y,m,n) || visited[x][y]) continue;\\n                \\n                isWater[x][y]=val+1;\\n                visited[x][y]=true;\\n                q.add(new int[]{x,y});\\n            }\\n            \\n        }\\n        \\n        return isWater;\\n        \\n    }\\n    \\n    boolean isValid(int r, int c, int m, int n) {\\n        return r>=0 && r<m && c>=0 && c<n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316019,
                "title": "easy-c-bfs-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        //push all the indices which have water to queue\\n        //now pop out cell from queue and assign the adjacent cells with a height value greater by 1\\n        queue<pair<int,int>> q;\\n        int currHeight=1;\\n        vector<vector<int>> offsets={{1,0},{0,1},{-1,0},{0,-1}};\\n        \\n        int m=isWater.size();\\n        int n=isWater[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                    //it has water\\n                    q.push({i,j});\\n                    res[i][j]=0;\\n                }\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int len=q.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                auto [x,y] = q.front();\\n                q.pop();\\n                //assign every adjacent cell with the currHeight;\\n                for(int j=0;j<4;j++)\\n                {\\n                    int X=x+offsets[j][0];\\n                    int Y=y+offsets[j][1];\\n                    if(X<0 || Y<0 || X>=m || Y>=n || res[X][Y]!=-1)\\n                        continue;\\n                    res[X][Y]=currHeight;\\n                    q.push({X,Y});\\n                }\\n            }\\n            currHeight++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        //push all the indices which have water to queue\\n        //now pop out cell from queue and assign the adjacent cells with a height value greater by 1\\n        queue<pair<int,int>> q;\\n        int currHeight=1;\\n        vector<vector<int>> offsets={{1,0},{0,1},{-1,0},{0,-1}};\\n        \\n        int m=isWater.size();\\n        int n=isWater[0].size();\\n        vector<vector<int>> res(m,vector<int>(n,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                    //it has water\\n                    q.push({i,j});\\n                    res[i][j]=0;\\n                }\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int len=q.size();\\n            for(int i=0;i<len;i++)\\n            {\\n                auto [x,y] = q.front();\\n                q.pop();\\n                //assign every adjacent cell with the currHeight;\\n                for(int j=0;j<4;j++)\\n                {\\n                    int X=x+offsets[j][0];\\n                    int Y=y+offsets[j][1];\\n                    if(X<0 || Y<0 || X>=m || Y>=n || res[X][Y]!=-1)\\n                        continue;\\n                    res[X][Y]=currHeight;\\n                    q.push({X,Y});\\n                }\\n            }\\n            currHeight++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229071,
                "title": "java-solution-using-bfs-queue",
                "content": "```\\nclass Solution {\\n    \\n    public int[][] highestPeak(int[][] isWater) {\\n        int row = isWater.length;\\n        int col = isWater[0].length;\\n        int [][] ans = new int[row][col];\\n        Queue<Pair<Integer , Integer>> q = new LinkedList<>(); // queue of pair to store index \\n        for(int i=0;i<row ;i++){\\n            for(int j=0;j<col ;j++){\\n                if(isWater[i][j] == 1){\\n                    ans[i][j] =0;\\n                    q.offer(new Pair(i , j));\\n                }else{\\n                    ans[i][j]= -1;\\n                }\\n            }\\n        }\\n        int[] dir = new int[] {0,1,0,-1,0}; \\n        while(q.size()>0){\\n            Pair<Integer , Integer> p = q.poll();\\n            int cr = p.getKey() ; //cr represent current_row\\n            int cc = p.getValue(); // cc represent current_column\\n            \\n            for(int i=0;i<4 ;i++){\\n                int ncr = cr+dir[i]; int ncc = cc+dir[i+1]; // ncr -> new current row , ncc -> new current column\\n                if(ncr<0 || ncr>=row || ncc<0 || ncc>= col || ans[ncr][ncc] != -1){\\n                    continue;\\n                }\\n                ans[ncr][ncc] = 1+ ans[cr][cc];\\n                q.offer(new Pair(ncr , ncc));\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] highestPeak(int[][] isWater) {\\n        int row = isWater.length;\\n        int col = isWater[0].length;\\n        int [][] ans = new int[row][col];\\n        Queue<Pair<Integer , Integer>> q = new LinkedList<>(); // queue of pair to store index \\n        for(int i=0;i<row ;i++){\\n            for(int j=0;j<col ;j++){\\n                if(isWater[i][j] == 1){\\n                    ans[i][j] =0;\\n                    q.offer(new Pair(i , j));\\n                }else{\\n                    ans[i][j]= -1;\\n                }\\n            }\\n        }\\n        int[] dir = new int[] {0,1,0,-1,0}; \\n        while(q.size()>0){\\n            Pair<Integer , Integer> p = q.poll();\\n            int cr = p.getKey() ; //cr represent current_row\\n            int cc = p.getValue(); // cc represent current_column\\n            \\n            for(int i=0;i<4 ;i++){\\n                int ncr = cr+dir[i]; int ncc = cc+dir[i+1]; // ncr -> new current row , ncc -> new current column\\n                if(ncr<0 || ncr>=row || ncc<0 || ncc>= col || ans[ncr][ncc] != -1){\\n                    continue;\\n                }\\n                ans[ncr][ncc] = 1+ ans[cr][cc];\\n                q.offer(new Pair(ncr , ncc));\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117300,
                "title": "easiest-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    //bfs\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<vector<int>> ans(isWater.size(),vector<int>(isWater[0].size(),-1));\\n        queue<pair<int,int>> que;\\n        for(int i=0;i<isWater.size();i++){\\n            for(int j=0;j<isWater[0].size();j++){\\n                if(isWater[i][j]==1){\\n                    que.push({i,j});\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n        int dir[]={-1,0,1,0,-1};\\n        while(!que.empty()){\\n            int i,j;\\n            tie(i,j)=que.front();que.pop();\\n            for(int k=0;k<4;k++){\\n                int ni=i+dir[k],nj=j+dir[k+1];\\n                if(ni<0||ni>=isWater.size()||nj<0||nj>=isWater[0].size()||ans[ni][nj]!=-1)continue;\\n                ans[ni][nj]=ans[i][j]+1;\\n                que.push({ni,nj});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //bfs\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<vector<int>> ans(isWater.size(),vector<int>(isWater[0].size(),-1));\\n        queue<pair<int,int>> que;\\n        for(int i=0;i<isWater.size();i++){\\n            for(int j=0;j<isWater[0].size();j++){\\n                if(isWater[i][j]==1){\\n                    que.push({i,j});\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n        int dir[]={-1,0,1,0,-1};\\n        while(!que.empty()){\\n            int i,j;\\n            tie(i,j)=que.front();que.pop();\\n            for(int k=0;k<4;k++){\\n                int ni=i+dir[k],nj=j+dir[k+1];\\n                if(ni<0||ni>=isWater.size()||nj<0||nj>=isWater[0].size()||ans[ni][nj]!=-1)continue;\\n                ans[ni][nj]=ans[i][j]+1;\\n                que.push({ni,nj});\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095891,
                "title": "js-solution-100-time-100-space",
                "content": "```\\nvar highestPeak = function(w) {\\n    const m = w.length\\n    const n = w[0].length\\n    let q = []\\n    for(let mi=0; mi<m; mi++){\\n        for(let ni=0; ni<n; ni++){\\n            if(w[mi][ni]) q.push([mi, ni])\\n        }\\n    }\\n    \\n    const pos = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n    function getCells([mi, ni]){\\n        return pos.map(([ud,lr])=>[mi+ud, ni+lr])\\n            .filter(([mj, nj])=>(mj>=0 && mj<m && nj>=0 && nj<n) && !w[mj][nj])\\n    }\\n    \\n    const h = Array(m).fill(0).map(()=>Array(n).fill(0))\\n    \\n    let i = 0 // reduce time for q.shift\\n    while(i<q.length){\\n        const cell = q[i++]\\n        const cells = getCells(cell)\\n        const newHeight = h[cell[0]][cell[1]]+1 // reduce time for array lookup\\n        cells\\n            .filter(([mj, nj])=>!h[mj][nj])\\n            .forEach(c=>{\\n                h[c[0]][c[1]]=newHeight\\n                q.push(c)\\n        })\\n    }\\n    \\n    return h\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar highestPeak = function(w) {\\n    const m = w.length\\n    const n = w[0].length\\n    let q = []\\n    for(let mi=0; mi<m; mi++){\\n        for(let ni=0; ni<n; ni++){\\n            if(w[mi][ni]) q.push([mi, ni])\\n        }\\n    }\\n    \\n    const pos = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\n    function getCells([mi, ni]){\\n        return pos.map(([ud,lr])=>[mi+ud, ni+lr])\\n            .filter(([mj, nj])=>(mj>=0 && mj<m && nj>=0 && nj<n) && !w[mj][nj])\\n    }\\n    \\n    const h = Array(m).fill(0).map(()=>Array(n).fill(0))\\n    \\n    let i = 0 // reduce time for q.shift\\n    while(i<q.length){\\n        const cell = q[i++]\\n        const cells = getCells(cell)\\n        const newHeight = h[cell[0]][cell[1]]+1 // reduce time for array lookup\\n        cells\\n            .filter(([mj, nj])=>!h[mj][nj])\\n            .forEach(c=>{\\n                h[c[0]][c[1]]=newHeight\\n                q.push(c)\\n        })\\n    }\\n    \\n    return h\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074697,
                "title": "java-clean-concise-code-using-breadth-first-search-o-n-time-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        \\n        int rowLength = isWater.length;\\n        int colLength = isWater[0].length;\\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int[][] heights = new int[rowLength][colLength];\\n        Queue<int[]> queue = new LinkedList <>();\\n        \\n        for (int row = 0; row < rowLength; row++) {\\n            for (int col = 0; col < colLength; col++) {\\n                if (isWater[row][col] == 1) {\\n                    heights[row][col] = 0;\\n                    queue.offer (new int[] {row, col});\\n                }\\n                else {\\n                    heights[row][col] = -1;\\n                }\\n            }\\n        }\\n        \\n        while (!queue.isEmpty ()) {\\n            int[] mat = queue.poll ();\\n            \\n            for (int[] direction : directions) {\\n                int row = mat[0] + direction[0];\\n                int col = mat[1] + direction[1];\\n                \\n                if (row < 0 || row == rowLength || col < 0 || col == colLength || heights[row][col] != -1) {\\n                    continue;\\n                }\\n                \\n                heights[row][col] = heights[mat[0]][mat[1]] + 1;\\n                queue.offer (new int[] {row, col});\\n            }\\n        }\\n        \\n        return heights;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        \\n        int rowLength = isWater.length;\\n        int colLength = isWater[0].length;\\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        int[][] heights = new int[rowLength][colLength];\\n        Queue<int[]> queue = new LinkedList <>();\\n        \\n        for (int row = 0; row < rowLength; row++) {\\n            for (int col = 0; col < colLength; col++) {\\n                if (isWater[row][col] == 1) {\\n                    heights[row][col] = 0;\\n                    queue.offer (new int[] {row, col});\\n                }\\n                else {\\n                    heights[row][col] = -1;\\n                }\\n            }\\n        }\\n        \\n        while (!queue.isEmpty ()) {\\n            int[] mat = queue.poll ();\\n            \\n            for (int[] direction : directions) {\\n                int row = mat[0] + direction[0];\\n                int col = mat[1] + direction[1];\\n                \\n                if (row < 0 || row == rowLength || col < 0 || col == colLength || heights[row][col] != -1) {\\n                    continue;\\n                }\\n                \\n                heights[row][col] = heights[mat[0]][mat[1]] + 1;\\n                queue.offer (new int[] {row, col});\\n            }\\n        }\\n        \\n        return heights;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074667,
                "title": "python-bfs-flip-water-and-land-and-then-start-with-water",
                "content": "```py\\n\\'\\'\\'\\nw: BFS\\nh: first we flip the 0 and 1 to be 1 and 0 and append water cell to queue\\n\\tthen we start from water cell, do the regular BFS for all the water cells\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        \\n        direction = [(0,1),(0,-1),(1,0),(-1,0)]\\n\\t\\t\\n        queue = collections.deque([])\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    isWater[i][j] = 0\\n                    queue.append((i, j))\\n                    seen.add((i,j))\\n                else:\\n                    isWater[i][j] = 1\\n                    \\n        while queue:\\n            x, y = queue.popleft()\\n            for dx, dy in direction:\\n                nx = x + dx\\n                ny = y + dy\\n                if 0 <= nx < m and 0 <=ny<n and (nx,ny) not in seen and isWater[nx][ny]:\\n                    isWater[nx][ny] = isWater[x][y] + 1\\n                    queue.append((nx,ny))\\n                    seen.add((nx,ny))\\n        \\n        #print(isWater)\\n        return isWater\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: BFS\\nh: first we flip the 0 and 1 to be 1 and 0 and append water cell to queue\\n\\tthen we start from water cell, do the regular BFS for all the water cells\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        \\n        direction = [(0,1),(0,-1),(1,0),(-1,0)]\\n\\t\\t\\n        queue = collections.deque([])\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    isWater[i][j] = 0\\n                    queue.append((i, j))\\n                    seen.add((i,j))\\n                else:\\n                    isWater[i][j] = 1\\n                    \\n        while queue:\\n            x, y = queue.popleft()\\n            for dx, dy in direction:\\n                nx = x + dx\\n                ny = y + dy\\n                if 0 <= nx < m and 0 <=ny<n and (nx,ny) not in seen and isWater[nx][ny]:\\n                    isWater[nx][ny] = isWater[x][y] + 1\\n                    queue.append((nx,ny))\\n                    seen.add((nx,ny))\\n        \\n        #print(isWater)\\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074539,
                "title": "solution-using-bfs-time-o-mn-space-o-mn",
                "content": "Steps:\\n- Collect all the cell that has water and mark the height as 0\\n- Fetch all the neighbours and mark them as previous value + 1\\n- Repeat the step until all the block are processed\\n\\nTime Complexity: O(MN)\\nSpace Complexity: O(MN)\\n\\n```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int[][] result = new int[isWater.length][isWater[0].length];\\n        for(int[] row: result) \\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        for(int i=0; i<isWater.length; ++i)\\n            for(int j=0; j<isWater[i].length; ++j)\\n                if (isWater[i][j] == 1)\\n                    queue.add(new Pair(i, j));\\n        \\n        int height = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair<Integer, Integer> xy = queue.poll();\\n                int x = xy.getKey(), y = xy.getValue();\\n                // Boundary condition\\n                if (x<0 || y<0 || x>=result.length || y>=result[x].length)\\n                    continue;\\n                // Check if it is already visited with less height\\n                if (result[x][y] <= height)\\n                    continue;\\n                result[x][y] = height;\\n                queue.add(new Pair(x, y+1));\\n                queue.add(new Pair(x, y-1));\\n                queue.add(new Pair(x+1, y));\\n                queue.add(new Pair(x-1, y));\\n            }\\n            ++height;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int[][] result = new int[isWater.length][isWater[0].length];\\n        for(int[] row: result) \\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        Queue<Pair<Integer, Integer>> queue = new LinkedList<>();\\n        for(int i=0; i<isWater.length; ++i)\\n            for(int j=0; j<isWater[i].length; ++j)\\n                if (isWater[i][j] == 1)\\n                    queue.add(new Pair(i, j));\\n        \\n        int height = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                Pair<Integer, Integer> xy = queue.poll();\\n                int x = xy.getKey(), y = xy.getValue();\\n                // Boundary condition\\n                if (x<0 || y<0 || x>=result.length || y>=result[x].length)\\n                    continue;\\n                // Check if it is already visited with less height\\n                if (result[x][y] <= height)\\n                    continue;\\n                result[x][y] = height;\\n                queue.add(new Pair(x, y+1));\\n                queue.add(new Pair(x, y-1));\\n                queue.add(new Pair(x+1, y));\\n                queue.add(new Pair(x-1, y));\\n            }\\n            ++height;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079295,
                "title": "java-same-as-rotting-oranges-multisource-bfs",
                "content": "```\\nclass Solution {\\n    int[] dRow = {-1, 1, 0, 0};\\n    int[] dCol = {0, 0, -1, 1};\\n    public int[][] highestPeak(int[][] isWater) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        int m = isWater.length, n = isWater[0].length;\\n        int[][] heights = new int[m][n];\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (isWater[row][col] == 1) queue.offer(new int[]{row, col});\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            int[] arr = queue.poll();\\n            int row = arr[0], col = arr[1];\\n            for (int i = 0; i < 4; i++) {\\n                int adjR = row + dRow[i], adjC = col + dCol[i];\\n                if (adjR >= 0 && adjC >= 0 && adjR < m && adjC < n && isWater[adjR][adjC] == 0) {\\n                    heights[adjR][adjC] = heights[row][col] + 1;\\n                    isWater[adjR][adjC] = 1;\\n                    queue.offer(new int[]{adjR, adjC});\\n                }\\n            }\\n        }\\n        return heights;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[] dRow = {-1, 1, 0, 0};\\n    int[] dCol = {0, 0, -1, 1};\\n    public int[][] highestPeak(int[][] isWater) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        int m = isWater.length, n = isWater[0].length;\\n        int[][] heights = new int[m][n];\\n        for (int row = 0; row < m; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (isWater[row][col] == 1) queue.offer(new int[]{row, col});\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            int[] arr = queue.poll();\\n            int row = arr[0], col = arr[1];\\n            for (int i = 0; i < 4; i++) {\\n                int adjR = row + dRow[i], adjC = col + dCol[i];\\n                if (adjR >= 0 && adjC >= 0 && adjR < m && adjC < n && isWater[adjR][adjC] == 0) {\\n                    heights[adjR][adjC] = heights[row][col] + 1;\\n                    isWater[adjR][adjC] = 1;\\n                    queue.offer(new int[]{adjR, adjC});\\n                }\\n            }\\n        }\\n        return heights;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841920,
                "title": "c-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water)\\n    {\\n        int n = water.size(),m=water[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m,-1));\\n        queue<pair<int,int>> q;\\n        \\n        //Step 1 : identify where water is present and marks as a zero in new vector push indices in queue to move in four direction\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(water[i][j] == 1)\\n                {\\n                    ans[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n            int x = it.first,y=it.second;\\n            int v = ans[x][y];\\n            \\n            // traversing up down right left in ans array to find where is -1\\n            vector<int> temp = {-1,0,1,0,-1};\\n            for(int i=0; i<temp.size()-1;i++)\\n            {\\n                if(x+temp[i]>=0 && x+temp[i]<n && y+temp[i+1]<m &&y+temp[i+1]>=0)\\n                {\\n                    if(ans[x+temp[i]][y+temp[i+1]] == -1)\\n                    {\\n                        ans[x+temp[i]][y+temp[i+1]] = v+1;\\n                        q.push({x+temp[i],y+temp[i+1]});\\n                    }\\n                        \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water)\\n    {\\n        int n = water.size(),m=water[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m,-1));\\n        queue<pair<int,int>> q;\\n        \\n        //Step 1 : identify where water is present and marks as a zero in new vector push indices in queue to move in four direction\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(water[i][j] == 1)\\n                {\\n                    ans[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n            int x = it.first,y=it.second;\\n            int v = ans[x][y];\\n            \\n            // traversing up down right left in ans array to find where is -1\\n            vector<int> temp = {-1,0,1,0,-1};\\n            for(int i=0; i<temp.size()-1;i++)\\n            {\\n                if(x+temp[i]>=0 && x+temp[i]<n && y+temp[i+1]<m &&y+temp[i+1]>=0)\\n                {\\n                    if(ans[x+temp[i]][y+temp[i+1]] == -1)\\n                    {\\n                        ans[x+temp[i]][y+temp[i+1]] = v+1;\\n                        q.push({x+temp[i],y+temp[i+1]});\\n                    }\\n                        \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522529,
                "title": "bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m=isWater.size();\\n        int n=isWater[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        queue<pair<int,int>>pq;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(vis[i][j]==0&&isWater[i][j]==1){\\n                    pq.push({i,j});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            auto it=pq.front();\\n            pq.pop();\\n            int i=it.first;\\n            int j=it.second;\\n            int x[]={1,0,-1,0};\\n            int y[]={0,1,0,-1};\\n            for(int k=0;k<4;++k){\\n                int px=it.first+x[k];\\n                int py=it.second+y[k];\\n                if(px<0||py<0||px>=m||py>=n||vis[px][py]==1) continue;\\n                ans[px][py]=ans[i][j]+1;\\n                vis[px][py]=1;\\n                pq.push({px,py});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m=isWater.size();\\n        int n=isWater[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        queue<pair<int,int>>pq;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(vis[i][j]==0&&isWater[i][j]==1){\\n                    pq.push({i,j});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            auto it=pq.front();\\n            pq.pop();\\n            int i=it.first;\\n            int j=it.second;\\n            int x[]={1,0,-1,0};\\n            int y[]={0,1,0,-1};\\n            for(int k=0;k<4;++k){\\n                int px=it.first+x[k];\\n                int py=it.second+y[k];\\n                if(px<0||py<0||px>=m||py>=n||vis[px][py]==1) continue;\\n                ans[px][py]=ans[i][j]+1;\\n                vis[px][py]=1;\\n                pq.push({px,py});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427270,
                "title": "c-bfs-multisource-solution-easy",
                "content": "```\\nvector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        //we will do multi source bfs here, all the water cells push in the queue \\n        queue<vector<int>> q;\\n        int r = isWater.size();\\n        int c = isWater[0].size();\\n        vector<vector<int>> height(r,vector<int>(c, -1));\\n        vector<pair<int,int>> dirs = {{-1,0}, {1,0}, {0,1}, {0,-1}};\\n        for(int i = 0;i <r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(isWater[i][j] == 1)\\n                {\\n                    q.push({i,j,0});\\n                    height[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto v = q.front();\\n            q.pop();\\n            int x = v[0];\\n            int y = v[1];\\n            int h = v[2];\\n            \\n            for(auto dir : dirs)\\n            {\\n                int nx = x + dir.first;\\n                int ny = y + dir.second;\\n                int nh = h + 1;\\n                if(nx <0 || ny <0 ||nx >= r || ny >= c || isWater[nx][ny] != 0)\\n                {\\n                    continue;\\n                }\\n                \\n                isWater[nx][ny] = 1;\\n                height[nx][ny] = nh;\\n                q.push({nx,ny,nh});  \\n            }\\n  \\n        }\\n        \\n        return height;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        //we will do multi source bfs here, all the water cells push in the queue \\n        queue<vector<int>> q;\\n        int r = isWater.size();\\n        int c = isWater[0].size();\\n        vector<vector<int>> height(r,vector<int>(c, -1));\\n        vector<pair<int,int>> dirs = {{-1,0}, {1,0}, {0,1}, {0,-1}};\\n        for(int i = 0;i <r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(isWater[i][j] == 1)\\n                {\\n                    q.push({i,j,0});\\n                    height[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto v = q.front();\\n            q.pop();\\n            int x = v[0];\\n            int y = v[1];\\n            int h = v[2];\\n            \\n            for(auto dir : dirs)\\n            {\\n                int nx = x + dir.first;\\n                int ny = y + dir.second;\\n                int nh = h + 1;\\n                if(nx <0 || ny <0 ||nx >= r || ny >= c || isWater[nx][ny] != 0)\\n                {\\n                    continue;\\n                }\\n                \\n                isWater[nx][ny] = 1;\\n                height[nx][ny] = nh;\\n                q.push({nx,ny,nh});  \\n            }\\n  \\n        }\\n        \\n        return height;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345017,
                "title": "easy-to-understand-bfs-solution-c-o-mn-space-o-mn-time",
                "content": "```\\ntypedef pair<int, int> pi;\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>> &isWater)\\n    {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        for (int i = 0; i < isWater.size(); i++)\\n        {\\n            for (int j = 0; j < isWater[i].size(); j++)\\n            {\\n                if (isWater[i][j] == 1)\\n                {\\n                    isWater[i][j] = 0;\\n                    q.push({i, j});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        while (!q.empty())\\n        {\\n            pi p = q.front();\\n            q.pop();\\n            int i = p.first;\\n            int j = p.second;\\n            if ((i + 1) < n && vis[i + 1][j] == 0)\\n            {\\n                isWater[i + 1][j] = isWater[i][j] + 1;\\n                vis[i + 1][j] = 1;\\n                q.push({i + 1, j});\\n            }\\n            if ((i - 1) >= 0 && vis[i - 1][j] == 0)\\n            {\\n                isWater[i - 1][j] = isWater[i][j] + 1;\\n                vis[i - 1][j] = 1;\\n                q.push({i - 1, j});\\n            }\\n            if ((j - 1) >= 0 && vis[i][j - 1] == 0)\\n            {\\n                isWater[i][j - 1] = isWater[i][j] + 1;\\n                vis[i][j - 1] = 1;\\n                q.push({i, j - 1});\\n            }\\n            if ((j + 1) < m && vis[i][j + 1] == 0)\\n            {\\n                isWater[i][j + 1] = isWater[i][j] + 1;\\n                vis[i][j + 1] = 1;\\n                q.push({i, j + 1});\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int, int> pi;\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>> &isWater)\\n    {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        for (int i = 0; i < isWater.size(); i++)\\n        {\\n            for (int j = 0; j < isWater[i].size(); j++)\\n            {\\n                if (isWater[i][j] == 1)\\n                {\\n                    isWater[i][j] = 0;\\n                    q.push({i, j});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        while (!q.empty())\\n        {\\n            pi p = q.front();\\n            q.pop();\\n            int i = p.first;\\n            int j = p.second;\\n            if ((i + 1) < n && vis[i + 1][j] == 0)\\n            {\\n                isWater[i + 1][j] = isWater[i][j] + 1;\\n                vis[i + 1][j] = 1;\\n                q.push({i + 1, j});\\n            }\\n            if ((i - 1) >= 0 && vis[i - 1][j] == 0)\\n            {\\n                isWater[i - 1][j] = isWater[i][j] + 1;\\n                vis[i - 1][j] = 1;\\n                q.push({i - 1, j});\\n            }\\n            if ((j - 1) >= 0 && vis[i][j - 1] == 0)\\n            {\\n                isWater[i][j - 1] = isWater[i][j] + 1;\\n                vis[i][j - 1] = 1;\\n                q.push({i, j - 1});\\n            }\\n            if ((j + 1) < m && vis[i][j + 1] == 0)\\n            {\\n                isWater[i][j + 1] = isWater[i][j] + 1;\\n                vis[i][j + 1] = 1;\\n                q.push({i, j + 1});\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290259,
                "title": "beginner-friendly-easy-approach-clean-implementation-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(int i, int j, int n, int m){\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\n    \\n    vector<vector<int>> highestPeak(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n        vector<int> dx = {1, -1, 0, 0};\\n        vector<int> dy = {0, 0, 1, -1};\\n        \\n        queue<pair<int, int>> q;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(mat[i][j]==1){\\n                    dp[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int lvl = 1;\\n        while(!q.empty()){\\n            \\n            int size = q.size();\\n            \\n            while(size--){\\n                pair<int, int> t = q.front();\\n                q.pop();\\n                \\n                int x = t.first, y = t.second;\\n                \\n                for(int k=0; k<4; k++){\\n                    \\n                    int X = x+dx[k], Y = y+dy[k];\\n                    \\n                    if(isSafe(X, Y, n, m)){\\n                        if(dp[X][Y]>lvl){\\n                            dp[X][Y] = lvl;\\n                            q.push({X, Y});\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            lvl++;\\n            \\n        }\\n        \\n        return dp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(int i, int j, int n, int m){\\n        return (i>=0 && i<n && j>=0 && j<m);\\n    }\\n    \\n    vector<vector<int>> highestPeak(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n        vector<int> dx = {1, -1, 0, 0};\\n        vector<int> dy = {0, 0, 1, -1};\\n        \\n        queue<pair<int, int>> q;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(mat[i][j]==1){\\n                    dp[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int lvl = 1;\\n        while(!q.empty()){\\n            \\n            int size = q.size();\\n            \\n            while(size--){\\n                pair<int, int> t = q.front();\\n                q.pop();\\n                \\n                int x = t.first, y = t.second;\\n                \\n                for(int k=0; k<4; k++){\\n                    \\n                    int X = x+dx[k], Y = y+dy[k];\\n                    \\n                    if(isSafe(X, Y, n, m)){\\n                        if(dp[X][Y]>lvl){\\n                            dp[X][Y] = lvl;\\n                            q.push({X, Y});\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            lvl++;\\n            \\n        }\\n        \\n        return dp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227632,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int dirx[4] = {-1,1,0,0};\\n    int diry[4] = {0,0,-1,1};\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        vector<vector<int>> visited(n, vector<int> (m,0));\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 0) continue;\\n                isWater[i][j] = 0;\\n                q.push({i,j});\\n                visited[i][j] = 1;\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                pair<int,int> tp = q.front();\\n                q.pop();\\n                int x = tp.first;\\n                int y = tp.second;\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx >= n || nxty >= m || nxtx < 0 || nxty < 0 || visited[nxtx][nxty]) continue;\\n                    isWater[nxtx][nxty] = isWater[x][y]+1;\\n                    visited[nxtx][nxty] = 1;\\n                    q.push({nxtx,nxty});\\n                } \\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dirx[4] = {-1,1,0,0};\\n    int diry[4] = {0,0,-1,1};\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        vector<vector<int>> visited(n, vector<int> (m,0));\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 0) continue;\\n                isWater[i][j] = 0;\\n                q.push({i,j});\\n                visited[i][j] = 1;\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                pair<int,int> tp = q.front();\\n                q.pop();\\n                int x = tp.first;\\n                int y = tp.second;\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx >= n || nxty >= m || nxtx < 0 || nxty < 0 || visited[nxtx][nxty]) continue;\\n                    isWater[nxtx][nxty] = isWater[x][y]+1;\\n                    visited[nxtx][nxty] = 1;\\n                    q.push({nxtx,nxty});\\n                } \\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141687,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def highestPeak(self, x: List[List[int]]) -> List[List[int]]:\\n        m,n=len(x),len(x[0])\\n        q=[]\\n        for i in range(m):  \\n            for j in range(n):\\n                if x[i][j]==1:\\n                    x[i][j]=0\\n                    q.append((i,j))\\n                else:\\n                    x[i][j]=-1\\n        while q:\\n            i,j=q.pop(0)\\n            for d,e in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\\n                if 0<=d<m and 0<=e<n and x[d][e]==-1:\\n                    x[d][e]=x[i][j]+1\\n                    q.append((d,e))\\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, x: List[List[int]]) -> List[List[int]]:\\n        m,n=len(x),len(x[0])\\n        q=[]\\n        for i in range(m):  \\n            for j in range(n):\\n                if x[i][j]==1:\\n                    x[i][j]=0\\n                    q.append((i,j))\\n                else:\\n                    x[i][j]=-1\\n        while q:\\n            i,j=q.pop(0)\\n            for d,e in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\\n                if 0<=d<m and 0<=e<n and x[d][e]==-1:\\n                    x[d][e]=x[i][j]+1\\n                    q.append((d,e))\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111170,
                "title": "simple-java-bfs-solution",
                "content": "```\\n\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n     \\n        int n = isWater.length ;\\n        int m = isWater[0].length ;\\n        int dir[][] = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        int result[][] = new int[n][m] ;\\n        Queue<int[]> queue = new LinkedList<>() ;\\n        int count = 1 ;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(isWater[i][j] == 1){\\n                    queue.add(new int[]{i,j});\\n                }else{\\n                    result[i][j] = -1 ;\\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            \\n            int size = queue.size() ;\\n            \\n            while(size > 0){\\n                \\n                int[] cur = queue.poll() ;\\n                \\n                for(int[] d:dir){\\n                \\n                    int x = cur[0] + d[0] ;\\n                    int y = cur[1] + d[1] ;\\n                \\n                    if(x<0 || x>= n || y<0 || y>=m || result[x][y] != -1){\\n                        continue ;\\n                    }\\n\\n                    queue.add(new int[]{x,y}) ;\\n                    result[x][y] = count ;                \\n                }\\n                \\n                size-- ;\\n            }\\n            \\n           count++ ;             \\n        }\\n        \\n        return result ;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n     \\n        int n = isWater.length ;\\n        int m = isWater[0].length ;\\n        int dir[][] = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n        \\n        int result[][] = new int[n][m] ;\\n        Queue<int[]> queue = new LinkedList<>() ;\\n        int count = 1 ;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(isWater[i][j] == 1){\\n                    queue.add(new int[]{i,j});\\n                }else{\\n                    result[i][j] = -1 ;\\n                }\\n            }\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            \\n            int size = queue.size() ;\\n            \\n            while(size > 0){\\n                \\n                int[] cur = queue.poll() ;\\n                \\n                for(int[] d:dir){\\n                \\n                    int x = cur[0] + d[0] ;\\n                    int y = cur[1] + d[1] ;\\n                \\n                    if(x<0 || x>= n || y<0 || y>=m || result[x][y] != -1){\\n                        continue ;\\n                    }\\n\\n                    queue.add(new int[]{x,y}) ;\\n                    result[x][y] = count ;                \\n                }\\n                \\n                size-- ;\\n            }\\n            \\n           count++ ;             \\n        }\\n        \\n        return result ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943806,
                "title": "beats-100-percent-cpp-solution-simple-bfs",
                "content": "...\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&grid,vector<vector<bool>>&visited){\\n        queue<pair<int ,int>>q;\\n          int n =grid.size();\\n        int m =grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    //cout<<i<<\" \"<<j<<endl;\\n                    visited[i][j]=true;\\n                    grid[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int x =q.front().first;\\n            int y =q.front().second;\\n            q.pop();\\n            if(x+1<n){\\n                if(visited[x+1][y]==false){\\n                    grid[x+1][y]=grid[x][y]+1;\\n                \\n                    visited[x+1][y]=true;\\n                    q.push({x+1,y});\\n                }\\n            }\\n               if(x-1>=0){\\n                if(visited[x-1][y]==false){\\n                    grid[x-1][y]=grid[x][y]+1;\\n                    visited[x-1][y]=true;\\n                    q.push({x-1,y});\\n                }\\n            }\\n               if(y+1<m){\\n                if(visited[x][y+1]==false){\\n                    grid[x][y+1]=grid[x][y]+1;\\n                    visited[x][y+1]=true;\\n                    q.push({x,y+1});\\n                }\\n            }\\n               if(y-1>=0){\\n                if(visited[x][y-1]==false){\\n                    grid[x][y-1]=grid[x][y]+1;\\n   \\n                    visited[x][y-1]=true;\\n                    q.push({x,y-1});\\n                }\\n            }\\n        }\\n    \\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n       int n =grid.size();\\n        int m =grid[0].size();\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        bfs(grid,visited);\\n     \\n     \\n        return grid;\\n        \\n    }\\n};\\n...",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void bfs(vector<vector<int>>&grid,vector<vector<bool>>&visited){\\n        queue<pair<int ,int>>q;\\n          int n =grid.size();\\n        int m =grid[0].size();\\n        for(int i = 0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    //cout<<i<<\" \"<<j<<endl;\\n                    visited[i][j]=true;\\n                    grid[i][j]=0;\\n                    q.push({i,j}",
                "codeTag": "C++"
            },
            {
                "id": 1896898,
                "title": "bfs-with-lowest-height-clean-solution-in-c",
                "content": "\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) \\n    {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<vector<int>> q;\\n        vector<vector<int>> height(m,vector<int>(n));\\n        \\n        for(int r=0;r<m;r++)\\n        {\\n            for(int c=0;c<n;c++)\\n            {\\n                if(grid[r][c]==1) \\n                {    \\n                    height[r][c]=0;\\n                    q.push({r,c});\\n                }\\n                \\n                else height[r][c]=-1;\\n            }\\n        }\\n        \\n        vector<int> DIR={0,1,0,-1,0};\\n        while(!q.empty())\\n        {\\n            auto top=q.front();\\n            q.pop();\\n            \\n            int r=top[0], c=top[1];\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nr=r+DIR[i], nc=c+DIR[i+1];\\n                \\n                if(nr<0 || nc<0 || nr>=m || nc>=n || height[nr][nc]!=-1) continue;\\n                \\n                height[nr][nc]=height[r][c]+1;\\n                q.push({nr,nc});\\n            }\\n        }\\n        \\n        return height;\\n    }\\n};\\n\\nPlease Upvote if u will find solution helpful",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) \\n    {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        queue<vector<int>> q;\\n        vector<vector<int>> height(m,vector<int>(n));\\n        \\n        for(int r=0;r<m;r++)\\n        {\\n            for(int c=0;c<n;c++)\\n            {\\n                if(grid[r][c]==1) \\n                {    \\n                    height[r][c]=0;\\n                    q.push({r,c}",
                "codeTag": "Java"
            },
            {
                "id": 1787839,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:    \\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isW) {\\n        int r=isW.size(),c=isW[0].size();\\n        vector<vector<int>>ans(r,vector<int>(c,INT_MAX));\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                if(isW[i][j])\\n                    q.push({i,j});                    \\n        int lvl=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(ans[x][y]>lvl){\\n                    ans[x][y]=lvl;\\n                    for(int d=0;d<4;d++){\\n                        int i=x+dx[d],j=y+dy[d];\\n                        if(i<0 || i>=r || j<0 || j>=c) continue;\\n                        q.push({i,j});\\n                    }\\n                }\\n            }\\n            lvl++;\\n        }\\n        return ans;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isW) {\\n        int r=isW.size(),c=isW[0].size();\\n        vector<vector<int>>ans(r,vector<int>(c,INT_MAX));\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                if(isW[i][j])\\n                    q.push({i,j});                    \\n        int lvl=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(ans[x][y]>lvl){\\n                    ans[x][y]=lvl;\\n                    for(int d=0;d<4;d++){\\n                        int i=x+dx[d],j=y+dy[d];\\n                        if(i<0 || i>=r || j<0 || j>=c) continue;\\n                        q.push({i,j});\\n                    }\\n                }\\n            }\\n            lvl++;\\n        }\\n        return ans;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573120,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t{\\n\\t\\tpublic int[][] HighestPeak(int[][] isWater)\\n\\t\\t{\\n\\t\\t\\tQueue<(int, int, int)> queue = new Queue<(int, int, int)>();\\n\\t\\t\\tbool[,] visited = new bool[isWater.GetLength(0), isWater[0].Length];\\n\\t\\t\\tint[,] dir = new int[,] { { -1, 0 }, { 0, -1 }, { 1, 0 }, { 0, 1 } };\\n\\n\\t\\t\\tfor(int i = 0; i < isWater.GetLength(0); i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < isWater[i].Length; j++) {\\n\\t\\t\\t\\t\\tif(isWater[i][j] == 1) {\\n\\t\\t\\t\\t\\t\\tisWater[i][j] = 0;\\n\\t\\t\\t\\t\\t\\tvisited[i, j] = true;\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue((i, j, isWater[i][j]));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(queue.Count > 0) {\\n\\t\\t\\t\\t(int, int, int) node = queue.Dequeue();\\n\\n\\t\\t\\t\\tfor(int i = 0; i < dir.GetLength(0); i++) {\\n\\t\\t\\t\\t\\tint nr = node.Item1 + dir[i, 0];\\n\\t\\t\\t\\t\\tint nc = node.Item2 + dir[i, 1];\\n\\n\\t\\t\\t\\t\\tif(nr >= 0 && nr < isWater.GetLength(0) && nc >= 0 && nc < isWater[nr].Length && !visited[nr, nc]) {\\n\\t\\t\\t\\t\\t\\tisWater[nr][nc] = node.Item3 + 1;\\n\\t\\t\\t\\t\\t\\tvisited[nr, nc] = true;\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue((nr, nc, isWater[nr][nc]));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn isWater;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution\\n\\t{\\n\\t\\tpublic int[][] HighestPeak(int[][] isWater)\\n\\t\\t{\\n\\t\\t\\tQueue<(int, int, int)> queue = new Queue<(int, int, int)>();\\n\\t\\t\\tbool[,] visited = new bool[isWater.GetLength(0), isWater[0].Length];\\n\\t\\t\\tint[,] dir = new int[,] { { -1, 0 }",
                "codeTag": "Java"
            },
            {
                "id": 1570407,
                "title": "c-356ms-57-simple-bfs",
                "content": "Runtime: 324 ms, faster than 63.64% of C++ online submissions for Map of Highest Peak.\\nMemory Usage: 124.3 MB, less than 31.44% of C++ online submissions for Map of Highest Peak.\\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n    int y = grid.size(), yend = grid.size() - 1, x = grid[0].size(), xend = grid[0].size() - 1, level = -1;\\n  \\n    queue<pair<int,int>> q;  \\n    for(int ty = 0; ty != y; ty++)\\n      for(int tx = 0; tx != x; tx++){\\n        if(grid[ty][tx] == 1) q.push({ty,tx});\\n        grid[ty][tx] = INT_MAX; \\n      }\\n    \\n    while(!q.empty()){\\n      level++;\\n      int n = q.size();\\n      while(n--){\\n        auto [cy,cx] = q.front(); q.pop();\\n        if(grid[cy][cx] != INT_MAX) continue;\\n        grid[cy][cx] = level;\\n          \\n        if(cy         && grid[cy-1][cx] == INT_MAX) q.push({cy-1,cx});\\n        if(cy != yend && grid[cy+1][cx] == INT_MAX) q.push({cy+1,cx});\\n        if(cx         && grid[cy][cx-1] == INT_MAX) q.push({cy,cx-1});\\n        if(cx != xend && grid[cy][cx+1] == INT_MAX) q.push({cy,cx+1});\\n      }\\n    }\\n      \\n    return grid;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n    int y = grid.size(), yend = grid.size() - 1, x = grid[0].size(), xend = grid[0].size() - 1, level = -1;\\n  \\n    queue<pair<int,int>> q;  \\n    for(int ty = 0; ty != y; ty++)\\n      for(int tx = 0; tx != x; tx++){\\n        if(grid[ty][tx] == 1) q.push({ty,tx});\\n        grid[ty][tx] = INT_MAX; \\n      }\\n    \\n    while(!q.empty()){\\n      level++;\\n      int n = q.size();\\n      while(n--){\\n        auto [cy,cx] = q.front(); q.pop();\\n        if(grid[cy][cx] != INT_MAX) continue;\\n        grid[cy][cx] = level;\\n          \\n        if(cy         && grid[cy-1][cx] == INT_MAX) q.push({cy-1,cx});\\n        if(cy != yend && grid[cy+1][cx] == INT_MAX) q.push({cy+1,cx});\\n        if(cx         && grid[cy][cx-1] == INT_MAX) q.push({cy,cx-1});\\n        if(cx != xend && grid[cy][cx+1] == INT_MAX) q.push({cy,cx+1});\\n      }\\n    }\\n      \\n    return grid;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528067,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        \\n        int n=isWater.size();\\n        int m=isWater[0].size();\\n        \\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\t\\t\\n        \\n        queue<pair<int,int>>q;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(isWater[i][j]==1)\\n                    q.push({i,j}),vis[i][j]=1,ans[i][j]=0;\\n            }\\n        }\\n        \\n        int dx[4]={0,0,1,-1};\\n        int dy[4]={1,-1,0,0};\\n        \\n        int cnt=0;\\n        while(!q.empty())\\n        {\\n            int qsize=q.size();\\n            cnt++;\\n            while(qsize--)\\n            {                \\n                auto it=q.front();\\n                q.pop();\\n                \\n                int x=it.first;\\n                int y=it.second;\\n                \\n                for(int i=0; i<4; i++)\\n                {\\n                    if(x+dx[i]>=0 && x+dx[i]<n && y+dy[i]>=0 && y+dy[i]<m && vis[x+dx[i]][y+dy[i]]==0)\\n                    {\\n                        vis[x+dx[i]][y+dy[i]]=1;\\n                        ans[x+dx[i]][y+dy[i]]=cnt;\\n                        q.push({x+dx[i],y+dy[i]});\\n                    }\\n                }\\n            }          \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        \\n        int n=isWater.size();\\n        int m=isWater[0].size();\\n        \\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\t\\t\\n        \\n        queue<pair<int,int>>q;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(isWater[i][j]==1)\\n                    q.push({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 1383944,
                "title": "very-easy-to-follow-faster-than-95-and-lesser-memory-than-90-submissions",
                "content": "```\\ntypedef pair<int,int> pairs;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int num_rows = isWater.size();\\n        int num_cols = isWater[0].size();\\n        \\n        queue<pairs> cells; // queue to perform BFS\\n        \\n        for(int row = 0; row < num_rows; row++){\\n            for(int col = 0; col < num_cols; col++){\\n                // start BFS from water cells\\n                if (isWater[row][col] == 1)\\n                    cells.push(make_pair(row, col));\\n                isWater[row][col]--; // convert water cells to zero and land cells to -1\\n            }\\n        }\\n        \\n        while (!cells.empty()) {\\n            pairs currCell = cells.front();\\n            cells.pop();\\n            \\n            int row = currCell.first;\\n            int col = currCell.second;\\n            \\n            // Assign weights to neighbours and add to queue\\n            \\n            // north\\n            if (row > 0 && isWater[row-1][col] < 0) {\\n                isWater[row-1][col] = isWater[row][col] + 1;\\n                cells.push(make_pair(row-1, col));\\n            }\\n            // south\\n            if (row < num_rows-1 && isWater[row+1][col] < 0) {\\n                isWater[row+1][col] = isWater[row][col] + 1;\\n                cells.push(make_pair(row+1, col));\\n            }\\n            // east\\n            if (col < num_cols-1 && isWater[row][col+1] < 0) {\\n                isWater[row][col+1] = isWater[row][col] + 1;\\n                cells.push(make_pair(row, col+1));\\n            }\\n            // west\\n            if (col > 0 && isWater[row][col-1] < 0) {\\n                isWater[row][col-1] = isWater[row][col] + 1;\\n                cells.push(make_pair(row, col-1));\\n            }\\n            \\n        }\\n        \\n        return isWater;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int,int> pairs;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int num_rows = isWater.size();\\n        int num_cols = isWater[0].size();\\n        \\n        queue<pairs> cells; // queue to perform BFS\\n        \\n        for(int row = 0; row < num_rows; row++){\\n            for(int col = 0; col < num_cols; col++){\\n                // start BFS from water cells\\n                if (isWater[row][col] == 1)\\n                    cells.push(make_pair(row, col));\\n                isWater[row][col]--; // convert water cells to zero and land cells to -1\\n            }\\n        }\\n        \\n        while (!cells.empty()) {\\n            pairs currCell = cells.front();\\n            cells.pop();\\n            \\n            int row = currCell.first;\\n            int col = currCell.second;\\n            \\n            // Assign weights to neighbours and add to queue\\n            \\n            // north\\n            if (row > 0 && isWater[row-1][col] < 0) {\\n                isWater[row-1][col] = isWater[row][col] + 1;\\n                cells.push(make_pair(row-1, col));\\n            }\\n            // south\\n            if (row < num_rows-1 && isWater[row+1][col] < 0) {\\n                isWater[row+1][col] = isWater[row][col] + 1;\\n                cells.push(make_pair(row+1, col));\\n            }\\n            // east\\n            if (col < num_cols-1 && isWater[row][col+1] < 0) {\\n                isWater[row][col+1] = isWater[row][col] + 1;\\n                cells.push(make_pair(row, col+1));\\n            }\\n            // west\\n            if (col > 0 && isWater[row][col-1] < 0) {\\n                isWater[row][col-1] = isWater[row][col] + 1;\\n                cells.push(make_pair(row, col-1));\\n            }\\n            \\n        }\\n        \\n        return isWater;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376779,
                "title": "c-bfs-distance-of-nearest-water-cell-95-upvote",
                "content": "Normal BFS with initially the water cells\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size();\\n        int n = isWater[0].size();\\n     \\n        queue<pair<int,int>> q;\\n        \\n\\t\\t//We\\'ll be modifying the isWater grid itself as the answer\\n\\t\\t\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(isWater[i][j]==1){\\n                    isWater[i][j]=0;           //Water cells should be zero\\n                    q.push({i,j});             // pushing into queue\\n                }\\n                else{\\n                    isWater[i][j]=-1;      //land cells initially -1\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            pair<int,int> curr = q.front();\\n            q.pop();\\n            int i  =curr.first;\\n            int j = curr.second;\\n            \\n            if(i+1<m&&isWater[i+1][j]==-1){\\n                isWater[i+1][j]=1+isWater[i][j];\\n                q.push({i+1,j});\\n            }\\n            if(j-1>=0&&isWater[i][j-1]==-1){\\n                isWater[i][j-1]=1+isWater[i][j];\\n                q.push({i,j-1});\\n            }\\n            if(j+1<n&&isWater[i][j+1]==-1){\\n                isWater[i][j+1]=1+isWater[i][j];\\n                q.push({i,j+1});\\n            }\\n            if(i-1>=0&&isWater[i-1][j]==-1){\\n                isWater[i-1][j]=1+isWater[i][j];\\n                q.push({i-1,j});\\n            }\\n        }\\n        \\n        return isWater;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size();\\n        int n = isWater[0].size();\\n     \\n        queue<pair<int,int>> q;\\n        \\n\\t\\t//We\\'ll be modifying the isWater grid itself as the answer\\n\\t\\t\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(isWater[i][j]==1){\\n                    isWater[i][j]=0;           //Water cells should be zero\\n                    q.push({i,j});             // pushing into queue\\n                }\\n                else{\\n                    isWater[i][j]=-1;      //land cells initially -1\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            pair<int,int> curr = q.front();\\n            q.pop();\\n            int i  =curr.first;\\n            int j = curr.second;\\n            \\n            if(i+1<m&&isWater[i+1][j]==-1){\\n                isWater[i+1][j]=1+isWater[i][j];\\n                q.push({i+1,j});\\n            }\\n            if(j-1>=0&&isWater[i][j-1]==-1){\\n                isWater[i][j-1]=1+isWater[i][j];\\n                q.push({i,j-1});\\n            }\\n            if(j+1<n&&isWater[i][j+1]==-1){\\n                isWater[i][j+1]=1+isWater[i][j];\\n                q.push({i,j+1});\\n            }\\n            if(i-1>=0&&isWater[i-1][j]==-1){\\n                isWater[i-1][j]=1+isWater[i][j];\\n                q.push({i-1,j});\\n            }\\n        }\\n        \\n        return isWater;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356972,
                "title": "multi-source-bfs",
                "content": "```\\nclass Solution {\\n    int dir[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>&mat) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        bool vis[1001][1001];\\n        \\n        memset(vis,false,sizeof(vis));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    mat[i][j]=0;\\n                    q.push({i,j});\\n                    vis[i][j]=true;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int b=q.size();\\n            while(b--)\\n            {\\n               int i=q.front().first;\\n                int j=q.front().second;\\n                q.pop();\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+dir[k][0];\\n                    int y=j+dir[k][1];\\n                    \\n                    if(x>=0&&x<=n-1&&y>=0&&y<=m-1&&vis[x][y]==false)\\n                    {\\n                        mat[x][y]=(mat[i][j]+1);\\n                        q.push({x,y});\\n                        vis[x][y]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return mat;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dir[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>&mat) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        bool vis[1001][1001];\\n        \\n        memset(vis,false,sizeof(vis));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    mat[i][j]=0;\\n                    q.push({i,j});\\n                    vis[i][j]=true;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int b=q.size();\\n            while(b--)\\n            {\\n               int i=q.front().first;\\n                int j=q.front().second;\\n                q.pop();\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+dir[k][0];\\n                    int y=j+dir[k][1];\\n                    \\n                    if(x>=0&&x<=n-1&&y>=0&&y<=m-1&&vis[x][y]==false)\\n                    {\\n                        mat[x][y]=(mat[i][j]+1);\\n                        q.push({x,y});\\n                        vis[x][y]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return mat;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338049,
                "title": "find-surrounding-neighbors-layer-by-layer-88-speed",
                "content": "Runtime: 3700 ms, faster than 88.13%\\nMemory Usage: 155 MB, less than 30.57%\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        land = set()\\n        water = set()\\n        for r, row in enumerate(isWater):\\n            for c, v in enumerate(row):\\n                if v:\\n                    water.add((r, c))\\n                else:\\n                    land.add((r, c))\\n        height = 0\\n        cells = water\\n        while cells:\\n            new_cells = set()\\n            for r, c in cells:\\n                isWater[r][c] = height\\n                for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    new_cell = (r + i, c + j)\\n                    if new_cell in land:\\n                        land.remove(new_cell)\\n                        new_cells.add(new_cell)\\n            cells = new_cells\\n            height += 1\\n        return isWater\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        land = set()\\n        water = set()\\n        for r, row in enumerate(isWater):\\n            for c, v in enumerate(row):\\n                if v:\\n                    water.add((r, c))\\n                else:\\n                    land.add((r, c))\\n        height = 0\\n        cells = water\\n        while cells:\\n            new_cells = set()\\n            for r, c in cells:\\n                isWater[r][c] = height\\n                for i, j in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                    new_cell = (r + i, c + j)\\n                    if new_cell in land:\\n                        land.remove(new_cell)\\n                        new_cells.add(new_cell)\\n            cells = new_cells\\n            height += 1\\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248400,
                "title": "c-bfs-based-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& v) {\\n        \\n        vector<vector<int>>visited(v.size(),vector<int>(v[0].size(),0));\\n        queue<pair<pair<int,int>,int>>pq;\\n        \\n        \\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    pq.push({{i,j},0});\\n                    visited[i][j]=1;\\n                    v[i][j]=0;//emptying matrix to store values again\\n                }\\n            }\\n        }\\n        \\n        \\n        while(pq.size()!=0)\\n        {\\n            pair<int,int>p=pq.front().first;\\n            int lev=pq.front().second;\\n            pq.pop();\\n            \\n            int i=p.first,j=p.second; \\n            if(i-1>=0&&visited[i-1][j]==0)\\n            {\\n                visited[i-1][j]=1;\\n                v[i-1][j]=lev+1;\\n                pq.push({{i-1,j},lev+1});\\n            }\\n              if(j-1>=0&&visited[i][j-1]==0)\\n            {\\n                visited[i][j-1]=1;\\n                v[i][j-1]=lev+1;\\n                pq.push({{i,j-1},lev+1});\\n            }\\n            \\n              if(i+1<v.size()&&visited[i+1][j]==0)\\n            {\\n                visited[i+1][j]=1;\\n                v[i+1][j]=lev+1;\\n                pq.push({{i+1,j},lev+1});\\n            }\\n            \\n              if(j+1<v[0].size()&&visited[i][j+1]==0)\\n            {\\n                visited[i][j+1]=1;\\n                v[i][j+1]=lev+1;\\n                pq.push({{i,j+1},lev+1});\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& v) {\\n        \\n        vector<vector<int>>visited(v.size(),vector<int>(v[0].size(),0));\\n        queue<pair<pair<int,int>,int>>pq;\\n        \\n        \\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[0].size();j++)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    pq.push({{i,j},0});\\n                    visited[i][j]=1;\\n                    v[i][j]=0;//emptying matrix to store values again\\n                }\\n            }\\n        }\\n        \\n        \\n        while(pq.size()!=0)\\n        {\\n            pair<int,int>p=pq.front().first;\\n            int lev=pq.front().second;\\n            pq.pop();\\n            \\n            int i=p.first,j=p.second; \\n            if(i-1>=0&&visited[i-1][j]==0)\\n            {\\n                visited[i-1][j]=1;\\n                v[i-1][j]=lev+1;\\n                pq.push({{i-1,j},lev+1});\\n            }\\n              if(j-1>=0&&visited[i][j-1]==0)\\n            {\\n                visited[i][j-1]=1;\\n                v[i][j-1]=lev+1;\\n                pq.push({{i,j-1},lev+1});\\n            }\\n            \\n              if(i+1<v.size()&&visited[i+1][j]==0)\\n            {\\n                visited[i+1][j]=1;\\n                v[i+1][j]=lev+1;\\n                pq.push({{i+1,j},lev+1});\\n            }\\n            \\n              if(j+1<v[0].size()&&visited[i][j+1]==0)\\n            {\\n                visited[i][j+1]=1;\\n                v[i][j+1]=lev+1;\\n                pq.push({{i,j+1},lev+1});\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241596,
                "title": "c",
                "content": "\\n    bool isValid(int x,int y, int m , int n)\\n    {\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n    int m=isWater.size();\\n    int n=isWater[0].size();    \\n    vector<vector<int>>vis(m,vector<int>(n,0));\\n    vector<vector<int>>dist(m,vector<int>(n,-1));\\n        \\n    queue<vector<int>>q;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                q.push({i,j}); \\n                dist[i][j]=0;    \\n                }\\n                  \\n            }\\n        }\\n        \\n        int x,y,d;\\n        while(!q.empty())\\n        {\\n           x=q.front()[0];\\n           y=q.front()[1];\\n            \\n           q.pop(); \\n           \\n            if(isValid(x+1,y,m,n) && dist[x+1][y]==-1)\\n            {\\n                dist[x+1][y]=dist[x][y]+1;\\n                q.push({x+1,y});\\n            }\\n              if(isValid(x-1,y,m,n) && dist[x-1][y]==-1)\\n            {\\n                dist[x-1][y]=dist[x][y]+1;\\n                q.push({x-1,y});\\n            }\\n              if(isValid(x,y+1,m,n) && dist[x][y+1]==-1)\\n            {\\n                dist[x][y+1]=dist[x][y]+1;\\n                q.push({x,y+1});\\n            }\\n              if(isValid(x,y-1,m,n) && dist[x][y-1]==-1)\\n            {\\n                dist[x][y-1]=dist[x][y]+1;\\n                q.push({x,y-1});\\n            }\\n        }\\n        \\n        return dist;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    bool isValid(int x,int y, int m , int n)\\n    {\\n        if(x>=0 && x<m && y>=0 && y<n) return true;\\n        return false;\\n    }\\n    \\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n    int m=isWater.size();\\n    int n=isWater[0].size();    \\n    vector<vector<int>>vis(m,vector<int>(n,0));\\n    vector<vector<int>>dist(m,vector<int>(n,-1));\\n        \\n    queue<vector<int>>q;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                q.push({i,j}); \\n                dist[i][j]=0;    \\n                }\\n                  \\n            }\\n        }\\n        \\n        int x,y,d;\\n        while(!q.empty())\\n        {\\n           x=q.front()[0];\\n           y=q.front()[1];\\n            \\n           q.pop(); \\n           \\n            if(isValid(x+1,y,m,n) && dist[x+1][y]==-1)\\n            {\\n                dist[x+1][y]=dist[x][y]+1;\\n                q.push({x+1,y});\\n            }\\n              if(isValid(x-1,y,m,n) && dist[x-1][y]==-1)\\n            {\\n                dist[x-1][y]=dist[x][y]+1;\\n                q.push({x-1,y});\\n            }\\n              if(isValid(x,y+1,m,n) && dist[x][y+1]==-1)\\n            {\\n                dist[x][y+1]=dist[x][y]+1;\\n                q.push({x,y+1});\\n            }\\n              if(isValid(x,y-1,m,n) && dist[x][y-1]==-1)\\n            {\\n                dist[x][y-1]=dist[x][y]+1;\\n                q.push({x,y-1});\\n            }\\n        }\\n        \\n        return dist;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1236824,
                "title": "java-easy-bfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    int dir[][] = {{0,1},{1,0},{-1,0},{0,-1}};\\n    \\n    public int[][] highestPeak(int[][] M) {\\n        int L = M.length;\\n        int B = M[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean visi[][] = new boolean[L][B];\\n        int ans[][] = new int[L][B];\\n        \\n        for(int i = 0 ; i < L ; i++) {\\n            for(int j = 0 ; j < B ; j++) {\\n                if(M[i][j] == 1) {\\n                    queue.add(new int[]{i , j , 0});\\n                }\\n            }\\n        }\\n        while(!queue.isEmpty()) {\\n            int[] node = queue.remove();\\n            ans[node[0]][node[1]] = node[2];\\n            for(int d[] : dir) {\\n                int x = node[0] + d[0];\\n                int y = node[1] + d[1];        \\n                if(x >= 0 && x < L && y >= 0 && y < B && !visi[x][y] && M[x][y] == 0) {\\n                    queue.add(new int[]{x , y , node[2] + 1});\\n                    visi[x][y] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int dir[][] = {{0,1},{1,0},{-1,0},{0,-1}};\\n    \\n    public int[][] highestPeak(int[][] M) {\\n        int L = M.length;\\n        int B = M[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean visi[][] = new boolean[L][B];\\n        int ans[][] = new int[L][B];\\n        \\n        for(int i = 0 ; i < L ; i++) {\\n            for(int j = 0 ; j < B ; j++) {\\n                if(M[i][j] == 1) {\\n                    queue.add(new int[]{i , j , 0});\\n                }\\n            }\\n        }\\n        while(!queue.isEmpty()) {\\n            int[] node = queue.remove();\\n            ans[node[0]][node[1]] = node[2];\\n            for(int d[] : dir) {\\n                int x = node[0] + d[0];\\n                int y = node[1] + d[1];        \\n                if(x >= 0 && x < L && y >= 0 && y < B && !visi[x][y] && M[x][y] == 0) {\\n                    queue.add(new int[]{x , y , node[2] + 1});\\n                    visi[x][y] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234299,
                "title": "c-multi-source-bfs-from-cells-having-water",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m,int n,int x,int y,vector<vector<int>>& visited){\\n        if(x>=0 && x<m && y>=0 && y<n && visited[x][y]==0)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        int m = isWater.size();\\n        int n = isWater[0].size();\\n        \\n        vector<int> dx = {-1,0,1,0};\\n        vector<int> dy = {0,-1,0,1};\\n        \\n        vector<vector<int>> visited(m,vector<int>(n,0));\\n        vector<vector<int>> dp(m,vector<int>(n,1001));\\n        \\n        \\n        queue<pair<int,int>> q;\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(isWater[i][j]){\\n                    dp[i][j]=0;\\n                    q.push({i,j});\\n                    visited[i][j]=true;\\n                }\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> cell = q.front();\\n            q.pop();\\n            int x = cell.first;\\n            int y = cell.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                if(isValid(m,n,x+dx[i],y+dy[i],visited))\\n                {\\n                    dp[x+dx[i]][y+dy[i]] = dp[x][y]+1;\\n                    q.push({x+dx[i],y+dy[i]});\\n                    visited[x+dx[i]][y+dy[i]] = 1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m,int n,int x,int y,vector<vector<int>>& visited){\\n        if(x>=0 && x<m && y>=0 && y<n && visited[x][y]==0)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        \\n        int m = isWater.size();\\n        int n = isWater[0].size();\\n        \\n        vector<int> dx = {-1,0,1,0};\\n        vector<int> dy = {0,-1,0,1};\\n        \\n        vector<vector<int>> visited(m,vector<int>(n,0));\\n        vector<vector<int>> dp(m,vector<int>(n,1001));\\n        \\n        \\n        queue<pair<int,int>> q;\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(isWater[i][j]){\\n                    dp[i][j]=0;\\n                    q.push({i,j});\\n                    visited[i][j]=true;\\n                }\\n        \\n        while(!q.empty())\\n        {\\n            pair<int,int> cell = q.front();\\n            q.pop();\\n            int x = cell.first;\\n            int y = cell.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                if(isValid(m,n,x+dx[i],y+dy[i],visited))\\n                {\\n                    dp[x+dx[i]][y+dy[i]] = dp[x][y]+1;\\n                    q.push({x+dx[i],y+dy[i]});\\n                    visited[x+dx[i]][y+dy[i]] = 1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220716,
                "title": "python-bfs-unclear-instructions-must-have-dif-of-one-if-possible-comments",
                "content": "You have to have a difference of one if possible, else difference of zero.\\n\\nI solved this with DFS first before realizing it takes too much time.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        def getNeighborhood(i,j): # get l, r, u, d if possible\\n            neighbors = []\\n            if i+1 < N: neighbors.append((i+1,j))\\n            if i-1 > -1: neighbors.append((i-1,j))\\n            if j+1 < M: neighbors.append((i,j+1))\\n            if j-1 > -1: neighbors.append((i,j-1))\\n            return neighbors\\n        \\n        \\n        N = len(isWater); M = len(isWater[0])\\n        grid = [[float(\"inf\") if not isWater[i][j] else 0 for j in range(len(isWater[0]))] for i in range(len(isWater)) ]\\n        waters = deque([])\\n        \\n        for i in range(N): # get all waters\\n            for j in range(M):\\n                if isWater[i][j]: waters.append((i,j))\\n                    \\n        while waters: # BFS\\n            x, y = waters.popleft()\\n            for i, j in getNeighborhood(x,y):\\n                if not isWater[i][j] and abs(grid[x][y] - grid[i][j]) > 1:  # if the same/ or + 1 difference ignore\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[x][y] + 1 # increase by one from it\\'s neighbor\\n\\t\\t\\t\\t\\twaters.append((i,j)) # if difference greater than 1 exists, revisit it\\n                \\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        def getNeighborhood(i,j): # get l, r, u, d if possible\\n            neighbors = []\\n            if i+1 < N: neighbors.append((i+1,j))\\n            if i-1 > -1: neighbors.append((i-1,j))\\n            if j+1 < M: neighbors.append((i,j+1))\\n            if j-1 > -1: neighbors.append((i,j-1))\\n            return neighbors\\n        \\n        \\n        N = len(isWater); M = len(isWater[0])\\n        grid = [[float(\"inf\") if not isWater[i][j] else 0 for j in range(len(isWater[0]))] for i in range(len(isWater)) ]\\n        waters = deque([])\\n        \\n        for i in range(N): # get all waters\\n            for j in range(M):\\n                if isWater[i][j]: waters.append((i,j))\\n                    \\n        while waters: # BFS\\n            x, y = waters.popleft()\\n            for i, j in getNeighborhood(x,y):\\n                if not isWater[i][j] and abs(grid[x][y] - grid[i][j]) > 1:  # if the same/ or + 1 difference ignore\\n\\t\\t\\t\\t\\tgrid[i][j] = grid[x][y] + 1 # increase by one from it\\'s neighbor\\n\\t\\t\\t\\t\\twaters.append((i,j)) # if difference greater than 1 exists, revisit it\\n                \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145169,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& w) {\\n        int n=w.size();\\n        int m=w[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,-1));\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(w[i][j]==1){\\n                    ans[i][j]=0;\\n                    q.push(make_pair(i,j));\\n                }\\n            }\\n        }\\n        while(!q.empty()){\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            if(i>0){\\n                if(ans[i-1][j]==-1){\\n                    ans[i-1][j]=ans[i][j]+1;\\n                    q.push(make_pair(i-1,j));\\n                }\\n            }\\n            if(j>0){\\n                if(ans[i][j-1]==-1){\\n                    ans[i][j-1]=ans[i][j]+1;\\n                    q.push(make_pair(i,j-1));\\n                }\\n            }\\n            if(i<n-1){\\n                if(ans[i+1][j]==-1){\\n                    ans[i+1][j]=ans[i][j]+1;\\n                    q.push(make_pair(i+1,j));\\n                }\\n            }\\n            if(j<m-1){\\n                if(ans[i][j+1]==-1){\\n                    ans[i][j+1]=ans[i][j]+1;\\n                    q.push(make_pair(i,j+1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& w) {\\n        int n=w.size();\\n        int m=w[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,-1));\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(w[i][j]==1){\\n                    ans[i][j]=0;\\n                    q.push(make_pair(i,j));\\n                }\\n            }\\n        }\\n        while(!q.empty()){\\n            int i=q.front().first;\\n            int j=q.front().second;\\n            q.pop();\\n            if(i>0){\\n                if(ans[i-1][j]==-1){\\n                    ans[i-1][j]=ans[i][j]+1;\\n                    q.push(make_pair(i-1,j));\\n                }\\n            }\\n            if(j>0){\\n                if(ans[i][j-1]==-1){\\n                    ans[i][j-1]=ans[i][j]+1;\\n                    q.push(make_pair(i,j-1));\\n                }\\n            }\\n            if(i<n-1){\\n                if(ans[i+1][j]==-1){\\n                    ans[i+1][j]=ans[i][j]+1;\\n                    q.push(make_pair(i+1,j));\\n                }\\n            }\\n            if(j<m-1){\\n                if(ans[i][j+1]==-1){\\n                    ans[i][j+1]=ans[i][j]+1;\\n                    q.push(make_pair(i,j+1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142677,
                "title": "python-runtime-faster-than-98-and-memory-used-less-than-96-comments-included",
                "content": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        \\n        # height = 0 if isWater is 1, height = -1 otherwise\\n        height = [[(isWater[i][j]-1) for j in range(n)] for i in range(m)]\\n        \\n        # let location be the list of cell coordinates where height level=0\\n        location = []\\n        for i in range(m):\\n            for j in range(n):\\n                if height[i][j]==0:\\n                    location.append([i,j])\\n        level = 0\\n        \\n        # for cells in the location list, if its adjacent cell\\'s height is unassigned (-1),\\n        # set the adjacent cell\\'s height to be level+1,\\n        # then gather these adjacent cells\\' coordinates as the new location\\n        # when location list is empty, it means all the cells are assigned with positive heights\\n        while location!=[]:\\n            level += 1\\n            new_location = []\\n            for pos in location:\\n                i = pos[0]\\n                j = pos[1]\\n                if i!=0 and height[i-1][j]<0:\\n                    height[i-1][j] = level\\n                    new_location.append([i-1,j])\\n                if j!=0 and height[i][j-1]<0:\\n                    height[i][j-1] = level\\n                    new_location.append([i,j-1])\\n                if i!=m-1 and height[i+1][j]<0:\\n                    height[i+1][j] = level\\n                    new_location.append([i+1,j])\\n                if j!=n-1 and height[i][j+1]<0:\\n                    height[i][j+1] = level\\n                    new_location.append([i,j+1])\\n            \\n            location = new_location\\n            \\n        return height\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        \\n        # height = 0 if isWater is 1, height = -1 otherwise\\n        height = [[(isWater[i][j]-1) for j in range(n)] for i in range(m)]\\n        \\n        # let location be the list of cell coordinates where height level=0\\n        location = []\\n        for i in range(m):\\n            for j in range(n):\\n                if height[i][j]==0:\\n                    location.append([i,j])\\n        level = 0\\n        \\n        # for cells in the location list, if its adjacent cell\\'s height is unassigned (-1),\\n        # set the adjacent cell\\'s height to be level+1,\\n        # then gather these adjacent cells\\' coordinates as the new location\\n        # when location list is empty, it means all the cells are assigned with positive heights\\n        while location!=[]:\\n            level += 1\\n            new_location = []\\n            for pos in location:\\n                i = pos[0]\\n                j = pos[1]\\n                if i!=0 and height[i-1][j]<0:\\n                    height[i-1][j] = level\\n                    new_location.append([i-1,j])\\n                if j!=0 and height[i][j-1]<0:\\n                    height[i][j-1] = level\\n                    new_location.append([i,j-1])\\n                if i!=m-1 and height[i+1][j]<0:\\n                    height[i+1][j] = level\\n                    new_location.append([i+1,j])\\n                if j!=n-1 and height[i][j+1]<0:\\n                    height[i][j+1] = level\\n                    new_location.append([i,j+1])\\n            \\n            location = new_location\\n            \\n        return height\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140086,
                "title": "weeb-does-python-bfs",
                "content": "\\n\\tclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        row, col = len(isWater), len(isWater[0])\\n        queue, visited = deque([]), set([])\\n        for x in range(row):\\n            for y in range(col):\\n                if isWater[x][y] == 1:\\n                    isWater[x][y] = 0\\n                    queue.append((x,y))\\n                    visited.add((x,y))\\n        \\n        while queue:\\n            x, y = queue.popleft()\\n            for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\\n                if (nx,ny) in visited: continue\\n                if 0<=nx<row and 0<=ny<col:\\n                    isWater[nx][ny] = isWater[x][y] + 1 \\n                    visited.add((nx,ny))\\n                    queue.append((nx,ny))\\n        \\n        return isWater\\n\\nI\\'m a weeb, obviously I\\'ll share some anime\\n# This time try watching ***Gotoubun no Hanayome(The Quintessential Quintuplets)***\\n\\n# Genres: Harem, Romantic comedy\\n# Episodes: 24 (2 seasons)\\n\\nGuess what, **season 3 is confirmed.**\\nBUT, there is still no official release date as of the time of this post\\nAnyways, go check out this anime. Its wholesome, I promise.\\n\\nFor the ones that know this anime, Miku is the best and if u agree then pls upvote this post.\\nOh yea and dont downvote if u hate Miku. (Although i doubt that)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n\\tclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        row, col = len(isWater), len(isWater[0])\\n        queue, visited = deque([]), set([])\\n        for x in range(row):\\n            for y in range(col):\\n                if isWater[x][y] == 1:\\n                    isWater[x][y] = 0\\n                    queue.append((x,y))\\n                    visited.add((x,y))\\n        \\n        while queue:\\n            x, y = queue.popleft()\\n            for nx,ny in [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]:\\n                if (nx,ny) in visited: continue\\n                if 0<=nx<row and 0<=ny<col:\\n                    isWater[nx][ny] = isWater[x][y] + 1 \\n                    visited.add((nx,ny))\\n                    queue.append((nx,ny))\\n        \\n        return isWater\\n\\nI\\'m a weeb, obviously I\\'ll share some anime\\n# This time try watching ***Gotoubun no Hanayome(The Quintessential Quintuplets)***\\n\\n# Genres: Harem, Romantic comedy\\n# Episodes: 24 (2 seasons)\\n\\nGuess what, **season 3 is confirmed.**\\nBUT, there is still no official release date as of the time of this post\\nAnyways, go check out this anime. Its wholesome, I promise.\\n\\nFor the ones that know this anime, Miku is the best and if u agree then pls upvote this post.\\nOh yea and dont downvote if u hate Miku. (Although i doubt that)",
                "codeTag": "Java"
            },
            {
                "id": 1137309,
                "title": "bfs-but-corrected-easy-to-understand",
                "content": "TLE solution\\nbasically using bfs with no brain.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector <pair<int,int>> vec;\\n        for(int i=0;i<isWater.size();i++)\\n        {\\n            for(int j=0;j<isWater[i].size();j++)\\n            {\\n                if(isWater[i][j]==1) {isWater[i][j]=0; vec.push_back(make_pair(i,j));}\\n                else isWater[i][j]=1e9;\\n                \\n            }\\n        }\\n        cout<<1;\\n        vector <pair<int,int> > v={{0,1},{1,0},{-1,0},{0,-1}};\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            cout<<i;\\n            queue <pair<int,int>> q;\\n            q.push({vec[i].first,vec[i].second});\\n            int c=0;\\n            while(q.size()!=0)\\n            {\\n                cout<<q.size()<<endl;\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    if(v[j].first+p.first>=0&&v[j].first+p.first<isWater.size()&&v[j].second+p.second>=0&&v[j].second+p.second<isWater[0].size())\\n                    {\\n                        \\n                        if(isWater[v[j].first+p.first][v[j].second+p.second]>isWater[p.first][p.second]+1)\\n                        {\\n                            q.push({v[j].first+p.first,v[j].second+p.second});\\n                            isWater[v[j].first+p.first][v[j].second+p.second]=isWater[p.first][p.second]+1;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n       \\n        return isWater;\\n        \\n        \\n    }\\n};\\n```\\n\\ncorrected solution \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        queue <pair<int,int>> q;\\n        for(int i=0;i<isWater.size();i++)\\n        {\\n            for(int j=0;j<isWater[i].size();j++)\\n            {\\n                if(isWater[i][j]==1) {isWater[i][j]=0; q.push(make_pair(i,j));}\\n                else isWater[i][j]=-1;\\n                \\n            }\\n        }\\n        \\n        vector <pair<int,int> > v={{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        \\n        //int c=q.size();\\n        while(q.size()!=0)\\n        {\\n            pair<int,int> p;\\n            p=q.front();\\n            q.pop();\\n            for(int j=0;j<4;j++)\\n            {\\n                if(p.first+v[j].first>=0&&p.first+v[j].first<isWater.size()&&p.second+v[j].second>=0&&p.second+v[j].second<isWater[0].size()&&isWater[p.first+v[j].first][p.second+v[j].second]==-1)\\n                {\\n                    q.push({p.first+v[j].first,p.second+v[j].second});\\n                    isWater[p.first+v[j].first][p.second+v[j].second]=isWater[p.first][p.second]+1;\\n                }   \\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector <pair<int,int>> vec;\\n        for(int i=0;i<isWater.size();i++)\\n        {\\n            for(int j=0;j<isWater[i].size();j++)\\n            {\\n                if(isWater[i][j]==1) {isWater[i][j]=0; vec.push_back(make_pair(i,j));}\\n                else isWater[i][j]=1e9;\\n                \\n            }\\n        }\\n        cout<<1;\\n        vector <pair<int,int> > v={{0,1},{1,0},{-1,0},{0,-1}};\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            cout<<i;\\n            queue <pair<int,int>> q;\\n            q.push({vec[i].first,vec[i].second});\\n            int c=0;\\n            while(q.size()!=0)\\n            {\\n                cout<<q.size()<<endl;\\n                pair<int,int> p=q.front();\\n                q.pop();\\n                for(int j=0;j<4;j++)\\n                {\\n                    if(v[j].first+p.first>=0&&v[j].first+p.first<isWater.size()&&v[j].second+p.second>=0&&v[j].second+p.second<isWater[0].size())\\n                    {\\n                        \\n                        if(isWater[v[j].first+p.first][v[j].second+p.second]>isWater[p.first][p.second]+1)\\n                        {\\n                            q.push({v[j].first+p.first,v[j].second+p.second});\\n                            isWater[v[j].first+p.first][v[j].second+p.second]=isWater[p.first][p.second]+1;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n        }\\n       \\n        return isWater;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        queue <pair<int,int>> q;\\n        for(int i=0;i<isWater.size();i++)\\n        {\\n            for(int j=0;j<isWater[i].size();j++)\\n            {\\n                if(isWater[i][j]==1) {isWater[i][j]=0; q.push(make_pair(i,j));}\\n                else isWater[i][j]=-1;\\n                \\n            }\\n        }\\n        \\n        vector <pair<int,int> > v={{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        \\n        //int c=q.size();\\n        while(q.size()!=0)\\n        {\\n            pair<int,int> p;\\n            p=q.front();\\n            q.pop();\\n            for(int j=0;j<4;j++)\\n            {\\n                if(p.first+v[j].first>=0&&p.first+v[j].first<isWater.size()&&p.second+v[j].second>=0&&p.second+v[j].second<isWater[0].size()&&isWater[p.first+v[j].first][p.second+v[j].second]==-1)\\n                {\\n                    q.push({p.first+v[j].first,p.second+v[j].second});\\n                    isWater[p.first+v[j].first][p.second+v[j].second]=isWater[p.first][p.second]+1;\\n                }   \\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1116893,
                "title": "python-simple-bfs-faster-than-100",
                "content": "```\\nclass Solution:\\n    def highestPeak(self, iswater: List[List[int]]) -> List[List[int]]:\\n        \\n        newiswater = [[None] * len(iswater[0]) for i in range(len(iswater))]\\n        deq = collections.deque([])\\n        \\n        for row in range(len(iswater)):\\n            for col in range(len(iswater[0])):\\n                if iswater[row][col] == 1:\\n                    deq.append([row, col])\\n                    newiswater[row][col] = 0\\n        \\n        while deq:\\n            row, col = deq.popleft()\\n            for new_row, new_col in (row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1):\\n                if 0 <= new_row <= len(newiswater) - 1 and 0 <= new_col <= len(newiswater[0]) - 1 and newiswater[new_row][new_col] is None:\\n                    newiswater[new_row][new_col] = newiswater[row][col] + 1\\n                    deq.append([new_row, new_col])\\n                        \\n        return newiswater\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, iswater: List[List[int]]) -> List[List[int]]:\\n        \\n        newiswater = [[None] * len(iswater[0]) for i in range(len(iswater))]\\n        deq = collections.deque([])\\n        \\n        for row in range(len(iswater)):\\n            for col in range(len(iswater[0])):\\n                if iswater[row][col] == 1:\\n                    deq.append([row, col])\\n                    newiswater[row][col] = 0\\n        \\n        while deq:\\n            row, col = deq.popleft()\\n            for new_row, new_col in (row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1):\\n                if 0 <= new_row <= len(newiswater) - 1 and 0 <= new_col <= len(newiswater[0]) - 1 and newiswater[new_row][new_col] is None:\\n                    newiswater[new_row][new_col] = newiswater[row][col] + 1\\n                    deq.append([new_row, new_col])\\n                        \\n        return newiswater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105246,
                "title": "bfs-java",
                "content": "```\\nclass Solution {\\n    static int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    static int INF = 10000;\\n    \\n    public int[][] highestPeak(int[][] isWater) {\\n        int row = isWater.length, col = isWater[0].length;\\n        int[][] res = new int[row][col];\\n        boolean[][] seen = new boolean[row][col];\\n        Queue<int[]> qu = new LinkedList<>();\\n        \\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(isWater[i][j] == 1) {\\n                    res[i][j] = 0;\\n                    qu.add(new int[]{i, j});\\n                    seen[i][j] = true;\\n                }\\n                else {\\n                    res[i][j] = INF;\\n                }\\n            }\\n        }\\n        \\n        int LEVEL = 0;\\n        \\n        while(!qu.isEmpty()) {\\n            int sz = qu.size();\\n            while(sz-- > 0) {\\n                int[] pos = qu.poll();\\n                for(int[] dir:dirs) {\\n                    int x = pos[0] + dir[0], y = pos[1] + dir[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || seen[x][y])\\n                        continue;\\n                    res[x][y] = LEVEL + 1;\\n                    seen[x][y] = true;\\n                    qu.add(new int[]{x, y});\\n                }\\n            }\\n            LEVEL++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int[][] dirs = {{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 1082283,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int r, c;\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        r=isWater.size();\\n        c=isWater[0].size();\\n        vector<vector<bool> >visited(r, vector<bool>(c,false));\\n        queue<pair<int, int>> q;\\n        for(int i=0;i<isWater.size();i++){\\n           for(int j=0; j<isWater[0].size();j++){\\n               if(isWater[i][j] == 1) {\\n                   isWater[i][j] = 0;\\n                   visited[i][j] = true;\\n                   q.push({i, j});\\n               }\\n           }\\n        }\\n        int i, j;\\n        while(!q.empty()){\\n            pair<int, int> top = q.front();\\n            q.pop();\\n            i=top.first;j=top.second;\\n            visited[i][j] = true;\\n            if(isSafe(i-1, j) && !visited[i-1][j]) {\\n                isWater[i-1][j]=isWater[i][j]+1;\\n                visited[i-1][j]=true;\\n                q.push({i-1, j});\\n            }\\n            if(isSafe(i+1, j) && !visited[i+1][j]) {\\n                isWater[i+1][j]=isWater[i][j]+1;\\n                visited[i+1][j]=true;\\n                q.push({i+1, j});\\n            }\\n            if(isSafe(i, j-1) && !visited[i][j-1]){\\n                isWater[i][j-1]=isWater[i][j]+1;\\n                visited[i][j-1]=true;\\n                q.push({i, j-1});\\n            } \\n            if(isSafe(i, j+1) && !visited[i][j+1]) {\\n                isWater[i][j+1]=isWater[i][j]+1;\\n                visited[i][j+1]=true;\\n                q.push({i, j+1});\\n            }\\n        }\\n        return isWater;\\n    }\\n    \\n    bool isSafe(int i, int j){\\n        return i>=0 && i<r && j>=0 && j<c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r, c;\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        r=isWater.size();\\n        c=isWater[0].size();\\n        vector<vector<bool> >visited(r, vector<bool>(c,false));\\n        queue<pair<int, int>> q;\\n        for(int i=0;i<isWater.size();i++){\\n           for(int j=0; j<isWater[0].size();j++){\\n               if(isWater[i][j] == 1) {\\n                   isWater[i][j] = 0;\\n                   visited[i][j] = true;\\n                   q.push({i, j});\\n               }\\n           }\\n        }\\n        int i, j;\\n        while(!q.empty()){\\n            pair<int, int> top = q.front();\\n            q.pop();\\n            i=top.first;j=top.second;\\n            visited[i][j] = true;\\n            if(isSafe(i-1, j) && !visited[i-1][j]) {\\n                isWater[i-1][j]=isWater[i][j]+1;\\n                visited[i-1][j]=true;\\n                q.push({i-1, j});\\n            }\\n            if(isSafe(i+1, j) && !visited[i+1][j]) {\\n                isWater[i+1][j]=isWater[i][j]+1;\\n                visited[i+1][j]=true;\\n                q.push({i+1, j});\\n            }\\n            if(isSafe(i, j-1) && !visited[i][j-1]){\\n                isWater[i][j-1]=isWater[i][j]+1;\\n                visited[i][j-1]=true;\\n                q.push({i, j-1});\\n            } \\n            if(isSafe(i, j+1) && !visited[i][j+1]) {\\n                isWater[i][j+1]=isWater[i][j]+1;\\n                visited[i][j+1]=true;\\n                q.push({i, j+1});\\n            }\\n        }\\n        return isWater;\\n    }\\n    \\n    bool isSafe(int i, int j){\\n        return i>=0 && i<r && j>=0 && j<c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081900,
                "title": "runtime-53-ms-faster-than-100-00-easy-java-solution-using-bfs",
                "content": "```\\nclass Solution {\\n    \\n    static class Pair{\\n        int x,y;\\n        Pair(int x,int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n    }\\n\\t//using pair class to store the cordinates of matrix\\n\\t\\n    static int dx[]  ={1,0,-1,0};\\n    static int dy[]  ={0,1,0,-1};\\n\\t//four possible directions to move\\n\\t\\n    public int[][] highestPeak(int[][] ar) {\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        \\n        boolean vis[][] = new boolean[ar.length][ar[0].length];\\n\\t\\t//boolean array to store visited cordinates\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            for(int j=0;j<ar[0].length;j++)\\n            {\\n                if(ar[i][j]==1)\\n                {q.add(new Pair(i,j));ar[i][j]=0;vis[i][j]=true;}//adding water cordinate to queue and changing its value to 0,mark the cordinate as true\\n            }\\n        }\\n        \\n        while(q.size()>0)//simple bfs\\n        {\\n            Pair tmp = q.poll();\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nx = tmp.x+dx[i];\\n                int ny = tmp.y+dy[i];\\n                \\n                if(nx>=0 && nx<ar.length && ny>=0 && ny<ar[0].length && !vis[nx][ny])\\n                {\\n                    q.add(new Pair(nx,ny));\\n                    vis[nx][ny] = true;\\n                    ar[nx][ny] = 1+ar[tmp.x][tmp.y];\\n                }\\n            }\\n        }\\n        return ar;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static class Pair{\\n        int x,y;\\n        Pair(int x,int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n    }\\n\\t//using pair class to store the cordinates of matrix\\n\\t\\n    static int dx[]  ={1,0,-1,0};\\n    static int dy[]  ={0,1,0,-1};\\n\\t//four possible directions to move\\n\\t\\n    public int[][] highestPeak(int[][] ar) {\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        \\n        boolean vis[][] = new boolean[ar.length][ar[0].length];\\n\\t\\t//boolean array to store visited cordinates\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            for(int j=0;j<ar[0].length;j++)\\n            {\\n                if(ar[i][j]==1)\\n                {q.add(new Pair(i,j));ar[i][j]=0;vis[i][j]=true;}//adding water cordinate to queue and changing its value to 0,mark the cordinate as true\\n            }\\n        }\\n        \\n        while(q.size()>0)//simple bfs\\n        {\\n            Pair tmp = q.poll();\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                int nx = tmp.x+dx[i];\\n                int ny = tmp.y+dy[i];\\n                \\n                if(nx>=0 && nx<ar.length && ny>=0 && ny<ar[0].length && !vis[nx][ny])\\n                {\\n                    q.add(new Pair(nx,ny));\\n                    vis[nx][ny] = true;\\n                    ar[nx][ny] = 1+ar[tmp.x][tmp.y];\\n                }\\n            }\\n        }\\n        return ar;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078889,
                "title": "c-multisource-bfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n      int m = isWater.size();\\n      if (m == 0) return {};\\n      int n = isWater[0].size();\\n      vector<vector<int>> res(m, vector<int>(n));\\n\\t  \\n      queue<pair<int, int>> q;\\n\\t  // add all positions of water into queue\\n      for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n          if (isWater[i][j]) {\\n            q.emplace(i, j);\\n          }\\n        }\\n      }\\n\\t  \\n\\t  // expand from each position with water\\n      while (!q.empty()) {\\n        int z = q.size();\\n        for (int i = 0; i < z; ++i) {\\n          auto [x, y] = q.front();\\n          q.pop();\\n          if (x-1 >= 0 and res[x-1][y] == 0 and !isWater[x-1][y]) {\\n            q.emplace(x-1, y);\\n            res[x-1][y] = res[x][y]+1;\\n          }\\n          if (y-1 >= 0 and res[x][y-1] == 0 and !isWater[x][y-1]) {\\n            q.emplace(x, y-1);\\n            res[x][y-1] = res[x][y] + 1;\\n          }\\n          if (x+1 < m and res[x+1][y] == 0 and !isWater[x+1][y]) {\\n            q.emplace(x+1, y);\\n            res[x+1][y] = res[x][y] + 1;\\n          }\\n          if (y+1 < n and res[x][y+1] == 0 and !isWater[x][y+1]) {\\n            q.emplace(x, y+1);\\n            res[x][y+1] = res[x][y] + 1;\\n          }\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n      int m = isWater.size();\\n      if (m == 0) return {};\\n      int n = isWater[0].size();\\n      vector<vector<int>> res(m, vector<int>(n));\\n\\t  \\n      queue<pair<int, int>> q;\\n\\t  // add all positions of water into queue\\n      for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n          if (isWater[i][j]) {\\n            q.emplace(i, j);\\n          }\\n        }\\n      }\\n\\t  \\n\\t  // expand from each position with water\\n      while (!q.empty()) {\\n        int z = q.size();\\n        for (int i = 0; i < z; ++i) {\\n          auto [x, y] = q.front();\\n          q.pop();\\n          if (x-1 >= 0 and res[x-1][y] == 0 and !isWater[x-1][y]) {\\n            q.emplace(x-1, y);\\n            res[x-1][y] = res[x][y]+1;\\n          }\\n          if (y-1 >= 0 and res[x][y-1] == 0 and !isWater[x][y-1]) {\\n            q.emplace(x, y-1);\\n            res[x][y-1] = res[x][y] + 1;\\n          }\\n          if (x+1 < m and res[x+1][y] == 0 and !isWater[x+1][y]) {\\n            q.emplace(x+1, y);\\n            res[x+1][y] = res[x][y] + 1;\\n          }\\n          if (y+1 < n and res[x][y+1] == 0 and !isWater[x][y+1]) {\\n            q.emplace(x, y+1);\\n            res[x][y+1] = res[x][y] + 1;\\n          }\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076965,
                "title": "javascript-bfs",
                "content": "```\\n/**\\n * @param {number[][]} isWater\\n * @return {number[][]}\\n */\\nvar highestPeak = function(isWater) {\\n    let arr = Array(isWater.length);\\n    let queue = [];\\n    let mr = isWater.length;\\n    let mc = isWater[0].length;\\n    for(let i = 0; i < mr; i++){\\n        arr[i] = Array(mc).fill(-1);\\n        for(let j = 0; j < mc; j++){\\n            if(isWater[i][j] === 1){\\n                queue.push([i,j]);\\n                arr[i][j] = 0;\\n            }else{\\n                arr[i][j] = -1;\\n            }\\n        }\\n    }\\n    let moves = [[-1,0],[1,0],[0,-1],[0,1]];\\n    let i = 0;\\n    while(i < queue.length){\\n        let [r,c] = queue[i];\\n        for(let move of moves){\\n            let nr = r + move[0];\\n            let nc = c + move[1];\\n            if(nr < 0 || nc < 0 || nr >= mr || nc >= mc || arr[nr][nc] != -1){\\n                continue;\\n            }\\n            arr[nr][nc] = arr[r][c] + 1;\\n            queue.push([nr,nc]);\\n        }\\n        i++;\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} isWater\\n * @return {number[][]}\\n */\\nvar highestPeak = function(isWater) {\\n    let arr = Array(isWater.length);\\n    let queue = [];\\n    let mr = isWater.length;\\n    let mc = isWater[0].length;\\n    for(let i = 0; i < mr; i++){\\n        arr[i] = Array(mc).fill(-1);\\n        for(let j = 0; j < mc; j++){\\n            if(isWater[i][j] === 1){\\n                queue.push([i,j]);\\n                arr[i][j] = 0;\\n            }else{\\n                arr[i][j] = -1;\\n            }\\n        }\\n    }\\n    let moves = [[-1,0],[1,0],[0,-1],[0,1]];\\n    let i = 0;\\n    while(i < queue.length){\\n        let [r,c] = queue[i];\\n        for(let move of moves){\\n            let nr = r + move[0];\\n            let nc = c + move[1];\\n            if(nr < 0 || nc < 0 || nr >= mr || nc >= mc || arr[nr][nc] != -1){\\n                continue;\\n            }\\n            arr[nr][nc] = arr[r][c] + 1;\\n            queue.push([nr,nc]);\\n        }\\n        i++;\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074974,
                "title": "java-bfs-solution-o-m-n",
                "content": "The idea is similar to [200. Number of Islands\\n](https://leetcode.com/problems/number-of-islands/)\\n\\nStart the BFS from water. In each round, increase the height by 1.\\n\\n\\n```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int[] dir = new int[]{ 0, 1, 0, -1, 0 };\\n        int r = isWater.length, c = isWater[0].length;\\n        int[][] ans = new int[r][c];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(isWater[i][j] == 1) queue.add(new int[]{ i, j });\\n                else ans[i][j] = -1;\\n            }\\n        }\\n        int round = 1;\\n        while(!queue.isEmpty()) {\\n            for(int size = queue.size(); size > 0; size--) {\\n                int[] cur = queue.poll();\\n                int x = cur[0], y = cur[1];\\n                for(int d = 0; d < 4; d++) {\\n                    int xx = x + dir[d], yy = y + dir[d+1];\\n                    if(0 <= xx && xx < r && 0 <= yy && yy < c && ans[xx][yy] == -1) {\\n                        ans[xx][yy] = round;\\n                        queue.add(new int[]{ xx, yy });\\n                    }\\n                }\\n            }\\n            round++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nTime: ```O(M*N)```\\nSpace: ```O(M*N)```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int[] dir = new int[]{ 0, 1, 0, -1, 0 };\\n        int r = isWater.length, c = isWater[0].length;\\n        int[][] ans = new int[r][c];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(isWater[i][j] == 1) queue.add(new int[]{ i, j });\\n                else ans[i][j] = -1;\\n            }\\n        }\\n        int round = 1;\\n        while(!queue.isEmpty()) {\\n            for(int size = queue.size(); size > 0; size--) {\\n                int[] cur = queue.poll();\\n                int x = cur[0], y = cur[1];\\n                for(int d = 0; d < 4; d++) {\\n                    int xx = x + dir[d], yy = y + dir[d+1];\\n                    if(0 <= xx && xx < r && 0 <= yy && yy < c && ans[xx][yy] == -1) {\\n                        ans[xx][yy] = round;\\n                        queue.add(new int[]{ xx, yy });\\n                    }\\n                }\\n            }\\n            round++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```O(M*N)```\n```O(M*N)```",
                "codeTag": "Java"
            },
            {
                "id": 1074738,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    int[] dx = new int[] {0, 1, 0, -1};\\n    int[] dy = new int[] {1, 0, -1, 0};\\n    \\n    public int[][] highestPeak(int[][] mat) {\\n        int r = mat.length, c = mat[0].length;\\n        int[][] result = new int[r][c];\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[r][c];\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(mat[i][j] == 1) { \\n                    visited[i][j] = true;\\n                    queue.offer(new int[] {i, j});\\n                }   \\n            }\\n        }\\n        \\n        while(queue.size() != 0) {\\n            int[] curr = queue.poll();\\n            int x = curr[0], y = curr[1];\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i], ny = y + dy[i];\\n                if(nx >= 0 && nx < r && ny >= 0 && ny < c && !visited[nx][ny]) {\\n                    visited[nx][ny] = true;\\n                    queue.offer(new int[] {nx, ny});\\n                    result[nx][ny] = result[x][y] + 1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] dx = new int[] {0, 1, 0, -1};\\n    int[] dy = new int[] {1, 0, -1, 0};\\n    \\n    public int[][] highestPeak(int[][] mat) {\\n        int r = mat.length, c = mat[0].length;\\n        int[][] result = new int[r][c];\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][] visited = new boolean[r][c];\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                if(mat[i][j] == 1) { \\n                    visited[i][j] = true;\\n                    queue.offer(new int[] {i, j});\\n                }   \\n            }\\n        }\\n        \\n        while(queue.size() != 0) {\\n            int[] curr = queue.poll();\\n            int x = curr[0], y = curr[1];\\n            for(int i = 0; i < 4; i++) {\\n                int nx = x + dx[i], ny = y + dy[i];\\n                if(nx >= 0 && nx < r && ny >= 0 && ny < c && !visited[nx][ny]) {\\n                    visited[nx][ny] = true;\\n                    queue.offer(new int[] {nx, ny});\\n                    result[nx][ny] = result[x][y] + 1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074702,
                "title": "ruby-bfs",
                "content": "```\\ndef highest_peak(is_water)\\n  queue = []\\n  is_water.size.times do |i|\\n    is_water[0].size.times do |j|\\n      if is_water[i][j] == 1\\n        is_water[i][j] = 0\\n        queue.push([i, j])\\n      else\\n        is_water[i][j] = \\'*\\'\\n      end\\n    end\\n  end\\n  \\n  while queue.size > 0\\n    i, j = queue.shift\\n    \\n    if (i+1 < is_water.size && is_water[i+1][j] == \\'*\\')\\n      is_water[i+1][j] = is_water[i][j] + 1\\n      queue.push([i+1, j])\\n    end\\n    \\n    if (i-1 >= 0 && is_water[i-1][j] == \\'*\\')\\n      is_water[i-1][j] = is_water[i][j] + 1\\n      queue.push([i-1, j])\\n    end\\n    \\n    if (j+1 < is_water[0].size && is_water[i][j+1] == \\'*\\')\\n      is_water[i][j+1] = is_water[i][j] + 1\\n      queue.push([i, j+1])\\n    end\\n    \\n    if (j-1 >= 0 && is_water[i][j-1] == \\'*\\')\\n      is_water[i][j-1] = is_water[i][j] + 1\\n      queue.push([i, j-1])\\n    end\\n  end\\n  is_water\\nend\\n",
                "solutionTags": [],
                "code": "```\\ndef highest_peak(is_water)\\n  queue = []\\n  is_water.size.times do |i|\\n    is_water[0].size.times do |j|\\n      if is_water[i][j] == 1\\n        is_water[i][j] = 0\\n        queue.push([i, j])\\n      else\\n        is_water[i][j] = \\'*\\'\\n      end\\n    end\\n  end\\n  \\n  while queue.size > 0\\n    i, j = queue.shift\\n    \\n    if (i+1 < is_water.size && is_water[i+1][j] == \\'*\\')\\n      is_water[i+1][j] = is_water[i][j] + 1\\n      queue.push([i+1, j])\\n    end\\n    \\n    if (i-1 >= 0 && is_water[i-1][j] == \\'*\\')\\n      is_water[i-1][j] = is_water[i][j] + 1\\n      queue.push([i-1, j])\\n    end\\n    \\n    if (j+1 < is_water[0].size && is_water[i][j+1] == \\'*\\')\\n      is_water[i][j+1] = is_water[i][j] + 1\\n      queue.push([i, j+1])\\n    end\\n    \\n    if (j-1 >= 0 && is_water[i][j-1] == \\'*\\')\\n      is_water[i][j-1] = is_water[i][j] + 1\\n      queue.push([i, j-1])\\n    end\\n  end\\n  is_water\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1074643,
                "title": "java-very-clean-bfs-o-n-time-and-space-beats-83-time-and-space",
                "content": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater)\\n    {\\n        Queue<int []> todo = new LinkedList<int[]>();\\n        int [][] map = new int [isWater.length][isWater[0].length];\\n        boolean [][] visited = new boolean[isWater.length][isWater[0].length];\\n        int i, j, size;\\n        int [][] deltas = new int [][] {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        for (i = 0; i < isWater.length; i++)\\n        {\\n            for (j = 0; j < isWater[i].length; j++)\\n            {\\n                if (isWater[i][j] == 1)\\n                {\\n                    todo.offer(new int [] {i, j});\\n                }\\n            }\\n        }\\n        int [] tmp, next;\\n        int level = 0;\\n        while (!todo.isEmpty())\\n        {\\n            size = todo.size();\\n            for (i = 0; i < size; i++)\\n            {\\n                tmp = todo.poll();\\n                if (visited[tmp[0]][tmp[1]])\\n                {\\n                    continue;\\n                }\\n                map[tmp[0]][tmp[1]] = level;\\n                visited[tmp[0]][tmp[1]] = true;\\n                for (int [] delta : deltas)\\n                {\\n                    next = new int [] {tmp[0] + delta[0], tmp[1] + delta[1]};\\n                    if (isValid(isWater, next) && !visited[next[0]][next[1]])\\n                    {\\n                        todo.offer(next);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return map;\\n    }\\n    \\n    private boolean isValid(int [][] grid, int [] coords)\\n    {\\n        return coords[0] >= 0 && coords[0] < grid.length && coords[1] >= 0 && coords[1] < grid[0].length;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] highestPeak(int[][] isWater)\\n    {\\n        Queue<int []> todo = new LinkedList<int[]>();\\n        int [][] map = new int [isWater.length][isWater[0].length];\\n        boolean [][] visited = new boolean[isWater.length][isWater[0].length];\\n        int i, j, size;\\n        int [][] deltas = new int [][] {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1074638,
                "title": "dp-2d-matrix-two-direction-traversal",
                "content": "first go from top left to bottom right and update the min distance to its top and left water cell\\nsecond round go from bottom right to top left and update the min distance to its bottom and right water cell\\nsimilar problem [542. 01 Matrix](https://leetcode.com/problems/01-matrix/)\\n```\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        //dp: the distance to 0\\n        int m=isWater.size(),n=isWater[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        int mx=m*n;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(isWater[i][j]==0)\\n                    dp[i][j]=min(i?dp[i-1][j]:mx,j?dp[i][j-1]:mx)+1;\\n                else dp[i][j]=0;\\n            }\\n        }\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(isWater[i][j]==0){\\n                    dp[i][j]=min({dp[i][j],min(i+1<m?dp[i+1][j]:mx,j+1<n?dp[i][j+1]:mx)+1});\\n                }\\n                else dp[i][j]=0;\\n            }\\n        }\\n        return dp;\\n    }\\n```\\n\\t\\nI used the pattern in my post:\\n[https://leetcode.com/discuss/general-discussion/1069177/topic-3-dynamic-programming-patterns-i](https://leetcode.com/discuss/general-discussion/1069177/topic-3-dynamic-programming-patterns-i)",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        //dp: the distance to 0\\n        int m=isWater.size(),n=isWater[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        int mx=m*n;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(isWater[i][j]==0)\\n                    dp[i][j]=min(i?dp[i-1][j]:mx,j?dp[i][j-1]:mx)+1;\\n                else dp[i][j]=0;\\n            }\\n        }\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(isWater[i][j]==0){\\n                    dp[i][j]=min({dp[i][j],min(i+1<m?dp[i+1][j]:mx,j+1<n?dp[i][j+1]:mx)+1});\\n                }\\n                else dp[i][j]=0;\\n            }\\n        }\\n        return dp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074550,
                "title": "python3-simple-bfs-solution-o-mn",
                "content": "Add the water cells to a queue. It is guaranteed that atleast one water cell is present. Do BFS after that\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q = deque()\\n        for i in range(len(isWater)):\\n            for k in range(len(isWater[0])):\\n                if isWater[i][k] == 1:\\n                    q.append((i, k, 0))\\n        \\n        visited = set([(i, k) for i, k, _ in q])\\n        directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        while q:\\n            i, k, h = q.popleft()\\n            isWater[i][k] = h\\n            for x, y in directions:\\n                nxt_i, nxt_k = i + x, k + y\\n                if 0 <= nxt_i < len(isWater) and 0 <= nxt_k < len(isWater[0]) and (nxt_i, nxt_k) not in visited:\\n                    visited.add((nxt_i, nxt_k))\\n                    q.append((nxt_i, nxt_k, h+1))\\n        \\n        return isWater\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q = deque()\\n        for i in range(len(isWater)):\\n            for k in range(len(isWater[0])):\\n                if isWater[i][k] == 1:\\n                    q.append((i, k, 0))\\n        \\n        visited = set([(i, k) for i, k, _ in q])\\n        directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n        while q:\\n            i, k, h = q.popleft()\\n            isWater[i][k] = h\\n            for x, y in directions:\\n                nxt_i, nxt_k = i + x, k + y\\n                if 0 <= nxt_i < len(isWater) and 0 <= nxt_k < len(isWater[0]) and (nxt_i, nxt_k) not in visited:\\n                    visited.add((nxt_i, nxt_k))\\n                    q.append((nxt_i, nxt_k, h+1))\\n        \\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032996,
                "title": "java-muti-source-bfs",
                "content": "```\\nclass Solution {\\n    class Node{\\n        int i;\\n        int j;\\n        public Node(int i , int j){\\n            this.i = i;\\n            this.j = j;\\n        }\\n    }\\n    int[][] dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n    public int[][] highestPeak(int[][] arr) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int[][] ans = new int[rows][cols];\\n        Queue<Node> queue = new LinkedList<>();\\n        for(int i = 0 ; i < rows ; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                ans[i][j] = -2;\\n                if(arr[i][j] == 1){\\n                    ans[i][j] = 0;\\n                    queue.offer(new Node(i , j));\\n                }\\n            }\\n        }\\n        int counter = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node curNode = queue.poll();\\n                int i = curNode.i;\\n                int j = curNode.j;\\n                ans[i][j] = counter;\\n                for(int ptr = 0 ; ptr < 4 ; ptr++){\\n                    int I = i + dir[ptr][0];\\n                    int J = j + dir[ptr][1];\\n                    if(I < rows && I >= 0 && J < cols &&  J >= 0 && ans[I][J] == -2){\\n                        ans[I][J] = -1;\\n                        queue.offer(new Node(I , J));\\n                    }\\n                }\\n            }\\n            counter++;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```\\n***Please UpVote, if found useful :)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int i;\\n        int j;\\n        public Node(int i , int j){\\n            this.i = i;\\n            this.j = j;\\n        }\\n    }\\n    int[][] dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n    public int[][] highestPeak(int[][] arr) {\\n        int rows = arr.length;\\n        int cols = arr[0].length;\\n        int[][] ans = new int[rows][cols];\\n        Queue<Node> queue = new LinkedList<>();\\n        for(int i = 0 ; i < rows ; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                ans[i][j] = -2;\\n                if(arr[i][j] == 1){\\n                    ans[i][j] = 0;\\n                    queue.offer(new Node(i , j));\\n                }\\n            }\\n        }\\n        int counter = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node curNode = queue.poll();\\n                int i = curNode.i;\\n                int j = curNode.j;\\n                ans[i][j] = counter;\\n                for(int ptr = 0 ; ptr < 4 ; ptr++){\\n                    int I = i + dir[ptr][0];\\n                    int J = j + dir[ptr][1];\\n                    if(I < rows && I >= 0 && J < cols &&  J >= 0 && ans[I][J] == -2){\\n                        ans[I][J] = -1;\\n                        queue.offer(new Node(I , J));\\n                    }\\n                }\\n            }\\n            counter++;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015330,
                "title": "c-bfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) {\\n        queue<pair<int,int>> q;\\n        int n=water.size();\\n        int m=water[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(water[i][j]==1){\\n                    q.push({i,j});\\n                    water[i][j]=0;\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        int dr[4]={-1,0,1,0};\\n        int dc[4]={0,1,0,-1};\\n        \\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m && !vis[nr][nc]){\\n                    water[nr][nc]=1+water[r][c];\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) {\\n        queue<pair<int,int>> q;\\n        int n=water.size();\\n        int m=water[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(water[i][j]==1){\\n                    q.push({i,j});\\n                    water[i][j]=0;\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        int dr[4]={-1,0,1,0};\\n        int dc[4]={0,1,0,-1};\\n        \\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m && !vis[nr][nc]){\\n                    water[nr][nc]=1+water[r][c];\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n        }\\n        return water;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990021,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n    const int m = isWater.size();\\n    const int n = isWater[0].size();\\n    const vector<int> dirs{0, 1, 0, -1, 0};\\n    vector<vector<int>> ans(m, vector<int>(n, -1));\\n    queue<pair<int, int>> q;\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (isWater[i][j] == 1) {\\n          q.emplace(i, j);\\n          ans[i][j] = 0;\\n        }\\n\\n    while (!q.empty()) {\\n      const auto [i, j] = q.front();\\n      q.pop();\\n      for (int k = 0; k < 4; ++k) {\\n        const int x = i + dirs[k];\\n        const int y = j + dirs[k + 1];\\n        if (x < 0 || x == m || y < 0 || y == n)\\n          continue;\\n        if (ans[x][y] != -1)\\n          continue;\\n        ans[x][y] = ans[i][j] + 1;\\n        q.emplace(x, y);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n    const int m = isWater.size();\\n    const int n = isWater[0].size();\\n    const vector<int> dirs{0, 1, 0, -1, 0};\\n    vector<vector<int>> ans(m, vector<int>(n, -1));\\n    queue<pair<int, int>> q;\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (isWater[i][j] == 1) {\\n          q.emplace(i, j);\\n          ans[i][j] = 0;\\n        }\\n\\n    while (!q.empty()) {\\n      const auto [i, j] = q.front();\\n      q.pop();\\n      for (int k = 0; k < 4; ++k) {\\n        const int x = i + dirs[k];\\n        const int y = j + dirs[k + 1];\\n        if (x < 0 || x == m || y < 0 || y == n)\\n          continue;\\n        if (ans[x][y] != -1)\\n          continue;\\n        ans[x][y] = ans[i][j] + 1;\\n        q.emplace(x, y);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984335,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q = deque()\\n        dir=[-1,0,1,0,-1]\\n        rowsize=len(isWater)\\n        colsize=len(isWater[0])\\n        visited=set()\\n        for i in range(rowsize):\\n            for j in range(colsize):\\n                if isWater[i][j]==1:\\n                    q.append([i,j])\\n                    visited.add(tuple([i,j]))\\n                    isWater[i][j]=0\\n        idx=1\\n        while q:\\n            size=len(q)\\n            for i in range(size):\\n                [r,c]=q.popleft()\\n                for i in range(1,len(dir)):\\n                    row,col=r+dir[i-1],c+dir[i]\\n                    if row<0 or row>=rowsize or col<0 or col>=colsize:continue\\n                    if (row,col) in visited:continue\\n                    isWater[row][col]=idx\\n                    visited.add(tuple([row,col]))\\n                    q.append([row,col])\\n            idx+=1\\n        return isWater\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q = deque()\\n        dir=[-1,0,1,0,-1]\\n        rowsize=len(isWater)\\n        colsize=len(isWater[0])\\n        visited=set()\\n        for i in range(rowsize):\\n            for j in range(colsize):\\n                if isWater[i][j]==1:\\n                    q.append([i,j])\\n                    visited.add(tuple([i,j]))\\n                    isWater[i][j]=0\\n        idx=1\\n        while q:\\n            size=len(q)\\n            for i in range(size):\\n                [r,c]=q.popleft()\\n                for i in range(1,len(dir)):\\n                    row,col=r+dir[i-1],c+dir[i]\\n                    if row<0 or row>=rowsize or col<0 or col>=colsize:continue\\n                    if (row,col) in visited:continue\\n                    isWater[row][col]=idx\\n                    visited.add(tuple([row,col]))\\n                    q.append([row,col])\\n            idx+=1\\n        return isWater\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936988,
                "title": "the-easiest-solution-clean-code-multisource-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size(), m = isWater.at(0).size();\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n\\n        queue<array<int, 3>> q;\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < m; ++j) {\\n                if(isWater[i][j]) {\\n                    vis[i][j] = 0;\\n                    q.push({i, j, 0});\\n                }\\n            }\\n        }\\n        int dx[] = {0, 1, 0, -1, 0};\\n        int mx = 0;\\n        while(q.size()) {\\n            auto [x, y, d] = q.front(); q.pop();\\n            for(int i = 0; i < 4; ++i) {\\n                int nx = x + dx[i];\\n                int ny = y + dx[i+1];\\n                if(nx < n and ny < m and nx >= 0 and ny >= 0 and vis[nx][ny] == -1) {\\n                    vis[nx][ny] = d + 1;\\n                    q.push({nx, ny, d + 1});\\n                }\\n            }\\n        }\\n\\n        return vis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size(), m = isWater.at(0).size();\\n        vector<vector<int>> vis(n, vector<int>(m, -1));\\n\\n        queue<array<int, 3>> q;\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < m; ++j) {\\n                if(isWater[i][j]) {\\n                    vis[i][j] = 0;\\n                    q.push({i, j, 0});\\n                }\\n            }\\n        }\\n        int dx[] = {0, 1, 0, -1, 0};\\n        int mx = 0;\\n        while(q.size()) {\\n            auto [x, y, d] = q.front(); q.pop();\\n            for(int i = 0; i < 4; ++i) {\\n                int nx = x + dx[i];\\n                int ny = y + dx[i+1];\\n                if(nx < n and ny < m and nx >= 0 and ny >= 0 and vis[nx][ny] == -1) {\\n                    vis[nx][ny] = d + 1;\\n                    q.push({nx, ny, d + 1});\\n                }\\n            }\\n        }\\n\\n        return vis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845080,
                "title": "my-c-visited-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct lands{\\n    int x;\\n    int y;\\n    int val;\\n    struct lands* next;\\n};\\nstruct lands* head;\\nstruct lands* tail;\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\n\\nint queue_land(int x, int y, int val){\\n    struct lands* temp = malloc(sizeof(struct lands));\\n    temp->x = x;\\n    temp->y = y;\\n    temp->val= val;\\n    temp->next = NULL;\\n    if(head==NULL){\\n        head = temp;\\n        tail = temp;\\n    }\\n    else{\\n        tail->next = temp;\\n        tail = temp;\\n    }\\n    return 0;\\n}\\n\\nint bfs(int** isWater, int row, int col, struct lands* curr){\\n    if(curr->val)\\n        isWater[curr->x][curr->y] = curr->val;\\n    else\\n        isWater[curr->x][curr->y] = -1; // -1 for water\\n    \\n    if(curr->x-1 >= 0){\\n        if(!isWater[curr->x-1][curr->y]){ //0 means not visited.\\n            isWater[curr->x-1][curr->y] = -1; // set -1 for queued.\\n            queue_land(curr->x-1, curr->y, curr->val+1);\\n        }\\n    }\\n    if(curr->x+1 < row){\\n        if(!isWater[curr->x+1][curr->y]){ //0 means not visited.\\n            isWater[curr->x+1][curr->y] = -1; // set -1 for queued.\\n            queue_land(curr->x+1, curr->y, curr->val+1);\\n        }\\n    }\\n    if(curr->y-1 >= 0){\\n        if(!isWater[curr->x][curr->y-1]){ //0 means not visited.\\n            isWater[curr->x][curr->y-1] = -1; // set -1 for queued.\\n            queue_land(curr->x, curr->y-1, curr->val+1);\\n        }\\n    }\\n    if(curr->y+1 < col){\\n        if(!isWater[curr->x][curr->y+1]){ //0 means not visited.\\n            isWater[curr->x][curr->y+1] = -1; // set -1 for queued.\\n            queue_land(curr->x, curr->y+1, curr->val+1);\\n        } \\n    }\\n    //printf(\"---- %d, %d, %d ----\\\\n\", curr->x, curr->y, curr->val);\\n    if(curr->next != NULL)\\n        bfs(isWater, row, col, curr->next);\\n    free(curr);\\n    return 0;\\n}\\n\\nint** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }\\n    }\\n    \\n    int col = *isWaterColSize;\\n    bfs(isWater,isWaterSize,col,head);\\n    \\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<col;j++){\\n            if(isWater[i][j]==-1)\\n                isWater[i][j] = 0;  // set water back.\\n        }\\n    }\\n    *returnSize = isWaterSize;\\n    *returnColumnSizes = malloc(sizeof(int)*isWaterSize);\\n    for(i=0;i<*returnSize;i++){\\n        (*returnColumnSizes)[i] = *isWaterColSize;\\n    }\\n    return isWater;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct lands{\\n    int x;\\n    int y;\\n    int val;\\n    struct lands* next;\\n};\\nstruct lands* head;\\nstruct lands* tail;\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\n\\nint queue_land(int x, int y, int val){\\n    struct lands* temp = malloc(sizeof(struct lands));\\n    temp->x = x;\\n    temp->y = y;\\n    temp->val= val;\\n    temp->next = NULL;\\n    if(head==NULL){\\n        head = temp;\\n        tail = temp;\\n    }\\n    else{\\n        tail->next = temp;\\n        tail = temp;\\n    }\\n    return 0;\\n}\\n\\nint bfs(int** isWater, int row, int col, struct lands* curr){\\n    if(curr->val)\\n        isWater[curr->x][curr->y] = curr->val;\\n    else\\n        isWater[curr->x][curr->y] = -1; // -1 for water\\n    \\n    if(curr->x-1 >= 0){\\n        if(!isWater[curr->x-1][curr->y]){ //0 means not visited.\\n            isWater[curr->x-1][curr->y] = -1; // set -1 for queued.\\n            queue_land(curr->x-1, curr->y, curr->val+1);\\n        }\\n    }\\n    if(curr->x+1 < row){\\n        if(!isWater[curr->x+1][curr->y]){ //0 means not visited.\\n            isWater[curr->x+1][curr->y] = -1; // set -1 for queued.\\n            queue_land(curr->x+1, curr->y, curr->val+1);\\n        }\\n    }\\n    if(curr->y-1 >= 0){\\n        if(!isWater[curr->x][curr->y-1]){ //0 means not visited.\\n            isWater[curr->x][curr->y-1] = -1; // set -1 for queued.\\n            queue_land(curr->x, curr->y-1, curr->val+1);\\n        }\\n    }\\n    if(curr->y+1 < col){\\n        if(!isWater[curr->x][curr->y+1]){ //0 means not visited.\\n            isWater[curr->x][curr->y+1] = -1; // set -1 for queued.\\n            queue_land(curr->x, curr->y+1, curr->val+1);\\n        } \\n    }\\n    //printf(\"---- %d, %d, %d ----\\\\n\", curr->x, curr->y, curr->val);\\n    if(curr->next != NULL)\\n        bfs(isWater, row, col, curr->next);\\n    free(curr);\\n    return 0;\\n}\\n\\nint** highestPeak(int** isWater, int isWaterSize, int* isWaterColSize, int* returnSize, int** returnColumnSizes){\\n    int i, j;\\n    head = NULL;\\n    tail = NULL;\\n\\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<*isWaterColSize;j++){\\n            if(isWater[i][j])\\n                queue_land(i,j,0);\\n        }\\n    }\\n    \\n    int col = *isWaterColSize;\\n    bfs(isWater,isWaterSize,col,head);\\n    \\n    for(i=0;i<isWaterSize;i++){\\n        for(j=0;j<col;j++){\\n            if(isWater[i][j]==-1)\\n                isWater[i][j] = 0;  // set water back.\\n        }\\n    }\\n    *returnSize = isWaterSize;\\n    *returnColumnSizes = malloc(sizeof(int)*isWaterSize);\\n    for(i=0;i<*returnSize;i++){\\n        (*returnColumnSizes)[i] = *isWaterColSize;\\n    }\\n    return isWater;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838327,
                "title": "c-easy-to-understand-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMatrix(Graph) problem with land and water is generally solved using DFS or BFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Multi Source BFS algorithm or Level order traversal.\\nThe Alorithm is similar to BFS however we now use loop to check all the cell in the queue and subsequently adding the next adjacent cells of these cells.\\nWe will maintain a variable intialised with 0 and increase it whenever the loop has finished iterating.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$ each cell will be visited atmost once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m=isWater.size();\\n        int n=isWater[0].size();\\n\\n        //to store solution\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        //to map visited cell\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        //for bfs or level order traversal\\n        queue<pair<int,int>> q;\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(isWater[i][j])\\n                {\\n                    //pushing all the water cell as source in the queue\\n                    q.push({i,j});\\n                    vis[i][j]=true;\\n                }\\n            }\\n        }\\n        //directions\\n        vector<int> cell={-1,0,1,0,-1};\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            //loop to iterate all cells currently in the queue\\n            while(size--)\\n            {\\n                auto [i,j]=q.front();\\n                q.pop();\\n                ans[i][j]=level;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+cell[k];\\n                    int y=j+cell[k+1];\\n                    if(x<0||y<0||x>=m||y>=n||vis[x][y])continue;\\n                    vis[x][y]=true;\\n                    q.push({x,y});\\n                }\\n\\n            }\\n            //incrementing level\\n            level++;\\n        }\\n        //returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m=isWater.size();\\n        int n=isWater[0].size();\\n\\n        //to store solution\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        //to map visited cell\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        //for bfs or level order traversal\\n        queue<pair<int,int>> q;\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(isWater[i][j])\\n                {\\n                    //pushing all the water cell as source in the queue\\n                    q.push({i,j});\\n                    vis[i][j]=true;\\n                }\\n            }\\n        }\\n        //directions\\n        vector<int> cell={-1,0,1,0,-1};\\n        int level=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            //loop to iterate all cells currently in the queue\\n            while(size--)\\n            {\\n                auto [i,j]=q.front();\\n                q.pop();\\n                ans[i][j]=level;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+cell[k];\\n                    int y=j+cell[k+1];\\n                    if(x<0||y<0||x>=m||y>=n||vis[x][y])continue;\\n                    vis[x][y]=true;\\n                    q.push({x,y});\\n                }\\n\\n            }\\n            //incrementing level\\n            level++;\\n        }\\n        //returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833080,
                "title": "bfs-with-queue",
                "content": "# Intuition\\n\\nWe have to fill every cell starting from water. Sound like BFS problem to me!\\n\\n# Approach\\n\\n1. Collect all of the water cells to Q first. Mark them as 0 level. Mark other cells with `-1`, so they are not visited yet.\\n2. Keep maxH, as max level of water.\\n3. Pop coordinates from Q and check for neighbours and set them cur maxH. \\n\\n\\n# Complexity\\n- Time complexity:\\n`O(rows * cols)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\ntype Pair struct {r, c int}\\n\\nfunc highestPeak(isWater [][]int) [][]int {\\n    rows, cols := len(isWater), len(isWater[0])\\n\\n    q := []Pair{}\\n\\n    // collect water first\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            if isWater[r][c] == 1 {\\n                q = append(q, Pair{r, c})\\n                isWater[r][c] = 0\\n            } else {\\n                isWater[r][c] = -1\\n            }\\n        }\\n    }\\n\\n    inBounds := func(r, c int) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols\\n    }\\n\\n    maxH := 1\\n\\n    checkNei := func(r, c int) bool {\\n        if !inBounds(r, c) || isWater[r][c] != -1 {\\n            return false\\n        }\\n        isWater[r][c] = maxH\\n        return true\\n    }\\n\\n    \\n    for len(q) != 0 {\\n        n := len(q)\\n        for i := 0; i < n; i++ {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if checkNei(cur.r + 1, cur.c) {q = append(q, Pair{cur.r + 1, cur.c})}\\n            if checkNei(cur.r - 1, cur.c) {q = append(q, Pair{cur.r - 1, cur.c})}\\n            if checkNei(cur.r, cur.c + 1) {q = append(q, Pair{cur.r, cur.c + 1})}\\n            if checkNei(cur.r, cur.c - 1) {q = append(q, Pair{cur.r, cur.c - 1})}\\n        }\\n        maxH += 1\\n    }\\n\\n\\n    return isWater\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ntype Pair struct {r, c int}\\n\\nfunc highestPeak(isWater [][]int) [][]int {\\n    rows, cols := len(isWater), len(isWater[0])\\n\\n    q := []Pair{}\\n\\n    // collect water first\\n    for r := 0; r < rows; r++ {\\n        for c := 0; c < cols; c++ {\\n            if isWater[r][c] == 1 {\\n                q = append(q, Pair{r, c})\\n                isWater[r][c] = 0\\n            } else {\\n                isWater[r][c] = -1\\n            }\\n        }\\n    }\\n\\n    inBounds := func(r, c int) bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols\\n    }\\n\\n    maxH := 1\\n\\n    checkNei := func(r, c int) bool {\\n        if !inBounds(r, c) || isWater[r][c] != -1 {\\n            return false\\n        }\\n        isWater[r][c] = maxH\\n        return true\\n    }\\n\\n    \\n    for len(q) != 0 {\\n        n := len(q)\\n        for i := 0; i < n; i++ {\\n            cur := q[0]\\n            q = q[1:]\\n\\n            if checkNei(cur.r + 1, cur.c) {q = append(q, Pair{cur.r + 1, cur.c})}\\n            if checkNei(cur.r - 1, cur.c) {q = append(q, Pair{cur.r - 1, cur.c})}\\n            if checkNei(cur.r, cur.c + 1) {q = append(q, Pair{cur.r, cur.c + 1})}\\n            if checkNei(cur.r, cur.c - 1) {q = append(q, Pair{cur.r, cur.c - 1})}\\n        }\\n        maxH += 1\\n    }\\n\\n\\n    return isWater\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825575,
                "title": "c-bfs-easy-approach-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size(), m=isWater[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        queue<pair<int, pair<int, int>>> q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(isWater[i][j]==1){\\n                ans[i][j] = 0;\\n                vis[i][j] = 1;\\n                q.push({0, {i, j}});\\n                }\\n            }\\n        }\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        while(!q.empty()){\\n            int sum = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row+delrow[i];\\n                int ncol = col+delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0){\\n                    vis[nrow][ncol] = 1;\\n                    ans[nrow][ncol] = sum+1;\\n                    q.push({sum+1, {nrow, ncol}});\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size(), m=isWater[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        queue<pair<int, pair<int, int>>> q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(isWater[i][j]==1){\\n                ans[i][j] = 0;\\n                vis[i][j] = 1;\\n                q.push({0, {i, j}});\\n                }\\n            }\\n        }\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        while(!q.empty()){\\n            int sum = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row+delrow[i];\\n                int ncol = col+delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0){\\n                    vis[nrow][ncol] = 1;\\n                    ans[nrow][ncol] = sum+1;\\n                    q.push({sum+1, {nrow, ncol}});\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788413,
                "title": "easy-c-solution-bfs-efficient-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(short i,short j,short m,short n){\\n        if(i>=0 && i<m && j>=0 && j<n)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n        queue<pair<pair<short,short>,short>> q;\\n        short m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> h(m,vector<int> (n,-1));\\n        for(short i=0;i<m;i++){\\n            for(short j=0;j<n;j++){\\n                if(grid[i][j]==1)\\n                {\\n                    q.push({{i,j},0});\\n                    h[i][j]=0;\\n                }\\n            }\\n        }\\n        vector<short> dx={-1,0,1,0};\\n        vector<short> dy={0,1,0,-1};\\n        while(!q.empty()){\\n            short x=q.front().first.first;\\n            short y=q.front().first.second;\\n            short t=q.front().second;\\n            q.pop();\\n            for(short i=0;i<4;i++){\\n                short newX=x+dx[i];\\n                short newY=y+dy[i];\\n                if(isValid(newX,newY,m,n)){\\n                    if(h[newX][newY]==-1){\\n                        q.push({{newX,newY},t+1});\\n                        h[newX][newY]=t+1;\\n                    }\\n                }\\n            }\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(short i,short j,short m,short n){\\n        if(i>=0 && i<m && j>=0 && j<n)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n        queue<pair<pair<short,short>,short>> q;\\n        short m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> h(m,vector<int> (n,-1));\\n        for(short i=0;i<m;i++){\\n            for(short j=0;j<n;j++){\\n                if(grid[i][j]==1)\\n                {\\n                    q.push({{i,j},0});\\n                    h[i][j]=0;\\n                }\\n            }\\n        }\\n        vector<short> dx={-1,0,1,0};\\n        vector<short> dy={0,1,0,-1};\\n        while(!q.empty()){\\n            short x=q.front().first.first;\\n            short y=q.front().first.second;\\n            short t=q.front().second;\\n            q.pop();\\n            for(short i=0;i<4;i++){\\n                short newX=x+dx[i];\\n                short newY=y+dy[i];\\n                if(isValid(newX,newY,m,n)){\\n                    if(h[newX][newY]==-1){\\n                        q.push({{newX,newY},t+1});\\n                        h[newX][newY]=t+1;\\n                    }\\n                }\\n            }\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764955,
                "title": "python-solution-with-multi-source-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse multi-source BFS find nearest water cell\\nfor every land cell multi-source BFS ensuring find closest water cell from all possibile\\'s:\\nas shown examples in 1d:\\nw----?--wxx, w is water, ? is land-distance we query?\\nwith multi-source BFS we got answer is 3:\\nw1234?21w12 ? will be 3 as close to 2nd water cell!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. init queue as all water cell in grid, (r,c,0) 0 is distance to water\\n2. pop one from front get current height=h,and search if cell neighbor is vlidated one: neither visited nor out of boundary, water cell,\\n3. if is the cell and not visted yet, its high will be h+1, mark it and append to tail of queue\\n4. loop until queue empty!\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N) as bfs visit every cell in grid\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N) queue size\\n\\n# Code\\n```\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        \"\"\"\\n        :type isWater: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nr,nc,qs=len(isWater),len(isWater[0]),[]\\n        for r in range(nr):\\n            for c in range(nc):\\n                if not isWater[r][c]:continue\\n                qs.append((r,c,0))\\n                isWater[r][c]=-1\\n        \\n        def _isOutBoundary(r,c):\\n            return True if r<0 or c<0 or r>nr-1 or c>nc-1 else False\\n\\n        while qs:\\n            r,c,h=qs.pop(0)\\n            for rr,cc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:\\n                if _isOutBoundary(rr,cc) or isWater[rr][cc]>0 or isWater[rr][cc]==-1:continue\\n                isWater[rr][cc]=h+1\\n                qs.append((rr,cc,h+1))\\n\\n        for r in range(nr):\\n            for c in range(nc):\\n                if isWater[r][c]==-1:isWater[r][c]=0\\n        return isWater\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        \"\"\"\\n        :type isWater: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nr,nc,qs=len(isWater),len(isWater[0]),[]\\n        for r in range(nr):\\n            for c in range(nc):\\n                if not isWater[r][c]:continue\\n                qs.append((r,c,0))\\n                isWater[r][c]=-1\\n        \\n        def _isOutBoundary(r,c):\\n            return True if r<0 or c<0 or r>nr-1 or c>nc-1 else False\\n\\n        while qs:\\n            r,c,h=qs.pop(0)\\n            for rr,cc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:\\n                if _isOutBoundary(rr,cc) or isWater[rr][cc]>0 or isWater[rr][cc]==-1:continue\\n                isWater[rr][cc]=h+1\\n                qs.append((rr,cc,h+1))\\n\\n        for r in range(nr):\\n            for c in range(nc):\\n                if isWater[r][c]==-1:isWater[r][c]=0\\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760901,
                "title": "ez-bfs-solution-explained-with-comments",
                "content": "**Time Complexity : O( m * n) + O (m * n)\\nSpace Complexity : O ( m * n) + O (m * n)** [ Queue + Visited Array]\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        queue<vector<int>>q;\\n        int m=isWater.size(),n=isWater[0].size();        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(isWater[i][j]==1)//Water is detected so we put the co-ordinates in the queue\\n                    q.push({i,j});\\n                isWater[i][j]=!isWater[i][j];//Making \\'1\\' to \\'0\\' and vice versa. 1 -> is Land and 0 -> is water NOW   \\n            }\\n                \\n                \\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int row[]={+1,0,-1,0},col[]={0,+1,0,-1};//To explore all the four directions of the water body signified by 0\\n        int c=1;//Count the increment\\n        while(!q.empty()){\\n           int size=q.size();\\n            while(size--){\\n                auto x=q.front();\\n                q.pop();               \\n               visited[x[0]][x[1]]=true;\\n                for(int k=0;k<4;k++){\\n                    int newRow=x[0]+row[k],newCol=x[1]+col[k];\\n                    // If the new index is unvisited and is a land we increment it and mark it as visited                     \\n                    if(newRow>=0&&newCol>=0&&newRow<m&&newCol<n&&isWater[newRow][newCol]!=0&&!visited[newRow][newCol]){\\n                        isWater[newRow][newCol]=c;\\n                        visited[newRow][newCol]=true;\\n                        q.push({newRow,newCol});\\n                    }\\n                }\\n            }\\n            c++;//Increase count for next bfs\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        queue<vector<int>>q;\\n        int m=isWater.size(),n=isWater[0].size();        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                if(isWater[i][j]==1)//Water is detected so we put the co-ordinates in the queue\\n                    q.push({i,j});\\n                isWater[i][j]=!isWater[i][j];//Making \\'1\\' to \\'0\\' and vice versa. 1 -> is Land and 0 -> is water NOW   \\n            }\\n                \\n                \\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        int row[]={+1,0,-1,0},col[]={0,+1,0,-1};//To explore all the four directions of the water body signified by 0\\n        int c=1;//Count the increment\\n        while(!q.empty()){\\n           int size=q.size();\\n            while(size--){\\n                auto x=q.front();\\n                q.pop();               \\n               visited[x[0]][x[1]]=true;\\n                for(int k=0;k<4;k++){\\n                    int newRow=x[0]+row[k],newCol=x[1]+col[k];\\n                    // If the new index is unvisited and is a land we increment it and mark it as visited                     \\n                    if(newRow>=0&&newCol>=0&&newRow<m&&newCol<n&&isWater[newRow][newCol]!=0&&!visited[newRow][newCol]){\\n                        isWater[newRow][newCol]=c;\\n                        visited[newRow][newCol]=true;\\n                        q.push({newRow,newCol});\\n                    }\\n                }\\n            }\\n            c++;//Increase count for next bfs\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714020,
                "title": "easy-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>&w) {\\n        int m=w.size();int n=w[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                w[i][j] = w[i][j] ? 0 : -1;\\n                if(!w[i][j])q.push({i,j});\\n            }\\n        }\\n        int d[5]={1,0,-1,0,1};\\n        while(!q.empty()){\\n            auto [i,j]=q.front();q.pop();\\n            int h=w[i][j];\\n            for(int k=0;k<4;k++){\\n                int x=i+d[k];\\n                int y=j+d[k+1];\\n                if(x>=0 && y>=0 && x<m && y<n && w[x][y]==-1){\\n                    q.push({x,y});\\n                    w[x][y]=h+1;\\n                }\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>&w) {\\n        int m=w.size();int n=w[0].size();\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                w[i][j] = w[i][j] ? 0 : -1;\\n                if(!w[i][j])q.push({i,j});\\n            }\\n        }\\n        int d[5]={1,0,-1,0,1};\\n        while(!q.empty()){\\n            auto [i,j]=q.front();q.pop();\\n            int h=w[i][j];\\n            for(int k=0;k<4;k++){\\n                int x=i+d[k];\\n                int y=j+d[k+1];\\n                if(x>=0 && y>=0 && x<m && y<n && w[x][y]==-1){\\n                    q.push({x,y});\\n                    w[x][y]=h+1;\\n                }\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656608,
                "title": "simple-bfs-graph-c-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        queue< pair<pair<int,int>, int> >q;\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n                if(isWater[i][j]==1){\\n                    isWater[i][j] = 0;\\n                    visited[i][j] = 1;\\n                    q.push({{i, j}, 0});\\n                }\\n            }\\n        }\\n\\n        int row[4] = {0, 0, 1, -1};\\n        int col[4] = {1, -1, 0, 0};\\n\\n        while(!q.empty()){\\n            int x = q.front().first.first;\\n            int y = q.front().first.second;\\n            int val = q.front().second;\\n            q.pop();\\n\\n            for(int i=0 ;i<4 ;i++){\\n                int newx = x+row[i];\\n                int newy = y+col[i];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && !visited[newx][newy] ){\\n                    visited[newx][newy] = 1;\\n                    isWater[newx][newy] = val+1;\\n                    q.push({{newx, newy}, val+1});\\n                }\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        queue< pair<pair<int,int>, int> >q;\\n\\n        for(int i=0 ;i<n ;i++){\\n            for(int j=0 ;j<m ;j++){\\n                if(isWater[i][j]==1){\\n                    isWater[i][j] = 0;\\n                    visited[i][j] = 1;\\n                    q.push({{i, j}, 0});\\n                }\\n            }\\n        }\\n\\n        int row[4] = {0, 0, 1, -1};\\n        int col[4] = {1, -1, 0, 0};\\n\\n        while(!q.empty()){\\n            int x = q.front().first.first;\\n            int y = q.front().first.second;\\n            int val = q.front().second;\\n            q.pop();\\n\\n            for(int i=0 ;i<4 ;i++){\\n                int newx = x+row[i];\\n                int newy = y+col[i];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && !visited[newx][newy] ){\\n                    visited[newx][newy] = 1;\\n                    isWater[newx][newy] = val+1;\\n                    q.push({{newx, newy}, val+1});\\n                }\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655977,
                "title": "multisource-bfs-easy-to-understand-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Multi source bfs\\n    int dx[4] = {-1, 1, 0, 0};\\n    int dy[4] = {0, 0, -1, 1};\\n\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n\\n        queue<pair<int, pair<int, int>>> q;\\n\\n        <!-- Distance Matrix -->\\n        vector<vector<int>> dist(n, vector<int>(m, 1e8));\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({0, {i, j}});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n        <!-- BFS Traversal -->\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int d = it.first;\\n            int i = it.second.first;\\n            int j = it.second.second;\\n            q.pop();\\n\\n            <!-- Flood Fill -->\\n            for(int k = 0; k < 4; k++){\\n                int ii = i + dx[k];\\n                int jj = j + dy[k];\\n                if(ii >= 0 && ii < n && jj >= 0 && jj < m && isWater[ii][jj] == 0){\\n\\n                    <!-- To avoid visiting again and again -->\\n                    isWater[ii][jj] = 1;\\n                    <!-- Increasing distance by 1 -->\\n                    dist[ii][jj] = d+1;\\n                    q.push({d+1, {ii, jj}});\\n\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Multi source bfs\\n    int dx[4] = {-1, 1, 0, 0};\\n    int dy[4] = {0, 0, -1, 1};\\n\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n\\n        queue<pair<int, pair<int, int>>> q;\\n\\n        <!-- Distance Matrix -->\\n        vector<vector<int>> dist(n, vector<int>(m, 1e8));\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({0, {i, j}});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n        <!-- BFS Traversal -->\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int d = it.first;\\n            int i = it.second.first;\\n            int j = it.second.second;\\n            q.pop();\\n\\n            <!-- Flood Fill -->\\n            for(int k = 0; k < 4; k++){\\n                int ii = i + dx[k];\\n                int jj = j + dy[k];\\n                if(ii >= 0 && ii < n && jj >= 0 && jj < m && isWater[ii][jj] == 0){\\n\\n                    <!-- To avoid visiting again and again -->\\n                    isWater[ii][jj] = 1;\\n                    <!-- Increasing distance by 1 -->\\n                    dist[ii][jj] = d+1;\\n                    q.push({d+1, {ii, jj}});\\n\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654177,
                "title": "just-clean-code",
                "content": "The code speaks for itself. The only trick is in initializing the matrix with -= 1 -> turns water into 0 and land into -1 -> we reuse negative number during bfs as \"not visited flag\".\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        n, m = len(isWater[0]), len(isWater)\\n\\n        def init():\\n            nonlocal n, m, isWater\\n\\n            queue = deque()\\n            for x in range(n):\\n                for y in range(m):\\n                    isWater[y][x] -= 1\\n                    if isWater[y][x] == 0:\\n                        queue.append((x, y))\\n            return queue\\n        \\n        def bfs(queue):\\n            nonlocal n, m, isWater\\n\\n            while queue:\\n                x, y = queue.popleft()\\n                for a, b in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n                    if not(0 <= a < n and 0 <= b < m):  continue\\n                    if isWater[b][a] != -1:             continue\\n                    isWater[b][a] = isWater[y][x] + 1\\n                    queue.append((a, b))\\n\\n        queue = init()\\n        bfs(queue)\\n        return isWater\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        n, m = len(isWater[0]), len(isWater)\\n\\n        def init():\\n            nonlocal n, m, isWater\\n\\n            queue = deque()\\n            for x in range(n):\\n                for y in range(m):\\n                    isWater[y][x] -= 1\\n                    if isWater[y][x] == 0:\\n                        queue.append((x, y))\\n            return queue\\n        \\n        def bfs(queue):\\n            nonlocal n, m, isWater\\n\\n            while queue:\\n                x, y = queue.popleft()\\n                for a, b in (x+1, y), (x-1, y), (x, y+1), (x, y-1):\\n                    if not(0 <= a < n and 0 <= b < m):  continue\\n                    if isWater[b][a] != -1:             continue\\n                    isWater[b][a] = isWater[y][x] + 1\\n                    queue.append((a, b))\\n\\n        queue = init()\\n        bfs(queue)\\n        return isWater\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641432,
                "title": "o-1-space-bfs-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    def inBound(self, row: int, col: int, grid: List[List[int]]) -> bool:\\n        \\n        if row < 0 or row >= len(grid):\\n            return False\\n        \\n        if col < 0 or col >= len(grid[0]):\\n            return False\\n        \\n        return True\\n    \\n    \\n    def getNeighbors(self, row: int, col: int, isWater: List[List[int]]) -> int:\\n        \\n        nbrs = []\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        for x, y in directions:\\n            if self.inBound(row+x, col+y, isWater) and isWater[row+x][col+y] == -1:\\n                nbrs.append((row+x, col+y))\\n                \\n        return nbrs\\n    \\n    \\n    # O(n*m) time,\\n    # O(1) space,\\n    # Approach: bfs, \\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        queue = deque()\\n        \\n        for row in range(len(isWater)):\\n            for col in range(len(isWater[0])):\\n                if isWater[row][col]:\\n                    queue.append((row, col))\\n                isWater[row][col] = -1\\n                \\n        height = 0\\n        while queue:\\n            n = len(queue)\\n            for _ in range(n):\\n                row, col = queue.popleft()\\n                if isWater[row][col] != -1:\\n                    continue\\n                    \\n                isWater[row][col] = height\\n                for nbr in self.getNeighbors(row, col, isWater):\\n                    queue.append(nbr)\\n                    \\n            height += 1\\n        \\n        return isWater\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def inBound(self, row: int, col: int, grid: List[List[int]]) -> bool:\\n        \\n        if row < 0 or row >= len(grid):\\n            return False\\n        \\n        if col < 0 or col >= len(grid[0]):\\n            return False\\n        \\n        return True\\n    \\n    \\n    def getNeighbors(self, row: int, col: int, isWater: List[List[int]]) -> int:\\n        \\n        nbrs = []\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        for x, y in directions:\\n            if self.inBound(row+x, col+y, isWater) and isWater[row+x][col+y] == -1:\\n                nbrs.append((row+x, col+y))\\n                \\n        return nbrs\\n    \\n    \\n    # O(n*m) time,\\n    # O(1) space,\\n    # Approach: bfs, \\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        queue = deque()\\n        \\n        for row in range(len(isWater)):\\n            for col in range(len(isWater[0])):\\n                if isWater[row][col]:\\n                    queue.append((row, col))\\n                isWater[row][col] = -1\\n                \\n        height = 0\\n        while queue:\\n            n = len(queue)\\n            for _ in range(n):\\n                row, col = queue.popleft()\\n                if isWater[row][col] != -1:\\n                    continue\\n                    \\n                isWater[row][col] = height\\n                for nbr in self.getNeighbors(row, col, isWater):\\n                    queue.append(nbr)\\n                    \\n            height += 1\\n        \\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629601,
                "title": "similar-to-01-matrix-as-far-as-possible-pacific-atlantic-ocean",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n      queue<pair<int,int>> q;\\n        vector<vector<int>> vis(isWater.size() , vector<int> (isWater[0].size(),-1));\\n        for(int i = 0 ; i < isWater.size() ; i++)\\n        {\\n            for(int j = 0 ; j < isWater[0].size() ; j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                    isWater[i][j] = 0;\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(q.size() > 0)\\n        {\\n            int size = q.size();\\n            for(int i = 0 ;  i < size ; i++)\\n            {\\n                auto it = q.front();\\n                q.pop();\\n                int cr = it.first;\\n                int cc = it.second;\\n                vector<int> x = {0,0,-1,1};\\n                vector<int> y = {1,-1,0,0};\\n                for(int k = 0 ; k < 4 ; k++)\\n                {\\n                    int newr = cr + x[k];\\n                    int newc = cc + y[k];\\n                    if(newr >= 0 and newc >= 0 and newr <= isWater.size()-1 and newc <= isWater[0].size()-1 and isWater[newr][newc]==0 and vis[newr][newc]==-1)\\n                    {\\n                        isWater[newr][newc] = 1 + isWater[cr][cc];\\n                        q.push({newr,newc});\\n                        vis[newr][newc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n      queue<pair<int,int>> q;\\n        vector<vector<int>> vis(isWater.size() , vector<int> (isWater[0].size(),-1));\\n        for(int i = 0 ; i < isWater.size() ; i++)\\n        {\\n            for(int j = 0 ; j < isWater[0].size() ; j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                    isWater[i][j] = 0;\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(q.size() > 0)\\n        {\\n            int size = q.size();\\n            for(int i = 0 ;  i < size ; i++)\\n            {\\n                auto it = q.front();\\n                q.pop();\\n                int cr = it.first;\\n                int cc = it.second;\\n                vector<int> x = {0,0,-1,1};\\n                vector<int> y = {1,-1,0,0};\\n                for(int k = 0 ; k < 4 ; k++)\\n                {\\n                    int newr = cr + x[k];\\n                    int newc = cc + y[k];\\n                    if(newr >= 0 and newc >= 0 and newr <= isWater.size()-1 and newc <= isWater[0].size()-1 and isWater[newr][newc]==0 and vis[newr][newc]==-1)\\n                    {\\n                        isWater[newr][newc] = 1 + isWater[cr][cc];\\n                        q.push({newr,newc});\\n                        vis[newr][newc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617951,
                "title": "unveiling-the-mysteries-of-the-magical-height-assignment-algorithm-in-harry-potter-s-land",
                "content": "**Solution**\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        q = deque()\\n        for i, row in enumerate(isWater):\\n            for j, val in enumerate(row):\\n                if val:\\n                    q.append((i, j))\\n                    row[j] = 0\\n                else:\\n                    row[j] = -1\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in directions:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < len(isWater) and 0 <= new_y < len(isWater[0]) and isWater[new_x][new_y] == -1:\\n                    isWater[new_x][new_y] = 1 + isWater[x][y]\\n                    q.append((new_x, new_y))\\n        return isWater\\n```\\n\\n**Introduction:**\\nIn the enchanting realm of Harry Potter, even the land and water cells hold secrets waiting to be unveiled. To unlock the hidden heights within these cells, a clever algorithm emerges\\u2014a spellbinding solution known as the \"Highest Peak.\" This article delves into the intricacies of this magical algorithm, deciphering its inner workings, its cunning approach, and the secrets it holds.\\n\\n**The Quest for Heights:**\\nThe task at hand is to assign heights to each cell in a matrix, representing land and water. The main goal is to maximize the maximum height in the matrix while adhering to specific rules. Let us embark on this journey and explore how the Highest Peak algorithm accomplishes this mystical feat.\\n\\n**Unveiling the Main Trick:**\\nThe Highest Peak algorithm employs a brilliant strategy\\u2014a combination of breadth-first search (BFS) and the art of incremental height assignment. It magically traverses the matrix, starting from the water cells, to unlock the heights of the land cells. But how does it work its magic?\\n\\n**The Enchanting Steps:**\\n1. Initiating the Quest:\\n   - A queue, symbolizing a magical portal, is created to store the coordinates of water cells.\\n   - Each water cell\\'s height is set to 0, while land cells are initially marked with a height of -1.\\n   - This preparation ensures that water cells begin their mystical journey from a height of 0, while land cells await their turn.\\n\\n2. Unleashing the Magic of BFS:\\n   - The algorithm enters the realm of BFS, traversing through the enchanted portal queue.\\n   - It selects a cell from the queue, representing the current location within the matrix.\\n   - Four primary directions, symbolizing the cardinal points of magic, guide the algorithm\\'s exploration: north, south, east, and west.\\n\\n3. Ascending the Heights:\\n   - For each direction, the algorithm determines the neighboring cell\\'s coordinates.\\n   - If the neighboring cell is within the matrix boundaries and has not yet been assigned a height, the algorithm proceeds.\\n   - The algorithm assigns the neighboring cell a height, calculated as 1 plus the height of the current cell. This ensures a gradual ascent in the heights, adhering to the absolute height difference constraint.\\n\\n4. Expanding the Mystical Influence:\\n   - As the algorithm progresses, the heights of neighboring cells increase, mirroring the spreading influence of its enchanting powers.\\n   - New cells, now assigned heights, are added to the queue, ready to explore their surroundings and continue the magical propagation.\\n\\n5. Journey\\'s End:\\n   - The algorithm continues this enchanting dance until the queue is empty, signaling that all cells have been visited.\\n   - Finally, the matrix, now infused with heights, is revealed to the magical world, showcasing the heights attained by each cell.\\n\\n**The Secret Time Complexity**:\\nNow that we have unraveled the magical steps of the Highest Peak algorithm, it\\'s time to shed light on its time complexity. The algorithm traverses through each cell in the matrix once, and for each cell, it examines its neighbors. Thus, the time complexity of the algorithm is O(m * n), where m represents the number of rows and n symbolizes the number of columns in the matrix. In the realm of computational magic, this time complexity is considered efficient, ensuring that the algorithm swiftly achieves its mission.\\n\\n**Conclusion:**\\nThe Highest Peak algorithm has bewitched us with its spellbinding approach to assigning heights to land and water cells. By combining the powers of BFS and incremental height assignment, it reveals the mystical heights hidden within the matrix. As we bid farewell to this magical journey, we are left in awe of the algorithm\\'s elegance and efficiency. So, let us embrace the Highest Peak algorithm and weave its enchanting spells into the fabric of our own adventures. May heights rise, and magic prevail!",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        \\n        q = deque()\\n        for i, row in enumerate(isWater):\\n            for j, val in enumerate(row):\\n                if val:\\n                    q.append((i, j))\\n                    row[j] = 0\\n                else:\\n                    row[j] = -1\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in directions:\\n                new_x, new_y = x + dx, y + dy\\n                if 0 <= new_x < len(isWater) and 0 <= new_y < len(isWater[0]) and isWater[new_x][new_y] == -1:\\n                    isWater[new_x][new_y] = 1 + isWater[x][y]\\n                    q.append((new_x, new_y))\\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615473,
                "title": "c-solution-bfs-striver-code-template",
                "content": "\\n- Space complexity:\\n-- O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        vector<vector<int>> ans(n, vector<int>(m, -1));\\n\\n        queue<pair<int, int>> q;\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(mat[i][j]==1) {\\n                    ans[i][j] = 0; //assign height 0 to the water;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n\\n        int delr[] = {0, +1, 0, -1};\\n        int delc[] = {+1, 0, -1, 0};\\n\\n        while(!q.empty()) {\\n            int s = q.size();\\n            for(int ss=0;ss<s;ss++) {\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                q.pop();\\n                int height = ans[row][col];\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delr[i];\\n                    int ncol = col + delc[i];\\n\\n                    if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && mat[nrow][ncol]==0 &&ans[nrow][ncol]==-1) {\\n                        ans[nrow][ncol] = height+1;\\n                        q.push({nrow, ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        vector<vector<int>> ans(n, vector<int>(m, -1));\\n\\n        queue<pair<int, int>> q;\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(mat[i][j]==1) {\\n                    ans[i][j] = 0; //assign height 0 to the water;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n\\n        int delr[] = {0, +1, 0, -1};\\n        int delc[] = {+1, 0, -1, 0};\\n\\n        while(!q.empty()) {\\n            int s = q.size();\\n            for(int ss=0;ss<s;ss++) {\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                q.pop();\\n                int height = ans[row][col];\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delr[i];\\n                    int ncol = col + delc[i];\\n\\n                    if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && mat[nrow][ncol]==0 &&ans[nrow][ncol]==-1) {\\n                        ans[nrow][ncol] = height+1;\\n                        q.push({nrow, ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596276,
                "title": "simple-bfs-solution-tc-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int [][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 1)\\n                {\\n                    q.add(new int[]{i,j});\\n                    isWater[i][j] = 0;\\n                }\\n                else\\n                isWater[i][j] = -1;\\n            }\\n        }\\n\\n        while(q.size() > 0)\\n        {\\n            int count = q.size();\\n            var loc = q.poll();\\n            for(int j = 0; j < dir.length; j++)\\n            {\\n                int newR = loc[0] + dir[j][0];\\n                int newC = loc[1] + dir[j][1];\\n                if(isValid(newR, newC, n, m, isWater))\\n                {\\n                    isWater[newR][newC] = isWater[loc[0]][loc[1]] + 1;\\n                    q.add(new int[]{newR, newC});\\n                }\\n            }            \\n        }\\n\\n        return isWater;\\n    }\\n\\n    public boolean isValid(int r, int c, int n, int m, int [][] isWater)\\n    {\\n        return r >=0 && r < n && c >= 0 && c < m && isWater[r][c] == -1;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int [][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 1)\\n                {\\n                    q.add(new int[]{i,j});\\n                    isWater[i][j] = 0;\\n                }\\n                else\\n                isWater[i][j] = -1;\\n            }\\n        }\\n\\n        while(q.size() > 0)\\n        {\\n            int count = q.size();\\n            var loc = q.poll();\\n            for(int j = 0; j < dir.length; j++)\\n            {\\n                int newR = loc[0] + dir[j][0];\\n                int newC = loc[1] + dir[j][1];\\n                if(isValid(newR, newC, n, m, isWater))\\n                {\\n                    isWater[newR][newC] = isWater[loc[0]][loc[1]] + 1;\\n                    q.add(new int[]{newR, newC});\\n                }\\n            }            \\n        }\\n\\n        return isWater;\\n    }\\n\\n    public boolean isValid(int r, int c, int n, int m, int [][] isWater)\\n    {\\n        return r >=0 && r < n && c >= 0 && c < m && isWater[r][c] == -1;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595877,
                "title": "c-solution-bfs-queue-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n        int m = isWater.Length;\\n        int n = isWater[0].Length;\\n        int max = m+n;\\n        int[][] res = new int[m][];\\n        bool[,] visited = new bool[m,n];\\n        Queue<(int row, int column)> q = new();\\n\\n        for(int i=0; i<m; i++){\\n            res[i] = new int[n];\\n\\n            for(int j=0; j<n; j++){\\n\\n                if(isWater[i][j] == 1){\\n                    visited[i,j] = true;\\n                    res[i][j] = 0;\\n                    q.Enqueue((i-1, j));\\n                    q.Enqueue((i+1, j));\\n                    q.Enqueue((i, j-1));\\n                    q.Enqueue((i, j+1));\\n\\n                }\\n                else{\\n                    res[i][j] = max;\\n                }\\n            }\\n        }\\n\\n        while(q.Count > 0){\\n            int count = q.Count;\\n\\n            while(count-- > 0){\\n                var currentCell = q.Dequeue();\\n                int row = currentCell.row;\\n                int column = currentCell.column;\\n\\n                if(row < 0 || column < 0 || row >= m || column >= n || visited[row, column]){\\n                    continue;\\n                }\\n\\n                visited[row, column] = true;\\n\\n                res[row][column] = 1 + GetMin(res, row, column);\\n                q.Enqueue(( row-1, column ));\\n                q.Enqueue(( row+1, column ));\\n                q.Enqueue(( row, column-1 ));\\n                q.Enqueue(( row, column+1 ));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    private int GetMin(int[][] res, int row, int col){\\n        int min = int.MaxValue;\\n\\n        if(row > 0){\\n            min = Math.Min(min, res[row-1][col]);\\n        }\\n\\n        if(col > 0){\\n            min = Math.Min(min, res[row][col-1]);\\n        }\\n\\n        if(row < res.Length - 1){\\n            min = Math.Min(min, res[row+1][col]);\\n        }\\n        \\n        if(col < res[row].Length - 1){\\n            min = Math.Min(min, res[row][col+1]);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n        int m = isWater.Length;\\n        int n = isWater[0].Length;\\n        int max = m+n;\\n        int[][] res = new int[m][];\\n        bool[,] visited = new bool[m,n];\\n        Queue<(int row, int column)> q = new();\\n\\n        for(int i=0; i<m; i++){\\n            res[i] = new int[n];\\n\\n            for(int j=0; j<n; j++){\\n\\n                if(isWater[i][j] == 1){\\n                    visited[i,j] = true;\\n                    res[i][j] = 0;\\n                    q.Enqueue((i-1, j));\\n                    q.Enqueue((i+1, j));\\n                    q.Enqueue((i, j-1));\\n                    q.Enqueue((i, j+1));\\n\\n                }\\n                else{\\n                    res[i][j] = max;\\n                }\\n            }\\n        }\\n\\n        while(q.Count > 0){\\n            int count = q.Count;\\n\\n            while(count-- > 0){\\n                var currentCell = q.Dequeue();\\n                int row = currentCell.row;\\n                int column = currentCell.column;\\n\\n                if(row < 0 || column < 0 || row >= m || column >= n || visited[row, column]){\\n                    continue;\\n                }\\n\\n                visited[row, column] = true;\\n\\n                res[row][column] = 1 + GetMin(res, row, column);\\n                q.Enqueue(( row-1, column ));\\n                q.Enqueue(( row+1, column ));\\n                q.Enqueue(( row, column-1 ));\\n                q.Enqueue(( row, column+1 ));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n    private int GetMin(int[][] res, int row, int col){\\n        int min = int.MaxValue;\\n\\n        if(row > 0){\\n            min = Math.Min(min, res[row-1][col]);\\n        }\\n\\n        if(col > 0){\\n            min = Math.Min(min, res[row][col-1]);\\n        }\\n\\n        if(row < res.Length - 1){\\n            min = Math.Min(min, res[row+1][col]);\\n        }\\n        \\n        if(col < res[row].Length - 1){\\n            min = Math.Min(min, res[row][col+1]);\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563530,
                "title": "simple-bfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& data) {\\n\\n        int m = data.size();\\n        int n = data[0].size();\\n\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        queue <pair<int,int>> q;\\n        \\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(data[i][j]==1){\\n                    ans[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n\\n            if(x+1<m){\\n                if(ans[x+1][y]==-1){\\n                    ans[x+1][y] = ans[x][y]+1;\\n                    q.push({x+1,y});\\n                }\\n            }\\n\\n            if(y+1<n){\\n                if(ans[x][y+1]==-1){\\n                    ans[x][y+1] = ans[x][y]+1;\\n                    q.push({x,y+1});\\n                }\\n            }\\n\\n            if(x-1>=0){\\n                if(ans[x-1][y]==-1){\\n                    ans[x-1][y] = ans[x][y]+1;\\n                    q.push({x-1,y});\\n                }\\n            }\\n\\n            if(y-1>=0){\\n                if(ans[x][y-1]==-1){\\n                    ans[x][y-1] = ans[x][y]+1;\\n                    q.push({x,y-1});\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& data) {\\n\\n        int m = data.size();\\n        int n = data[0].size();\\n\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        queue <pair<int,int>> q;\\n        \\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(data[i][j]==1){\\n                    ans[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n\\n            if(x+1<m){\\n                if(ans[x+1][y]==-1){\\n                    ans[x+1][y] = ans[x][y]+1;\\n                    q.push({x+1,y});\\n                }\\n            }\\n\\n            if(y+1<n){\\n                if(ans[x][y+1]==-1){\\n                    ans[x][y+1] = ans[x][y]+1;\\n                    q.push({x,y+1});\\n                }\\n            }\\n\\n            if(x-1>=0){\\n                if(ans[x-1][y]==-1){\\n                    ans[x-1][y] = ans[x][y]+1;\\n                    q.push({x-1,y});\\n                }\\n            }\\n\\n            if(y-1>=0){\\n                if(ans[x][y-1]==-1){\\n                    ans[x][y-1] = ans[x][y]+1;\\n                    q.push({x,y-1});\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555334,
                "title": "kotlin-floodfill-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun highestPeak(isWater: Array<IntArray>): Array<IntArray> {\\n        val h = isWater.size\\n        val w = isWater[0].size\\n\\n        val directs = arrayOf(intArrayOf(1, 0), intArrayOf(-1, 0), intArrayOf(0, 1), intArrayOf(0, -1))\\n\\n        val map = Array(h){ IntArray(w){ 0 } }\\n        val visit = Array(h){ BooleanArray(w){ false } }\\n        var queue = LinkedList<Pair<Int, Int>>()\\n\\n        for (r in 0 until h) {\\n            for (c in 0 until w) {\\n                if (isWater[r][c] == 0) continue\\n                visit[r][c] = true\\n                queue.offer(Pair(r, c))\\n            }\\n        }\\n\\n        var height = 0\\n\\n        while(!queue.isEmpty()) {\\n            var nq = LinkedList<Pair<Int, Int>>()\\n\\n            while(!queue.isEmpty()) {\\n                val coord = queue.poll()\\n                val y = coord.first\\n                val x = coord.second\\n                map[y][x] = height\\n\\n                for (direct in directs) {\\n                    val ny = y + direct[0]\\n                    val nx = x + direct[1]\\n\\n                    if (ny >= h || ny < 0) continue\\n                    if (nx >= w || nx < 0) continue\\n                    if (visit[ny][nx]) continue\\n\\n                    visit[ny][nx] = true\\n                    nq.offer(Pair(ny, nx))                    \\n                }\\n            }\\n\\n            height++\\n            queue = nq\\n        }\\n\\n        return map\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun highestPeak(isWater: Array<IntArray>): Array<IntArray> {\\n        val h = isWater.size\\n        val w = isWater[0].size\\n\\n        val directs = arrayOf(intArrayOf(1, 0), intArrayOf(-1, 0), intArrayOf(0, 1), intArrayOf(0, -1))\\n\\n        val map = Array(h){ IntArray(w){ 0 } }\\n        val visit = Array(h){ BooleanArray(w){ false } }\\n        var queue = LinkedList<Pair<Int, Int>>()\\n\\n        for (r in 0 until h) {\\n            for (c in 0 until w) {\\n                if (isWater[r][c] == 0) continue\\n                visit[r][c] = true\\n                queue.offer(Pair(r, c))\\n            }\\n        }\\n\\n        var height = 0\\n\\n        while(!queue.isEmpty()) {\\n            var nq = LinkedList<Pair<Int, Int>>()\\n\\n            while(!queue.isEmpty()) {\\n                val coord = queue.poll()\\n                val y = coord.first\\n                val x = coord.second\\n                map[y][x] = height\\n\\n                for (direct in directs) {\\n                    val ny = y + direct[0]\\n                    val nx = x + direct[1]\\n\\n                    if (ny >= h || ny < 0) continue\\n                    if (nx >= w || nx < 0) continue\\n                    if (visit[ny][nx]) continue\\n\\n                    visit[ny][nx] = true\\n                    nq.offer(Pair(ny, nx))                    \\n                }\\n            }\\n\\n            height++\\n            queue = nq\\n        }\\n\\n        return map\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553706,
                "title": "c-best-solution-bfs-o-mn-o-mn",
                "content": "# Intuition\\n- Check all the cells looking for the water cells, then add them to the queue\\n- Run BFS in the queue adding the levels\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nm)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n        int[,] @checked = new int[isWater.Length, isWater[0].Length];\\n        var queue = new Queue<(int, int)>();\\n        \\n        for(int x = 0; x < isWater.Length; x++)\\n            for(int y = 0; y < isWater[0].Length; y++)\\n                if(isWater[x][y] == 1)\\n                {\\n                    @checked[x, y] = 1;\\n                    queue.Enqueue((x, y));\\n                }\\n\\n        int level = -1;\\n        while(queue.Count > 0)\\n        {\\n            level++;\\n            var levelSize = queue.Count;\\n            for(int i = 0; i < levelSize; i++)\\n            {\\n                var (x, y) = queue.Dequeue();\\n                isWater[x][y] = level;\\n                foreach(var (dx, dy) in Directions)\\n                    if(IsValidPoint(isWater, x + dx, y + dy) && @checked[x + dx, y + dy] == 0)\\n                    {\\n                        @checked[x + dx, y + dy] = 1;\\n                        queue.Enqueue((x + dx, y + dy));\\n                    }\\n            }\\n        }\\n\\n        return isWater;\\n    }\\n\\n    static (int, int)[] Directions = new (int, int)[] { \\n        (-1, 0), \\n        (0, 1), \\n        (1, 0), \\n        (0, -1)\\n    };\\n\\n    static bool IsValidPoint(int[][] grid, int x, int y) => \\n        (x >= 0 && y >= 0 && x < grid.Length && y < grid[x].Length);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n        int[,] @checked = new int[isWater.Length, isWater[0].Length];\\n        var queue = new Queue<(int, int)>();\\n        \\n        for(int x = 0; x < isWater.Length; x++)\\n            for(int y = 0; y < isWater[0].Length; y++)\\n                if(isWater[x][y] == 1)\\n                {\\n                    @checked[x, y] = 1;\\n                    queue.Enqueue((x, y));\\n                }\\n\\n        int level = -1;\\n        while(queue.Count > 0)\\n        {\\n            level++;\\n            var levelSize = queue.Count;\\n            for(int i = 0; i < levelSize; i++)\\n            {\\n                var (x, y) = queue.Dequeue();\\n                isWater[x][y] = level;\\n                foreach(var (dx, dy) in Directions)\\n                    if(IsValidPoint(isWater, x + dx, y + dy) && @checked[x + dx, y + dy] == 0)\\n                    {\\n                        @checked[x + dx, y + dy] = 1;\\n                        queue.Enqueue((x + dx, y + dy));\\n                    }\\n            }\\n        }\\n\\n        return isWater;\\n    }\\n\\n    static (int, int)[] Directions = new (int, int)[] { \\n        (-1, 0), \\n        (0, 1), \\n        (1, 0), \\n        (0, -1)\\n    };\\n\\n    static bool IsValidPoint(int[][] grid, int x, int y) => \\n        (x >= 0 && y >= 0 && x < grid.Length && y < grid[x].Length);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551631,
                "title": "just-a-classical-bfs-problem-commented-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n// first  make all  1 cells to 0 and push them to queue\\n//make  all next level(direct neighbours )=>1 and so on\\n// clasical level-wise BFS problem\\n\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        //push cell as {{x,y},level} to queue\\n        queue<pair<pair<int,int>,int>>q;\\n\\t\\tvector<vector<int>> visit(n,vector<int>(m,0));\\n\\n        //push all 1 cells to queue to apply bfs on these cells\\n        for(int i=0;i<n;++i){\\n        \\tfor(int j=0;j<m;++j){\\n        \\t\\tif(grid[i][j]==1){\\n                    q.push({{i,j},0});\\n                    grid[i][j]=0; //mark them as 0\\n                    visit[i][j]=1;\\n        \\t\\t}\\n        \\t}\\n        }\\n\\n       //to travserse 4 directions\\n        int dx[4]={-1,0,1,0};\\n        int dy[4]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n        \\n            auto x=q.front();q.pop();\\n\\n            int i=x.first.first,j=x.first.second;\\n            int level=x.second;\\n\\n            for(int k=0;k<4;++k){\\n                int nrow= i+ dx[k];\\n                int ncol= j+ dy[k];\\n\\n                //make the level of it\\'s neighbour as it\\'s cell value\\n                if(nrow>=0 and nrow<n and ncol>=0 and ncol<m and !visit[nrow][ncol]){\\n                    grid[nrow][ncol]=level+1;  //next level from {i,j}\\n                    visit[nrow][ncol]=1;\\n                    q.push({{nrow,ncol},level+1});\\n                }\\n            }\\n        \\t\\n        }\\n\\n        return grid;\\n    }\\n};\\n```\\n---\\n\\n- *Leave a like if you found the solution helpful.*\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n// first  make all  1 cells to 0 and push them to queue\\n//make  all next level(direct neighbours )=>1 and so on\\n// clasical level-wise BFS problem\\n\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        //push cell as {{x,y},level} to queue\\n        queue<pair<pair<int,int>,int>>q;\\n\\t\\tvector<vector<int>> visit(n,vector<int>(m,0));\\n\\n        //push all 1 cells to queue to apply bfs on these cells\\n        for(int i=0;i<n;++i){\\n        \\tfor(int j=0;j<m;++j){\\n        \\t\\tif(grid[i][j]==1){\\n                    q.push({{i,j},0});\\n                    grid[i][j]=0; //mark them as 0\\n                    visit[i][j]=1;\\n        \\t\\t}\\n        \\t}\\n        }\\n\\n       //to travserse 4 directions\\n        int dx[4]={-1,0,1,0};\\n        int dy[4]={0,1,0,-1};\\n\\n        while(!q.empty()){\\n        \\n            auto x=q.front();q.pop();\\n\\n            int i=x.first.first,j=x.first.second;\\n            int level=x.second;\\n\\n            for(int k=0;k<4;++k){\\n                int nrow= i+ dx[k];\\n                int ncol= j+ dy[k];\\n\\n                //make the level of it\\'s neighbour as it\\'s cell value\\n                if(nrow>=0 and nrow<n and ncol>=0 and ncol<m and !visit[nrow][ncol]){\\n                    grid[nrow][ncol]=level+1;  //next level from {i,j}\\n                    visit[nrow][ncol]=1;\\n                    q.push({{nrow,ncol},level+1});\\n                }\\n            }\\n        \\t\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548535,
                "title": "bfs-template-questions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- many questions in leetcode are similar to this one\\n- like number of provinces\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q, visited = deque(), set()\\n        ROWS, COLS = len(isWater), len(isWater[0])\\n        res = [[0] * COLS for i in range(ROWS)]\\n        # put water points inside res, q, and visited\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if isWater[i][j] == 1:\\n                    res[i][j] = 0\\n                    q.append((i, j, 0))\\n                    visited.add((i, j))\\n        # bfs\\n        while q:\\n            for i in range(len(q)):\\n                r, c, n = q.popleft()\\n                for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    row, col = r + dr, c + dc\\n                    if 0 <= row < ROWS and 0 <= col < COLS and (row, col) not in visited:\\n                        visited.add((row, col))\\n                        q.append((row, col, n + 1))\\n                        res[row][col] = n + 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q, visited = deque(), set()\\n        ROWS, COLS = len(isWater), len(isWater[0])\\n        res = [[0] * COLS for i in range(ROWS)]\\n        # put water points inside res, q, and visited\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if isWater[i][j] == 1:\\n                    res[i][j] = 0\\n                    q.append((i, j, 0))\\n                    visited.add((i, j))\\n        # bfs\\n        while q:\\n            for i in range(len(q)):\\n                r, c, n = q.popleft()\\n                for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                    row, col = r + dr, c + dc\\n                    if 0 <= row < ROWS and 0 <= col < COLS and (row, col) not in visited:\\n                        visited.add((row, col))\\n                        q.append((row, col, n + 1))\\n                        res[row][col] = n + 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529549,
                "title": "fully-explanation-greedy-multi-source-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Once all water cells have been initialized to a value of `0`, a Breadth-First Search (BFS) algorithm may be performed on each individual cell in order to increment the value of adjacent extensions by `1`.\\n2. The effectiveness of the greedy algorithm employed in this particular instance is derived from the utilization of a Multi-Source BFS. The selection of the first cell to be assigned a value is determined by its proximity to the nearest water cell. By incrementing the value of the current cell by `1` from its closest water cell and subsequently iterating through the remaining cells, the value assigned to the current cell must be a valid choice for its initial assignment. As a result, further visits may be bypassed as they originate from a more distant water cell.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a queue used to store the `val`, `x`, `y`.\\n2. Append all water cells into the queue.\\n3. Run BFS on each cell from the queue.\\n4. Update the `val` in `ans` if the first time visiting it and append its adj into the queue if the adj has not been assigned yet.\\n# Complexity\\n- Time complexity: O(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q = collections.deque()\\n        m, n = len(isWater), len(isWater[0])\\n        ans = [[-1] * n for _ in range(m)]\\n        # collect all water cell to be the sources of the BFS\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    q.append((0, i, j))\\n        while q:\\n            val, x, y = q.popleft() \\n            # we do not need to resign a cell since each cell is limited by its closest water cell\\n            if ans[x][y] != -1: continue\\n            ans[x][y] = val\\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                if 0 <= x+dx < m and 0 <= y+dy < n and ans[x+dx][y+dy] == -1:\\n                    q.append((val+1, x+dx, y+dy))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        q = collections.deque()\\n        m, n = len(isWater), len(isWater[0])\\n        ans = [[-1] * n for _ in range(m)]\\n        # collect all water cell to be the sources of the BFS\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    q.append((0, i, j))\\n        while q:\\n            val, x, y = q.popleft() \\n            # we do not need to resign a cell since each cell is limited by its closest water cell\\n            if ans[x][y] != -1: continue\\n            ans[x][y] = val\\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                if 0 <= x+dx < m and 0 <= y+dy < n and ans[x+dx][y+dy] == -1:\\n                    q.append((val+1, x+dx, y+dy))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525912,
                "title": "straight-forward-bfs-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n        int m = isWater.Length;\\n        int n = isWater[0].Length;\\n        int[][] maxHeight = InitializeResultMatrix(m,n);\\n        Queue<(int x, int y)> bfsQueue = new Queue<(int x, int y)>();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(isWater[i][j] == 1)\\n                    bfsQueue.Enqueue((i,j));\\n                else\\n                    maxHeight[i][j] = -1;\\n            }\\n        }\\n\\n        int[] dx = {-1, 0, 1, 0};\\n        int[] dy = {0, 1, 0, -1};\\n\\n        while(bfsQueue.Count > 0){\\n            int nn = bfsQueue.Count;\\n            for(int i = 0; i < nn; i++){\\n                var currNode = bfsQueue.Dequeue();\\n\\n                for(int d = 0; d < 4; d++){\\n                    int x = currNode.x + dx[d];\\n                    int y = currNode.y + dy[d];\\n\\n                    if(x < 0 || y < 0 || x >= m || y >= n || maxHeight[x][y] != -1)\\n                        continue;\\n\\n                    maxHeight[x][y] = maxHeight[currNode.x][currNode.y] + 1;\\n                    bfsQueue.Enqueue((x,y));\\n                }\\n            }\\n        }\\n        return maxHeight;\\n    }\\n\\n    private int[][] InitializeResultMatrix(int m, int n){\\n        int[][] result = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            result[i] = new int[n];\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n        int m = isWater.Length;\\n        int n = isWater[0].Length;\\n        int[][] maxHeight = InitializeResultMatrix(m,n);\\n        Queue<(int x, int y)> bfsQueue = new Queue<(int x, int y)>();\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(isWater[i][j] == 1)\\n                    bfsQueue.Enqueue((i,j));\\n                else\\n                    maxHeight[i][j] = -1;\\n            }\\n        }\\n\\n        int[] dx = {-1, 0, 1, 0};\\n        int[] dy = {0, 1, 0, -1};\\n\\n        while(bfsQueue.Count > 0){\\n            int nn = bfsQueue.Count;\\n            for(int i = 0; i < nn; i++){\\n                var currNode = bfsQueue.Dequeue();\\n\\n                for(int d = 0; d < 4; d++){\\n                    int x = currNode.x + dx[d];\\n                    int y = currNode.y + dy[d];\\n\\n                    if(x < 0 || y < 0 || x >= m || y >= n || maxHeight[x][y] != -1)\\n                        continue;\\n\\n                    maxHeight[x][y] = maxHeight[currNode.x][currNode.y] + 1;\\n                    bfsQueue.Enqueue((x,y));\\n                }\\n            }\\n        }\\n        return maxHeight;\\n    }\\n\\n    private int[][] InitializeResultMatrix(int m, int n){\\n        int[][] result = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            result[i] = new int[n];\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504760,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        const int n = isWater.size();\\n        const int m = isWater[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int c = 0;\\n        queue<pair<int, int>> q;\\n        vector<pair<int, int>> dirs {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (isWater[i][j] == 1) {\\n                    vis[i][j] = 1;\\n                    isWater[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        while(!q.empty()) {\\n            int p = q.size();\\n            ++c;\\n            while(p--) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for (int k = 0; k < 4; ++k) {\\n                    int di = dirs[k].first + i;\\n                    int dj = dirs[k].second + j;\\n                    if (di >= 0 && di < n && dj >= 0 && dj < m && !vis[di][dj]) {\\n                        isWater[di][dj] = c;\\n                        vis[di][dj] = 1;\\n                        q.push({di, dj});\\n                    }\\n                }\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        const int n = isWater.size();\\n        const int m = isWater[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        int c = 0;\\n        queue<pair<int, int>> q;\\n        vector<pair<int, int>> dirs {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (isWater[i][j] == 1) {\\n                    vis[i][j] = 1;\\n                    isWater[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        while(!q.empty()) {\\n            int p = q.size();\\n            ++c;\\n            while(p--) {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for (int k = 0; k < 4; ++k) {\\n                    int di = dirs[k].first + i;\\n                    int dj = dirs[k].second + j;\\n                    if (di >= 0 && di < n && dj >= 0 && dj < m && !vis[di][dj]) {\\n                        isWater[di][dj] = c;\\n                        vis[di][dj] = 1;\\n                        q.push({di, dj});\\n                    }\\n                }\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489896,
                "title": "python-3-with-bfs",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n\\n        n, m = len(isWater), len(isWater[0])\\n\\n        queue = deque([])\\n\\n        for i in range(n):\\n            for j in range(m):\\n\\n                if isWater[i][j] == 1:\\n\\n                    queue.append((i, j))\\n                    isWater[i][j] = 0\\n\\n                else:\\n                    isWater[i][j] = -1\\n\\n        DIR = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n\\n        while queue:\\n\\n            i, j = queue.popleft()\\n\\n            for y, x in DIR:\\n\\n                new_i, new_j = i + y, j + x\\n\\n                if 0 <= new_i < n and 0 <= new_j < m:\\n\\n                    if isWater[new_i][new_j] == -1:\\n                        isWater[new_i][new_j] = isWater[i][j] + 1\\n                        queue.append((new_i, new_j))\\n\\n\\n        return isWater\\n\\n            \\n\\n\\n\\n\\n         \\n\\n        \\n\\n\\n\\n\\n         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n\\n        n, m = len(isWater), len(isWater[0])\\n\\n        queue = deque([])\\n\\n        for i in range(n):\\n            for j in range(m):\\n\\n                if isWater[i][j] == 1:\\n\\n                    queue.append((i, j))\\n                    isWater[i][j] = 0\\n\\n                else:\\n                    isWater[i][j] = -1\\n\\n        DIR = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n\\n        while queue:\\n\\n            i, j = queue.popleft()\\n\\n            for y, x in DIR:\\n\\n                new_i, new_j = i + y, j + x\\n\\n                if 0 <= new_i < n and 0 <= new_j < m:\\n\\n                    if isWater[new_i][new_j] == -1:\\n                        isWater[new_i][new_j] = isWater[i][j] + 1\\n                        queue.append((new_i, new_j))\\n\\n\\n        return isWater\\n\\n            \\n\\n\\n\\n\\n         \\n\\n        \\n\\n\\n\\n\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483900,
                "title": "clean-bfs-template-for-other-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) \\n    {   \\n        int n  = water.size(),m = water[0].size();\\n        vector<vector<int>> h (n,vector<int>(m,-1));\\n        queue<pair<int,pair<int,int>>> q; // {height,{i,j}}\\n\\n        for(int i = 0; i<n;i++)\\n        for(int j = 0; j<m;j++)\\n        if(water[i][j]==1)\\n        {\\n            q.push({0,{i,j}});\\n            h[i][j] = 0 ; \\n        }\\n        int drow[] = {1,-1,0,0};\\n        int dcol[] = {0,0,1,-1};\\n\\n        while(q.size())\\n        {\\n            int height =q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n            for(int i = 0 ; i<4;i++)\\n            {\\n                int nr = row + drow[i];\\n                int nc = col + dcol[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m && h[nr][nc]==-1)\\n                {\\n                    q.push({height+1,{nr,nc}});\\n                    h[nr][nc] = height+1;\\n                }\\n            }\\n        }\\n\\n        return h ; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) \\n    {   \\n        int n  = water.size(),m = water[0].size();\\n        vector<vector<int>> h (n,vector<int>(m,-1));\\n        queue<pair<int,pair<int,int>>> q; // {height,{i,j}}\\n\\n        for(int i = 0; i<n;i++)\\n        for(int j = 0; j<m;j++)\\n        if(water[i][j]==1)\\n        {\\n            q.push({0,{i,j}});\\n            h[i][j] = 0 ; \\n        }\\n        int drow[] = {1,-1,0,0};\\n        int dcol[] = {0,0,1,-1};\\n\\n        while(q.size())\\n        {\\n            int height =q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n            for(int i = 0 ; i<4;i++)\\n            {\\n                int nr = row + drow[i];\\n                int nc = col + dcol[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m && h[nr][nc]==-1)\\n                {\\n                    q.push({height+1,{nr,nc}});\\n                    h[nr][nc] = height+1;\\n                }\\n            }\\n        }\\n\\n        return h ; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483851,
                "title": "c-easy-bfs-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInsert all 1 in queue first and mark as visited.\\nand 1  will be 0 step away from 1 .\\nThen one by one take element out of the  queue and put value(step) in dis vector.\\ncheck in all 4 direction if any element is not vis,if yes,insert that in queue while inserting dis(step) will be +1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m*4) - O(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        int delrow[] = {-1,0,+1,0};\\n        int delcol[] = {0,+1,0,-1};\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vector<vector<int>>dis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>>q;\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({{i,j},0});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int row = q.front().first.first;\\n            int col = q.front().first.second;\\n            int step = q.front().second;\\n            dis[row][col] = step;\\n            q.pop();\\n\\n            for(int i=0 ; i<4 ; i++){\\n               int nrow = row+delrow[i];\\n               int ncol = col+delcol[i];\\n               if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && !vis[nrow][ncol]){  //all are zero\\n                  q.push({{nrow,ncol},step+1});\\n                  vis[nrow][ncol] = 1;\\n               }\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        int delrow[] = {-1,0,+1,0};\\n        int delcol[] = {0,+1,0,-1};\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vector<vector<int>>dis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>>q;\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({{i,j},0});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int row = q.front().first.first;\\n            int col = q.front().first.second;\\n            int step = q.front().second;\\n            dis[row][col] = step;\\n            q.pop();\\n\\n            for(int i=0 ; i<4 ; i++){\\n               int nrow = row+delrow[i];\\n               int ncol = col+delcol[i];\\n               if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && !vis[nrow][ncol]){  //all are zero\\n                  q.push({{nrow,ncol},step+1});\\n                  vis[nrow][ncol] = 1;\\n               }\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460215,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& arr) {\\n        int m = arr.size(), n = arr[0].size();\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        queue<pair<int, int>> q;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(arr[i][j] == 1){\\n                    q.push({i, j});\\n                    res[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            //int size = q.size();\\n            auto top = q.front();\\n            q.pop();\\n            int x = top.first, y = top.second;\\n\\n            if(x > 0 && res[x-1][y] == -1){\\n                res[x-1][y] = res[x][y] + 1;\\n                q.push({x-1, y});\\n            }\\n            if(y > 0 && res[x][y-1] == -1){\\n                res[x][y-1] = res[x][y] + 1;\\n                q.push({x, y-1});\\n            }\\n            if(x < m-1 && res[x+1][y] == -1){\\n                res[x+1][y] = res[x][y] + 1;\\n                q.push({x+1, y});\\n            }\\n            if(y < n-1 && res[x][y+1] == -1){\\n                res[x][y+1] = res[x][y] + 1;\\n                q.push({x, y+1});\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& arr) {\\n        int m = arr.size(), n = arr[0].size();\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        queue<pair<int, int>> q;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(arr[i][j] == 1){\\n                    q.push({i, j});\\n                    res[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            //int size = q.size();\\n            auto top = q.front();\\n            q.pop();\\n            int x = top.first, y = top.second;\\n\\n            if(x > 0 && res[x-1][y] == -1){\\n                res[x-1][y] = res[x][y] + 1;\\n                q.push({x-1, y});\\n            }\\n            if(y > 0 && res[x][y-1] == -1){\\n                res[x][y-1] = res[x][y] + 1;\\n                q.push({x, y-1});\\n            }\\n            if(x < m-1 && res[x+1][y] == -1){\\n                res[x+1][y] = res[x][y] + 1;\\n                q.push({x+1, y});\\n            }\\n            if(y < n-1 && res[x][y+1] == -1){\\n                res[x][y+1] = res[x][y] + 1;\\n                q.push({x, y+1});\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443109,
                "title": "c-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n= isWater.size() ,m=isWater[0].size();\\n      vector<vector<int>> visited=isWater;\\n\\n      queue<pair<int,int>> q;\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n             if(visited[i][j]==1)\\n             {\\n                 visited[i][j]=-1;\\n                 q.push({i,j});\\n             }\\n          }\\n      } \\n      \\n\\n    vector<vector<int>> dir={{-1,0},{0,-1},{1,0},{0,1}};\\n      while(!q.empty())\\n      {\\n         int size=q.size();\\n\\n         for(int i=0;i<size;i++)\\n         {\\n            auto [r ,c]=q.front(); q.pop();\\n\\n            for(int k=0;k<4;k++)\\n            {\\n                int x= r+dir[k][0];\\n                int y=c+dir[k][1];\\n                if(x>=0&&x<n &&y>=0&&y<m && visited[x][y]==0)\\n                {\\n                    if(visited[r][c]==-1)\\n                    {\\n                        visited[x][y]++;\\n                    }else{\\n                        visited[x][y] += visited[r][c] +1;\\n                    }\\n                    q.push({x,y});\\n                }\\n            }\\n         }\\n       \\n      }\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(visited[i][j]==-1)\\n              {\\n                  visited[i][j]=0;\\n              }\\n          }\\n      }\\n\\n        return  visited;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n= isWater.size() ,m=isWater[0].size();\\n      vector<vector<int>> visited=isWater;\\n\\n      queue<pair<int,int>> q;\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n             if(visited[i][j]==1)\\n             {\\n                 visited[i][j]=-1;\\n                 q.push({i,j});\\n             }\\n          }\\n      } \\n      \\n\\n    vector<vector<int>> dir={{-1,0},{0,-1},{1,0},{0,1}};\\n      while(!q.empty())\\n      {\\n         int size=q.size();\\n\\n         for(int i=0;i<size;i++)\\n         {\\n            auto [r ,c]=q.front(); q.pop();\\n\\n            for(int k=0;k<4;k++)\\n            {\\n                int x= r+dir[k][0];\\n                int y=c+dir[k][1];\\n                if(x>=0&&x<n &&y>=0&&y<m && visited[x][y]==0)\\n                {\\n                    if(visited[r][c]==-1)\\n                    {\\n                        visited[x][y]++;\\n                    }else{\\n                        visited[x][y] += visited[r][c] +1;\\n                    }\\n                    q.push({x,y});\\n                }\\n            }\\n         }\\n       \\n      }\\n\\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(visited[i][j]==-1)\\n              {\\n                  visited[i][j]=0;\\n              }\\n          }\\n      }\\n\\n        return  visited;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438569,
                "title": "python-bfs-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSet to ```-1``` cells that have yet to be analysed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple BFS exploring only the cell with a negative value.\\nWe can reuse the input matrix, we do not need more memory.\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    DIRS = (\\n        (1, 0),\\n        (0, 1),\\n        (-1, 0),\\n        (0, -1),\\n    )\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        rows = len(isWater)\\n        cols = len(isWater[0])\\n        queue = deque()\\n        for i in range(rows):\\n            for j in range(cols):\\n                if isWater[i][j]:\\n                    queue.append((i,j))\\n                isWater[i][j] = -int(not isWater[i][j])\\n\\n        dist = 1\\n        while queue:\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                for dx, dy in self.DIRS:\\n                    newx, newy = x+dx, y+dy\\n                    if not (\\n                        (0 <= newx < rows) and\\n                        (0 <= newy < cols)\\n                    ) or isWater[newx][newy] >= 0:\\n                        continue\\n                    isWater[newx][newy] = dist\\n                    queue.append((newx, newy))\\n            dist += 1\\n        return isWater\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```-1```\n```\\nclass Solution:\\n    DIRS = (\\n        (1, 0),\\n        (0, 1),\\n        (-1, 0),\\n        (0, -1),\\n    )\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        rows = len(isWater)\\n        cols = len(isWater[0])\\n        queue = deque()\\n        for i in range(rows):\\n            for j in range(cols):\\n                if isWater[i][j]:\\n                    queue.append((i,j))\\n                isWater[i][j] = -int(not isWater[i][j])\\n\\n        dist = 1\\n        while queue:\\n            for _ in range(len(queue)):\\n                x, y = queue.popleft()\\n                for dx, dy in self.DIRS:\\n                    newx, newy = x+dx, y+dy\\n                    if not (\\n                        (0 <= newx < rows) and\\n                        (0 <= newy < cols)\\n                    ) or isWater[newx][newy] >= 0:\\n                        continue\\n                    isWater[newx][newy] = dist\\n                    queue.append((newx, newy))\\n            dist += 1\\n        return isWater\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432820,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n=isWater.length,m=isWater[0].length;\\n        boolean [][] visited= new boolean[n][m];\\n        LinkedList<int[]> queue = new LinkedList<int[]>();\\n        int [][] sol = new int[n][m];\\n        for (int i=0;i<n;i++)\\n            for (int j=0;j<m;j++)\\n                if (isWater[i][j]==1) visit(i,j,0,visited,queue,sol);\\n        int height =1;\\n        while (!queue.isEmpty()){\\n            int k = queue.size();\\n            for (int i=0;i<k;i++){\\n                int[] last = queue.poll();\\n                int row=last[0],col=last[1];\\n                if (row>0&&!visited[row-1][col]) visit (row-1,col,height,visited,queue,sol);\\n                if (row<n-1&&!visited[row+1][col]) visit (row+1,col,height,visited,queue,sol);\\n                if (col>0&&!visited[row][col-1]) visit (row,col-1,height,visited,queue,sol);\\n                if (col<m-1&&!visited[row][col+1]) visit (row,col+1,height,visited,queue,sol);\\n            }\\n            height++;\\n        }\\n        return sol;\\n    }\\n\\n    private void visit(int i,int j,int height,boolean [][]visited,LinkedList<int[]> queue,int [][] sol){\\n            queue.add(new int[]{i,j});\\n            visited[i][j]=true; \\n            sol[i][j]=height;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n=isWater.length,m=isWater[0].length;\\n        boolean [][] visited= new boolean[n][m];\\n        LinkedList<int[]> queue = new LinkedList<int[]>();\\n        int [][] sol = new int[n][m];\\n        for (int i=0;i<n;i++)\\n            for (int j=0;j<m;j++)\\n                if (isWater[i][j]==1) visit(i,j,0,visited,queue,sol);\\n        int height =1;\\n        while (!queue.isEmpty()){\\n            int k = queue.size();\\n            for (int i=0;i<k;i++){\\n                int[] last = queue.poll();\\n                int row=last[0],col=last[1];\\n                if (row>0&&!visited[row-1][col]) visit (row-1,col,height,visited,queue,sol);\\n                if (row<n-1&&!visited[row+1][col]) visit (row+1,col,height,visited,queue,sol);\\n                if (col>0&&!visited[row][col-1]) visit (row,col-1,height,visited,queue,sol);\\n                if (col<m-1&&!visited[row][col+1]) visit (row,col+1,height,visited,queue,sol);\\n            }\\n            height++;\\n        }\\n        return sol;\\n    }\\n\\n    private void visit(int i,int j,int height,boolean [][]visited,LinkedList<int[]> queue,int [][] sol){\\n            queue.add(new int[]{i,j});\\n            visited[i][j]=true; \\n            sol[i][j]=height;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340475,
                "title": "bfs-using-cells-with-lowest-height-no-extra-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        queue<pair<int, int>>q;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(isWater[i][j] == 1)\\n                {\\n                    isWater[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n                else\\n                    isWater[i][j] = -1;\\n            }\\n        }\\n        int delrow[] = {-1, 0, 1, 0};\\n        int delcol[] = {0, 1, 0, -1};\\n        while(!q.empty())\\n        {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            int val = isWater[row][col];\\n            q.pop();\\n            for(int i = 0 ; i < 4 ; i++)\\n            {\\n                int netrow = delrow[i] + row;\\n                int netcol = delcol[i] + col;\\n                if(netrow >= 0 && netrow < n && netcol >= 0 && netcol < m)\\n                {\\n                    if(isWater[netrow][netcol] == -1)\\n                     {\\n                        isWater[netrow][netcol] = val + 1;\\n                        q.push({netrow, netcol});\\n                     }\\n                }\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        queue<pair<int, int>>q;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                if(isWater[i][j] == 1)\\n                {\\n                    isWater[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n                else\\n                    isWater[i][j] = -1;\\n            }\\n        }\\n        int delrow[] = {-1, 0, 1, 0};\\n        int delcol[] = {0, 1, 0, -1};\\n        while(!q.empty())\\n        {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            int val = isWater[row][col];\\n            q.pop();\\n            for(int i = 0 ; i < 4 ; i++)\\n            {\\n                int netrow = delrow[i] + row;\\n                int netcol = delcol[i] + col;\\n                if(netrow >= 0 && netrow < n && netcol >= 0 && netcol < m)\\n                {\\n                    if(isWater[netrow][netcol] == -1)\\n                     {\\n                        isWater[netrow][netcol] = val + 1;\\n                        q.push({netrow, netcol});\\n                     }\\n                }\\n            }\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306900,
                "title": "easy-and-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vector<vector<int>>grid(n,vector<int>(m,0));\\n        queue<pair<int,pair<int,int>>>q;\\n\\n        for(int i = 0;i<n;i++){\\n\\n            for(int j= 0;j<m;j++){\\n\\n                if(isWater[i][j]==1){\\n                    q.push({0,{i,j}});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n\\n            int h = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n\\n            q.pop();\\n\\n            int dlrow [] = {-1,1,0,0};\\n            int dlcol [] = {0,0,-1,1};\\n\\n            for(int i = 0;i<4;i++){\\n\\n                int nrow = dlrow[i] + row;\\n                int ncol = dlcol[i] + col;\\n\\n\\n                if(nrow >=0 and ncol>=0 and nrow < n and ncol < m and vis[nrow][ncol]==0 ){\\n\\n                    grid[nrow][ncol] = 1 + h;\\n                    q.push({1+h,{nrow,ncol}});\\n                    vis[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vector<vector<int>>grid(n,vector<int>(m,0));\\n        queue<pair<int,pair<int,int>>>q;\\n\\n        for(int i = 0;i<n;i++){\\n\\n            for(int j= 0;j<m;j++){\\n\\n                if(isWater[i][j]==1){\\n                    q.push({0,{i,j}});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n\\n            int h = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n\\n            q.pop();\\n\\n            int dlrow [] = {-1,1,0,0};\\n            int dlcol [] = {0,0,-1,1};\\n\\n            for(int i = 0;i<4;i++){\\n\\n                int nrow = dlrow[i] + row;\\n                int ncol = dlcol[i] + col;\\n\\n\\n                if(nrow >=0 and ncol>=0 and nrow < n and ncol < m and vis[nrow][ncol]==0 ){\\n\\n                    grid[nrow][ncol] = 1 + h;\\n                    q.push({1+h,{nrow,ncol}});\\n                    vis[nrow][ncol] = 1;\\n                }\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297316,
                "title": "c-bfs-easy-to-understand",
                "content": "```\\n    vector<vector<int>> highestPeak(vector<vector<int>>& arr) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int n= arr.size(),m= arr[0].size();\\n        int x=0,y=0;\\n        vector<vector<int>> ans(n,vector<int> (m,1e9));\\n        for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 if(arr[i][j]==1){\\n                     ans[i][j]=0;\\n                     q.push({{i,j},0});\\n                 }\\n             }\\n         }\\n        while(q.size()){\\n             auto box = q.front();\\n             q.pop();\\n             x = box.first.first;\\n             y = box.first.second;\\n             int t = box.second;\\n            if(x+1<n && ans[x+1][y]> t+1){\\n                q.push({{x+1,y},t+1});\\n                ans[x+1][y] = t+1;\\n            }\\n            if(x-1>=0 && ans[x-1][y]>t+1){\\n                  q.push({{x-1,y},t+1});\\n                 ans[x-1][y] = t+1;\\n            }\\n            if(y+1<m && ans[x][y+1]>t+1){\\n                  q.push({{x,y+1},t+1});\\n                 ans[x][y+1] = t+1;\\n            }\\n            if(y-1>=0 && ans[x][y-1]>t+1){\\n                 q.push({{x,y-1},t+1});\\n                 ans[x][y-1] = t+1;\\n            }\\n        }\\n        return ans;\\n    }          \\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n    vector<vector<int>> highestPeak(vector<vector<int>>& arr) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int n= arr.size(),m= arr[0].size();\\n        int x=0,y=0;\\n        vector<vector<int>> ans(n,vector<int> (m,1e9));\\n        for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 if(arr[i][j]==1){\\n                     ans[i][j]=0;\\n                     q.push({{i,j},0});\\n                 }\\n             }\\n         }\\n        while(q.size()){\\n             auto box = q.front();\\n             q.pop();\\n             x = box.first.first;\\n             y = box.first.second;\\n             int t = box.second;\\n            if(x+1<n && ans[x+1][y]> t+1){\\n                q.push({{x+1,y},t+1});\\n                ans[x+1][y] = t+1;\\n            }\\n            if(x-1>=0 && ans[x-1][y]>t+1){\\n                  q.push({{x-1,y},t+1});\\n                 ans[x-1][y] = t+1;\\n            }\\n            if(y+1<m && ans[x][y+1]>t+1){\\n                  q.push({{x,y+1},t+1});\\n                 ans[x][y+1] = t+1;\\n            }\\n            if(y-1>=0 && ans[x][y-1]>t+1){\\n                 q.push({{x,y-1},t+1});\\n                 ans[x][y-1] = t+1;\\n            }\\n        }\\n        return ans;\\n    }          \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281700,
                "title": "simple-python3-bfs-solution-with-marking-when-it-is-first-visited-only",
                "content": "# Intuition\\nBfs in related topics and absence of Dfs.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nUse simple bfs and mark the cell when it is first visited only.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$ \\n\\n- Space complexity: $$O(n * m)$$\\n\\n# Code\\n```\\nfrom typing import *\\nfrom collections import *\\n\\n\\nclass Solution:\\n    def highestPeak(self, a: List[List[int]]) -> List[List[int]]:\\n        n, m = len(a), len(a[0])\\n        dp = [[0 for _ in range(m)] for _ in range(n)]\\n\\n        q = deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if a[i][j] == 1:\\n                    q.append((i, j))\\n\\n        dx, dy = [0, 0, -1, +1], [-1, +1, 0, 0]\\n        while len(q) > 0:\\n            x, y = q.popleft()\\n\\n            for k in range(4):\\n                newx, newy = x + dx[k], y + dy[k]\\n\\n                if not (0 <= newx < n and 0 <= newy < m) or dp[newx][newy] > 0 or a[newx][newy] == 1:\\n                    continue\\n\\n                dp[newx][newy] = dp[x][y] + 1\\n                q.append((newx, newy))\\n\\n        return dp\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nfrom typing import *\\nfrom collections import *\\n\\n\\nclass Solution:\\n    def highestPeak(self, a: List[List[int]]) -> List[List[int]]:\\n        n, m = len(a), len(a[0])\\n        dp = [[0 for _ in range(m)] for _ in range(n)]\\n\\n        q = deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if a[i][j] == 1:\\n                    q.append((i, j))\\n\\n        dx, dy = [0, 0, -1, +1], [-1, +1, 0, 0]\\n        while len(q) > 0:\\n            x, y = q.popleft()\\n\\n            for k in range(4):\\n                newx, newy = x + dx[k], y + dy[k]\\n\\n                if not (0 <= newx < n and 0 <= newy < m) or dp[newx][newy] > 0 or a[newx][newy] == 1:\\n                    continue\\n\\n                dp[newx][newy] = dp[x][y] + 1\\n                q.append((newx, newy))\\n\\n        return dp\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274966,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(MN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(MN)\\n# Code\\n```\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        \"\"\"\\n        :type isWater: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        def search(i,j,d):\\n            new_s = []\\n            for i_, j_ in [(1,0),(0,1),(-1,0),(0,-1)]:\\n                n_i, n_j = i + i_, j + j_\\n                if 0 <= n_i < m and 0 <= n_j < n and (n_i, n_j) not in visit:\\n                    visit.add((n_i, n_j))\\n                    res[n_i][n_j] = d+1\\n                    new_s.append((n_i, n_j)) \\n            return new_s\\n\\n        m, n = len(isWater), len(isWater[0])\\n        res = [ [0] * n for _ in range(m) ]\\n        visit = set()\\n\\n        stack = [(i,j) for i in range(m) for j in range(n) if isWater[i][j] == 1]\\n        for i,j in stack:\\n            visit.add((i,j))\\n        deep = 0\\n        while stack:\\n            temp = []           \\n            for i,j in stack:\\n                temp.extend(search(i,j,deep))\\n            \\n            stack = temp\\n            deep += 1\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def highestPeak(self, isWater):\\n        \"\"\"\\n        :type isWater: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        def search(i,j,d):\\n            new_s = []\\n            for i_, j_ in [(1,0),(0,1),(-1,0),(0,-1)]:\\n                n_i, n_j = i + i_, j + j_\\n                if 0 <= n_i < m and 0 <= n_j < n and (n_i, n_j) not in visit:\\n                    visit.add((n_i, n_j))\\n                    res[n_i][n_j] = d+1\\n                    new_s.append((n_i, n_j)) \\n            return new_s\\n\\n        m, n = len(isWater), len(isWater[0])\\n        res = [ [0] * n for _ in range(m) ]\\n        visit = set()\\n\\n        stack = [(i,j) for i in range(m) for j in range(n) if isWater[i][j] == 1]\\n        for i,j in stack:\\n            visit.add((i,j))\\n        deep = 0\\n        while stack:\\n            temp = []           \\n            for i,j in stack:\\n                temp.extend(search(i,j,deep))\\n            \\n            stack = temp\\n            deep += 1\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273832,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func highestPeak(_ isWater: [[Int]]) -> [[Int]] {\\n        \\n        var res = Array(repeating: Array(repeating: -1, count: isWater.first!.count), count: isWater.count)\\n        var i = 0\\n        var stack = Set(\\n            (0..<isWater.count)\\n                .flatMap { x in (0..<isWater[x].count).map { [x, $0] } }\\n                .filter { isWater[$0[0]][$0[1]] == 1 }\\n        )\\n        \\n        while !stack.isEmpty {\\n            var new = Set<[Int]>()\\n\\n            for p in stack where res[p[0]][p[1]] == -1 {\\n                res[p[0]][p[1]] = i\\n                [[p[0] - 1, p[1]], [p[0] + 1, p[1]], [p[0], p[1] - 1], [p[0], p[1] + 1]]\\n                    .filter { (p: [Int]) -> Bool in\\n                        p[0] >= 0 && p[0] < res.count && p[1] >= 0 && p[1] < res[p[0]].count && res[p[0]][p[1]] == -1\\n                    }\\n                    .forEach { new.insert($0) }\\n            }\\n\\n            stack = new\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func highestPeak(_ isWater: [[Int]]) -> [[Int]] {\\n        \\n        var res = Array(repeating: Array(repeating: -1, count: isWater.first!.count), count: isWater.count)\\n        var i = 0\\n        var stack = Set(\\n            (0..<isWater.count)\\n                .flatMap { x in (0..<isWater[x].count).map { [x, $0] } }\\n                .filter { isWater[$0[0]][$0[1]] == 1 }\\n        )\\n        \\n        while !stack.isEmpty {\\n            var new = Set<[Int]>()\\n\\n            for p in stack where res[p[0]][p[1]] == -1 {\\n                res[p[0]][p[1]] = i\\n                [[p[0] - 1, p[1]], [p[0] + 1, p[1]], [p[0], p[1] - 1], [p[0], p[1] + 1]]\\n                    .filter { (p: [Int]) -> Bool in\\n                        p[0] >= 0 && p[0] < res.count && p[1] >= 0 && p[1] < res[p[0]].count && res[p[0]][p[1]] == -1\\n                    }\\n                    .forEach { new.insert($0) }\\n            }\\n\\n            stack = new\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236217,
                "title": "easy-c-bfs-solution-no-need-to-make-visited-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int>a={0,0,1,-1};\\nvector<int>b={1,-1,0,0};\\n    vector<vector<int>>ans;\\n   queue<pair<int,int>>q;\\n    void bfs(vector<vector<int>>& water){\\n        while(!q.empty()){\\n                int u=q.front().first;\\n                int v=q.front().second;  \\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int ax=u+a[i];\\n                    int ay=v+b[i];\\n                    if(ax>=0&&ay>=0&&ax<water.size()&&ay<water[0].size()&&ans[ax][ay]>1+ans[u][v]){\\n                          ans[ax][ay]=1+ans[u][v];\\n                        q.push({ax,ay});\\n                      \\n                    }\\n                }\\n            \\n        }\\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) {\\n        int n=water.size();\\n        int m=water[0].size();\\n   \\n    \\n        ans.resize(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(water[i][j]==1){\\n                    q.push({i,j});\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n         bfs(water);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int>a={0,0,1,-1};\\nvector<int>b={1,-1,0,0};\\n    vector<vector<int>>ans;\\n   queue<pair<int,int>>q;\\n    void bfs(vector<vector<int>>& water){\\n        while(!q.empty()){\\n                int u=q.front().first;\\n                int v=q.front().second;  \\n                q.pop();\\n                for(int i=0;i<4;i++){\\n                    int ax=u+a[i];\\n                    int ay=v+b[i];\\n                    if(ax>=0&&ay>=0&&ax<water.size()&&ay<water[0].size()&&ans[ax][ay]>1+ans[u][v]){\\n                          ans[ax][ay]=1+ans[u][v];\\n                        q.push({ax,ay});\\n                      \\n                    }\\n                }\\n            \\n        }\\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) {\\n        int n=water.size();\\n        int m=water[0].size();\\n   \\n    \\n        ans.resize(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(water[i][j]==1){\\n                    q.push({i,j});\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n         bfs(water);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230276,
                "title": "simple-c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n=isWater.size();\\n        int m=isWater[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        vector<vector<int>> ans(n,vector<int> (m,1e9));\\n        queue<pair<pair<int,int>,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                    q.push({{i,j},0});\\n                    vis[i][j]=1;\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n        int xd[4]={0,-1,0,1};\\n        int yd[4]={1,0,-1,0};\\n        while(!q.empty())\\n        {\\n            int row=q.front().first.first;\\n            int col=q.front().first.second;\\n            int dis=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int xm=row+xd[i];\\n                int ym=col+yd[i];\\n                if(xm>=0 && xm<n && ym>=0 && ym<m && !vis[xm][ym])\\n                {\\n                    q.push({{xm,ym},dis+1});\\n                    vis[xm][ym]=1;\\n                    ans[xm][ym]=min(ans[xm][ym],dis+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n=isWater.size();\\n        int m=isWater[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        vector<vector<int>> ans(n,vector<int> (m,1e9));\\n        queue<pair<pair<int,int>,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(isWater[i][j]==1)\\n                {\\n                    q.push({{i,j},0});\\n                    vis[i][j]=1;\\n                    ans[i][j]=0;\\n                }\\n            }\\n        }\\n        int xd[4]={0,-1,0,1};\\n        int yd[4]={1,0,-1,0};\\n        while(!q.empty())\\n        {\\n            int row=q.front().first.first;\\n            int col=q.front().first.second;\\n            int dis=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int xm=row+xd[i];\\n                int ym=col+yd[i];\\n                if(xm>=0 && xm<n && ym>=0 && ym<m && !vis[xm][ym])\\n                {\\n                    q.push({{xm,ym},dis+1});\\n                    vis[xm][ym]=1;\\n                    ans[xm][ym]=min(ans[xm][ym],dis+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207731,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size() ;\\n        int n = isWater[0].size() ;\\n        vector<vector<int>>ret(m, vector<int>(n)) ;\\n        vector<vector<int>>dir{{1,0},{-1,0},{0,1},{0,-1}} ;\\n        queue<pair<int, int>> q ;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({i, j}) ;\\n                    isWater[i][j] = - 1 ;\\n                    ret[i][j] = 0 ;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            for(int i = 0; i < size; i++){\\n                auto [x, y] = q.front() ;\\n                int level = ret[x][y] ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dir[k][0] ;\\n                    int yy = y + dir[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n )\\n                        continue ;\\n                    if(isWater[xx][yy] == -1)\\n                        continue ;\\n                    isWater[xx][yy] = -1 ;\\n                    q.push({xx, yy}) ;\\n                    ret[xx][yy] = level + 1 ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size() ;\\n        int n = isWater[0].size() ;\\n        vector<vector<int>>ret(m, vector<int>(n)) ;\\n        vector<vector<int>>dir{{1,0},{-1,0},{0,1},{0,-1}} ;\\n        queue<pair<int, int>> q ;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push({i, j}) ;\\n                    isWater[i][j] = - 1 ;\\n                    ret[i][j] = 0 ;\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            for(int i = 0; i < size; i++){\\n                auto [x, y] = q.front() ;\\n                int level = ret[x][y] ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dir[k][0] ;\\n                    int yy = y + dir[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n )\\n                        continue ;\\n                    if(isWater[xx][yy] == -1)\\n                        continue ;\\n                    isWater[xx][yy] = -1 ;\\n                    q.push({xx, yy}) ;\\n                    ret[xx][yy] = level + 1 ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173892,
                "title": "simple-java-bfs-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(M * N)\\n\\n- Space complexity:\\nO(M * N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int[][] dirt = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        Queue<int[]> queue = new LinkedList<>();\\n        int m = isWater.length, n = isWater[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    queue.offer(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int[][] res = new int[m][n];\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                if (res[cur[0]][cur[1]] != 0 || level > 0 && isWater[cur[0]][cur[1]] == 1) continue;\\n                res[cur[0]][cur[1]] = level;\\n                \\n                for (int[] d : dirt) {\\n                    int x = cur[0] + d[0];\\n                    int y = cur[1] + d[1];\\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int[][] dirt = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        Queue<int[]> queue = new LinkedList<>();\\n        int m = isWater.length, n = isWater[0].length;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    queue.offer(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int[][] res = new int[m][n];\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                if (res[cur[0]][cur[1]] != 0 || level > 0 && isWater[cur[0]][cur[1]] == 1) continue;\\n                res[cur[0]][cur[1]] = level;\\n                \\n                for (int[] d : dirt) {\\n                    int x = cur[0] + d[0];\\n                    int y = cur[1] + d[1];\\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170966,
                "title": "python-3-intuitive-same-approach-as-rotting-oranges-multi-source-brbfs",
                "content": "# Intuition\\nThe intuition is same as the one used in Rotting Oranges question.\\nWe perform the multi source bfs.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMulti source bfs is implemented starting from every water cell, and a separate cost matrix is maintained which records the heights.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n**2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        n = len(isWater)\\n        m = len(isWater[0])\\n        vis = [[0 for i in range(m)] for j in range(n)]\\n        delrow = [-1,1,0,0]\\n        delcol = [0,0,1,-1]\\n        cost = [[0 for i in range(m)] for j in range(n)]\\n        l = collections.deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if isWater[i][j] == 1:\\n                    l.append([i,j,0])\\n        tm = 0\\n        while l:\\n            ele = l.popleft()\\n            r = ele[0]\\n            c = ele[1]\\n            t = ele[2]\\n            tm = max(tm,t)\\n            for i in range(4):\\n                nrow = r+delrow[i]\\n                ncol = c+delcol[i]\\n                if nrow>=0 and nrow<n and ncol>=0 and ncol<m and vis[nrow][ncol] == 0 and isWater[nrow][ncol]!=1:\\n                    vis[nrow][ncol] = 1\\n                    cost[nrow][ncol] = tm+1\\n                    l.append([nrow,ncol,tm+1])\\n        return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        n = len(isWater)\\n        m = len(isWater[0])\\n        vis = [[0 for i in range(m)] for j in range(n)]\\n        delrow = [-1,1,0,0]\\n        delcol = [0,0,1,-1]\\n        cost = [[0 for i in range(m)] for j in range(n)]\\n        l = collections.deque()\\n        for i in range(n):\\n            for j in range(m):\\n                if isWater[i][j] == 1:\\n                    l.append([i,j,0])\\n        tm = 0\\n        while l:\\n            ele = l.popleft()\\n            r = ele[0]\\n            c = ele[1]\\n            t = ele[2]\\n            tm = max(tm,t)\\n            for i in range(4):\\n                nrow = r+delrow[i]\\n                ncol = c+delcol[i]\\n                if nrow>=0 and nrow<n and ncol>=0 and ncol<m and vis[nrow][ncol] == 0 and isWater[nrow][ncol]!=1:\\n                    vis[nrow][ncol] = 1\\n                    cost[nrow][ncol] = tm+1\\n                    l.append([nrow,ncol,tm+1])\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168653,
                "title": "c-very-easy-bfs-solution-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={0,0,-1,1};\\nint dy[4]={-1,1,0,0};\\n\\n    void bfs(queue<pair<int,int>> &q,vector<vector<int>>& water,vector<vector<int>> &vis){\\n        while(!q.empty()){\\n            int a=q.front().first;\\n            int b=q.front().second;\\n            q.pop();\\n            //water[a][b]=0;\\n            vis[a][b]=1;\\n            for(int i=0;i<4;i++){\\n                int x=a+dx[i];\\n                int y=b+dy[i];\\n                if(x>=0 && x<n && y>=0 && y<m && vis[x][y]==0 ){\\n                    vis[x][y]=1;\\n                    water[x][y]=water[a][b]+1;\\n                    q.push({x,y});\\n                }\\n            }\\n\\n        }\\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) {\\n        queue<pair<int,int>>q;\\n        n=water.size();\\n        m=water[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(water[i][j]==1){\\n                   q.push({i,j});\\n                   vis[i][j]=1;\\n                   water[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n       \\n        bfs(q,water,vis);\\n        return water;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={0,0,-1,1};\\nint dy[4]={-1,1,0,0};\\n\\n    void bfs(queue<pair<int,int>> &q,vector<vector<int>>& water,vector<vector<int>> &vis){\\n        while(!q.empty()){\\n            int a=q.front().first;\\n            int b=q.front().second;\\n            q.pop();\\n            //water[a][b]=0;\\n            vis[a][b]=1;\\n            for(int i=0;i<4;i++){\\n                int x=a+dx[i];\\n                int y=b+dy[i];\\n                if(x>=0 && x<n && y>=0 && y<m && vis[x][y]==0 ){\\n                    vis[x][y]=1;\\n                    water[x][y]=water[a][b]+1;\\n                    q.push({x,y});\\n                }\\n            }\\n\\n        }\\n    }\\n    vector<vector<int>> highestPeak(vector<vector<int>>& water) {\\n        queue<pair<int,int>>q;\\n        n=water.size();\\n        m=water[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(water[i][j]==1){\\n                   q.push({i,j});\\n                   vis[i][j]=1;\\n                   water[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n       \\n        bfs(q,water,vis);\\n        return water;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158419,
                "title": "c-bfs-solution-explained",
                "content": "# Intuition\\n\\nMy first thought for solving this problem would be to use a BFS approach. \\n\\n# Approach\\n\\nThe approach I used to solve this problem was a BFS approach, as described in the intuition. We can traverse the matrix and for each cell check if it is water, if it is, we set the cell to 0 and add it to the queue. Then, for each cell in the queue, we can check its neighbors and if they are not water, we set them to the current cell\\'s value plus one, and add them to the queue. This way, we can traverse the matrix and for each cell that is not water, set it to the value of the closest water cell plus one.\\n\\n# Complexity\\n\\n- Time complexity: $$O(mn)$$\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (isWater[i][j]) {\\n                    res[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        while (!q.empty()) {\\n            int i = q.front().first, j = q.front().second;\\n            q.pop();\\n            if (i > 0 && res[i - 1][j] == -1) {\\n                res[i - 1][j] = res[i][j] + 1;\\n                q.push({i - 1, j});\\n            }\\n            if (i < m - 1 && res[i + 1][j] == -1) {\\n                res[i + 1][j] = res[i][j] + 1;\\n                q.push({i + 1, j});\\n            }\\n            if (j > 0 && res[i][j - 1] == -1) {\\n                res[i][j - 1] = res[i][j] + 1;\\n                q.push({i, j - 1});\\n            }\\n            if (j < n - 1 && res[i][j + 1] == -1) {\\n                res[i][j + 1] = res[i][j] + 1;\\n                q.push({i, j + 1});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (isWater[i][j]) {\\n                    res[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        while (!q.empty()) {\\n            int i = q.front().first, j = q.front().second;\\n            q.pop();\\n            if (i > 0 && res[i - 1][j] == -1) {\\n                res[i - 1][j] = res[i][j] + 1;\\n                q.push({i - 1, j});\\n            }\\n            if (i < m - 1 && res[i + 1][j] == -1) {\\n                res[i + 1][j] = res[i][j] + 1;\\n                q.push({i + 1, j});\\n            }\\n            if (j > 0 && res[i][j - 1] == -1) {\\n                res[i][j - 1] = res[i][j] + 1;\\n                q.push({i, j - 1});\\n            }\\n            if (j < n - 1 && res[i][j + 1] == -1) {\\n                res[i][j + 1] = res[i][j] + 1;\\n                q.push({i, j + 1});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3148554,
                "title": "python-multi-source-bfs",
                "content": "```\\nclass Solution:\\n    def highestPeak(self, isWater):\\n        m, n = len(isWater), len(isWater[0])\\n        queue, seen = [], set()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    queue.append((i, j))\\n                    seen.add((i, j))\\n                    isWater[i][j] = 0\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                i, j = queue.pop(0)\\n                for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in seen:\\n                        queue.append((x, y))\\n                        seen.add((x, y))\\n                        isWater[x][y] = isWater[i][j] + 1\\n        return isWater\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater):\\n        m, n = len(isWater), len(isWater[0])\\n        queue, seen = [], set()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1:\\n                    queue.append((i, j))\\n                    seen.add((i, j))\\n                    isWater[i][j] = 0\\n        while queue:\\n            size = len(queue)\\n            for _ in range(size):\\n                i, j = queue.pop(0)\\n                for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                    if 0 <= x < m and 0 <= y < n and (x, y) not in seen:\\n                        queue.append((x, y))\\n                        seen.add((x, y))\\n                        isWater[x][y] = isWater[i][j] + 1\\n        return isWater\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140818,
                "title": "c-bfs-concise-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    bool w[1001][1001]{};\\n    vector<vector<int>> highestPeak(vector<vector<int>>& m) {\\n        int ms = m.size(), mss = m.front().size();\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < ms; i++) {\\n            for (int j = 0; j < mss; j++) {\\n                if (m[i][j]) {\\n                    m[i][j] = 0;\\n                    q.push({i, j});\\n                    w[i][j] = true;\\n                }\\n            }\\n        }\\n        while (!q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n            \\n            for (auto [i, j] : {pair<int, int>{x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}}) {\\n                if (i >= 0 and j >= 0 and i < ms and j < mss and !w[i][j] and !m[i][j]) {\\n                    m[i][j] = m[x][y] + 1;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool w[1001][1001]{};\\n    vector<vector<int>> highestPeak(vector<vector<int>>& m) {\\n        int ms = m.size(), mss = m.front().size();\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < ms; i++) {\\n            for (int j = 0; j < mss; j++) {\\n                if (m[i][j]) {\\n                    m[i][j] = 0;\\n                    q.push({i, j});\\n                    w[i][j] = true;\\n                }\\n            }\\n        }\\n        while (!q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n            \\n            for (auto [i, j] : {pair<int, int>{x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}}) {\\n                if (i >= 0 and j >= 0 and i < ms and j < mss and !w[i][j] and !m[i][j]) {\\n                    m[i][j] = m[x][y] + 1;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083208,
                "title": "slow-scala-bfs-recursion",
                "content": "# Code\\n```\\n  def highestPeak(arr: Array[Array[Int]]): Array[Array[Int]] = {\\n    for{ i <- (0 until (arr.size)) ; j <- (0 until (arr(0).size))}{arr(i)(j) = 1-arr(i)(j)}\\n    lazy val set = (0 until (arr.size)).flatMap{i =>\\n      (0 until (arr(0).size)).flatMap{j => Set(\\n        if(i>0 && arr(i)(j) != arr(i-1)(j)) {if(arr(i)(j)==0) Some((i,j)) else Some((i-1,j)) } else None,\\n        if(j>0 && arr(i)(j) != arr(i)(j-1)) {if(arr(i)(j)==0) Some((i,j)) else Some((i,j-1)) } else None\\n    ).flatten}.toSet}.toSet\\n    def impl(level: Int, set: Set[(Int,Int)], visited: Set[(Int,Int)]): Array[Array[Int]]  =\\n      if(set.isEmpty) arr else {\\n        lazy val newSet = set.flatMap{case (i,j) =>\\n          List((i-1, j), (i+1, j), (i, j-1), (i, j+1)).filter{case (a,b) =>\\n            a >= 0 && a < arr.size && b >= 0 && b < arr(0).size && arr(a)(b) != 0 && !visited.contains(a,b)\\n          }\\n        }\\n        newSet.foreach{case (i,j) => arr(i)(j) = level}\\n        impl(level+1, newSet, visited++newSet)\\n      }\\n    impl(1, set, set)\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n  def highestPeak(arr: Array[Array[Int]]): Array[Array[Int]] = {\\n    for{ i <- (0 until (arr.size)) ; j <- (0 until (arr(0).size))}{arr(i)(j) = 1-arr(i)(j)}\\n    lazy val set = (0 until (arr.size)).flatMap{i =>\\n      (0 until (arr(0).size)).flatMap{j => Set(\\n        if(i>0 && arr(i)(j) != arr(i-1)(j)) {if(arr(i)(j)==0) Some((i,j)) else Some((i-1,j)) } else None,\\n        if(j>0 && arr(i)(j) != arr(i)(j-1)) {if(arr(i)(j)==0) Some((i,j)) else Some((i,j-1)) } else None\\n    ).flatten}.toSet}.toSet\\n    def impl(level: Int, set: Set[(Int,Int)], visited: Set[(Int,Int)]): Array[Array[Int]]  =\\n      if(set.isEmpty) arr else {\\n        lazy val newSet = set.flatMap{case (i,j) =>\\n          List((i-1, j), (i+1, j), (i, j-1), (i, j+1)).filter{case (a,b) =>\\n            a >= 0 && a < arr.size && b >= 0 && b < arr(0).size && arr(a)(b) != 0 && !visited.contains(a,b)\\n          }\\n        }\\n        newSet.foreach{case (i,j) => arr(i)(j) = level}\\n        impl(level+1, newSet, visited++newSet)\\n      }\\n    impl(1, set, set)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3079599,
                "title": "java-space-98-time-98-bfs",
                "content": "# Intuition\\nIt would not be intuitive to try to traverse the matrix linearly or in some pattern.  It makes the most sense to start at the points of water and spread out by hitting all adjacent spots of water, then all adjacent spots of those spots, and so on until every spot is filled.  This ensures that the height increases as you move away from water spots.\\n\\n# Approach\\nWe can first fill all spots adjacent to water with height 1, increment the height, then fill all adjacent spots of those with height 2, and so on.  \\n\\nTo hit all of these spots in order, we use a queue.  We do one linear traversal through the matrix to find the water spots and put them in the queue.  We set them to -1 (this will help later).\\n\\nNow the queue is filled with all the water spots.  We remove the (r,c) coords of the first water spot from the queue, then fill the adjacent spots with height 1.  If an adjacent spot is in bounds and has height 0, it is filled with the height (we set water spots to -1 earlier so they are skipped).  The (r,c) coords of these adjacent spots are put into the queue.  Once all water spots come out of the queue, we increment the height to 2, and start removing spots with height 1 from the queue.  The spots adjacent to these are then filled with height 2, and put into the queue.  This process continues until the queue is empty, which means all spots on the board were filled.\\n \\n# Complexity\\n- Time complexity:\\n    - First linear pass\\n    -       m x n\\n    - Filling the spots (4 adjacency checks per spot in the matrix)\\n    -       4 (m x n)\\n    - Final linear pass\\n    -       m x n\\n    - This simplifies to O( m x n )\\n\\n- Space complexity:\\n    - No additional space for the matrix because the passed matrix is reused\\n    - There are two queues, one for row and one for col.  These can have up to (m x n) entries each\\n    -       2 (m x n)\\n    - This simplifies to O( m x n )\\n\\n# Code\\n```\\nclass Solution {    \\n    public int[][] highestPeak(int[][] isWater) {\\n        Queue<Integer> rows = new ArrayDeque<>();\\n        Queue<Integer> cols = new ArrayDeque<>();\\n\\n        int maxR = isWater.length - 1;\\n        int maxC = isWater[0].length - 1;\\n\\n        // Put water spot coords in queues, set water spots to -1 height so the filling algorithm\\n        // avoids these spots (it only fills spots with height=0)\\n        for (int r = 0; r <= maxR; r++) {\\n            for (int c = 0; c <= maxC; c++) {\\n                if (isWater[r][c] == 1) {\\n                    rows.add(r);\\n                    cols.add(c);\\n                    isWater[r][c] = -1;\\n                }\\n            }\\n        }\\n\\n        int currentHeight = 1;\\n        int r;\\n        int c;\\n        \\n        // Fill the matrix by\\n        // (1) getting the next position from the queue, \\n        // (2) filling the 4 adjacent spots with the current height if they have not been already filled\\n        // (3) incrementing the height after filling around all spots of the current height\\n        while (!rows.isEmpty() && !cols.isEmpty()) {\\n\\n            // (1) get next position from the queue\\n            r = rows.remove();\\n            c = cols.remove();\\n\\n            // (3) increment the current height\\n            if (isWater[r][c] == currentHeight)\\n                currentHeight++;\\n\\n            // (2) Check 4 adjacent spots and fill them if they have not been filled\\n            if (r > 0 && isWater[r-1][c] == 0) {\\n                isWater[r-1][c] = currentHeight;\\n                rows.add(r-1);\\n                cols.add(c);\\n            }\\n            if (r < maxR && isWater[r+1][c] == 0) {\\n                isWater[r+1][c] = currentHeight;\\n                rows.add(r+1);\\n                cols.add(c);\\n            }\\n            if (c > 0 && isWater[r][c-1] == 0) {\\n                isWater[r][c-1] = currentHeight;\\n                rows.add(r);\\n                cols.add(c-1);\\n            }\\n            if (c < maxC && isWater[r][c+1] == 0) {\\n                isWater[r][c+1] = currentHeight;\\n                rows.add(r);\\n                cols.add(c+1);\\n            }\\n        }\\n\\n        // Final matrix pass to change all water spots from -1 to 0\\n        for (r = 0; r <= maxR; r++) {\\n            for (c = 0; c <= maxC; c++) {\\n                if (isWater[r][c] == -1) {\\n                    isWater[r][c] = 0;\\n                }\\n            }\\n        }\\n\\n        return isWater;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    public int[][] highestPeak(int[][] isWater) {\\n        Queue<Integer> rows = new ArrayDeque<>();\\n        Queue<Integer> cols = new ArrayDeque<>();\\n\\n        int maxR = isWater.length - 1;\\n        int maxC = isWater[0].length - 1;\\n\\n        // Put water spot coords in queues, set water spots to -1 height so the filling algorithm\\n        // avoids these spots (it only fills spots with height=0)\\n        for (int r = 0; r <= maxR; r++) {\\n            for (int c = 0; c <= maxC; c++) {\\n                if (isWater[r][c] == 1) {\\n                    rows.add(r);\\n                    cols.add(c);\\n                    isWater[r][c] = -1;\\n                }\\n            }\\n        }\\n\\n        int currentHeight = 1;\\n        int r;\\n        int c;\\n        \\n        // Fill the matrix by\\n        // (1) getting the next position from the queue, \\n        // (2) filling the 4 adjacent spots with the current height if they have not been already filled\\n        // (3) incrementing the height after filling around all spots of the current height\\n        while (!rows.isEmpty() && !cols.isEmpty()) {\\n\\n            // (1) get next position from the queue\\n            r = rows.remove();\\n            c = cols.remove();\\n\\n            // (3) increment the current height\\n            if (isWater[r][c] == currentHeight)\\n                currentHeight++;\\n\\n            // (2) Check 4 adjacent spots and fill them if they have not been filled\\n            if (r > 0 && isWater[r-1][c] == 0) {\\n                isWater[r-1][c] = currentHeight;\\n                rows.add(r-1);\\n                cols.add(c);\\n            }\\n            if (r < maxR && isWater[r+1][c] == 0) {\\n                isWater[r+1][c] = currentHeight;\\n                rows.add(r+1);\\n                cols.add(c);\\n            }\\n            if (c > 0 && isWater[r][c-1] == 0) {\\n                isWater[r][c-1] = currentHeight;\\n                rows.add(r);\\n                cols.add(c-1);\\n            }\\n            if (c < maxC && isWater[r][c+1] == 0) {\\n                isWater[r][c+1] = currentHeight;\\n                rows.add(r);\\n                cols.add(c+1);\\n            }\\n        }\\n\\n        // Final matrix pass to change all water spots from -1 to 0\\n        for (r = 0; r <= maxR; r++) {\\n            for (c = 0; c <= maxC; c++) {\\n                if (isWater[r][c] == -1) {\\n                    isWater[r][c] = 0;\\n                }\\n            }\\n        }\\n\\n        return isWater;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077362,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] water) {\\n        int m = water.length;int n = water[0].length;\\n        \\n        int height[][]  = new int[m][n];\\n        int vis[][] = new int[m][n];\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(water[i][j] == 1){\\n                    vis[i][j]=1;\\n                    f(water,height,i,j,vis);\\n                }\\n            }\\n        }\\n        Queue<Pair> q=new LinkedList<>();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(height[i][j]==1)q.add(new Pair(i,j));\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            \\n            Pair p =q.poll();\\n            int drow[] = {1,0,-1,0};\\n        int dcol[] ={0,1,0,-1};\\n        \\n        for(int i=0;i<4;i++){\\n            int dr= p.r+drow[i];int dc= p.c+dcol[i];\\n            \\n            if(dr>=0 && dc>=0 && dr<water.length && dc<water[0].length && vis[dr][dc]==0){\\n                vis[dr][dc]=1;\\n                height[dr][dc] = 1+height[p.r][p.c];\\n                q.add(new Pair(dr,dc));\\n            }\\n            \\n        }\\n            \\n    }\\n        return height;\\n    }\\n\\n    \\npublic void f(int water[][],int height[][],int r,int c,int vis[][]){\\n        int drow[] = {1,0,-1,0};\\n        int dcol[] ={0,1,0,-1};\\n    \\n        height[r][c]=0;\\n        \\n        for(int i=0;i<4;i++){\\n            int dr= r+drow[i];int dc= c+dcol[i];\\n            \\n            if(dr>=0 && dc>=0 && dr<water.length && dc<water[0].length){\\n                if(water[dr][dc]==1)height[dr][dc]=0;\\n                else height[dr][dc]=1;\\n                vis[dr][dc]=1;\\n                }\\n    \\n        }\\n    }\\n}\\n\\nclass Pair{\\n    int r;int c;\\n    \\n    public Pair(int r,int c){\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] water) {\\n        int m = water.length;int n = water[0].length;\\n        \\n        int height[][]  = new int[m][n];\\n        int vis[][] = new int[m][n];\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(water[i][j] == 1){\\n                    vis[i][j]=1;\\n                    f(water,height,i,j,vis);\\n                }\\n            }\\n        }\\n        Queue<Pair> q=new LinkedList<>();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(height[i][j]==1)q.add(new Pair(i,j));\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            \\n            Pair p =q.poll();\\n            int drow[] = {1,0,-1,0};\\n        int dcol[] ={0,1,0,-1};\\n        \\n        for(int i=0;i<4;i++){\\n            int dr= p.r+drow[i];int dc= p.c+dcol[i];\\n            \\n            if(dr>=0 && dc>=0 && dr<water.length && dc<water[0].length && vis[dr][dc]==0){\\n                vis[dr][dc]=1;\\n                height[dr][dc] = 1+height[p.r][p.c];\\n                q.add(new Pair(dr,dc));\\n            }\\n            \\n        }\\n            \\n    }\\n        return height;\\n    }\\n\\n    \\npublic void f(int water[][],int height[][],int r,int c,int vis[][]){\\n        int drow[] = {1,0,-1,0};\\n        int dcol[] ={0,1,0,-1};\\n    \\n        height[r][c]=0;\\n        \\n        for(int i=0;i<4;i++){\\n            int dr= r+drow[i];int dc= c+dcol[i];\\n            \\n            if(dr>=0 && dc>=0 && dr<water.length && dc<water[0].length){\\n                if(water[dr][dc]==1)height[dr][dc]=0;\\n                else height[dr][dc]=1;\\n                vis[dr][dc]=1;\\n                }\\n    \\n        }\\n    }\\n}\\n\\nclass Pair{\\n    int r;int c;\\n    \\n    public Pair(int r,int c){\\n        this.r = r;\\n        this.c = c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044655,
                "title": "c-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> highestPeak(vector<vector<int>>& arr) \\n    {\\n        //no of rows and colmns for the arr\\n        n = arr.size();\\n        m = arr[0].size();\\n        \\n        //final vector to return from this function\\n        vector<vector<int>>ans;\\n        ans.resize(arr.size(),vector<int>(arr[0].size(),-1));\\n        \\n        //will hold the curr cordinate for the bfs traversal\\n        queue<vector<int>>q;\\n        \\n        //finding the water cell in the matrix\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr[i].size();j++)\\n            {\\n                if(arr[i][j] == 1)  //the the curr cell is water cell\\n                {\\n                    ans[i][j] = 0;\\n                    q.push({i,j,0});\\n                }\\n            }\\n        }\\n        \\n        //bfs on all the cells\\n        while(!q.empty())\\n        {\\n            vector<int> v = q.front();\\n            q.pop();\\n            \\n            int row = v[0];\\n            int col = v[1];\\n            int currval = v[2];\\n            \\n            //checking if the upper nbr is aval\\n            if(isValid(row-1,col)==true and ans[row-1][col]==-1)\\n            {\\n                ans[row-1][col] = currval+1;\\n                q.push({row-1,col,currval+1});\\n            }\\n            if(isValid(row,col+1)==true and ans[row][col+1]==-1)\\n            {\\n                ans[row][col+1] = currval+1;\\n                q.push({row,col+1,currval+1});\\n            }\\n            if(isValid(row+1,col)==true and ans[row+1][col]==-1)\\n            {\\n                ans[row+1][col] = currval+1;\\n                q.push({row+1,col,currval+1});\\n            }\\n            if(isValid(row,col-1)==true and ans[row][col-1]==-1)\\n            {\\n                ans[row][col-1] = currval+1;\\n                q.push({row,col-1,currval+1});\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isValid(int row,int col)\\n    {\\n        if(row<0 or row>=n or col<0 or col>=m)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> highestPeak(vector<vector<int>>& arr) \\n    {\\n        //no of rows and colmns for the arr\\n        n = arr.size();\\n        m = arr[0].size();\\n        \\n        //final vector to return from this function\\n        vector<vector<int>>ans;\\n        ans.resize(arr.size(),vector<int>(arr[0].size(),-1));\\n        \\n        //will hold the curr cordinate for the bfs traversal\\n        queue<vector<int>>q;\\n        \\n        //finding the water cell in the matrix\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr[i].size();j++)\\n            {\\n                if(arr[i][j] == 1)  //the the curr cell is water cell\\n                {\\n                    ans[i][j] = 0;\\n                    q.push({i,j,0});\\n                }\\n            }\\n        }\\n        \\n        //bfs on all the cells\\n        while(!q.empty())\\n        {\\n            vector<int> v = q.front();\\n            q.pop();\\n            \\n            int row = v[0];\\n            int col = v[1];\\n            int currval = v[2];\\n            \\n            //checking if the upper nbr is aval\\n            if(isValid(row-1,col)==true and ans[row-1][col]==-1)\\n            {\\n                ans[row-1][col] = currval+1;\\n                q.push({row-1,col,currval+1});\\n            }\\n            if(isValid(row,col+1)==true and ans[row][col+1]==-1)\\n            {\\n                ans[row][col+1] = currval+1;\\n                q.push({row,col+1,currval+1});\\n            }\\n            if(isValid(row+1,col)==true and ans[row+1][col]==-1)\\n            {\\n                ans[row+1][col] = currval+1;\\n                q.push({row+1,col,currval+1});\\n            }\\n            if(isValid(row,col-1)==true and ans[row][col-1]==-1)\\n            {\\n                ans[row][col-1] = currval+1;\\n                q.push({row,col-1,currval+1});\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isValid(int row,int col)\\n    {\\n        if(row<0 or row>=n or col<0 or col>=m)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012688,
                "title": "clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(isWater), len(isWater[0])\\n        queue = deque()\\n        heights = [[None]*COLS for _ in range(ROWS)]\\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                if isWater[r][c] == 1:\\n                    queue.append((r, c, 0))\\n                    heights[r][c] = 0\\n        \\n        while queue:\\n            r, c, dis = queue.popleft()\\n            \\n            directions = [[0,1], [1,0], [0,-1], [-1,0]]\\n            for i, j in directions:\\n                currR, currC = r+i, c+j\\n                if 0<= currR < ROWS and 0 <= currC < COLS and heights[currR][currC] == None:\\n                    queue.append((currR, currC, dis+1))\\n                    heights[currR][currC] = dis+1\\n\\n        return heights    \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(isWater), len(isWater[0])\\n        queue = deque()\\n        heights = [[None]*COLS for _ in range(ROWS)]\\n\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                if isWater[r][c] == 1:\\n                    queue.append((r, c, 0))\\n                    heights[r][c] = 0\\n        \\n        while queue:\\n            r, c, dis = queue.popleft()\\n            \\n            directions = [[0,1], [1,0], [0,-1], [-1,0]]\\n            for i, j in directions:\\n                currR, currC = r+i, c+j\\n                if 0<= currR < ROWS and 0 <= currC < COLS and heights[currR][currC] == None:\\n                    queue.append((currR, currC, dis+1))\\n                    heights[currR][currC] = dis+1\\n\\n        return heights    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009197,
                "title": "python-dijkstra-bfs-from-water-cells",
                "content": "# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        # Do BFS starting from all water cells at the same time.\\n        # Active cells are those from which we are currently searching.\\n        # Initially, active cells are water cells.\\n        # Use deque so we can pop from one end and append to the other end.\\n        active = collections.deque()\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        height = [[None] * n for i in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]:\\n                    active.append([i, j])\\n                    height[i][j] = 0\\n        while active:\\n            i, j = active.popleft()\\n            for [k, l] in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:\\n                if 0 <= k < m and 0 <= l < n and height[k][l] is None:\\n                    height[k][l] = height[i][j] + 1\\n                    active.append([k, l])\\n        return height\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        # Do BFS starting from all water cells at the same time.\\n        # Active cells are those from which we are currently searching.\\n        # Initially, active cells are water cells.\\n        # Use deque so we can pop from one end and append to the other end.\\n        active = collections.deque()\\n        m = len(isWater)\\n        n = len(isWater[0])\\n        height = [[None] * n for i in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]:\\n                    active.append([i, j])\\n                    height[i][j] = 0\\n        while active:\\n            i, j = active.popleft()\\n            for [k, l] in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:\\n                if 0 <= k < m and 0 <= l < n and height[k][l] is None:\\n                    height[k][l] = height[i][j] + 1\\n                    active.append([k, l])\\n        return height\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974244,
                "title": "easy-to-understand-c-bfs-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<vector<int>> dir = {{0,-1},{0,1},{-1,0},{1,0}};\\n        int r = isWater.size(); int c = isWater[0].size();\\n        vector<vector<int>> result(r,vector<int>(c,-1));\\n        \\n        // Idea is to start with water cell, as it gaurenteed to have height 0 and all its\\n        // neighbour which are land should have height 1 at max.\\n        queue<pair<int,int>> q;\\n        int level = 0;\\n        for(int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (isWater[i][j]) {\\n                    result[i][j] = level;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        //Iterate through first level as water and then discover next set of land phase by phase, \\n        // keep assinging the new leve to subsequent iteration new disovered lands, this \\n        // gaurantees the rule as each land found by new land has height by 1 only\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            level++;\\n            for (int i = 0; i < sz; i++) {\\n                auto [x,y] = q.front(); q.pop();\\n                for (auto &d : dir) {\\n                    int nx = x + d[0]; int ny = y + d[1];\\n                    if (nx < 0 || nx >= r || ny < 0 || ny >= c || result[nx][ny] != -1)\\n                        continue;\\n                    result[nx][ny] = level;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<vector<int>> dir = {{0,-1},{0,1},{-1,0},{1,0}};\\n        int r = isWater.size(); int c = isWater[0].size();\\n        vector<vector<int>> result(r,vector<int>(c,-1));\\n        \\n        // Idea is to start with water cell, as it gaurenteed to have height 0 and all its\\n        // neighbour which are land should have height 1 at max.\\n        queue<pair<int,int>> q;\\n        int level = 0;\\n        for(int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (isWater[i][j]) {\\n                    result[i][j] = level;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        //Iterate through first level as water and then discover next set of land phase by phase, \\n        // keep assinging the new leve to subsequent iteration new disovered lands, this \\n        // gaurantees the rule as each land found by new land has height by 1 only\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            level++;\\n            for (int i = 0; i < sz; i++) {\\n                auto [x,y] = q.front(); q.pop();\\n                for (auto &d : dir) {\\n                    int nx = x + d[0]; int ny = y + d[1];\\n                    if (nx < 0 || nx >= r || ny < 0 || ny >= c || result[nx][ny] != -1)\\n                        continue;\\n                    result[nx][ny] = level;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945563,
                "title": "python-bfs-o-mn",
                "content": "# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        que = deque()\\n        m, n = len(isWater), len(isWater[0])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]:\\n                    que.append((i,j,0))\\n                    visited.add((i,j))\\n        while que:\\n            i,j,d = que.popleft()\\n            isWater[i][j] = d\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=i+di<m and 0<=j+dj<n and (i+di,j+dj) not in visited:\\n                    que.append((i+di,j+dj,d+1))\\n                    visited.add((i+di,j+dj))\\n        return isWater\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        que = deque()\\n        m, n = len(isWater), len(isWater[0])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j]:\\n                    que.append((i,j,0))\\n                    visited.add((i,j))\\n        while que:\\n            i,j,d = que.popleft()\\n            isWater[i][j] = d\\n            for di,dj in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                if 0<=i+di<m and 0<=j+dj<n and (i+di,j+dj) not in visited:\\n                    que.append((i+di,j+dj,d+1))\\n                    visited.add((i+di,j+dj))\\n        return isWater\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901442,
                "title": "c-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size() , n = isWater[0].size();\\n        int dir[5] = {-1 , 0 , 1 , 0 , -1};\\n        vector<vector<int>>vis(m , vector<int>(n));\\n        queue<pair<pair<int,int> , int>>q;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && isWater[i][j]){\\n                    vis[i][j] = 1;\\n                    for(int k = 0; k < 4; k++){\\n                        int nr = i + dir[k] , nc = j + dir[k + 1];\\n                        if(nr >= 0 && nc >= 0 && nr < m && nc < n && isWater[nr][nc] == 0 && !vis[nr][nc]){\\n                            isWater[nr][nc] = 1;\\n                            vis[nr][nc] = 1;\\n                            q.push({{nr , nc}, 1});\\n                        }\\n                    }\\n                    isWater[i][j] = 0;\\n                }\\n            }\\n        }   \\n        while(q.size()){\\n            int r = q.front().first.first , c = q.front().first.second ,h = q.front().second;\\n            for(int k = 0; k < 4; k++){\\n                int nr = r + dir[k] , nc = c + dir[k + 1];\\n                if(nr >= 0 && nc >= 0 && nr < m && nc < n && !vis[nr][nc]){\\n                    isWater[nr][nc] = h + 1;\\n                    q.push({{nr , nc}, h + 1});\\n                    vis[nr][nc] = 1;\\n                }\\n            }\\n            q.pop();\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size() , n = isWater[0].size();\\n        int dir[5] = {-1 , 0 , 1 , 0 , -1};\\n        vector<vector<int>>vis(m , vector<int>(n));\\n        queue<pair<pair<int,int> , int>>q;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(!vis[i][j] && isWater[i][j]){\\n                    vis[i][j] = 1;\\n                    for(int k = 0; k < 4; k++){\\n                        int nr = i + dir[k] , nc = j + dir[k + 1];\\n                        if(nr >= 0 && nc >= 0 && nr < m && nc < n && isWater[nr][nc] == 0 && !vis[nr][nc]){\\n                            isWater[nr][nc] = 1;\\n                            vis[nr][nc] = 1;\\n                            q.push({{nr , nc}, 1});\\n                        }\\n                    }\\n                    isWater[i][j] = 0;\\n                }\\n            }\\n        }   \\n        while(q.size()){\\n            int r = q.front().first.first , c = q.front().first.second ,h = q.front().second;\\n            for(int k = 0; k < 4; k++){\\n                int nr = r + dir[k] , nc = c + dir[k + 1];\\n                if(nr >= 0 && nc >= 0 && nr < m && nc < n && !vis[nr][nc]){\\n                    isWater[nr][nc] = h + 1;\\n                    q.push({{nr , nc}, h + 1});\\n                    vis[nr][nc] = 1;\\n                }\\n            }\\n            q.pop();\\n        }\\n        return isWater;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845072,
                "title": "simple-c-bfs-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) \\n    {\\n        vector<pair<int,int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        int rows=isWater.size();\\n        int cols=isWater[0].size();\\n        vector<vector<int>> ans(rows, vector<int> (cols,0));\\n        queue<pair<int,int>> q;\\n        set<pair<int,int>> vis;\\n        int level=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(isWater[x][y]==1) \\n                {\\n                    q.push({x,y});\\n                    vis.insert({x,y});\\n                    ans[x][y]=0;\\n                }\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int r=q.front().first;\\n                int c=q.front().second;\\n                q.pop();\\n                for(int x=0; x<4; x++)\\n                {\\n                    int dr=r+directions[x].first, dc=c+directions[x].second;\\n                    if(dr>=0 && dr<rows && dc>=0 && dc<cols)\\n                    {\\n                        if(vis.find({dr,dc})==vis.end()) \\n                        {\\n                            ans[dr][dc]=level;\\n                            q.push({dr,dc});\\n                            vis.insert({dr,dc});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) \\n    {\\n        vector<pair<int,int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        int rows=isWater.size();\\n        int cols=isWater[0].size();\\n        vector<vector<int>> ans(rows, vector<int> (cols,0));\\n        queue<pair<int,int>> q;\\n        set<pair<int,int>> vis;\\n        int level=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(isWater[x][y]==1) \\n                {\\n                    q.push({x,y});\\n                    vis.insert({x,y});\\n                    ans[x][y]=0;\\n                }\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            level++;\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int r=q.front().first;\\n                int c=q.front().second;\\n                q.pop();\\n                for(int x=0; x<4; x++)\\n                {\\n                    int dr=r+directions[x].first, dc=c+directions[x].second;\\n                    if(dr>=0 && dr<rows && dc>=0 && dc<cols)\\n                    {\\n                        if(vis.find({dr,dc})==vis.end()) \\n                        {\\n                            ans[dr][dc]=level;\\n                            q.push({dr,dc});\\n                            vis.insert({dr,dc});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837503,
                "title": "bfs-solution-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n x m)\\n\\n- Space complexity:\\nO(n x m)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n            Queue<(int row, int col,  int[] prev)>  q = new Queue<(int, int, int[])>();\\n            //insert all the places with water\\n            bool[,] vs = new bool[isWater.Length, isWater[0].Length] ;\\n            for(int i = 0; i < isWater.Length; i++)\\n            {\\n                for(int j = 0;j < isWater[i].Length; j++)\\n                {\\n                    if(isWater[i][j] == 1)\\n                    {\\n                        q.Enqueue((i, j, new int[] {-1,-1}));\\n                    }\\n                }\\n            }\\n            while (q.Count > 0)\\n            {\\n                int r = q.Peek().row;\\n                int c = q.Peek().col;\\n                int prevR = q.Peek().prev[0];\\n                int prevC = q.Peek().prev[1];\\n                q.Dequeue();\\n                if (!vs[r, c])\\n                {\\n                    vs[r, c] = true;\\n                    if (isWater[r][c] == 1 && prevR == -1 && prevC == -1)\\n                    {\\n                        isWater[r][c] = 0;\\n                    }\\n                    else\\n                    {\\n                        isWater[r][c] = isWater[prevR][prevC] + 1;\\n                    }\\n                    if (r - 1 >= 0)\\n                    {\\n                        q.Enqueue((r - 1, c, new int[] {r,c}));\\n                    }\\n                    if (c - 1 >= 0)\\n                    {\\n                        q.Enqueue((r, c - 1, new int[] { r, c }));\\n                    }\\n                    if (r + 1 <= isWater.Length - 1)\\n                    {\\n                        q.Enqueue((r + 1, c, new int[] { r, c }));\\n                    }\\n                    if (c + 1 <= isWater[0].Length - 1)\\n                    {\\n                        q.Enqueue((r, c + 1, new int[] { r, c }));\\n                    }\\n                }\\n            }\\n            return isWater; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] HighestPeak(int[][] isWater) {\\n            Queue<(int row, int col,  int[] prev)>  q = new Queue<(int, int, int[])>();\\n            //insert all the places with water\\n            bool[,] vs = new bool[isWater.Length, isWater[0].Length] ;\\n            for(int i = 0; i < isWater.Length; i++)\\n            {\\n                for(int j = 0;j < isWater[i].Length; j++)\\n                {\\n                    if(isWater[i][j] == 1)\\n                    {\\n                        q.Enqueue((i, j, new int[] {-1,-1}));\\n                    }\\n                }\\n            }\\n            while (q.Count > 0)\\n            {\\n                int r = q.Peek().row;\\n                int c = q.Peek().col;\\n                int prevR = q.Peek().prev[0];\\n                int prevC = q.Peek().prev[1];\\n                q.Dequeue();\\n                if (!vs[r, c])\\n                {\\n                    vs[r, c] = true;\\n                    if (isWater[r][c] == 1 && prevR == -1 && prevC == -1)\\n                    {\\n                        isWater[r][c] = 0;\\n                    }\\n                    else\\n                    {\\n                        isWater[r][c] = isWater[prevR][prevC] + 1;\\n                    }\\n                    if (r - 1 >= 0)\\n                    {\\n                        q.Enqueue((r - 1, c, new int[] {r,c}));\\n                    }\\n                    if (c - 1 >= 0)\\n                    {\\n                        q.Enqueue((r, c - 1, new int[] { r, c }));\\n                    }\\n                    if (r + 1 <= isWater.Length - 1)\\n                    {\\n                        q.Enqueue((r + 1, c, new int[] { r, c }));\\n                    }\\n                    if (c + 1 <= isWater[0].Length - 1)\\n                    {\\n                        q.Enqueue((r, c + 1, new int[] { r, c }));\\n                    }\\n                }\\n            }\\n            return isWater; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836275,
                "title": "java-c-simple-bfs",
                "content": "\\n\\n# Complexity\\n- Time complexity:  $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        queue<pair<pair<int, int>, int>> q; // {{row, col}, level}\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));  // visited array of BFS\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 1)  // water cell \\n                {\\n                    q.push({{i, j}, 0});  // Initailly push all the water in the queue.\\n                    vis[i][j] = true; // marked as visited.\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        while(!q.empty())\\n        {\\n            int row = q.front().first.first;  // row\\n            int col = q.front().first.second; // col\\n            int level = q.front().second; // level\\n            q.pop();\\n            ans[row][col] = level;\\n            // Traverse all the neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m \\n                   && vis[nrow][ncol] == false && isWater[nrow][ncol] == 0) // check for validity of row and col\\n                {\\n                    q.push({{nrow, ncol}, level + 1});\\n                    vis[nrow][ncol] = true;  // Mark as visited           \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java Code\\n```\\nclass Tuple{\\n    int first;\\n    int second;\\n    int level;\\n    public Tuple(int first, int second, int level){\\n        this.first = first;\\n        this.second = second;\\n        this.level = level;\\n    }\\n}\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n        Queue<Tuple> q = new LinkedList<>(); // {{row, col}, level}\\n\\n        boolean[][] vis = new boolean[n][m];  // visited array of BFS\\n        int[][] ans = new int[n][m];\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 1)  // water cell \\n                {\\n                    q.offer(new Tuple(i, j, 0));  // Initailly push all the water in the queue.\\n                    vis[i][j] = true; // marked as visited.\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        while(!q.isEmpty())\\n        {\\n            int row = q.peek().first;  // row\\n            int col = q.peek().second; // col\\n            int level = q.peek().level; // level\\n            q.remove();\\n            ans[row][col] = level;\\n            // Traverse all the neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m \\n                   && vis[nrow][ncol] == false && isWater[nrow][ncol] == 0) // check for validity of row and col\\n                {\\n                    q.offer(new Tuple(nrow, ncol, level + 1));\\n                    vis[nrow][ncol] = true;  // Mark as visited           \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int n = isWater.size();\\n        int m = isWater[0].size();\\n        queue<pair<pair<int, int>, int>> q; // {{row, col}, level}\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));  // visited array of BFS\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 1)  // water cell \\n                {\\n                    q.push({{i, j}, 0});  // Initailly push all the water in the queue.\\n                    vis[i][j] = true; // marked as visited.\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        while(!q.empty())\\n        {\\n            int row = q.front().first.first;  // row\\n            int col = q.front().first.second; // col\\n            int level = q.front().second; // level\\n            q.pop();\\n            ans[row][col] = level;\\n            // Traverse all the neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m \\n                   && vis[nrow][ncol] == false && isWater[nrow][ncol] == 0) // check for validity of row and col\\n                {\\n                    q.push({{nrow, ncol}, level + 1});\\n                    vis[nrow][ncol] = true;  // Mark as visited           \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Tuple{\\n    int first;\\n    int second;\\n    int level;\\n    public Tuple(int first, int second, int level){\\n        this.first = first;\\n        this.second = second;\\n        this.level = level;\\n    }\\n}\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int n = isWater.length;\\n        int m = isWater[0].length;\\n        Queue<Tuple> q = new LinkedList<>(); // {{row, col}, level}\\n\\n        boolean[][] vis = new boolean[n][m];  // visited array of BFS\\n        int[][] ans = new int[n][m];\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(isWater[i][j] == 1)  // water cell \\n                {\\n                    q.offer(new Tuple(i, j, 0));  // Initailly push all the water in the queue.\\n                    vis[i][j] = true; // marked as visited.\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {-1, 0, +1, 0};\\n        int delcol[] = {0, +1, 0, -1};\\n\\n        while(!q.isEmpty())\\n        {\\n            int row = q.peek().first;  // row\\n            int col = q.peek().second; // col\\n            int level = q.peek().level; // level\\n            q.remove();\\n            ans[row][col] = level;\\n            // Traverse all the neighbours\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m \\n                   && vis[nrow][ncol] == false && isWater[nrow][ncol] == 0) // check for validity of row and col\\n                {\\n                    q.offer(new Tuple(nrow, ncol, level + 1));\\n                    vis[nrow][ncol] = true;  // Mark as visited           \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834433,
                "title": "python-super-easy-bfs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n\\n        dp = [[0 if isWater[i][j] else -1  for j in range(len(isWater[0]))] for i in range(len(isWater))]\\n        queue = []\\n        for i in range(len(isWater)):\\n            for j in range(len(isWater[0])):\\n                if dp[i][j] == 0:\\n                    queue.append((i, j))\\n\\n        while queue:\\n            i, j = queue.pop(0)\\n            for x in range(-1, 2):\\n                for y in range(-1, 2):\\n                    if abs(x+y) == 1 and i + y >= 0 and i + y < len(isWater) and j + x >= 0 and j + x < len(isWater[0]) and dp[i+y][j+x] == -1:\\n                        dp[i+y][j+x] = 1 + dp[i][j]\\n                        queue.append((i+y, j+x))\\n        return dp \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n\\n        dp = [[0 if isWater[i][j] else -1  for j in range(len(isWater[0]))] for i in range(len(isWater))]\\n        queue = []\\n        for i in range(len(isWater)):\\n            for j in range(len(isWater[0])):\\n                if dp[i][j] == 0:\\n                    queue.append((i, j))\\n\\n        while queue:\\n            i, j = queue.pop(0)\\n            for x in range(-1, 2):\\n                for y in range(-1, 2):\\n                    if abs(x+y) == 1 and i + y >= 0 and i + y < len(isWater) and j + x >= 0 and j + x < len(isWater[0]) and dp[i+y][j+x] == -1:\\n                        dp[i+y][j+x] = 1 + dp[i][j]\\n                        queue.append((i+y, j+x))\\n        return dp \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826612,
                "title": "easy-to-understand-bfs-solution-c-code",
                "content": "# Complexity\\n- Time complexity:\\n    O(n*n)\\n- Space complexity:\\n    O(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int row=isWater.size(), col=isWater[0].size();\\n        vector<vector<int>> vis(row,vector<int>(col,0)),ans(row,vector<int>(col,0));\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(isWater[i][j]){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        int arr[]={-1,0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first.first, y=q.front().first.second,val=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int tx=x+arr[i] , ty=y+arr[i+1];\\n                if(tx>=0 and tx<row and ty>=0 and ty<col and !vis[tx][ty]){\\n                    ans[tx][ty]=val+1;\\n                    vis[tx][ty]=1;\\n                    q.push({{tx,ty},val+1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        queue<pair<pair<int,int>,int>> q;\\n        int row=isWater.size(), col=isWater[0].size();\\n        vector<vector<int>> vis(row,vector<int>(col,0)),ans(row,vector<int>(col,0));\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(isWater[i][j]){\\n                    q.push({{i,j},0});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        int arr[]={-1,0,1,0,-1};\\n        while(!q.empty()){\\n            int x=q.front().first.first, y=q.front().first.second,val=q.front().second;\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int tx=x+arr[i] , ty=y+arr[i+1];\\n                if(tx>=0 and tx<row and ty>=0 and ty<col and !vis[tx][ty]){\\n                    ans[tx][ty]=val+1;\\n                    vis[tx][ty]=1;\\n                    q.push({{tx,ty},val+1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804992,
                "title": "java-very-simple-bfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int m = isWater.length;\\n        int n = isWater[0].length;\\n        int[] rDir = new int[]{-1, 0, 1, 0};\\n        int[] cDir = new int[]{0, 1, 0, -1};\\n        \\n        int[][] arr = new int[m][n];\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                arr[i][j] = -1;\\n                \\n                if(isWater[i][j] == 1) {\\n                    q.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int cnt = 0;\\n        while(!q.isEmpty()) {\\n            int len = q.size();\\n\\n            for(int i=0; i<len; i++) {\\n                int[] cur = q.poll();\\n                int r = cur[0];\\n                int c = cur[1];\\n                \\n                if(arr[r][c] >= 0) continue;\\n                arr[r][c] = cnt;\\n\\n                for(int k=0; k<4; k++) {\\n                    int nR = r + rDir[k];\\n                    int nC = c + cDir[k];\\n                    \\n                    if(nR < 0 || nC < 0 || nR >= m || nC >= n || arr[nR][nC] >= 0) continue;\\n                    q.add(new int[]{nR, nC});\\n                }\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] highestPeak(int[][] isWater) {\\n        int m = isWater.length;\\n        int n = isWater[0].length;\\n        int[] rDir = new int[]{-1, 0, 1, 0};\\n        int[] cDir = new int[]{0, 1, 0, -1};\\n        \\n        int[][] arr = new int[m][n];\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                arr[i][j] = -1;\\n                \\n                if(isWater[i][j] == 1) {\\n                    q.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        int cnt = 0;\\n        while(!q.isEmpty()) {\\n            int len = q.size();\\n\\n            for(int i=0; i<len; i++) {\\n                int[] cur = q.poll();\\n                int r = cur[0];\\n                int c = cur[1];\\n                \\n                if(arr[r][c] >= 0) continue;\\n                arr[r][c] = cnt;\\n\\n                for(int k=0; k<4; k++) {\\n                    int nR = r + rDir[k];\\n                    int nC = c + cDir[k];\\n                    \\n                    if(nR < 0 || nC < 0 || nR >= m || nC >= n || arr[nR][nC] >= 0) continue;\\n                    q.add(new int[]{nR, nC});\\n                }\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804958,
                "title": "simple-multi-source-bfs-from-water-bodies",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& a) {\\n\\t\\n        // using multi-source bfs , compute the minimum distance of every node from a water body\\n        int dr[4] = {1, -1, 0, 0}, dc[4] = {0, 0, 1, -1};\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX / 4));\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(a[i][j] == 1){\\n                    q.push({i, j});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n                                 \\n        auto inside = [&](int i, int j){\\n            return i >= 0 and i < n and j >= 0 and j < m;\\n        };\\n                                 \\n                                 \\n        while(q.size()){\\n            auto top = q.front(); q.pop();\\n            int i = top.first, j = top.second;\\n            // cout << i << \" \" << j << \" -> \";\\n            for(int k = 0; k < 4; ++k){\\n                int ni = i + dr[k], nj = j + dc[k];\\n                // cout << ni << \"--\" << nj << \" \";\\n                if(inside(ni, nj) and dist[ni][nj] == INT_MAX / 4){\\n                    q.push({ni, nj});\\n                    dist[ni][nj] = dist[i][j] + 1;\\n                }\\n            }\\n            // cout << \"\\\\n\";\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& a) {\\n\\t\\n        // using multi-source bfs , compute the minimum distance of every node from a water body\\n        int dr[4] = {1, -1, 0, 0}, dc[4] = {0, 0, 1, -1};\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX / 4));\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(a[i][j] == 1){\\n                    q.push({i, j});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n                                 \\n        auto inside = [&](int i, int j){\\n            return i >= 0 and i < n and j >= 0 and j < m;\\n        };\\n                                 \\n                                 \\n        while(q.size()){\\n            auto top = q.front(); q.pop();\\n            int i = top.first, j = top.second;\\n            // cout << i << \" \" << j << \" -> \";\\n            for(int k = 0; k < 4; ++k){\\n                int ni = i + dr[k], nj = j + dc[k];\\n                // cout << ni << \"--\" << nj << \" \";\\n                if(inside(ni, nj) and dist[ni][nj] == INT_MAX / 4){\\n                    q.push({ni, nj});\\n                    dist[ni][nj] = dist[i][j] + 1;\\n                }\\n            }\\n            // cout << \"\\\\n\";\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2771847,
                "title": "tle",
                "content": "I have TLE with this test case with BFS\\nhttps://leetcode.com/submissions/detail/835660425/testcase/\\n \\n Anyone managed to have their solution passed recently?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2766793,
                "title": "c-easy-to-understand-bfs-solution",
                "content": "```\\nint arr[5] = {0, -1, 0, 1, 0};\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size();\\n        queue<pair<int, int>> q;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    q.push({i, j});\\n                    isWater[i][j] = 0;\\n                }\\n                else {\\n                    isWater[i][j] = -1;\\n                }\\n            }\\n        }\\n        \\n        int currH = 1;\\n        while (!q.empty()) {\\n            int z = q.size();\\n            for (int i=0; i<z; i++) {\\n                auto temp = q.front();\\n                q.pop();\\n                for (int j=0; j<4; j++) {\\n                    int x = temp.first+arr[j], y = temp.second+arr[j+1];\\n                    if (x>=m || y>=n || x<0 || y<0)\\n                        continue;\\n                    if (isWater[x][y] == -1) {\\n                        isWater[x][y] = currH;\\n                        q.push({x, y});\\n                    }\\n                }\\n            }\\n            currH++;\\n        }\\n        return isWater;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint arr[5] = {0, -1, 0, 1, 0};\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        int m = isWater.size(), n = isWater[0].size();\\n        queue<pair<int, int>> q;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (isWater[i][j] == 1) {\\n                    q.push({i, j});\\n                    isWater[i][j] = 0;\\n                }\\n                else {\\n                    isWater[i][j] = -1;\\n                }\\n            }\\n        }\\n        \\n        int currH = 1;\\n        while (!q.empty()) {\\n            int z = q.size();\\n            for (int i=0; i<z; i++) {\\n                auto temp = q.front();\\n                q.pop();\\n                for (int j=0; j<4; j++) {\\n                    int x = temp.first+arr[j], y = temp.second+arr[j+1];\\n                    if (x>=m || y>=n || x<0 || y<0)\\n                        continue;\\n                    if (isWater[x][y] == -1) {\\n                        isWater[x][y] = currH;\\n                        q.push({x, y});\\n                    }\\n                }\\n            }\\n            currH++;\\n        }\\n        return isWater;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763393,
                "title": "clean-bfs-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<vector<int>> dist(isWater.size(), vector<int>(isWater[0].size(),INT_MAX));\\n        queue<pair<int,int>> q;\\n        for(int i = 0 ; i < isWater.size() ; i++){\\n            for(int j = 0 ; j< isWater[0].size() ; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push(pair<int,int>(i,j));\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n        vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while(q.size()){\\n            pair<int,int> p;\\n            p=q.front();\\n            q.pop();\\n            for(int i = 0 ; i < 4 ; i++){\\n                int x = p.first + dir[i][0];\\n                int y = p.second + dir[i][1];\\n                if(x>=0 && x<isWater.size() && y>=0 && y<isWater[0].size()){\\n                    if(dist[x][y] > dist[p.first][p.second] + 1){\\n                        dist[x][y] = dist[p.first][p.second] + 1;\\n                        q.push(pair<int,int>(x,y));\\n                    }\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {\\n        vector<vector<int>> dist(isWater.size(), vector<int>(isWater[0].size(),INT_MAX));\\n        queue<pair<int,int>> q;\\n        for(int i = 0 ; i < isWater.size() ; i++){\\n            for(int j = 0 ; j< isWater[0].size() ; j++){\\n                if(isWater[i][j] == 1){\\n                    q.push(pair<int,int>(i,j));\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n        vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while(q.size()){\\n            pair<int,int> p;\\n            p=q.front();\\n            q.pop();\\n            for(int i = 0 ; i < 4 ; i++){\\n                int x = p.first + dir[i][0];\\n                int y = p.second + dir[i][1];\\n                if(x>=0 && x<isWater.size() && y>=0 && y<isWater[0].size()){\\n                    if(dist[x][y] > dist[p.first][p.second] + 1){\\n                        dist[x][y] = dist[p.first][p.second] + 1;\\n                        q.push(pair<int,int>(x,y));\\n                    }\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749022,
                "title": "c-bfs-queue-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& a) {\\n        int i, j, n=a.size(), m=a[0].size(), dist=0, x, y;\\n        vector<vector<int>> ans(n, vector<int> (m)), vis(n, vector<int> (m, 0));\\n        int dr[]={-1, 0, 1, 0};\\n        int dc[]={0, 1, 0, -1};\\n        queue<vector<int>> q;\\n        for(i=0;i<n;i++) {\\n            for(j=0;j<m;j++) {\\n                if(a[i][j]==1) {\\n                    ans[i][j]=0;\\n                    q.push({i, j, dist});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        while(q.size()) {\\n            auto it=q.front(); q.pop();\\n            x=it[0], y=it[1], dist=it[2];\\n            for(i=0;i<4;i++) {\\n                int newRow=x+dr[i];\\n                int newCol=y+dc[i];\\n                if(newRow>=0 &&newRow<n && newCol>=0 && newCol<m && vis[newRow][newCol]==0 && a[newRow][newCol]==0) {\\n                    vis[newRow][newCol]=1;\\n                    ans[newRow][newCol]=dist+1;\\n                    q.push({newRow, newCol, dist+1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& a) {\\n        int i, j, n=a.size(), m=a[0].size(), dist=0, x, y;\\n        vector<vector<int>> ans(n, vector<int> (m)), vis(n, vector<int> (m, 0));\\n        int dr[]={-1, 0, 1, 0};\\n        int dc[]={0, 1, 0, -1};\\n        queue<vector<int>> q;\\n        for(i=0;i<n;i++) {\\n            for(j=0;j<m;j++) {\\n                if(a[i][j]==1) {\\n                    ans[i][j]=0;\\n                    q.push({i, j, dist});\\n                    vis[i][j]=1;\\n                }\\n            }\\n        }\\n        while(q.size()) {\\n            auto it=q.front(); q.pop();\\n            x=it[0], y=it[1], dist=it[2];\\n            for(i=0;i<4;i++) {\\n                int newRow=x+dr[i];\\n                int newCol=y+dc[i];\\n                if(newRow>=0 &&newRow<n && newCol>=0 && newCol<m && vis[newRow][newCol]==0 && a[newRow][newCol]==0) {\\n                    vis[newRow][newCol]=1;\\n                    ans[newRow][newCol]=dist+1;\\n                    q.push({newRow, newCol, dist+1});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735788,
                "title": "bfs",
                "content": "```\\nvector<vector<int>> highestPeak(vector<vector<int>>& g)\\n{\\n\\tvector out(size(g), vector(size(g[0]), -1));\\n\\tqueue<pair<int,int>>q;\\n\\tfor(int i{}; i<size(g); ++i)\\n\\t\\tfor(int j{}; j<size(g[0]); ++j)\\n\\t\\t\\tif(g[i][j]) q.push({i,j}), g[i][j]=-1, out[i][j]=0;\\n\\n\\tfor( ; !empty(q); )\\n\\t{\\n\\t\\tconst auto [x, y] = q.front(); q.pop();    \\n\\t\\tfor(pair<int,int> pp[]{{-1,0}, {1,0}, {0,-1}, {0,1}}; const auto & [i, j]: pp)\\n\\t\\t\\tif(int xx{i+x}, yy{j+y}; xx>=0 and xx<size(g) and yy>=0 and yy<size(g[0]) and out[xx][yy]==-1) \\n\\t\\t\\t\\tout[xx][yy]=1+out[x][y], q.push({xx, yy}); \\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> highestPeak(vector<vector<int>>& g)\\n{\\n\\tvector out(size(g), vector(size(g[0]), -1));\\n\\tqueue<pair<int,int>>q;\\n\\tfor(int i{}; i<size(g); ++i)\\n\\t\\tfor(int j{}; j<size(g[0]); ++j)\\n\\t\\t\\tif(g[i][j]) q.push({i,j}), g[i][j]=-1, out[i][j]=0;\\n\\n\\tfor( ; !empty(q); )\\n\\t{\\n\\t\\tconst auto [x, y] = q.front(); q.pop();    \\n\\t\\tfor(pair<int,int> pp[]{{-1,0}, {1,0}, {0,-1}, {0,1}}; const auto & [i, j]: pp)\\n\\t\\t\\tif(int xx{i+x}, yy{j+y}; xx>=0 and xx<size(g) and yy>=0 and yy<size(g[0]) and out[xx][yy]==-1) \\n\\t\\t\\t\\tout[xx][yy]=1+out[x][y], q.push({xx, yy}); \\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733822,
                "title": "rust-solution-using-bfs",
                "content": "```\\nimpl Solution {\\n    pub fn highest_peak(is_water: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let n = is_water.len();\\n        let m = is_water[0].len();\\n\\n        let mut result = vec![vec![1_000_000_000;m];n];\\n        let mut stack = vec![];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if is_water[i][j] == 1 {\\n                    stack.push((i,j,0));\\n                    result[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while !stack.is_empty() {\\n            let mut new_stack = vec![];\\n            while let Some((i,j,cv)) = stack.pop() {\\n                let nv = cv + 1;\\n                if 0 < i && result[i-1][j] > nv {\\n                    result[i-1][j] = nv;\\n                    new_stack.push((i-1,j,nv));\\n                }\\n\\n                if i < n-1 && result[i+1][j] > nv {\\n                    result[i+1][j] = nv;\\n                    new_stack.push((i+1,j,nv));\\n                }\\n\\n                if 0 < j && result[i][j-1] > nv {\\n                    result[i][j-1] = nv;\\n                    new_stack.push((i,j-1,nv));\\n                }\\n\\n                if j < m-1 && result[i][j+1] > nv {\\n                    result[i][j+1] = nv;\\n                    new_stack.push((i,j+1,nv));\\n                }\\n            }\\n            stack = new_stack;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn highest_peak(is_water: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let n = is_water.len();\\n        let m = is_water[0].len();\\n\\n        let mut result = vec![vec![1_000_000_000;m];n];\\n        let mut stack = vec![];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if is_water[i][j] == 1 {\\n                    stack.push((i,j,0));\\n                    result[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while !stack.is_empty() {\\n            let mut new_stack = vec![];\\n            while let Some((i,j,cv)) = stack.pop() {\\n                let nv = cv + 1;\\n                if 0 < i && result[i-1][j] > nv {\\n                    result[i-1][j] = nv;\\n                    new_stack.push((i-1,j,nv));\\n                }\\n\\n                if i < n-1 && result[i+1][j] > nv {\\n                    result[i+1][j] = nv;\\n                    new_stack.push((i+1,j,nv));\\n                }\\n\\n                if 0 < j && result[i][j-1] > nv {\\n                    result[i][j-1] = nv;\\n                    new_stack.push((i,j-1,nv));\\n                }\\n\\n                if j < m-1 && result[i][j+1] > nv {\\n                    result[i][j+1] = nv;\\n                    new_stack.push((i,j+1,nv));\\n                }\\n            }\\n            stack = new_stack;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724856,
                "title": "python-bfs-solution-faster-than-96",
                "content": "```\\nclass Solution:\\n    def highestPeak(self, grid: List[List[int]]) -> List[List[int]]:\\n        queue, numRows, numCols = deque(), len(grid), len(grid[0])\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    grid[row][col] = 0\\n                    queue.append((row, col))\\n                else:\\n                    grid[row][col] = -1\\n        while queue:\\n            row, col = queue.popleft()\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if numRows > newRow >= 0 <= newCol < numCols and grid[newRow][newCol] < 0:\\n                    grid[newRow][newCol] = grid[row][col] + 1\\n                    queue.append((newRow, newCol))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, grid: List[List[int]]) -> List[List[int]]:\\n        queue, numRows, numCols = deque(), len(grid), len(grid[0])\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    grid[row][col] = 0\\n                    queue.append((row, col))\\n                else:\\n                    grid[row][col] = -1\\n        while queue:\\n            row, col = queue.popleft()\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if numRows > newRow >= 0 <= newCol < numCols and grid[newRow][newCol] < 0:\\n                    grid[newRow][newCol] = grid[row][col] + 1\\n                    queue.append((newRow, newCol))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677727,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n    \\n         vector<vector<int>> a( n , vector<int> (m, -1)); \\n    \\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    a[i][j]=0;\\n                   \\n                }\\n\\n            }\\n        } \\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            if(x-1>=0&&x-1<n&&a[p.first-1][p.second]==-1)\\n            {\\n                a[p.first-1][p.second]=1+a[p.first][p.second];\\n                q.push({p.first-1,p.second});\\n            }\\n             if(x+1<n&&x+1>=0&&a[p.first+1][p.second]==-1)\\n            {\\n                a[p.first+1][p.second]=1+a[p.first][p.second];\\n                q.push({p.first+1,p.second});\\n            }\\n             if(y-1>=0&&y-1<m&&a[p.first][p.second-1]==-1)\\n            {\\n                a[p.first][p.second-1]=1+a[p.first][p.second];\\n                q.push({p.first,p.second-1});\\n            }\\n             if(y+1<m&&y+1>=0&&a[p.first][p.second+1]==-1)\\n            {\\n                a[p.first][p.second+1]=1+a[p.first][p.second];\\n                q.push({p.first,p.second+1});\\n            }\\n        }\\n  \\n    return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> highestPeak(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n    \\n         vector<vector<int>> a( n , vector<int> (m, -1)); \\n    \\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(v[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    a[i][j]=0;\\n                   \\n                }\\n\\n            }\\n        } \\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            if(x-1>=0&&x-1<n&&a[p.first-1][p.second]==-1)\\n            {\\n                a[p.first-1][p.second]=1+a[p.first][p.second];\\n                q.push({p.first-1,p.second});\\n            }\\n             if(x+1<n&&x+1>=0&&a[p.first+1][p.second]==-1)\\n            {\\n                a[p.first+1][p.second]=1+a[p.first][p.second];\\n                q.push({p.first+1,p.second});\\n            }\\n             if(y-1>=0&&y-1<m&&a[p.first][p.second-1]==-1)\\n            {\\n                a[p.first][p.second-1]=1+a[p.first][p.second];\\n                q.push({p.first,p.second-1});\\n            }\\n             if(y+1<m&&y+1>=0&&a[p.first][p.second+1]==-1)\\n            {\\n                a[p.first][p.second+1]=1+a[p.first][p.second];\\n                q.push({p.first,p.second+1});\\n            }\\n        }\\n  \\n    return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636213,
                "title": "javascript-bfs-easy-understand",
                "content": "```\\nvar highestPeak = function(isWater) {\\n    \\n  let stack = [];\\n  \\n  const visited = new Set();\\n  \\n  for(let i=0; i<isWater.length; i++) {\\n    for(let j=0; j<isWater[i].length; j++) {\\n      if(isWater[i][j]===1) {\\n        isWater[i][j]=0\\n        stack.push([i, j, 0]); \\n        visited.add([i, j].toString());\\n      } else {\\n        isWater[i][j]=1;\\n      }\\n    }\\n  }\\n  \\n  const getAdjacents = function(i, j) {\\n    let arr = [];\\n    if(i>0) arr.push([i-1, j]);\\n    if(j>0) arr.push([i, j-1]);\\n    if(i<isWater.length-1) arr.push([i+1, j]);\\n    if(j<isWater[i].length-1) arr.push([i, j+1]);\\n    return arr;\\n  }\\n  \\n  while(stack.length) {\\n    let newStack = [];\\n    while(stack.length) {\\n      let [i, j, val] = stack.pop();\\n      let arr = getAdjacents(i, j);\\n      for(let index=0; index<arr.length; index++) {\\n        let [newI, newJ] = arr[index];\\n        //console.log(visited)\\n        if(visited.has([newI, newJ].toString())) continue;\\n        visited.add([newI, newJ].toString());\\n        isWater[newI][newJ] = val+1; \\n        newStack.push([newI, newJ, val+1]);\\n      }\\n    }\\n    stack = newStack;\\n  }\\n  \\n  return isWater;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar highestPeak = function(isWater) {\\n    \\n  let stack = [];\\n  \\n  const visited = new Set();\\n  \\n  for(let i=0; i<isWater.length; i++) {\\n    for(let j=0; j<isWater[i].length; j++) {\\n      if(isWater[i][j]===1) {\\n        isWater[i][j]=0\\n        stack.push([i, j, 0]); \\n        visited.add([i, j].toString());\\n      } else {\\n        isWater[i][j]=1;\\n      }\\n    }\\n  }\\n  \\n  const getAdjacents = function(i, j) {\\n    let arr = [];\\n    if(i>0) arr.push([i-1, j]);\\n    if(j>0) arr.push([i, j-1]);\\n    if(i<isWater.length-1) arr.push([i+1, j]);\\n    if(j<isWater[i].length-1) arr.push([i, j+1]);\\n    return arr;\\n  }\\n  \\n  while(stack.length) {\\n    let newStack = [];\\n    while(stack.length) {\\n      let [i, j, val] = stack.pop();\\n      let arr = getAdjacents(i, j);\\n      for(let index=0; index<arr.length; index++) {\\n        let [newI, newJ] = arr[index];\\n        //console.log(visited)\\n        if(visited.has([newI, newJ].toString())) continue;\\n        visited.add([newI, newJ].toString());\\n        isWater[newI][newJ] = val+1; \\n        newStack.push([newI, newJ, val+1]);\\n      }\\n    }\\n    stack = newStack;\\n  }\\n  \\n  return isWater;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2619873,
                "title": "c-bfs-levels",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> highestPeak(vector<vector<int>>& a) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint m=a[0].size();\\n\\t\\t\\tvector<vector<int>> d={{1,0},{-1,0},{0,1},{0,-1}};\\n\\t\\t\\tqueue<vector<int>> q;\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)  {\\n\\t\\t\\t\\t\\tif(a[i][j]) {\\n\\t\\t\\t\\t\\t\\tq.push({i,j});\\n\\t\\t\\t\\t\\t\\ta[i][j]=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse a[i][j]=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint h=1;\\n\\t\\t\\twhile(q.size())  {\\n\\t\\t\\t\\tint sz=q.size();\\n\\t\\t\\t\\twhile(sz--) {\\n\\t\\t\\t\\t\\tint x=q.front()[0];\\n\\t\\t\\t\\t\\tint y=q.front()[1];\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\t\\t\\tint x1=x+d[i][0];\\n\\t\\t\\t\\t\\t\\tint y1=y+d[i][1];\\n\\t\\t\\t\\t\\t\\tif(x1>=0&&y1>=0&&x1<n&&y1<m&&a[x1][y1]==-1)  {\\n\\t\\t\\t\\t\\t\\t\\ta[x1][y1]=h;\\n\\t\\t\\t\\t\\t\\t\\tq.push({x1,y1});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th++;\\n\\t\\t\\t}\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> highestPeak(vector<vector<int>>& a) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint m=a[0].size();\\n\\t\\t\\tvector<vector<int>> d={{1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2569764,
                "title": "python-bfs-solution",
                "content": "```\\ndef highestPeak(self, grid: List[List[int]]) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tres = [[-1]*n for _ in range(m)]\\n\\tq = deque()\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif grid[i][j]:\\n\\t\\t\\t\\tq.append((i,j))\\n\\t\\t\\t\\tres[i][j] = 0\\n\\twhile(q):\\n\\t\\ti, j = q.popleft()\\n\\t\\tfor x, y in ((i-1, j),(i+1, j),(i, j-1),(i, j+1)):\\n\\t\\t\\tif 0<=x<m and 0<=y<n and res[x][y]==-1:\\n\\t\\t\\t\\tq.append((x, y))\\n\\t\\t\\t\\tres[x][y]=res[i][j]+1\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndef highestPeak(self, grid: List[List[int]]) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tres = [[-1]*n for _ in range(m)]\\n\\tq = deque()\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif grid[i][j]:\\n\\t\\t\\t\\tq.append((i,j))\\n\\t\\t\\t\\tres[i][j] = 0\\n\\twhile(q):\\n\\t\\ti, j = q.popleft()\\n\\t\\tfor x, y in ((i-1, j),(i+1, j),(i, j-1),(i, j+1)):\\n\\t\\t\\tif 0<=x<m and 0<=y<n and res[x][y]==-1:\\n\\t\\t\\t\\tq.append((x, y))\\n\\t\\t\\t\\tres[x][y]=res[i][j]+1\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2568705,
                "title": "python-multi-source-bfs-implementation",
                "content": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m,n,q = len(isWater), len(isWater[0]), deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1: \\n                    isWater[i][j] = 0\\n                    q.append((i,j))\\n                else:\\n                    isWater[i][j] = -1\\n\\n        level = 0\\n        while q:\\n            level += 1\\n            for _ in range(len(q)):\\n                i,j = q.popleft()\\n                for dx,dy in [[0,1],[1,0],[0,-1],[-1,0]]:\\n                    x, y = i + dx, j + dy\\n                    if 0 <= x < m and 0 <= y < n and isWater[x][y] == -1:\\n                        isWater[x][y] = level\\n                        q.append((x,y))\\n        \\n        return isWater\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\\n        m,n,q = len(isWater), len(isWater[0]), deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if isWater[i][j] == 1: \\n                    isWater[i][j] = 0\\n                    q.append((i,j))\\n                else:\\n                    isWater[i][j] = -1\\n\\n        level = 0\\n        while q:\\n            level += 1\\n            for _ in range(len(q)):\\n                i,j = q.popleft()\\n                for dx,dy in [[0,1],[1,0],[0,-1],[-1,0]]:\\n                    x, y = i + dx, j + dy\\n                    if 0 <= x < m and 0 <= y < n and isWater[x][y] == -1:\\n                        isWater[x][y] = level\\n                        q.append((x,y))\\n        \\n        return isWater\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565659,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int offset[5] = {0,1,0,-1,0};\\n    vector<vector<int>> highestPeak(vector<vector<int>>& w) {\\n        int m = w.size(), n = w[0].size(), h = 1;\\n        vector<pair<int,int>> q;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                w[i][j] = w[i][j] == 1 ? 0 : -1;\\n                if(w[i][j] == 0) q.push_back({i,j});\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            vector<pair<int,int>> q1;\\n            for(auto [i,j] : q){\\n                for(int d = 0; d<4; d++){\\n                    int x = i+offset[d], y = j+offset[d+1];\\n                    if(x>=0 && y>=0 && x<m && y<n && w[x][y] == -1){\\n                        q1.push_back({x,y});\\n                        w[x][y] = h;\\n                    }\\n                }\\n            }\\n            swap(q,q1);\\n            h++;\\n        }\\n        \\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int offset[5] = {0,1,0,-1,0};\\n    vector<vector<int>> highestPeak(vector<vector<int>>& w) {\\n        int m = w.size(), n = w[0].size(), h = 1;\\n        vector<pair<int,int>> q;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                w[i][j] = w[i][j] == 1 ? 0 : -1;\\n                if(w[i][j] == 0) q.push_back({i,j});\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            vector<pair<int,int>> q1;\\n            for(auto [i,j] : q){\\n                for(int d = 0; d<4; d++){\\n                    int x = i+offset[d], y = j+offset[d+1];\\n                    if(x>=0 && y>=0 && x<m && y<n && w[x][y] == -1){\\n                        q1.push_back({x,y});\\n                        w[x][y] = h;\\n                    }\\n                }\\n            }\\n            swap(q,q1);\\n            h++;\\n        }\\n        \\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575553,
                "content": [
                    {
                        "username": "unzledick",
                        "content": "When using C in test case 58,\\ninput array size is 999x1000 (input argument isWaterSize is 999)\\nBut the array in expected result is a 1000x1000 size array.\\n(I returned a 1000x1000 size array and pass the test case.)"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Simple BFS. This problem is same as LeetCode 542 ( 01 Matrix )."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I don\\'t understand why all adjacent land cells cannot be just \"1\". That would mean their differences is zero, which is less than the 1 max requirement. Where in the problem does it say the adjacent land cells sometimes have to be 2 ?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The problem asks us to find a matrix such that maximum height of land cells is maximized. Maintaining all land cells with just height \\'1\\' won\\'t give us the correct answer"
                    }
                ]
            },
            {
                "id": 2035509,
                "content": [
                    {
                        "username": "unzledick",
                        "content": "When using C in test case 58,\\ninput array size is 999x1000 (input argument isWaterSize is 999)\\nBut the array in expected result is a 1000x1000 size array.\\n(I returned a 1000x1000 size array and pass the test case.)"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Simple BFS. This problem is same as LeetCode 542 ( 01 Matrix )."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I don\\'t understand why all adjacent land cells cannot be just \"1\". That would mean their differences is zero, which is less than the 1 max requirement. Where in the problem does it say the adjacent land cells sometimes have to be 2 ?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The problem asks us to find a matrix such that maximum height of land cells is maximized. Maintaining all land cells with just height \\'1\\' won\\'t give us the correct answer"
                    }
                ]
            },
            {
                "id": 1943566,
                "content": [
                    {
                        "username": "unzledick",
                        "content": "When using C in test case 58,\\ninput array size is 999x1000 (input argument isWaterSize is 999)\\nBut the array in expected result is a 1000x1000 size array.\\n(I returned a 1000x1000 size array and pass the test case.)"
                    },
                    {
                        "username": "aftab0711",
                        "content": "Simple BFS. This problem is same as LeetCode 542 ( 01 Matrix )."
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I don\\'t understand why all adjacent land cells cannot be just \"1\". That would mean their differences is zero, which is less than the 1 max requirement. Where in the problem does it say the adjacent land cells sometimes have to be 2 ?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The problem asks us to find a matrix such that maximum height of land cells is maximized. Maintaining all land cells with just height \\'1\\' won\\'t give us the correct answer"
                    }
                ]
            }
        ]
    }
]