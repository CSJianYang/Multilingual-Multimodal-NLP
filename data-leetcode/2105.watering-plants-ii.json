[
    {
        "title": "Watering Plants II",
        "question_content": "Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n\n\tAlice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\n\tIt takes the same amount of time to water each plant regardless of how much water it needs.\n\tAlice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\n\tIn case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.\n&nbsp;\nExample 1:\n\nInput: plants = [2,2,3,3], capacityA = 5, capacityB = 5\nOutput: 1\nExplanation:\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n\nExample 2:\n\nInput: plants = [2,2,3,3], capacityA = 3, capacityB = 4\nOutput: 2\nExplanation:\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n\nExample 3:\n\nInput: plants = [5], capacityA = 10, capacityB = 8\nOutput: 0\nExplanation:\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0.\n\n&nbsp;\nConstraints:\n\n\tn == plants.length\n\t1 <= n <= 105\n\t1 <= plants[i] <= 106\n\tmax(plants[i]) <= capacityA, capacityB <= 109",
        "solutions": [
            {
                "id": 1624249,
                "title": "straightforward",
                "content": "I am scared of Alice and Bob problems. But this one, luckily, is benign (except for a lengthy description).\\n\\nThe one thing to realize is that, if the array size is odd, Alice or Bob can water it if they have water, or one of them needs to refill otherwise.\\n\\n**C++**\\n```cpp\\nint minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n    int i = 0, j = plants.size() - 1, canA = capacityA, canB = capacityB, res = 0;\\n    while (i < j) {\\n        res += (canA < plants[i]) + (canB < plants[j]);\\n        canA = canA < plants[i] ? capacityA : canA;\\n        canB = canB < plants[j] ? capacityB : canB;\\n        canA -= plants[i++];\\n        canB -= plants[j--];\\n    }\\n    return res + (i == j && max(canA, canB) < plants[i]);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n    int i = 0, j = plants.size() - 1, canA = capacityA, canB = capacityB, res = 0;\\n    while (i < j) {\\n        res += (canA < plants[i]) + (canB < plants[j]);\\n        canA = canA < plants[i] ? capacityA : canA;\\n        canB = canB < plants[j] ? capacityB : canB;\\n        canA -= plants[i++];\\n        canB -= plants[j--];\\n    }\\n    return res + (i == j && max(canA, canB) < plants[i]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624279,
                "title": "c-java-python-o-n-easy-intuition-image-explanation",
                "content": "As it\\'s given in problem statement\\n> Alice waters the plants in order from **left to right**, starting from the `0th` plant. Bob waters the plants in order from **right to left**, starting from the `(n - 1)th` plant. They begin watering the plants **simultaneously**.\\n\\n\\n# Intuition:\\n\\nWe need to keep two pointer in left and right to start watering from both sides simultaneously.            \\nKeep on counting fills for both of them.           \\nAnd when they meet in middle find the one with more water.           \\n\\n# Example:\\n\\nplants = [2, 1, 1, 1]\\naliceCapacity = 2,  bobCapacity = 4\\naliceCan = 2,  bobCan = 4\\n\\nNow currently Alice will water 0th plant and Bob waters 3rd plant.\\nThere was no refill.\\naliceCan = 0,  bobCan = 3\\nrefills = 0\\n\\nThen Alice will not be able to water 1st plant, so she needs to refill\\nbut Bob waters 2rd plant.\\naliceCan = 1,  bobCan = 3\\nrefills = 1\\n\\nHence total refills were 1.\\n\\nBut consider we had one more plant in middle.\\n[2, 1, 2, 1, 1]\\nBoth will reach at 2nd plant at same time\\nBob had 2 in it\\'s can but Alice had 0\\nHence bob would have watered it without refill.\\n\\n![image](https://assets.leetcode.com/users/images/fd2d22e4-ea3a-4a8b-8a23-2af5eb8e7f2f_1639283879.4184136.bmp)\\n\\n\\n# Code:\\n\\n## C++:\\n```c++\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int N = plants.size(), i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        // Iterate over all plants left and right one similutaneously.\\n        while (i <= j) {\\n            \\n            // We have reached middle plant.\\n            if (i == j) { \\n                // The one with more water in can will water the plant.\\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        // Alice need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        // Bob need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                // If Alice doesn\\'t have sufficient water, she refills.\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                \\n                // Alice waters.\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                // If Bob doesn\\'t have sufficient water, he refills.\\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                \\n                // Bob waters.\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        return totalFills;\\n    }\\n};\\n```\\n\\n## Java:\\n```java\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int N = plants.length, i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        while (i <= j) {\\n            if (i == j) { \\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        \\n        return totalFills;\\n    }\\n}\\n```\\n\\n## Python:\\n```python\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        N = len(plants)\\n        i, j = 0, N -1\\n        \\n        if N == 1: \\n            return 0\\n        \\n        totalFills = 0\\n        aliceCan, bobCan = capacityA, capacityB\\n        \\n        while i <= j:\\n            \\n            if i == j:\\n                if aliceCan >= bobCan:\\n                    if aliceCan < plants[i]:\\n                        totalFills += 1\\n                    i += 1\\n    \\n                else:\\n                    if bobCan < plants[j]:\\n                        totalFills += 1\\n                    j -= 1 \\n            \\n            else:\\n                if aliceCan < plants[i]:\\n                    aliceCan = capacityA\\n                    totalFills += 1\\n                \\n                aliceCan -= plants[i]\\n                i += 1\\n                \\n                if bobCan < plants[j]:\\n                    bobCan = capacityB;\\n                    totalFills += 1\\n                \\n                bobCan -= plants[j]\\n                j -= 1\\n            \\n        return totalFills\\n        \\n```\\n\\n# Complexity Analysis:\\n**Time Complexity: O(N) -** We traverse each plant in the array only once.\\n**Space Complexity: O(1) -** We only use constant variables.\\n\\n\\nUpvote if you like. Comment for suggestions. \\uD83D\\uDE05",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int N = plants.size(), i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        // Iterate over all plants left and right one similutaneously.\\n        while (i <= j) {\\n            \\n            // We have reached middle plant.\\n            if (i == j) { \\n                // The one with more water in can will water the plant.\\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        // Alice need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        // Bob need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                // If Alice doesn\\'t have sufficient water, she refills.\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                \\n                // Alice waters.\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                // If Bob doesn\\'t have sufficient water, he refills.\\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                \\n                // Bob waters.\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        return totalFills;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int N = plants.length, i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        while (i <= j) {\\n            if (i == j) { \\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        \\n        return totalFills;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        N = len(plants)\\n        i, j = 0, N -1\\n        \\n        if N == 1: \\n            return 0\\n        \\n        totalFills = 0\\n        aliceCan, bobCan = capacityA, capacityB\\n        \\n        while i <= j:\\n            \\n            if i == j:\\n                if aliceCan >= bobCan:\\n                    if aliceCan < plants[i]:\\n                        totalFills += 1\\n                    i += 1\\n    \\n                else:\\n                    if bobCan < plants[j]:\\n                        totalFills += 1\\n                    j -= 1 \\n            \\n            else:\\n                if aliceCan < plants[i]:\\n                    aliceCan = capacityA\\n                    totalFills += 1\\n                \\n                aliceCan -= plants[i]\\n                i += 1\\n                \\n                if bobCan < plants[j]:\\n                    bobCan = capacityB;\\n                    totalFills += 1\\n                \\n                bobCan -= plants[j]\\n                j -= 1\\n            \\n        return totalFills\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625468,
                "title": "java-simple-detailed-explanation-3ms100-faster-2-pointer",
                "content": "###  \\u2714 ***Solution: 2 Pointer*** | Beats 100 %, 3ms \\u23F2\\n-----\\n* Alice start from i=0\\n* Bob start from j=n-1 index , n size of array\\n* Both Alice and bob move one step , Now  all cases possible in their movement\\n\\t* **Case 1 :** Alice and Bob both have sufficient water , they will water plant \\n\\t* **Case 2 :** Either Alice or Bob water finished , then refill water can of their and `increase refill count`\\n\\t* **Case 3**: If Alice and bob reach a plant at same time , then Check which one have more water , that will watering plant , if both with equal water then Alice water \\n\\t* Lets Make all these If-else conditions \\n\\n### Lets Code  \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\\uD83D\\uDCBB\\n---\\nDo read comment for more better understanding \\n```\\nclass Solution {\\n    public int minimumRefill(int[] p, int ca, int cb) {                \\n\\t\\n        int refill= 0,oca =  ca, ocb =  cb;// let save our  orginal capacity    , needed to refill can again\\n        int i=0, j = p.length-1; // starting both end \\n        \\n        while(i<=j){\\n\\t\\t\\n             if(i==j){// mean both at same position\\n                if(ca>=cb){\\n                   if(p[i]>ca){\\n                        refill++;\\n                    }                         \\n                }\\n                 else{                                      \\n                      if(p[j]>cb){\\n                        refill++;                        \\n                    }                     \\n                 }\\n\\t\\t\\t\\t // no more plant left for watering so break loop \\n                 break; \\n            }\\n                       \\n            // first check if they have sufficient amount of water \\n            // if not then refill it with orginal capacity                 \\n\\t\\t\\t\\n            if(p[i]>ca){\\n                refill++;\\n                ca =  oca;\\n            }            \\n            if(p[j]>cb){\\n                refill++;\\n                cb=  ocb;\\n            }\\n            \\n\\t\\t\\t// decrease consumed water \\n            ca-=p[i] ;                                  \\n            cb-=p[j]; \\n\\t\\t\\t\\n\\t\\t\\t// move both \\n\\t\\t\\ti++;           \\n            j--;\\t\\t\\t                                                \\n        }\\n        return refill;                \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] p, int ca, int cb) {                \\n\\t\\n        int refill= 0,oca =  ca, ocb =  cb;// let save our  orginal capacity    , needed to refill can again\\n        int i=0, j = p.length-1; // starting both end \\n        \\n        while(i<=j){\\n\\t\\t\\n             if(i==j){// mean both at same position\\n                if(ca>=cb){\\n                   if(p[i]>ca){\\n                        refill++;\\n                    }                         \\n                }\\n                 else{                                      \\n                      if(p[j]>cb){\\n                        refill++;                        \\n                    }                     \\n                 }\\n\\t\\t\\t\\t // no more plant left for watering so break loop \\n                 break; \\n            }\\n                       \\n            // first check if they have sufficient amount of water \\n            // if not then refill it with orginal capacity                 \\n\\t\\t\\t\\n            if(p[i]>ca){\\n                refill++;\\n                ca =  oca;\\n            }            \\n            if(p[j]>cb){\\n                refill++;\\n                cb=  ocb;\\n            }\\n            \\n\\t\\t\\t// decrease consumed water \\n            ca-=p[i] ;                                  \\n            cb-=p[j]; \\n\\t\\t\\t\\n\\t\\t\\t// move both \\n\\t\\t\\ti++;           \\n            j--;\\t\\t\\t                                                \\n        }\\n        return refill;                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832322,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int N = plants.size(), i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        // Iterate over all plants left and right one similutaneously.\\n        while (i <= j) {\\n            \\n            // We have reached middle plant.\\n            if (i == j) { \\n                // The one with more water in can will water the plant.\\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        // Alice need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        // Bob need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                // If Alice doesn\\'t have sufficient water, she refills.\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                \\n                // Alice waters.\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                // If Bob doesn\\'t have sufficient water, he refills.\\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                \\n                // Bob waters.\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        return totalFills;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int N = plants.size(), i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        // Iterate over all plants left and right one similutaneously.\\n        while (i <= j) {\\n            \\n            // We have reached middle plant.\\n            if (i == j) { \\n                // The one with more water in can will water the plant.\\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        // Alice need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        // Bob need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                // If Alice doesn\\'t have sufficient water, she refills.\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                \\n                // Alice waters.\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                // If Bob doesn\\'t have sufficient water, he refills.\\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                \\n                // Bob waters.\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        return totalFills;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624252,
                "title": "python3-2-pointers",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624321,
                "title": "java-c-easy-solution-explained-with-comments",
                "content": "**JAVA:**\\n\\n\\'\\'\\'class Solution {\\n\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n\\t\\n\\t\\t//number of refills\\n        int re = 0;\\n        \\n        int a = capacityA, b = capacityB;\\n        int n = plants.length;\\n        \\n\\t\\tif(n==1) return 0;\\n\\t\\t\\n        int j=n-1;\\n        for (int i = 0; i < n; ++i) {\\n            \\n            //if they are at the same plant\\n            if(i==j){\\n                \\n                //if both have equal water or alice has more water\\n                if(a>=b){\\n                    if (a < plants[i]) {\\n                        a = capacityA;\\n                        re++;\\n                        break;\\n                    }\\n                }\\n                \\n                //if bob has more water\\n                else if(b>a){\\n                    if(b < plants[j]){\\n                        b = capacityB;\\n                        re++;\\n                        break;\\n                    }\\n                }\\n                \\n                //we have watered all plants\\n                break;\\n            }\\n            \\n            //if less water in alice\\'s can than required refill it\\n            if (a < plants[i]) {\\n                a = capacityA;\\n                re++;\\n            }\\n            \\n            //if less water in bob\\'s can than required refill it\\n            if(b < plants[j]){\\n                b = capacityB;\\n                re++;\\n            }\\n            \\n            //reduce water in can which is poured\\n            a -= plants[i];\\n            b -= plants[j];\\n                \\n            j--;\\n            \\n            //in even number of plants, all are watered here\\n            if(i==j)\\n                break;\\n        }\\n        return re;\\n    }\\n}\\n\\n\\n\\n**C++:**\\n\\nclass Solution {\\npublic:\\n\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        //number of refills\\n        int re = 0;\\n        \\n        int a = capacityA, b = capacityB;\\n        int n = plants.size();\\n        \\n        if(n==1) return 0;\\n        \\n        int j=n-1;\\n        for (int i = 0; i < n; ++i) {\\n            \\n            //if they are at the same plant\\n            if(i==j){\\n                \\n                //if both have equal water or alice has more water\\n                if(a>=b){\\n                    if (a < plants[i]) {\\n                        a = capacityA;\\n                        re++;\\n                        break;\\n                    }\\n                }\\n                \\n                //if bob has more water\\n                else if(b>a){\\n                    if(b < plants[j]){\\n                        b = capacityB;\\n                        re++;\\n                        break;\\n                    }\\n                }\\n                \\n                //we have watered all plants\\n                break;\\n            }\\n            \\n            //if less water in alice\\'s can than required refill it\\n            if (a < plants[i]) {\\n                a = capacityA;\\n                re++;\\n            }\\n            \\n            //if less water in bob\\'s can than required refill it\\n            if(b < plants[j]){\\n                b = capacityB;\\n                re++;\\n            }\\n            \\n            //reduce water in can which is poured\\n            a -= plants[i];\\n            b -= plants[j];\\n                \\n            j--;\\n            \\n            //in even number of plants, all are watered here\\n            if(i==j)\\n                break;\\n        }\\n        return re;\\n    }\\n};",
                "solutionTags": [
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n\\t\\n\\t\\t//number of refills\\n        int re = 0;\\n        \\n        int a = capacityA, b = capacityB;\\n        int n = plants.length;\\n        \\n\\t\\tif(n==1) return 0;\\n\\t\\t\\n        int j=n-1;\\n        for (int i = 0; i < n; ++i) {\\n            \\n            //if they are at the same plant\\n            if(i==j){\\n                \\n                //if both have equal water or alice has more water\\n                if(a>=b){\\n                    if (a < plants[i]) {\\n                        a = capacityA;\\n                        re++;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1624226,
                "title": "c-two-pointers",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Two Pointers\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-271/problems/watering-plants-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& A, int ca, int cb) {\\n        int N = A.size(), i = 0, j = N - 1, ans = 0, a = ca, b = cb; // i/j is the position of Alice/Bob. a/b is the water of Alice/Bob\\n        while (i <= j) {\\n            if (i == j) { // If Alice and Bob are at the same spot\\n                if (a >= b) ans += a < A[i++];\\n                else ans += b < A[j--];\\n            } else {\\n                if (a < A[i]) a = ca, ++ans;\\n                a -= A[i++];\\n                if (b < A[j]) b = cb, ++ans;\\n                b -= A[j--];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-271/problems/watering-plants-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& A, int ca, int cb) {\\n        int N = A.size(), i = 0, j = N - 1, ans = 0, a = ca, b = cb; // i/j is the position of Alice/Bob. a/b is the water of Alice/Bob\\n        while (i <= j) {\\n            if (i == j) { // If Alice and Bob are at the same spot\\n                if (a >= b) ans += a < A[i++];\\n                else ans += b < A[j--];\\n            } else {\\n                if (a < A[i]) a = ca, ++ans;\\n                a -= A[i++];\\n                if (b < A[j]) b = cb, ++ans;\\n                b -= A[j--];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668106,
                "title": "c-solution",
                "content": "smjh\\n```\\n int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i=0;\\n        int j=plants.size()-1;\\n        int a=capacityA;\\n        int b=capacityB;\\n        int ans=0;\\n        while(i<j){\\n            if(plants[i]<=a){\\n                a-=plants[i];\\n                \\n            }\\n            else{\\n                a=capacityA;\\n                ans++;\\n                a-=plants[i];\\n            }\\n            if(plants[j]<=b){\\n                b-=plants[j];\\n                \\n            }\\n            else{\\n                b=capacityB;\\n                ans++;\\n                b-=plants[j];\\n            }\\n            i++;\\n            j--;\\n            \\n        }\\n        if(i==j){\\n            int mx=max(a,b);\\n            if(mx<plants[i]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nDo upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i=0;\\n        int j=plants.size()-1;\\n        int a=capacityA;\\n        int b=capacityB;\\n        int ans=0;\\n        while(i<j){\\n            if(plants[i]<=a){\\n                a-=plants[i];\\n                \\n            }\\n            else{\\n                a=capacityA;\\n                ans++;\\n                a-=plants[i];\\n            }\\n            if(plants[j]<=b){\\n                b-=plants[j];\\n                \\n            }\\n            else{\\n                b=capacityB;\\n                ans++;\\n                b-=plants[j];\\n            }\\n            i++;\\n            j--;\\n            \\n        }\\n        if(i==j){\\n            int mx=max(a,b);\\n            if(mx<plants[i]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1718613,
                "title": "java-solution-5ms-simple-and-easy",
                "content": "**//please upvote if you like my approach**\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int count=0;\\n        int c1=capacityA,c2=capacityB;\\n        for(int start=0,end=plants.length-1;start<=plants.length/2&&end>=plants.length/2;start++,end--){\\n            if(start==end||start>end)break;\\n            if(c1>=plants[start]){\\n                c1-=plants[start];\\n            }\\n            else{\\n                count++;\\n                c1=capacityA;\\n                c1-=plants[start];\\n            }\\n            if(c2>=plants[end]){\\n                c2-=plants[end];\\n            }\\n            else{\\n                count++;\\n                c2=capacityB;\\n                c2-=plants[end];\\n            }\\n        }\\n        if((c1>c2||c1==c2)&&plants.length%2!=0){\\n            if(plants[plants.length/2]>c1)count++;\\n        }\\n        else if(c1<c2&&plants.length%2!=0){\\n            if(plants[plants.length/2]>c2)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int count=0;\\n        int c1=capacityA,c2=capacityB;\\n        for(int start=0,end=plants.length-1;start<=plants.length/2&&end>=plants.length/2;start++,end--){\\n            if(start==end||start>end)break;\\n            if(c1>=plants[start]){\\n                c1-=plants[start];\\n            }\\n            else{\\n                count++;\\n                c1=capacityA;\\n                c1-=plants[start];\\n            }\\n            if(c2>=plants[end]){\\n                c2-=plants[end];\\n            }\\n            else{\\n                count++;\\n                c2=capacityB;\\n                c2-=plants[end];\\n            }\\n        }\\n        if((c1>c2||c1==c2)&&plants.length%2!=0){\\n            if(plants[plants.length/2]>c1)count++;\\n        }\\n        else if(c1<c2&&plants.length%2!=0){\\n            if(plants[plants.length/2]>c2)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645104,
                "title": "simple-o-n-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int alice=0,bob=n-1,temp1=capacityA,temp2=capacityB;\\n        int count=0;\\n        \\n        while(alice<bob){\\n            if(temp1<plants[alice]){\\n                count++;\\n                temp1=capacityA-plants[alice]; // refill Alice, and move forward after watering this.\\n            }else{\\n                temp1-=plants[alice];\\n            }\\n            if(temp2<plants[bob]){\\n                count++;\\n                temp2=capacityB-plants[bob]; // refill Bob, and move forward after watering this.\\n            }else{\\n                temp2-=plants[bob];\\n            }\\n            alice++,bob--;\\n        }\\n        \\n        if(alice==bob){\\n            if(max(temp1,temp2)<plants[alice]) // only in case of odd elements, both alice and bob hit same element.\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int alice=0,bob=n-1,temp1=capacityA,temp2=capacityB;\\n        int count=0;\\n        \\n        while(alice<bob){\\n            if(temp1<plants[alice]){\\n                count++;\\n                temp1=capacityA-plants[alice]; // refill Alice, and move forward after watering this.\\n            }else{\\n                temp1-=plants[alice];\\n            }\\n            if(temp2<plants[bob]){\\n                count++;\\n                temp2=capacityB-plants[bob]; // refill Bob, and move forward after watering this.\\n            }else{\\n                temp2-=plants[bob];\\n            }\\n            alice++,bob--;\\n        }\\n        \\n        if(alice==bob){\\n            if(max(temp1,temp2)<plants[alice]) // only in case of odd elements, both alice and bob hit same element.\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625030,
                "title": "c-easy-to-understand",
                "content": "```\\n\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int n=plants.size();\\n        int n1=capacityA;\\n        int n2=capacityB;\\n        int i=0;\\n        int j=n-1;\\n        int count=0;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n            if(n1<plants[i] && n2<plants[i]) \\n                count++;\\n            }\\n            else \\n            {\\n            if(plants[i]<=n1)\\n            {\\n                n1=n1-plants[i];\\n            }\\n            else if(plants[i]>n1)\\n            {\\n                n1=capacityA;\\n                count++;\\n                n1=n1-plants[i];\\n            }\\n            if(plants[j]<=n2)\\n            {\\n                n2=n2-plants[j];\\n            }\\n            else if(plants[j]>n2)\\n            {\\n                n2=capacityB;\\n                count++;\\n                n2=n2-plants[j];\\n            }\\n        }\\n            i++;\\n            j--;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int n=plants.size();\\n        int n1=capacityA;\\n        int n2=capacityB;\\n        int i=0;\\n        int j=n-1;\\n        int count=0;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n            if(n1<plants[i] && n2<plants[i]) \\n                count++;\\n            }\\n            else \\n            {\\n            if(plants[i]<=n1)\\n            {\\n                n1=n1-plants[i];\\n            }\\n            else if(plants[i]>n1)\\n            {\\n                n1=capacityA;\\n                count++;\\n                n1=n1-plants[i];\\n            }\\n            if(plants[j]<=n2)\\n            {\\n                n2=n2-plants[j];\\n            }\\n            else if(plants[j]>n2)\\n            {\\n                n2=capacityB;\\n                count++;\\n                n2=n2-plants[j];\\n            }\\n        }\\n            i++;\\n            j--;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624806,
                "title": "c-easy-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int n = p.size();\\n        int i = 0 ; int j = n-1;\\n        ll a = ca  ;\\n        ll b = cb ; \\n        ll ans=0;\\n        while(i <= j)\\n        {\\n            //cout<<ca<<\" \"<<cb<<endl;\\n             if(i==j)\\n            {\\n                 \\n                ca = max(ca , cb);\\n                 if(ca >= p[i]){i++;break;}\\n                 else\\n                 {\\n                     a  = max(a,b);\\n                     if(a >= p[i])\\n                     {\\n                         ans++; break;\\n                     }\\n                     ans+=ceil(p[i]/a);\\n                 }\\n                 \\n            }\\n            if(ca < p[i])\\n            {\\n                ans++;\\n                ca = a ; \\n                \\n            }\\n            if(cb < p[j])\\n            {\\n                ans++;\\n                cb = b ; \\n            }\\n           \\n            if(ca >= p[i])\\n            {\\n                ca-=p[i];\\n                i++;\\n            }\\n             if(cb >= p[j])\\n            {\\n                cb-=p[j];\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int \\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int n = p.size();\\n        int i = 0 ; int j = n-1;\\n        ll a = ca  ;\\n        ll b = cb ; \\n        ll ans=0;\\n        while(i <= j)\\n        {\\n            //cout<<ca<<\" \"<<cb<<endl;\\n             if(i==j)\\n            {\\n                 \\n                ca = max(ca , cb);\\n                 if(ca >= p[i]){i++;break;}",
                "codeTag": "C++"
            },
            {
                "id": 1624382,
                "title": "just-brute-force",
                "content": "```\\nint minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        typedef long long ll;\\n        \\n        ll n = size(plants);\\n        ll cnt = 0;\\n        \\n        ll al = 0 , bob = n-1;\\n        \\n        ll tal = capacityA , tbob = capacityB;\\n        \\n        while(al < bob)\\n        {\\n            if(tal >= plants[al])\\n            {\\n                tal -= plants[al];\\n            }\\n            else\\n            {\\n                tal = capacityA , cnt++;\\n                tal -= plants[al];\\n            }\\n            \\n            if(tbob >= plants[bob])\\n            {\\n                tbob -= plants[bob];\\n            }\\n            else\\n            {\\n                tbob = capacityB , cnt++;\\n                tbob -= plants[bob];\\n            }\\n            \\n            al++ , bob--;\\n        }\\n        \\n        if(al == bob)\\n        {\\n            if(tal == tbob)\\n            {\\n                if(tal >= plants[al]) tal -= plants[al];\\n                else cnt++;\\n            }\\n            else\\n            {\\n                ll mx = max(tal,tbob);\\n                if(mx >= plants[al]) mx -= plants[al];\\n                else cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```\\n\\n**Time Complexity :** O(n)\\n**Space Complexity** : O(1)",
                "solutionTags": [],
                "code": "```\\nint minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        typedef long long ll;\\n        \\n        ll n = size(plants);\\n        ll cnt = 0;\\n        \\n        ll al = 0 , bob = n-1;\\n        \\n        ll tal = capacityA , tbob = capacityB;\\n        \\n        while(al < bob)\\n        {\\n            if(tal >= plants[al])\\n            {\\n                tal -= plants[al];\\n            }\\n            else\\n            {\\n                tal = capacityA , cnt++;\\n                tal -= plants[al];\\n            }\\n            \\n            if(tbob >= plants[bob])\\n            {\\n                tbob -= plants[bob];\\n            }\\n            else\\n            {\\n                tbob = capacityB , cnt++;\\n                tbob -= plants[bob];\\n            }\\n            \\n            al++ , bob--;\\n        }\\n        \\n        if(al == bob)\\n        {\\n            if(tal == tbob)\\n            {\\n                if(tal >= plants[al]) tal -= plants[al];\\n                else cnt++;\\n            }\\n            else\\n            {\\n                ll mx = max(tal,tbob);\\n                if(mx >= plants[al]) mx -= plants[al];\\n                else cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1624262,
                "title": "two-pointer-solution",
                "content": "```\\nint sum = 0;\\n        int alice = capacityA;\\n        int bob = capacityB;\\n        for(int i = 0, j = plants.length - 1; i <= j; i++, j--){\\n            if(i == j){\\n                if(alice >= bob){\\n                    if(alice >= plants[i]){\\n                        alice -= plants[i];\\n                        plants[i] = 0; \\n                    }\\n                    else{\\n                        alice = capacityA;\\n                        sum++;\\n                        alice -= plants[i];\\n                        plants[i] = 0;\\n                    }\\n                }\\n                else{\\n                    if(bob >= plants[j]){\\n                        bob -= plants[j];\\n                        plants[j] = 0;\\n                    }\\n                    else{\\n                        bob = capacityB;\\n                        sum++;\\n                        bob -= plants[j];\\n                        plants[j] = 0;\\n                    }\\n                }\\n                break;\\n            }\\n            if(alice >= plants[i]){\\n                alice -= plants[i];\\n                plants[i] = 0; \\n            }\\n            else{\\n                alice = capacityA;\\n                sum++;\\n                alice -= plants[i];\\n                plants[i] = 0; \\n            }\\n            if(bob >= plants[j]){\\n                bob -= plants[j];\\n                plants[j] = 0;\\n            }\\n            else{\\n                bob = capacityB;\\n                sum++;\\n                bob -= plants[j];\\n                plants[j] = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nint sum = 0;\\n        int alice = capacityA;\\n        int bob = capacityB;\\n        for(int i = 0, j = plants.length - 1; i <= j; i++, j--){\\n            if(i == j){\\n                if(alice >= bob){\\n                    if(alice >= plants[i]){\\n                        alice -= plants[i];\\n                        plants[i] = 0; \\n                    }\\n                    else{\\n                        alice = capacityA;\\n                        sum++;\\n                        alice -= plants[i];\\n                        plants[i] = 0;\\n                    }\\n                }\\n                else{\\n                    if(bob >= plants[j]){\\n                        bob -= plants[j];\\n                        plants[j] = 0;\\n                    }\\n                    else{\\n                        bob = capacityB;\\n                        sum++;\\n                        bob -= plants[j];\\n                        plants[j] = 0;\\n                    }\\n                }\\n                break;\\n            }\\n            if(alice >= plants[i]){\\n                alice -= plants[i];\\n                plants[i] = 0; \\n            }\\n            else{\\n                alice = capacityA;\\n                sum++;\\n                alice -= plants[i];\\n                plants[i] = 0; \\n            }\\n            if(bob >= plants[j]){\\n                bob -= plants[j];\\n                plants[j] = 0;\\n            }\\n            else{\\n                bob = capacityB;\\n                sum++;\\n                bob -= plants[j];\\n                plants[j] = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958238,
                "title": "easy-and-basic-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n = plants.size();\\n        int count =0;\\n        int start =0;\\n        int end =n-1;\\n        int aliceCC = capacityA;\\n        int bobCC = capacityB;\\n        while(start<=end){\\n           \\n            if(start==end){\\n               if(aliceCC>=bobCC){\\n                    if(aliceCC>=plants[start]){\\n                        aliceCC-=plants[start];\\n                    }\\n                    else{\\n                        aliceCC=capacityA;\\n                         count+=1;\\n                    }\\n               }\\n               else{\\n                   if(bobCC>=plants[end]){\\n                          bobCC-=plants[end];\\n                    }\\n                    else{\\n                           bobCC=capacityB;\\n                           count+=1;\\n                     }\\n               }\\n              break;\\n            }\\n            if(aliceCC>=plants[start]){\\n                 aliceCC-=plants[start];\\n            }\\n            else{\\n                aliceCC=capacityA;\\n                aliceCC-=plants[start];\\n                count+=1;\\n            }\\n            if(bobCC>=plants[end]){\\n                 bobCC-=plants[end];\\n            }\\n            else{\\n                bobCC=capacityB;\\n                bobCC-=plants[end];\\n                count+=1;\\n            }\\n\\n\\n            start++;\\n            end--;\\n        }\\n    return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n = plants.size();\\n        int count =0;\\n        int start =0;\\n        int end =n-1;\\n        int aliceCC = capacityA;\\n        int bobCC = capacityB;\\n        while(start<=end){\\n           \\n            if(start==end){\\n               if(aliceCC>=bobCC){\\n                    if(aliceCC>=plants[start]){\\n                        aliceCC-=plants[start];\\n                    }\\n                    else{\\n                        aliceCC=capacityA;\\n                         count+=1;\\n                    }\\n               }\\n               else{\\n                   if(bobCC>=plants[end]){\\n                          bobCC-=plants[end];\\n                    }\\n                    else{\\n                           bobCC=capacityB;\\n                           count+=1;\\n                     }\\n               }\\n              break;\\n            }\\n            if(aliceCC>=plants[start]){\\n                 aliceCC-=plants[start];\\n            }\\n            else{\\n                aliceCC=capacityA;\\n                aliceCC-=plants[start];\\n                count+=1;\\n            }\\n            if(bobCC>=plants[end]){\\n                 bobCC-=plants[end];\\n            }\\n            else{\\n                bobCC=capacityB;\\n                bobCC-=plants[end];\\n                count+=1;\\n            }\\n\\n\\n            start++;\\n            end--;\\n        }\\n    return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957751,
                "title": "two-pointer-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumRefill(_ plants: [Int], _ capacityA: Int, _ capacityB: Int) -> Int {\\n        var ans = 0\\n        var i = 0\\n        var aliceWater = capacityA\\n        var bobWater = capacityB\\n        var j = plants.count-1\\n        \\n        while i < j {\\n            if plants[i] > aliceWater {\\n                ans += 1\\n                aliceWater = capacityA\\n            }\\n            \\n            if plants[j] > bobWater {\\n                ans += 1\\n                bobWater = capacityB\\n            }\\n            aliceWater -= plants[i]\\n            bobWater -= plants[j]\\n            i += 1\\n            j -= 1\\n        }\\n        if plants[j] > bobWater &&  plants[i] > aliceWater && i == j {\\n            ans += 1\\n            bobWater = capacityB\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumRefill(_ plants: [Int], _ capacityA: Int, _ capacityB: Int) -> Int {\\n        var ans = 0\\n        var i = 0\\n        var aliceWater = capacityA\\n        var bobWater = capacityB\\n        var j = plants.count-1\\n        \\n        while i < j {\\n            if plants[i] > aliceWater {\\n                ans += 1\\n                aliceWater = capacityA\\n            }\\n            \\n            if plants[j] > bobWater {\\n                ans += 1\\n                bobWater = capacityB\\n            }\\n            aliceWater -= plants[i]\\n            bobWater -= plants[j]\\n            i += 1\\n            j -= 1\\n        }\\n        if plants[j] > bobWater &&  plants[i] > aliceWater && i == j {\\n            ans += 1\\n            bobWater = capacityB\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918926,
                "title": "c-super-easy-clean-code-two-pointers-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        \\n        int n = plants.size();\\n        int i = 0;\\n        int j = n-1;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        int cnt = 0;\\n        while(i < j){\\n            capA -= plants[i];\\n            capB -= plants[j];\\n\\n            if(capA < 0){\\n                cnt++;\\n                capA = capacityA - plants[i];\\n            } \\n            if(capB < 0){\\n                capB = capacityB - plants[j];\\n                cnt++;\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n\\n        if(i == j){\\n            capA = max(capA,capB);\\n            if(capA < plants[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        \\n        int n = plants.size();\\n        int i = 0;\\n        int j = n-1;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        int cnt = 0;\\n        while(i < j){\\n            capA -= plants[i];\\n            capB -= plants[j];\\n\\n            if(capA < 0){\\n                cnt++;\\n                capA = capacityA - plants[i];\\n            } \\n            if(capB < 0){\\n                capB = capacityB - plants[j];\\n                cnt++;\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n\\n        if(i == j){\\n            capA = max(capA,capB);\\n            if(capA < plants[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706367,
                "title": "straightforward-c-solution-clean-and-simple-code-o-n-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n = plants.size(), i = 0, j = n-1, A = capacityA, B = capacityB, count = 0;\\n        while(i<=j)\\n        {\\n            if(A>=plants[i]) \\n                A -= plants[i++];\\n            else{ \\n                A = capacityA;\\n                count++;\\n                A -= plants[i++];\\n            }\\n            if(B>=plants[j])\\n                B -= plants[j--];\\n            else{\\n                B = capacityB;\\n                count++;\\n                B -= plants[j--];\\n            }\\n            if(i==j)\\n            {\\n                if(A>=B){\\n                    if(A>=plants[i])    A -= plants[i++];\\n                    else{\\n                        A = capacityA;\\n                        count++;\\n                        A -= plants[i++];\\n                    }\\n                }\\n                else{\\n                    if(B>=plants[j])    B -= plants[j--];\\n                    else{\\n                        B = capacityB;\\n                        count++;\\n                        B -= plants[j--];\\n                    }\\n                }   \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n = plants.size(), i = 0, j = n-1, A = capacityA, B = capacityB, count = 0;\\n        while(i<=j)\\n        {\\n            if(A>=plants[i]) \\n                A -= plants[i++];\\n            else{ \\n                A = capacityA;\\n                count++;\\n                A -= plants[i++];\\n            }\\n            if(B>=plants[j])\\n                B -= plants[j--];\\n            else{\\n                B = capacityB;\\n                count++;\\n                B -= plants[j--];\\n            }\\n            if(i==j)\\n            {\\n                if(A>=B){\\n                    if(A>=plants[i])    A -= plants[i++];\\n                    else{\\n                        A = capacityA;\\n                        count++;\\n                        A -= plants[i++];\\n                    }\\n                }\\n                else{\\n                    if(B>=plants[j])    B -= plants[j--];\\n                    else{\\n                        B = capacityB;\\n                        count++;\\n                        B -= plants[j--];\\n                    }\\n                }   \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521637,
                "title": "java-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] p,int  A, int B) {\\n        int n=p.length;\\n        int x=A,y=B;\\n        int i=0,j=n-1,c=0;\\n        while(i<j){\\n            if(x<p[i]){\\n                c++;\\n                x=A;\\n            }\\n            if(y<p[j]){\\n                c++;\\n               y=B;\\n            }\\n            x=x-p[i];\\n             y=y-p[j];\\n            i++;\\n            j--;\\n         }\\n      if(i==j && n%2!=0){\\n                if(Math.max(x,y)<p[i])\\n                    c++;\\n            }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] p,int  A, int B) {\\n        int n=p.length;\\n        int x=A,y=B;\\n        int i=0,j=n-1,c=0;\\n        while(i<j){\\n            if(x<p[i]){\\n                c++;\\n                x=A;\\n            }\\n            if(y<p[j]){\\n                c++;\\n               y=B;\\n            }\\n            x=x-p[i];\\n             y=y-p[j];\\n            i++;\\n            j--;\\n         }\\n      if(i==j && n%2!=0){\\n                if(Math.max(x,y)<p[i])\\n                    c++;\\n            }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515118,
                "title": "simple-c-solution-2-pointer-approach-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int waterA = capacityA, waterB = capacityB, s = 0, e = plants.size() - 1, count = 0;\\n        while(s<e)\\n        {\\n            if(waterA < plants[s])\\n            {\\n                waterA = capacityA;\\n                count++;\\n            }\\n            waterA -= plants[s++];\\n            if(waterB < plants[e])\\n            {\\n                waterB = capacityB;\\n                count++;\\n            }\\n            waterB -= plants[e--];\\n        } \\n        if(s==e)\\n        {\\n            int maxWater =0;\\n            if(waterA >= waterB) maxWater = waterA;\\n            else maxWater = waterB;\\n            if(maxWater < plants[s]) count++;\\n        }        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int waterA = capacityA, waterB = capacityB, s = 0, e = plants.size() - 1, count = 0;\\n        while(s<e)\\n        {\\n            if(waterA < plants[s])\\n            {\\n                waterA = capacityA;\\n                count++;\\n            }\\n            waterA -= plants[s++];\\n            if(waterB < plants[e])\\n            {\\n                waterB = capacityB;\\n                count++;\\n            }\\n            waterB -= plants[e--];\\n        } \\n        if(s==e)\\n        {\\n            int maxWater =0;\\n            if(waterA >= waterB) maxWater = waterA;\\n            else maxWater = waterB;\\n            if(maxWater < plants[s]) count++;\\n        }        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212746,
                "title": "easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int cnt=0;\\n        int start=0;\\n        int end=n-1;\\n        int a=capacityA;\\n        int b=capacityB;\\n        while(1)\\n        {\\n            if(end<start)\\n            break;\\n            if(end==start)\\n            {\\n                if(a<plants[start] && b<plants[end])\\n                cnt++;\\n                break;\\n            }\\n            if(plants[start]>a)\\n            {\\n                cnt++;\\n                a=capacityA-plants[start];\\n            }else if(plants[start]<=a)\\n            {\\n                a-=plants[start];\\n            }\\n            if(plants[end]>b)\\n            {\\n                cnt++;\\n                b=capacityB-plants[end];\\n            }else if(plants[end]<=b)\\n            {\\n                b-=plants[end];\\n            }\\n            start++;\\n            end--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int cnt=0;\\n        int start=0;\\n        int end=n-1;\\n        int a=capacityA;\\n        int b=capacityB;\\n        while(1)\\n        {\\n            if(end<start)\\n            break;\\n            if(end==start)\\n            {\\n                if(a<plants[start] && b<plants[end])\\n                cnt++;\\n                break;\\n            }\\n            if(plants[start]>a)\\n            {\\n                cnt++;\\n                a=capacityA-plants[start];\\n            }else if(plants[start]<=a)\\n            {\\n                a-=plants[start];\\n            }\\n            if(plants[end]>b)\\n            {\\n                cnt++;\\n                b=capacityB-plants[end];\\n            }else if(plants[end]<=b)\\n            {\\n                b-=plants[end];\\n            }\\n            start++;\\n            end--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090856,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif plants.length i.e n is even they do not meet they will crossover each other otherwise they will meet at the middle which is last iteration check if any one of them has sufficient water then continue otherwise increment refill++\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        //TimeComplexity-O(N) spaceComplexity-O(1)\\n        int n=plants.length;\\n        int fulla=capacityA;\\n        int fullb=capacityB;\\n        int start=0;\\n        int end=n-1;\\n        int refill=0;\\n        while(start<=end){\\n            if(start==end){\\n                if(capacityA<plants[start] && capacityB<plants[start]){\\n                    refill++;\\n                }\\n            }\\n            else{\\n            if(capacityA>=plants[start]){\\n                capacityA=capacityA-plants[start];\\n            }else{\\n                capacityA=fulla;\\n                capacityA=capacityA-plants[start];\\n                refill++;\\n            }\\n            if(capacityB>=plants[end]){\\n                capacityB=capacityB-plants[end];\\n            }else{\\n                capacityB=fullb;\\n                capacityB=capacityB-plants[end];\\n                refill++;\\n            }\\n            }\\n            start++;\\n            end--;\\n        }\\n        return refill;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        //TimeComplexity-O(N) spaceComplexity-O(1)\\n        int n=plants.length;\\n        int fulla=capacityA;\\n        int fullb=capacityB;\\n        int start=0;\\n        int end=n-1;\\n        int refill=0;\\n        while(start<=end){\\n            if(start==end){\\n                if(capacityA<plants[start] && capacityB<plants[start]){\\n                    refill++;\\n                }\\n            }\\n            else{\\n            if(capacityA>=plants[start]){\\n                capacityA=capacityA-plants[start];\\n            }else{\\n                capacityA=fulla;\\n                capacityA=capacityA-plants[start];\\n                refill++;\\n            }\\n            if(capacityB>=plants[end]){\\n                capacityB=capacityB-plants[end];\\n            }else{\\n                capacityB=fullb;\\n                capacityB=capacityB-plants[end];\\n                refill++;\\n            }\\n            }\\n            start++;\\n            end--;\\n        }\\n        return refill;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738213,
                "title": "c-two-pointer-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i = 0;\\n        int j = plants.size() - 1;\\n        int tot_refill = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        while(i<j){\\n            \\n            if(plants[i]<=capacityA)\\n            {\\n                capacityA-=plants[i];\\n                i++;\\n            }\\n            else{\\n                tot_refill++;\\n                capacityA = capA-plants[i];\\n                i++;\\n            }\\n            if(plants[j]<=capacityB)\\n            {\\n                capacityB-=plants[j];\\n                j--;\\n            }\\n            else{\\n                tot_refill++;\\n                capacityB = capB-plants[j];\\n                j--;\\n            }\\n        }\\n        if(i==j){\\n            if(capacityA<plants[i] && capacityB<plants[i])\\n                tot_refill++;\\n        }\\n        return tot_refill;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i = 0;\\n        int j = plants.size() - 1;\\n        int tot_refill = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        while(i<j){\\n            \\n            if(plants[i]<=capacityA)\\n            {\\n                capacityA-=plants[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2615156,
                "title": "very-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length, ai = 0, bi = n - 1, ac = capacityA, bc = capacityB, c = 0;\\n        // ai is alice\\'s current index and bi for bob. Same for capacity\\n\\t\\t\\n        while(ai < bi){\\n\\t\\t\\t// If there is not enough water in the can, then refill it and increment the count\\n            if(ac < plants[ai]){ ac = capacityA; c++; }\\n            ac -= plants[ai++];\\n            \\n            if(bc < plants[bi]){ bc = capacityB; c++; }\\n            bc -= plants[bi--];\\n        }\\n\\t\\t\\n        // If alice and bob are on the same plant and both don\\'t have sufficient water in their cans.\\n\\t\\t// Then increment the count because one will have to refill.\\n\\t\\t\\n        if(ai == bi && ac < plants[ai] && bc < plants[bi]) c++;\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length, ai = 0, bi = n - 1, ac = capacityA, bc = capacityB, c = 0;\\n        // ai is alice\\'s current index and bi for bob. Same for capacity\\n\\t\\t\\n        while(ai < bi){\\n\\t\\t\\t// If there is not enough water in the can, then refill it and increment the count\\n            if(ac < plants[ai]){ ac = capacityA; c++; }\\n            ac -= plants[ai++];\\n            \\n            if(bc < plants[bi]){ bc = capacityB; c++; }\\n            bc -= plants[bi--];\\n        }\\n\\t\\t\\n        // If alice and bob are on the same plant and both don\\'t have sufficient water in their cans.\\n\\t\\t// Then increment the count because one will have to refill.\\n\\t\\t\\n        if(ai == bi && ac < plants[ai] && bc < plants[bi]) c++;\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524354,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int i = 0, j = plants.size() - 1, canA = capacityA, canB = capacityB, res = 0;\\n        while (i < j) {\\n            res += (canA < plants[i]) + (canB < plants[j]);\\n            canA = canA < plants[i] ? capacityA : canA;\\n            canB = canB < plants[j] ? capacityB : canB;\\n            canA -= plants[i++];\\n            canB -= plants[j--];\\n        }\\n        return res + (i == j && max(canA, canB) < plants[i]);\\n    }\\n\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int i = 0, j = plants.size() - 1, canA = capacityA, canB = capacityB, res = 0;\\n        while (i < j) {\\n            res += (canA < plants[i]) + (canB < plants[j]);\\n            canA = canA < plants[i] ? capacityA : canA;\\n            canB = canB < plants[j] ? capacityB : canB;\\n            canA -= plants[i++];\\n            canB -= plants[j--];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2071545,
                "title": "cpp-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.size()-1,count=0,tempA=capacityA,tempB=capacityB;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(capacityA>=plants[i]||capacityB>=plants[j])\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n            if(capacityA>=plants[i]&&capacityB>=plants[j]&&i!=j)\\n            {\\n                capacityA-=plants[i];\\n                capacityB-=plants[j];\\n                i++;\\n                j--;\\n                \\n            }\\n            else if(capacityA>=plants[i]&&capacityB<plants[j]&&i!=j)\\n            {\\n                capacityA-=plants[i];\\n                capacityB=tempB;\\n                i++;\\n                capacityB-=plants[j];\\n                j--;\\n                count++;\\n            }\\n            else if(capacityA<plants[i]&&capacityB>=plants[j]&&i!=j)\\n            {\\n                capacityA=tempA;\\n                capacityA-=plants[i];\\n                i++;\\n                capacityB-=plants[j];\\n                j--;\\n                count++;\\n            }\\n            else if(capacityA<plants[i]&&capacityB<plants[j]&&i!=j)\\n            {\\n                \\n                capacityA=tempA;\\n                capacityA-=plants[i];\\n                i++;\\n                capacityB=tempB;\\n                capacityB-=plants[j];\\n                j--;\\n                count++;\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.size()-1,count=0,tempA=capacityA,tempB=capacityB;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(capacityA>=plants[i]||capacityB>=plants[j])\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n            if(capacityA>=plants[i]&&capacityB>=plants[j]&&i!=j)\\n            {\\n                capacityA-=plants[i];\\n                capacityB-=plants[j];\\n                i++;\\n                j--;\\n                \\n            }\\n            else if(capacityA>=plants[i]&&capacityB<plants[j]&&i!=j)\\n            {\\n                capacityA-=plants[i];\\n                capacityB=tempB;\\n                i++;\\n                capacityB-=plants[j];\\n                j--;\\n                count++;\\n            }\\n            else if(capacityA<plants[i]&&capacityB>=plants[j]&&i!=j)\\n            {\\n                capacityA=tempA;\\n                capacityA-=plants[i];\\n                i++;\\n                capacityB-=plants[j];\\n                j--;\\n                count++;\\n            }\\n            else if(capacityA<plants[i]&&capacityB<plants[j]&&i!=j)\\n            {\\n                \\n                capacityA=tempA;\\n                capacityA-=plants[i];\\n                i++;\\n                capacityB=tempB;\\n                capacityB-=plants[j];\\n                j--;\\n                count++;\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729214,
                "title": "java-solution-3ms-simple-and-faster-than-99-91",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        \\n        int n = plants.length;\\n        int i = 0, j = n - 1;\\n        int aRefill = 0, bRefill = 0;\\n        int initialCapacityA = capacityA;\\n        int initialCapacityB = capacityB;\\n        \\n        while (i <= j) {\\n            if (i == j) {\\n                if (!(capacityA >= plants[i] || capacityB >=  plants[i])) {\\n                    aRefill++;\\n                }\\n                i++;\\n                continue;\\n            } \\n            \\n            if (capacityA >= plants[i]) {\\n                capacityA = capacityA - plants[i];\\n            } else {\\n                aRefill++;\\n                capacityA = initialCapacityA - plants[i];\\n            }\\n            \\n            if (capacityB >= plants[j]) {\\n                capacityB = capacityB - plants[j];\\n            } else {\\n                bRefill++;\\n                capacityB = initialCapacityB - plants[j];\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return (aRefill + bRefill);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        \\n        int n = plants.length;\\n        int i = 0, j = n - 1;\\n        int aRefill = 0, bRefill = 0;\\n        int initialCapacityA = capacityA;\\n        int initialCapacityB = capacityB;\\n        \\n        while (i <= j) {\\n            if (i == j) {\\n                if (!(capacityA >= plants[i] || capacityB >=  plants[i])) {\\n                    aRefill++;\\n                }\\n                i++;\\n                continue;\\n            } \\n            \\n            if (capacityA >= plants[i]) {\\n                capacityA = capacityA - plants[i];\\n            } else {\\n                aRefill++;\\n                capacityA = initialCapacityA - plants[i];\\n            }\\n            \\n            if (capacityB >= plants[j]) {\\n                capacityB = capacityB - plants[j];\\n            } else {\\n                bRefill++;\\n                capacityB = initialCapacityB - plants[j];\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return (aRefill + bRefill);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668031,
                "title": "c-easy-solution-two-pointers-o-n",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n     \\n        int n(plants.size()), res(0), aliceC(capacityA), bobC(capacityB), alice(0), bob(n-1);\\n        \\n        while (alice < bob)\\n        {\\n            if (alice == bob)\\n            {\\n                if (aliceC < plants[alice] and bobC < plants[bob]) res++;\\n                break;\\n            }\\n            if (aliceC < plants[alice]) aliceC = capacityA, res++;\\n            if (bobC < plants[bob]) bobC = capacityB, res++;\\n            aliceC -= plants[alice++];\\n            bobC -= plants[bob--];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n     \\n        int n(plants.size()), res(0), aliceC(capacityA), bobC(capacityB), alice(0), bob(n-1);\\n        \\n        while (alice < bob)\\n        {\\n            if (alice == bob)\\n            {\\n                if (aliceC < plants[alice] and bobC < plants[bob]) res++;\\n                break;\\n            }\\n            if (aliceC < plants[alice]) aliceC = capacityA, res++;\\n            if (bobC < plants[bob]) bobC = capacityB, res++;\\n            aliceC -= plants[alice++];\\n            bobC -= plants[bob--];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655027,
                "title": "c-easy-code",
                "content": "class Solution {\\npublic:\\n   \\n   int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n   \\n        int n=plants.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        \\n        int bob=n-1;\\n        int A=capacityA,B=capacityB;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==bob)\\n            {\\n                if(plants[i]>capacityA && plants[i]>capacityB)\\n                {\\n                    count++;\\n                }\\n                break;\\n            \\n            }\\n            if(plants[i]>capacityA)\\n            {\\n                count++;\\n                capacityA=A;\\n                \\n            }\\n            if(plants[bob]>capacityB)\\n            {\\n                count++;\\n                capacityB=B;\\n            }\\n            capacityA-=plants[i];\\n            capacityB-=plants[bob];\\n            bob--;\\n            if(i==bob)\\n            {\\n                break;\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n   \\n   int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n   \\n        int n=plants.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1643367,
                "title": "c-solution-two-pointers",
                "content": "```\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int a=0;\\n        int b=n-1;\\n        int ans = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        \\n        while(a<b){\\n            if(capA<plants[a]){\\n                capA=capacityA;\\n                ans++;\\n            }\\n            if(capB<plants[b]){\\n                capB=capacityB;\\n                ans++;\\n            }\\n            capA-=plants[a];\\n            a++;\\n            capB-=plants[b];\\n            b--;\\n        }\\n        \\n        if(a==b){\\n            int maxCap=max(capA, capB);\\n            if(maxCap<plants[a])\\n                ans++;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int a=0;\\n        int b=n-1;\\n        int ans = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        \\n        while(a<b){\\n            if(capA<plants[a]){\\n                capA=capacityA;\\n                ans++;\\n            }\\n            if(capB<plants[b]){\\n                capB=capacityB;\\n                ans++;\\n            }\\n            capA-=plants[a];\\n            a++;\\n            capB-=plants[b];\\n            b--;\\n        }\\n        \\n        if(a==b){\\n            int maxCap=max(capA, capB);\\n            if(maxCap<plants[a])\\n                ans++;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634500,
                "title": "c-easy-solution-two-pointer-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int ans=0;\\n        int i=0;\\n        int j=plants.size()-1;\\n        int alice = capacityA;\\n        int bob = capacityB;\\n        while(i <= j){\\n            if(i != j){\\n                if(alice < plants[i]){\\n                    alice = capacityA;\\n                    ans++;\\n                }\\n                if(bob < plants[j]){\\n                    bob = capacityB;\\n                    ans++;\\n                }\\n                alice -= plants[i];\\n                bob -= plants[j];\\n                \\n            }else{\\n                if(bob < plants[i] && alice < plants[i])\\n                    ans++;\\n                    \\n            }\\n            i++,j--;\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int ans=0;\\n        int i=0;\\n        int j=plants.size()-1;\\n        int alice = capacityA;\\n        int bob = capacityB;\\n        while(i <= j){\\n            if(i != j){\\n                if(alice < plants[i]){\\n                    alice = capacityA;\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1628243,
                "title": "python-very-easy-and-fastest-solution",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \\n        Alice , Bob  = capacityA, capacityB\\n        \\n        res, i, j = 0, 0, len(plants)-1\\n        \\n        while i < j:\\n            if Alice >= plants[i]:\\n                Alice -= plants[i]\\n            else:\\n                res += 1\\n                Alice = capacityA - plants[i]\\n            \\n            if Bob >= plants[j]:\\n                Bob -= plants[j]\\n            else:\\n                res += 1\\n                Bob = capacityB - plants[j]\\n                \\n            i += 1    \\n            j -= 1\\n        \\n        return res + 1 if i == j and Alice < plants[i] and Bob < plants[i] else res\\n\\t\\t\\n```\\n![image](https://assets.leetcode.com/users/images/9e48f3e3-47c8-4159-9f9c-c89b028591e9_1639462682.9795556.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \\n        Alice , Bob  = capacityA, capacityB\\n        \\n        res, i, j = 0, 0, len(plants)-1\\n        \\n        while i < j:\\n            if Alice >= plants[i]:\\n                Alice -= plants[i]\\n            else:\\n                res += 1\\n                Alice = capacityA - plants[i]\\n            \\n            if Bob >= plants[j]:\\n                Bob -= plants[j]\\n            else:\\n                res += 1\\n                Bob = capacityB - plants[j]\\n                \\n            i += 1    \\n            j -= 1\\n        \\n        return res + 1 if i == j and Alice < plants[i] and Bob < plants[i] else res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625797,
                "title": "java-clean-2-pointer-simulation",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n\\t\\n        int left = 0, right = plants.length - 1;\\n        int alice = capacityA, bob = capacityB, refills = 0;\\n        \\n        while(left <= right)\\n        {\\n            if(left == right)\\n            {\\n                if(plants[left] > Math.max(alice, bob)) //check if we need one last refill\\n                {\\n                    refills++;\\n                }\\n                break; //end simulation since we are on last element\\n            }\\n            \\n            if(alice < plants[left])\\n            {\\n                refills++;\\n                alice = capacityA;\\n            }\\n\\n            if(bob < plants[right])\\n            {\\n                refills++;\\n                bob = capacityB;\\n            }\\n\\n            alice -= plants[left++];\\n            bob -= plants[right--];\\n        }\\n        \\n        return refills;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n\\t\\n        int left = 0, right = plants.length - 1;\\n        int alice = capacityA, bob = capacityB, refills = 0;\\n        \\n        while(left <= right)\\n        {\\n            if(left == right)\\n            {\\n                if(plants[left] > Math.max(alice, bob)) //check if we need one last refill\\n                {\\n                    refills++;\\n                }\\n                break; //end simulation since we are on last element\\n            }\\n            \\n            if(alice < plants[left])\\n            {\\n                refills++;\\n                alice = capacityA;\\n            }\\n\\n            if(bob < plants[right])\\n            {\\n                refills++;\\n                bob = capacityB;\\n            }\\n\\n            alice -= plants[left++];\\n            bob -= plants[right--];\\n        }\\n        \\n        return refills;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625775,
                "title": "python-3-two-pointers-o-n",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        a, b = 0, len(plants) - 1\\n        waterA, waterB = capacityA, capacityB\\n        res = 0\\n        while a < b:\\n            if waterA < plants[a]:\\n                res += 1\\n                waterA = capacityA\\n            waterA -= plants[a]\\n            a += 1\\n            \\n            if waterB < plants[b]:\\n                res += 1\\n                waterB = capacityB\\n            waterB -= plants[b]\\n            b -= 1\\n        \\n        if a == b and waterA < plants[a] and waterB < plants[a]:\\n            res += 1\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        a, b = 0, len(plants) - 1\\n        waterA, waterB = capacityA, capacityB\\n        res = 0\\n        while a < b:\\n            if waterA < plants[a]:\\n                res += 1\\n                waterA = capacityA\\n            waterA -= plants[a]\\n            a += 1\\n            \\n            if waterB < plants[b]:\\n                res += 1\\n                waterB = capacityB\\n            waterB -= plants[b]\\n            b -= 1\\n        \\n        if a == b and waterA < plants[a] and waterB < plants[a]:\\n            res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1625615,
                "title": "how-about-this-test-case",
                "content": "```\\n[1, 1, 1, 1]\\n1\\n10000\\n```\\n\\nIdeally Bob can water all the plans in one go & number of refills should be 0. However as per accepted code it is 1. Wouldn\\'t this be more greeedy?",
                "solutionTags": [],
                "code": "```\\n[1, 1, 1, 1]\\n1\\n10000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624816,
                "title": "c-using-2-pointers",
                "content": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i = 0, j = plants.size() - 1;\\n        int refil = 0;\\n        int tempA = capacityA;\\n        int tempB = capacityB;\\n        \\n        while(i <= j) {\\n            \\n            if(i == j) {\\n                if(tempA >= tempB) {\\n                    if(tempA < plants[i]) {\\n                        tempA = capacityA;\\n                        refil++;\\n                    }\\n                    tempA = tempA - plants[i];\\n                    i++;\\n                }\\n                else {\\n                    if(tempB < plants[i]) {\\n                        tempB = capacityB;   \\n                        refil++;\\n                    }\\n                    tempB = tempB - plants[j];\\n                    j--;\\n                }\\n                \\n            }\\n            \\n            else{\\n                if(tempA < plants[i]) {\\n                    tempA = capacityA;\\n                    refil++;\\n                }\\n                tempA = tempA - plants[i];\\n                i++;\\n\\n                if(tempB < plants[j]) {\\n                    tempB = capacityB;   \\n                    refil++;\\n                }\\n                tempB = tempB - plants[j];\\n                j--;\\n            }\\n\\n        }\\n        \\n        return refil;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i = 0, j = plants.size() - 1;\\n        int refil = 0;\\n        int tempA = capacityA;\\n        int tempB = capacityB;\\n        \\n        while(i <= j) {\\n            \\n            if(i == j) {\\n                if(tempA >= tempB) {\\n                    if(tempA < plants[i]) {\\n                        tempA = capacityA;\\n                        refil++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1624717,
                "title": "c-100-faster-full-code-walkthrough-2-pointer-approach-o-n-time",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\nIntuition- at each time alice waters 1 plant from left and bob 1 plant from the right. If odd no. of plants alice will water the last plant.\\n\\n**Time Complexity- O(n)\\nSpace Complexity- O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        //Let A is B representing the water of Alice\\'s and Bob\\'s watering cans initially full to the capacity\\n\\t\\tint A=capacityA,B=capacityB;\\n\\t\\t//Alice starts watering from start index i and bob from end index j;\\n        int i=0,j=plants.size()-1;\\n        int refill=0;\\n        while(i<j){\\n            if(plants[i]>A){\\n\\t\\t\\t\\t//A does not have enough water to completely water the current plant\\n                refill++;\\n                A=capacityA;\\n            }\\n            if(plants[j]>B){\\n\\t\\t\\t\\t//B does not have enough water to completely water the current plant\\n                refill++;\\n                B=capacityB;\\n            }\\n\\t\\t\\t//after watering index i and j, decrease water in the Alice\\'s and Bob\\'s watering cans by amount of water required by the respective plants\\n            A-=plants[i++];\\n            B-=plants[j--];\\n        }\\n\\t\\t//if both Alice and Bob reach the same plant\\n        if(i==j){\\n            if(A>=B){\\n\\t\\t\\t   //Alice has greater or equal water in her watering can compared to Bob.\\n                if(plants[i]>A){\\n                    refill++;\\n                    A=capacityA;\\n                }\\n                A-=plants[i++];\\n            }\\n            else{\\n\\t\\t\\t\\t//Bob has greater water in his watering can compared to Bob.\\n                if(plants[j]>B){\\n                    refill++;\\n                    B=capacityB;\\n                }\\n                B-=plants[j--];\\n            }\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        //Let A is B representing the water of Alice\\'s and Bob\\'s watering cans initially full to the capacity\\n\\t\\tint A=capacityA,B=capacityB;\\n\\t\\t//Alice starts watering from start index i and bob from end index j;\\n        int i=0,j=plants.size()-1;\\n        int refill=0;\\n        while(i<j){\\n            if(plants[i]>A){\\n\\t\\t\\t\\t//A does not have enough water to completely water the current plant\\n                refill++;\\n                A=capacityA;\\n            }\\n            if(plants[j]>B){\\n\\t\\t\\t\\t//B does not have enough water to completely water the current plant\\n                refill++;\\n                B=capacityB;\\n            }\\n\\t\\t\\t//after watering index i and j, decrease water in the Alice\\'s and Bob\\'s watering cans by amount of water required by the respective plants\\n            A-=plants[i++];\\n            B-=plants[j--];\\n        }\\n\\t\\t//if both Alice and Bob reach the same plant\\n        if(i==j){\\n            if(A>=B){\\n\\t\\t\\t   //Alice has greater or equal water in her watering can compared to Bob.\\n                if(plants[i]>A){\\n                    refill++;\\n                    A=capacityA;\\n                }\\n                A-=plants[i++];\\n            }\\n            else{\\n\\t\\t\\t\\t//Bob has greater water in his watering can compared to Bob.\\n                if(plants[j]>B){\\n                    refill++;\\n                    B=capacityB;\\n                }\\n                B-=plants[j--];\\n            }\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624692,
                "title": "simple-brute-force",
                "content": "````\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        //using a simple brute force\\n        int ans=0;\\n        int a=capacityA;\\n        int b=capacityB;\\n        int i=0;\\n        int j=plants.size()-1;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n              if(a>=b)\\n              {\\n                  ans+=a<plants[i];\\n                  i++;\\n              }\\n                else\\n                {\\n                    ans+=b<plants[j];\\n                    j--;\\n                }\\n            }\\n            else\\n            {\\n                if(a<plants[i])\\n                {\\n                    a=capacityA;\\n                    ans++;\\n                }\\n                    a=a-plants[i];\\n                    i++;\\n                \\n                if(b<plants[j])\\n                {\\n                    b=capacityB;\\n                    ans++;\\n                }\\n                    b=b-plants[j];\\n                    j--;\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        //using a simple brute force\\n        int ans=0;\\n        int a=capacityA;\\n        int b=capacityB;\\n        int i=0;\\n        int j=plants.size()-1;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n              if(a>=b)\\n              {\\n                  ans+=a<plants[i];\\n                  i++;\\n              }\\n                else\\n                {\\n                    ans+=b<plants[j];\\n                    j--;\\n                }\\n            }\\n            else\\n            {\\n                if(a<plants[i])\\n                {\\n                    a=capacityA;\\n                    ans++;\\n                }\\n                    a=a-plants[i];\\n                    i++;\\n                \\n                if(b<plants[j])\\n                {\\n                    b=capacityB;\\n                    ans++;\\n                }\\n                    b=b-plants[j];\\n                    j--;\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624628,
                "title": "simple-python-solution-easy-to-understand-2-pointers",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        capA = capacityA\\n        capB = capacityB\\n        \\n        start = 0\\n        end = len(plants)-1\\n        ref = 0\\n        while start < end:\\n            if plants[start]  <= capA:\\n                capA -= plants[start]\\n            else:\\n                capA = capacityA - plants[start]\\n                ref += 1\\n            \\n            if plants[end] <= capB:\\n                capB -= plants[end]\\n            else:\\n                capB = capacityB - plants[end]\\n                ref += 1\\n                \\n            start += 1\\n            end -= 1\\n        if len(plants)%2 != 0:\\n            if capA > capB:\\n                capA -= plants[start]\\n            elif capB > capA:\\n                capB -= plants[start]\\n            elif capA == capB:\\n                capA -= plants[start]\\n\\n            if capA < 0:\\n                ref += 1\\n            elif capB < 0:\\n                ref += 1\\n            \\n        return ref\\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        capA = capacityA\\n        capB = capacityB\\n        \\n        start = 0\\n        end = len(plants)-1\\n        ref = 0\\n        while start < end:\\n            if plants[start]  <= capA:\\n                capA -= plants[start]\\n            else:\\n                capA = capacityA - plants[start]\\n                ref += 1\\n            \\n            if plants[end] <= capB:\\n                capB -= plants[end]\\n            else:\\n                capB = capacityB - plants[end]\\n                ref += 1\\n                \\n            start += 1\\n            end -= 1\\n        if len(plants)%2 != 0:\\n            if capA > capB:\\n                capA -= plants[start]\\n            elif capB > capA:\\n                capB -= plants[start]\\n            elif capA == capB:\\n                capA -= plants[start]\\n\\n            if capA < 0:\\n                ref += 1\\n            elif capB < 0:\\n                ref += 1\\n            \\n        return ref\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624627,
                "title": "java-two-pointers-simulation-o-n-time-and-o-1-space-solution",
                "content": "```java\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int refill = 0; \\n        int i = 0, j = plants.length-1; \\n        int a = capacityA, b = capacityB;\\n        \\n        while(i <= j) {\\n            if (i == j) {\\n                if (plants[i] > Math.max(a, b)) {\\n                    refill++;\\n                }\\n                break;\\n            } else {\\n                if (a < plants[i]) {\\n                    refill++; \\n                    a = capacityA;\\n                }\\n                a -= plants[i]; \\n                if (b < plants[j]) {\\n                    refill++;\\n                    b = capacityB;\\n                }\\n                b -= plants[j];\\n                \\n                i++;\\n                j--;\\n            }\\n        }\\n        \\n        return refill;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int refill = 0; \\n        int i = 0, j = plants.length-1; \\n        int a = capacityA, b = capacityB;\\n        \\n        while(i <= j) {\\n            if (i == j) {\\n                if (plants[i] > Math.max(a, b)) {\\n                    refill++;\\n                }\\n                break;\\n            } else {\\n                if (a < plants[i]) {\\n                    refill++; \\n                    a = capacityA;\\n                }\\n                a -= plants[i]; \\n                if (b < plants[j]) {\\n                    refill++;\\n                    b = capacityB;\\n                }\\n                b -= plants[j];\\n                \\n                i++;\\n                j--;\\n            }\\n        }\\n        \\n        return refill;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624613,
                "title": "c-fun-with-lambda-functions",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minimumRefill(std::vector<int>& plants, int capacityA, int capacityB) {\\n\\t\\tauto const n = static_cast<int>(std::size(plants));\\n\\t\\tauto const k = n / 2;\\n\\n\\t\\t// Lambda function returning another lambda function\\n\\t\\tauto lambda = [](auto& remains, auto capacity) {\\n\\t\\t\\treturn [&remains, capacity](auto accu, auto plant) {\\n\\t\\t\\t\\tif (plant > remains) {\\n\\t\\t\\t\\t\\tremains = capacity;\\n\\t\\t\\t\\t\\t++accu;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tremains -= plant;\\n\\t\\t\\t\\treturn accu;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Do the front half\\n\\t\\tauto remainsA = capacityA;\\n\\t\\tauto result = std::accumulate(std::cbegin(plants), std::next(std::cbegin(plants), k), 0, lambda(remainsA, capacityA));\\n\\n\\t\\t// Do the back half\\n\\t\\tauto remainsB = capacityB;\\n\\t\\tresult += std::accumulate(std::crbegin(plants), std::next(std::crbegin(plants), k), 0, lambda(remainsB, capacityB));\\n\\n\\t\\t// Handle the middle plant if necessary\\n\\t\\tif (n % 2 != 0) {\\n\\t\\t\\tauto plant = *std::next(std::cbegin(plants), k);\\n\\t\\t\\tif (plant > std::max(remainsA, remainsB)) { ++result; }\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumRefill(std::vector<int>& plants, int capacityA, int capacityB) {\\n\\t\\tauto const n = static_cast<int>(std::size(plants));\\n\\t\\tauto const k = n / 2;\\n\\n\\t\\t// Lambda function returning another lambda function\\n\\t\\tauto lambda = [](auto& remains, auto capacity) {\\n\\t\\t\\treturn [&remains, capacity](auto accu, auto plant) {\\n\\t\\t\\t\\tif (plant > remains) {\\n\\t\\t\\t\\t\\tremains = capacity;\\n\\t\\t\\t\\t\\t++accu;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tremains -= plant;\\n\\t\\t\\t\\treturn accu;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Do the front half\\n\\t\\tauto remainsA = capacityA;\\n\\t\\tauto result = std::accumulate(std::cbegin(plants), std::next(std::cbegin(plants), k), 0, lambda(remainsA, capacityA));\\n\\n\\t\\t// Do the back half\\n\\t\\tauto remainsB = capacityB;\\n\\t\\tresult += std::accumulate(std::crbegin(plants), std::next(std::crbegin(plants), k), 0, lambda(remainsB, capacityB));\\n\\n\\t\\t// Handle the middle plant if necessary\\n\\t\\tif (n % 2 != 0) {\\n\\t\\t\\tauto plant = *std::next(std::cbegin(plants), k);\\n\\t\\t\\tif (plant > std::max(remainsA, remainsB)) { ++result; }\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624599,
                "title": "c-simple-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int l=0,r=p.size()-1,a=ca,b=cb;\\n        int res=0;\\n        while(l<=r){\\n            if(l==r){\\n                if(ca>=p[l] && a>=p[l] && a>=b)\\n                    l++;\\n                else if(cb>=p[r] && b>=p[r] && b>=a)\\n                    r--;\\n                else{\\n                    res++;\\n                    a=ca;\\n                    b=cb;\\n                    l++;r--;\\n                }\\n            }else{\\n                if(ca>=p[l]){\\n                    if(a>=p[l]){\\n                        a-=p[l];\\n                    }else{\\n                        res++;\\n                        a=ca;\\n                        a-=p[l];\\n                    }\\n                    l++;\\n                }\\n                if(cb>=p[r]){\\n                    if(b>=p[r])\\n                        b-=p[r];\\n                    else{\\n                        res++;\\n                        b=cb;\\n                        b-=p[r];\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int l=0,r=p.size()-1,a=ca,b=cb;\\n        int res=0;\\n        while(l<=r){\\n            if(l==r){\\n                if(ca>=p[l] && a>=p[l] && a>=b)\\n                    l++;\\n                else if(cb>=p[r] && b>=p[r] && b>=a)\\n                    r--;\\n                else{\\n                    res++;\\n                    a=ca;\\n                    b=cb;\\n                    l++;r--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1624587,
                "title": "java-solution-two-pointer-o-n-100-faster",
                "content": "```\\npublic int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        \\n        int currentA = capacityA, currentB = capacityB;\\n        \\n        int i=0,j=plants.length-1;\\n        int count = 0;\\n        \\n        while(i<=j){\\n            if(i==j){\\n                if(currentA>=currentB){\\n                    if(currentA<plants[i]){\\n                        count++;\\n                        currentA=capacityA;\\n                    }\\n                    currentA-=plants[i];\\n                }else{\\n                    if(currentB<plants[j]){\\n                        count++;\\n                        currentB=capacityB;\\n                    }\\n                    currentB-=plants[j];\\n                }\\n            }else{\\n                if(currentA<plants[i]){\\n                        count++;\\n                        currentA=capacityA;\\n                }\\n                currentA-=plants[i];\\n                \\n                if(currentB<plants[j]){\\n                        count++;\\n                        currentB=capacityB;\\n                }\\n                currentB-=plants[j];\\n            }\\n            i++;j--;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        \\n        int currentA = capacityA, currentB = capacityB;\\n        \\n        int i=0,j=plants.length-1;\\n        int count = 0;\\n        \\n        while(i<=j){\\n            if(i==j){\\n                if(currentA>=currentB){\\n                    if(currentA<plants[i]){\\n                        count++;\\n                        currentA=capacityA;\\n                    }\\n                    currentA-=plants[i];\\n                }else{\\n                    if(currentB<plants[j]){\\n                        count++;\\n                        currentB=capacityB;\\n                    }\\n                    currentB-=plants[j];\\n                }\\n            }else{\\n                if(currentA<plants[i]){\\n                        count++;\\n                        currentA=capacityA;\\n                }\\n                currentA-=plants[i];\\n                \\n                if(currentB<plants[j]){\\n                        count++;\\n                        currentB=capacityB;\\n                }\\n                currentB-=plants[j];\\n            }\\n            i++;j--;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624544,
                "title": "python3-explained-like-i-m-5-d",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        n = len(plants)\\n        # they travel till midpoint\\n        steps = n//2\\n        \\n        # number of refills for alice and bob each\\n        refilla, refillb = 0, 0\\n        # amount of water in each can left\\n        lefta, leftb = capacityA, capacityB\\n        \\n        for i in range(steps):\\n            # if alice does not have enough water, refill\\n            if plants[i] > lefta:\\n                lefta = capacityA - plants[i]\\n                refilla += 1\\n            # alice has enough\\n            else:\\n                lefta -= plants[i]\\n            # if bob does not have enough water, refill\\n            if plants[n-1-i] > leftb:\\n                leftb = capacityB - plants[n-1-i]\\n                refillb += 1\\n            # bob has enough\\n            else: \\n                leftb -= plants[n-1-i]\\n        \\n        # if array is odd sized, need to handle the middle plant\\n        if len(plants) % 2 == 1:\\n            middlewater = plants[steps]\\n            # if bob has more\\n            if leftb > lefta:\\n                # Bob fills\\n                if leftb < middlewater:\\n                    refillb += 1\\n            # if alice has more or both have equal\\n            else:\\n                # Alice fills\\n                if lefta < middlewater:\\n                    refilla += 1\\n\\n        return refilla + refillb\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        n = len(plants)\\n        # they travel till midpoint\\n        steps = n//2\\n        \\n        # number of refills for alice and bob each\\n        refilla, refillb = 0, 0\\n        # amount of water in each can left\\n        lefta, leftb = capacityA, capacityB\\n        \\n        for i in range(steps):\\n            # if alice does not have enough water, refill\\n            if plants[i] > lefta:\\n                lefta = capacityA - plants[i]\\n                refilla += 1\\n            # alice has enough\\n            else:\\n                lefta -= plants[i]\\n            # if bob does not have enough water, refill\\n            if plants[n-1-i] > leftb:\\n                leftb = capacityB - plants[n-1-i]\\n                refillb += 1\\n            # bob has enough\\n            else: \\n                leftb -= plants[n-1-i]\\n        \\n        # if array is odd sized, need to handle the middle plant\\n        if len(plants) % 2 == 1:\\n            middlewater = plants[steps]\\n            # if bob has more\\n            if leftb > lefta:\\n                # Bob fills\\n                if leftb < middlewater:\\n                    refillb += 1\\n            # if alice has more or both have equal\\n            else:\\n                # Alice fills\\n                if lefta < middlewater:\\n                    refilla += 1\\n\\n        return refilla + refillb\\n",
                "codeTag": "Java"
            },
            {
                "id": 1624384,
                "title": "c-two-pointers-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int A, int B) {\\n        \\n      int x=A,y=B;\\n      int n=plants.size();\\n      int i=0,j=n-1;\\n      int c=0;\\n      \\n      while(i<=j){\\n        if(i==j){\\n            if(A< plants[i] && B < plants[i])\\n                c++;\\n            }\\n        else{\\n          \\n          if(A < plants[i]){\\n            A=x;\\n            c++;\\n            A=A-plants[i];\\n          }\\n          else if(A>= plants[i]){\\n            A=A-plants[i];\\n          }  \\n          if(B < plants[j]){\\n            B=y;\\n            c++;\\n            B=B-plants[j];\\n          }\\n          else if(B >= plants[j]){\\n            B=B-plants[j];\\n          }\\n        }\\n         i++;\\n         j--;\\n        \\n      }\\n      return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int A, int B) {\\n        \\n      int x=A,y=B;\\n      int n=plants.size();\\n      int i=0,j=n-1;\\n      int c=0;\\n      \\n      while(i<=j){\\n        if(i==j){\\n            if(A< plants[i] && B < plants[i])\\n                c++;\\n            }\\n        else{\\n          \\n          if(A < plants[i]){\\n            A=x;\\n            c++;\\n            A=A-plants[i];\\n          }\\n          else if(A>= plants[i]){\\n            A=A-plants[i];\\n          }  \\n          if(B < plants[j]){\\n            B=y;\\n            c++;\\n            B=B-plants[j];\\n          }\\n          else if(B >= plants[j]){\\n            B=B-plants[j];\\n          }\\n        }\\n         i++;\\n         j--;\\n        \\n      }\\n      return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624383,
                "title": "javascript-2105-watering-plants-ii",
                "content": "---\\n\\n- Weekly Contest 271 - https://leetcode.com/contest/weekly-contest-271/ranking/83/\\n  - Q1 answer\\n    - https://leetcode.com/problems/rings-and-rods/discuss/1624271/JavaScript-2103.-Rings-and-Rods\\n  - Q2 answer\\n    - https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624314/JavaScript-2104.-Sum-of-Subarray-Ranges\\n  - Q3 answer\\n    - https://leetcode.com/problems/watering-plants-ii/discuss/1624383/JavaScript-2105.-Watering-Plants-II\\n    - below\\n  - Q4 answer\\n    - https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/discuss/1626153/JavaScript-2106.-Maximum-Fruits-Harvested-After-at-Most-K-Steps\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar minimumRefill = function (plants, capacityA, capacityB) {\\n    let n = plants.length,\\n        mid = Math.trunc(n / 2),\\n        remainA = capacityA, // remaining\\n        remainB = capacityB,\\n        refills = 0;\\n    for (let i = 0; i < mid; i++) {\\n        if (remainA < plants[i])           (remainA = capacityA), refills++;\\n        if (remainB < plants[n - 1 - i])   (remainB = capacityB), refills++;\\n        remainA -= plants[i];\\n        remainB -= plants[n - 1 - i];\\n    }\\n    return refills + (n % 2 && plants[mid] > Math.max(remainA, remainB));\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRefill = function (plants, capacityA, capacityB) {\\n    let n = plants.length,\\n        mid = Math.trunc(n / 2),\\n        remainA = capacityA, // remaining\\n        remainB = capacityB,\\n        refills = 0;\\n    for (let i = 0; i < mid; i++) {\\n        if (remainA < plants[i])           (remainA = capacityA), refills++;\\n        if (remainB < plants[n - 1 - i])   (remainB = capacityB), refills++;\\n        remainA -= plants[i];\\n        remainB -= plants[n - 1 - i];\\n    }\\n    return refills + (n % 2 && plants[mid] > Math.max(remainA, remainB));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624371,
                "title": "c-two-pointer-implementation",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION**\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumRefill(vector<int>& p, int cA, int cB) {\\n        int n=p.size();\\n        int steps=0;\\n        int i=0,j=n-1;\\n        int ta=cA,tb=cB;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n               if(cA>=p[i]||cB>=p[i])break;\\n                else\\n                {\\n                    steps++;\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                if(cA>=p[i])\\n                {\\n                    cA-=p[i];\\n                    i++;\\n                }\\n                else\\n                {\\n                    cA=ta-p[i];\\n                    if(cA>=0)\\n                    {\\n                      steps++;\\n                        i++;\\n                    }\\n                }\\n                \\n                if(cB>=p[j])\\n                {\\n                    cB-=p[j];\\n                    j--;\\n                }\\n                else\\n                {\\n                    cB=tb-p[j];\\n                    if(cB>=0)\\n                    {\\n                      steps++;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return steps;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minimumRefill(vector<int>& p, int cA, int cB) {\\n        int n=p.size();\\n        int steps=0;\\n        int i=0,j=n-1;\\n        int ta=cA,tb=cB;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n               if(cA>=p[i]||cB>=p[i])break;\\n                else\\n                {\\n                    steps++;\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                if(cA>=p[i])\\n                {\\n                    cA-=p[i];\\n                    i++;\\n                }\\n                else\\n                {\\n                    cA=ta-p[i];\\n                    if(cA>=0)\\n                    {\\n                      steps++;\\n                        i++;\\n                    }\\n                }\\n                \\n                if(cB>=p[j])\\n                {\\n                    cB-=p[j];\\n                    j--;\\n                }\\n                else\\n                {\\n                    cB=tb-p[j];\\n                    if(cB>=0)\\n                    {\\n                      steps++;\\n                        j--;\\n                    }\\n                }\\n            }\\n        }\\n        return steps;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624324,
                "title": "python-solution-two-pointers-o-n-solution",
                "content": "\\n**Time: O(N)**, **Space: O(1)**\\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        alice,bob = 0,len(plants)-1\\n        result,capacity_A,capacity_B = 0,capacityA,capacityB\\n        while alice < bob:\\n            if capacity_A < plants[alice]:\\n                capacity_A = capacityA\\n                result += 1\\n            capacity_A -= plants[alice]\\n            if capacity_B < plants[bob]:\\n                capacity_B = capacityB\\n                result += 1\\n            capacity_B -= plants[bob]\\n            alice += 1\\n            bob -= 1\\n        if alice == bob:\\n            max_capacity = max(capacity_A,capacity_B)\\n            if max_capacity < plants[alice]: result += 1\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        alice,bob = 0,len(plants)-1\\n        result,capacity_A,capacity_B = 0,capacityA,capacityB\\n        while alice < bob:\\n            if capacity_A < plants[alice]:\\n                capacity_A = capacityA\\n                result += 1\\n            capacity_A -= plants[alice]\\n            if capacity_B < plants[bob]:\\n                capacity_B = capacityB\\n                result += 1\\n            capacity_B -= plants[bob]\\n            alice += 1\\n            bob -= 1\\n        if alice == bob:\\n            max_capacity = max(capacity_A,capacity_B)\\n            if max_capacity < plants[alice]: result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624310,
                "title": "python3-simulation",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        a=0\\n        b=len(plants)-1\\n        waterA=capacityA\\n        waterB=capacityB\\n        refills=0\\n        while a<b:\\n            if waterA<plants[a]:\\n                waterA=capacityA\\n                refills+=1\\n            waterA-=plants[a]\\n            a+=1\\n            if a<=b and waterB<plants[b]:\\n                waterB=capacityB\\n                refills+=1\\n            waterB-=plants[b]\\n            b-=1\\n        if a==b:\\n            refills+=plants[a]>max(waterA,waterB)\\n        return refills\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        a=0\\n        b=len(plants)-1\\n        waterA=capacityA\\n        waterB=capacityB\\n        refills=0\\n        while a<b:\\n            if waterA<plants[a]:\\n                waterA=capacityA\\n                refills+=1\\n            waterA-=plants[a]\\n            a+=1\\n            if a<=b and waterB<plants[b]:\\n                waterB=capacityB\\n                refills+=1\\n            waterB-=plants[b]\\n            b-=1\\n        if a==b:\\n            refills+=plants[a]>max(waterA,waterB)\\n        return refills\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624295,
                "title": "c-o-n-simple-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& a, int ca, int cb) {\\n        int n = a.size();\\n        int i = 0;\\n        int j = n-1;\\n        int c = 0 ;\\n        int ica = ca;\\n        int icb = cb;\\n        while(i<=j){\\n            if(i==j){\\n                if(ca>cb){\\n                    if(ca<a[i]){\\n                        c++;\\n                    }\\n                }else{\\n                    if(cb<a[j]){\\n                        c++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            \\n            \\n            if(ca<a[i]){\\n                ca = ica;\\n                c++;\\n            }\\n            ca=ca-a[i];\\n            if(cb<a[j]){\\n                c++;\\n                cb=icb;\\n            }\\n            cb=cb-a[j];\\n            i++;\\n            j--;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& a, int ca, int cb) {\\n        int n = a.size();\\n        int i = 0;\\n        int j = n-1;\\n        int c = 0 ;\\n        int ica = ca;\\n        int icb = cb;\\n        while(i<=j){\\n            if(i==j){\\n                if(ca>cb){\\n                    if(ca<a[i]){\\n                        c++;\\n                    }\\n                }else{\\n                    if(cb<a[j]){\\n                        c++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n                continue;\\n            }\\n            \\n            \\n            if(ca<a[i]){\\n                ca = ica;\\n                c++;\\n            }\\n            ca=ca-a[i];\\n            if(cb<a[j]){\\n                c++;\\n                cb=icb;\\n            }\\n            cb=cb-a[j];\\n            i++;\\n            j--;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624245,
                "title": "java-easy-o-n-two-pointer",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int cA = capacityA;\\n        int cB = capacityB;\\n        int a=0;\\n        int b=plants.length-1;\\n        int refill = 0;\\n        while(a < b){\\n            if(cA >= plants[a]){\\n                cA -= plants[a];\\n            }else {\\n                refill++;  //increment count when can is less than plant[i]\\n                cA = capacityA-plants[a];\\n            }\\n            a++;\\n            if(cB >= plants[b]){\\n                cB -= plants[b];\\n            }else {\\n                refill++; //increment count when can is less than plant[i]\\n                cB = capacityB-plants[b];\\n            }\\n            b--;\\n        }\\n        if(a == b){\\n            if(cB > cA){\\n                if(plants[a] > cB)\\n                    refill++; //increment for last plant\\n            }else if(plants[a] > cA){\\n                refill++;  //increment for last plant\\n            }\\n        }\\n        return refill;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int cA = capacityA;\\n        int cB = capacityB;\\n        int a=0;\\n        int b=plants.length-1;\\n        int refill = 0;\\n        while(a < b){\\n            if(cA >= plants[a]){\\n                cA -= plants[a];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1624219,
                "title": "c-two-pointer-with-explanation",
                "content": "**Explanation:-**\\n1. This is a **two pointer problem** \\n2. Start watering the plants as said from both the ends ,when there is ```insufficient water then refill the can```.\\n3. If we have even number of plants then ```alice and bob will water equal number of plants(n/2)```.\\n4. If we have odd number of plants then for middle plant check if either of them can water it, if not then just ```increase the answer (we only care about refilling, we don\\'t care who will water the plant)```\\n\\n**Time Complexity:-** O(n)\\n**Space Complexity:-** O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int l=0,r=p.size()-1,a=ca,b=cb,ans=0;\\n        while(l<r){\\n            // insufficient water the refill\\n             if(ca<p[l]){\\n                ca=a;\\n                ans++;\\n            } \\n            if(cb<p[r]){\\n                cb=b;\\n                ans++;\\n            }\\n            ca-=p[l]; \\n            cb-=p[r];\\n            l++;r--;\\n        }\\n        // only happen when we have odd number of plants\\n        if(l==r)\\n         if(max(ca,cb)<p[l]) // deciding if either of them have to refill the container\\n             ans++;\\n        return ans;   \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```insufficient water then refill the can```\n```alice and bob will water equal number of plants(n/2)```\n```increase the answer (we only care about refilling, we don\\'t care who will water the plant)```\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int l=0,r=p.size()-1,a=ca,b=cb,ans=0;\\n        while(l<r){\\n            // insufficient water the refill\\n             if(ca<p[l]){\\n                ca=a;\\n                ans++;\\n            } \\n            if(cb<p[r]){\\n                cb=b;\\n                ans++;\\n            }\\n            ca-=p[l]; \\n            cb-=p[r];\\n            l++;r--;\\n        }\\n        // only happen when we have odd number of plants\\n        if(l==r)\\n         if(max(ca,cb)<p[l]) // deciding if either of them have to refill the container\\n             ans++;\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061801,
                "title": "python-easy-sol",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], ca: int, cb: int) -> int:\\n        a,b=0,len(plants)-1\\n        alice,bob=ca,cb\\n        res=0\\n        while a<=b:\\n            if a==b:\\n                if alice>=bob:\\n                    if alice<plants[a]:\\n                        res+=1\\n                    return res\\n                else:\\n                    if bob<plants[b]:\\n                        res+=1\\n                    return res\\n            if plants[a]>alice:\\n                alice=ca\\n                res+=1\\n            if plants[b]>bob:\\n                bob=cb\\n                res+=1\\n            alice-=plants[a]\\n            bob-=plants[b]\\n            a+=1\\n            b-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], ca: int, cb: int) -> int:\\n        a,b=0,len(plants)-1\\n        alice,bob=ca,cb\\n        res=0\\n        while a<=b:\\n            if a==b:\\n                if alice>=bob:\\n                    if alice<plants[a]:\\n                        res+=1\\n                    return res\\n                else:\\n                    if bob<plants[b]:\\n                        res+=1\\n                    return res\\n            if plants[a]>alice:\\n                alice=ca\\n                res+=1\\n            if plants[b]>bob:\\n                bob=cb\\n                res+=1\\n            alice-=plants[a]\\n            bob-=plants[b]\\n            a+=1\\n            b-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057309,
                "title": "brutee",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint refil=0;\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int a=0;\\n        int b=(n-1);\\n        int A=capacityA;\\n        int B=capacityB;\\n        for(;a<=b;){\\n            if(a==b){\\n                if(capacityA>capacityB){\\n                    if(capacityA<plants[a]){\\n                        refil++;\\n                        capacityA=A;\\n                    }\\n                     capacityA-=plants[a];\\n                     a++;\\n                     continue;\\n                }\\n                else if(capacityA<capacityB){\\n                    if(capacityB<plants[b]){\\n                        refil++;\\n                        capacityB=B;\\n                    }\\n                     capacityB-=plants[b];\\n                     b--;\\n                     continue;\\n                }\\n                else{\\n                    if(capacityA<plants[a]){\\n                        refil++;\\n                        capacityA=A;\\n                    }\\n                     capacityA-=plants[a];\\n                     a++;\\n                     continue;\\n                }\\n           }\\n           if(capacityA<plants[a]){\\n               refil++;\\n               capacityA=A;\\n           }\\n           if(capacityB<plants[b]){\\n               refil++;\\n               capacityB=B;\\n           }\\n           capacityA-=plants[a];\\n           capacityB-=plants[b];\\n           a++;\\n           b--;\\n           \\n\\n        }\\n        return refil;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint refil=0;\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n=plants.size();\\n        int a=0;\\n        int b=(n-1);\\n        int A=capacityA;\\n        int B=capacityB;\\n        for(;a<=b;){\\n            if(a==b){\\n                if(capacityA>capacityB){\\n                    if(capacityA<plants[a]){\\n                        refil++;\\n                        capacityA=A;\\n                    }\\n                     capacityA-=plants[a];\\n                     a++;\\n                     continue;\\n                }\\n                else if(capacityA<capacityB){\\n                    if(capacityB<plants[b]){\\n                        refil++;\\n                        capacityB=B;\\n                    }\\n                     capacityB-=plants[b];\\n                     b--;\\n                     continue;\\n                }\\n                else{\\n                    if(capacityA<plants[a]){\\n                        refil++;\\n                        capacityA=A;\\n                    }\\n                     capacityA-=plants[a];\\n                     a++;\\n                     continue;\\n                }\\n           }\\n           if(capacityA<plants[a]){\\n               refil++;\\n               capacityA=A;\\n           }\\n           if(capacityB<plants[b]){\\n               refil++;\\n               capacityB=B;\\n           }\\n           capacityA-=plants[a];\\n           capacityB-=plants[b];\\n           a++;\\n           b--;\\n           \\n\\n        }\\n        return refil;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040752,
                "title": "easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int count = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        int start = 0;\\n        int end = plants.length-1;\\n        while(start<end){\\n            if(plants[start]>capacityA){\\n                count++;\\n                capacityA=capA;\\n            }\\n            if(plants[end]>capacityB){\\n                count++;\\n                capacityB=capB;\\n            }\\n            capacityA-=plants[start];\\n            capacityB-=plants[end];\\n            start++;\\n            end--;\\n            if(start==end&&plants.length%2==1){\\n                if(Math.max(capacityA,capacityB)<plants[start]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int count = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n        int start = 0;\\n        int end = plants.length-1;\\n        while(start<end){\\n            if(plants[start]>capacityA){\\n                count++;\\n                capacityA=capA;\\n            }\\n            if(plants[end]>capacityB){\\n                count++;\\n                capacityB=capB;\\n            }\\n            capacityA-=plants[start];\\n            capacityB-=plants[end];\\n            start++;\\n            end--;\\n            if(start==end&&plants.length%2==1){\\n                if(Math.max(capacityA,capacityB)<plants[start]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994229,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n    int ans = 0;\\n    int i = 0;\\n    int j = plants.size() - 1;\\n    int canA = capacityA;\\n    int canB = capacityB;\\n\\n    while (i < j) {\\n      ans += (canA < plants[i]) + (canB < plants[j]);\\n      if (canA < plants[i])\\n        canA = capacityA;\\n      if (canB < plants[j])\\n        canB = capacityB;\\n      canA -= plants[i++];\\n      canB -= plants[j--];\\n    }\\n\\n    return ans + (i == j && max(canA, canB) < plants[i]);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n    int ans = 0;\\n    int i = 0;\\n    int j = plants.size() - 1;\\n    int canA = capacityA;\\n    int canB = capacityB;\\n\\n    while (i < j) {\\n      ans += (canA < plants[i]) + (canB < plants[j]);\\n      if (canA < plants[i])\\n        canA = capacityA;\\n      if (canB < plants[j])\\n        canB = capacityB;\\n      canA -= plants[i++];\\n      canB -= plants[j--];\\n    }\\n\\n    return ans + (i == j && max(canA, canB) < plants[i]);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970955,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,ans=0,c=0;\\n        int A=capacityA,B=capacityB;\\n        while(i<=j){\\n            ans=i;\\n            if(i!=j){\\n            if(A>=plants[i]){\\n                A-=plants[i];\\n            }\\n            else if(A<plants[i]){\\n                c++;\\n                A=capacityA;\\n                A=A-plants[i];\\n            }\\n            if(B>=plants[j]){\\n                B-=plants[j];\\n            }\\n            else if(B<plants[j]){\\n                c++;\\n                B=capacityB;\\n                B-=plants[j];\\n            }\\n            }\\n            else if(i==j){\\n                if(A==B){\\n                    if(A<plants[i])\\n                    c++;\\n                }\\n                else{\\n                    if(A>B){\\n                        if(A<plants[i])\\n                        c++;\\n                    }\\n                    else{\\n                        if(B<plants[i])\\n                        c++;\\n                    }\\n                }\\n            }\\n            i++;j--;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,ans=0,c=0;\\n        int A=capacityA,B=capacityB;\\n        while(i<=j){\\n            ans=i;\\n            if(i!=j){\\n            if(A>=plants[i]){\\n                A-=plants[i];\\n            }\\n            else if(A<plants[i]){\\n                c++;\\n                A=capacityA;\\n                A=A-plants[i];\\n            }\\n            if(B>=plants[j]){\\n                B-=plants[j];\\n            }\\n            else if(B<plants[j]){\\n                c++;\\n                B=capacityB;\\n                B-=plants[j];\\n            }\\n            }\\n            else if(i==j){\\n                if(A==B){\\n                    if(A<plants[i])\\n                    c++;\\n                }\\n                else{\\n                    if(A>B){\\n                        if(A<plants[i])\\n                        c++;\\n                    }\\n                    else{\\n                        if(B<plants[i])\\n                        c++;\\n                    }\\n                }\\n            }\\n            i++;j--;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951438,
                "title": "python-2-pointers-with-explanation",
                "content": "# Intuition\\nWe know that both Alice and Bob start from both ends and water them at the same time. The only tricky part about this problem is to determine the order of when both alice and bob reach the same plant.\\n\\n# Approach\\nWe generate a separate array to contain True and False values, This is used to check which plants have been watered.\\n\\nAt each iteration, we check for both Alice and Bob if they are able to water the plants and if a refill is required and update the left and right pointers.\\n\\n```python\\nif capacityA >= plants[l] and not watered[l]:\\n    if a < plants[l]:\\n        refills += 1\\n        a = capacityA\\n    a -= plants[l]\\n    watered[l] = True\\nl += 1\\n\\nif capacityB >= plants[r] and not watered[r]:\\n    if b < plants[r]:\\n        refills += 1\\n        b = capacityB\\n    b -= plants[r]\\n    watered[r] = True\\nr -= 1\\n```\\n\\nNote that when Alice and Bob reach the same plant, the person who has the more water will water the plant. For the case of when they have both the same amount of water, it is already covered in this section of the code here:\\n```python\\nif capacityA >= plants[l] and not watered[l]:\\n    if a < plants[l]:\\n        refills += 1\\n        a = capacityA\\n    a -= plants[l]\\n    watered[l] = True\\nl += 1\\n```\\nTherefore we will only need to state the condition where Bob is required to water the plant when he has more water than Alice. Note that for the case when they both do not have enough to water the plants, Alice will first have to refill and water the plant.\\n```python\\nif l == r and b > a and b >= plants[l]:\\n    b -= plants[l]\\n    watered[l] = True\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n\\n        l, r = 0 , len(plants) - 1\\n\\n        refills = 0\\n        a, b = capacityA, capacityB\\n        watered = [False] * len(plants)\\n        while l < len(plants) and r >= 0:\\n            \\n            # if both reach the same plant, determine who to water the plant\\n            if l == r and b > a and b >= plants[l]:\\n                b -= plants[l]\\n                watered[l] = True\\n\\n            if capacityA >= plants[l] and not watered[l]:\\n                if a < plants[l]:\\n                    refills += 1\\n                    a = capacityA\\n                a -= plants[l]\\n                watered[l] = True\\n            l += 1\\n\\n            if capacityB >= plants[r] and not watered[r]:\\n                if b < plants[r]:\\n                    refills += 1\\n                    b = capacityB\\n                b -= plants[r]\\n                watered[r] = True\\n            r -= 1\\n\\n        return refills\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python\\nif capacityA >= plants[l] and not watered[l]:\\n    if a < plants[l]:\\n        refills += 1\\n        a = capacityA\\n    a -= plants[l]\\n    watered[l] = True\\nl += 1\\n\\nif capacityB >= plants[r] and not watered[r]:\\n    if b < plants[r]:\\n        refills += 1\\n        b = capacityB\\n    b -= plants[r]\\n    watered[r] = True\\nr -= 1\\n```\n```python\\nif capacityA >= plants[l] and not watered[l]:\\n    if a < plants[l]:\\n        refills += 1\\n        a = capacityA\\n    a -= plants[l]\\n    watered[l] = True\\nl += 1\\n```\n```python\\nif l == r and b > a and b >= plants[l]:\\n    b -= plants[l]\\n    watered[l] = True\\n```\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n\\n        l, r = 0 , len(plants) - 1\\n\\n        refills = 0\\n        a, b = capacityA, capacityB\\n        watered = [False] * len(plants)\\n        while l < len(plants) and r >= 0:\\n            \\n            # if both reach the same plant, determine who to water the plant\\n            if l == r and b > a and b >= plants[l]:\\n                b -= plants[l]\\n                watered[l] = True\\n\\n            if capacityA >= plants[l] and not watered[l]:\\n                if a < plants[l]:\\n                    refills += 1\\n                    a = capacityA\\n                a -= plants[l]\\n                watered[l] = True\\n            l += 1\\n\\n            if capacityB >= plants[r] and not watered[r]:\\n                if b < plants[r]:\\n                    refills += 1\\n                    b = capacityB\\n                b -= plants[r]\\n                watered[r] = True\\n            r -= 1\\n\\n        return refills\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940809,
                "title": "c-more-readable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, const int capacityA, const int capacityB) {\\n        int alice = 0;\\n        int bob = (int)plants.size() - 1;\\n        int refills = 0;\\n        int curA = capacityA;\\n        int curB = capacityB;\\n\\n        for (; alice <= bob; alice ++, bob --) {\\n            if (alice == bob) {\\n                const int required = plants[alice];\\n                if (curA >= curB) {\\n                     DoWater(refills, curA, required, capacityA);\\n                } else {\\n                    DoWater(refills, curB, required, capacityB);\\n                }\\n            } else {\\n                DoWater(refills, curA, plants[alice], capacityA);\\n                DoWater(refills, curB, plants[bob], capacityB);\\n            }\\n        }\\n        return refills;\\n    }\\n\\nprivate:\\n    void DoWater(int& refills, int& curWater, const int required, const int capacity) {\\n        if (curWater < required) {\\n            refills ++;\\n            curWater = capacity;\\n        }\\n        curWater -= required;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, const int capacityA, const int capacityB) {\\n        int alice = 0;\\n        int bob = (int)plants.size() - 1;\\n        int refills = 0;\\n        int curA = capacityA;\\n        int curB = capacityB;\\n\\n        for (; alice <= bob; alice ++, bob --) {\\n            if (alice == bob) {\\n                const int required = plants[alice];\\n                if (curA >= curB) {\\n                     DoWater(refills, curA, required, capacityA);\\n                } else {\\n                    DoWater(refills, curB, required, capacityB);\\n                }\\n            } else {\\n                DoWater(refills, curA, plants[alice], capacityA);\\n                DoWater(refills, curB, plants[bob], capacityB);\\n            }\\n        }\\n        return refills;\\n    }\\n\\nprivate:\\n    void DoWater(int& refills, int& curWater, const int required, const int capacity) {\\n        if (curWater < required) {\\n            refills ++;\\n            curWater = capacity;\\n        }\\n        curWater -= required;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869702,
                "title": "rust-doubleendediterator",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        let mut a_cap = capacity_a;\\n        let mut b_cap = capacity_b;\\n        let mut plant_iter = plants.iter().peekable();\\n        let mut bob_plant = plant_iter.next_back();\\n        let mut refills = 0;\\n\\n        while let Some(alice_plant) = plant_iter.next() {\\n            //alice needs a refill\\n            if alice_plant > &a_cap {\\n                a_cap = capacity_a;\\n                a_cap -= alice_plant;\\n                refills += 1;\\n            }\\n            //no refill needed\\n            else {a_cap -= alice_plant}\\n            \\n            if let Some(bob_plant) = bob_plant{\\n                //bob needs a refill\\n                if bob_plant > &b_cap{\\n                    b_cap = capacity_b;\\n                    b_cap -= bob_plant;\\n                    refills += 1;\\n                }\\n                //no refill needed\\n                else {b_cap -= bob_plant};\\n            }\\n\\n            bob_plant = plant_iter.next_back();\\n            //check if alice and bob are at the same plant\\n            if(plant_iter.peek().is_none()){\\n                if let Some(plant) = bob_plant{\\n                    //if both alice and bob dont have enough water a final refill needed\\n                    if plant > &a_cap && plant >&b_cap {\\n                        refills += 1;\\n                    }\\n                }\\n            }\\n        }\\n        refills\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        let mut a_cap = capacity_a;\\n        let mut b_cap = capacity_b;\\n        let mut plant_iter = plants.iter().peekable();\\n        let mut bob_plant = plant_iter.next_back();\\n        let mut refills = 0;\\n\\n        while let Some(alice_plant) = plant_iter.next() {\\n            //alice needs a refill\\n            if alice_plant > &a_cap {\\n                a_cap = capacity_a;\\n                a_cap -= alice_plant;\\n                refills += 1;\\n            }\\n            //no refill needed\\n            else {a_cap -= alice_plant}\\n            \\n            if let Some(bob_plant) = bob_plant{\\n                //bob needs a refill\\n                if bob_plant > &b_cap{\\n                    b_cap = capacity_b;\\n                    b_cap -= bob_plant;\\n                    refills += 1;\\n                }\\n                //no refill needed\\n                else {b_cap -= bob_plant};\\n            }\\n\\n            bob_plant = plant_iter.next_back();\\n            //check if alice and bob are at the same plant\\n            if(plant_iter.peek().is_none()){\\n                if let Some(plant) = bob_plant{\\n                    //if both alice and bob dont have enough water a final refill needed\\n                    if plant > &a_cap && plant >&b_cap {\\n                        refills += 1;\\n                    }\\n                }\\n            }\\n        }\\n        refills\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818777,
                "title": "o-n-time-complixity-java-solution-beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i = 0;\\n        int j = plants.length-1;\\n        int count = 0;\\n        int nums[] = plants;\\n        int a = capacityA;\\n        int b = capacityB;\\n\\n    L1: while(i <= j) {\\n            if(i == j) {\\n                if(capacityA > capacityB) {\\n                    if(capacityA < nums[i]) count++;\\n\\n                } else if(capacityB > capacityA) {\\n                    if(capacityB < nums[i]) count++;\\n\\n                } else {\\n                     if(capacityA < nums[i]) count++;\\n                }\\n\\n                break L1;\\n            }\\n\\n           if(capacityA < nums[i]) {\\n                count++;\\n                capacityA = a;\\n           }\\n\\n           capacityA -= nums[i++];\\n\\n           if(capacityB < nums[j]) {\\n               capacityB = b;\\n               count++;\\n           }\\n           capacityB -= nums[j--];\\n        }\\n\\n\\n        return count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i = 0;\\n        int j = plants.length-1;\\n        int count = 0;\\n        int nums[] = plants;\\n        int a = capacityA;\\n        int b = capacityB;\\n\\n    L1: while(i <= j) {\\n            if(i == j) {\\n                if(capacityA > capacityB) {\\n                    if(capacityA < nums[i]) count++;\\n\\n                } else if(capacityB > capacityA) {\\n                    if(capacityB < nums[i]) count++;\\n\\n                } else {\\n                     if(capacityA < nums[i]) count++;\\n                }\\n\\n                break L1;\\n            }\\n\\n           if(capacityA < nums[i]) {\\n                count++;\\n                capacityA = a;\\n           }\\n\\n           capacityA -= nums[i++];\\n\\n           if(capacityB < nums[j]) {\\n               capacityB = b;\\n               count++;\\n           }\\n           capacityB -= nums[j--];\\n        }\\n\\n\\n        return count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816432,
                "title": "simple-and-clean-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumRefill(vector<int> &plants, int capacityA, int capacityB)\\n    {\\n        int alice = capacityA, bob = capacityB;\\n        int ans = 0;\\n        int i = 0, j = plants.size() - 1;\\n\\n        while (i < j)\\n        {\\n            if (alice < plants[i])\\n            {\\n                alice = capacityA;\\n                ans++;\\n            }\\n\\n            if (bob < plants[j])\\n            {\\n                bob = capacityB;\\n                ans++;\\n            }\\n\\n            alice -= plants[i];\\n            bob -= plants[j];\\n            i++;\\n            j--;\\n        }\\n\\n        if (i == j)\\n        {\\n            if (alice >= bob)\\n            {\\n                if (alice < plants[i])\\n                    ans++;\\n                return ans;\\n            }\\n\\n            else if (bob < plants[i])\\n                ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumRefill(vector<int> &plants, int capacityA, int capacityB)\\n    {\\n        int alice = capacityA, bob = capacityB;\\n        int ans = 0;\\n        int i = 0, j = plants.size() - 1;\\n\\n        while (i < j)\\n        {\\n            if (alice < plants[i])\\n            {\\n                alice = capacityA;\\n                ans++;\\n            }\\n\\n            if (bob < plants[j])\\n            {\\n                bob = capacityB;\\n                ans++;\\n            }\\n\\n            alice -= plants[i];\\n            bob -= plants[j];\\n            i++;\\n            j--;\\n        }\\n\\n        if (i == j)\\n        {\\n            if (alice >= bob)\\n            {\\n                if (alice < plants[i])\\n                    ans++;\\n                return ans;\\n            }\\n\\n            else if (bob < plants[i])\\n                ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755653,
                "title": "recursion-solution-java-easy-to-understand",
                "content": "\\n# Approach\\n\\n---\\n> Two Pointers + Recursion\\n\\n- Two pointers denoting respective positions of Alice and Bob.\\n\\n- Whenever they run out of water, their cans are refilled with the original water capacity.\\n\\n- Refilling is being tracked and stored in **count**.\\n\\n---\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int count;\\n    public static int cAfull;\\n    public static int cBfull;\\n\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n\\n        count = 0;\\n        cAfull = capacityA;\\n        cBfull = capacityB;\\n\\n        helper(plants, capacityA, capacityB, 0, plants.length-1);\\n\\n        return count;\\n        \\n    }\\n\\n    public static void helper(int plants[], int cA, int cB, int i, int j){\\n\\n// Base Condition\\n\\n        if(i > j){\\n            return;\\n        }\\n\\n// If both of them reach at a single plant position.\\n\\n        if(i == j){\\n            if(cA >= cB && cA < plants[i] || cA < cB && cB < plants[j]){\\n                count++;\\n            }\\n            return;\\n        }\\n\\n// Checking Alice capacity\\n\\n        if(plants[i] > cA){\\n            count++;\\n            cA = cAfull;\\n        }\\n\\n//Checking Bob capacity\\n\\n        if(plants[j] > cB){\\n            count++;\\n            cB = cBfull;\\n        }\\n\\n        cB -= plants[j];\\n        cA -= plants[i];\\n\\n        helper(plants, cA, cB, i+1, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int count;\\n    public static int cAfull;\\n    public static int cBfull;\\n\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n\\n        count = 0;\\n        cAfull = capacityA;\\n        cBfull = capacityB;\\n\\n        helper(plants, capacityA, capacityB, 0, plants.length-1);\\n\\n        return count;\\n        \\n    }\\n\\n    public static void helper(int plants[], int cA, int cB, int i, int j){\\n\\n// Base Condition\\n\\n        if(i > j){\\n            return;\\n        }\\n\\n// If both of them reach at a single plant position.\\n\\n        if(i == j){\\n            if(cA >= cB && cA < plants[i] || cA < cB && cB < plants[j]){\\n                count++;\\n            }\\n            return;\\n        }\\n\\n// Checking Alice capacity\\n\\n        if(plants[i] > cA){\\n            count++;\\n            cA = cAfull;\\n        }\\n\\n//Checking Bob capacity\\n\\n        if(plants[j] > cB){\\n            count++;\\n            cB = cBfull;\\n        }\\n\\n        cB -= plants[j];\\n        cA -= plants[i];\\n\\n        helper(plants, cA, cB, i+1, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704810,
                "title": "my-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& flowers, int capacityA, int capacityB) {\\n        int cnt=0;int k1=capacityA,k2=capacityB;\\n        int n=flowers.size();\\n        for(int i=0;i<n/2;i++){\\nif(flowers[i]<=capacityA){\\n    capacityA-=flowers[i];\\n}else{\\n    capacityA=k1;cnt++;capacityA-=flowers[i];\\n}\\n        }\\n        for(int i=n-1;i>n/2;i--){\\nif(flowers[i]<=capacityB){\\n    capacityB-=flowers[i];\\n}else{\\n    capacityB=k2;cnt++;capacityB-=flowers[i];\\n}\\n        }\\n        if(n%2!=0 && flowers[(n/2)]>capacityA && flowers[(n/2)]>capacityB){\\n            cnt++;\\n        }\\n        else if(n%2==0){\\n            if(flowers[(n/2)]>capacityB){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& flowers, int capacityA, int capacityB) {\\n        int cnt=0;int k1=capacityA,k2=capacityB;\\n        int n=flowers.size();\\n        for(int i=0;i<n/2;i++){\\nif(flowers[i]<=capacityA){\\n    capacityA-=flowers[i];\\n}else{\\n    capacityA=k1;cnt++;capacityA-=flowers[i];\\n}\\n        }\\n        for(int i=n-1;i>n/2;i--){\\nif(flowers[i]<=capacityB){\\n    capacityB-=flowers[i];\\n}else{\\n    capacityB=k2;cnt++;capacityB-=flowers[i];\\n}\\n        }\\n        if(n%2!=0 && flowers[(n/2)]>capacityA && flowers[(n/2)]>capacityB){\\n            cnt++;\\n        }\\n        else if(n%2==0){\\n            if(flowers[(n/2)]>capacityB){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694562,
                "title": "don-t-think-much",
                "content": "# Intuition\\nJust follow the description\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0; int j=plants.length-1; int count=0;\\n        int a = capacityA, b= capacityB;\\n        while(i<j){\\n            if(plants[i]<=a){a=a-plants[i];i++;}\\n            else if(plants[i]>a){a=capacityA;count++;a=a-plants[i];i++;}\\n            if(plants[j]<=b){b=b-plants[j];j--;}\\n            else if(plants[j]>b){b=capacityB;count++;b=b-plants[j];j--;}\\n        }\\n        if(i==j){ if(a>b && a<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a<b && b<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a==b && a<plants[i]){count++;return count++;}}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0; int j=plants.length-1; int count=0;\\n        int a = capacityA, b= capacityB;\\n        while(i<j){\\n            if(plants[i]<=a){a=a-plants[i];i++;}\\n            else if(plants[i]>a){a=capacityA;count++;a=a-plants[i];i++;}\\n            if(plants[j]<=b){b=b-plants[j];j--;}\\n            else if(plants[j]>b){b=capacityB;count++;b=b-plants[j];j--;}\\n        }\\n        if(i==j){ if(a>b && a<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a<b && b<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a==b && a<plants[i]){count++;return count++;}}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658644,
                "title": "watering-plantii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int canA=capacityA, canB=capacityB;\\n        int refillA=0; int refillB=0;\\n        int i=0,j=plants.length-1;\\n\\n        while(i<j){\\n            if(canA<plants[i]){\\n                refillA++;\\n                canA=capacityA;\\n            }\\n            if(canB< plants[j]){\\n                refillB++;\\n                canB=capacityB;\\n            }\\n            canA=canA-plants[i];\\n            canB=canB-plants[j];\\n            i++;\\n            j--;\\n        }\\n        if(i==j){\\n            if(canA<plants[i]&&canB<plants[i]){\\n                refillA++;\\n            }\\n        }\\n        return refillA +refillB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int canA=capacityA, canB=capacityB;\\n        int refillA=0; int refillB=0;\\n        int i=0,j=plants.length-1;\\n\\n        while(i<j){\\n            if(canA<plants[i]){\\n                refillA++;\\n                canA=capacityA;\\n            }\\n            if(canB< plants[j]){\\n                refillB++;\\n                canB=capacityB;\\n            }\\n            canA=canA-plants[i];\\n            canB=canB-plants[j];\\n            i++;\\n            j--;\\n        }\\n        if(i==j){\\n            if(canA<plants[i]&&canB<plants[i]){\\n                refillA++;\\n            }\\n        }\\n        return refillA +refillB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653133,
                "title": "simple-java-simulation-4-ms-beats-100",
                "content": "# Approach\\nWe can simulate this process quite easily. I have a `res` variable to keep track of refills. At the end of every watering, Alice moves right and Bob moves left, so we finish when Bob is to the left of Alice. In the event that Bob and Alice are on the same plant (`ad == bd`), we can pick who to water the plant. Since this is the last plant, we don\\'t really care about updating the remaining water in their cans, just if we need to refill. In every other case (when `ad != bd`), we can simply check refills for Alice and Bob individually. After any necessary refills, we can move Alice (`ad++`) forward and Bob (`bd--`) backward. After all plants have been watered, we can return `res`. God did!\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int res = 0;\\n        int ad = 0, bd = plants.length-1;\\n        int a = capacityA, b = capacityB;\\n        while (ad <= bd) {\\n            if (ad == bd) {\\n                if (a >= b) {\\n                    if (a >= plants[ad]) {\\n                        a -= plants[ad];\\n                    } else {\\n                        res++;\\n                        a = capacityA - plants[ad];\\n                    }\\n                } else {\\n                    if (b >= plants[bd]) {\\n                        b -= plants[bd];\\n                    } else {\\n                        res++;\\n                        b = capacityB - plants[bd];\\n                    }\\n                }\\n            } else {\\n                if (a >= plants[ad]) {\\n                    a -= plants[ad];\\n                } else {\\n                    res++;\\n                    a = capacityA - plants[ad];\\n                }\\n                if (b >= plants[bd]) {\\n                    b -= plants[bd];\\n                } else {\\n                    res++;\\n                    b = capacityB - plants[bd];\\n                }\\n            }\\n            ad++;\\n            bd--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int res = 0;\\n        int ad = 0, bd = plants.length-1;\\n        int a = capacityA, b = capacityB;\\n        while (ad <= bd) {\\n            if (ad == bd) {\\n                if (a >= b) {\\n                    if (a >= plants[ad]) {\\n                        a -= plants[ad];\\n                    } else {\\n                        res++;\\n                        a = capacityA - plants[ad];\\n                    }\\n                } else {\\n                    if (b >= plants[bd]) {\\n                        b -= plants[bd];\\n                    } else {\\n                        res++;\\n                        b = capacityB - plants[bd];\\n                    }\\n                }\\n            } else {\\n                if (a >= plants[ad]) {\\n                    a -= plants[ad];\\n                } else {\\n                    res++;\\n                    a = capacityA - plants[ad];\\n                }\\n                if (b >= plants[bd]) {\\n                    b -= plants[bd];\\n                } else {\\n                    res++;\\n                    b = capacityB - plants[bd];\\n                }\\n            }\\n            ad++;\\n            bd--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626996,
                "title": "simple-solution-for-kotlin-using-two-pointers-time-o-logn-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUses two opinters checking both start and end; \\nstart for alice, end for bob, \\ndecrement alice and bob based on the corresponding value at plants[i], \\ncheck to see if they need to refill during each iteration,\\nhandle each edge case only one plant -> 0,\\nboth meet at same plant -> whoever has more or alice waters,\\ninvalid input throw exception.\\n\\n# Complexity\\n- Time complexity:\\nO (log n)\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    fun minimumRefill(plants: IntArray, capacityA: Int, capacityB: Int): Int {\\n        if(capacityA == 0 || capacityB == 0){\\n            throw Exception(\"Invalid Input\")\\n        }\\n\\n        if(plants.size ==1){\\n            return 0\\n        }\\n\\n        var start =0 \\n        var end = plants.lastIndex\\n        var refill = 0\\n        var alice= capacityA\\n        var bob= capacityB\\n\\n        while(start <= end){\\n            if(start == end){\\n                // bob waters plant as he has more\\n                if(bob > alice) {\\n                    if(bob < plants[end]){\\n                        refill++   \\n                    }  \\n                    return refill\\n                }\\n                // else alice waters as she has more or is equal to bob\\n                if(alice < plants[start]){\\n                    refill++\\n                } \\n                return refill \\n            }\\n\\n            if(alice < plants[start]){\\n                refill++\\n                alice= capacityA\\n            }\\n            alice -= plants[start++]\\n\\n            if(bob < plants[end]){\\n                refill++\\n                bob= capacityB\\n            } \\n            bob -= plants[end--]\\n        }\\n        return refill \\n    }\\n}\\n\\n// ask for example \\n\\n\\n// two pointers \\n// start  end\\n// if can water water else refill then water (increment refill)\\n// move pointers start and end \\n// return refill at end \\n// water is reduce pointer by plants[i]\\n\\n// 5:47\\n\\n// if start == end then capacityA must water it \\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun minimumRefill(plants: IntArray, capacityA: Int, capacityB: Int): Int {\\n        if(capacityA == 0 || capacityB == 0){\\n            throw Exception(\"Invalid Input\")\\n        }\\n\\n        if(plants.size ==1){\\n            return 0\\n        }\\n\\n        var start =0 \\n        var end = plants.lastIndex\\n        var refill = 0\\n        var alice= capacityA\\n        var bob= capacityB\\n\\n        while(start <= end){\\n            if(start == end){\\n                // bob waters plant as he has more\\n                if(bob > alice) {\\n                    if(bob < plants[end]){\\n                        refill++   \\n                    }  \\n                    return refill\\n                }\\n                // else alice waters as she has more or is equal to bob\\n                if(alice < plants[start]){\\n                    refill++\\n                } \\n                return refill \\n            }\\n\\n            if(alice < plants[start]){\\n                refill++\\n                alice= capacityA\\n            }\\n            alice -= plants[start++]\\n\\n            if(bob < plants[end]){\\n                refill++\\n                bob= capacityB\\n            } \\n            bob -= plants[end--]\\n        }\\n        return refill \\n    }\\n}\\n\\n// ask for example \\n\\n\\n// two pointers \\n// start  end\\n// if can water water else refill then water (increment refill)\\n// move pointers start and end \\n// return refill at end \\n// water is reduce pointer by plants[i]\\n\\n// 5:47\\n\\n// if start == end then capacityA must water it \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598437,
                "title": "c-solution-2-pointer-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& arr, int ca, int cb) {\\n        int n = arr.size();\\n        int i = 0;\\n        int j = n-1;\\n\\n        if(n==1) {\\n            return 0;\\n        }\\n\\n        int cur_a = ca;\\n        int cur_b = cb;\\n\\n        int refill = 0;\\n\\n        while(i<j) {\\n            if(arr[i]<=cur_a) {\\n                cur_a = cur_a - arr[i];\\n            } else {\\n                refill++;\\n                cur_a = ca - arr[i];\\n            }\\n            i++;\\n\\n            if(arr[j]<=cur_b) {\\n                cur_b = cur_b - arr[j];\\n            } else {\\n                refill++;\\n                cur_b = cb - arr[j];\\n            }\\n            j--;\\n        }\\n\\n        if(i==j) {\\n            if(cur_a>=cur_b) {\\n                if(arr[i]>cur_a) refill++;\\n            } else {\\n                if(arr[i]>cur_b) refill++;\\n            }\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& arr, int ca, int cb) {\\n        int n = arr.size();\\n        int i = 0;\\n        int j = n-1;\\n\\n        if(n==1) {\\n            return 0;\\n        }\\n\\n        int cur_a = ca;\\n        int cur_b = cb;\\n\\n        int refill = 0;\\n\\n        while(i<j) {\\n            if(arr[i]<=cur_a) {\\n                cur_a = cur_a - arr[i];\\n            } else {\\n                refill++;\\n                cur_a = ca - arr[i];\\n            }\\n            i++;\\n\\n            if(arr[j]<=cur_b) {\\n                cur_b = cur_b - arr[j];\\n            } else {\\n                refill++;\\n                cur_b = cb - arr[j];\\n            }\\n            j--;\\n        }\\n\\n        if(i==j) {\\n            if(cur_a>=cur_b) {\\n                if(arr[i]>cur_a) refill++;\\n            } else {\\n                if(arr[i]>cur_b) refill++;\\n            }\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553943,
                "title": "easy-python-solution-beats-91-30-run-time",
                "content": "# Approach\\nCompute if refill is needed at each plant[i].\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        a = 0\\n        b = len(plants)-1\\n        r = 0\\n        ca, cb = capacityA, capacityB\\n        while a<b:\\n            if ca <  plants[a]:\\n                ca = capacityA\\n                r+=1\\n\\n            if cb <  plants[b]:\\n                cb = capacityB\\n                r+=1\\n\\n            ca -= plants[a]\\n            cb -= plants[b]\\n            \\n            a+=1\\n            b-=1\\n        \\n        if a == b:\\n            if ca >= cb:\\n                if ca <  plants[a]:\\n                    ca = capacityA\\n                    r+=1\\n                ca -= plants[a]\\n            \\n            elif ca < cb:\\n                if cb <  plants[b]:\\n                    cb = capacityB\\n                    r+=1\\n                cb -= plants[b]\\n\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        a = 0\\n        b = len(plants)-1\\n        r = 0\\n        ca, cb = capacityA, capacityB\\n        while a<b:\\n            if ca <  plants[a]:\\n                ca = capacityA\\n                r+=1\\n\\n            if cb <  plants[b]:\\n                cb = capacityB\\n                r+=1\\n\\n            ca -= plants[a]\\n            cb -= plants[b]\\n            \\n            a+=1\\n            b-=1\\n        \\n        if a == b:\\n            if ca >= cb:\\n                if ca <  plants[a]:\\n                    ca = capacityA\\n                    r+=1\\n                ca -= plants[a]\\n            \\n            elif ca < cb:\\n                if cb <  plants[b]:\\n                    cb = capacityB\\n                    r+=1\\n                cb -= plants[b]\\n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545265,
                "title": "two-pointer-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int lo = 0;\\n        int hi = plants.length - 1;\\n        int ans = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n\\n        while (lo < hi) {\\n\\n            if (capA < plants[lo]) {\\n                ans++;\\n                capA = capacityA;\\n            }\\n\\n            if (capB < plants[hi]) {\\n                ans++;\\n                capB = capacityB;\\n            }\\n            capA -= plants[lo++];\\n            capB -= plants[hi--];\\n        }\\n\\n        if (lo == hi) {\\n\\n            if (capA == capB || capA > capB) {\\n\\n                if (capA < plants[lo]) {\\n                    ans++;\\n                }\\n                lo++;\\n            } else {\\n\\n                if (capB < plants[lo]) {\\n                    ans++;\\n                }\\n                hi--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int lo = 0;\\n        int hi = plants.length - 1;\\n        int ans = 0;\\n        int capA = capacityA;\\n        int capB = capacityB;\\n\\n        while (lo < hi) {\\n\\n            if (capA < plants[lo]) {\\n                ans++;\\n                capA = capacityA;\\n            }\\n\\n            if (capB < plants[hi]) {\\n                ans++;\\n                capB = capacityB;\\n            }\\n            capA -= plants[lo++];\\n            capB -= plants[hi--];\\n        }\\n\\n        if (lo == hi) {\\n\\n            if (capA == capB || capA > capB) {\\n\\n                if (capA < plants[lo]) {\\n                    ans++;\\n                }\\n                lo++;\\n            } else {\\n\\n                if (capB < plants[lo]) {\\n                    ans++;\\n                }\\n                hi--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537376,
                "title": "brute-force-beginner-s-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int valA = capacityA , valB = capacityB ;\\n        int n = plants.size() ;\\n        int l = 0 , r = n-1 ;\\n        int countA = 0 , countB = 0;\\n        while(l<r){\\n            if(valA>=plants[l]){\\n                valA -= plants[l] ;\\n            }\\n            else{\\n                countA++ ;\\n                valA = capacityA ;\\n                valA -= plants[l] ;\\n            }\\n            if(valB>=plants[r]){\\n                valB -= plants[r] ;\\n            }\\n            else{\\n                countB++ ;\\n                valB = capacityB ;\\n                valB -= plants[r] ;\\n            }\\n            l++ ;\\n            r-- ;\\n        }\\n        if(n%2 == 1){\\n            if(valA>=plants[l] || valB>=plants[r]){\\n            }\\n            else countA++;\\n        }\\n        return countA + countB ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int valA = capacityA , valB = capacityB ;\\n        int n = plants.size() ;\\n        int l = 0 , r = n-1 ;\\n        int countA = 0 , countB = 0;\\n        while(l<r){\\n            if(valA>=plants[l]){\\n                valA -= plants[l] ;\\n            }\\n            else{\\n                countA++ ;\\n                valA = capacityA ;\\n                valA -= plants[l] ;\\n            }\\n            if(valB>=plants[r]){\\n                valB -= plants[r] ;\\n            }\\n            else{\\n                countB++ ;\\n                valB = capacityB ;\\n                valB -= plants[r] ;\\n            }\\n            l++ ;\\n            r-- ;\\n        }\\n        if(n%2 == 1){\\n            if(valA>=plants[l] || valB>=plants[r]){\\n            }\\n            else countA++;\\n        }\\n        return countA + countB ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513995,
                "title": "c-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simulate the process\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int result = 0;\\n\\n        int left = 0;\\n        int right = plants.Length - 1;\\n        int a = capacityA;\\n        int b = capacityB;\\n        \\n        for (;left < right; a -= plants[left++], b -= plants[right--]) {\\n            if (a < plants[left]) {\\n                ++result;\\n                a = capacityA;\\n            }\\n            \\n            if (b < plants[right]) {\\n                ++result;\\n                b = capacityB;\\n            }\\n        }\\n\\n        return (left == right && Math.Max(a, b) < plants[left]) \\n            ? result + 1\\n            : result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int result = 0;\\n\\n        int left = 0;\\n        int right = plants.Length - 1;\\n        int a = capacityA;\\n        int b = capacityB;\\n        \\n        for (;left < right; a -= plants[left++], b -= plants[right--]) {\\n            if (a < plants[left]) {\\n                ++result;\\n                a = capacityA;\\n            }\\n            \\n            if (b < plants[right]) {\\n                ++result;\\n                b = capacityB;\\n            }\\n        }\\n\\n        return (left == right && Math.Max(a, b) < plants[left]) \\n            ? result + 1\\n            : result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482912,
                "title": "clean-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI knew in Plants I we looped through the plants and handled certain cases accordingly, so dealing with two people felt the need to use the two pointer approach, each pointer representing Alice and Bob respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSetting a pointer to each person (Alice and Bob) and handled the two cases:\\n\\n**Case 1:**\\nAlice or Bob could not water fully the plant, therefore a refill was required\\n\\n**Case 2:**\\nAlice and Bob could water their plant without any refills.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n\\n        # two pointer approach\\n        a = 0\\n        b = len(plants) - 1\\n\\n        canA, canB = capacityA, capacityB\\n\\n        refills = 0\\n\\n        while a <= b:\\n\\n            # special case: alice and bob in same space\\n            if a == b:\\n                if canA < plants[a] and canB < plants[b]:\\n                    refills += 1\\n                break\\n\\n            # alice watering\\n            if canA >= plants[a]: \\n                canA -= plants[a] \\n            else:\\n                canA = capacityA - plants[a]\\n                refills += 1\\n            \\n            # bob watering\\n            if canB >= plants[b]:\\n                canB -= plants[b]\\n            else:\\n                canB = capacityB - plants[b]\\n                refills += 1\\n            \\n            a += 1\\n            b -= 1\\n\\n        return refills\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n\\n        # two pointer approach\\n        a = 0\\n        b = len(plants) - 1\\n\\n        canA, canB = capacityA, capacityB\\n\\n        refills = 0\\n\\n        while a <= b:\\n\\n            # special case: alice and bob in same space\\n            if a == b:\\n                if canA < plants[a] and canB < plants[b]:\\n                    refills += 1\\n                break\\n\\n            # alice watering\\n            if canA >= plants[a]: \\n                canA -= plants[a] \\n            else:\\n                canA = capacityA - plants[a]\\n                refills += 1\\n            \\n            # bob watering\\n            if canB >= plants[b]:\\n                canB -= plants[b]\\n            else:\\n                canB = capacityB - plants[b]\\n                refills += 1\\n            \\n            a += 1\\n            b -= 1\\n\\n        return refills\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465534,
                "title": "2-pointers-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int currA=capacityA, currB=capacityB;\\n        int a=0, b=plants.size()-1;\\n        int refill=0;\\n        while(a<b)\\n        {\\n            if(currA>=plants[a]) currA-=plants[a];\\n            else \\n            {\\n                currA=capacityA-plants[a];\\n                refill++;\\n            }\\n            plants[a]=0;\\n            a++;\\n            if(currB>=plants[b]) currB-=plants[b];\\n            else \\n            {\\n                currB=capacityB-plants[b];\\n                refill++;\\n            }\\n            plants[b]=0;\\n            b--;\\n        }\\n        if(plants[a]!=0)\\n        {\\n            if(currA<plants[a] && currB<plants[b]) refill++;\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int currA=capacityA, currB=capacityB;\\n        int a=0, b=plants.size()-1;\\n        int refill=0;\\n        while(a<b)\\n        {\\n            if(currA>=plants[a]) currA-=plants[a];\\n            else \\n            {\\n                currA=capacityA-plants[a];\\n                refill++;\\n            }\\n            plants[a]=0;\\n            a++;\\n            if(currB>=plants[b]) currB-=plants[b];\\n            else \\n            {\\n                currB=capacityB-plants[b];\\n                refill++;\\n            }\\n            plants[b]=0;\\n            b--;\\n        }\\n        if(plants[a]!=0)\\n        {\\n            if(currA<plants[a] && currB<plants[b]) refill++;\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444969,
                "title": "ez-solution",
                "content": "# Intuition\\nthere are 2 cases, one where plants.size() mod 2 is equal to zero, and one where it isnt. if it isnt, then alice and bob eventually meet up. if it is equal to zero, then alice and bob never do meet up.\\nfor the mod 2 = 0 case, it is just a simple for loop. for the mod 2 = 1 case, there is a simple for loop, but we need to compare who has more water in their can at the time bob and alice meet up, and if they can water the plant. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int cA, int cB) {\\n        int wa = cA;\\n        int wb = cB;\\n        int n = plants.size();\\n        int r = 0;\\n        if (n % 2 == 0) {\\n            for (int i = 0; i < (n/2); i++) {\\n                if (plants[i] <= wa) {\\n                    wa = wa - plants[i];\\n                }\\n                else {\\n                    ++r;\\n                    wa = cA;\\n                    wa = wa - plants[i];\\n                }\\n                if (plants[n - 1 - i] <= wb) {\\n                    wb = wb - plants[n - 1 - i];\\n                }\\n                else {\\n                    ++r;\\n                    wb = cB;\\n                    wb = wb - plants[n - 1 - i];\\n                }\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < floor(n/2); i++) {\\n                if (plants[i] <= wa) {\\n                    wa -= plants[i];\\n                }\\n                else {\\n                    ++r;\\n                    wa = cA;\\n                    wa -= plants[i];\\n                }\\n                if (plants[n - 1 - i] <= wb) {\\n                    wb -= plants[n - 1 - i];\\n                }\\n                else {\\n                    ++r;\\n                    wb = cB;\\n                    wb = wb - plants[n - 1 - i];\\n                }\\n            }\\n            if (wb >= plants[floor(n/2)] && wb > wa) {\\n                wb -= plants[floor(n/2)];\\n            }\\n            else if (wa >= plants[floor(n/2)] && wa > wb) {\\n                wa -= plants[floor(n/2)];\\n            }\\n            else if (wa == wb && wa >= plants[floor(n/2)]){\\n                wa -= plants[floor(n/2)];\\n            }\\n            else {\\n                ++r;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int cA, int cB) {\\n        int wa = cA;\\n        int wb = cB;\\n        int n = plants.size();\\n        int r = 0;\\n        if (n % 2 == 0) {\\n            for (int i = 0; i < (n/2); i++) {\\n                if (plants[i] <= wa) {\\n                    wa = wa - plants[i];\\n                }\\n                else {\\n                    ++r;\\n                    wa = cA;\\n                    wa = wa - plants[i];\\n                }\\n                if (plants[n - 1 - i] <= wb) {\\n                    wb = wb - plants[n - 1 - i];\\n                }\\n                else {\\n                    ++r;\\n                    wb = cB;\\n                    wb = wb - plants[n - 1 - i];\\n                }\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < floor(n/2); i++) {\\n                if (plants[i] <= wa) {\\n                    wa -= plants[i];\\n                }\\n                else {\\n                    ++r;\\n                    wa = cA;\\n                    wa -= plants[i];\\n                }\\n                if (plants[n - 1 - i] <= wb) {\\n                    wb -= plants[n - 1 - i];\\n                }\\n                else {\\n                    ++r;\\n                    wb = cB;\\n                    wb = wb - plants[n - 1 - i];\\n                }\\n            }\\n            if (wb >= plants[floor(n/2)] && wb > wa) {\\n                wb -= plants[floor(n/2)];\\n            }\\n            else if (wa >= plants[floor(n/2)] && wa > wb) {\\n                wa -= plants[floor(n/2)];\\n            }\\n            else if (wa == wb && wa >= plants[floor(n/2)]){\\n                wa -= plants[floor(n/2)];\\n            }\\n            else {\\n                ++r;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441059,
                "title": "two-pointer-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1;\\n        int alice=capacityA,bob=capacityB,steps=0;\\n        while(i<=j){\\n            if(i==j){\\n                if(Math.max(capacityA,capacityB)>=plants[i]){\\n                    break;\\n                }\\n                else{\\n                    steps++;\\n                    break;\\n                }\\n            }\\n            if(plants[i]<=capacityA){\\n                capacityA-=plants[i];\\n            }\\n            else{\\n                capacityA = alice;\\n                steps++;\\n                capacityA-=plants[i];\\n            }\\n            if(plants[j]<=capacityB){\\n                capacityB-=plants[j];\\n            }\\n            else{\\n                capacityB = bob;\\n                steps++;\\n                capacityB-=plants[j];\\n            }\\n            i++;j--;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1;\\n        int alice=capacityA,bob=capacityB,steps=0;\\n        while(i<=j){\\n            if(i==j){\\n                if(Math.max(capacityA,capacityB)>=plants[i]){\\n                    break;\\n                }\\n                else{\\n                    steps++;\\n                    break;\\n                }\\n            }\\n            if(plants[i]<=capacityA){\\n                capacityA-=plants[i];\\n            }\\n            else{\\n                capacityA = alice;\\n                steps++;\\n                capacityA-=plants[i];\\n            }\\n            if(plants[j]<=capacityB){\\n                capacityB-=plants[j];\\n            }\\n            else{\\n                capacityB = bob;\\n                steps++;\\n                capacityB-=plants[j];\\n            }\\n            i++;j--;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423830,
                "title": "python-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans=0\\n        l,r=0,len(plants)-1\\n        A,B=capacityA,capacityB\\n        while l<r:\\n            if plants[l]<=A:\\n                A-=plants[l]\\n                l+=1\\n            else:\\n                A=capacityA\\n                A-=plants[l]\\n                l+=1\\n                ans+=1\\n            if plants[r]<=B:\\n                B-=plants[r]\\n                r-=1\\n            else:\\n                B=capacityB\\n                B-=plants[r]\\n                r-=1\\n                ans+=1\\n            print(l,r,A,B)    \\n            if l==r:\\n                if A>B and plants[l]<=A:\\n                    l+=1\\n                elif A>B and plants[l]>A:\\n                    ans+=1\\n                    l+=1\\n                elif A<B and plants[r]<=B:\\n                    r-=1\\n                elif A<B and plants[r]>B:\\n                    ans+=1\\n                    r-=1  \\n                elif A==B and plants[l]>A:\\n                    ans+=1\\n                    l+=1\\n                else:\\n                    l+=1                  \\n        return ans            \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans=0\\n        l,r=0,len(plants)-1\\n        A,B=capacityA,capacityB\\n        while l<r:\\n            if plants[l]<=A:\\n                A-=plants[l]\\n                l+=1\\n            else:\\n                A=capacityA\\n                A-=plants[l]\\n                l+=1\\n                ans+=1\\n            if plants[r]<=B:\\n                B-=plants[r]\\n                r-=1\\n            else:\\n                B=capacityB\\n                B-=plants[r]\\n                r-=1\\n                ans+=1\\n            print(l,r,A,B)    \\n            if l==r:\\n                if A>B and plants[l]<=A:\\n                    l+=1\\n                elif A>B and plants[l]>A:\\n                    ans+=1\\n                    l+=1\\n                elif A<B and plants[r]<=B:\\n                    r-=1\\n                elif A<B and plants[r]>B:\\n                    ans+=1\\n                    r-=1  \\n                elif A==B and plants[l]>A:\\n                    ans+=1\\n                    l+=1\\n                else:\\n                    l+=1                  \\n        return ans            \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413664,
                "title": "java-best-solution-1ms-easy-to-implement-simple-code",
                "content": "\\n\\n\\n# Approach\\nEASY TO IMPLEMENT \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {  \\n        int i=0,j=plants.length-1;\\n        int min=0;\\n        int originala=capacityA,originalb=capacityB;\\n        while(i<=j){\\n          if(i==j){\\n              if(capacityA<plants[i] && capacityB<plants[i]){\\n                  min++;\\n                  break;\\n              }\\n              break;\\n          }\\n         if(plants[i]<=capacityA){\\n             capacityA=capacityA-plants[i];\\n             i++;\\n             \\n         }else{\\n             capacityA=originala;\\n             capacityA=capacityA-plants[i];\\n             i++;\\n             min++;\\n         }\\n         if(plants[j]<=capacityB){\\n             capacityB=capacityB-plants[j];\\n            j--;\\n            \\n         }\\n         else{\\n             capacityB=originalb;\\n             capacityB=capacityB-plants[j];\\n             j--;\\n             min++;\\n         }\\n\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {  \\n        int i=0,j=plants.length-1;\\n        int min=0;\\n        int originala=capacityA,originalb=capacityB;\\n        while(i<=j){\\n          if(i==j){\\n              if(capacityA<plants[i] && capacityB<plants[i]){\\n                  min++;\\n                  break;\\n              }\\n              break;\\n          }\\n         if(plants[i]<=capacityA){\\n             capacityA=capacityA-plants[i];\\n             i++;\\n             \\n         }else{\\n             capacityA=originala;\\n             capacityA=capacityA-plants[i];\\n             i++;\\n             min++;\\n         }\\n         if(plants[j]<=capacityB){\\n             capacityB=capacityB-plants[j];\\n            j--;\\n            \\n         }\\n         else{\\n             capacityB=originalb;\\n             capacityB=capacityB-plants[j];\\n             j--;\\n             min++;\\n         }\\n\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407947,
                "title": "easy-and-understandable-solution-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        i,j,capA,capB=0,len(plants)-1,capacityA,capacityB\\n        res=[0]*len(plants)\\n        while(i<=j):\\n            if(i<j):\\n                if(capacityA>=plants[i]):\\n                    capacityA-=plants[i]\\n                else:\\n                    capacityA=capA-plants[i]\\n                    res[i]=1\\n                if(capacityB>=plants[j]):\\n                    capacityB-=plants[j]\\n                else:\\n                    capacityB=capB-plants[j]\\n                    res[j]=1\\n            else:\\n                if(plants[i]>max(capacityA,capacityB)):\\n                    res[i]=1\\n            i+=1\\n            j-=1\\n        return sum(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        i,j,capA,capB=0,len(plants)-1,capacityA,capacityB\\n        res=[0]*len(plants)\\n        while(i<=j):\\n            if(i<j):\\n                if(capacityA>=plants[i]):\\n                    capacityA-=plants[i]\\n                else:\\n                    capacityA=capA-plants[i]\\n                    res[i]=1\\n                if(capacityB>=plants[j]):\\n                    capacityB-=plants[j]\\n                else:\\n                    capacityB=capB-plants[j]\\n                    res[j]=1\\n            else:\\n                if(plants[i]>max(capacityA,capacityB)):\\n                    res[i]=1\\n            i+=1\\n            j-=1\\n        return sum(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404494,
                "title": "python3-most-intutive-solution-beats-100-users-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, p: List[int], capacityA: int, capacityB: int) -> int:\\n        i,j,steps=0,len(p)-1,0\\n        curCapA,curCapB=capacityA,capacityB\\n        while i<=j:\\n            if i==j:\\n                if curCapA>=curCapB:\\n                    if curCapA-p[i]<0:\\n                        steps+=1\\n                else:\\n                    if curCapB-p[j]<0:\\n                        steps+=1\\n            else:\\n                if curCapA-p[i]<0:\\n                    curCapA=capacityA-p[i]\\n                    steps+=1\\n                else:\\n                    curCapA-=p[i]\\n                if curCapB-p[j]<0:\\n                    curCapB=capacityB-p[j]\\n                    steps+=1\\n                else:\\n                    curCapB-=p[j]\\n            i,j=i+1,j-1\\n        return steps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, p: List[int], capacityA: int, capacityB: int) -> int:\\n        i,j,steps=0,len(p)-1,0\\n        curCapA,curCapB=capacityA,capacityB\\n        while i<=j:\\n            if i==j:\\n                if curCapA>=curCapB:\\n                    if curCapA-p[i]<0:\\n                        steps+=1\\n                else:\\n                    if curCapB-p[j]<0:\\n                        steps+=1\\n            else:\\n                if curCapA-p[i]<0:\\n                    curCapA=capacityA-p[i]\\n                    steps+=1\\n                else:\\n                    curCapA-=p[i]\\n                if curCapB-p[j]<0:\\n                    curCapB=capacityB-p[j]\\n                    steps+=1\\n                else:\\n                    curCapB-=p[j]\\n            i,j=i+1,j-1\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398503,
                "title": "java-solution-using-two-pointer-method",
                "content": "\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int start = 0;\\n        int res=0;\\n        int end = plants.length-1;\\n        int capacityA1 = capacityA;\\n        int capacityB1 = capacityB;\\n        while(start < end){\\n            if (capacityA1 >= plants[start]) {\\n                capacityA1 -= plants[start];\\n            } else {\\n                res++;\\n                capacityA1 = capacityA - plants[start];\\n            }\\n            start++;\\n\\n            if (capacityB1 >= plants[end]) {\\n                capacityB1 -= plants[end];\\n            } else {\\n                res++;\\n                capacityB1 = capacityB - plants[end];\\n            }\\n            end--;\\n        }\\n        if (start == end) {\\n            int left = Math.max(capacityA1, capacityB1);\\n            if (left < plants[start]) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int start = 0;\\n        int res=0;\\n        int end = plants.length-1;\\n        int capacityA1 = capacityA;\\n        int capacityB1 = capacityB;\\n        while(start < end){\\n            if (capacityA1 >= plants[start]) {\\n                capacityA1 -= plants[start];\\n            } else {\\n                res++;\\n                capacityA1 = capacityA - plants[start];\\n            }\\n            start++;\\n\\n            if (capacityB1 >= plants[end]) {\\n                capacityB1 -= plants[end];\\n            } else {\\n                res++;\\n                capacityB1 = capacityB - plants[end];\\n            }\\n            end--;\\n        }\\n        if (start == end) {\\n            int left = Math.max(capacityA1, capacityB1);\\n            if (left < plants[start]) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397947,
                "title": "java-simple-and-short-o-n-2-time-4ms-faster-than-99-1-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,waterA=capacityA,waterB=capacityB,refil=0;\\n        while(i<j){\\n            if(waterA<plants[i]){\\n                waterA=capacityA;\\n                refil++;\\n            }\\n            waterA-=plants[i++];\\n            if(waterB<plants[j]){\\n                waterB=capacityB;\\n                refil++;\\n            }\\n            waterB-=plants[j--];\\n        }\\n        if(j-i==0 && waterA<plants[i] && waterB<plants[i])    refil++;\\n        return refil;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,waterA=capacityA,waterB=capacityB,refil=0;\\n        while(i<j){\\n            if(waterA<plants[i]){\\n                waterA=capacityA;\\n                refil++;\\n            }\\n            waterA-=plants[i++];\\n            if(waterB<plants[j]){\\n                waterB=capacityB;\\n                refil++;\\n            }\\n            waterB-=plants[j--];\\n        }\\n        if(j-i==0 && waterA<plants[i] && waterB<plants[i])    refil++;\\n        return refil;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386398,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int cA, int cB) {\\n        int n = p.size();\\n          int i =0;\\n          int j = n-1;\\n           int tempA = cA;\\n           int tempB = cB; \\n           int reFill =0;\\n          while(i<=j){\\n\\n              if(i == j){\\n\\n                \\n                if(tempA <p[i] && tempB <p[i]){\\n                    reFill++;\\n                    // i++;\\n                    // j++;\\n                    break;\\n                }\\n\\n                if(tempA >= tempB){\\n                     tempA -= p[i];\\n                    //  i++;\\n                    //  j--;\\n                    break;\\n                }\\n                else{\\n                     tempB -= p[i];\\n                    //  i++;\\n                    //  j--;\\n                    break;\\n                }\\n              }\\n\\n            // i!= j\\n\\n               if(p[i] > tempA){\\n                   reFill++;\\n                   tempA = cA;\\n                \\n               }  \\n\\n               if(p[j] >tempB){\\n                   reFill++;\\n                   tempB = cB;\\n               }\\n\\n             tempA-= p[i];\\n             tempB -= p[j];\\n             i++;\\n             j--;  \\n          }  \\n\\n          return reFill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int cA, int cB) {\\n        int n = p.size();\\n          int i =0;\\n          int j = n-1;\\n           int tempA = cA;\\n           int tempB = cB; \\n           int reFill =0;\\n          while(i<=j){\\n\\n              if(i == j){\\n\\n                \\n                if(tempA <p[i] && tempB <p[i]){\\n                    reFill++;\\n                    // i++;\\n                    // j++;\\n                    break;\\n                }\\n\\n                if(tempA >= tempB){\\n                     tempA -= p[i];\\n                    //  i++;\\n                    //  j--;\\n                    break;\\n                }\\n                else{\\n                     tempB -= p[i];\\n                    //  i++;\\n                    //  j--;\\n                    break;\\n                }\\n              }\\n\\n            // i!= j\\n\\n               if(p[i] > tempA){\\n                   reFill++;\\n                   tempA = cA;\\n                \\n               }  \\n\\n               if(p[j] >tempB){\\n                   reFill++;\\n                   tempB = cB;\\n               }\\n\\n             tempA-= p[i];\\n             tempB -= p[j];\\n             i++;\\n             j--;  \\n          }  \\n\\n          return reFill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355050,
                "title": "1-loop-solution-amazing-explanation-o-n",
                "content": "### Explained below inside the code for better Understanding.\\n# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# \\uD83D\\uDE09Please upvote it motivates me\\uD83D\\uDE09\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        \\n        int i=0,j=plants.size()-1;\\n        int canA = capacityA,canB = capacityB,refill=0;\\n\\n        while(i<=j)\\n        {\\n            /*If both Alice & Bob are on same plant then, the one who has more water will be watering the plant*/\\n            if(i == j)\\n            {\\n                //If Alice has more water than Bob\\n                if(canA >= canB)\\n                {\\n                    //If Alice doesn\\'t have enough water then refill.\\n                    if(canA < plants[i])\\n                    {\\n                        canA = capacityA;\\n                        refill++;\\n                    }\\n                }\\n\\n                //if Bob has more water\\n                else{\\n                    //If Bob doesn\\'t have enough water then refill.\\n                    if(canB < plants[j])\\n                    {\\n                        canB = capacityB;\\n                        refill++;\\n                    }\\n                }\\n            }\\n\\n            else{\\n                //If ALice doesn\\'t have enough water then refill.\\n                if(canA < plants[i]){\\n                    canA = capacityA;\\n                    refill++;\\n                }\\n                canA = canA - plants[i];\\n\\n                //If Bob doesn\\'t have enough water then refill.\\n                if(canB < plants[j]){\\n                    canB = capacityB;\\n                    refill++;\\n                }\\n                canB = canB - plants[j];\\n            }\\n\\n            i++,j--;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return refill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        \\n        int i=0,j=plants.size()-1;\\n        int canA = capacityA,canB = capacityB,refill=0;\\n\\n        while(i<=j)\\n        {\\n            /*If both Alice & Bob are on same plant then, the one who has more water will be watering the plant*/\\n            if(i == j)\\n            {\\n                //If Alice has more water than Bob\\n                if(canA >= canB)\\n                {\\n                    //If Alice doesn\\'t have enough water then refill.\\n                    if(canA < plants[i])\\n                    {\\n                        canA = capacityA;\\n                        refill++;\\n                    }\\n                }\\n\\n                //if Bob has more water\\n                else{\\n                    //If Bob doesn\\'t have enough water then refill.\\n                    if(canB < plants[j])\\n                    {\\n                        canB = capacityB;\\n                        refill++;\\n                    }\\n                }\\n            }\\n\\n            else{\\n                //If ALice doesn\\'t have enough water then refill.\\n                if(canA < plants[i]){\\n                    canA = capacityA;\\n                    refill++;\\n                }\\n                canA = canA - plants[i];\\n\\n                //If Bob doesn\\'t have enough water then refill.\\n                if(canB < plants[j]){\\n                    canB = capacityB;\\n                    refill++;\\n                }\\n                canB = canB - plants[j];\\n            }\\n\\n            i++,j--;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return refill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333153,
                "title": "c-golang-two-pointers-simulation",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int ans = 0, haveA = capacityA, haveB = capacityB, n = plants.size();\\n        for(int i = 0, j = n - 1; i < j; i++, j--) {\\n            if(haveA < plants[i]) {\\n                ans++;\\n                haveA = capacityA;\\n            }\\n            if(haveB < plants[j]) {\\n                ans++;\\n                haveB = capacityB;\\n            }\\n            haveA -= plants[i];\\n            haveB -= plants[j];\\n        }\\n        if(n % 2) {\\n            if(haveA >= haveB) ans += haveA < plants[n / 2];\\n            else ans += haveB < plants[n / 2]; \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumRefill(plants []int, capacityA int, capacityB int) int {\\n    var ans, haveA, haveB, n int = 0, capacityA, capacityB, len(plants)\\n    for i, j := 0, n - 1; i < j; i, j = i + 1, j - 1 {\\n        if haveA < plants[i] {\\n            ans++\\n            haveA = capacityA\\n        }\\n        if haveB < plants[j] {\\n            ans++\\n            haveB = capacityB\\n        }\\n        haveA -= plants[i]\\n        haveB -= plants[j]\\n    }\\n    if n % 2 == 1 {\\n        if haveA >= haveB {\\n            if haveA < plants[n / 2] {ans++}\\n        } else {\\n            if haveB < plants[n / 2] {ans++} \\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int ans = 0, haveA = capacityA, haveB = capacityB, n = plants.size();\\n        for(int i = 0, j = n - 1; i < j; i++, j--) {\\n            if(haveA < plants[i]) {\\n                ans++;\\n                haveA = capacityA;\\n            }\\n            if(haveB < plants[j]) {\\n                ans++;\\n                haveB = capacityB;\\n            }\\n            haveA -= plants[i];\\n            haveB -= plants[j];\\n        }\\n        if(n % 2) {\\n            if(haveA >= haveB) ans += haveA < plants[n / 2];\\n            else ans += haveB < plants[n / 2]; \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumRefill(plants []int, capacityA int, capacityB int) int {\\n    var ans, haveA, haveB, n int = 0, capacityA, capacityB, len(plants)\\n    for i, j := 0, n - 1; i < j; i, j = i + 1, j - 1 {\\n        if haveA < plants[i] {\\n            ans++\\n            haveA = capacityA\\n        }\\n        if haveB < plants[j] {\\n            ans++\\n            haveB = capacityB\\n        }\\n        haveA -= plants[i]\\n        haveB -= plants[j]\\n    }\\n    if n % 2 == 1 {\\n        if haveA >= haveB {\\n            if haveA < plants[n / 2] {ans++}\\n        } else {\\n            if haveB < plants[n / 2] {ans++} \\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332992,
                "title": "super-simple-python",
                "content": "# Intuition\\nkeep 2 pointers left-> right, right -> left\\n\\n# Approach\\nif even, then its simple. if odd the middle one will be watered by the greatest holding capacity that time\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        oa= capacityA\\n        ob= capacityB\\n        c=0\\n        if len(plants)%2==0:\\n            m= len(plants)//2\\n            i,j= m,m-1\\n        else:\\n            m = len(plants) // 2+1\\n            i,j= m,m-2\\n        for a,b in zip(range(0, i), range(len(plants)-1,j,-1)):\\n\\n            if a !=b:\\n                if capacityA >= plants[a]:\\n                    capacityA= capacityA - plants[a]\\n                else:\\n                    c=c+1\\n                    capacityA = oa\\n                    capacityA= capacityA - plants[a]\\n                if capacityB >= plants[b]:\\n                    capacityB= capacityB - plants[b]\\n                else:\\n                    c=c+1\\n                    capacityB = ob\\n                    capacityB= capacityB - plants[b]\\n            else:\\n                if capacityA < capacityB:\\n                    if capacityB >= plants[b]:\\n                        capacityB = capacityB - plants[b]\\n                    else:\\n                        c = c + 1\\n                        capacityB = ob\\n                        capacityB= capacityB - plants[b]\\n                else:\\n                    if capacityA >= plants[a]:\\n                        capacityA = capacityA - plants[a]\\n                    else:\\n                        c = c + 1\\n                        capacityA = oa\\n                        capacityA = capacityA - plants[a]\\n        return (c)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        oa= capacityA\\n        ob= capacityB\\n        c=0\\n        if len(plants)%2==0:\\n            m= len(plants)//2\\n            i,j= m,m-1\\n        else:\\n            m = len(plants) // 2+1\\n            i,j= m,m-2\\n        for a,b in zip(range(0, i), range(len(plants)-1,j,-1)):\\n\\n            if a !=b:\\n                if capacityA >= plants[a]:\\n                    capacityA= capacityA - plants[a]\\n                else:\\n                    c=c+1\\n                    capacityA = oa\\n                    capacityA= capacityA - plants[a]\\n                if capacityB >= plants[b]:\\n                    capacityB= capacityB - plants[b]\\n                else:\\n                    c=c+1\\n                    capacityB = ob\\n                    capacityB= capacityB - plants[b]\\n            else:\\n                if capacityA < capacityB:\\n                    if capacityB >= plants[b]:\\n                        capacityB = capacityB - plants[b]\\n                    else:\\n                        c = c + 1\\n                        capacityB = ob\\n                        capacityB= capacityB - plants[b]\\n                else:\\n                    if capacityA >= plants[a]:\\n                        capacityA = capacityA - plants[a]\\n                    else:\\n                        c = c + 1\\n                        capacityA = oa\\n                        capacityA = capacityA - plants[a]\\n        return (c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315768,
                "title": "c",
                "content": "```\\nint minimumRefill(int* plants, int plantsSize, int capacityA, int capacityB){\\n    int n = plantsSize ;\\n    int left = capacityA, right = capacityB ;\\n    int ret = 0 ;\\n    for(int i = 0 ; i < n/2 ; i++){\\n        left -= plants[i] ;\\n        right -= plants[n-1-i] ;\\n        if(left < 0){\\n            ret++ ;\\n            left = capacityA - plants[i] ;\\n        }\\n        if(right < 0){\\n            ret++ ;\\n            right = capacityB - plants[n-1-i] ;\\n        }\\n    }\\n    if(n % 2 == 0)\\n        return ret ;\\n    \\n    if(left >= right){\\n        if(left < plants[n/2])\\n            ret++ ;\\n    }\\n    else{\\n        if(right < plants[n/2])\\n            ret++ ;\\n    }\\n\\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumRefill(int* plants, int plantsSize, int capacityA, int capacityB){\\n    int n = plantsSize ;\\n    int left = capacityA, right = capacityB ;\\n    int ret = 0 ;\\n    for(int i = 0 ; i < n/2 ; i++){\\n        left -= plants[i] ;\\n        right -= plants[n-1-i] ;\\n        if(left < 0){\\n            ret++ ;\\n            left = capacityA - plants[i] ;\\n        }\\n        if(right < 0){\\n            ret++ ;\\n            right = capacityB - plants[n-1-i] ;\\n        }\\n    }\\n    if(n % 2 == 0)\\n        return ret ;\\n    \\n    if(left >= right){\\n        if(left < plants[n/2])\\n            ret++ ;\\n    }\\n    else{\\n        if(right < plants[n/2])\\n            ret++ ;\\n    }\\n\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310238,
                "title": "easy-two-pointers-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int ans=0;\\n        int n=plants.size();\\n        int start=0;\\n        int end=n-1;\\n        int x=capacityA;\\n        int y=capacityB;\\n        while(start<=end){\\n            if(start==end){\\n                if(x>=y){\\n                    if(x>=plants[start]){\\n                        break;\\n                    }\\n                    else{\\n                        ans++;\\n                        break;\\n                    }\\n\\n                }\\n                else{\\n                    if(y>=plants[end]){\\n                        break;\\n                    }\\n                    else{\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(x>=plants[start]){\\n                x-=plants[start];\\n                start++;\\n            }\\n            else{\\n                ans++;\\n                x=capacityA;\\n                x-=plants[start];\\n                start++;\\n\\n            }\\n            if(y>=plants[end]){\\n                y-=plants[end];\\n                end--;\\n            }\\n            else{\\n                ans++;\\n                y=capacityB;\\n                y-=plants[end];\\n                end--;\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int ans=0;\\n        int n=plants.size();\\n        int start=0;\\n        int end=n-1;\\n        int x=capacityA;\\n        int y=capacityB;\\n        while(start<=end){\\n            if(start==end){\\n                if(x>=y){\\n                    if(x>=plants[start]){\\n                        break;\\n                    }\\n                    else{\\n                        ans++;\\n                        break;\\n                    }\\n\\n                }\\n                else{\\n                    if(y>=plants[end]){\\n                        break;\\n                    }\\n                    else{\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(x>=plants[start]){\\n                x-=plants[start];\\n                start++;\\n            }\\n            else{\\n                ans++;\\n                x=capacityA;\\n                x-=plants[start];\\n                start++;\\n\\n            }\\n            if(y>=plants[end]){\\n                y-=plants[end];\\n                end--;\\n            }\\n            else{\\n                ans++;\\n                y=capacityB;\\n                y-=plants[end];\\n                end--;\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305993,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int A, int B) {\\n        int n=plants.size();\\n        int i=0,j=n-1;\\n        int currA=A,currB=B;\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(currA>=currB)\\n                {\\n                    if(currA<plants[i])\\n                        ans++;\\n                }\\n                else if(currB>currA)\\n                {\\n                    if(currB<plants[i])\\n                        ans++;\\n                }\\n                break;\\n            }\\n            \\n            if(plants[i]>currA)\\n            {\\n                ans++;\\n                currA=A-plants[i];\\n            }\\n            else\\n            {\\n                currA=currA-plants[i];\\n            }\\n            \\n            if(plants[j]>currB)\\n            {\\n                ans++;\\n                currB=B-plants[j];\\n            }\\n            else\\n                currB=currB-plants[j];\\n            i++;\\n            j--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int A, int B) {\\n        int n=plants.size();\\n        int i=0,j=n-1;\\n        int currA=A,currB=B;\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(currA>=currB)\\n                {\\n                    if(currA<plants[i])\\n                        ans++;\\n                }\\n                else if(currB>currA)\\n                {\\n                    if(currB<plants[i])\\n                        ans++;\\n                }\\n                break;\\n            }\\n            \\n            if(plants[i]>currA)\\n            {\\n                ans++;\\n                currA=A-plants[i];\\n            }\\n            else\\n            {\\n                currA=currA-plants[i];\\n            }\\n            \\n            if(plants[j]>currB)\\n            {\\n                ans++;\\n                currB=B-plants[j];\\n            }\\n            else\\n                currB=currB-plants[j];\\n            i++;\\n            j--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288395,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.size()-1,count=0,capa=capacityA,capb=capacityB;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(capa>=capb)\\n                {\\n                    if(capa<plants[i]) count++;\\n                    i++;\\n                }\\n                else\\n                {\\n                     if(capb<plants[j]) count++;\\n                     j--;\\n                }\\n            }\\n            else\\n            {\\n            if(capa>=plants[i])\\n          {\\n              capa-=plants[i];\\n            i++;\\n          }\\n          else\\n          {\\n            capa=capacityA;\\n            count++;\\n             capa-=plants[i];\\n            i++;\\n          }\\n           if(capb>=plants[j])\\n          {\\n              capb-=plants[j];\\n            j--;\\n          }\\n          else\\n          {\\n            capb=capacityB;\\n            count++;\\n             capb-=plants[j];\\n            j--;\\n          }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.size()-1,count=0,capa=capacityA,capb=capacityB;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(capa>=capb)\\n                {\\n                    if(capa<plants[i]) count++;\\n                    i++;\\n                }\\n                else\\n                {\\n                     if(capb<plants[j]) count++;\\n                     j--;\\n                }\\n            }\\n            else\\n            {\\n            if(capa>=plants[i])\\n          {\\n              capa-=plants[i];\\n            i++;\\n          }\\n          else\\n          {\\n            capa=capacityA;\\n            count++;\\n             capa-=plants[i];\\n            i++;\\n          }\\n           if(capb>=plants[j])\\n          {\\n              capb-=plants[j];\\n            j--;\\n          }\\n          else\\n          {\\n            capb=capacityB;\\n            count++;\\n             capb-=plants[j];\\n            j--;\\n          }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274962,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int n=plants.size();\\n        int l=0;\\n        int r=n-1;\\n        int ans=0;\\n        int a=capacityA;\\n        int b=capacityB;\\n        while(l<=r)\\n        {\\n            if (l==r)\\n            {\\n             if (plants[l]<=a || plants[r]<=b) break;\\n             else {\\n                 ans++;\\n                 break;\\n             }\\n            }\\n            if (plants[l]>a)\\n            {\\n                ans++;\\n                a=capacityA-plants[l];\\n                l++;\\n            }\\n            else{\\n                a-=plants[l];\\n                l++;\\n            }\\n            if (plants[r]>b)\\n            {\\n                ans++;\\n                b=capacityB-plants[r];\\n                r--;\\n            }\\n            else{\\n                b-=plants[r];\\n                r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int n=plants.size();\\n        int l=0;\\n        int r=n-1;\\n        int ans=0;\\n        int a=capacityA;\\n        int b=capacityB;\\n        while(l<=r)\\n        {\\n            if (l==r)\\n            {\\n             if (plants[l]<=a || plants[r]<=b) break;\\n             else {\\n                 ans++;\\n                 break;\\n             }\\n            }\\n            if (plants[l]>a)\\n            {\\n                ans++;\\n                a=capacityA-plants[l];\\n                l++;\\n            }\\n            else{\\n                a-=plants[l];\\n                l++;\\n            }\\n            if (plants[r]>b)\\n            {\\n                ans++;\\n                b=capacityB-plants[r];\\n                r--;\\n            }\\n            else{\\n                b-=plants[r];\\n                r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266138,
                "title": "javascript-2-pointers-kind-of-verbose",
                "content": "# Code\\n```\\n// O(n/2)\\nvar minimumRefill = function(plants, capacityA, capacityB) {\\n    let refill = 0;\\n    let a = capacityA;\\n    let b = capacityB;\\n    let l = 0;\\n    let r = plants.length - 1;\\n\\n    const fill = (i, val, cap, char) => {\\n        while (plants[i] > 0) {\\n            if (plants[i] <= val) {\\n                val -= plants[i];\\n                plants[i] = 0;\\n            } else {\\n                refill++;\\n                val = cap;\\n            }\\n        }\\n        if (char === \\'Alice\\') {\\n            a = val;\\n            l++;\\n        } else {\\n            b = val;\\n            r--;\\n        }\\n        return val;\\n    }\\n\\n    while (l < r) {\\n        fill(l, a, capacityA, \\'Alice\\');\\n        fill(r, b, capacityB);\\n    }\\n    if (l === r) {\\n        (b > a) ? fill(r, b, capacityB) : fill(l, a, capacityA, \\'Alice\\');\\n    }\\n    return refill;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n/2)\\nvar minimumRefill = function(plants, capacityA, capacityB) {\\n    let refill = 0;\\n    let a = capacityA;\\n    let b = capacityB;\\n    let l = 0;\\n    let r = plants.length - 1;\\n\\n    const fill = (i, val, cap, char) => {\\n        while (plants[i] > 0) {\\n            if (plants[i] <= val) {\\n                val -= plants[i];\\n                plants[i] = 0;\\n            } else {\\n                refill++;\\n                val = cap;\\n            }\\n        }\\n        if (char === \\'Alice\\') {\\n            a = val;\\n            l++;\\n        } else {\\n            b = val;\\n            r--;\\n        }\\n        return val;\\n    }\\n\\n    while (l < r) {\\n        fill(l, a, capacityA, \\'Alice\\');\\n        fill(r, b, capacityB);\\n    }\\n    if (l === r) {\\n        (b > a) ? fill(r, b, capacityB) : fill(l, a, capacityA, \\'Alice\\');\\n    }\\n    return refill;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238742,
                "title": "simplest-2-pointers-with-only-if-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to simulate this question in your mind and the main which i got is first we will check if we can water that plant or not if we can we will water or else we will refill it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int A, int B) {\\n        int i=0;\\n        int j=p.size()-1;\\n        int count=0;\\n        int x=A;\\n        int y=B;\\n        while(i<=j){\\n            if(i!=j && x-p[i]<0){\\n                count++;\\n                x=A;\\n            }\\n            if(i!=j && y-p[j]<0){\\n                count++;\\n                y=B;\\n            }\\n            if(i==j && x-p[i]<0 && y-p[j]<0){\\n                count++;\\n                x=A;\\n                y=B;\\n            }\\n            if( x-p[i]>=0){\\n                x=x-p[i];\\n                i++;\\n            }\\n            if( y-p[j]>=0){\\n                y=y-p[j];\\n                j--;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n};\\nupvote if you liked it.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int A, int B) {\\n        int i=0;\\n        int j=p.size()-1;\\n        int count=0;\\n        int x=A;\\n        int y=B;\\n        while(i<=j){\\n            if(i!=j && x-p[i]<0){\\n                count++;\\n                x=A;\\n            }\\n            if(i!=j && y-p[j]<0){\\n                count++;\\n                y=B;\\n            }\\n            if(i==j && x-p[i]<0 && y-p[j]<0){\\n                count++;\\n                x=A;\\n                y=B;\\n            }\\n            if( x-p[i]>=0){\\n                x=x-p[i];\\n                i++;\\n            }\\n            if( y-p[j]>=0){\\n                y=y-p[j];\\n                j--;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n};\\nupvote if you liked it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213318,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int l=0;\\n        int i=0,j=p.size()-1;\\n        int a=ca,b=cb;\\n        while(i<p.size() && j>=0 && i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(a>b)\\n                {\\n                    if(a<p[i])\\n                    l++;\\n                    break;\\n                }\\n                else if(b>a)\\n                {\\n                    if(b<p[i])\\n                    l++;\\n                    break;    \\n                }\\n                else\\n                {\\n                    if(a<p[i])\\n                    l++;\\n                    break;\\n                }\\n            }\\n          \\n          if(a<p[i])\\n          {\\n              a=ca;\\n              a-=p[i];\\n              i++;\\n              l++;\\n          }\\n          else\\n          {\\n              a-=p[i];\\n              i++;\\n          }\\n          if(b<p[j])\\n          {\\n              b=cb;\\n              l++;\\n              b-=p[j];\\n              j--;\\n          }\\n          else\\n          {\\n              b-=p[j];\\n              j--;\\n          }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int ca, int cb) {\\n        int l=0;\\n        int i=0,j=p.size()-1;\\n        int a=ca,b=cb;\\n        while(i<p.size() && j>=0 && i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(a>b)\\n                {\\n                    if(a<p[i])\\n                    l++;\\n                    break;\\n                }\\n                else if(b>a)\\n                {\\n                    if(b<p[i])\\n                    l++;\\n                    break;    \\n                }\\n                else\\n                {\\n                    if(a<p[i])\\n                    l++;\\n                    break;\\n                }\\n            }\\n          \\n          if(a<p[i])\\n          {\\n              a=ca;\\n              a-=p[i];\\n              i++;\\n              l++;\\n          }\\n          else\\n          {\\n              a-=p[i];\\n              i++;\\n          }\\n          if(b<p[j])\\n          {\\n              b=cb;\\n              l++;\\n              b-=p[j];\\n              j--;\\n          }\\n          else\\n          {\\n              b-=p[j];\\n              j--;\\n          }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210473,
                "title": "watering-plants-2",
                "content": "# Code\\n```\\nclass Solution {\\n    public static int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i = 0;\\n        int j = plants.length - 1;\\n        int cA1 = capacityA;\\n        int cB1 = capacityB;\\n        int fill = 0;\\n        while (i <= j) {\\n            if (i != j) {\\n                if (cA1 >= plants[i]) {\\n                    cA1 -= plants[i];\\n                } else {\\n                    cA1 = capacityA;\\n                    fill++;\\n                    cA1 -= plants[i];\\n                }\\n\\n                if (cB1 >= plants[j]) {\\n                    cB1 -= plants[j];\\n                } else {\\n                    cB1 = capacityB;\\n                    fill++;\\n                    cB1 -= plants[j];\\n                }\\n            }\\n            if (i == j) {\\n                if (cA1 >= cB1) {\\n                    if (plants[i] > cA1)\\n                        fill++;\\n                } else {\\n                    if (plants[j] > cB1)\\n                        fill++;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return fill;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public static int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i = 0;\\n        int j = plants.length - 1;\\n        int cA1 = capacityA;\\n        int cB1 = capacityB;\\n        int fill = 0;\\n        while (i <= j) {\\n            if (i != j) {\\n                if (cA1 >= plants[i]) {\\n                    cA1 -= plants[i];\\n                } else {\\n                    cA1 = capacityA;\\n                    fill++;\\n                    cA1 -= plants[i];\\n                }\\n\\n                if (cB1 >= plants[j]) {\\n                    cB1 -= plants[j];\\n                } else {\\n                    cB1 = capacityB;\\n                    fill++;\\n                    cB1 -= plants[j];\\n                }\\n            }\\n            if (i == j) {\\n                if (cA1 >= cB1) {\\n                    if (plants[i] > cA1)\\n                        fill++;\\n                } else {\\n                    if (plants[j] > cB1)\\n                        fill++;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return fill;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198420,
                "title": "go-90-faster-90-less-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc getMax(i, j int) int {\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\n\\treturn j\\n}\\n\\nfunc minimumRefill(plants []int, capacityA int, capacityB int) int {\\n\\n\\tout := 0\\n\\tcurrentA, currentB := 0, len(plants)-1\\n\\tbucketA, bucketB := capacityA, capacityB\\n\\n\\tfor currentA <= currentB {\\n\\n\\t\\tif currentA == currentB {\\n\\t\\t\\tif getMax(bucketA, bucketB) < plants[currentA] {\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\n\\t\\t\\tif bucketA < plants[currentA] {\\n\\t\\t\\t\\tout++\\n\\t\\t\\t\\tbucketA = capacityA\\n\\t\\t\\t}\\n\\n\\t\\t\\tif bucketB < plants[currentB] {\\n\\t\\t\\t\\tout++\\n\\t\\t\\t\\tbucketB = capacityB\\n\\t\\t\\t}\\n\\n\\t\\t\\tbucketA -= plants[currentA]\\n\\t\\t\\tbucketB -= plants[currentB]\\n\\n\\t\\t\\tcurrentA++\\n\\t\\t\\tcurrentB--\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nfunc getMax(i, j int) int {\\n\\tif i > j {\\n\\t\\treturn i\\n\\t}\\n\\n\\treturn j\\n}\\n\\nfunc minimumRefill(plants []int, capacityA int, capacityB int) int {\\n\\n\\tout := 0\\n\\tcurrentA, currentB := 0, len(plants)-1\\n\\tbucketA, bucketB := capacityA, capacityB\\n\\n\\tfor currentA <= currentB {\\n\\n\\t\\tif currentA == currentB {\\n\\t\\t\\tif getMax(bucketA, bucketB) < plants[currentA] {\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\n\\t\\t\\tif bucketA < plants[currentA] {\\n\\t\\t\\t\\tout++\\n\\t\\t\\t\\tbucketA = capacityA\\n\\t\\t\\t}\\n\\n\\t\\t\\tif bucketB < plants[currentB] {\\n\\t\\t\\t\\tout++\\n\\t\\t\\t\\tbucketB = capacityB\\n\\t\\t\\t}\\n\\n\\t\\t\\tbucketA -= plants[currentA]\\n\\t\\t\\tbucketB -= plants[currentB]\\n\\n\\t\\t\\tcurrentA++\\n\\t\\t\\tcurrentB--\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3108383,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int ca, int cb) {\\n        int refill = 0;\\n        for(int a = 0, b = plants.size() - 1, wa = ca, wb = cb; a <= b; a++, b--) {\\n            if(a == b) { // If Alice and Bob got to a common plant\\n                // and they both don\\'t have enough water, \\n                // then one of them needs to refill the supply of water before watering\\n                if(wa < plants[a] && wb < plants[b])\\n                    refill++;\\n            } else {\\n                if(wa < plants[a]) {\\n                    wa = ca; refill++;\\n                }\\n                if(wb < plants[b]) {\\n                    wb = cb; refill++;\\n                }\\n                wa -= plants[a]; wb -= plants[b];\\n            }\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int ca, int cb) {\\n        int refill = 0;\\n        for(int a = 0, b = plants.size() - 1, wa = ca, wb = cb; a <= b; a++, b--) {\\n            if(a == b) { // If Alice and Bob got to a common plant\\n                // and they both don\\'t have enough water, \\n                // then one of them needs to refill the supply of water before watering\\n                if(wa < plants[a] && wb < plants[b])\\n                    refill++;\\n            } else {\\n                if(wa < plants[a]) {\\n                    wa = ca; refill++;\\n                }\\n                if(wb < plants[b]) {\\n                    wb = cb; refill++;\\n                }\\n                wa -= plants[a]; wb -= plants[b];\\n            }\\n        }\\n        return refill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104172,
                "title": "easy-cpp-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int a, int b) {\\n        \\n        int capa=a;\\n        int capb=b;\\n        int ans=0;\\n        int i=0,j=p.size()-1;\\n        while(i<=j){\\n            \\n            if(i==j){\\n                if(a>=b){\\n                    if(p[i]<=a){\\n                        a-=p[i];\\n                        i++;\\n                    }else{\\n                        a=capa;\\n                        a-=p[i];\\n                        ans++;\\n                        i++;\\n                    }\\n                }else{\\n                    if(p[j]<=b){\\n                        b-=p[j];\\n                        j--;\\n                    }else if(p[j]>b){\\n                        b=capb;\\n                        b-=p[j];\\n                        ans++;\\n                        j--;;\\n                    }\\n                }\\n            }\\n            else{\\n                if(p[i]<=a){\\n                    a-=p[i];\\n                    i++;\\n                }else if(p[i]>a){\\n                    a=capa;\\n                    a-=p[i];\\n                    ans++;\\n                    i++;\\n                }\\n\\n                if(p[j]<=b){\\n                    b-=p[j];\\n                    j--;\\n                }else if(p[j]>b){\\n                    b=capb;\\n                    b-=p[j];\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int a, int b) {\\n        \\n        int capa=a;\\n        int capb=b;\\n        int ans=0;\\n        int i=0,j=p.size()-1;\\n        while(i<=j){\\n            \\n            if(i==j){\\n                if(a>=b){\\n                    if(p[i]<=a){\\n                        a-=p[i];\\n                        i++;\\n                    }else{\\n                        a=capa;\\n                        a-=p[i];\\n                        ans++;\\n                        i++;\\n                    }\\n                }else{\\n                    if(p[j]<=b){\\n                        b-=p[j];\\n                        j--;\\n                    }else if(p[j]>b){\\n                        b=capb;\\n                        b-=p[j];\\n                        ans++;\\n                        j--;;\\n                    }\\n                }\\n            }\\n            else{\\n                if(p[i]<=a){\\n                    a-=p[i];\\n                    i++;\\n                }else if(p[i]>a){\\n                    a=capa;\\n                    a-=p[i];\\n                    ans++;\\n                    i++;\\n                }\\n\\n                if(p[j]<=b){\\n                    b-=p[j];\\n                    j--;\\n                }else if(p[j]>b){\\n                    b=capb;\\n                    b-=p[j];\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095043,
                "title": "simple-two-pointer-approach-python-solution-o-n",
                "content": "# Intuition and Approach\\n* since both take same time to water any plant, we will do simulation with help of two pointers.\\n* we will keep cnt as ans and increase it when any of them refils water in the can.\\n* at the end return ans.\\n* ** take care of position on which then can reach at same time.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRefill(self, p: List[int], ca: int, cb: int) -> int:\\n        cat=ca\\n        cbt=cb\\n        cnt=0\\n        i=0\\n        j=len(p)-1\\n        while(i<=j):\\n            if(i<j):\\n                if(cat>=p[i]):\\n                    cat-=p[i]\\n                else:\\n                    cnt+=1\\n                    cat=ca-p[i]\\n                if(cbt>=p[j]):\\n                    cbt-=p[j]\\n                else:\\n                    cbt=cb-p[j]\\n                    cnt+=1\\n            else:\\n                if(cat>=cbt and cat<p[i]):\\n                    cnt+=1\\n                elif(cbt>cat and cbt<p[i]):\\n                    cnt+=1\\n            i+=1\\n            j-=1\\n        return cnt\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, p: List[int], ca: int, cb: int) -> int:\\n        cat=ca\\n        cbt=cb\\n        cnt=0\\n        i=0\\n        j=len(p)-1\\n        while(i<=j):\\n            if(i<j):\\n                if(cat>=p[i]):\\n                    cat-=p[i]\\n                else:\\n                    cnt+=1\\n                    cat=ca-p[i]\\n                if(cbt>=p[j]):\\n                    cbt-=p[j]\\n                else:\\n                    cbt=cb-p[j]\\n                    cnt+=1\\n            else:\\n                if(cat>=cbt and cat<p[i]):\\n                    cnt+=1\\n                elif(cbt>cat and cbt<p[i]):\\n                    cnt+=1\\n            i+=1\\n            j-=1\\n        return cnt\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076406,
                "title": "python-two-pointers",
                "content": "# We apply two pointers and check start Alice from left and Bob from right we do that while i<=j we make a special case when i==j when that happens if Alice water >=Bob Water we let Alice do it else Bob will fill. The condition for any one is simple. Just check if they have enough water and if so reduce the plant[i] or plant[j] from there capacity and if not make there capacity full using the temp varriable and and then reduce the plan[i] or plant[j] water from it and then increase the refile counter too. If Alice refils increase countA and if Bob refils increase counter countB in the end return countA + countB\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        tempA = capacityA\\n        tempB = capacityB\\n        countA = 0\\n        countB = 0\\n        i=0\\n        j=len(plants)-1\\n        while i<=j:\\n            if i==j:\\n                if capacityA>=capacityB:\\n                    if capacityA>=plants[i]:\\n                        capacityA-=plants[i]\\n                    else:\\n                        capacityA = tempA\\n                        capacityA-=plants[i]\\n                        countA+=1\\n                elif capacityB>capacityA:\\n                    if capacityB>=plants[j]:\\n                        capacityB-=plants[j]\\n                    else:\\n                        capacityB = tempB\\n                        capacityB-=plants[j]\\n                        countB+=1\\n                break\\n            if capacityA>=plants[i]:\\n                capacityA-=plants[i]\\n            else:\\n                capacityA = tempA\\n                capacityA-=plants[i]\\n                countA +=1\\n            if capacityB>=plants[j]:\\n                capacityB-=plants[j]\\n            else:\\n                capacityB = tempB\\n                capacityB-=plants[j]\\n                countB+=1\\n            i+=1\\n            j-=1\\n        \\n        return countA+countB\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        tempA = capacityA\\n        tempB = capacityB\\n        countA = 0\\n        countB = 0\\n        i=0\\n        j=len(plants)-1\\n        while i<=j:\\n            if i==j:\\n                if capacityA>=capacityB:\\n                    if capacityA>=plants[i]:\\n                        capacityA-=plants[i]\\n                    else:\\n                        capacityA = tempA\\n                        capacityA-=plants[i]\\n                        countA+=1\\n                elif capacityB>capacityA:\\n                    if capacityB>=plants[j]:\\n                        capacityB-=plants[j]\\n                    else:\\n                        capacityB = tempB\\n                        capacityB-=plants[j]\\n                        countB+=1\\n                break\\n            if capacityA>=plants[i]:\\n                capacityA-=plants[i]\\n            else:\\n                capacityA = tempA\\n                capacityA-=plants[i]\\n                countA +=1\\n            if capacityB>=plants[j]:\\n                capacityB-=plants[j]\\n            else:\\n                capacityB = tempB\\n                capacityB-=plants[j]\\n                countB+=1\\n            i+=1\\n            j-=1\\n        \\n        return countA+countB\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076069,
                "title": "beats-97-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int alice_can = capacityA,bob_can = capacityB;\\n\\n        int count1 = 0,count2 = plants.length-1,refill_time = 0;\\n        while(count1 <= count2){\\n            if(count1 == count2){\\n               if(alice_can >= plants[count1] || bob_can >= plants[count2])break;\\n               else{\\n                   refill_time++;\\n                   break;\\n               }\\n            }\\n            if(plants[count1] <= alice_can){\\n                alice_can -= plants[count1];\\n            }else{\\n                alice_can = capacityA-plants[count1];\\n                refill_time++;\\n            }\\n            if(plants[count2] <= bob_can) bob_can -= plants[count2];\\n            else{\\n                bob_can = capacityB-plants[count2];\\n                refill_time++;\\n            }\\n            count1++;\\n            count2--;\\n\\n        }\\n    return refill_time;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int alice_can = capacityA,bob_can = capacityB;\\n\\n        int count1 = 0,count2 = plants.length-1,refill_time = 0;\\n        while(count1 <= count2){\\n            if(count1 == count2){\\n               if(alice_can >= plants[count1] || bob_can >= plants[count2])break;\\n               else{\\n                   refill_time++;\\n                   break;\\n               }\\n            }\\n            if(plants[count1] <= alice_can){\\n                alice_can -= plants[count1];\\n            }else{\\n                alice_can = capacityA-plants[count1];\\n                refill_time++;\\n            }\\n            if(plants[count2] <= bob_can) bob_can -= plants[count2];\\n            else{\\n                bob_can = capacityB-plants[count2];\\n                refill_time++;\\n            }\\n            count1++;\\n            count2--;\\n\\n        }\\n    return refill_time;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055828,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n               \\n        int start=0;\\n        int end=plants.size()-1;\\n        long long count=0;\\n        int quantityA=capacityA;\\n        int quantityB=capacityB;\\n        while(start<=end){\\n            \\n            if(start==end){\\n                \\n                if(quantityA<plants[start] && quantityB<plants[end]){\\n                    count++;\\n                }\\n                start++;\\n                end--;\\n            }\\n            else{\\n               if(quantityA>=plants[start]){\\n                   quantityA=quantityA-plants[start];\\n                   start++;\\n               }\\n               else{\\n                   count++;\\n                   quantityA=capacityA;\\n                   quantityA=quantityA-plants[start];\\n                   start++;\\n               }\\n               if(quantityB>=plants[end]){\\n                   quantityB=quantityB-plants[end];\\n                   end--;\\n               }\\n               else{\\n                   count++;\\n                   quantityB=capacityB;\\n                   quantityB=quantityB-plants[end];\\n                   end--;\\n               }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n               \\n        int start=0;\\n        int end=plants.size()-1;\\n        long long count=0;\\n        int quantityA=capacityA;\\n        int quantityB=capacityB;\\n        while(start<=end){\\n            \\n            if(start==end){\\n                \\n                if(quantityA<plants[start] && quantityB<plants[end]){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3030736,
                "title": "array-iteration-o-n-very-simple",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \"\"\"\\n        simple iteration problem using two pointers\\n        if len(plants) is even, alice and bob will not meet on same plant\\n        if len(plants) is odd, alice and bob will meet at same plant\\n        \"\"\"\\n        i, j, refills = 0, len(plants)-1, 0\\n        cur_cap_A, cur_cap_B = capacityA, capacityB\\n        while i < j:\\n            if cur_cap_A >= plants[i]:\\n                # plant can be watered without refill\\n                cur_cap_A-=plants[i]\\n            else:\\n                # refill and then water\\n                refills+=1\\n                cur_cap_A = capacityA - plants[i]\\n            i+=1\\n            if cur_cap_B >= plants[j]:\\n                # plant can be watered without refill\\n                cur_cap_B-=plants[j]\\n            else:\\n                refills+=1\\n                cur_cap_B = capacityB - plants[j]\\n            j-=1\\n\\n        if len(plants)% 2 and plants[len(plants)//2] > max(cur_cap_B, cur_cap_A):\\n            return refills+1\\n        return refills\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \"\"\"\\n        simple iteration problem using two pointers\\n        if len(plants) is even, alice and bob will not meet on same plant\\n        if len(plants) is odd, alice and bob will meet at same plant\\n        \"\"\"\\n        i, j, refills = 0, len(plants)-1, 0\\n        cur_cap_A, cur_cap_B = capacityA, capacityB\\n        while i < j:\\n            if cur_cap_A >= plants[i]:\\n                # plant can be watered without refill\\n                cur_cap_A-=plants[i]\\n            else:\\n                # refill and then water\\n                refills+=1\\n                cur_cap_A = capacityA - plants[i]\\n            i+=1\\n            if cur_cap_B >= plants[j]:\\n                # plant can be watered without refill\\n                cur_cap_B-=plants[j]\\n            else:\\n                refills+=1\\n                cur_cap_B = capacityB - plants[j]\\n            j-=1\\n\\n        if len(plants)% 2 and plants[len(plants)//2] > max(cur_cap_B, cur_cap_A):\\n            return refills+1\\n        return refills\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980021,
                "title": "watering-plants-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n = plants.size(); \\n        int A = capacityA;\\n        int B = capacityB;\\n        int i=0;\\n        int j=n-1;\\n        int refill = 0;\\n        while(i<j){\\n            if(plants[i]<=capacityA){\\n            capacityA = capacityA - plants[i];\\n            i++;\\n            }\\n            else{\\n                refill++;\\n                capacityA = A;\\n                capacityA = capacityA - plants[i];\\n                i++;\\n            }\\n\\n            if(plants[j]<=capacityB){\\n            capacityB = capacityB - plants[j];\\n            j--;\\n            }\\n            else{\\n                refill++;\\n                capacityB = B;\\n                capacityB = capacityB - plants[j];\\n                j--;\\n            }\\n  \\n        }\\n\\n        if(i==j){\\n            if(capacityA == capacityB){\\n                if(capacityA >= plants[i]){\\n                capacityA = capacityA - plants[i];\\n                return refill ;}\\n                else{\\n                    refill++;\\n                    return refill ;\\n                }\\n\\n\\n                if(capacityB >= plants[i]){\\n                capacityB = capacityB - plants[i];\\n                return refill ;}\\n                else{\\n                    refill++;\\n                    return refill ;\\n                }\\n            }\\n\\n\\n            else{\\n                if(capacityA < plants[i] && capacityB < plants[i] ){\\n                    refill++;\\n                    return refill;\\n                }\\n                \\n            }\\n            \\n        }\\n\\n        return refill;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int n = plants.size(); \\n        int A = capacityA;\\n        int B = capacityB;\\n        int i=0;\\n        int j=n-1;\\n        int refill = 0;\\n        while(i<j){\\n            if(plants[i]<=capacityA){\\n            capacityA = capacityA - plants[i];\\n            i++;\\n            }\\n            else{\\n                refill++;\\n                capacityA = A;\\n                capacityA = capacityA - plants[i];\\n                i++;\\n            }\\n\\n            if(plants[j]<=capacityB){\\n            capacityB = capacityB - plants[j];\\n            j--;\\n            }\\n            else{\\n                refill++;\\n                capacityB = B;\\n                capacityB = capacityB - plants[j];\\n                j--;\\n            }\\n  \\n        }\\n\\n        if(i==j){\\n            if(capacityA == capacityB){\\n                if(capacityA >= plants[i]){\\n                capacityA = capacityA - plants[i];\\n                return refill ;}\\n                else{\\n                    refill++;\\n                    return refill ;\\n                }\\n\\n\\n                if(capacityB >= plants[i]){\\n                capacityB = capacityB - plants[i];\\n                return refill ;}\\n                else{\\n                    refill++;\\n                    return refill ;\\n                }\\n            }\\n\\n\\n            else{\\n                if(capacityA < plants[i] && capacityB < plants[i] ){\\n                    refill++;\\n                    return refill;\\n                }\\n                \\n            }\\n            \\n        }\\n\\n        return refill;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975978,
                "title": "java-optimum-solution-beats-98-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,tempcapA=capacityA,tempcapB=capacityB;\\n        int refilA=0,refilB=0;\\n        while(i<j){\\n\\n                if(plants[i]>tempcapA){\\n                    tempcapA=capacityA;\\n                    refilA++;\\n                }\\n                \\n                if(plants[j]>tempcapB){\\n                    tempcapB=capacityB;\\n                    refilB++;\\n                }\\n\\n                tempcapA-=plants[i];\\n                tempcapB-=plants[j];\\n                i++;\\n                j--;\\n        \\n        }\\n        \\n        if(i==j){\\n            if(tempcapA<plants[i] && tempcapB<plants[j])\\n                refilA++;    \\n        }\\n\\n        return refilA+refilB;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,tempcapA=capacityA,tempcapB=capacityB;\\n        int refilA=0,refilB=0;\\n        while(i<j){\\n\\n                if(plants[i]>tempcapA){\\n                    tempcapA=capacityA;\\n                    refilA++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2975870,
                "title": "java-optimum-solution-beats-98-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,tempcapA=capacityA,tempcapB=capacityB;\\n        int refilA=0,refilB=0;\\n        while(i<=j){\\n            if(i!=j){\\n                if(plants[i]>tempcapA){\\n                    tempcapA=capacityA;\\n                    tempcapA-=plants[i];\\n                    refilA++;\\n                }\\n                else\\n                    tempcapA-=plants[i];\\n                \\n                if(plants[j]>tempcapB){\\n                    tempcapB=capacityB;\\n                    tempcapB-=plants[j];\\n                    refilB++;\\n                }\\n                else\\n                    tempcapB-=plants[j];\\n                i++;\\n                j--;\\n            }\\n            else{\\n                if(Math.max(tempcapA,tempcapB)<plants[i]){\\n                    refilA++;\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return refilA+refilB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0,j=plants.length-1,tempcapA=capacityA,tempcapB=capacityB;\\n        int refilA=0,refilB=0;\\n        while(i<=j){\\n            if(i!=j){\\n                if(plants[i]>tempcapA){\\n                    tempcapA=capacityA;\\n                    tempcapA-=plants[i];\\n                    refilA++;\\n                }\\n                else\\n                    tempcapA-=plants[i];\\n                \\n                if(plants[j]>tempcapB){\\n                    tempcapB=capacityB;\\n                    tempcapB-=plants[j];\\n                    refilB++;\\n                }\\n                else\\n                    tempcapB-=plants[j];\\n                i++;\\n                j--;\\n            }\\n            else{\\n                if(Math.max(tempcapA,tempcapB)<plants[i]){\\n                    refilA++;\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return refilA+refilB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974695,
                "title": "100-faster-and-100-less-memory-easy-and-simple-ts-js",
                "content": "\\n\\n# Code\\n```\\nfunction minimumRefill(plants: number[], capacityA: number, capacityB: number): number {\\n    let alice_pos: number = 0;\\n    let alice_water: number = capacityA;\\n    \\n    let bob_water: number = capacityB;\\n    let bob_pos: number = plants.length-1;\\n    \\n    let count_refill: number = 0;\\n    // divide it by two\\n    for (let i = 0; i < Math.floor(plants.length/2); i += 1){\\n        if (plants[alice_pos] <= alice_water){\\n            alice_water -= plants[alice_pos];\\n            alice_pos += 1;\\n        }else{\\n            count_refill += 1;\\n            alice_water = capacityA;\\n            alice_water -= plants[alice_pos];\\n            alice_pos += 1;\\n        }\\n        if (plants[bob_pos] <= bob_water){\\n            bob_water -= plants[bob_pos];\\n            bob_pos -= 1;\\n        }else{\\n            count_refill += 1;\\n            bob_water = capacityB;\\n            bob_water -= plants[bob_pos];\\n            bob_pos -= 1;\\n        }\\n    }\\n    if (plants.length % 2 === 0) return count_refill;\\n    // below if the length of the plants\\n    // is odd, so alice and bob\\n    // will always meet in the middle\\n    const mid_plant_pos: number = Math.floor(plants.length/2);\\n    if (alice_water < plants[mid_plant_pos] && bob_water < plants[mid_plant_pos]){ \\n        // if both alice and bob dont have enough water to water the plant\\n        count_refill += 1;\\n    } \\n    return count_refill;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nfunction minimumRefill(plants: number[], capacityA: number, capacityB: number): number {\\n    let alice_pos: number = 0;\\n    let alice_water: number = capacityA;\\n    \\n    let bob_water: number = capacityB;\\n    let bob_pos: number = plants.length-1;\\n    \\n    let count_refill: number = 0;\\n    // divide it by two\\n    for (let i = 0; i < Math.floor(plants.length/2); i += 1){\\n        if (plants[alice_pos] <= alice_water){\\n            alice_water -= plants[alice_pos];\\n            alice_pos += 1;\\n        }else{\\n            count_refill += 1;\\n            alice_water = capacityA;\\n            alice_water -= plants[alice_pos];\\n            alice_pos += 1;\\n        }\\n        if (plants[bob_pos] <= bob_water){\\n            bob_water -= plants[bob_pos];\\n            bob_pos -= 1;\\n        }else{\\n            count_refill += 1;\\n            bob_water = capacityB;\\n            bob_water -= plants[bob_pos];\\n            bob_pos -= 1;\\n        }\\n    }\\n    if (plants.length % 2 === 0) return count_refill;\\n    // below if the length of the plants\\n    // is odd, so alice and bob\\n    // will always meet in the middle\\n    const mid_plant_pos: number = Math.floor(plants.length/2);\\n    if (alice_water < plants[mid_plant_pos] && bob_water < plants[mid_plant_pos]){ \\n        // if both alice and bob dont have enough water to water the plant\\n        count_refill += 1;\\n    } \\n    return count_refill;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2944433,
                "title": "most-easy-and-bets-approach-c-100-faster",
                "content": "```\\nint minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int initial_a=capacityA;\\n        int initial_b=capacityB;\\n        int a=0,b=plants.size()-1;\\n        int count=0;\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(capacityA<plants[a] && capacityB<plants[a])\\n                {\\n                    count++;\\n                }\\n                a++;\\n                b--;\\n            }\\n            else\\n            {\\n                if(plants[a]>capacityA)\\n                {\\n                    count++;\\n                    capacityA=initial_a;\\n                    capacityA-=plants[a];\\n                    a++;\\n                }\\n                else\\n                {\\n                    capacityA-=plants[a];\\n                    a++;\\n                }\\n                if(plants[b]>capacityB)\\n                {\\n                    count++;\\n                    capacityB=initial_b;\\n                    capacityB-=plants[b];\\n                    b--;\\n                }\\n                else\\n                {\\n                    capacityB-=plants[b];\\n                    b--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int initial_a=capacityA;\\n        int initial_b=capacityB;\\n        int a=0,b=plants.size()-1;\\n        int count=0;\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(capacityA<plants[a] && capacityB<plants[a])\\n                {\\n                    count++;\\n                }\\n                a++;\\n                b--;\\n            }\\n            else\\n            {\\n                if(plants[a]>capacityA)\\n                {\\n                    count++;\\n                    capacityA=initial_a;\\n                    capacityA-=plants[a];\\n                    a++;\\n                }\\n                else\\n                {\\n                    capacityA-=plants[a];\\n                    a++;\\n                }\\n                if(plants[b]>capacityB)\\n                {\\n                    count++;\\n                    capacityB=initial_b;\\n                    capacityB-=plants[b];\\n                    b--;\\n                }\\n                else\\n                {\\n                    capacityB-=plants[b];\\n                    b--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2936326,
                "title": "simple-java-solution-with-while-loop-using-if-else",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] arr, int capacityA, int capacityB) {\\n         \\n        int alice =capacityA;\\n        int bob =capacityB;\\n\\n        int start=0;\\n        int end =arr.length-1;\\n        int refil =0;\\n\\n        while(start<=end){\\n            if(start==end){\\n                if(arr[start]>alice && arr[end]>bob){\\n                    refil++;\\n                }\\n                break;\\n            }\\n            if(arr[start]>alice){\\n                refil++;\\n                alice =capacityA;\\n            }\\n                alice-=arr[start];\\n                start++;\\n            if(arr[end]>bob){\\n                refil++;\\n                bob=capacityB;\\n            }\\n            bob -=arr[end];\\n            end--;\\n        }\\n        return refil;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] arr, int capacityA, int capacityB) {\\n         \\n        int alice =capacityA;\\n        int bob =capacityB;\\n\\n        int start=0;\\n        int end =arr.length-1;\\n        int refil =0;\\n\\n        while(start<=end){\\n            if(start==end){\\n                if(arr[start]>alice && arr[end]>bob){\\n                    refil++;\\n                }\\n                break;\\n            }\\n            if(arr[start]>alice){\\n                refil++;\\n                alice =capacityA;\\n            }\\n                alice-=arr[start];\\n                start++;\\n            if(arr[end]>bob){\\n                refil++;\\n                bob=capacityB;\\n            }\\n            bob -=arr[end];\\n            end--;\\n        }\\n        return refil;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933396,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length;\\n        int left = 0;\\n        int right = n - 1;\\n        int a = capacityA;\\n        int b = capacityB;\\n        int refil = 0;\\n        while(left <= right){\\n            if(left == right){\\n                if(a > b){\\n                    // Alice\\n                    int waterA = plants[left];\\n                    if(waterA > a){\\n                        a = capacityA;\\n                        refil++;\\n                    }\\n                    a -= waterA;\\n                } else if(b > a){\\n                    // Bob\\n                    int waterB = plants[right];\\n                    if(waterB > b){\\n                        b = capacityB;\\n                        refil++;\\n                    }\\n                    b -= waterB;\\n                } else {\\n                    // Alice\\n                    int waterA = plants[left];\\n                    if(waterA > a){\\n                        a = capacityA;\\n                        refil++;\\n                    }\\n                    a -= waterA;\\n                }\\n            } else {\\n                int waterA = plants[left];\\n                if(waterA > a){\\n                    a = capacityA;\\n                    refil++;\\n                }\\n                a -= waterA;\\n                int waterB = plants[right];\\n                if(waterB > b){\\n                    b = capacityB;\\n                    refil++;\\n                }\\n                b -= waterB;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return refil;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length;\\n        int left = 0;\\n        int right = n - 1;\\n        int a = capacityA;\\n        int b = capacityB;\\n        int refil = 0;\\n        while(left <= right){\\n            if(left == right){\\n                if(a > b){\\n                    // Alice\\n                    int waterA = plants[left];\\n                    if(waterA > a){\\n                        a = capacityA;\\n                        refil++;\\n                    }\\n                    a -= waterA;\\n                } else if(b > a){\\n                    // Bob\\n                    int waterB = plants[right];\\n                    if(waterB > b){\\n                        b = capacityB;\\n                        refil++;\\n                    }\\n                    b -= waterB;\\n                } else {\\n                    // Alice\\n                    int waterA = plants[left];\\n                    if(waterA > a){\\n                        a = capacityA;\\n                        refil++;\\n                    }\\n                    a -= waterA;\\n                }\\n            } else {\\n                int waterA = plants[left];\\n                if(waterA > a){\\n                    a = capacityA;\\n                    refil++;\\n                }\\n                a -= waterA;\\n                int waterB = plants[right];\\n                if(waterB > b){\\n                    b = capacityB;\\n                    refil++;\\n                }\\n                b -= waterB;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return refil;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919173,
                "title": "watering-plants-ii-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int cA, int cB) {\\n        int refill=0;\\n        int n=plants.size();\\n\\n        int c1=cA; //Alice\\n        int c2=cB; //Bob\\n\\n        int i=0;\\n        int j=n-1;\\n\\n        while(i<j){\\n                if(c1>=plants[i]){\\n                    c1-=plants[i];\\n                }\\n                else{\\n                    c1=cA;\\n                    c1-=plants[i];\\n                    refill++;\\n                }\\n\\n                if(c2>=plants[j]){\\n                    c2-=plants[j];\\n                }\\n                else{\\n                    c2=cB;\\n                    c2-=plants[j];\\n                    refill++;\\n                }\\n                i++;\\n                j--;\\n        }\\n\\n        if(i==j){\\n            if(max(c1,c2)<plants[i])\\n                refill++;\\n        }\\n        \\n        return refill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int cA, int cB) {\\n        int refill=0;\\n        int n=plants.size();\\n\\n        int c1=cA; //Alice\\n        int c2=cB; //Bob\\n\\n        int i=0;\\n        int j=n-1;\\n\\n        while(i<j){\\n                if(c1>=plants[i]){\\n                    c1-=plants[i];\\n                }\\n                else{\\n                    c1=cA;\\n                    c1-=plants[i];\\n                    refill++;\\n                }\\n\\n                if(c2>=plants[j]){\\n                    c2-=plants[j];\\n                }\\n                else{\\n                    c2=cB;\\n                    c2-=plants[j];\\n                    refill++;\\n                }\\n                i++;\\n                j--;\\n        }\\n\\n        if(i==j){\\n            if(max(c1,c2)<plants[i])\\n                refill++;\\n        }\\n        \\n        return refill;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912093,
                "title": "java-two-pointer-approach",
                "content": "# Code\\n```\\nclass Solution {\\n  public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n    int n = plants.length;\\n    int count = 0;\\n    int pA = 0, pB = n - 1;\\n    int leftA = capacityA, leftB = capacityB;\\n    while (pA < pB) {\\n      // enough water\\n      if (leftA >= plants[pA])\\n        leftA -= plants[pA];\\n      else {\\n        count++;\\n        leftA = capacityA - plants[pA];\\n      }\\n      pA++;\\n\\n      if (leftB >= plants[pB])\\n        leftB -= plants[pB];\\n      else {\\n        count++;\\n        leftB = capacityB - plants[pB];\\n      }\\n      pB--;\\n    }\\n\\n    // meet on same plant\\n    if (pA == pB) {\\n      int left = Math.max(leftA, leftB);\\n      if (left < plants[pA])\\n        count++;\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n    int n = plants.length;\\n    int count = 0;\\n    int pA = 0, pB = n - 1;\\n    int leftA = capacityA, leftB = capacityB;\\n    while (pA < pB) {\\n      // enough water\\n      if (leftA >= plants[pA])\\n        leftA -= plants[pA];\\n      else {\\n        count++;\\n        leftA = capacityA - plants[pA];\\n      }\\n      pA++;\\n\\n      if (leftB >= plants[pB])\\n        leftB -= plants[pB];\\n      else {\\n        count++;\\n        leftB = capacityB - plants[pB];\\n      }\\n      pB--;\\n    }\\n\\n    // meet on same plant\\n    if (pA == pB) {\\n      int left = Math.max(leftA, leftB);\\n      if (left < plants[pA])\\n        count++;\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898680,
                "title": "c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int N = plants.size(), i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        // Iterate over all plants left and right one similutaneously.\\n        while (i <= j) {\\n            \\n            // We have reached middle plant.\\n            if (i == j) { \\n                // The one with more water in can will water the plant.\\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        // Alice need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        // Bob need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                // If Alice doesn\\'t have sufficient water, she refills.\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                \\n                // Alice waters.\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                // If Bob doesn\\'t have sufficient water, he refills.\\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                \\n                // Bob waters.\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        return totalFills;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int N = plants.size(), i = 0, j = N - 1;\\n        \\n        if (N == 1) return 0;\\n        \\n        int totalFills = 0; \\n        int aliceCan = capacityA, bobCan = capacityB; \\n        \\n        // Iterate over all plants left and right one similutaneously.\\n        while (i <= j) {\\n            \\n            // We have reached middle plant.\\n            if (i == j) { \\n                // The one with more water in can will water the plant.\\n                if (aliceCan >= bobCan) {\\n                    if (aliceCan < plants[i]) {\\n                        // Alice need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    ++i;\\n                }\\n                else {\\n                    if (bobCan < plants[j]) {\\n                        // Bob need to refill the can.\\n                        ++totalFills;\\n                    }\\n                    --j;\\n                }\\n            } \\n            \\n            else {\\n                // If Alice doesn\\'t have sufficient water, she refills.\\n                if (aliceCan < plants[i]) {\\n                    aliceCan = capacityA;\\n                    ++totalFills;\\n                }\\n                \\n                // Alice waters.\\n                aliceCan -= plants[i];\\n                ++i;\\n                \\n                // If Bob doesn\\'t have sufficient water, he refills.\\n                if (bobCan < plants[j]) {\\n                    bobCan = capacityB; \\n                    ++totalFills;\\n                }\\n                \\n                // Bob waters.\\n                bobCan -= plants[j];\\n                --j;\\n            }\\n        }\\n        return totalFills;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888325,
                "title": "c-simple-solution",
                "content": "**Please upvote if my solution was helpful ;)**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MinimumRefill(int[] plants, int capacityA, int capacityB) \\n    {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int output = 0;\\n        for(int i = 0; i <= (plants.Length - 1)/2 ; i++)\\n        {\\n            //In case both Alice and Bob reach the same plant\\n            if(i == plants.Length - 1 - i)\\n            {\\n                if(plants[i] > Math.Max(canA, canB))\\n                {\\n                    output++;\\n                }\\n                break;\\n            }\\n            //Alice waters from the left to the right\\n            if(plants[i] > canA)\\n            {\\n                //refill\\n                output++;\\n                //water the plant\\n                canA = capacityA - plants[i];\\n            }else\\n            {\\n                //water the plant\\n                canA -= plants[i];\\n            }\\n            //Bob waters from the right to the left\\n            if(plants[plants.Length - 1 - i] > canB)\\n            {\\n                //refill\\n                output++;\\n                //water the plant\\n                canB = capacityB - plants[plants.Length - 1 - i];\\n            }else\\n            {\\n                //water the plant\\n                canB -= plants[plants.Length - 1 - i];\\n            }\\n\\n        }\\n\\n        return output;\\n    }\\n}\\n```\\n# The same code but using while loop\\n\\n```\\npublic class Solution \\n{\\n    public int MinimumRefill(int[] plants, int capacityA, int capacityB) \\n    {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int output = 0;\\n        int a = 0;\\n        int b = plants.Length - 1;\\n        while(a<=b)\\n        {\\n           if(a == b)\\n            {\\n                if(plants[a] > Math.Max(canA, canB))\\n                {\\n                    output++;\\n                }\\n                break;\\n            }\\n\\n            if(plants[a] > canA)\\n            {\\n                output++;\\n                canA = capacityA - plants[a];\\n            }else\\n            {\\n                canA -= plants[a];\\n            }\\n            if(plants[b] > canB)\\n            {\\n                output++;\\n                canB = capacityB - plants[b];\\n            }else\\n            {\\n                canB -= plants[b];\\n            }\\n            a++;\\n            b--;\\n\\n        }\\n\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimumRefill(int[] plants, int capacityA, int capacityB) \\n    {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int output = 0;\\n        for(int i = 0; i <= (plants.Length - 1)/2 ; i++)\\n        {\\n            //In case both Alice and Bob reach the same plant\\n            if(i == plants.Length - 1 - i)\\n            {\\n                if(plants[i] > Math.Max(canA, canB))\\n                {\\n                    output++;\\n                }\\n                break;\\n            }\\n            //Alice waters from the left to the right\\n            if(plants[i] > canA)\\n            {\\n                //refill\\n                output++;\\n                //water the plant\\n                canA = capacityA - plants[i];\\n            }else\\n            {\\n                //water the plant\\n                canA -= plants[i];\\n            }\\n            //Bob waters from the right to the left\\n            if(plants[plants.Length - 1 - i] > canB)\\n            {\\n                //refill\\n                output++;\\n                //water the plant\\n                canB = capacityB - plants[plants.Length - 1 - i];\\n            }else\\n            {\\n                //water the plant\\n                canB -= plants[plants.Length - 1 - i];\\n            }\\n\\n        }\\n\\n        return output;\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int MinimumRefill(int[] plants, int capacityA, int capacityB) \\n    {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int output = 0;\\n        int a = 0;\\n        int b = plants.Length - 1;\\n        while(a<=b)\\n        {\\n           if(a == b)\\n            {\\n                if(plants[a] > Math.Max(canA, canB))\\n                {\\n                    output++;\\n                }\\n                break;\\n            }\\n\\n            if(plants[a] > canA)\\n            {\\n                output++;\\n                canA = capacityA - plants[a];\\n            }else\\n            {\\n                canA -= plants[a];\\n            }\\n            if(plants[b] > canB)\\n            {\\n                output++;\\n                canB = capacityB - plants[b];\\n            }else\\n            {\\n                canB -= plants[b];\\n            }\\n            a++;\\n            b--;\\n\\n        }\\n\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863062,
                "title": "java-easy-solution",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int minimumRefill(int[] plants, int A, int B) {\\n        int i=0;\\n        int j=plants.length-1;\\n        int k=0;\\n        int a=A;\\n        int b=B;\\n        int count=0;\\n        while(k<plants.length)\\n        {\\n            if(i==j)\\n            {\\n              if(A>B)\\n              {\\n                  if(A<plants[i])\\n                  {\\n                      count++;\\n                      A=a;\\n                  }\\n                  A=A-plants[i];\\n                  i++;\\n              }\\n              else if(B>A)\\n              {\\n                  if(B<plants[i])\\n                  {\\n                      B=b;\\n                      count++;\\n                  }\\n                  B=B-plants[i];\\n                  j--;\\n              }\\n                else\\n                {\\n                    if(A<plants[i])\\n                  {\\n                      count++;\\n                      A=a;\\n                  }\\n                    A=A-plants[i];\\n                    i++;\\n                }\\n                k++;\\n                continue;\\n            }\\n            if(A>=plants[i])\\n            {\\n               A=A-plants[i];\\n                i++;\\n                k++;\\n            }\\n            else\\n            {\\n                A=a;\\n                A=A-plants[i];\\n                i++;\\n                k++;\\n                count++;\\n            }\\n            if(B>=plants[j])\\n            {\\n                B=B-plants[j];\\n                j--;\\n                k++;\\n            }\\n             else\\n            {\\n                B=b;\\n                B=B-plants[j];\\n                j--;\\n                k++; \\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int minimumRefill(int[] plants, int A, int B) {\\n        int i=0;\\n        int j=plants.length-1;\\n        int k=0;\\n        int a=A;\\n        int b=B;\\n        int count=0;\\n        while(k<plants.length)\\n        {\\n            if(i==j)\\n            {\\n              if(A>B)\\n              {\\n                  if(A<plants[i])\\n                  {\\n                      count++;\\n                      A=a;\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 2860648,
                "title": "simple-java-code-with-explanation-and-readable-code",
                "content": "\\n\\n# Approach\\nWe  take alice water as initial alice\\'s can capacity and bob water as bob\\'s can capacity. We just simply reduce the water as they water if they have enough water. Using two pointer from left and right since both take same time to water each plant.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        \\n        int len = plants.length;\\n\\n        int aliceWater = capacityA;\\n        int bobWater = capacityB;\\n\\n        int aliceInd = 0;\\n        int bobInd = len-1;\\n        int refillCounts = 0;\\n        while(aliceInd < bobInd){\\n            if(plants[aliceInd] <= aliceWater){\\n                aliceWater = aliceWater - plants[aliceInd];\\n               \\n            }\\n            else{\\n                aliceWater = capacityA - plants[aliceInd];\\n                refillCounts++;\\n            }\\n\\n            if(plants[bobInd] <= bobWater){\\n                bobWater = bobWater - plants[bobInd];\\n               \\n            }\\n            else{\\n                bobWater = capacityB - plants[bobInd];\\n                refillCounts++;\\n            }\\n\\n            aliceInd++;\\n            bobInd--;\\n        }\\n        if(aliceInd == bobInd){\\n            if((bobWater == aliceWater || aliceWater > bobWater) && plants[aliceInd] > aliceWater){\\n                   refillCounts++;\\n            }\\n            else if (bobWater > aliceWater  && plants[bobInd] > bobWater){\\n                refillCounts++;\\n            }\\n        }\\n        return refillCounts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        \\n        int len = plants.length;\\n\\n        int aliceWater = capacityA;\\n        int bobWater = capacityB;\\n\\n        int aliceInd = 0;\\n        int bobInd = len-1;\\n        int refillCounts = 0;\\n        while(aliceInd < bobInd){\\n            if(plants[aliceInd] <= aliceWater){\\n                aliceWater = aliceWater - plants[aliceInd];\\n               \\n            }\\n            else{\\n                aliceWater = capacityA - plants[aliceInd];\\n                refillCounts++;\\n            }\\n\\n            if(plants[bobInd] <= bobWater){\\n                bobWater = bobWater - plants[bobInd];\\n               \\n            }\\n            else{\\n                bobWater = capacityB - plants[bobInd];\\n                refillCounts++;\\n            }\\n\\n            aliceInd++;\\n            bobInd--;\\n        }\\n        if(aliceInd == bobInd){\\n            if((bobWater == aliceWater || aliceWater > bobWater) && plants[aliceInd] > aliceWater){\\n                   refillCounts++;\\n            }\\n            else if (bobWater > aliceWater  && plants[bobInd] > bobWater){\\n                refillCounts++;\\n            }\\n        }\\n        return refillCounts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847731,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        n = len(plants)\\n        \\n        alice = 0\\n        bob = n - 1\\n        \\n        alicesCan = capacityA\\n        bobsCan = capacityB\\n        \\n        answer = 0        \\n        while alice < bob:\\n            # Alice\\n            if alicesCan >= plants[alice]:\\n                alicesCan -= plants[alice]\\n            else:\\n                alicesCan = capacityA - plants[alice]\\n                answer += 1\\n            # Bob\\n            if bobsCan >= plants[bob]:\\n                bobsCan -= plants[bob]\\n            else:\\n                bobsCan = capacityB - plants[bob]\\n                answer += 1\\n            alice += 1\\n            bob -= 1\\n            \\n        if n % 2 == 1:\\n            # Alice\\n            if max(alicesCan, bobsCan) < plants[alice]:\\n                answer += 1\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        n = len(plants)\\n        \\n        alice = 0\\n        bob = n - 1\\n        \\n        alicesCan = capacityA\\n        bobsCan = capacityB\\n        \\n        answer = 0        \\n        while alice < bob:\\n            # Alice\\n            if alicesCan >= plants[alice]:\\n                alicesCan -= plants[alice]\\n            else:\\n                alicesCan = capacityA - plants[alice]\\n                answer += 1\\n            # Bob\\n            if bobsCan >= plants[bob]:\\n                bobsCan -= plants[bob]\\n            else:\\n                bobsCan = capacityB - plants[bob]\\n                answer += 1\\n            alice += 1\\n            bob -= 1\\n            \\n        if n % 2 == 1:\\n            # Alice\\n            if max(alicesCan, bobsCan) < plants[alice]:\\n                answer += 1\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842982,
                "title": "two-pointer-rust-solution-o-n-time-o-1-space",
                "content": "```\\nuse std::cmp;\\n\\nimpl Solution {\\n    \\n    // O(n) time,\\n    // O(1) space,\\n    // Approach: simulation, two pointers, array\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        \\n        let mut curr_a: i32 = capacity_a;\\n        let mut curr_b: i32 = capacity_b;\\n        \\n        let mut refills: i32 = 0;\\n        \\n        let mut left = 0 as usize;\\n        let mut right = plants.len()-1;\\n        \\n        \\n        while left <= right {\\n            \\n            if left == right {\\n                if cmp::max(curr_a, curr_b) < plants[left] {\\n                    refills += 1;\\n                }\\n                break;\\n            }\\n            \\n            if curr_a < plants[left] {\\n                refills += 1;\\n                curr_a = capacity_a;\\n            }\\n            curr_a -= plants[left];\\n            \\n            if curr_b < plants[right] {\\n                refills += 1;\\n                curr_b = capacity_b;\\n            }\\n            curr_b -= plants[right];\\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return refills;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nuse std::cmp;\\n\\nimpl Solution {\\n    \\n    // O(n) time,\\n    // O(1) space,\\n    // Approach: simulation, two pointers, array\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        \\n        let mut curr_a: i32 = capacity_a;\\n        let mut curr_b: i32 = capacity_b;\\n        \\n        let mut refills: i32 = 0;\\n        \\n        let mut left = 0 as usize;\\n        let mut right = plants.len()-1;\\n        \\n        \\n        while left <= right {\\n            \\n            if left == right {\\n                if cmp::max(curr_a, curr_b) < plants[left] {\\n                    refills += 1;\\n                }\\n                break;\\n            }\\n            \\n            if curr_a < plants[left] {\\n                refills += 1;\\n                curr_a = capacity_a;\\n            }\\n            curr_a -= plants[left];\\n            \\n            if curr_b < plants[right] {\\n                refills += 1;\\n                curr_b = capacity_b;\\n            }\\n            curr_b -= plants[right];\\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return refills;\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2842490,
                "title": "c-solution-beginner-friendly",
                "content": "``` For better understanding first solve \" Watering plants \".```\\n\\n``` You can check out my solution of \" Watering plants \" (https://leetcode.com/problems/watering-plants/discuss/2842379/c-solution-very-easy-solution-beginner-friendly).```\\n\\n``` Time complexity :- O(n) where n is size of the array.```\\n``` Auxiliary space :- O(1).```\\n```\\n int minimumRefill(vector<int>& a, int capA, int capB) {\\n        int n=a.size();\\n        int res=0,c1=capA,c2=capB,i=0,j=n-1;\\n        if(n%2!=0)\\n        {\\n            while(i<j)\\n            {\\n                if(c1<a[i])\\n                {\\n                    res+=1;\\n                    c1=capA;\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                else\\n                {\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                if(c2<a[j])\\n                {\\n                    res+=1;\\n                    c2=capB;\\n                    c2-=a[j];\\n                    j--;\\n                }\\n                else\\n                {\\n                    c2-=a[j];\\n                    j--;\\n                }\\n            }\\n            if(i==j)\\n            {\\n                int p=max(c1,c2);\\n                if(p<a[i])\\n                    res+=1;\\n            }\\n        }\\n        else\\n        {\\n            while(i<j)\\n            {\\n                if(c1<a[i])\\n                {\\n                    res+=1;\\n                    c1=capA;\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                else\\n                {\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                if(c2<a[j])\\n                {\\n                    res+=1;\\n                    c2=capB;\\n                    c2-=a[j];\\n                    j--;\\n                }\\n                else\\n                {\\n                    c2-=a[j];\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n``` If you like my approach then please upvote me.```\\n\\n",
                "solutionTags": [],
                "code": "``` For better understanding first solve \" Watering plants \".```\n``` You can check out my solution of \" Watering plants \" (https://leetcode.com/problems/watering-plants/discuss/2842379/c-solution-very-easy-solution-beginner-friendly).```\n``` Time complexity :- O(n) where n is size of the array.```\n``` Auxiliary space :- O(1).```\n```\\n int minimumRefill(vector<int>& a, int capA, int capB) {\\n        int n=a.size();\\n        int res=0,c1=capA,c2=capB,i=0,j=n-1;\\n        if(n%2!=0)\\n        {\\n            while(i<j)\\n            {\\n                if(c1<a[i])\\n                {\\n                    res+=1;\\n                    c1=capA;\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                else\\n                {\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                if(c2<a[j])\\n                {\\n                    res+=1;\\n                    c2=capB;\\n                    c2-=a[j];\\n                    j--;\\n                }\\n                else\\n                {\\n                    c2-=a[j];\\n                    j--;\\n                }\\n            }\\n            if(i==j)\\n            {\\n                int p=max(c1,c2);\\n                if(p<a[i])\\n                    res+=1;\\n            }\\n        }\\n        else\\n        {\\n            while(i<j)\\n            {\\n                if(c1<a[i])\\n                {\\n                    res+=1;\\n                    c1=capA;\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                else\\n                {\\n                    c1-=a[i];\\n                    i++;\\n                }\\n                if(c2<a[j])\\n                {\\n                    res+=1;\\n                    c2=capB;\\n                    c2-=a[j];\\n                    j--;\\n                }\\n                else\\n                {\\n                    c2-=a[j];\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n``` If you like my approach then please upvote me.```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831022,
                "title": "using-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int a, int b) {\\n        int i=0;\\n        int j=p.size()-1;\\n        int oa=a;\\n        int ob=b;\\n        int res=0;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(a>=b)\\n                {\\n                    if(a>=p[i])\\n                    {\\n                        a=a-p[i];\\n                        i++;\\n                    }\\n                    else \\n                    {\\n                        res++;\\n                        a=oa;\\n                        a=a-p[i];\\n                        i++;\\n                    }\\n                }\\n                else \\n                {\\n                    if(b>=p[j])\\n                    {\\n                        b=b-p[j];\\n                        j--;\\n                    }\\n                    else \\n                    {\\n                        res++;\\n                        b=ob;\\n                        b=b-p[j];\\n                        j--;\\n                    }\\n                }\\n            }\\n            else \\n            {\\n                if(a>=p[i])\\n                {\\n                    a=a-p[i];\\n                    i++;\\n                }\\n                else \\n                {\\n                    res++;\\n                    a=oa;\\n                    a=a-p[i];\\n                    i++;\\n                }\\n                if(b>=p[j])\\n                {\\n                    b=b-p[j];\\n                    j--;\\n                }\\n                else \\n                {\\n                    res++;\\n                    b=ob;\\n                    b=b-p[j];\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int a, int b) {\\n        int i=0;\\n        int j=p.size()-1;\\n        int oa=a;\\n        int ob=b;\\n        int res=0;\\n        while(i<=j)\\n        {\\n            if(i==j)\\n            {\\n                if(a>=b)\\n                {\\n                    if(a>=p[i])\\n                    {\\n                        a=a-p[i];\\n                        i++;\\n                    }\\n                    else \\n                    {\\n                        res++;\\n                        a=oa;\\n                        a=a-p[i];\\n                        i++;\\n                    }\\n                }\\n                else \\n                {\\n                    if(b>=p[j])\\n                    {\\n                        b=b-p[j];\\n                        j--;\\n                    }\\n                    else \\n                    {\\n                        res++;\\n                        b=ob;\\n                        b=b-p[j];\\n                        j--;\\n                    }\\n                }\\n            }\\n            else \\n            {\\n                if(a>=p[i])\\n                {\\n                    a=a-p[i];\\n                    i++;\\n                }\\n                else \\n                {\\n                    res++;\\n                    a=oa;\\n                    a=a-p[i];\\n                    i++;\\n                }\\n                if(b>=p[j])\\n                {\\n                    b=b-p[j];\\n                    j--;\\n                }\\n                else \\n                {\\n                    res++;\\n                    b=ob;\\n                    b=b-p[j];\\n                    j--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753260,
                "title": "python-3-o-n-two-pointers",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capA: int, capB: int) -> int:\\n        res = 0\\n        n = len(plants)\\n        wa, wb = capA, capB\\n        \\n        for i in range(n // 2):\\n            if plants[i] > wa:\\n                res += 1\\n                wa = capA\\n            wa -= plants[i]\\n            \\n            if plants[n - i - 1] > wb:\\n                res += 1\\n                wb = capB\\n            wb -= plants[n - i - 1]\\n\\n        if n & 1:\\n            if wa == wb or wa > wb:\\n                if plants[n // 2] > wa:\\n                    res += 1\\n            elif wa < wb:\\n                if plants[n // 2] > wb:\\n                    res += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capA: int, capB: int) -> int:\\n        res = 0\\n        n = len(plants)\\n        wa, wb = capA, capB\\n        \\n        for i in range(n // 2):\\n            if plants[i] > wa:\\n                res += 1\\n                wa = capA\\n            wa -= plants[i]\\n            \\n            if plants[n - i - 1] > wb:\\n                res += 1\\n                wb = capB\\n            wb -= plants[n - i - 1]\\n\\n        if n & 1:\\n            if wa == wb or wa > wb:\\n                if plants[n // 2] > wa:\\n                    res += 1\\n            elif wa < wb:\\n                if plants[n // 2] > wb:\\n                    res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729034,
                "title": "javascript-watering-plants-ii",
                "content": "Runtime: 126 ms, faster than 74.07% of JavaScript online submissions for Watering Plants II.\\nMemory Usage: 53.6 MB, less than 88.89% of JavaScript online submissions for Watering Plants II.\\n```\\nvar minimumRefill = function (plants, capacityA, capacityB) {\\n  let l = 0;\\n  let r = plants.length - 1;\\n  let res = 0;\\n  let cA = capacityA;\\n  let cB = capacityB;\\n\\n  while (l < r) {\\n    if (cA < plants[l]) {\\n      res += 1;\\n      cA = capacityA;\\n      cA = cA - plants[l];\\n      l += 1;\\n    } else {\\n      cA = cA - plants[l];\\n      l += 1;\\n    }\\n    if (cB < plants[r]) {\\n      res += 1;\\n      cB = capacityB;\\n      cB = cB - plants[r];\\n      r -= 1;\\n    } else {\\n      cB = cB - plants[r];\\n      r -= 1;\\n    }\\n  }\\n  if (plants[l] > cA && l === r && plants[r]>cB) {\\n    res += 1;\\n  }\\n  return res;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar minimumRefill = function (plants, capacityA, capacityB) {\\n  let l = 0;\\n  let r = plants.length - 1;\\n  let res = 0;\\n  let cA = capacityA;\\n  let cB = capacityB;\\n\\n  while (l < r) {\\n    if (cA < plants[l]) {\\n      res += 1;\\n      cA = capacityA;\\n      cA = cA - plants[l];\\n      l += 1;\\n    } else {\\n      cA = cA - plants[l];\\n      l += 1;\\n    }\\n    if (cB < plants[r]) {\\n      res += 1;\\n      cB = capacityB;\\n      cB = cB - plants[r];\\n      r -= 1;\\n    } else {\\n      cB = cB - plants[r];\\n      r -= 1;\\n    }\\n  }\\n  if (plants[l] > cA && l === r && plants[r]>cB) {\\n    res += 1;\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719759,
                "title": "ez-python-greedy",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \"\"\"\\n            alice water from L->R (strting 0)\\n            bob water R->L \\n            \\n            return number of times refiling of watercan is required to complete watering all plants\\n        \"\"\"\\n        \\n        A = capacityA\\n        A_ptr = 0\\n        \\n        B = capacityB\\n        B_ptr = len(plants) - 1\\n        \\n        refil = 0\\n        \\n        while A_ptr < B_ptr:\\n            \\n            if A < plants[A_ptr] and A != capacityA:\\n                # we need refill water and we are not already at max capacity\\n                refil += 1\\n                A = capacityA\\n            \\n            if A >= plants[A_ptr]: # now if we can fill this plant lets will\\n                A -= plants[A_ptr]\\n                A_ptr += 1\\n                \\n                \\n            if B < plants[B_ptr] and B != capacityB:\\n                # need refil\\n                refil += 1\\n                B = capacityB\\n            \\n            if B >= plants[B_ptr]:\\n                B -= plants[B_ptr]\\n                B_ptr -= 1\\n        \\n        if len(plants) % 2 !=0:\\n            # odd plants\\n            if B >= plants[A_ptr] or A >= plants[A_ptr]:\\n                # if either have enough water to plant\\n                pass\\n            else:\\n                refil += 1\\n        \\n        \\n        return refil\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \"\"\"\\n            alice water from L->R (strting 0)\\n            bob water R->L \\n            \\n            return number of times refiling of watercan is required to complete watering all plants\\n        \"\"\"\\n        \\n        A = capacityA\\n        A_ptr = 0\\n        \\n        B = capacityB\\n        B_ptr = len(plants) - 1\\n        \\n        refil = 0\\n        \\n        while A_ptr < B_ptr:\\n            \\n            if A < plants[A_ptr] and A != capacityA:\\n                # we need refill water and we are not already at max capacity\\n                refil += 1\\n                A = capacityA\\n            \\n            if A >= plants[A_ptr]: # now if we can fill this plant lets will\\n                A -= plants[A_ptr]\\n                A_ptr += 1\\n                \\n                \\n            if B < plants[B_ptr] and B != capacityB:\\n                # need refil\\n                refil += 1\\n                B = capacityB\\n            \\n            if B >= plants[B_ptr]:\\n                B -= plants[B_ptr]\\n                B_ptr -= 1\\n        \\n        if len(plants) % 2 !=0:\\n            # odd plants\\n            if B >= plants[A_ptr] or A >= plants[A_ptr]:\\n                # if either have enough water to plant\\n                pass\\n            else:\\n                refil += 1\\n        \\n        \\n        return refil\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717928,
                "title": "python3-o-n-time-complexity-two-pointers",
                "content": "This problem can be solved by keeping the following cases in mind:\\n1. Alice and Bob are on different indices\\n2. Alice and Bob are on the same index\\n\\nFor each case, there are only two possbilities:\\n1. The requirement of water is less than the capacity Alice and Bob hold for their respective plant. In this case, subtract the capacity of water poured.\\n2. If the requirement is greater, then refill and increment the count.\\n\\n**NOTE: If Alice and Bob are on the same index, compare the requirement of the plant with the maximum of the capacities Alice and Bob hold at the moment.**\\n```\\n\\t\\ta, b = 0, len(plants) - 1\\n        curr_a, curr_b = capacityA, capacityB\\n        res = 0\\n        while a <= b:\\n\\t\\t\\t#Checking if the can Alice holds has enough water to pour to the plant\\n            if a != b and plants[a] > curr_a:\\n                curr_a = capacityA\\n                res += 1\\n\\t\\t\\t\\n\\t\\t\\t#Checking if the can Bob holds has enough water to pour to the plant\\n            if a != b and plants[b] > curr_b:\\n                curr_b = capacityB\\n                res += 1\\n\\t\\t\\t\\n\\t\\t\\t#If Alice and Bob are on the same index\\n            if a == b:\\n                val = max(curr_a, curr_b)\\n                if plants[a] > val:\\n                    res += 1\\n\\t\\t\\t\\n\\t\\t\\t#Decreasing the water poured from the can\\n            curr_a -= plants[a]\\n            curr_b -= plants[b]\\n            a += 1\\n            b -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\\t\\ta, b = 0, len(plants) - 1\\n        curr_a, curr_b = capacityA, capacityB\\n        res = 0\\n        while a <= b:\\n\\t\\t\\t#Checking if the can Alice holds has enough water to pour to the plant\\n            if a != b and plants[a] > curr_a:\\n                curr_a = capacityA\\n                res += 1\\n\\t\\t\\t\\n\\t\\t\\t#Checking if the can Bob holds has enough water to pour to the plant\\n            if a != b and plants[b] > curr_b:\\n                curr_b = capacityB\\n                res += 1\\n\\t\\t\\t\\n\\t\\t\\t#If Alice and Bob are on the same index\\n            if a == b:\\n                val = max(curr_a, curr_b)\\n                if plants[a] > val:\\n                    res += 1\\n\\t\\t\\t\\n\\t\\t\\t#Decreasing the water poured from the can\\n            curr_a -= plants[a]\\n            curr_b -= plants[b]\\n            a += 1\\n            b -= 1\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2657208,
                "title": "easy-and-simple-c-o-n-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int orig_a = capacityA;\\n        int orig_b = capacityB;\\n        int n = plants.size();\\n        int ref_a = 0;\\n        int ref_b = 0;\\n        int a = 0;\\n        int b = n-1;\\n        while(a<b){\\n            if(capacityA-plants[a]>=0)\\n            {\\n                capacityA = capacityA-plants[a];\\n                a++;\\n            }\\n            else{\\n                ref_a++;\\n                capacityA= orig_a-plants[a];\\n                a++;\\n            }\\n            if(capacityB-plants[b]>=0)\\n            {\\n                capacityB = capacityB-plants[b];\\n                b--;\\n            }\\n            else{\\n                ref_b++;\\n                capacityB= orig_b-plants[b];\\n                b--;\\n            }\\n        }\\n        if(a==b and capacityA>capacityB and capacityA<plants[a]){\\n            ref_a++;\\n        }\\n        else if(a==b && capacityB>capacityA && capacityB<plants[a]){\\n            ref_b++;\\n        }\\n        else if(a==b && capacityA==capacityB){\\n            if(capacityA<plants[a])\\n                ref_a++;\\n        }\\n        return ref_a+ref_b;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int orig_a = capacityA;\\n        int orig_b = capacityB;\\n        int n = plants.size();\\n        int ref_a = 0;\\n        int ref_b = 0;\\n        int a = 0;\\n        int b = n-1;\\n        while(a<b){\\n            if(capacityA-plants[a]>=0)\\n            {\\n                capacityA = capacityA-plants[a];\\n                a++;\\n            }\\n            else{\\n                ref_a++;\\n                capacityA= orig_a-plants[a];\\n                a++;\\n            }\\n            if(capacityB-plants[b]>=0)\\n            {\\n                capacityB = capacityB-plants[b];\\n                b--;\\n            }\\n            else{\\n                ref_b++;\\n                capacityB= orig_b-plants[b];\\n                b--;\\n            }\\n        }\\n        if(a==b and capacityA>capacityB and capacityA<plants[a]){\\n            ref_a++;\\n        }\\n        else if(a==b && capacityB>capacityA && capacityB<plants[a]){\\n            ref_b++;\\n        }\\n        else if(a==b && capacityA==capacityB){\\n            if(capacityA<plants[a])\\n                ref_a++;\\n        }\\n        return ref_a+ref_b;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655022,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::*;\\nimpl Solution {\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        let mut que = plants.into_iter().collect::<VecDeque<i32>>();\\n    \\n        let mut count = 0;\\n        let mut a = capacity_a;\\n        let mut b = capacity_b;\\n        while 1 < que.len() {\\n            let fv = que.pop_front().unwrap();\\n            let bv = que.pop_back().unwrap();\\n    \\n            if a < fv {\\n                a = capacity_a - fv;\\n                count += 1;\\n            } else {\\n                a -= fv;\\n            }\\n    \\n            if b < bv {\\n                b = capacity_b - bv;\\n                count += 1;\\n            } else {\\n                b -= bv;\\n            }\\n        }\\n    \\n        if let Some(v) = que.pop_front() {\\n            if a.max(b) < v {\\n                count + 1\\n            } else {\\n                count\\n            }\\n        } else {\\n            count\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\nimpl Solution {\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        let mut que = plants.into_iter().collect::<VecDeque<i32>>();\\n    \\n        let mut count = 0;\\n        let mut a = capacity_a;\\n        let mut b = capacity_b;\\n        while 1 < que.len() {\\n            let fv = que.pop_front().unwrap();\\n            let bv = que.pop_back().unwrap();\\n    \\n            if a < fv {\\n                a = capacity_a - fv;\\n                count += 1;\\n            } else {\\n                a -= fv;\\n            }\\n    \\n            if b < bv {\\n                b = capacity_b - bv;\\n                count += 1;\\n            } else {\\n                b -= bv;\\n            }\\n        }\\n    \\n        if let Some(v) = que.pop_front() {\\n            if a.max(b) < v {\\n                count + 1\\n            } else {\\n                count\\n            }\\n        } else {\\n            count\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631522,
                "title": "step-by-step-simulation",
                "content": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int cA, int cB) {\\n        \\n        int n = p.size();\\n        int i = 0;\\n        int j = n-1;\\n        \\n        int cnt = 0;\\n        \\n        int tA = cA;\\n        int tB = cB;\\n        \\n        while(i < j){\\n            if(tA >= p[i]){\\n                tA -= p[i];\\n            }else{\\n                tA = cA;\\n                cnt++;\\n                tA -= p[i];\\n            }\\n            \\n            if(tB >= p[j]){\\n                tB -= p[j];\\n            }else{\\n                tB = cB;\\n                cnt++;\\n                tB -= p[j];\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        if(i == j){\\n            if(tA == tB){\\n                if(tA < p[i]){\\n                    cnt++;\\n                }\\n            }else{\\n                if(tA > tB){\\n                    if(tA < p[i])\\n                        cnt++;\\n                }else {\\n                    if(tB < p[j]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& p, int cA, int cB) {\\n        \\n        int n = p.size();\\n        int i = 0;\\n        int j = n-1;\\n        \\n        int cnt = 0;\\n        \\n        int tA = cA;\\n        int tB = cB;\\n        \\n        while(i < j){\\n            if(tA >= p[i]){\\n                tA -= p[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2625945,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n         \\n         int steps = 0;\\n         int start = 0;\\n         int cA = capacityA;\\n         int cB = capacityB;\\n         int end = plants.length - 1;\\n         while (end >= start)\\n         {\\n              if(start != end)\\n              {\\n                  if (plants[start] <= cA)\\n             {\\n                 cA -= plants[start];\\n                 start ++;\\n             }\\n             else\\n             {\\n                 \\n                 cA = capacityA;\\n                 steps += 1;\\n                 cA -= plants[start];\\n                 start ++;\\n             }\\n             if ( plants[end] <= cB)\\n             {\\n                 cB -= plants[end];\\n                 end  --;\\n             }\\n             else\\n             {\\n                 cB = capacityB;\\n                 cB -= plants[end];\\n                 steps += 1;\\n                 end--;\\n             }\\n             }\\n                else\\n                {\\n                    if(cA >= plants[start] || cB >= plants[end])\\n                    {\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        steps += 1;\\n                        break;\\n                    }\\n                }\\n              \\n         }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n         \\n         int steps = 0;\\n         int start = 0;\\n         int cA = capacityA;\\n         int cB = capacityB;\\n         int end = plants.length - 1;\\n         while (end >= start)\\n         {\\n              if(start != end)\\n              {\\n                  if (plants[start] <= cA)\\n             {\\n                 cA -= plants[start];\\n                 start ++;\\n             }\\n             else\\n             {\\n                 \\n                 cA = capacityA;\\n                 steps += 1;\\n                 cA -= plants[start];\\n                 start ++;\\n             }\\n             if ( plants[end] <= cB)\\n             {\\n                 cB -= plants[end];\\n                 end  --;\\n             }\\n             else\\n             {\\n                 cB = capacityB;\\n                 cB -= plants[end];\\n                 steps += 1;\\n                 end--;\\n             }\\n             }\\n                else\\n                {\\n                    if(cA >= plants[start] || cB >= plants[end])\\n                    {\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        steps += 1;\\n                        break;\\n                    }\\n                }\\n              \\n         }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622478,
                "title": "c-100-easy-and-understandable-solution-using-two-pointers-t-c-o-n",
                "content": "**Please Upvote if helpful\\nComment down your doubts for instant reply**\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int s=0;\\n        int e=plants.size()-1;\\n        int ans=0;\\n        int capacitya=capacityA;\\n        int capacityb=capacityB;\\n        while(s<=e){\\n            if(s==e){\\n                if(capacityb>capacitya){\\n                    if(capacityb<plants[s]){\\n                        ans++;\\n                    }\\n                }else{\\n                    if(capacitya<plants[s]){\\n                        ans++;\\n                    }                    \\n                }\\n                break;\\n            }\\n            if(capacitya<plants[s]){\\n                ans++;\\n                capacitya=capacityA;\\n            }\\n            capacitya-=plants[s];\\n            if(capacityb<plants[e]){\\n                ans++;\\n                capacityb=capacityB;\\n            }\\n            capacityb-=plants[e];\\n            s++;e--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int s=0;\\n        int e=plants.size()-1;\\n        int ans=0;\\n        int capacitya=capacityA;\\n        int capacityb=capacityB;\\n        while(s<=e){\\n            if(s==e){\\n                if(capacityb>capacitya){\\n                    if(capacityb<plants[s]){\\n                        ans++;\\n                    }\\n                }else{\\n                    if(capacitya<plants[s]){\\n                        ans++;\\n                    }                    \\n                }\\n                break;\\n            }\\n            if(capacitya<plants[s]){\\n                ans++;\\n                capacitya=capacityA;\\n            }\\n            capacitya-=plants[s];\\n            if(capacityb<plants[e]){\\n                ans++;\\n                capacityb=capacityB;\\n            }\\n            capacityb-=plants[e];\\n            s++;e--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604881,
                "title": "python-readable-and-easy-solution",
                "content": "My thought process was:\\n1) We need to check whether Alica and Bob meet at the same plant\\n2) As all actions are instantaneously, bot Alice and Bob water the same amount of plants\\n3) It does not matter to the solution who waters which plant\\n4) For every plant we need to check whether our bucket is enough, otherwise we need to refill before watering the plant\\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \\n        # check whether they will reach the same plant (uneven array length)\\n        same_plant = len(plants) % 2 == 1\\n        \\n        # get the middle plant\\n        mid_plant = len(plants)//2\\n        \\n        # make the two buckets\\n        a_bucket = capacityA\\n        b_bucket = capacityB\\n        fillups = 0\\n        for idx in range(mid_plant):\\n            # check alice\\n            if a_bucket >= plants[idx]:\\n                a_bucket -= plants[idx]\\n            else:\\n                fillups += 1\\n                a_bucket = capacityA - plants[idx]\\n            \\n            # check bob\\n            if b_bucket >= plants[-idx-1]:\\n                b_bucket -= plants[-idx-1]\\n            else:\\n                fillups += 1\\n                b_bucket = capacityB - plants[-idx-1]\\n        \\n        # check whether we meet at the same place and need to refill there\\n        leftover_plant = plants[mid_plant]\\n        if same_plant and a_bucket < leftover_plant and b_bucket < leftover_plant:\\n            fillups += 1\\n            \\n        return fillups\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        \\n        # check whether they will reach the same plant (uneven array length)\\n        same_plant = len(plants) % 2 == 1\\n        \\n        # get the middle plant\\n        mid_plant = len(plants)//2\\n        \\n        # make the two buckets\\n        a_bucket = capacityA\\n        b_bucket = capacityB\\n        fillups = 0\\n        for idx in range(mid_plant):\\n            # check alice\\n            if a_bucket >= plants[idx]:\\n                a_bucket -= plants[idx]\\n            else:\\n                fillups += 1\\n                a_bucket = capacityA - plants[idx]\\n            \\n            # check bob\\n            if b_bucket >= plants[-idx-1]:\\n                b_bucket -= plants[-idx-1]\\n            else:\\n                fillups += 1\\n                b_bucket = capacityB - plants[-idx-1]\\n        \\n        # check whether we meet at the same place and need to refill there\\n        leftover_plant = plants[mid_plant]\\n        if same_plant and a_bucket < leftover_plant and b_bucket < leftover_plant:\\n            fillups += 1\\n            \\n        return fillups\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602292,
                "title": "c-two-pointers",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumRefill(vector<int>& a, int ca, int cb) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint l=0,r=n-1,fca=ca,fcb=cb,count=0;\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(ca>=a[l]) ca-=a[l++];\\n\\t\\t\\t\\telse if(ca<a[l]) {\\n\\t\\t\\t\\t\\tca=fca;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tca-=a[l++];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(cb>=a[r]) cb-=a[r--];\\n\\t\\t\\t\\telse if(cb<a[r]) {\\n\\t\\t\\t\\t\\tcb=fcb;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tcb-=a[r--];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(l==r)  {\\n\\t\\t\\t\\tca=max(ca,cb);\\n\\t\\t\\t\\tif(ca<a[l]) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumRefill(vector<int>& a, int ca, int cb) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint l=0,r=n-1,fca=ca,fcb=cb,count=0;\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(ca>=a[l]) ca-=a[l++];\\n\\t\\t\\t\\telse if(ca<a[l]) {\\n\\t\\t\\t\\t\\tca=fca;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tca-=a[l++];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2599560,
                "title": "java-solution-faster-than-89-36-other-submission",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int left=0,right=plants.length-1;\\n        int refillA=0,refillB=0;\\n        \\n        while(left<right){\\n            \\n            if(canA<plants[left]){\\n                refillA++;\\n                canA = capacityA;\\n            }\\n            if(canB<plants[right]){\\n                refillB++;\\n                canB = capacityB;\\n            }\\n            \\n            canA=canA-plants[left];\\n            canB=canB-plants[right];\\n            left++;\\n            right--;\\n        }\\n        \\n            if(left==right){\\n                if(canA<plants[left] && canB<plants[left]){\\n                    refillA++;\\n                }\\n            }\\n       \\n    \\n        return refillA+refillB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int left=0,right=plants.length-1;\\n        int refillA=0,refillB=0;\\n        \\n        while(left<right){\\n            \\n            if(canA<plants[left]){\\n                refillA++;\\n                canA = capacityA;\\n            }\\n            if(canB<plants[right]){\\n                refillB++;\\n                canB = capacityB;\\n            }\\n            \\n            canA=canA-plants[left];\\n            canB=canB-plants[right];\\n            left++;\\n            right--;\\n        }\\n        \\n            if(left==right){\\n                if(canA<plants[left] && canB<plants[left]){\\n                    refillA++;\\n                }\\n            }\\n       \\n    \\n        return refillA+refillB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586402,
                "title": "java-two-pointers-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int maxA=capacityA,maxB=capacityB,count=0,i=0,j=plants.length-1;\\n        while(j-i>=0 && i<plants.length && j>=0){\\n            if(i==j){\\n                if(Math.max(capacityA,capacityB)<plants[i])\\n                    count++;\\n                break;\\n            }\\n            if(capacityA>=plants[i])\\n                capacityA=capacityA-plants[i];\\n            else{\\n                count++;\\n                capacityA=maxA;\\n                capacityA=capacityA-plants[i];\\n            }\\n            i++;\\n            if(capacityB>=plants[j])\\n                capacityB=capacityB-plants[j];\\n            else{\\n                count++;\\n                capacityB=maxB;\\n                capacityB=capacityB-plants[j];\\n            }\\n            j--;  \\n        }\\n        return count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int maxA=capacityA,maxB=capacityB,count=0,i=0,j=plants.length-1;\\n        while(j-i>=0 && i<plants.length && j>=0){\\n            if(i==j){\\n                if(Math.max(capacityA,capacityB)<plants[i])\\n                    count++;\\n                break;\\n            }\\n            if(capacityA>=plants[i])\\n                capacityA=capacityA-plants[i];\\n            else{\\n                count++;\\n                capacityA=maxA;\\n                capacityA=capacityA-plants[i];\\n            }\\n            i++;\\n            if(capacityB>=plants[j])\\n                capacityB=capacityB-plants[j];\\n            else{\\n                count++;\\n                capacityB=maxB;\\n                capacityB=capacityB-plants[j];\\n            }\\n            j--;  \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582689,
                "title": "python-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans, bobWater, aliceWater = 0, capacityB, capacityA\\n        alicePos, bobPos = 0, len(plants) - 1\\n        while alicePos < bobPos:\\n            if plants[alicePos] > aliceWater:\\n                ans += 1\\n                aliceWater = capacityA\\n            if plants[bobPos] > bobWater:\\n                ans += 1\\n                bobWater = capacityB\\n            print(ans, aliceWater, bobWater)\\n            aliceWater -= plants[alicePos]\\n            bobWater -= plants[bobPos]\\n            alicePos += 1\\n            bobPos -= 1\\n        if len(plants) & 1 and plants[alicePos] > max(aliceWater, bobWater):\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans, bobWater, aliceWater = 0, capacityB, capacityA\\n        alicePos, bobPos = 0, len(plants) - 1\\n        while alicePos < bobPos:\\n            if plants[alicePos] > aliceWater:\\n                ans += 1\\n                aliceWater = capacityA\\n            if plants[bobPos] > bobWater:\\n                ans += 1\\n                bobWater = capacityB\\n            print(ans, aliceWater, bobWater)\\n            aliceWater -= plants[alicePos]\\n            bobWater -= plants[bobPos]\\n            alicePos += 1\\n            bobPos -= 1\\n        if len(plants) & 1 and plants[alicePos] > max(aliceWater, bobWater):\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579059,
                "title": "easy-understanding-well-divided-code-python",
                "content": "```\\nclass Solution(object):\\n    def minimumRefill(self, plants, capacityA, capacityB):\\n        \"\"\"\\n        :type plants: List[int]\\n        :type capacityA: int\\n        :type capacityB: int\\n        :rtype: int\\n        \"\"\"\\n        i, j = 0, len(plants) - 1\\n        cA, cB = capacityA, capacityB\\n        self.refills = 0\\n        \\n        while i <= j:\\n            if i == j:\\n                if cA >= cB:\\n                    cA = self.aliceWaters(cA, capacityA, plants[i])\\n                else:\\n                    cB = self.bobWaters(cB, capacityB, plants[j])\\n                    \\n            else:\\n                # both water 1 plant each\\n                cA = self.aliceWaters(cA, capacityA, plants[i])\\n                cB = self.bobWaters(cB, capacityB, plants[j])\\n                \\n            i += 1\\n            j -= 1\\n        \\n        return self.refills\\n            \\n    def aliceWaters(self, cA, capacityA, waterNeeded):\\n        if cA < waterNeeded:  # Alice has to refill\\n            cA = capacityA\\n            self.refills += 1\\n        \\n        cA -= waterNeeded\\n        return cA\\n        \\n    def bobWaters(self, cB, capacityB, waterNeeded):\\n        if cB < waterNeeded:  # Alice has to refill\\n            cB = capacityB\\n            self.refills += 1\\n        \\n        cB -= waterNeeded\\n        return cB",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumRefill(self, plants, capacityA, capacityB):\\n        \"\"\"\\n        :type plants: List[int]\\n        :type capacityA: int\\n        :type capacityB: int\\n        :rtype: int\\n        \"\"\"\\n        i, j = 0, len(plants) - 1\\n        cA, cB = capacityA, capacityB\\n        self.refills = 0\\n        \\n        while i <= j:\\n            if i == j:\\n                if cA >= cB:\\n                    cA = self.aliceWaters(cA, capacityA, plants[i])\\n                else:\\n                    cB = self.bobWaters(cB, capacityB, plants[j])\\n                    \\n            else:\\n                # both water 1 plant each\\n                cA = self.aliceWaters(cA, capacityA, plants[i])\\n                cB = self.bobWaters(cB, capacityB, plants[j])\\n                \\n            i += 1\\n            j -= 1\\n        \\n        return self.refills\\n            \\n    def aliceWaters(self, cA, capacityA, waterNeeded):\\n        if cA < waterNeeded:  # Alice has to refill\\n            cA = capacityA\\n            self.refills += 1\\n        \\n        cA -= waterNeeded\\n        return cA\\n        \\n    def bobWaters(self, cB, capacityB, waterNeeded):\\n        if cB < waterNeeded:  # Alice has to refill\\n            cB = capacityB\\n            self.refills += 1\\n        \\n        cB -= waterNeeded\\n        return cB",
                "codeTag": "Java"
            },
            {
                "id": 2574037,
                "title": "simple-and-easy-to-understand",
                "content": "\\nlet tempCapA = capacityA;\\nlet tempCapB = capacityB;\\nlet refill = 0;\\n\\nlet i = 0,\\n  j = plants.length - 1;\\n\\nwhile (i <= j) {\\n  if (i == j) {\\n    if (tempCapB > tempCapA) {\\n      if (plants[i] > tempCapB) {\\n        refill++;\\n      }\\n    } else {\\n      if (plants[i] > tempCapA) {\\n        refill++;\\n      }\\n    }\\n  } else {\\n    if (plants[i] > tempCapA) {\\n      refill++;\\n      tempCapA = capacityA - plants[i];\\n    } else {\\n      tempCapA = tempCapA - plants[i];\\n    }\\n\\n    if (plants[j] > tempCapB) {\\n      refill++;\\n      tempCapB = capacityB - plants[j];\\n    } else {\\n      tempCapB = tempCapB - plants[j];\\n    }\\n  }\\n  i++, j--;\\n}\\n\\nreturn refill",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "\\nlet tempCapA = capacityA;\\nlet tempCapB = capacityB;\\nlet refill = 0;\\n\\nlet i = 0,\\n  j = plants.length - 1;\\n\\nwhile (i <= j) {\\n  if (i == j) {\\n    if (tempCapB > tempCapA) {\\n      if (plants[i] > tempCapB) {\\n        refill++;\\n      }\\n    } else {\\n      if (plants[i] > tempCapA) {\\n        refill++;\\n      }\\n    }\\n  } else {\\n    if (plants[i] > tempCapA) {\\n      refill++;\\n      tempCapA = capacityA - plants[i];\\n    } else {\\n      tempCapA = tempCapA - plants[i];\\n    }\\n\\n    if (plants[j] > tempCapB) {\\n      refill++;\\n      tempCapB = capacityB - plants[j];\\n    } else {\\n      tempCapB = tempCapB - plants[j];\\n    }\\n  }\\n  i++, j--;\\n}\\n\\nreturn refill",
                "codeTag": "Unknown"
            },
            {
                "id": 2569381,
                "title": "clean-and-readable-code-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int A, int B) {\\n        int ans=0,cA=A,cB=B;\\n        int j=plants.size()-1;\\n        int i=0;\\n        while(i<j)\\n        {\\n            if(plants[i]>cA)\\n            {\\n                cA=A;\\n                ans++;\\n            }\\n            if(plants[j]>cB)\\n            {\\n                cB=B;\\n                ans++;\\n            }\\n            cA-=plants[i];\\n            cB-=plants[j];\\n            i++;\\n            j--;\\n        }\\n        if((plants.size()&1)&&plants[i]>max(cA,cB))ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int A, int B) {\\n        int ans=0,cA=A,cB=B;\\n        int j=plants.size()-1;\\n        int i=0;\\n        while(i<j)\\n        {\\n            if(plants[i]>cA)\\n            {\\n                cA=A;\\n                ans++;\\n            }\\n            if(plants[j]>cB)\\n            {\\n                cB=B;\\n                ans++;\\n            }\\n            cA-=plants[i];\\n            cB-=plants[j];\\n            i++;\\n            j--;\\n        }\\n        if((plants.size()&1)&&plants[i]>max(cA,cB))ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556520,
                "title": "simple-two-pointer-approach-c-well-commented",
                "content": "`Please upvote if you like my solution .`\\n```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i =0 , j = plants.size()-1;\\n        // store capacities in n and m\\n        int ans = 0 , n = capacityA , m = capacityB;\\n        // loop for weatering plants  \\n        while(i < j){\\n            // if Alice can water plant ith then he will water it and reduce water from his can\\n            if(capacityA >= plants[i]){ \\n                capacityA -= plants[i];\\n                plants[i] = 0;\\n            }else{ // alice cannot water ith plant so refill and then water it \\n                capacityA  = n; ans++;\\n                capacityA -= plants[i];\\n                plants[i] = 0;\\n            }\\n            i++; // ith plant watered \\n            // if bob can water plant jth then he will water it and reduce water from his can \\n            if(capacityB >= plants[j]){ \\n                capacityB -= plants[j];\\n                plants[j] = 0;\\n            }else{ // bob cannot water jth plant so he will refill then water it \\n                capacityB = m;\\n                ans++;\\n                capacityB -= plants[j];\\n                plants[j] = 0;\\n            }\\n            j--; // plant jth watered \\n            if(i >= j) break; // check if then bot have to water same plant or they have crossed each other or not\\n        }\\n        // when they both have to water same plant \\n        if(i == j){\\n            if(capacityB > capacityA  && capacityB < plants[i] ) ans++;\\n            else if( capacityA > capacityB  && capacityA < plants[i] ) ans++;\\n            else if(capacityB == capacityA && capacityA < plants[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int i =0 , j = plants.size()-1;\\n        // store capacities in n and m\\n        int ans = 0 , n = capacityA , m = capacityB;\\n        // loop for weatering plants  \\n        while(i < j){\\n            // if Alice can water plant ith then he will water it and reduce water from his can\\n            if(capacityA >= plants[i]){ \\n                capacityA -= plants[i];\\n                plants[i] = 0;\\n            }else{ // alice cannot water ith plant so refill and then water it \\n                capacityA  = n; ans++;\\n                capacityA -= plants[i];\\n                plants[i] = 0;\\n            }\\n            i++; // ith plant watered \\n            // if bob can water plant jth then he will water it and reduce water from his can \\n            if(capacityB >= plants[j]){ \\n                capacityB -= plants[j];\\n                plants[j] = 0;\\n            }else{ // bob cannot water jth plant so he will refill then water it \\n                capacityB = m;\\n                ans++;\\n                capacityB -= plants[j];\\n                plants[j] = 0;\\n            }\\n            j--; // plant jth watered \\n            if(i >= j) break; // check if then bot have to water same plant or they have crossed each other or not\\n        }\\n        // when they both have to water same plant \\n        if(i == j){\\n            if(capacityB > capacityA  && capacityB < plants[i] ) ans++;\\n            else if( capacityA > capacityB  && capacityA < plants[i] ) ans++;\\n            else if(capacityB == capacityA && capacityA < plants[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549193,
                "title": "begineer-friendly-approach-two-pointer-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int c_A, int c_B) {\\n        int i=0,j=plants.size()-1;\\n        int temp_A=c_A;\\n        int temp_B=c_B;\\n        int fill=0;\\n        \\n        while(i<j){\\n            \\n            if(plants[i]>temp_A){\\n                fill++;\\n                temp_A=c_A;\\n                            }            \\n            if(plants[j]>temp_B){\\n                temp_B=c_B;\\n                fill++;\\n            }\\n            temp_A=temp_A-plants[i];\\n            i++;\\n            temp_B=temp_B-plants[j];\\n            j--;\\n            \\n        }\\n        \\n        if(i==j){\\n                 if(temp_A<plants[i] && temp_B<plants[i]){\\n                     fill++;\\n                 }                    \\n        }\\n        return fill;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int c_A, int c_B) {\\n        int i=0,j=plants.size()-1;\\n        int temp_A=c_A;\\n        int temp_B=c_B;\\n        int fill=0;\\n        \\n        while(i<j){\\n            \\n            if(plants[i]>temp_A){\\n                fill++;\\n                temp_A=c_A;\\n                            }            \\n            if(plants[j]>temp_B){\\n                temp_B=c_B;\\n                fill++;\\n            }\\n            temp_A=temp_A-plants[i];\\n            i++;\\n            temp_B=temp_B-plants[j];\\n            j--;\\n            \\n        }\\n        \\n        if(i==j){\\n                 if(temp_A<plants[i] && temp_B<plants[i]){\\n                     fill++;\\n                 }                    \\n        }\\n        return fill;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545059,
                "title": "c-basic-solution",
                "content": "\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int count=0;\\n        int ca=capacityA, cb=capacityB;\\n        int n=plants.size();\\n        int ia=-1,ib=n;\\n        while(ia+1<=ib-1){\\n            if(ia+1 == ib-1){\\n                if(plants[ia+1] > max(ca,cb))\\n                    count++;\\n                ia++;\\n                ib--;\\n                n--;\\n                continue;                 \\n            }\\n            if(plants[ia+1] <= ca){\\n               \\n                ca=ca-plants[ia+1];\\n                 ia++;\\n                n--;\\n                \\n            }\\n            else{\\n                count++;\\n                ca=capacityA;\\n                ca=ca-plants[ia+1];\\n                ia++;\\n                n--;\\n            }\\n            if(plants[ib-1]<=cb){\\n                \\n                cb=cb-plants[ib-1];\\n                ib--;\\n                n--;\\n            }\\n            else{\\n                count++;\\n                cb=capacityB;\\n                cb=cb-plants[ib-1];\\n                ib--;\\n                n--;\\n            }\\n            if(n==0)\\n                break;\\n        }\\n        return count;\\n        \\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {\\n        int count=0;\\n        int ca=capacityA, cb=capacityB;\\n        int n=plants.size();\\n        int ia=-1,ib=n;\\n        while(ia+1<=ib-1){\\n            if(ia+1 == ib-1){\\n                if(plants[ia+1] > max(ca,cb))\\n                    count++;\\n                ia++;\\n                ib--;\\n                n--;\\n                continue;                 \\n            }\\n            if(plants[ia+1] <= ca){\\n               \\n                ca=ca-plants[ia+1];\\n                 ia++;\\n                n--;\\n                \\n            }\\n            else{\\n                count++;\\n                ca=capacityA;\\n                ca=ca-plants[ia+1];\\n                ia++;\\n                n--;\\n            }\\n            if(plants[ib-1]<=cb){\\n                \\n                cb=cb-plants[ib-1];\\n                ib--;\\n                n--;\\n            }\\n            else{\\n                count++;\\n                cb=capacityB;\\n                cb=cb-plants[ib-1];\\n                ib--;\\n                n--;\\n            }\\n            if(n==0)\\n                break;\\n        }\\n        return count;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2537864,
                "title": "rust-with-two-pointers",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        let n = plants.len();\\n        let mut vala = capacity_a;\\n        let mut valb = capacity_b;\\n        let mut res = 0;\\n        let mut posa: usize = 0;\\n        let mut posb: usize = n-1;\\n        while posa < posb {\\n            if vala < plants[posa] {\\n                res += 1;\\n                vala = capacity_a - plants[posa];\\n            } else {\\n                vala -= plants[posa];\\n            }\\n            posa += 1;\\n            if valb < plants[posb] {\\n                res += 1;\\n                valb = capacity_b - plants[posb];\\n            } else {\\n                valb -= plants[posb];\\n            }\\n            posb -= 1;\\n            \\n        }\\n        if posa == posb {\\n            if vala >= valb && vala < plants[posa] {\\n                res += 1;\\n            }\\n            if vala < valb && valb < plants[posb] {\\n                res += 1;\\n            }\\n        }\\n        res\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_refill(plants: Vec<i32>, capacity_a: i32, capacity_b: i32) -> i32 {\\n        let n = plants.len();\\n        let mut vala = capacity_a;\\n        let mut valb = capacity_b;\\n        let mut res = 0;\\n        let mut posa: usize = 0;\\n        let mut posb: usize = n-1;\\n        while posa < posb {\\n            if vala < plants[posa] {\\n                res += 1;\\n                vala = capacity_a - plants[posa];\\n            } else {\\n                vala -= plants[posa];\\n            }\\n            posa += 1;\\n            if valb < plants[posb] {\\n                res += 1;\\n                valb = capacity_b - plants[posb];\\n            } else {\\n                valb -= plants[posb];\\n            }\\n            posb -= 1;\\n            \\n        }\\n        if posa == posb {\\n            if vala >= valb && vala < plants[posa] {\\n                res += 1;\\n            }\\n            if vala < valb && valb < plants[posb] {\\n                res += 1;\\n            }\\n        }\\n        res\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530816,
                "title": "java-2-pointer-easy-to-under-stand",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int i = 0;\\n        int j = plants.length - 1;\\n        int refillA = 0;\\n        int refillB = 0;\\n        while(i < j){\\n            if(canA < plants[i]){\\n                refillA++;\\n                canA = capacityA;\\n            }\\n            if(canB < plants[j]){\\n                refillB++;\\n                canB = capacityB;\\n            }\\n            canA -= plants[i];\\n            canB -= plants[j];\\n            i++;\\n            j--;\\n        }\\n        \\n        if(i == j){\\n            if(canA < plants[i] && canB < plants[i]){\\n                refillA++;\\n            }\\n        }\\n\\n        return refillA + refillB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int canA = capacityA;\\n        int canB = capacityB;\\n        int i = 0;\\n        int j = plants.length - 1;\\n        int refillA = 0;\\n        int refillB = 0;\\n        while(i < j){\\n            if(canA < plants[i]){\\n                refillA++;\\n                canA = capacityA;\\n            }\\n            if(canB < plants[j]){\\n                refillB++;\\n                canB = capacityB;\\n            }\\n            canA -= plants[i];\\n            canB -= plants[j];\\n            i++;\\n            j--;\\n        }\\n        \\n        if(i == j){\\n            if(canA < plants[i] && canB < plants[i]){\\n                refillA++;\\n            }\\n        }\\n\\n        return refillA + refillB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524478,
                "title": "cpp-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int ca, int cb) {\\n        int a=0;int b=plants.size()-1,ka=ca,kb=cb,ans=0;\\n        while(a<b){\\n            if(plants[a]>ka){\\n                ans++; ka=ca;\\n            }\\n            if(plants[b]>kb){\\n                ans++; kb=cb;\\n            }\\n            kb-=plants[b]; ka-=plants[a];\\n            a++;b--;\\n        }\\n        if(a==b&&plants[a]>ka&&plants[a]>kb) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int ca, int cb) {\\n        int a=0;int b=plants.size()-1,ka=ca,kb=cb,ans=0;\\n        while(a<b){\\n            if(plants[a]>ka){\\n                ans++; ka=ca;\\n            }\\n            if(plants[b]>kb){\\n                ans++; kb=cb;\\n            }\\n            kb-=plants[b]; ka-=plants[a];\\n            a++;b--;\\n        }\\n        if(a==b&&plants[a]>ka&&plants[a]>kb) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524333,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int i=0,j=plants.size()-1;\\n        int a=capacityA,b=capacityB;\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            if(i<j)\\n            {\\n                if(plants[i]>a)\\n                {\\n                    a=capacityA-plants[i];\\n                    ans++;\\n                }\\n                else\\n                {\\n                    a-=plants[i];\\n                }\\n                if(plants[j]>b)\\n                {\\n                    b=capacityB-plants[j];\\n                    ans++;\\n                }\\n                else\\n                {\\n                    b-=plants[j];\\n                }\\n            }\\n            else\\n            {\\n                if(a>=b)\\n                {\\n                    if(plants[i]>a)\\n                    {\\n                        a=capacityA-plants[i];\\n                        ans++;\\n                    }\\n                    else\\n                    {\\n                        a-=plants[i];\\n                    }\\n                }\\n                else\\n                {\\n                    if(plants[j]>b)\\n                    {\\n                        b=capacityB-plants[j];\\n                        ans++;\\n                    }\\n                    else\\n                    {\\n                        b-=plants[j];\\n                    }\\n                    \\n                }\\n            }\\n            i++;\\n            j--;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) \\n    {\\n        int i=0,j=plants.size()-1;\\n        int a=capacityA,b=capacityB;\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            if(i<j)\\n            {\\n                if(plants[i]>a)\\n                {\\n                    a=capacityA-plants[i];\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2500008,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int alice=0, bob= plants.length-1,alice_can= capacityA, bob_can = capacityB;\\n        int refill=0;\\n        while(alice<=bob){\\n            if(alice==bob){\\n                if(plants[alice]<=alice_can || plants[bob]<=bob_can){\\n                    break;\\n                }\\n                else{\\n                    refill++;\\n                    break;\\n                }\\n            }\\n            if(plants[alice]<=alice_can){\\n                alice_can-=plants[alice];\\n                alice++;\\n            }\\n            else{\\n                alice_can= capacityA;\\n                refill++;\\n                alice_can-=plants[alice];\\n                alice++;\\n            }\\n            if(plants[bob]<=bob_can){\\n                bob_can-=plants[bob];\\n                bob--;\\n            }\\n            else{\\n                bob_can=capacityB;\\n                refill++;\\n                bob_can-=plants[bob];\\n                bob--;\\n            }\\n        }\\n        return refill;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int alice=0, bob= plants.length-1,alice_can= capacityA, bob_can = capacityB;\\n        int refill=0;\\n        while(alice<=bob){\\n            if(alice==bob){\\n                if(plants[alice]<=alice_can || plants[bob]<=bob_can){\\n                    break;\\n                }\\n                else{\\n                    refill++;\\n                    break;\\n                }\\n            }\\n            if(plants[alice]<=alice_can){\\n                alice_can-=plants[alice];\\n                alice++;\\n            }\\n            else{\\n                alice_can= capacityA;\\n                refill++;\\n                alice_can-=plants[alice];\\n                alice++;\\n            }\\n            if(plants[bob]<=bob_can){\\n                bob_can-=plants[bob];\\n                bob--;\\n            }\\n            else{\\n                bob_can=capacityB;\\n                refill++;\\n                bob_can-=plants[bob];\\n                bob--;\\n            }\\n        }\\n        return refill;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498806,
                "title": "easy-to-understand-optimized-c",
                "content": "![image](https://assets.leetcode.com/users/images/5f2f908b-7bdc-4f70-b357-95c8f64a76de_1661757420.0607197.png)\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/5f2f908b-7bdc-4f70-b357-95c8f64a76de_1661757420.0607197.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2479469,
                "title": "python-solution-optimization-is-important-clean-code",
                "content": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:  \\n        n=len(plants)\\n        if n==1:\\n            if capacityA>=plants[0] or capacityB>=plants[0]:\\n                return 0 \\n            else:\\n                return 1\\n        s=0\\n        pa=capacityA\\n        pb=capacityB\\n        length=n\\n        if n%2!=0:\\n            length=n+1\\n        for i in range(1,length//2):\\n            da=capacityA-plants[i-1]\\n            db=capacityB-plants[n-i]\\n            if i==n-i-1:\\n                if da>=plants[i] or db>=plants[i]:\\n                    return s \\n                else:\\n                    return s+1 \\n            if da>=plants[i]:\\n                capacityA=da\\n            else:\\n                s+=1\\n                capacityA=pa\\n            if db>=plants[n-i-1]:\\n                capacityB=db\\n            else:\\n                s+=1\\n                capacityB=pb\\n        return s\\n``` \\n**Please upvote if you found it helpful** \\n**Feel free to post doubts**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:  \\n        n=len(plants)\\n        if n==1:\\n            if capacityA>=plants[0] or capacityB>=plants[0]:\\n                return 0 \\n            else:\\n                return 1\\n        s=0\\n        pa=capacityA\\n        pb=capacityB\\n        length=n\\n        if n%2!=0:\\n            length=n+1\\n        for i in range(1,length//2):\\n            da=capacityA-plants[i-1]\\n            db=capacityB-plants[n-i]\\n            if i==n-i-1:\\n                if da>=plants[i] or db>=plants[i]:\\n                    return s \\n                else:\\n                    return s+1 \\n            if da>=plants[i]:\\n                capacityA=da\\n            else:\\n                s+=1\\n                capacityA=pa\\n            if db>=plants[n-i-1]:\\n                capacityB=db\\n            else:\\n                s+=1\\n                capacityB=pb\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471641,
                "title": "python-3-simulation",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n\\t\\t\\tl,r=0,len(plants)-1\\n\\t\\t\\tA,B=capacityA,capacityB\\n\\t\\t\\tt=0\\n\\t\\t\\twhile l<r:\\n\\t\\t\\t\\tif plants[l]>A:\\n\\t\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\t\\tA=capacityA\\n\\t\\t\\t\\tif plants[r]>B:\\n\\t\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\t\\tB=capacityB\\n\\t\\t\\t\\tA-=plants[l]\\n\\t\\t\\t\\tB-=plants[r]\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tr-=1\\n\\t\\t\\tif l==r and max(A,B)<plants[l]:\\n\\t\\t\\t\\tt+=1\\n\\t\\t\\treturn t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n\\t\\t\\tl,r=0,len(plants)-1\\n\\t\\t\\tA,B=capacityA,capacityB\\n\\t\\t\\tt=0\\n\\t\\t\\twhile l<r:\\n\\t\\t\\t\\tif plants[l]>A:\\n\\t\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\t\\tA=capacityA\\n\\t\\t\\t\\tif plants[r]>B:\\n\\t\\t\\t\\t\\tt+=1\\n\\t\\t\\t\\t\\tB=capacityB\\n\\t\\t\\t\\tA-=plants[l]\\n\\t\\t\\t\\tB-=plants[r]\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tr-=1\\n\\t\\t\\tif l==r and max(A,B)<plants[l]:\\n\\t\\t\\t\\tt+=1\\n\\t\\t\\treturn t",
                "codeTag": "Java"
            },
            {
                "id": 2453325,
                "title": "java-object-oriented-clean-code",
                "content": "```\\npublic class Solution {\\n    private static class Tuple {\\n        private final int originalCapacity;\\n        private int capacity;\\n        private int refills;\\n\\n        public Tuple(int originalCapacity) {\\n            this.originalCapacity = originalCapacity;\\n            this.capacity = originalCapacity;\\n            this.refills = 0;\\n        }\\n    }\\n\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length;\\n        int left = 0;\\n        int right = n - 1;\\n        Tuple aliceContainer = new Tuple(capacityA);\\n        Tuple bobContainer = new Tuple(capacityB);\\n        while (left < (n + 1) / 2) {\\n            if (left == right) {\\n                if (aliceContainer.capacity >= bobContainer.capacity) {\\n                    fillFrom(aliceContainer, plants[left]);\\n                } else {\\n                    fillFrom(bobContainer, plants[right]);\\n                }\\n                break;\\n            } else {\\n                fillFrom(aliceContainer, plants[left]);\\n                fillFrom(bobContainer, plants[right]);\\n            }\\n            ++left;\\n            --right;\\n        }\\n        return aliceContainer.refills + bobContainer.refills;\\n    }\\n\\n    private void fillFrom(Tuple tuple, int requiredWater) {\\n        if (requiredWater > tuple.capacity) {\\n            tuple.refills += 1;\\n            tuple.capacity = tuple.originalCapacity;\\n        }\\n        tuple.capacity -= requiredWater;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private static class Tuple {\\n        private final int originalCapacity;\\n        private int capacity;\\n        private int refills;\\n\\n        public Tuple(int originalCapacity) {\\n            this.originalCapacity = originalCapacity;\\n            this.capacity = originalCapacity;\\n            this.refills = 0;\\n        }\\n    }\\n\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int n = plants.length;\\n        int left = 0;\\n        int right = n - 1;\\n        Tuple aliceContainer = new Tuple(capacityA);\\n        Tuple bobContainer = new Tuple(capacityB);\\n        while (left < (n + 1) / 2) {\\n            if (left == right) {\\n                if (aliceContainer.capacity >= bobContainer.capacity) {\\n                    fillFrom(aliceContainer, plants[left]);\\n                } else {\\n                    fillFrom(bobContainer, plants[right]);\\n                }\\n                break;\\n            } else {\\n                fillFrom(aliceContainer, plants[left]);\\n                fillFrom(bobContainer, plants[right]);\\n            }\\n            ++left;\\n            --right;\\n        }\\n        return aliceContainer.refills + bobContainer.refills;\\n    }\\n\\n    private void fillFrom(Tuple tuple, int requiredWater) {\\n        if (requiredWater > tuple.capacity) {\\n            tuple.refills += 1;\\n            tuple.capacity = tuple.originalCapacity;\\n        }\\n        tuple.capacity -= requiredWater;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1708945,
                "content": [
                    {
                        "username": "gregsklyanny",
                        "content": "Is this a real Medium problem?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yea for me it was, i have a huge 100 line algorithm hahahaha im so noob"
                    },
                    {
                        "username": "shakthisri",
                        "content": "same doubt"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "for me, this problem was easier to solve than the original Watering Plants one lol."
                    },
                    {
                        "username": "ycw96",
                        "content": "Think about watering flowers: when your water is not enough, will you use up all your water first or fill the bucket first?"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "according to sample test case\\nwe need to refill first\\nthen use it again\\n\\nnot logical\\nbut thats what is stated"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0; int j=plants.length-1; int count=0;\\n        int a = capacityA, b= capacityB;\\n        while(i<j){\\n            if(plants[i]<=a){a=a-plants[i];i++;}\\n            else if(plants[i]>a){a=capacityA;count++;a=a-plants[i];i++;}\\n            if(plants[j]<=b){b=b-plants[j];j--;}\\n            else if(plants[j]>b){b=capacityB;count++;b=b-plants[j];j--;}\\n        }\\n        if(i==j){ if(a>b && a<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a<b && b<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a==b && a<plants[i]){count++;return count++;}}\\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1982471,
                "content": [
                    {
                        "username": "gregsklyanny",
                        "content": "Is this a real Medium problem?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yea for me it was, i have a huge 100 line algorithm hahahaha im so noob"
                    },
                    {
                        "username": "shakthisri",
                        "content": "same doubt"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "for me, this problem was easier to solve than the original Watering Plants one lol."
                    },
                    {
                        "username": "ycw96",
                        "content": "Think about watering flowers: when your water is not enough, will you use up all your water first or fill the bucket first?"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "according to sample test case\\nwe need to refill first\\nthen use it again\\n\\nnot logical\\nbut thats what is stated"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0; int j=plants.length-1; int count=0;\\n        int a = capacityA, b= capacityB;\\n        while(i<j){\\n            if(plants[i]<=a){a=a-plants[i];i++;}\\n            else if(plants[i]>a){a=capacityA;count++;a=a-plants[i];i++;}\\n            if(plants[j]<=b){b=b-plants[j];j--;}\\n            else if(plants[j]>b){b=capacityB;count++;b=b-plants[j];j--;}\\n        }\\n        if(i==j){ if(a>b && a<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a<b && b<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a==b && a<plants[i]){count++;return count++;}}\\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1576080,
                "content": [
                    {
                        "username": "gregsklyanny",
                        "content": "Is this a real Medium problem?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yea for me it was, i have a huge 100 line algorithm hahahaha im so noob"
                    },
                    {
                        "username": "shakthisri",
                        "content": "same doubt"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "for me, this problem was easier to solve than the original Watering Plants one lol."
                    },
                    {
                        "username": "ycw96",
                        "content": "Think about watering flowers: when your water is not enough, will you use up all your water first or fill the bucket first?"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "according to sample test case\\nwe need to refill first\\nthen use it again\\n\\nnot logical\\nbut thats what is stated"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0; int j=plants.length-1; int count=0;\\n        int a = capacityA, b= capacityB;\\n        while(i<j){\\n            if(plants[i]<=a){a=a-plants[i];i++;}\\n            else if(plants[i]>a){a=capacityA;count++;a=a-plants[i];i++;}\\n            if(plants[j]<=b){b=b-plants[j];j--;}\\n            else if(plants[j]>b){b=capacityB;count++;b=b-plants[j];j--;}\\n        }\\n        if(i==j){ if(a>b && a<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a<b && b<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a==b && a<plants[i]){count++;return count++;}}\\n        return count;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1948446,
                "content": [
                    {
                        "username": "gregsklyanny",
                        "content": "Is this a real Medium problem?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yea for me it was, i have a huge 100 line algorithm hahahaha im so noob"
                    },
                    {
                        "username": "shakthisri",
                        "content": "same doubt"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "for me, this problem was easier to solve than the original Watering Plants one lol."
                    },
                    {
                        "username": "ycw96",
                        "content": "Think about watering flowers: when your water is not enough, will you use up all your water first or fill the bucket first?"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "according to sample test case\\nwe need to refill first\\nthen use it again\\n\\nnot logical\\nbut thats what is stated"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "class Solution {\\n    public int minimumRefill(int[] plants, int capacityA, int capacityB) {\\n        int i=0; int j=plants.length-1; int count=0;\\n        int a = capacityA, b= capacityB;\\n        while(i<j){\\n            if(plants[i]<=a){a=a-plants[i];i++;}\\n            else if(plants[i]>a){a=capacityA;count++;a=a-plants[i];i++;}\\n            if(plants[j]<=b){b=b-plants[j];j--;}\\n            else if(plants[j]>b){b=capacityB;count++;b=b-plants[j];j--;}\\n        }\\n        if(i==j){ if(a>b && a<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a<b && b<plants[i]){count++;return count++;}}\\n        if(i==j){ if(a==b && a<plants[i]){count++;return count++;}}\\n        return count;\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]