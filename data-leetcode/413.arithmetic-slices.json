[
    {
        "title": "Arithmetic Slices",
        "question_content": "An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\n\tFor example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\n\nGiven an integer array nums, return the number of arithmetic subarrays of nums.\nA subarray is a contiguous subsequence of the array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 5000\n\t-1000 <= nums[i] <= 1000",
        "solutions": [
            {
                "id": 1814371,
                "title": "c-easy-to-understand-full-explanation",
                "content": "# 413. Arithmetic Slices\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Brute force  Apprachwith O(n) & O(n*n).\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)   **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n\\n* The Idea is Simple , the array is called **arithmetic** if it **consists of at least 3 elements**.\\n* So, firstly **if arr_size is < 3** , we will **return false.**\\n* The **second requirement** of the question is, that the d**ifference b/w any two consecutive elements** should be **same.**\\n* so running a **loop from i = 0 to nums.size() - 2** as we need at least 2 consecutive elements.\\n* now we will store the difference of first 2 elements in a diff variable.\\n* Again, we will traverse a loop to find how many consecutive pairs are with same diff.\\n* running a i**nner loop from i + 2** as the outer for loop has **calculcated the diff of first 2 elements** for us.\\n* now if the **difference of arr[j] - arr[j-1]** ,current and previous element is same , this means we find a **consecutive pair**, with **same diff**, therefore we will i**ncrease the count.**\\n* If the **diff is not same** then we will **break the loop**, a**s we need  consecutive elements diff** to be **same**.\\n* **Return the Count.**\\n\\n**TIME COMPLEXITY\\nO(N * N)**\\n\\n**SPACE COMPLEXITY\\nO(1)**\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\t\\t// if nums size is less than 3 return false\\n        if(nums.size() < 3)\\n            return 0;\\n        \\n        int cnt = 0, diff;\\n        \\n        for(int i = 0; i<nums.size()-2; ++i)\\n        {\\n\\t\\t\\t// storing diff of first 2 elements\\n            diff = nums[i+1] - nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// checking for consecutive elements with same difference.\\n            for(int j = i+2; j<nums.size(); ++j)\\n            {\\n\\t\\t\\t\\t// if we find the same diff of next 2 elements\\n\\t\\t\\t\\t// this means we  find consecutive elements\\n\\t\\t\\t\\t// increase the Count\\n                if(nums[j] - nums[j-1] == diff)\\n                    ++cnt;\\n                else\\n\\t\\t\\t\\t// break as we need to cnt for consecutive diff elements\\n                    break;\\n            }\\n        }\\n\\t\\t// return cnt\\n        return cnt;\\n    }\\n};\\n```\\n\\n**OPTIMISED IN O(N)**\\n\\n![image](https://assets.leetcode.com/users/images/df39d63b-9589-4add-9822-2672aed7a950_1646269919.6060157.png)\\n\\n**EXPLANATION**\\n* The Idea is Simple , the array is called **arithmetic** if it **consists of at least 3 elements**.\\n* So, firstly **if arr_size is < 3** , we will **return false.**\\n* The **second requirement** of the question is, that the d**ifference b/w any two consecutive elements** should be **same.**\\n* Storing diff of first 2 elements in diff as **prev_diff = nums[1] - nums[0]**.\\n* Now iterating a **loop from i = 1 to nums.size()-1** and **finding the diff of next consecutive elements**.\\n* If the **diff is equal to prev_diff,** **increase the cnt of ind** variable;\\n* **else set ind to zero** and **update prev_diff with curr diff**.\\n* add **ind to cnt.**\\n* **Return cnt.**\\n\\n**TIME COMPLEXITY\\nO(N)**\\n\\n**SPACE COMPLEXITY\\nO(1)**\\n\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        \\n        int cnt = 0, diff = 0 , ind = 0;\\n        int prev_diff = nums[1] - nums[0];\\n        \\n        for(int i = 1; i<nums.size()-1 ; ++i)\\n        {\\n            // curr difference\\n            int diff = nums[i+1] - nums[i];\\n            \\n            // if we find same diff of consecutive elements\\n            // increase count\\n            if(diff ==  prev_diff)\\n                ++ind;\\n            \\n            else\\n            {\\n                // update prev diff with curr diff\\n                // as we don\\'t find consecutive elements with same diff\\n                prev_diff = diff;\\n                ind = 0;  // make ind to 0\\n            }\\n            \\n            // add cosecutive arithmetic sequence cnt\\n                cnt += ind;\\n        }\\n        \\n       \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Brute force  Apprachwith O(n) & O(n*n).\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09 \\n\\n```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\t\\t// if nums size is less than 3 return false\\n        if(nums.size() < 3)\\n            return 0;\\n        \\n        int cnt = 0, diff;\\n        \\n        for(int i = 0; i<nums.size()-2; ++i)\\n        {\\n\\t\\t\\t// storing diff of first 2 elements\\n            diff = nums[i+1] - nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// checking for consecutive elements with same difference.\\n            for(int j = i+2; j<nums.size(); ++j)\\n            {\\n\\t\\t\\t\\t// if we find the same diff of next 2 elements\\n\\t\\t\\t\\t// this means we  find consecutive elements\\n\\t\\t\\t\\t// increase the Count\\n                if(nums[j] - nums[j-1] == diff)\\n                    ++cnt;\\n                else\\n\\t\\t\\t\\t// break as we need to cnt for consecutive diff elements\\n                    break;\\n            }\\n        }\\n\\t\\t// return cnt\\n        return cnt;\\n    }\\n};\\n```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        \\n        int cnt = 0, diff = 0 , ind = 0;\\n        int prev_diff = nums[1] - nums[0];\\n        \\n        for(int i = 1; i<nums.size()-1 ; ++i)\\n        {\\n            // curr difference\\n            int diff = nums[i+1] - nums[i];\\n            \\n            // if we find same diff of consecutive elements\\n            // increase count\\n            if(diff ==  prev_diff)\\n                ++ind;\\n            \\n            else\\n            {\\n                // update prev diff with curr diff\\n                // as we don\\'t find consecutive elements with same diff\\n                prev_diff = diff;\\n                ind = 0;  // make ind to 0\\n            }\\n            \\n            // add cosecutive arithmetic sequence cnt\\n                cnt += ind;\\n        }\\n        \\n       \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814356,
                "title": "java-3-liner-explained",
                "content": "**Idea:**\\n* An Arithmetic Slice (AS) is at least 3 ints long, s.t. for a1, a2, a3, they\\'re in arithmetic progression (AP), i.e. `a3 - a2 = a2 - a1`\\n* If there\\'s an AS forming at any index, then it\\'ll be 1 longer than the AS forming at the previous index. Why?\\n\\t* Let a[i], ..., a[j] form an AS of size k, and \\n\\t* a[j + 1] - a[j] = a[j] - a[j - 1], then a[j + 1] becomes a part of the previous AS, i.e. it extends the AS by 1\\n* Total AS = sum of all count of AS ending at each index\\n* Example: `nums: [1, 2, 3, 8, 9, 10]`\\n```\\nLet AS[i] denote number of AS ending at this index. \\nBy definition AS[0] = AS[1] = 0. Also, AS[i] = 0 for any index for which the current int and previous two ints are not in AP\\n\\nnums 1 2 3 8 9 10\\nAS   0 0 1 0 0 1\\n\\nsince 3 - 2 = 2 - 1 \\u21D2 AS[2] = 1 + AS[1] = 1\\n8 - 3 \\u2260 3 - 2 \\u21D2 AS[3] = 0\\n9 - 8 \\u2260 8 - 3 \\u21D2 AS[4] = 0 \\n10 - 9 = 9 - 8 \\u21D2 AS[5] = 1 + AS[4] = 1\\n\\nTotal AS = 1 + 1 = 2 [Ans]\\n```\\n\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n\\tvar slices = 0;\\n\\t\\n\\tfor (int i = 2, prev = 0; i < nums.length; i++)\\n\\t\\tslices += (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) \\n\\t\\t\\t\\t? ++prev \\n\\t\\t\\t\\t: (prev = 0);\\n\\t\\n\\treturn slices;\\n}\\n```\\n**Note:**\\n```\\nslices += (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) ? ++prev : (prev = 0);\\n```\\nis just a 1 liner for \\n```\\nif (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n\\tprev = prev + 1;\\n\\tslices = slices + prev;\\n} else {\\n\\tprev = 0;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nLet AS[i] denote number of AS ending at this index. \\nBy definition AS[0] = AS[1] = 0. Also, AS[i] = 0 for any index for which the current int and previous two ints are not in AP\\n\\nnums 1 2 3 8 9 10\\nAS   0 0 1 0 0 1\\n\\nsince 3 - 2 = 2 - 1 \\u21D2 AS[2] = 1 + AS[1] = 1\\n8 - 3 \\u2260 3 - 2 \\u21D2 AS[3] = 0\\n9 - 8 \\u2260 8 - 3 \\u21D2 AS[4] = 0 \\n10 - 9 = 9 - 8 \\u21D2 AS[5] = 1 + AS[4] = 1\\n\\nTotal AS = 1 + 1 = 2 [Ans]\\n```\n```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n\\tvar slices = 0;\\n\\t\\n\\tfor (int i = 2, prev = 0; i < nums.length; i++)\\n\\t\\tslices += (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) \\n\\t\\t\\t\\t? ++prev \\n\\t\\t\\t\\t: (prev = 0);\\n\\t\\n\\treturn slices;\\n}\\n```\n```\\nslices += (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) ? ++prev : (prev = 0);\\n```\n```\\nif (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n\\tprev = prev + 1;\\n\\tslices = slices + prev;\\n} else {\\n\\tprev = 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90058,
                "title": "simple-java-solution-9-lines-2ms",
                "content": "    public int numberOfArithmeticSlices(int[] A) {\\n        int curr = 0, sum = 0;\\n        for (int i=2; i<A.length; i++)\\n            if (A[i]-A[i-1] == A[i-1]-A[i-2]) {\\n                curr += 1;\\n                sum += curr;\\n            } else {\\n                curr = 0;\\n            }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "    public int numberOfArithmeticSlices(int[] A) {\\n        int curr = 0, sum = 0;\\n        for (int i=2; i<A.length; i++)\\n            if (A[i]-A[i-1] == A[i-1]-A[i-2]) {\\n                curr += 1;\\n                sum += curr;\\n            } else {\\n                curr = 0;\\n            }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 90093,
                "title": "3ms-c-standard-dp-solution-with-very-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int n = A.size();\\n        if (n < 3) return 0;\\n        vector<int> dp(n, 0); // dp[i] means the number of arithmetic slices ending with A[i]\\n        if (A[2]-A[1] == A[1]-A[0]) dp[2] = 1; // if the first three numbers are arithmetic or not\\n        int result = dp[2];\\n        for (int i = 3; i < n; ++i) {\\n            // if A[i-2], A[i-1], A[i] are arithmetic, then the number of arithmetic slices ending with A[i] (dp[i])\\n            // equals to:\\n            //      the number of arithmetic slices ending with A[i-1] (dp[i-1], all these arithmetic slices appending A[i] are also arithmetic)\\n            //      +\\n            //      A[i-2], A[i-1], A[i] (a brand new arithmetic slice)\\n            // it is how dp[i] = dp[i-1] + 1 comes\\n            if (A[i]-A[i-1] == A[i-1]-A[i-2]) \\n                dp[i] = dp[i-1] + 1;\\n            result += dp[i]; // accumulate all valid slices\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int n = A.size();\\n        if (n < 3) return 0;\\n        vector<int> dp(n, 0); // dp[i] means the number of arithmetic slices ending with A[i]\\n        if (A[2]-A[1] == A[1]-A[0]) dp[2] = 1; // if the first three numbers are arithmetic or not\\n        int result = dp[2];\\n        for (int i = 3; i < n; ++i) {\\n            // if A[i-2], A[i-1], A[i] are arithmetic, then the number of arithmetic slices ending with A[i] (dp[i])\\n            // equals to:\\n            //      the number of arithmetic slices ending with A[i-1] (dp[i-1], all these arithmetic slices appending A[i] are also arithmetic)\\n            //      +\\n            //      A[i-2], A[i-1], A[i] (a brand new arithmetic slice)\\n            // it is how dp[i] = dp[i-1] + 1 comes\\n            if (A[i]-A[i-1] == A[i-1]-A[i-2]) \\n                dp[i] = dp[i-1] + 1;\\n            result += dp[i]; // accumulate all valid slices\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455367,
                "title": "python-bottom-up-dp-time-o-n-space-o-1-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bottom up DP**\\n- Let `dp[i]` denote the number of arithmetic subarray ends at `nums[i]`.\\n- If `if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]` then we can form the **Arithmetic subarray** ends at `nums[i]`.\\n\\t- So `dp[i] = dp[i-1] + 1`. \\n- For example: `nums = [1, 3, 5, 7, 9]`\\n\\t- `dp[2] = 1` arithmetic subarrays are `{1, 3, 5}`\\n\\t- `dp[3] = dp[2] + 1 = 2`, arithmetic subarrays are `{1, 3, 5, 7}, {3, 5, 7}`\\n\\t- `dp[4] = dp[3] + 1 = 3`, arithmetic subarrays are `{1, 3, 5, 7, 9}, {3, 5, 7, 9}, {5, 7, 9}`\\n```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        ans = 0\\n        for i in range(2, n):\\n            if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]:\\n                dp[i] = dp[i-1] + 1\\n            ans += dp[i]\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 5000` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Space Optimized)**\\n- Since our dp only access current dp state `dp` and previous dp state `dpPrev`.\\n- So we can easy to achieve O(1) in space.\\n\\n```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp, dpPrev = 0, 0\\n        ans = 0\\n        for i in range(2, n):\\n            if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]:\\n                dp = dpPrev + 1\\n            ans += dp\\n            dpPrev = dp\\n            dp = 0\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 5000` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        ans = 0\\n        for i in range(2, n):\\n            if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]:\\n                dp[i] = dp[i-1] + 1\\n            ans += dp[i]\\n        return ans\\n```\n```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp, dpPrev = 0, 0\\n        ans = 0\\n        for i in range(2, n):\\n            if nums[i-1] - nums[i-2] == nums[i] - nums[i-1]:\\n                dp = dpPrev + 1\\n            ans += dp\\n            dpPrev = dp\\n            dp = 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607523,
                "title": "c-minimalizm",
                "content": "```cpp\\nint numberOfArithmeticSlices(vector<int>& A, int res = 0) {\\n    for (auto i = 2, j = 1; i < A.size(); ++i) {\\n        if (A[i] - A[i - 1] != A[j] - A[j - 1])\\n            j = i;\\n        res += i - j;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numberOfArithmeticSlices(vector<int>& A, int res = 0) {\\n    for (auto i = 2, j = 1; i < A.size(); ++i) {\\n        if (A[i] - A[i - 1] != A[j] - A[j - 1])\\n            j = i;\\n        res += i - j;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982169,
                "title": "faster-than-99-44-python-3-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/389f0a2a-afc6-4835-9d1e-64eeddc8ca9b_1608660351.5834854.png)\\n\\n\\n**-->**  Create an array of size le (le=len(A))\\n\\n**-->** as given \\'\\'A sequence of numbers is called arithmetic if it consists of at **least three elements**\\'\\', start for loop from 2 to le.(**because first two elements(index 0 and 1) will never from a sequence as minimum length of a sequence is 3**)\\n\\n**-->** it is also given that \\'\\'A sequence of numbers is called arithmetic if it consists of at least three elements and **if the difference between any two consecutive elements is the same.**\\'\\'\\nhere i is current element ,if  A[i]-A[i-1] == A[i-1]-A[i-2]  then **sequence length for current element i.e l[i] will be 1+sequence length of previous element(l[i-1)**\\n\\nTO return the total number of arithmetic slices in the array A  **return Caluculated Sum of array l**\\n\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        le=len(A)\\n        l=[0]*(le)\\n        for i in range(2,le):\\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\\n                l[i]=1+l[i-1]\\n        return sum(l)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/389f0a2a-afc6-4835-9d1e-64eeddc8ca9b_1608660351.5834854.png)\\n\\n\\n**-->**  Create an array of size le (le=len(A))\\n\\n**-->** as given \\'\\'A sequence of numbers is called arithmetic if it consists of at **least three elements**\\'\\', start for loop from 2 to le.(**because first two elements(index 0 and 1) will never from a sequence as minimum length of a sequence is 3**)\\n\\n**-->** it is also given that \\'\\'A sequence of numbers is called arithmetic if it consists of at least three elements and **if the difference between any two consecutive elements is the same.**\\'\\'\\nhere i is current element ,if  A[i]-A[i-1] == A[i-1]-A[i-2]  then **sequence length for current element i.e l[i] will be 1+sequence length of previous element(l[i-1)**\\n\\nTO return the total number of arithmetic slices in the array A  **return Caluculated Sum of array l**\\n\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        le=len(A)\\n        l=[0]*(le)\\n        for i in range(2,le):\\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\\n                l[i]=1+l[i-1]\\n        return sum(l)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 215861,
                "title": "detailed-explanation-two-dp-solutions",
                "content": "### 1st DP Solution: time O(n^2), space: O(n^2)\\nWe find the sub problem: \\nAssume `A[i:j]` (both include `A[i]` and `A[j]`) is an  arithmetic slice, then we have:\\n1) if `A[i]-A[i-1] = = A[i+1]-A[i]`, then `A[i-1:j]` is  an arithmetic slice;\\n2) if `A[j+1]-A[j] = = A[j]-A[j-1]`, then `A[i:j+1]` is  an arithmetic slice.\\n\\nuse `dp[i][j]` to memorize whether `A[i:j]` is  an  arithmetic slice,  and `count` to count the  num of arithmetic slices:\\n\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int n=A.length;\\n        if(n<3){return 0;}\\n        boolean[][] dp=new boolean[n][n]; //initial value is false\\n        int count=0;\\n        for(int i=0;i<n-3+1;i++){\\n            if((A[i+1]-A[i])==(A[i+2]-A[i+1])){\\n                dp[i][i+3-1]=true;\\n                count++;\\n            }\\n        }\\n        for(int k=4;k<=n;k++){\\n            for (int i=0;i<n-k+1;i++){\\n                int j=i+k-1;\\n                if(dp[i+1][j]==true&&(A[i+1]-A[i]==A[i+2]-A[i+1])){\\n                    dp[i][j]=true;\\n                    count++;\\n                }else if(dp[i][j-1]==true&&(A[j]-A[j-1]==A[j-1]-A[j-2])){\\n                    dp[i][j]=true;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n### 2nd DP Solution: time O(n), space O(n)\\nWe can find another sub problem: assume `dp[i]` is the number of arithmetic slices which are end with `A[i]`. then we have:\\n`dp[i]=(A[i]-A[i-1] = = A[i-1]-A[i-2])? 1+dp[i-1] : 0`, the code:\\n\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int n=A.length;\\n        if(n<3){return 0;}\\n        int[] dp=new int[n];\\n        dp[0]=0;\\n        dp[1]=0;\\n        int sum=0;\\n        for(int i=2;i<n;i++){\\n            if((A[i]-A[i-1])==(A[i-1]-A[i-2])){\\n                dp[i]=dp[i-1]+1;\\n            }else{\\n                dp[i]=0;\\n            }\\n            sum+=dp[i];\\n        }\\n        return sum;\\n    }\\nup to now, time complexity is O(n), but space complexity is also O(n). In fact, we only need a `curr` to memorize the num of arithmetic slices which end with current `A[i]` and a `sum` to memorize num of all `curr`. that is [@icl7722\\'s solution](https://leetcode.com/problems/arithmetic-slices/discuss/90058/Simple-Java-solution-9-lines-2ms), which time complexity is O(n) and space complexity is O(1).\\n\\n\\tpublic int numberOfArithmeticSlices(int[] A) {\\n\\t\\tint curr = 0, sum = 0;\\n\\t\\tfor (int i=2; i<A.length; i++)\\n\\t\\t\\tif (A[i]-A[i-1] == A[i-1]-A[i-2]) {\\n\\t\\t\\t\\tcurr += 1;\\n\\t\\t\\t\\tsum += curr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr = 0;\\n\\t\\t\\t}\\n\\t\\treturn sum;\\n\\t}",
                "solutionTags": [],
                "code": "### 1st DP Solution: time O(n^2), space: O(n^2)\\nWe find the sub problem: \\nAssume `A[i:j]` (both include `A[i]` and `A[j]`) is an  arithmetic slice, then we have:\\n1) if `A[i]-A[i-1] = = A[i+1]-A[i]`, then `A[i-1:j]` is  an arithmetic slice;\\n2) if `A[j+1]-A[j] = = A[j]-A[j-1]`, then `A[i:j+1]` is  an arithmetic slice.\\n\\nuse `dp[i][j]` to memorize whether `A[i:j]` is  an  arithmetic slice,  and `count` to count the  num of arithmetic slices:\\n\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int n=A.length;\\n        if(n<3){return 0;}\\n        boolean[][] dp=new boolean[n][n]; //initial value is false\\n        int count=0;\\n        for(int i=0;i<n-3+1;i++){\\n            if((A[i+1]-A[i])==(A[i+2]-A[i+1])){\\n                dp[i][i+3-1]=true;\\n                count++;\\n            }\\n        }\\n        for(int k=4;k<=n;k++){\\n            for (int i=0;i<n-k+1;i++){\\n                int j=i+k-1;\\n                if(dp[i+1][j]==true&&(A[i+1]-A[i]==A[i+2]-A[i+1])){\\n                    dp[i][j]=true;\\n                    count++;\\n                }else if(dp[i][j-1]==true&&(A[j]-A[j-1]==A[j-1]-A[j-2])){\\n                    dp[i][j]=true;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n### 2nd DP Solution: time O(n), space O(n)\\nWe can find another sub problem: assume `dp[i]` is the number of arithmetic slices which are end with `A[i]`. then we have:\\n`dp[i]=(A[i]-A[i-1] = = A[i-1]-A[i-2])? 1+dp[i-1] : 0`, the code:\\n\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int n=A.length;\\n        if(n<3){return 0;}\\n        int[] dp=new int[n];\\n        dp[0]=0;\\n        dp[1]=0;\\n        int sum=0;\\n        for(int i=2;i<n;i++){\\n            if((A[i]-A[i-1])==(A[i-1]-A[i-2])){\\n                dp[i]=dp[i-1]+1;\\n            }else{\\n                dp[i]=0;\\n            }\\n            sum+=dp[i];\\n        }\\n        return sum;\\n    }\\nup to now, time complexity is O(n), but space complexity is also O(n). In fact, we only need a `curr` to memorize the num of arithmetic slices which end with current `A[i]` and a `sum` to memorize num of all `curr`. that is [@icl7722\\'s solution](https://leetcode.com/problems/arithmetic-slices/discuss/90058/Simple-Java-solution-9-lines-2ms), which time complexity is O(n) and space complexity is O(1).\\n\\n\\tpublic int numberOfArithmeticSlices(int[] A) {\\n\\t\\tint curr = 0, sum = 0;\\n\\t\\tfor (int i=2; i<A.length; i++)\\n\\t\\t\\tif (A[i]-A[i-1] == A[i-1]-A[i-2]) {\\n\\t\\t\\t\\tcurr += 1;\\n\\t\\t\\t\\tsum += curr;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr = 0;\\n\\t\\t\\t}\\n\\t\\treturn sum;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1071335,
                "title": "c-math-o-n-0ms-beats-100-no-extra-space-explanation",
                "content": "**EXPLANATION**\\n- First check whether the size of ```A``` is less than 3 or not.\\n\\t```\\n\\tint n=A.size();\\n\\tif(n<3) return 0;\\n\\t```\\n- Then, create few variables:\\n\\t- ```ans``` : To store our answer\\n\\t- ```curr``` : To store the count of numbers in last arithmetic sequence\\n\\t- ```last_diff``` : To store the difference of last consequtive numbers\\n\\t```\\n\\tint ans=0,curr=0,last_diff=A[1]-A[0];\\n\\t```\\n- Finally, iterate ```A``` starting from **```i=1```** and in each iteration, find the difference between current and next consecutive number, ```curr_diff = A[i+1] - A[i]```.Then, check weather ```curr_diff==last_diff```:\\n\\t- If true, then ```++curr```, as now ```A[i+1]``` also contribute to the last arithmetic sequence\\n\\t- If false, then ```curr=0```; since, `A[i+1]` no longer contribute to the last arithmetic sequence, so need to reset ```curr=0``` and replace ```curr_diff with last_diff```(as both are different now).\\nAt the end of it, **add** the ```curr``` value to our ```ans```.\\n\\t```\\n\\tfor(int i=1;i<n-1;++i){\\n\\t\\tint curr_diff=A[i+1]-A[i]; // current difference \\n\\n\\t\\tif(curr_diff==last_diff){ // if last difference == current difference\\n\\t\\t\\t++curr; // then \"A[i+1]\" also contribute to the last arithmetic sequence\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tlast_diff=curr_diff; // we need to reset curr=0 and replace curr_diff with last_diff\\n\\t\\t\\tcurr=0;\\n\\t\\t}\\n\\t\\tans+=curr; // add current continuous arithmetic sequence count to ans\\n\\t}\\n\\t```\\n\\t\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int n=A.size();\\n        if(n<3) return 0;\\n        \\n        // curr is the count of current continuous sequence of arithmetic numbers\\n        // last_diff is A[i]-A[i-1], for any \"i\", that is last_difference of the previous arithmetic sequence(if exist)\\n        int ans=0,curr=0,last_diff=A[1]-A[0];\\n        \\n        for(int i=1;i<n-1;++i){\\n            int curr_diff=A[i+1]-A[i]; // current difference \\n            \\n            if(curr_diff==last_diff){ // if last difference == current difference\\n                ++curr; // then \"A[i+1]\" also contribute to the last arithmetic sequence\\n            }\\n            else{\\n                last_diff=curr_diff; // we need to reset curr=0 and replace curr_diff with last_diff\\n                curr=0;\\n            }\\n            ans+=curr; // add current continuous arithmetic sequence count to ans\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```A```\n```\\n\\tint n=A.size();\\n\\tif(n<3) return 0;\\n\\t```\n```ans```\n```curr```\n```last_diff```\n```\\n\\tint ans=0,curr=0,last_diff=A[1]-A[0];\\n\\t```\n```A```\n```i=1```\n```curr_diff = A[i+1] - A[i]```\n```curr_diff==last_diff```\n```++curr```\n```A[i+1]```\n```curr=0```\n```curr=0```\n```curr_diff with last_diff```\n```curr```\n```ans```\n```\\n\\tfor(int i=1;i<n-1;++i){\\n\\t\\tint curr_diff=A[i+1]-A[i]; // current difference \\n\\n\\t\\tif(curr_diff==last_diff){ // if last difference == current difference\\n\\t\\t\\t++curr; // then \"A[i+1]\" also contribute to the last arithmetic sequence\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tlast_diff=curr_diff; // we need to reset curr=0 and replace curr_diff with last_diff\\n\\t\\t\\tcurr=0;\\n\\t\\t}\\n\\t\\tans+=curr; // add current continuous arithmetic sequence count to ans\\n\\t}\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int n=A.size();\\n        if(n<3) return 0;\\n        \\n        // curr is the count of current continuous sequence of arithmetic numbers\\n        // last_diff is A[i]-A[i-1], for any \"i\", that is last_difference of the previous arithmetic sequence(if exist)\\n        int ans=0,curr=0,last_diff=A[1]-A[0];\\n        \\n        for(int i=1;i<n-1;++i){\\n            int curr_diff=A[i+1]-A[i]; // current difference \\n            \\n            if(curr_diff==last_diff){ // if last difference == current difference\\n                ++curr; // then \"A[i+1]\" also contribute to the last arithmetic sequence\\n            }\\n            else{\\n                last_diff=curr_diff; // we need to reset curr=0 and replace curr_diff with last_diff\\n                curr=0;\\n            }\\n            ans+=curr; // add current continuous arithmetic sequence count to ans\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814513,
                "title": "c-detailed-explanation-w-two-approaches-see-how-actually-it-works-dry-run",
                "content": "***Brief note about Question-***\\n* We have to return *the number of arithmetic subarrays of an array.*\\n* An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5,7,9,10,11,12,13]\\n\\nThen, answer should be 7,How 7?\\nLet see,\\n\\n[5, 7, 9] (having a difference of 2 i.e 7 - 5 == 9 - 7 == 2)  [\"For element upto 9\"]\\n\\n[9, 10, 11] (having a difference of 1 i.e 10 - 9 == 11 - 10 == 1) [\"For element upto 11\"]\\n\\n[9, 10, 11, 12] (having a difference of 1 ) [\"For element upto 12\"]\\n[10, 11, 12] (having a difference of 1 )  \\n\\n[9, 10, 11, 12, 13] (having a difference of 1 ) [\"For element upto 13\"]\\n[10, 11, 12, 13] (having a difference of 1 )\\n[11, 12, 13] (having a difference of 1 )\\n\\nIf we count above all, then answer comes out to be 7.\\n```\\n___________\\n***Solution - I (DP, Accepted)-***\\n* First thing that we will see, if the size of the array is greater than 2, after that only we are able to calculate our answer.\\n* What we will in DP? what DP says?\\n* We use DP, because DP stop us for repeating some calculation, that we have already calculate pevuously.\\n* So, Is their anything required like DP? \\n* Answer is Yess!!, We make an dp array `(we say it as t)`, and then we starting storing result, by saying that,\\n* Upto this point, how many number of subarrays are their, with a given difference.\\n* If the current difference is same as the previous diffference, then we say, all the previous arrays are also applicable with  this current element, so we increase our dp[i] as `d[i] = dp[i -1] + 1`\\n* Let\\'s understand with example.\\n```\\nSuppose our array is arr[]: [5,7,9,10,11,12,13]\\n\\nHere, we know for to be arithmatic slice, we need atleast three elements, \\n\\nwe intiliaze our answer as zero,\\n    ans = 0, as it tells us number of all the subarrays\\n\\t\\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n              \\u2191\\n\\t\\t\\t  so, first subarray containg three elements is [5,7 9]\\n              we check whether is satisfies our required criteria or not, \\n              i.e [7 - 5] == [9 - 7] == 2\\n              and yess, it satisfies our required criteria, then we will say,\\n              okay, upto this point (that means upto the index of 9 i.e 2) \\n              upto this index we got an subarray as our possible answer, so\\n              we increase our dp[2] by 1\\n\\t\\t\\t  and our answer now become \\n\\t\\t\\t  ans = ans + dp[i] (and currently we are on index 2 i.e i  = 2)\\n\\t\\t\\t  so ans = 0 + dp[2] = 0 + 1 = 1\\n\\t\\t\\t  ans = 1, means it says that till now we got an subarray satisfiesing the condition\\n\\t\\t\\t  and that subarray is [5,7,9]\\n\\t\\t\\t  \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                  \\u2191\\n\\t\\t\\t\\t  Now, we move to our next element i.e 10 (current index become 3, i.e , i = 3)\\n\\t\\t\\t\\t  we will check difference with its previous element\\n\\t\\t\\t\\t  so it comes out to be [10 - 9] == 1,\\n\\t\\t\\t\\t  now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t  so for that, we take difference  of [9 - 7] == 2\\n\\t\\t\\t\\t  but it comes out to be 1, then we say it does not satisfies our criteria,\\n\\t\\t\\t\\t  so dp[3] = 0 (means we are not able to get any subarray at this point satisfising criteria)\\n\\t\\t\\t\\t  now, our answer now become \\n\\t\\t\\t     ans = ans + dp[i] (and currently we are on index 3 i.e i  = 3)\\n\\t\\t\\t     so ans = 1 + dp[3] = 1 + 0 = 1\\n\\t\\t\\t     ans = 1, means it says that till now we got an subarray satisfiesing the condition\\n\\t\\t\\t\\t \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  Now, we move to our next element i.e 11 (current index become 4, i.e , i = 4)\\n\\t\\t\\t\\t\\t  we will check difference with its previous element\\n\\t\\t\\t\\t      so it comes out to be [11 - 10] == 1,\\n\\t\\t\\t\\t\\t  now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t\\t  so for that, we take difference  of [10 - 9] == 1\\n\\t\\t\\t\\t\\t  and yess, it satisfies our required criteria, then we will say\\n\\t\\t\\t\\t\\t  okay, upto this point (that means upto the index of 11 i.e 4)\\n\\t\\t\\t\\t\\t  upto this index we got an subarray as our possible answer, so\\n\\t\\t\\t\\t\\t  we increase our dp[4] by 1\\n\\t\\t\\t\\t\\t  so, it becomes\\n\\t\\t\\t\\t\\t  dp[i] = dp[i - 1] + 1\\n\\t\\t\\t\\t\\t  dp[4] = dp[3] + 1\\n\\t\\t\\t\\t\\t  dp[4] = 0 + 1\\n\\t\\t\\t\\t\\t  dp[4] = 1\\n\\t\\t\\t\\t\\t  so, on 4th point we got an answer and i.e [9, 10, 11]\\n\\t\\t\\t\\t\\t  now, our answer now become\\n\\t\\t\\t\\t\\t  ans = ans + dp[i] (and currently we are on index 4 i.e i  = 4)\\n\\t\\t\\t\\t\\t  so ans = 1 + dp[4] = 1 + 1 = 2\\n\\t\\t\\t\\t\\t  ans = 2, says that till now we got two possible subarrays as our answer \\n\\t\\t\\t\\t\\t  and that subarrays are [5,7,9] and [9, 10, 11]\\n\\t\\t\\t\\t\\t  \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                         \\u2191\\n\\t\\t\\t\\t\\t     Now, we move to our next element i.e 12 (current index become 5, i.e , i = 5)\\n\\t\\t\\t\\t\\t\\t we will check difference with its previous element\\n\\t\\t\\t\\t\\t\\t so it comes out to be [12 - 11] == 1\\n\\t\\t\\t\\t\\t\\t now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t\\t\\t so for that, we take difference  of [11 - 10] == 1\\n\\t\\t\\t\\t\\t\\t and yess, it satisfies our required criteria, then we will say\\n\\t\\t\\t\\t\\t\\t okay, upto this point (that means upto the index of 12 i.e 5)\\n\\t\\t\\t\\t\\t\\t upto this index we got an subarray as our possible answer, so\\n\\t\\t\\t\\t\\t\\t we increase our dp[5] by 1\\n\\t\\t\\t\\t\\t\\t so, it becomes\\n\\t\\t\\t\\t\\t\\t dp[i] = dp[i - 1] + 1\\n\\t\\t\\t\\t\\t\\t dp[5] = dp[4] + 1\\n\\t\\t\\t\\t\\t\\t dp[5] = 1 + 1\\n\\t\\t\\t\\t\\t\\t dp[5] = 2\\n\\t\\t\\t\\t\\t\\t so, on 5th index we got two possible answers, i. e [9,10,11,12] and [10,11,12]\\n\\t\\t\\t\\t\\t\\t now, our answer now become\\n\\t\\t\\t\\t\\t\\t ans = ans + dp[i] (and currently we are on index 5 i.e i  = 5)\\n\\t\\t\\t\\t\\t\\t so ans = 2 + dp[5] = 2 + 2 = 4\\n\\t\\t\\t\\t\\t\\t ans = 4, says that till now we got four possible subarrays as our answer\\n\\t\\t\\t\\t\\t\\t and that subarrays are [5,7,9] , [9, 10, 11] , [9,10,11,12] and [10,11,12]\\n\\t\\t\\t\\t\\t\\t \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                              \\u2191\\n\\t\\t\\t\\t\\t\\t\\t  Now, we move to our next element i.e 13 (current index become 6, i.e , i = 6)\\n\\t\\t\\t\\t\\t\\t\\t  we will check difference with its previous element\\n\\t\\t\\t\\t\\t\\t\\t  so it comes out to be [13 - 12] == 1\\n\\t\\t\\t\\t\\t\\t\\t  now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t\\t\\t\\t  so for that, we take difference  of [12 - 11] == 1\\n\\t\\t\\t\\t\\t\\t\\t  and yess, it satisfies our required criteria, then we will say\\n\\t\\t\\t\\t\\t\\t\\t  okay, upto this point (that means upto the index of 13 i.e 6)\\n\\t\\t\\t\\t\\t\\t\\t  upto this index we got an subarray as our possible answer, so\\n\\t\\t\\t\\t\\t\\t\\t  we increase our dp[6] by 1\\n\\t\\t\\t\\t\\t\\t\\t  so, it becomes\\n\\t\\t\\t\\t\\t\\t\\t  dp[i] = dp[i - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\t  dp[6] = dp[5] + 1\\n\\t\\t\\t\\t\\t\\t\\t  dp[6] = 2 + 1\\n\\t\\t\\t\\t\\t\\t\\t  dp[6]  = 3\\n\\t\\t\\t\\t\\t\\t\\t  so, on 6th index we got three possible answers, i. e \\n\\t\\t\\t\\t\\t\\t\\t  [9,10,11,12,13], [10, 11, 12, 13] and [11, 12, 13]\\n\\t\\t\\t\\t\\t\\t\\t  now, our answer now become\\n\\t\\t\\t\\t\\t\\t\\t  ans = ans + dp[i] (and currently we are on index 6 i.e i  = 6)\\n\\t\\t\\t\\t\\t\\t\\t  so ans = 4 + dp[6] = 4 + 3 = 7\\n\\t\\t\\t\\t\\t\\t\\t  ans = 7, says that till now we got 7 possible subarrays as our answer i.e\\n\\t\\t\\t\\t\\t\\t\\t  and that subarrays are \\n\\t\\t\\t\\t\\t\\t\\t  [5,7,9] , [9, 10, 11] , [9,10,11,12] , [10,11,12], [9,10,11,12,13], [10, 11, 12, 13] and [11, 12, 13]\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\nNow, we reached to our last index, and whatever should be the answer is our final answer,\\nso the final answer should be 7\\n```\\n___\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will use dp array for storing answer\\n\\nIt paases [ 15 / 15 ] in built test cases\\n```\\n____\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int dp[5001] = {0}; // intiliaze dp and intially give all elements value as zero\\n    \\n    int numberOfArithmeticSlices(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        if(n < 3) // if the size of the array is less than 3,\\n        {\\n            return 0; // then answer is not possible, simply return 0\\n        }\\n        \\n        // for the first subarray\\n        if(arr[2] - arr[1] == arr[1] - arr[0])\\n        {\\n            dp[2] = 1;\\n        }\\n        \\n        int ans = 0;  // variable that stores our final answer\\n        \\n        // start traversing from the loop\\n        for(int i = 2; i < n; i++)\\n        {\\n            // for curremt element check difference with previous elements\\n            if(arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2])\\n            {\\n                // if difference is same increase dp[i] by 1\\n                dp[i] = dp[i - 1] + 1; \\n            }\\n            \\n            // and add to our answer\\n            ans = ans + dp[i];\\n        }\\n        \\n        return ans; // finally return answer\\n    }\\n};\\n```\\n___________\\n***Solution - II (using NORMAL observation, Accepted)-***\\n* Now, question arieses do we really need dp to store our answer?\\n* Can\\'t is their any way so that we just change our answer variable.\\n* Ans is YESS!!, Actually we don\\'t need dp.\\n* See, by using dp, what awe are trying to say, we want to say that, okay at this point how many subarrays we got satisfising condition and for that what we will doing we simply seeing the difference with previous elements.\\n* So, what happen if we make an temp element and do that our whole calculation in that variable only.\\n* See, code , you will got this easily.\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we will be not using anything from our side\\n\\nIt paases [ 15 / 15 ] in built test cases\\n```\\n_____\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        if(n < 3)  // if size is less than 3\\n        {\\n            return 0; // then simply return 0\\n        }\\n        \\n        int ans = 0, curr = 0; // declaring variables\\n        \\n        // for the first part\\n        // it stores what is the difference of last consecutive elements\\n        int last_diff = arr[1] - arr[0];\\n        \\n        // start traversing from the array\\n        for(int i = 1; i < n - 1; i++)\\n        {\\n            // for any index what is the current difference\\n            int curr_diff = arr[i + 1] - arr[i];\\n            \\n            // if current difference is equal to the last difference\\n            if(curr_diff == last_diff)\\n            {\\n                curr++; // increase current variable\\n            }\\n            else // but if not, give current difference to last difference\\n            {\\n                last_diff = curr_diff;\\n                curr = 0; // and make curr to zero, as we have to do a new start\\n            }\\n            \\n            ans = ans + curr; // add current to our answer\\n        }\\n        \\n        return ans; // finally return the answer\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5,7,9,10,11,12,13]\\n\\nThen, answer should be 7,How 7?\\nLet see,\\n\\n[5, 7, 9] (having a difference of 2 i.e 7 - 5 == 9 - 7 == 2)  [\"For element upto 9\"]\\n\\n[9, 10, 11] (having a difference of 1 i.e 10 - 9 == 11 - 10 == 1) [\"For element upto 11\"]\\n\\n[9, 10, 11, 12] (having a difference of 1 ) [\"For element upto 12\"]\\n[10, 11, 12] (having a difference of 1 )  \\n\\n[9, 10, 11, 12, 13] (having a difference of 1 ) [\"For element upto 13\"]\\n[10, 11, 12, 13] (having a difference of 1 )\\n[11, 12, 13] (having a difference of 1 )\\n\\nIf we count above all, then answer comes out to be 7.\\n```\n```\\nSuppose our array is arr[]: [5,7,9,10,11,12,13]\\n\\nHere, we know for to be arithmatic slice, we need atleast three elements, \\n\\nwe intiliaze our answer as zero,\\n    ans = 0, as it tells us number of all the subarrays\\n\\t\\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n              \\u2191\\n\\t\\t\\t  so, first subarray containg three elements is [5,7 9]\\n              we check whether is satisfies our required criteria or not, \\n              i.e [7 - 5] == [9 - 7] == 2\\n              and yess, it satisfies our required criteria, then we will say,\\n              okay, upto this point (that means upto the index of 9 i.e 2) \\n              upto this index we got an subarray as our possible answer, so\\n              we increase our dp[2] by 1\\n\\t\\t\\t  and our answer now become \\n\\t\\t\\t  ans = ans + dp[i] (and currently we are on index 2 i.e i  = 2)\\n\\t\\t\\t  so ans = 0 + dp[2] = 0 + 1 = 1\\n\\t\\t\\t  ans = 1, means it says that till now we got an subarray satisfiesing the condition\\n\\t\\t\\t  and that subarray is [5,7,9]\\n\\t\\t\\t  \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                  \\u2191\\n\\t\\t\\t\\t  Now, we move to our next element i.e 10 (current index become 3, i.e , i = 3)\\n\\t\\t\\t\\t  we will check difference with its previous element\\n\\t\\t\\t\\t  so it comes out to be [10 - 9] == 1,\\n\\t\\t\\t\\t  now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t  so for that, we take difference  of [9 - 7] == 2\\n\\t\\t\\t\\t  but it comes out to be 1, then we say it does not satisfies our criteria,\\n\\t\\t\\t\\t  so dp[3] = 0 (means we are not able to get any subarray at this point satisfising criteria)\\n\\t\\t\\t\\t  now, our answer now become \\n\\t\\t\\t     ans = ans + dp[i] (and currently we are on index 3 i.e i  = 3)\\n\\t\\t\\t     so ans = 1 + dp[3] = 1 + 0 = 1\\n\\t\\t\\t     ans = 1, means it says that till now we got an subarray satisfiesing the condition\\n\\t\\t\\t\\t \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  Now, we move to our next element i.e 11 (current index become 4, i.e , i = 4)\\n\\t\\t\\t\\t\\t  we will check difference with its previous element\\n\\t\\t\\t\\t      so it comes out to be [11 - 10] == 1,\\n\\t\\t\\t\\t\\t  now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t\\t  so for that, we take difference  of [10 - 9] == 1\\n\\t\\t\\t\\t\\t  and yess, it satisfies our required criteria, then we will say\\n\\t\\t\\t\\t\\t  okay, upto this point (that means upto the index of 11 i.e 4)\\n\\t\\t\\t\\t\\t  upto this index we got an subarray as our possible answer, so\\n\\t\\t\\t\\t\\t  we increase our dp[4] by 1\\n\\t\\t\\t\\t\\t  so, it becomes\\n\\t\\t\\t\\t\\t  dp[i] = dp[i - 1] + 1\\n\\t\\t\\t\\t\\t  dp[4] = dp[3] + 1\\n\\t\\t\\t\\t\\t  dp[4] = 0 + 1\\n\\t\\t\\t\\t\\t  dp[4] = 1\\n\\t\\t\\t\\t\\t  so, on 4th point we got an answer and i.e [9, 10, 11]\\n\\t\\t\\t\\t\\t  now, our answer now become\\n\\t\\t\\t\\t\\t  ans = ans + dp[i] (and currently we are on index 4 i.e i  = 4)\\n\\t\\t\\t\\t\\t  so ans = 1 + dp[4] = 1 + 1 = 2\\n\\t\\t\\t\\t\\t  ans = 2, says that till now we got two possible subarrays as our answer \\n\\t\\t\\t\\t\\t  and that subarrays are [5,7,9] and [9, 10, 11]\\n\\t\\t\\t\\t\\t  \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                         \\u2191\\n\\t\\t\\t\\t\\t     Now, we move to our next element i.e 12 (current index become 5, i.e , i = 5)\\n\\t\\t\\t\\t\\t\\t we will check difference with its previous element\\n\\t\\t\\t\\t\\t\\t so it comes out to be [12 - 11] == 1\\n\\t\\t\\t\\t\\t\\t now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t\\t\\t so for that, we take difference  of [11 - 10] == 1\\n\\t\\t\\t\\t\\t\\t and yess, it satisfies our required criteria, then we will say\\n\\t\\t\\t\\t\\t\\t okay, upto this point (that means upto the index of 12 i.e 5)\\n\\t\\t\\t\\t\\t\\t upto this index we got an subarray as our possible answer, so\\n\\t\\t\\t\\t\\t\\t we increase our dp[5] by 1\\n\\t\\t\\t\\t\\t\\t so, it becomes\\n\\t\\t\\t\\t\\t\\t dp[i] = dp[i - 1] + 1\\n\\t\\t\\t\\t\\t\\t dp[5] = dp[4] + 1\\n\\t\\t\\t\\t\\t\\t dp[5] = 1 + 1\\n\\t\\t\\t\\t\\t\\t dp[5] = 2\\n\\t\\t\\t\\t\\t\\t so, on 5th index we got two possible answers, i. e [9,10,11,12] and [10,11,12]\\n\\t\\t\\t\\t\\t\\t now, our answer now become\\n\\t\\t\\t\\t\\t\\t ans = ans + dp[i] (and currently we are on index 5 i.e i  = 5)\\n\\t\\t\\t\\t\\t\\t so ans = 2 + dp[5] = 2 + 2 = 4\\n\\t\\t\\t\\t\\t\\t ans = 4, says that till now we got four possible subarrays as our answer\\n\\t\\t\\t\\t\\t\\t and that subarrays are [5,7,9] , [9, 10, 11] , [9,10,11,12] and [10,11,12]\\n\\t\\t\\t\\t\\t\\t \\nindex: [0, 1, 2,  3, 4,  5,  6]\\narr[]: [5, 7, 9, 10, 11, 12, 13]\\n                              \\u2191\\n\\t\\t\\t\\t\\t\\t\\t  Now, we move to our next element i.e 13 (current index become 6, i.e , i = 6)\\n\\t\\t\\t\\t\\t\\t\\t  we will check difference with its previous element\\n\\t\\t\\t\\t\\t\\t\\t  so it comes out to be [13 - 12] == 1\\n\\t\\t\\t\\t\\t\\t\\t  now we will check, whether 1 is that difference of all possible previous subarrays\\n\\t\\t\\t\\t\\t\\t\\t  so for that, we take difference  of [12 - 11] == 1\\n\\t\\t\\t\\t\\t\\t\\t  and yess, it satisfies our required criteria, then we will say\\n\\t\\t\\t\\t\\t\\t\\t  okay, upto this point (that means upto the index of 13 i.e 6)\\n\\t\\t\\t\\t\\t\\t\\t  upto this index we got an subarray as our possible answer, so\\n\\t\\t\\t\\t\\t\\t\\t  we increase our dp[6] by 1\\n\\t\\t\\t\\t\\t\\t\\t  so, it becomes\\n\\t\\t\\t\\t\\t\\t\\t  dp[i] = dp[i - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\t  dp[6] = dp[5] + 1\\n\\t\\t\\t\\t\\t\\t\\t  dp[6] = 2 + 1\\n\\t\\t\\t\\t\\t\\t\\t  dp[6]  = 3\\n\\t\\t\\t\\t\\t\\t\\t  so, on 6th index we got three possible answers, i. e \\n\\t\\t\\t\\t\\t\\t\\t  [9,10,11,12,13], [10, 11, 12, 13] and [11, 12, 13]\\n\\t\\t\\t\\t\\t\\t\\t  now, our answer now become\\n\\t\\t\\t\\t\\t\\t\\t  ans = ans + dp[i] (and currently we are on index 6 i.e i  = 6)\\n\\t\\t\\t\\t\\t\\t\\t  so ans = 4 + dp[6] = 4 + 3 = 7\\n\\t\\t\\t\\t\\t\\t\\t  ans = 7, says that till now we got 7 possible subarrays as our answer i.e\\n\\t\\t\\t\\t\\t\\t\\t  and that subarrays are \\n\\t\\t\\t\\t\\t\\t\\t  [5,7,9] , [9, 10, 11] , [9,10,11,12] , [10,11,12], [9,10,11,12,13], [10, 11, 12, 13] and [11, 12, 13]\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\nNow, we reached to our last index, and whatever should be the answer is our final answer,\\nso the final answer should be 7\\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will use dp array for storing answer\\n\\nIt paases [ 15 / 15 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[5001] = {0}; // intiliaze dp and intially give all elements value as zero\\n    \\n    int numberOfArithmeticSlices(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        if(n < 3) // if the size of the array is less than 3,\\n        {\\n            return 0; // then answer is not possible, simply return 0\\n        }\\n        \\n        // for the first subarray\\n        if(arr[2] - arr[1] == arr[1] - arr[0])\\n        {\\n            dp[2] = 1;\\n        }\\n        \\n        int ans = 0;  // variable that stores our final answer\\n        \\n        // start traversing from the loop\\n        for(int i = 2; i < n; i++)\\n        {\\n            // for curremt element check difference with previous elements\\n            if(arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2])\\n            {\\n                // if difference is same increase dp[i] by 1\\n                dp[i] = dp[i - 1] + 1; \\n            }\\n            \\n            // and add to our answer\\n            ans = ans + dp[i];\\n        }\\n        \\n        return ans; // finally return answer\\n    }\\n};\\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we will be not using anything from our side\\n\\nIt paases [ 15 / 15 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        if(n < 3)  // if size is less than 3\\n        {\\n            return 0; // then simply return 0\\n        }\\n        \\n        int ans = 0, curr = 0; // declaring variables\\n        \\n        // for the first part\\n        // it stores what is the difference of last consecutive elements\\n        int last_diff = arr[1] - arr[0];\\n        \\n        // start traversing from the array\\n        for(int i = 1; i < n - 1; i++)\\n        {\\n            // for any index what is the current difference\\n            int curr_diff = arr[i + 1] - arr[i];\\n            \\n            // if current difference is equal to the last difference\\n            if(curr_diff == last_diff)\\n            {\\n                curr++; // increase current variable\\n            }\\n            else // but if not, give current difference to last difference\\n            {\\n                last_diff = curr_diff;\\n                curr = 0; // and make curr to zero, as we have to do a new start\\n            }\\n            \\n            ans = ans + curr; // add current to our answer\\n        }\\n        \\n        return ans; // finally return the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242396,
                "title": "python-short-solution-with-explanation",
                "content": "```\\n\"\"\"\\nEvery digit that gets added to the sequence adds \\'n\\' more possibilities to the output where \\'n\\' is the difference between number of digits in array and 3.\\n\\ne.g For [1,2,3] we have [1,2,3]\\nFor [1,2,3,4] we have [1,2,3], [1,2,3,4], [2,3,4] ie it adds 2 new sub-arrays ending with 4.\\nFor [1,2,3,4,5], we have [1,2,3,4,5], [2,3,4,5], [3,4,5] ie it adds 3 new sub-arrays ending with 5 to whatever we could make with 4 elements ie [1,2,3,4]\\nLikewise for 6 elements, we will have 4 new sub-arrays that\\'d be added, so on and forth.\\n\\nTLDR:\\n\\nSo the logic is to add 1 to every single element that gets added in the sequence.\\n\\n\"\"\"\\nclass Solution(object):\\n    def numberOfArithmeticSlices(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total_sequences = seq_count = 0\\n\\n        for i in xrange(2, len(A)):\\n        \\tif A[i] - A[i-1] == A[i-1] - A[i-2]:\\n        \\t\\tseq_count += 1\\n        \\t\\ttotal_sequences += seq_count\\n        \\telse:\\n        \\t\\tseq_count = 0\\n\\n        return total_sequences\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nEvery digit that gets added to the sequence adds \\'n\\' more possibilities to the output where \\'n\\' is the difference between number of digits in array and 3.\\n\\ne.g For [1,2,3] we have [1,2,3]\\nFor [1,2,3,4] we have [1,2,3], [1,2,3,4], [2,3,4] ie it adds 2 new sub-arrays ending with 4.\\nFor [1,2,3,4,5], we have [1,2,3,4,5], [2,3,4,5], [3,4,5] ie it adds 3 new sub-arrays ending with 5 to whatever we could make with 4 elements ie [1,2,3,4]\\nLikewise for 6 elements, we will have 4 new sub-arrays that\\'d be added, so on and forth.\\n\\nTLDR:\\n\\nSo the logic is to add 1 to every single element that gets added in the sequence.\\n\\n\"\"\"\\nclass Solution(object):\\n    def numberOfArithmeticSlices(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total_sequences = seq_count = 0\\n\\n        for i in xrange(2, len(A)):\\n        \\tif A[i] - A[i-1] == A[i-1] - A[i-2]:\\n        \\t\\tseq_count += 1\\n        \\t\\ttotal_sequences += seq_count\\n        \\telse:\\n        \\t\\tseq_count = 0\\n\\n        return total_sequences\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815680,
                "title": "c-o-n-beats-100-smallest-easy-to-understand-solution",
                "content": "**Please upvote if you like it. Thanks :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n<3){\\n            return 0;\\n        }\\n        int ans = 0, count = 0;\\n        for (int i=1;i<n-1;i++){\\n            if (nums[i+1]-nums[i]==nums[i]-nums[i-1]){\\n                count++;\\n                ans +=count;\\n            }\\n            else{\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n<3){\\n            return 0;\\n        }\\n        int ans = 0, count = 0;\\n        for (int i=1;i<n-1;i++){\\n            if (nums[i+1]-nums[i]==nums[i]-nums[i-1]){\\n                count++;\\n                ans +=count;\\n            }\\n            else{\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071502,
                "title": "javascript-dynamic-programming-dp-solution-that-s-easy-to-understand",
                "content": "**Note**: I did not get this on my first try. I had to peek, but after seeing I understand. I was on the right path to finding this solution.\\n\\n**Requirements**\\n* A minimum of 3 elements is needed to make a slice\\n* A slice can be 3 or more elements, and each additional element counts as a unique slice\\n\\n**Dynamic Programming** is the act of using a previous sub-problem to find a new sub-problems solution. Let\\'s take the following example into account.\\n\\n`[1, 2, 3, 4]`  ---> `[1,2,3]`, `[2,3,4]`, `[1,2,3,4]]` ---> **3**\\n\\nWe can visually see that the above array has 3 slices, but it\\'s important to notice that `[1,2,3,4]` is an **extension** of `[1,2,3]`\\n\\nNow let\\'s try this with some DP. First, we need to allocate an array the size of our input, and fill it with zeroes. Afterwards, we are to start from an index, and check to see if the difference between two elements is the same.\\n\\n**Step 1**\\nA  =  `[1, 2, 3, 4]` \\ndp = `[0, 0, 0, 0]`\\n\\n**Step 2**\\nA  =  `[1, 2, 3, 4]` \\ndp = `[0, 0, 1, 0]`\\nWe get a 1 here, because the difference between 1 and 2, and 2 and 3 are the same. So we know this solution for this subproblem is one.\\n\\n**Step 2**\\nA  =  `[1, 2, 3, 4]` \\ndp = `[0, 0, 1, 2]`\\nNow this is the kicker. For this last index, we know [1,2,3,4] is an extension of [1,2,3], **but** [2,3,4] is also it\\'s own arithmetic slice. This 2 comes from the extension of [1,2,3], but also the unique sub-slice of [2,3,4]. `dp[i] = 1 + dp[i - 1];` is summing the previous subproblem (where we got 1), but also adding an additional 1 for the `[2,3,4]` we have found.\\n\\nDynamic programming is weird. This could be done with recursion or even a brute force method, but this is the optimal solution with: \\n\\n**Time**: O(n)\\n**Space**: O(n)\\n\\n```\\nvar numberOfArithmeticSlices = function (A) {\\n\\tlet sum = 0,\\n\\t\\tdp = Array(A.length).fill(0);\\n\\n\\tfor (var i = 2; i <= dp.length - 1; i++) {\\n\\t\\tif (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {\\n\\t\\t\\tdp[i] = 1 + dp[i - 1];\\n\\t\\t\\tsum += dp[i];\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar numberOfArithmeticSlices = function (A) {\\n\\tlet sum = 0,\\n\\t\\tdp = Array(A.length).fill(0);\\n\\n\\tfor (var i = 2; i <= dp.length - 1; i++) {\\n\\t\\tif (A[i] - A[i - 1] === A[i - 1] - A[i - 2]) {\\n\\t\\t\\tdp[i] = 1 + dp[i - 1];\\n\\t\\t\\tsum += dp[i];\\n\\t\\t}\\n\\t}\\n\\n\\treturn sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071074,
                "title": "python-oneliner-using-groupby-explained",
                "content": "Let us understand, what arithmetic slice means on the example \\n`1, 2, 3, 4, 5, 10, 12, 14, 16`.\\n\\nFirst of all, we can take only adjacent elements, we can not take elements `[1, 3, 5]` for example.\\n\\nLet us evaluate differences between adjacent elements.\\n\\n`1, 1, 1, 1, 5, 2, 2, 2`\\n\\nWe can say that arithmetic slice in original list are groups of `>=2` elements with equal values. So, what we can do is to iterate over groups of elements and calcualate answer for each group. Let us look at first one: we can take:\\n\\n`1, 2, 3`, `2, 3, 4`, `3, 4, 5`, `1, 2, 3, 4`, `2, 3, 4, 5`, `1, 2, 3, 4, 5`.\\n\\nIn general case, if we have group of lenth `k` in list of differences, we have exaclty `k(k-1)/2` arithmetic slices. Note, that this also deal correctly with `k = 1` case, where we have arithmetic progression of length `2`, which is not slice.\\n\\nHowever if you use groupby and will write `(len(list(j))-1)*len(list(j))//2 for ...`, it is not going to work properly, because groupby is iterator objext and it will take next `j`, which is not correct. We can use here the following trick: note, that\\n\\n`k(k-1)/2 = ((2*k-1)^2 - 1)/ 8`, which uses only one yield from iterator groupby.\\n\\n**Complexity**: time complexity is just `O(n)`, because we iterate list once to get differences and iterate it second time, evaluating sum. Space complexity is `O(n)`, because we create list `B` here. If you know how to still keep it oneliner but make it `O(1)` space, **please, let me know!**\\n\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A):\\n        B =  [j-i for i,j in zip(A, A[1:])]\\n        return sum(((2*len(list(j))-1)**2-1)//8 for i, j in groupby(B))\\n```\\n\\n### Oneliner\\n\\nIt can be written as:\\n\\n```\\nreturn sum(((2*len(list(j))-1)**2-1)//8 for i, j in groupby([j-i for i,j in zip(A, A[1:])]))\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A):\\n        B =  [j-i for i,j in zip(A, A[1:])]\\n        return sum(((2*len(list(j))-1)**2-1)//8 for i, j in groupby(B))\\n```\n```\\nreturn sum(((2*len(list(j))-1)**2-1)//8 for i, j in groupby([j-i for i,j in zip(A, A[1:])]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90057,
                "title": "2ms-java-o-n-time-o-1-space-solution",
                "content": "\\n```\\npublic int numberOfArithmeticSlices(int[] A) {\\n        if(A == null || A.length < 3)\\n            return 0;\\n        int sum = 0;\\n        int len = 2;\\n\\n        for(int i=2;i<A.length;i++) {\\n\\n            // keep increasing the splice\\n            if(A[i] - A[i-1] == A[i-1] - A[i-2]) {\\n                len++;\\n            }\\n            else {\\n                if(len > 2) {\\n                    sum += calculateSlices(len);\\n                }\\n                // reset the length of new slice\\n                len = 2;\\n            }\\n        }\\n        // add up the slice in the rear\\n        if(len>2)\\n            sum += calculateSlices(len);\\n\\n        return sum;\\n    }\\n\\n    private int calculateSlices(int n){\\n        return (n-1)*(n-2)/2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numberOfArithmeticSlices(int[] A) {\\n        if(A == null || A.length < 3)\\n            return 0;\\n        int sum = 0;\\n        int len = 2;\\n\\n        for(int i=2;i<A.length;i++) {\\n\\n            // keep increasing the splice\\n            if(A[i] - A[i-1] == A[i-1] - A[i-2]) {\\n                len++;\\n            }\\n            else {\\n                if(len > 2) {\\n                    sum += calculateSlices(len);\\n                }\\n                // reset the length of new slice\\n                len = 2;\\n            }\\n        }\\n        // add up the slice in the rear\\n        if(len>2)\\n            sum += calculateSlices(len);\\n\\n        return sum;\\n    }\\n\\n    private int calculateSlices(int n){\\n        return (n-1)*(n-2)/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814767,
                "title": "well-explained-and-easy-to-understand-with-2-approaches-optimal-aproach",
                "content": "## ***1st Solution: time O(n), space: O(n)|| Optimal***\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n    int curr = 0, sum = 0;\\n    for (int i=2; i<A.length; i++)\\n        if (A[i]-A[i-1] == A[i-1]-A[i-2]) {\\n            curr += 1;\\n            sum += curr;\\n        } else {\\n            curr = 0;\\n        }\\n    return sum;\\n    }\\n}\\n```\\n\\n## ***2nd Solution: time O(n^2), space: O(n^2)***\\n\\n\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n    int n=A.length;\\n    if(n<3){return 0;}\\n    boolean[][] dp=new boolean[n][n]; //initial value is false\\n    int count=0;\\n    for(int i=0;i<n-3+1;i++){\\n        if((A[i+1]-A[i])==(A[i+2]-A[i+1])){\\n            dp[i][i+3-1]=true;\\n            count++;\\n        }\\n    }\\n    for(int k=4;k<=n;k++){\\n        for (int i=0;i<n-k+1;i++){\\n            int j=i+k-1;\\n            if(dp[i+1][j]==true&&(A[i+1]-A[i]==A[i+2]-A[i+1])){\\n                dp[i][j]=true;\\n                count++;\\n            }else if(dp[i][j-1]==true&&(A[j]-A[j-1]==A[j-1]-A[j-2])){\\n                dp[i][j]=true;\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n    int curr = 0, sum = 0;\\n    for (int i=2; i<A.length; i++)\\n        if (A[i]-A[i-1] == A[i-1]-A[i-2]) {\\n            curr += 1;\\n            sum += curr;\\n        } else {\\n            curr = 0;\\n        }\\n    return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n    int n=A.length;\\n    if(n<3){return 0;}\\n    boolean[][] dp=new boolean[n][n]; //initial value is false\\n    int count=0;\\n    for(int i=0;i<n-3+1;i++){\\n        if((A[i+1]-A[i])==(A[i+2]-A[i+1])){\\n            dp[i][i+3-1]=true;\\n            count++;\\n        }\\n    }\\n    for(int k=4;k<=n;k++){\\n        for (int i=0;i<n-k+1;i++){\\n            int j=i+k-1;\\n            if(dp[i+1][j]==true&&(A[i+1]-A[i]==A[i+2]-A[i+1])){\\n                dp[i][j]=true;\\n                count++;\\n            }else if(dp[i][j-1]==true&&(A[j]-A[j-1]==A[j-1]-A[j-2])){\\n                dp[i][j]=true;\\n                count++;\\n            }\\n        }\\n    }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812284,
                "title": "c-solutions-using-recursion-dp-and-formula-in-o-n-time",
                "content": "```\\n\\n//Recursion\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n                slices(A, A.size() - 1);\\n        return sum;\\n\\n        \\n    }\\n    \\n    \\n     int slices(vector<int>& A, int i) {\\n        if (i < 2)\\n            return 0;\\n        int ap = 0;\\n        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n            ap = 1 + slices(A, i - 1);\\n            sum += ap;\\n        } else\\n            slices(A, i - 1);\\n        return ap;\\n    }\\n};\\n\\n//DP\\n\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n   vector<int> dp(A.size());\\n        int sum = 0;\\n        for (int i = 2; i < dp.size(); i++) {\\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n                dp[i] = 1 + dp[i - 1];\\n                sum += dp[i];\\n            }\\n        }\\n        return sum;\\n     \\n    }\\n    \\n    \\n    \\n};\\n\\n\\n//DP with constant space\\n\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n        int sum = 0,cur = 0;\\n        for (int i = 2; i < A.size(); i++) {\\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n                cur += 1;\\n                sum += cur;\\n            }\\n            else\\n                cur = 0;\\n        }\\n        return sum;\\n     \\n    }\\n    \\n    \\n    \\n};\\n\\n//Using Formula\\n\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n               int count = 0;\\n        int sum = 0;\\n        for (int i = 2; i < A.size(); i++) {\\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n                count++;\\n            } else {\\n                sum += (count + 1) * (count) / 2;\\n                count = 0;\\n            }\\n        }\\n        return sum += count * (count + 1) / 2;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n//Recursion\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n                slices(A, A.size() - 1);\\n        return sum;\\n\\n        \\n    }\\n    \\n    \\n     int slices(vector<int>& A, int i) {\\n        if (i < 2)\\n            return 0;\\n        int ap = 0;\\n        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n            ap = 1 + slices(A, i - 1);\\n            sum += ap;\\n        } else\\n            slices(A, i - 1);\\n        return ap;\\n    }\\n};\\n\\n//DP\\n\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n   vector<int> dp(A.size());\\n        int sum = 0;\\n        for (int i = 2; i < dp.size(); i++) {\\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n                dp[i] = 1 + dp[i - 1];\\n                sum += dp[i];\\n            }\\n        }\\n        return sum;\\n     \\n    }\\n    \\n    \\n    \\n};\\n\\n\\n//DP with constant space\\n\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n        int sum = 0,cur = 0;\\n        for (int i = 2; i < A.size(); i++) {\\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n                cur += 1;\\n                sum += cur;\\n            }\\n            else\\n                cur = 0;\\n        }\\n        return sum;\\n     \\n    }\\n    \\n    \\n    \\n};\\n\\n//Using Formula\\n\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        \\n               int count = 0;\\n        int sum = 0;\\n        for (int i = 2; i < A.size(); i++) {\\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\\n                count++;\\n            } else {\\n                sum += (count + 1) * (count) / 2;\\n                count = 0;\\n            }\\n        }\\n        return sum += count * (count + 1) / 2;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90112,
                "title": "python-dp-solution",
                "content": "    def numberOfArithmeticSlices(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        opt, i = [0,0], 1\\n        for j in xrange(2,len(A)):\\n            if A[j]-A[j-1] == A[j-1]-A[j-2]:\\n                opt.append(opt[j-1]+i)\\n                i += 1\\n            else:\\n                opt.append(opt[j-1])\\n                i = 1\\n        return opt[-1]",
                "solutionTags": [],
                "code": "    def numberOfArithmeticSlices(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        opt, i = [0,0], 1\\n        for j in xrange(2,len(A)):\\n            if A[j]-A[j-1] == A[j-1]-A[j-2]:\\n                opt.append(opt[j-1]+i)\\n                i += 1\\n            else:\\n                opt.append(opt[j-1])\\n                i = 1\\n        return opt[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1814917,
                "title": "c-0ms-faster-than-100-explanation-clean-code",
                "content": "**Basic approach**\\n\\n   Our main motive is that find number of continuous elements with equal mutual difference\\n   So we will make a vector of mutual difference of given array\\n  \\n   After that we will traverse that diff array and count number of diff same\\n   ie. diffarr={2,2,2,2,2,4}; \\n   so we will get count = 5.\\n   It means there will be 6 elements whose difference count is 5.\\n   \\n   So, from these 6 elements we can make total number of subsets are\\n  \\uD83D\\uDC49  subset of size 6=1\\n  \\uD83D\\uDC49  subset of size 5=2\\n  \\uD83D\\uDC49  subset of size 4=3\\n  \\uD83D\\uDC49  subset of size 3=4\\n   So, total number of subset = 1+2+3+4=10\\n   \\n   From formula let k=6-3+1=4 (minimum size of subset will be 3)\\n   res=(k * k+1)/2 =(4 * 5)/2 = 10;\\n   As same we can do for all the unique differences.\\n   \\n   \\n   \\n   \\n     class Solution {\\n     public:\\n      int numberOfArithmeticSlices(vector<int>& A) {\\n        int len = A.size();\\n        if (len <= 2) {\\n            return 0;\\n        }\\n\\n        vector<int> arr(len-1, 0);\\n        for (int i = 0; i < len-1; i++) {\\n            arr[i] = A[i+1] - A[i];\\n        }\\n\\n        int n = 1;\\n        int res = 0;\\n        for (int i = 1; i < arr.size(); i++) {\\n            if (arr[i] == arr[i-1]) {\\n                n += 1;\\n            }\\n\\n            if (i == arr.size()-1 || arr[i] != arr[i-1]) {\\n                res += sumHelp(n);\\n                n = 1;\\n            }\\n        }\\n\\n        return res;\\n       }\\n\\n      int sumHelp(int n) {\\n        return n * (n-1) / 2;\\n    }\\n\\t};`",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     public:\\n      int numberOfArithmeticSlices(vector<int>& A) {\\n        int len = A.size();\\n        if (len <= 2) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1814399,
                "title": "python-o-n-solution-dp",
                "content": "**Idea:**\\n1. If we transform the array to a difference array. (e.g. [1, 5, 9, 13, 6, 8, 10] --> [4, 4, 4, -7, 2, 2]), the question becomes asking how many subarrays of length >=2 that consists of identical elements in the diff_arr (I will call them good subarrays).\\n2. To count the total number of good subarrays, we just need to iterate through the array once while keeping track of the current diff and cnt. At each index, we count the number of good subarrays that end at this index and add it to res.\\n\\nThe following is an implementation of the above idea without explicitly constructing the diff array.\\n\\nTime complexity: O(N), because we iterate through the array once, at each index there are only a constant number of operations.\\nSpace complexity: O(1)\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        cur_diff, cnt = -1, 0\\n        res = 0\\n        for i in range(1, len(nums)):\\n            new_diff = nums[i] - nums[i-1]\\n            if new_diff != cur_diff:\\n                cur_diff, cnt = new_diff, 1\\n            else:\\n                res += cnt\\n                cnt += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        cur_diff, cnt = -1, 0\\n        res = 0\\n        for i in range(1, len(nums)):\\n            new_diff = nums[i] - nums[i-1]\\n            if new_diff != cur_diff:\\n                cur_diff, cnt = new_diff, 1\\n            else:\\n                res += cnt\\n                cnt += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696874,
                "title": "2ms-sliding-window-c-basic-math-solution-with-detailed-comments-clean-code",
                "content": "The below is my solution using Sliding Window technique.\\n\\n**Math used:-**\\nSum of 1st n natural numbers = **((n)\\\\*(n+1))/2**.\\n\\nConsider a sequence whose common difference is equal,\\n1. nums =  [1,2,3], then the possible outputs are: [1,2,3] = 1.\\n2. nums =  [1,2,3,4], then the possible outputs are: [1,2,3], [1,2,3,4], [2,3,4]. = 3.\\n3. nums = [1,2,3,4,5], => [1,2,3], [1,2,3,4], [1,2,3,4,5], [2,3,4], [2,3,4,5], [3,4,5] = 6.\\n.\\n.\\n\\nIf we define window as the number of contiguous elements, this resembles the formula **(n\\\\*(n+1))/2** ,where n = (size of window) - 2.\\n\\nLet **k = size of window -2** , then formula will become **((k-2)\\\\*(k-1))/2**.\\n\\n**Solution : **\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3 ) return 0; // Base case\\n\\n        int slices = 0;\\n\\n        // Both ends of sliding window.\\n        int left =0 , right = 1;\\n\\n        // current common difference\\n        int currDiff = nums[right] - nums[left];\\n\\n        // starting from index 2\\n        right++;\\n        while( right < n ){\\n            if( nums[right] - nums[right-1] == currDiff ){\\n                // increase the window size\\n                right++;\\n            }else{\\n                int windowSize = right-left;\\n                if( windowSize >=3 ){\\n                    // add all the possible windows with size >= 3\\n                    slices += ( (windowSize-2) * (windowSize-1) )/2;\\n                }\\n\\n                // as the present element (nums[right]) broke the series, start the window from the element \"nums[right-1]\"\\n                // so window starts from (left = right-1)\\n                left = right-1;\\n                currDiff = nums[right]-nums[left];\\n                right++;\\n            }\\n        }\\n\\n        // case when window extends till the last element\\n        int windowSize = right - left;\\n        if(windowSize>=3)\\n            slices += ( (windowSize-2) * (windowSize-1) )/2;\\n        return slices;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if( n < 3 ) return 0; // Base case\\n\\n        int slices = 0;\\n\\n        // Both ends of sliding window.\\n        int left =0 , right = 1;\\n\\n        // current common difference\\n        int currDiff = nums[right] - nums[left];\\n\\n        // starting from index 2\\n        right++;\\n        while( right < n ){\\n            if( nums[right] - nums[right-1] == currDiff ){\\n                // increase the window size\\n                right++;\\n            }else{\\n                int windowSize = right-left;\\n                if( windowSize >=3 ){\\n                    // add all the possible windows with size >= 3\\n                    slices += ( (windowSize-2) * (windowSize-1) )/2;\\n                }\\n\\n                // as the present element (nums[right]) broke the series, start the window from the element \"nums[right-1]\"\\n                // so window starts from (left = right-1)\\n                left = right-1;\\n                currDiff = nums[right]-nums[left];\\n                right++;\\n            }\\n        }\\n\\n        // case when window extends till the last element\\n        int windowSize = right - left;\\n        if(windowSize>=3)\\n            slices += ( (windowSize-2) * (windowSize-1) )/2;\\n        return slices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814838,
                "title": "0-ms-100-simple-code-brute-force",
                "content": "SOLUTION IN O(N^2)\\n\\n\\n\\n      int c = 0;\\n         if(nums.length < 3)\\n            return 0;\\n        else{\\n            for(int i = 0;i<nums.length;i++){\\n                for(int j = i;j<nums.length-2;j++){     \\n                    if(nums[j]-nums[j+1] == nums[j+1]-nums[j+2])\\n                            c++;\\n                    else break;     \\n                }\\n            }\\n         }\\n        return c;",
                "solutionTags": [
                    "Java"
                ],
                "code": "SOLUTION IN O(N^2)\\n\\n\\n\\n      int c = 0;\\n         if(nums.length < 3)\\n            return 0;\\n        else{\\n            for(int i = 0;i<nums.length;i++){\\n                for(int j = i;j<nums.length-2;j++){     \\n                    if(nums[j]-nums[j+1] == nums[j+1]-nums[j+2])\\n                            c++;\\n                    else break;     \\n                }\\n            }\\n         }\\n        return c;",
                "codeTag": "Unknown"
            },
            {
                "id": 90067,
                "title": "java-2ms-o-n-solution-using-dp-with-detail-explanation",
                "content": "trying to find the relationship between f(n)  and f(n - 1) when A[n] can be part of current arithmetic slice. \\n\\nthen easy to find that if A[n] can be the end of the current arithmetic slice, then the total number of arithmetic slices will be incremented by the length of current slice(including A[n]) - 3 + 1;\\n\\ne.g. \\nwhen 1 2 3 --> (1, 2, 3) increment is 3 - 3 + 1 = 1  \\nwhen 1 2 3 4 --> (2, 3, 4), (1, 2, 3,4),  increment is 4 - 3 + 1 = 2\\nwhen 1 2 3 4 5 --> (3, 4, 5), (2, 3, 4, 5), (1, 2, 3, 4, 5), increment is 5 - 3 + 1 = 3.\\n \\n\\nso the first step is to loop and store the length of arithmetic.\\nsecond loop is to added up all the increments.\\n\\ne.g. [1 2 3 4 0 0 7 8 9]\\nfirst loop [0 0 3 4 0 0 0 0 3];\\nsecond loop sum = (3 - 3 + 1) + (4 - 3 + 1) + 0 + 0 + 0 + 0 + (3 - 3 + 1) = 4\\n\\n```\\npublic class Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        if(A == null || A.length == 0) return 0;\\n        int[] index = new int[A.length];\\n        for(int i = 2; i < index.length; i++)\\n        {\\n        \\tif(A[i] - A[i - 1] == A[i - 1] - A[i - 2])\\n        \\t{\\n        \\t\\tif(index[i - 1] == 0) index[i] = 3;\\n        \\t\\telse index[i] = index[i - 1] + 1;\\n        \\t}\\n        \\telse index[i] = 0;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < index.length; i++)\\n        {\\n        \\tif(index[i] != 0)\\n        \\t{\\n        \\t\\tsum += index[i] - 3 + 1;\\n        \\t}\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        if(A == null || A.length == 0) return 0;\\n        int[] index = new int[A.length];\\n        for(int i = 2; i < index.length; i++)\\n        {\\n        \\tif(A[i] - A[i - 1] == A[i - 1] - A[i - 2])\\n        \\t{\\n        \\t\\tif(index[i - 1] == 0) index[i] = 3;\\n        \\t\\telse index[i] = index[i - 1] + 1;\\n        \\t}\\n        \\telse index[i] = 0;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < index.length; i++)\\n        {\\n        \\tif(index[i] != 0)\\n        \\t{\\n        \\t\\tsum += index[i] - 3 + 1;\\n        \\t}\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90100,
                "title": "a-clear-python-solution-with-a-little-math",
                "content": "The key idea is to find blocks with the same difference, i.e., for [1,2,3,4,7,9,11,13,15], the [1,2,3,4] and [7,9,11,13,15] are two blocks with difference 1 and 2, respectively. \\n\\nOnce we know the lengths, which are 4 and 5, then the number of slices are just (n-1)(n-2)/2, which is, n-2 + n-3 + ... + n-(n-1) for each n. Then just create a list of maximum lengths of blocks and apply the above formula. Enjoy!\\n\\n    def numberOfArithmeticSlices(self, A):\\n        if len(A) < 3: return 0\\n        ns, n = [], 0\\n        for i in range(2, len(A)):\\n            if A[i] - A[i-1] == A[i-1] - A[i-2]:\\n                n += 1\\n            else:\\n                if n >= 1: ns.append(n+2)\\n                n = 0\\n        else:\\n            if n >= 1: ns.append(n+2)\\n        return int(sum(list(map(lambda x: (x-1)*(x-2)/2, ns))))",
                "solutionTags": [],
                "code": "The key idea is to find blocks with the same difference, i.e., for [1,2,3,4,7,9,11,13,15], the [1,2,3,4] and [7,9,11,13,15] are two blocks with difference 1 and 2, respectively. \\n\\nOnce we know the lengths, which are 4 and 5, then the number of slices are just (n-1)(n-2)/2, which is, n-2 + n-3 + ... + n-(n-1) for each n. Then just create a list of maximum lengths of blocks and apply the above formula. Enjoy!\\n\\n    def numberOfArithmeticSlices(self, A):\\n        if len(A) < 3: return 0\\n        ns, n = [], 0\\n        for i in range(2, len(A)):\\n            if A[i] - A[i-1] == A[i-1] - A[i-2]:\\n                n += 1\\n            else:\\n                if n >= 1: ns.append(n+2)\\n                n = 0\\n        else:\\n            if n >= 1: ns.append(n+2)\\n        return int(sum(list(map(lambda x: (x-1)*(x-2)/2, ns))))",
                "codeTag": "Python3"
            },
            {
                "id": 1815047,
                "title": "easy-solution-with-very-clear-explanation",
                "content": "**Please dont downvote guys if cannot support,We are putting lot of effort in it\\uD83D\\uDE42**\\n\\n\\n```\\nThe question is asking us to do return the number of arithmetic subarrays of nums.\\n\\nWhat is subarrays \\uD83E\\uDD14 ?\\n    A subarray is a contiguous subsequence of the array.\\nWe are using Dp concept to solve this\\n\\tBig 0:\\n\\t\\tTime:(n) # n--> length of array\\n\\t\\tSpace:(1)\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/d19956e9-b64d-428c-a9e6-dd7cc1b396a4_1646286530.812204.gif)\\n\\n![image](https://assets.leetcode.com/users/images/66c5c1ff-e2b8-499f-9121-20f30d907bdf_1646286541.913811.png)\\n\\n`JavaScript`\\n\\n```\\nconst numberOfArithmeticSlices = (nums) => {\\n  let count = 0;\\n  let arithmetic_subarrays_count = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    const difference_1 = nums[i] - nums[i + 1]; // ! getting difference between two consecutive numbers\\n    const difference_2 = nums[i + 1] - nums[i + 2]; // ! getting difference between next two consecutive number\\n    if (difference_1 === difference_2) {\\n      count++;\\n      arithmetic_subarrays_count += count;\\n    } else {\\n      count = 0;\\n    }\\n  }\\n\\n  return arithmetic_subarrays_count;\\n};\\n```\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nThe question is asking us to do return the number of arithmetic subarrays of nums.\\n\\nWhat is subarrays \\uD83E\\uDD14 ?\\n    A subarray is a contiguous subsequence of the array.\\nWe are using Dp concept to solve this\\n\\tBig 0:\\n\\t\\tTime:(n) # n--> length of array\\n\\t\\tSpace:(1)\\n```\n```\\nconst numberOfArithmeticSlices = (nums) => {\\n  let count = 0;\\n  let arithmetic_subarrays_count = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    const difference_1 = nums[i] - nums[i + 1]; // ! getting difference between two consecutive numbers\\n    const difference_2 = nums[i + 1] - nums[i + 2]; // ! getting difference between next two consecutive number\\n    if (difference_1 === difference_2) {\\n      count++;\\n      arithmetic_subarrays_count += count;\\n    } else {\\n      count = 0;\\n    }\\n  }\\n\\n  return arithmetic_subarrays_count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814935,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\n\\npublic:\\n\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\n    int count=0,ans=0;\\n\\n    for(int i=2;i<nums.size();i++)  \\n\\n    {\\n\\n        if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n\\n            count++;\\n\\n            ans+=count;}\\n\\n        else count=0;\\n\\n    }\\n\\n        return ans;\\n\\n        }\\n\\n};\\n        \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\n    int count=0,ans=0;\\n\\n    for(int i=2;i<nums.size();i++)  \\n\\n    {\\n\\n        if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n\\n            count++;\\n\\n            ans+=count;}",
                "codeTag": "Java"
            },
            {
                "id": 1814920,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int numberOfArithmeticSlices(int[] n) {\\n        int k=n.length;\\n        if(k<3)\\n            return 0;\\n        int s=0,p=0;\\n        for(int i=0;i<k-2;i++)\\n        {\\n            int a=n[i];\\n            int b=n[i+1];\\n            int c=n[i+2];\\n            if(a-b == b-c)\\n            {\\n                p++;\\n                s+=p;\\n            }\\n            else\\n            {\\n                p=0;\\n            }\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int numberOfArithmeticSlices(int[] n) {\\n        int k=n.length;\\n        if(k<3)\\n            return 0;\\n        int s=0,p=0;\\n        for(int i=0;i<k-2;i++)\\n        {\\n            int a=n[i];\\n            int b=n[i+1];\\n            int c=n[i+2];\\n            if(a-b == b-c)\\n            {\\n                p++;\\n                s+=p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1814712,
                "title": "solution-in-dynamic-programming-with-easy-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here array is arithmetic if it consists of\\xA0at least three elements ****and if the difference between any two consecutive elements is the same.\\n- We will be using the sliding window technique, comparing 3 elements at a time and then storing the answer in dp array.\\n- Start our loop from 3rd element and compare it with the previous 2 and if there is more than 3 elements with the same difference then we\\u2019ll also add that to our dp.\\n- Let\\u2019s take an example:\\n\\n```\\n\\tarray: [1,2,3,4]\\n\\tHere first 3 element:   [1,2,3] is arithmetic -> count=1\\n\\talso next 3 element:    [2,3,4] is arithmetic -> count=1\\n\\tnow all together:     [1,2,3,4] is arithmetic -> count=1\\n```\\n\\n- So while storing 2nd ans in dp, we\\'ll simply add the previous 1 to our current dp. \\n**`dp[i] = 1 + dp[i-1]`**\\n- Add the current dp count to our answer variable, **`count += dp[i];`**\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        vector<int> dp(n);\\n        \\n        for(int i=2; i<n; i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n                dp[i] = 1 + dp[i-1];\\n                count += dp[i];\\n            }\\n        }\\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tarray: [1,2,3,4]\\n\\tHere first 3 element:   [1,2,3] is arithmetic -> count=1\\n\\talso next 3 element:    [2,3,4] is arithmetic -> count=1\\n\\tnow all together:     [1,2,3,4] is arithmetic -> count=1\\n```\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        vector<int> dp(n);\\n        \\n        for(int i=2; i<n; i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n                dp[i] = 1 + dp[i-1];\\n                count += dp[i];\\n            }\\n        }\\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814435,
                "title": "javascript-easy-to-understand-2-solutions",
                "content": "## SOLUTION 1\\n\\nFor this solution, the core strategy is:\\n- try to find every full arithmetic sequence (not a sub arithmetic sequence inside another bigger arithmetic sequence)\\n- try to find a mathematical method to get all counts of arithmetic sequences from a full arithmetic sequence\\n- sum them up to get the result\\n\\nAbout the first part, it\\'s easy. We could traverse the `nums` and check the difference for the current number with the prev difference.\\n\\nAbout the second part, you could give some examples and think about the process. To spend some time, I guess you could figure it out. If the `n` is the length of a full arithmetic sequence - 1, then it\\'s actually the sum from 1 to `n`, which is `(1 + n) * n / 2`.\\n\\nFinally, we sum them up during the traversal.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst getTotalCounts = len => (1 + len) * len / 2;\\nconst numberOfArithmeticSlices = (nums) => {\\n  let ret = 0;\\n  let curLen = 0;\\n\\n  for (let i = 2, prev = nums[1] - nums[0]; i < nums.length; ++i) {\\n    const diff = nums[i] - nums[i - 1];\\n    if (diff === prev) { ++curLen; continue; }\\n    ret += getTotalCounts(curLen);\\n    prev = diff;\\n    curLen = 0;\\n  }\\n\\n  return ret + getTotalCounts(curLen);\\n};\\n```\\n\\n## SOLUTION 2\\n\\nFor this solution, actually it\\'s a DP solution. I found a javascript post [here](https://leetcode.com/problems/arithmetic-slices/discuss/1071502/JavaScript-Dynamic-Programming-(DP)-solution-that\\'s-easy-to-understand) with a detailed explanation. So I\\'m not gonna repeat it again here. Thanks to the author of that post.\\n\\nBTW, instead of an extra DP array, we could just maintain a variable for optimization.\\n\\nSince I haven\\'t explained too much here, if you have any questions, welcome to leave a comment, I\\'ll reply to it later.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst numberOfArithmeticSlices = (nums) => {\\n  let ret = 0;\\n  for (let i = 2, prev = nums[1] - nums[0], curCount = 0; i < nums.length; ++i) {\\n    const diff = nums[i] - nums[i - 1];\\n    diff === prev ? (ret += ++curCount) : (prev = diff, curCount = 0);\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst getTotalCounts = len => (1 + len) * len / 2;\\nconst numberOfArithmeticSlices = (nums) => {\\n  let ret = 0;\\n  let curLen = 0;\\n\\n  for (let i = 2, prev = nums[1] - nums[0]; i < nums.length; ++i) {\\n    const diff = nums[i] - nums[i - 1];\\n    if (diff === prev) { ++curLen; continue; }\\n    ret += getTotalCounts(curLen);\\n    prev = diff;\\n    curLen = 0;\\n  }\\n\\n  return ret + getTotalCounts(curLen);\\n};\\n```\n```js\\nconst numberOfArithmeticSlices = (nums) => {\\n  let ret = 0;\\n  for (let i = 2, prev = nums[1] - nums[0], curCount = 0; i < nums.length; ++i) {\\n    const diff = nums[i] - nums[i - 1];\\n    diff === prev ? (ret += ++curCount) : (prev = diff, curCount = 0);\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071042,
                "title": "c-super-simple-and-short-dp-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        vector<int> dp(A.size());\\n        int res = 0;\\n        for (int i = 2; i < A.size(); i++) {\\n            if (A[i] - A[i-1] == A[i-1] - A[i-2]) {\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        vector<int> dp(A.size());\\n        int res = 0;\\n        for (int i = 2; i < A.size(); i++) {\\n            if (A[i] - A[i-1] == A[i-1] - A[i-2]) {\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071037,
                "title": "python-o-n-with-explanation",
                "content": "1. scan for all the arith slices (as long as poosible);\\n2. let \\'x\\' be the number of arith slice for slice with length \\'n\\',  \\n\\t* \\t if n==3: **x = 1**\\n\\t* \\t if n==4: **x = 1+2**            *# 1 slice with length 4; 2 slices with length 3;*\\n\\t* \\t if n==5: **x = 1+2+3**      *# 1 slice with length 5; 2 slices with length 4; 3 slices with length 3*\\n\\t* \\t ...\\n\\t* \\t if n==m: **x = 1+2+...+(m-2) = (m-2)\\\\*(m-2+1)/2 = (m-2)\\\\*(m-1)/2**\\n```\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        if not A or len(A) < 3: return 0\\n        res = 0\\n        cnt, diff = 2, A[1] - A[0]\\n        for i in range(2, len(A)):\\n            if A[i] - A[i-1] == diff:\\n                cnt += 1\\n            else:\\n                if cnt > 2: res += ((cnt-1)*(cnt-2))//2\\n                cnt, diff = 2, A[i] - A[i-1]\\n        if cnt > 2: res += ((cnt-1)*(cnt-2))//2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        if not A or len(A) < 3: return 0\\n        res = 0\\n        cnt, diff = 2, A[1] - A[0]\\n        for i in range(2, len(A)):\\n            if A[i] - A[i-1] == diff:\\n                cnt += 1\\n            else:\\n                if cnt > 2: res += ((cnt-1)*(cnt-2))//2\\n                cnt, diff = 2, A[i] - A[i-1]\\n        if cnt > 2: res += ((cnt-1)*(cnt-2))//2\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1816907,
                "title": "dp-based-approach-recursion-memoization-c-clean-code",
                "content": "# Code : \\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int idx, int prev, int d, int n)\\n    {\\n        if(idx == n || nums[idx] - prev != d) return 0;\\n        \\n        return 1 + solve(nums, idx+1, nums[idx], d, n);\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        if(n < 3) return 0;\\n        \\n        int countSubarray = 0;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int d = nums[i+1] - nums[i];\\n            countSubarray += solve(nums, i+2, nums[i+1], d, n);\\n        }\\n        return countSubarray;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int idx, int prev, int d, int n)\\n    {\\n        if(idx == n || nums[idx] - prev != d) return 0;\\n        \\n        return 1 + solve(nums, idx+1, nums[idx], d, n);\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        if(n < 3) return 0;\\n        \\n        int countSubarray = 0;\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int d = nums[i+1] - nums[i];\\n            countSubarray += solve(nums, i+2, nums[i+1], d, n);\\n        }\\n        return countSubarray;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318165,
                "title": "0-ms-100-faster-simple-recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun (vector <int> &a, int n, int counter)\\n    {\\n        if (n < 3) return 0;\\n        if (a[n-1] + a[n-3] == 2 * a[n-2]) { counter ++; return counter + fun (a, n-1, counter);}\\n        else return fun (a, n-1, 0);\\n        \\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int c = 0;\\n        return fun (nums, nums.size(),c);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun (vector <int> &a, int n, int counter)\\n    {\\n        if (n < 3) return 0;\\n        if (a[n-1] + a[n-3] == 2 * a[n-2]) { counter ++; return counter + fun (a, n-1, counter);}\\n        else return fun (a, n-1, 0);\\n        \\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int c = 0;\\n        return fun (nums, nums.size(),c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90123,
                "title": "concise-and-simple-c-8-lines-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if(A.size() < 3) return 0;\\n        int count = 0, int ret = 0;\\n        for(int i = 1; i < A.size() - 1; i++)\\n        {\\n            if(A[i] - A[i-1] == A[i+1] - A[i]) ret += ++count;\\n            else count = 0;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if(A.size() < 3) return 0;\\n        int count = 0, int ret = 0;\\n        for(int i = 1; i < A.size() - 1; i++)\\n        {\\n            if(A[i] - A[i-1] == A[i+1] - A[i]) ret += ++count;\\n            else count = 0;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815446,
                "title": "from-recursion-to-the-most-optimized-solution-detailed-explanation",
                "content": "**Approach - 1: RECURSION + MEMOIZATION**\\nIf I\\'m at i\\'th index, I should check the differences between i with (i - 1) and (i - 1) with (i-2)\\'th element. If the differences are equal then we can say that this is an arithmatic subarray. \\nNow, if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) and upto (i - 1)\\'th index, there are \\'x\\' number of arithmatic subarrays present, then all those subarrays will also make valid subarrays with the current i\\'th element. So we have to add that number \\'x\\' with our present count which was 1.\\nWe have to thus calculate, for every index i, the number of arithmatic slices ending at index i, and add all of that which is going to be our answer.\\nOnce Recursion is done, Memoise the solution to reduce the time complexity from O(N ^ N) to O(N).\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int i, vector<int>& dp)  {\\n        if (i < 2) {\\n            return 0;\\n        }\\n        int &val = dp[i];\\n        if (val != -1) {\\n            return val;\\n        }\\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n            return val = solve(nums, i - 1, dp) + 1;\\n        }\\n        return val = 0;\\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        const int n = nums.size();\\n        int ans = 0;\\n        vector<int> dp(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            ans += solve(nums, i, dp);\\n        }\\n        return ans;\\n    }\\n};\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\n```\\n\\n**Approach - 2: Tabulation with Extra Space**\\nThis is the continuation part of the above solution. We make the same dp array of size n, where\\ndp[i] = no. of arithmatic subarrays ending at index i.\\nWe will fill the dp table using the recurrence relation used above only.\\nLastly, our answer will be summation of the whole dp array.\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        const int n = nums.size();\\n        if (n < 3) {\\n            return 0;\\n        }\\n        vector<int> dp(n);\\n        int ans = 0;\\n        for (int i = 2; i < n; i++) {\\n            if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) {\\n                dp[i] = dp[i - 1] + 1;\\n                ans += dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\n```\\n\\n**Approach - 3: Tabulation without Extra Space**\\nIn the tabulation solution, we can make an observation that every dp state value is dependent only on the previous state\\'s value.\\n```\\n dp[i] = dp[i - 1] + 1;\\n```\\nSo instead of saving the values in an array, we can just store the value in a variable \\'prev\\' and update this \\'prev\\' variable in each iteration accordingly. Thus we can reduce the extra space used in the previous solution.\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        const int n = nums.size();\\n        if (n < 3) {\\n            return 0;\\n        }\\n        int prev = 0, cur = 0;\\n        int ans = 0;\\n        for (int i = 2; i < n; i++) {\\n            if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) {\\n                cur = prev + 1;\\n                ans += cur;\\n                prev = cur;\\n            }\\n            else {\\n                prev = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int i, vector<int>& dp)  {\\n        if (i < 2) {\\n            return 0;\\n        }\\n        int &val = dp[i];\\n        if (val != -1) {\\n            return val;\\n        }\\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n            return val = solve(nums, i - 1, dp) + 1;\\n        }\\n        return val = 0;\\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        const int n = nums.size();\\n        int ans = 0;\\n        vector<int> dp(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            ans += solve(nums, i, dp);\\n        }\\n        return ans;\\n    }\\n};\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        const int n = nums.size();\\n        if (n < 3) {\\n            return 0;\\n        }\\n        vector<int> dp(n);\\n        int ans = 0;\\n        for (int i = 2; i < n; i++) {\\n            if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) {\\n                dp[i] = dp[i - 1] + 1;\\n                ans += dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\n```\n```\\n dp[i] = dp[i - 1] + 1;\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        const int n = nums.size();\\n        if (n < 3) {\\n            return 0;\\n        }\\n        int prev = 0, cur = 0;\\n        int ans = 0;\\n        for (int i = 2; i < n; i++) {\\n            if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) {\\n                cur = prev + 1;\\n                ans += cur;\\n                prev = cur;\\n            }\\n            else {\\n                prev = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815029,
                "title": "java-solution-using-recursion-beats-100",
                "content": "\\n```\\n\\tpublic int numberOfArithmeticSlices(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return 0;\\n        return rec(nums,n,0);\\n    }\\n    public int rec(int[] nums, int n, int counter){\\n        if(n<3) return 0;\\n        if(nums[n-1]-nums[n-2]==nums[n-2]-nums[n-3]){\\n            counter++;\\n            return counter+rec(nums, n-1, counter);\\n        }\\n        else return rec(nums, n-1, 0);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n```\\n\\tpublic int numberOfArithmeticSlices(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return 0;\\n        return rec(nums,n,0);\\n    }\\n    public int rec(int[] nums, int n, int counter){\\n        if(n<3) return 0;\\n        if(nums[n-1]-nums[n-2]==nums[n-2]-nums[n-3]){\\n            counter++;\\n            return counter+rec(nums, n-1, counter);\\n        }\\n        else return rec(nums, n-1, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1317077,
                "title": "4ms-without-dp-o-1-space-o-n-one-pass-only-explained",
                "content": "Read **comments** you will surely get the approach\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return 0;// minimum length of arithmetic must be 3\\n        int left=0;\\n        int right=1;\\n        int diff=-1;//difference of arithmetic [left,right]\\n        int ans=0;\\n        int len;//length of found arithmetic \\n        while(right<n){\\n\\t\\t    //on starting of loop right=left+1 always\\n\\t\\t\\t//store diff for which we want to find the arithmetic \\n            diff=nums[right]-nums[left];\\n\\t\\t\\t//increase right untill we found a element whose difference from previous element is not equal to \\'diff\\'\\n            while(right<n&&nums[right]-nums[right-1]==diff){\\n                right++;\\n            }\\n\\t\\t\\t//decrease right by 1 because last element is not valid -> nums[right]-nums[right-1]!=diff\\n            right--;\\n\\t\\t\\t//store length of found arithmetic\\n            len=right-left+1;\\n\\t\\t\\t//if len is not greater than equal to 3 do nthing\\n            if(len>=3){\\n\\t\\t\\t    //example : - let we found arithmetic 1,2,3,4,5,6\\n\\t\\t\\t\\t//so we can form a 3 length, 4 length,5 length,6 length arithmetic from found arithmetic (possible lengths 6-3+1 i.e 3,4,5,6)\\n\\t\\t\\t\\t//3 length arithmetic are : 1,2,3 | 2,3,4 | 3,4,5 | 4,5,6 \\n\\t\\t\\t\\t//number of 3 length arithmetic : 1 + (6-3) (1 is for 1,2,3(first 3 numbers) and we can slide thid window 3 times(6-3))\\n\\t\\t\\t\\t//number of 4 length arithmetic =1+(6-4)\\n\\t\\t\\t\\t//5 length =1+(6-5)\\n\\t\\t\\t\\t//6 length = 1+(6-6)\\n\\t\\t\\t\\t//total= 1+(6-3) + 1+(6-4) + 1+(6-5)+ 1+(6-6)\\n\\t\\t\\t\\t//total= 4 + (6-3) + (6-4) +(6-5)+(6-6)\\n\\t\\t\\t\\t//here 4 :  6-3+1\\n\\t\\t\\t\\t//6-3 + 6-4 +6-5 +6-6 =3+2+1+0=(3)*(3+1)/2  (use n*n+1/2)\\n\\t\\t\\t\\t//total= (6-3+1) + (6-3)*(6-3+1)/2;\\n\\t\\t\\t\\t//so therefore if we want to find all the arithmetic can be formed from a \\'m\\' length array : -\\n\\t\\t\\t\\t//total = (m-3+1) + (m-3)*(m-3+1)/2\\n                ans+=(len-3+1)+(len-3)*(len-3+1)/2;\\n            }\\n            left=right;\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return 0;// minimum length of arithmetic must be 3\\n        int left=0;\\n        int right=1;\\n        int diff=-1;//difference of arithmetic [left,right]\\n        int ans=0;\\n        int len;//length of found arithmetic \\n        while(right<n){\\n\\t\\t    //on starting of loop right=left+1 always\\n\\t\\t\\t//store diff for which we want to find the arithmetic \\n            diff=nums[right]-nums[left];\\n\\t\\t\\t//increase right untill we found a element whose difference from previous element is not equal to \\'diff\\'\\n            while(right<n&&nums[right]-nums[right-1]==diff){\\n                right++;\\n            }\\n\\t\\t\\t//decrease right by 1 because last element is not valid -> nums[right]-nums[right-1]!=diff\\n            right--;\\n\\t\\t\\t//store length of found arithmetic\\n            len=right-left+1;\\n\\t\\t\\t//if len is not greater than equal to 3 do nthing\\n            if(len>=3){\\n\\t\\t\\t    //example : - let we found arithmetic 1,2,3,4,5,6\\n\\t\\t\\t\\t//so we can form a 3 length, 4 length,5 length,6 length arithmetic from found arithmetic (possible lengths 6-3+1 i.e 3,4,5,6)\\n\\t\\t\\t\\t//3 length arithmetic are : 1,2,3 | 2,3,4 | 3,4,5 | 4,5,6 \\n\\t\\t\\t\\t//number of 3 length arithmetic : 1 + (6-3) (1 is for 1,2,3(first 3 numbers) and we can slide thid window 3 times(6-3))\\n\\t\\t\\t\\t//number of 4 length arithmetic =1+(6-4)\\n\\t\\t\\t\\t//5 length =1+(6-5)\\n\\t\\t\\t\\t//6 length = 1+(6-6)\\n\\t\\t\\t\\t//total= 1+(6-3) + 1+(6-4) + 1+(6-5)+ 1+(6-6)\\n\\t\\t\\t\\t//total= 4 + (6-3) + (6-4) +(6-5)+(6-6)\\n\\t\\t\\t\\t//here 4 :  6-3+1\\n\\t\\t\\t\\t//6-3 + 6-4 +6-5 +6-6 =3+2+1+0=(3)*(3+1)/2  (use n*n+1/2)\\n\\t\\t\\t\\t//total= (6-3+1) + (6-3)*(6-3+1)/2;\\n\\t\\t\\t\\t//so therefore if we want to find all the arithmetic can be formed from a \\'m\\' length array : -\\n\\t\\t\\t\\t//total = (m-3+1) + (m-3)*(m-3+1)/2\\n                ans+=(len-3+1)+(len-3)*(len-3+1)/2;\\n            }\\n            left=right;\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071140,
                "title": "python-sliding-window",
                "content": "# Idea\\nArithmetic sequences icrease or decrease by the same amount. We can pre-compute the differences between consecutive elements. Then, our problem can be reformulated as finding the number of sequenses of equal values which have a length of at least 2. We can accomplish this by using a sliding window approach.\\n#### Complexity\\n**Time:** O(N)\\n**Memory:** O(N) because of pre-computation, we can get down to O(1), if we do in-place comparisons.\\n#### The code:\\n```\\ndef numberOfArithmeticSlices(self, A: List[int]) -> int:\\n\\tdiffs = [b-a for a, b in zip(A, A[1:])]\\n\\tl = r = cnt = 0  # left, right pointers and counter\\n\\twhile r < len(diffs):\\n\\t\\tif diffs[r] == diffs[l]: \\n\\t\\t\\tcnt += r - l\\n\\t\\telse: \\n\\t\\t\\tl = r\\n\\t\\tr += 1\\n\\treturn cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\ndef numberOfArithmeticSlices(self, A: List[int]) -> int:\\n\\tdiffs = [b-a for a, b in zip(A, A[1:])]\\n\\tl = r = cnt = 0  # left, right pointers and counter\\n\\twhile r < len(diffs):\\n\\t\\tif diffs[r] == diffs[l]: \\n\\t\\t\\tcnt += r - l\\n\\t\\telse: \\n\\t\\t\\tl = r\\n\\t\\tr += 1\\n\\treturn cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 804474,
                "title": "3-approaches-c-easy",
                "content": "\\n     //1.dp\\n\\t \\n     int numberOfArithmeticSlices(vector<int>& A) {\\n             vector<int> dp(A.size(),0);\\n             int res=0;\\n             for(int i=2;i<A.size();i++){\\n                 if(A[i]-A[i-1]==A[i-1]-A[i-2]){\\n                     dp[i]=dp[i-1]+1;\\n                     res+=dp[i];\\n                 }\\n             }\\n             return res;\\n         }\\n\\t\\t \\n\\t\\t //2.dp with constant space\\n\\t\\t \\n\\t\\t int numberOfArithmeticSlices(vector<int>& A) {\\n          int dp=0,res=0;\\n          for(int i=2;i<A.size();i++){\\n              if(A[i]-A[i-1]==A[i-1]-A[i-2]){\\n                  dp=dp+1;\\n                  res+=dp;\\n              }\\n              else \\n                  dp=0;\\n          }\\n          return res;\\n       }\\n\\t   \\n\\t   //3.mathematical approach\\n\\t   \\n\\t   int numberOfArithmeticSlices(vector<int>& A) {\\n        int n=A.size();\\n        if(n<2) return 0;\\n        vector<int> v(n-1); \\n        for(int i=1;i<n;i++)\\n            v[i-1]=A[i]-A[i-1];\\n        \\n        int s=1,res=0;\\n        for(int i=0;i<n-2;i++)\\n        { \\n            if(v[i]==v[i+1]) {\\n\\t\\t\\ts++;\\n\\t\\t\\tcontinue;\\n\\t\\t\\t}else{   \\n                s+=1;\\n                int k=s-3+1;   \\n                if(k>0)\\n                res+=(k*(k+1))/2;   //total number of sets can be made using s same diff of size greater than 3  \\n             s=1;\\n            }   \\n        } \\n                s+=1;            //at last if s is non zero\\n                int k=s-3+1;\\n                if(k>0)\\n                res+=(k*(k+1))/2;\\n        return res;\\n    }\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "\\n     //1.dp\\n\\t \\n     int numberOfArithmeticSlices(vector<int>& A) {\\n             vector<int> dp(A.size(),0);\\n             int res=0;\\n             for(int i=2;i<A.size();i++){\\n                 if(A[i]-A[i-1]==A[i-1]-A[i-2]){\\n                     dp[i]=dp[i-1]+1;\\n                     res+=dp[i];\\n                 }\\n             }\\n             return res;\\n         }\\n\\t\\t \\n\\t\\t //2.dp with constant space\\n\\t\\t \\n\\t\\t int numberOfArithmeticSlices(vector<int>& A) {\\n          int dp=0,res=0;\\n          for(int i=2;i<A.size();i++){\\n              if(A[i]-A[i-1]==A[i-1]-A[i-2]){\\n                  dp=dp+1;\\n                  res+=dp;\\n              }\\n              else \\n                  dp=0;\\n          }\\n          return res;\\n       }\\n\\t   \\n\\t   //3.mathematical approach\\n\\t   \\n\\t   int numberOfArithmeticSlices(vector<int>& A) {\\n        int n=A.size();\\n        if(n<2) return 0;\\n        vector<int> v(n-1); \\n        for(int i=1;i<n;i++)\\n            v[i-1]=A[i]-A[i-1];\\n        \\n        int s=1,res=0;\\n        for(int i=0;i<n-2;i++)\\n        { \\n            if(v[i]==v[i+1]) {\\n\\t\\t\\ts++;\\n\\t\\t\\tcontinue;\\n\\t\\t\\t}else{   \\n                s+=1;\\n                int k=s-3+1;   \\n                if(k>0)\\n                res+=(k*(k+1))/2;   //total number of sets can be made using s same diff of size greater than 3  \\n             s=1;\\n            }   \\n        } \\n                s+=1;            //at last if s is non zero\\n                int k=s-3+1;\\n                if(k>0)\\n                res+=(k*(k+1))/2;\\n        return res;\\n    }\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 90159,
                "title": "3ms-question-maker-solution-in-cpp-o-n-time-and-in-space",
                "content": "I met this question in friend's friend's OA (recursive friend) lol\\n\\nIt could be solved in O(n) with small math trick~~ O(n) time and in space. Thanks @JianShi for this solution!\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if (A.size() < 3) return 0;\\n        int size = (int) A.size();\\n        for (int i = 0; i < size - 1; i++) {\\n            A[i] = A[i + 1] - A[i];\\n        }\\n        A.resize(size - 1);\\n        size--;\\n        \\n        int res = 0;\\n        int len = 1;\\n        for (int i = 1; i < size; i++) {\\n            if (A[i] != A[i - 1]) {\\n                res += len * (len - 1) / 2;\\n                len = 1;\\n            } else {\\n                len++;\\n            }\\n        }\\n        if (len > 1) res += len * (len - 1) / 2;\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if (A.size() < 3) return 0;\\n        int size = (int) A.size();\\n        for (int i = 0; i < size - 1; i++) {\\n            A[i] = A[i + 1] - A[i];\\n        }\\n        A.resize(size - 1);\\n        size--;\\n        \\n        int res = 0;\\n        int len = 1;\\n        for (int i = 1; i < size; i++) {\\n            if (A[i] != A[i - 1]) {\\n                res += len * (len - 1) / 2;\\n                len = 1;\\n            } else {\\n                len++;\\n            }\\n        }\\n        if (len > 1) res += len * (len - 1) / 2;\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817071,
                "title": "c-basic-approach-brute-force-arithmetic-slices",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if( nums.size()<3)\\n            return 0;\\n        \\n        int c=0;\\n        int total=0;\\n        for(int i=2;i<nums.size();i++){         //Starting when array Size >= 3\\n            \\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])      //Compairing the  difference like you do in AP\\n            {\\n                c++;   //sum of that particular no. of subarray is stored in \\'c\\' that was checked in if condition\\n                total=total+c;  //total number of subarray stored\\n            }\\n            \\n            else\\n            {\\n                c=0;\\n                \\n            }\\n\\n            }\\n        return total;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if( nums.size()<3)\\n            return 0;\\n        \\n        int c=0;\\n        int total=0;\\n        for(int i=2;i<nums.size();i++){         //Starting when array Size >= 3\\n            \\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])      //Compairing the  difference like you do in AP\\n            {\\n                c++;   //sum of that particular no. of subarray is stored in \\'c\\' that was checked in if condition\\n                total=total+c;  //total number of subarray stored\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551627,
                "title": "easy-solution-java-100-dynamic-programming",
                "content": "```\\npublic int numberOfArithmeticSlices(int[] arr) {\\n        int[] dp = new int[arr.length];\\n        int ans = 0;\\n        \\n        for(int i = 2; i < arr.length; i++){\\n            \\n            if(arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]){\\n                dp[i] = dp[i - 1] + 1;\\n                ans += dp[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int numberOfArithmeticSlices(int[] arr) {\\n        int[] dp = new int[arr.length];\\n        int ans = 0;\\n        \\n        for(int i = 2; i < arr.length; i++){\\n            \\n            if(arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]){\\n                dp[i] = dp[i - 1] + 1;\\n                ans += dp[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519262,
                "title": "c-faster-than-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans = 0;\\n        vector<int> val(nums.size(), 0);\\n        if(nums.size() < 3) {\\n            return 0;\\n        }\\n        \\n        for(int i = 2; i < nums.size(); i++) {\\n            if((nums[i] - nums[i-1]) == (nums[i-1] - nums[i-2])) {\\n                val[i] = val[i-1] + 1;\\n                ans += val[i];\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans = 0;\\n        vector<int> val(nums.size(), 0);\\n        if(nums.size() < 3) {\\n            return 0;\\n        }\\n        \\n        for(int i = 2; i < nums.size(); i++) {\\n            if((nums[i] - nums[i-1]) == (nums[i-1] - nums[i-2])) {\\n                val[i] = val[i-1] + 1;\\n                ans += val[i];\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122292,
                "title": "c-dp-approaoch-recursion",
                "content": "DP:\\n```\\nclass Solution {\\n   \\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum=0; //to store the final result\\n    vector<int> dp(n,0);// dp array will store the number of possible such subarray if\\n                   // array was of length i\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]) //check the constrain for index i\\n                dp[i] = 1+dp[i-1]; // add 1 to number of possible such subarray\\n            sum+=dp[i]; // go on adding to the sum the number of all sauch subarray for index upto i\\n        }\\n        return sum;  // return the answer\\n    }\\n};\\n```\\n\\nRecursion:\\n```\\nclass Solution {\\n    int sum=0;\\npublic:\\n    int slices(vector<int>& nums, int index){\\n        if(index<2)return 0; //if length of nums becomes less than 3 no such subarray is\\n                        //possible because we require subarray of size 3 or more\\n    int x = 0; //store the numbers of subarrays  from this index \\n    \\n//check the conditions if true add 1 to answer and recur for remainning part\\n        if(nums[index]- nums[index-1]==nums[index-1]-nums[index-2]){\\n        x =  1+slices(nums, index-1);\\n                sum+=x; //also add the number to final ans\\n        }\\n        else  //if conditions are not met then recur for remainning length\\n            slices(nums, index-1);\\n        \\n        return x; //here we are returning x to get the number of such subarray of after recurring\\n    }\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        slices(nums, n-1);\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum=0; //to store the final result\\n    vector<int> dp(n,0);// dp array will store the number of possible such subarray if\\n                   // array was of length i\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]) //check the constrain for index i\\n                dp[i] = 1+dp[i-1]; // add 1 to number of possible such subarray\\n            sum+=dp[i]; // go on adding to the sum the number of all sauch subarray for index upto i\\n        }\\n        return sum;  // return the answer\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int sum=0;\\npublic:\\n    int slices(vector<int>& nums, int index){\\n        if(index<2)return 0; //if length of nums becomes less than 3 no such subarray is\\n                        //possible because we require subarray of size 3 or more\\n    int x = 0; //store the numbers of subarrays  from this index \\n    \\n//check the conditions if true add 1 to answer and recur for remainning part\\n        if(nums[index]- nums[index-1]==nums[index-1]-nums[index-2]){\\n        x =  1+slices(nums, index-1);\\n                sum+=x; //also add the number to final ans\\n        }\\n        else  //if conditions are not met then recur for remainning length\\n            slices(nums, index-1);\\n        \\n        return x; //here we are returning x to get the number of such subarray of after recurring\\n    }\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        slices(nums, n-1);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071191,
                "title": "c-0-ms-faster-than-100-00-o-n-super-simple-easy-understanding-solution",
                "content": "```\\nint numberOfArithmeticSlices(int* A, int ASize){\\n    if ( ASize < 3 ) return 0;\\n        int res = 0, counter = 2, lastDif = A[1] - A[0], index = 2;\\n        \\n        for(; index < ASize; ++index)\\n        {\\n            if ( lastDif == A[index] - A[index - 1] )\\n                ++counter;\\n            else\\n            {\\n                if ( counter >= 3 )\\n                    res += (counter - 1) * (counter - 2) / 2;\\n                counter = 2;\\n                lastDif = A[index] - A[index - 1];\\n            }\\n        }\\n        if ( counter >= 3 )\\n            res += (counter - 1) * (counter - 2) / 2;\\n        return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfArithmeticSlices(int* A, int ASize){\\n    if ( ASize < 3 ) return 0;\\n        int res = 0, counter = 2, lastDif = A[1] - A[0], index = 2;\\n        \\n        for(; index < ASize; ++index)\\n        {\\n            if ( lastDif == A[index] - A[index - 1] )\\n                ++counter;\\n            else\\n            {\\n                if ( counter >= 3 )\\n                    res += (counter - 1) * (counter - 2) / 2;\\n                counter = 2;\\n                lastDif = A[index] - A[index - 1];\\n            }\\n        }\\n        if ( counter >= 3 )\\n            res += (counter - 1) * (counter - 2) / 2;\\n        return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1816934,
                "title": "easiest-approach-have-a-look",
                "content": "```\\n// PLEASE DO UPVOTE , IF YOU LIKE MY SOLUTION\\nint func(vector<int> &nums,int diff,int idx){\\n        if(idx >= nums.size()) return 0;\\n        if(nums[idx]-nums[idx-1] == diff){\\n            return 1 + func(nums,diff,idx+1);\\n        }else return 0; \\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums){\\n        if(nums.size() == 1 || nums.size() == 2) return 0;\\n        int ans = 0;\\n        for(int i=0;i<=nums.size()-3;i++){\\n            int diff = nums[i+1] - nums[i];\\n            if(nums[i+2]-nums[i+1] == diff && nums[i+1]-nums[i] == diff){\\n                ans += 1 + func(nums,diff,i+3);\\n            }\\n        }\\n        return ans;\\n    }\\n// PLEASE DO UPVOTE , IF YOU LIKE MY SOLUTION\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n// PLEASE DO UPVOTE , IF YOU LIKE MY SOLUTION\\nint func(vector<int> &nums,int diff,int idx){\\n        if(idx >= nums.size()) return 0;\\n        if(nums[idx]-nums[idx-1] == diff){\\n            return 1 + func(nums,diff,idx+1);\\n        }else return 0; \\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums){\\n        if(nums.size() == 1 || nums.size() == 2) return 0;\\n        int ans = 0;\\n        for(int i=0;i<=nums.size()-3;i++){\\n            int diff = nums[i+1] - nums[i];\\n            if(nums[i+2]-nums[i+1] == diff && nums[i+1]-nums[i] == diff){\\n                ans += 1 + func(nums,diff,i+3);\\n            }\\n        }\\n        return ans;\\n    }\\n// PLEASE DO UPVOTE , IF YOU LIKE MY SOLUTION\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815214,
                "title": "java-0ms-100-faster-self-explanatory-beginner-friendly-code",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length;\\n        \\n        if(n < 3) return 0;\\n        \\n        int ans = 0;\\n        \\n       for(int i=0;i<n-2;i++){\\n            int d = nums[i+1] - nums[i]; // finding difference\\n         \\n            for(int j=i+2;j<n;j++){\\n                \\n                if(nums[j] - nums[j-1] == d) ans++; //if d is the difference\\n                else  break;\\n                   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Time Complexity - O(n^2)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length;\\n        \\n        if(n < 3) return 0;\\n        \\n        int ans = 0;\\n        \\n       for(int i=0;i<n-2;i++){\\n            int d = nums[i+1] - nums[i]; // finding difference\\n         \\n            for(int j=i+2;j<n;j++){\\n                \\n                if(nums[j] - nums[j-1] == d) ans++; //if d is the difference\\n                else  break;\\n                   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Time Complexity - O(n^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815070,
                "title": "0ms-6-line-code-explanation-o-n-time-and-o-1-space-c",
                "content": "```\\n//Upvote if helpful\\n//Feel free to comment doubts or suggestions\\n```\\n**Intuition**:\\nThe best way to understand this is to understand sub-slice pattern\\nImagine we have a slice [1,2,3,4,5,6] we will need to traverse from 2 to 6 checking difference\\n->\\n**[1-2]: 0**   (0+0) |  invalid (n<3)\\n**[1-3]: 1**   (0+1) | [1,2,3]\\n**[1-4]: 3**   (1+2) | [1,2,3] [2,3,4] [1,2,3,4]\\n**[1-5]: 6**   (3+3) | [1,2,3] [2,3,4] [1,2,3,4] [3,4,5] [2,3,4,5] [1,2,3,4,5]\\n**[1-5]:10**(6+4) | [1,2,3] [2,3,4] [1,2,3,4] [3,4,5] [2,3,4,5] [1,2,3,4,5] [4,5,6] [3,4,5,6] [2,3,4,5,6] [1,2,3,4,5,6]\\n\\n![image](https://assets.leetcode.com/users/images/b893face-b872-4212-af23-059819af7b0c_1646287261.771687.png)\\n\\n\\n**Algorithm:**\\n1. No valid slices are possible if n<3 => return 0\\n2. Calculate first difference =>nums[1] -nums[0] and set subslice counter to zero\\n3. Iterate from i=2 to i=n-1\\n\\t1. If current diff==previous diff, subslice++\\n\\t2. Else, reset subslice =0 & set previous diff=current diff\\n\\t3. ans+=subsplice\\n4. Return answer\\n\\n**Time Complexity: O(n)** as we are traversing only once\\n**Space complexity: O(1)** as additional space required is only for variables \\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) \\n    {\\n        if(nums.size()<3) return 0;\\n        int diff=nums[1]-nums[0], sub_slices=0, ans=0; \\n        for(int i=2; i<nums.size(); i++)\\n        {\\n            diff==nums[i]-nums[i-1]? sub_slices++: sub_slices=0, diff=nums[i]-nums[i-1];\\n            ans+=sub_slices;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Upvote if helpful\\n//Feel free to comment doubts or suggestions\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) \\n    {\\n        if(nums.size()<3) return 0;\\n        int diff=nums[1]-nums[0], sub_slices=0, ans=0; \\n        for(int i=2; i<nums.size(); i++)\\n        {\\n            diff==nums[i]-nums[i-1]? sub_slices++: sub_slices=0, diff=nums[i]-nums[i-1];\\n            ans+=sub_slices;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799935,
                "title": "simple-math-solution-greedy",
                "content": "This is the first solution came in my mind.\\n# My Approach\\nIn this question An integer array is called arithmetic if it consists of at least three elements.\\nSo this line hits me that Can I use  **(i-1, i, i+1) .**\\n Example-     \\n               ![image](https://assets.leetcode.com/users/images/08964015-bf84-4fa9-ae63-2097d132b0bd_1645845112.2285032.png)\\n\\n```\\nint numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        int d=0,e=0,c=0,sum=0,f=0;\\n        for(int i=1;i<n-1;i++){\\n             d=nums[i]-nums[i-1];\\n             e=nums[i+1]-nums[i];\\n            if(d==e){\\n                c++;\\n            }\\n            else{\\n                sum+=(c*(c+1))/2;\\n                // cout<<sum<<endl;\\n                f=1;\\n                c=0;\\n            }\\n           \\n        }\\n        if(f==0 || c!=0){\\n            sum+=(c*(c+1))/2;\\n        }\\n        return sum;\\n    }\\n```\\n**Please upvote if you liked my approach...**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nint numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        int d=0,e=0,c=0,sum=0,f=0;\\n        for(int i=1;i<n-1;i++){\\n             d=nums[i]-nums[i-1];\\n             e=nums[i+1]-nums[i];\\n            if(d==e){\\n                c++;\\n            }\\n            else{\\n                sum+=(c*(c+1))/2;\\n                // cout<<sum<<endl;\\n                f=1;\\n                c=0;\\n            }\\n           \\n        }\\n        if(f==0 || c!=0){\\n            sum+=(c*(c+1))/2;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1528646,
                "title": "java-simple-code-0ms-100-explained",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n\\t\\n\\t    // straight away retuen if length is less than 3\\n        if(nums.length<3) return 0;\\n        int count=0;\\n        for(int i=0 ; i<nums.length-2 ; i++)\\n        {\\n\\t\\t    // if difference in common between i+1,i and i+2,i+1 , it means that it is part \\n\\t\\t\\t// of arithmetic progression so enter the if condition\\n            if(i+2<nums.length && nums[i+1]-nums[i] == nums[i+2]-nums[i+1])\\n            {\\n                int d=nums[i+1] - nums[i];\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// increment count till difference is common for i+1,i and i+2,i+1\\n                for(int j=i+2;j<nums.length-1 && nums[j+1]-nums[j]==d;j++) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n\\t\\n\\t    // straight away retuen if length is less than 3\\n        if(nums.length<3) return 0;\\n        int count=0;\\n        for(int i=0 ; i<nums.length-2 ; i++)\\n        {\\n\\t\\t    // if difference in common between i+1,i and i+2,i+1 , it means that it is part \\n\\t\\t\\t// of arithmetic progression so enter the if condition\\n            if(i+2<nums.length && nums[i+1]-nums[i] == nums[i+2]-nums[i+1])\\n            {\\n                int d=nums[i+1] - nums[i];\\n                count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// increment count till difference is common for i+1,i and i+2,i+1\\n                for(int j=i+2;j<nums.length-1 && nums[j+1]-nums[j]==d;j++) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071112,
                "title": "c-o-n-time-complexity-o-1-space-complexity-no-recursion-no-dp",
                "content": "**Some variables used in program**\\n**`d`** = common difference of AP\\n**`len`** = length of largest current AP sequence\\n**`( (len-2)*(len-1) )/2`** = total no of AP subsequence using this sequence\\n\\nLet\\'s say len = 5, \\nthen 1 sequence of length = 5\\n2 sequence of length = 4\\n3 sequence of length = 3\\n\\nSo total number of subsequence of using len = 1 + 2 + 3 \\nOr in general way = 1 + 2 + 3 + 4 + ......... + (len-2) =**`( (len-2)*(len-1) )/2`**   **// Sum of first n natural numbers**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& a) {\\n        if(a.size()<3)\\n            return 0;\\n        \\n        int ans =0, s = 0, len, d = a[1] - a[0];\\n        for(int i=1;i<a.size(); i++)\\n        {\\n            if(a[i] != a[i-1] + d)\\n            {\\n                len = i-s;\\n                if(len > 2)\\n                    ans += ( (len-2)*(len-1) )/2;\\n                d = a[i] - a[i-1];\\n                s = i-1;\\n            }\\n        }\\n        \\n        len = a.size() - s;\\n        if(len > 2)\\n            ans += ( (len-2)*(len-1) )/2;\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& a) {\\n        if(a.size()<3)\\n            return 0;\\n        \\n        int ans =0, s = 0, len, d = a[1] - a[0];\\n        for(int i=1;i<a.size(); i++)\\n        {\\n            if(a[i] != a[i-1] + d)\\n            {\\n                len = i-s;\\n                if(len > 2)\\n                    ans += ( (len-2)*(len-1) )/2;\\n                d = a[i] - a[i-1];\\n                s = i-1;\\n            }\\n        }\\n        \\n        len = a.size() - s;\\n        if(len > 2)\\n            ans += ( (len-2)*(len-1) )/2;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186378,
                "title": "clean-python-dp-solution",
                "content": "It's really smiliar to Fibonacci sequence!\nUse a list to record currenrt number of slices,\nwe keep adding and appending when the differences are the same,\nif the pattern break we reset the addend to 1 and skip the addition.\n\n```\n    def numberOfArithmeticSlices(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        \n        res = [0]\n        f = 1\n        for i in range(2,len(A)):\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\n                res.append(res[-1]+f)\n                f += 1\n            else:\n                f=1\n        \n        return res[-1]\n```",
                "solutionTags": [],
                "code": "```\n    def numberOfArithmeticSlices(self, A):\n        \"\"\"\n        :type A: List[int]\n        :rtype: int\n        \"\"\"\n        \n        res = [0]\n        f = 1\n        for i in range(2,len(A)):\n            if A[i]-A[i-1] == A[i-1]-A[i-2]:\n                res.append(res[-1]+f)\n                f += 1\n            else:\n                f=1\n        \n        return res[-1]\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3326114,
                "title": "beats-100-dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int numberOfArithmeticSlices(List<int> nums) {\\n      int sum = 0;\\n      int slice = 0;\\n      for(int i = 2;i<nums.length;i+=1){\\n          if(nums[i-2]-nums[i-1]==nums[i-1]-nums[i]){\\n              sum+=1;\\n              slice+=sum;    \\n          }\\n          else sum = 0;\\n      }\\n      return slice;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numberOfArithmeticSlices(List<int> nums) {\\n      int sum = 0;\\n      int slice = 0;\\n      for(int i = 2;i<nums.length;i+=1){\\n          if(nums[i-2]-nums[i-1]==nums[i-1]-nums[i]){\\n              sum+=1;\\n              slice+=sum;    \\n          }\\n          else sum = 0;\\n      }\\n      return slice;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209011,
                "title": "c-time-o-n-or-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)return 0;\\n        int x = 0, ans = 0;\\n        for(int i = 1; i < nums.size()-1; i++){\\n            if(nums[i]-nums[i-1]==nums[i+1]-nums[i]){\\n                x++;\\n                ans += x;\\n            }else{\\n                x = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)return 0;\\n        int x = 0, ans = 0;\\n        for(int i = 1; i < nums.size()-1; i++){\\n            if(nums[i]-nums[i-1]==nums[i+1]-nums[i]){\\n                x++;\\n                ans += x;\\n            }else{\\n                x = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207174,
                "title": "c-solution-beats-100-o-n-time-complexity-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer approach\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3) return 0;\\n        int i=0, j=1, diff=nums[j]-nums[i];\\n        j++;\\n        int ans=0;\\n        while(j<n)\\n        {\\n            if(nums[j]-nums[j-1]==diff)\\n            {\\n                if(j-i+1>=3) ans+=j-i+1-3+1;\\n                j++;\\n            }\\n            else\\n            {\\n                diff=nums[j]-nums[j-1];\\n                i=j-1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3) return 0;\\n        int i=0, j=1, diff=nums[j]-nums[i];\\n        j++;\\n        int ans=0;\\n        while(j<n)\\n        {\\n            if(nums[j]-nums[j-1]==diff)\\n            {\\n                if(j-i+1>=3) ans+=j-i+1-3+1;\\n                j++;\\n            }\\n            else\\n            {\\n                diff=nums[j]-nums[j-1];\\n                i=j-1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037074,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeats 100%\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach is simple \\n. find the subarray of length 3 , which has common consecutive difference.\\n. for that subarray check that if further elements can add up and consists the similar difference.\\n. keep on checking the same for further elements \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] arr) {\\n        int num =0;\\n        for(int i =0;i<arr.length-2;i++){\\n            int diff1 = arr[i+1]-arr[i];\\n            int diff2 = arr[i+2]-arr[i+1];\\n            if(diff1==diff2){\\n                num = num+1;\\n                for(int j = i+2;j<arr.length-1;j++){\\n                    if(arr[j+1]-arr[j]==diff1)\\n                    num++;\\n\\n                    else\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return num;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfArithmeticSlices(int[] arr) {\\n        int num =0;\\n        for(int i =0;i<arr.length-2;i++){\\n            int diff1 = arr[i+1]-arr[i];\\n            int diff2 = arr[i+2]-arr[i+1];\\n            if(diff1==diff2){\\n                num = num+1;\\n                for(int j = i+2;j<arr.length-1;j++){\\n                    if(arr[j+1]-arr[j]==diff1)\\n                    num++;\\n\\n                    else\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2853151,
                "title": "c-recursion-memoisation-tabulation-clean-code",
                "content": "```\\n// RECURSION - 0ms\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int i, int diff)\\n    {\\n        if(i == nums.size() - 1 || nums[i] + diff != nums[i + 1])\\n            return 0;\\n        \\n        return 1 + solve(nums, i + 1, diff);   \\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < nums.size() - 2; i++)\\n        {\\n            int diff = nums[i + 1] - nums[i];\\n            ans += solve(nums, i + 1, diff);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n// DP + Memoisation \\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        vector<int> dp(nums.size(), 0);\\n        int ans = 0;\\n        for(int i = 2 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])\\n            {\\n                dp[i] = 1 + dp[i - 1];\\n                ans += dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n// DP + Tabulation\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        int ans = 0;\\n        int curr= 0;\\n        for(int i = 2 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])\\n            {\\n                curr++;\\n                ans += curr;\\n            }\\n            else\\n                curr = 0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// RECURSION - 0ms\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int i, int diff)\\n    {\\n        if(i == nums.size() - 1 || nums[i] + diff != nums[i + 1])\\n            return 0;\\n        \\n        return 1 + solve(nums, i + 1, diff);   \\n    }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < nums.size() - 2; i++)\\n        {\\n            int diff = nums[i + 1] - nums[i];\\n            ans += solve(nums, i + 1, diff);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// DP + Memoisation \\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)\\n            return 0;\\n        vector<int> dp(nums.size(), 0);\\n        int ans = 0;\\n        for(int i = 2 ; i < nums.size(); i++)\\n        {\\n            if(nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2])\\n            {\\n                dp[i] = 1 + dp[i - 1];\\n                ans += dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828792,
                "title": "c-easy-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Suppose, we have an arithmetic subarray (say X) of length k\\n- Then, number of subarrays in X having length 3 = k-2\\n            number of subarrays in X having length 4 = k-3\\n            ...\\n            number of subarrays in X having length k = k - (k-1)\\n            number of subarrays in X having length 0 = k - (k)  `// adding just to ease our calculation`\\n\\n- Total number of subarrays in X:\\n![image.png](https://assets.leetcode.com/users/images/c0996972-7e78-40ef-9f3e-fa3d5bd2e861_1668822782.2685335.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calcTotal(int k) {\\n        return ((k-1)*(k-2))/2;\\n    }\\n\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        if(n<3) return 0;\\n\\n        int cnt = 0, diff = INT_MIN;\\n        int ans = 0;\\n        for(int i=1; i<n; ++i) {\\n            if(nums[i]-nums[i-1] == diff) {\\n                ++cnt;\\n            } else {\\n                if(cnt>2) ans += calcTotal(cnt);\\n                cnt = 2;    // any two numbers in sequence would always be in arithmetic\\n                diff = nums[i]-nums[i-1];\\n            }\\n        }\\n\\n        ans += calcTotal(cnt);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calcTotal(int k) {\\n        return ((k-1)*(k-2))/2;\\n    }\\n\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        if(n<3) return 0;\\n\\n        int cnt = 0, diff = INT_MIN;\\n        int ans = 0;\\n        for(int i=1; i<n; ++i) {\\n            if(nums[i]-nums[i-1] == diff) {\\n                ++cnt;\\n            } else {\\n                if(cnt>2) ans += calcTotal(cnt);\\n                cnt = 2;    // any two numbers in sequence would always be in arithmetic\\n                diff = nums[i]-nums[i-1];\\n            }\\n        }\\n\\n        ans += calcTotal(cnt);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601822,
                "title": "python-c-java-beginner-level-simple-short-solution-greedy-approach",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q413. Arithmetic Slices***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, n: List[int]) -> int:\\n        ans=0\\n        i,j=2,1\\n        while i<len(n):\\n            if n[i]-n[i-1]!=n[j]-n[j-1]:\\n                j=i\\n            ans+=i-j\\n            i+=1\\n        return ans;\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n//        int res=0;\\n//         for (int i = 2, j = 1; i < n.length; ++i) {\\n//         if (n[i] - n[i - 1] != n[j] - n[j - 1])\\n//             j = i;\\n//         res += i - j;\\n//     }\\n//     return res;\\n    //or\\n        if(nums.length<=2)\\n            return 0;\\n        int diff=0,cur=0,prev=nums[1]-nums[0],ind=0;\\n        for( int i=1;i<nums.length-1;i++)\\n        {\\n            diff=nums[i+1]-nums[i];\\n            if(prev==diff)\\n                ind++;\\n            else{\\n                prev=diff;\\n                ind=0;\\n            }\\n            cur+=ind;\\n        }\\n        return cur;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<=2)\\n            return 0;\\n        int diff=0,cur=0,prev=nums[1]-nums[0],ind=0;\\n        for( int i=1;i<nums.size()-1;i++)\\n        {\\n            diff=nums[i+1]-nums[i];\\n            if(prev==diff)\\n                ind++;\\n            else{\\n                prev=diff;\\n                ind=0;\\n            }\\n            cur+=ind;\\n        }\\n        return cur;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, n: List[int]) -> int:\\n        ans=0\\n        i,j=2,1\\n        while i<len(n):\\n            if n[i]-n[i-1]!=n[j]-n[j-1]:\\n                j=i\\n            ans+=i-j\\n            i+=1\\n        return ans;\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n//        int res=0;\\n//         for (int i = 2, j = 1; i < n.length; ++i) {\\n//         if (n[i] - n[i - 1] != n[j] - n[j - 1])\\n//             j = i;\\n//         res += i - j;\\n//     }\\n//     return res;\\n    //or\\n        if(nums.length<=2)\\n            return 0;\\n        int diff=0,cur=0,prev=nums[1]-nums[0],ind=0;\\n        for( int i=1;i<nums.length-1;i++)\\n        {\\n            diff=nums[i+1]-nums[i];\\n            if(prev==diff)\\n                ind++;\\n            else{\\n                prev=diff;\\n                ind=0;\\n            }\\n            cur+=ind;\\n        }\\n        return cur;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<=2)\\n            return 0;\\n        int diff=0,cur=0,prev=nums[1]-nums[0],ind=0;\\n        for( int i=1;i<nums.size()-1;i++)\\n        {\\n            diff=nums[i+1]-nums[i];\\n            if(prev==diff)\\n                ind++;\\n            else{\\n                prev=diff;\\n                ind=0;\\n            }\\n            cur+=ind;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521742,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        for(int i=0;i<=nums.length-3;i++){\\n            if((nums[i+1] - nums[i]) == (nums[i+2]-nums[i+1])){\\n                dp[i+2]=dp[i+2-1]+1;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<dp.length;i++){\\n            sum = sum + dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        for(int i=0;i<=nums.length-3;i++){\\n            if((nums[i+1] - nums[i]) == (nums[i+2]-nums[i+1])){\\n                dp[i+2]=dp[i+2-1]+1;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=0;i<dp.length;i++){\\n            sum = sum + dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179954,
                "title": "c-easy-dp-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n\\t\\t//dp[i] represents number of arithmatic subarrays ending at position i\\n        vector<int> dp(n,0);\\n        \\n\\t\\t\\n        for(int i=2;i<n;i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp[i]=1+dp[i-1];\\n            }\\n        }\\n        int sum=0;\\n        for(auto x:dp){\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```\\nIf you liked the code, Give it a **Thumbs Up !!!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n\\t\\t//dp[i] represents number of arithmatic subarrays ending at position i\\n        vector<int> dp(n,0);\\n        \\n\\t\\t\\n        for(int i=2;i<n;i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp[i]=1+dp[i-1];\\n            }\\n        }\\n        int sum=0;\\n        for(auto x:dp){\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816132,
                "title": "beginners-solution-easy-to-understand",
                "content": "93.60% Faster\\n```\\nclass Solution:\\n       def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-2):\\n            j = i+1\\n            while(j<len(nums)-1):\\n                if nums[j]-nums[j-1] == nums[j+1]-nums[j]:\\n                    count += 1\\n                    j += 1\\n                else:\\n                    break\\n        return count\\n```\\n\\n\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n       def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)-2):\\n            j = i+1\\n            while(j<len(nums)-1):\\n                if nums[j]-nums[j-1] == nums[j+1]-nums[j]:\\n                    count += 1\\n                    j += 1\\n                else:\\n                    break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815805,
                "title": "c-o-n-solution-413-arithmetic-slices",
                "content": "413. Arithmetic Slices Approach:\\n\\nUsing the property of n(n+1)/2.\\nFor Example nums = [1,2,3,4,5]\\nTotal number of possible cobinations are 1(size of 5) + 2(size of 4) + 3(size of 3) + All combinations below size 3 are 0.\\n\\nTotal Combinations = n*(n+1)/2(All size combinations) - n(size 1) - (n-1)(size 2)\\nTotal Combinations = (n^2 + n - 2n - 2n + 2)/2\\nTotal Combinations = n^2 - 3n + 2)/2\\nTotal Combinations = n*(n-3)/2 + 1\\n```\\nclass Solution {\\npublic:\\n\\n      int numberOfArithmeticSlices(vector < int > & nums) {\\n\\n         int n = nums.size();\\n\\n         int start, diff, len, ans;\\n         start = diff = len = ans = 0;\\n\\n         for (int i = 1; i < n; i++) {\\n            int currD = nums[i] - nums[i - 1];\\n\\n            if (diff != currD) {\\n               len = i - start;\\n               ans += (len * (len - 3)) / 2 + 1;\\n               start = i - 1;\\n               diff = currD;\\n            }\\n\\n            //last index\\n            if (i == n - 1) {\\n               len = n - start;\\n               ans += (len * (len - 3)) / 2 + 1;\\n            }\\n         }\\n\\n         return ans;\\n      }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n      int numberOfArithmeticSlices(vector < int > & nums) {\\n\\n         int n = nums.size();\\n\\n         int start, diff, len, ans;\\n         start = diff = len = ans = 0;\\n\\n         for (int i = 1; i < n; i++) {\\n            int currD = nums[i] - nums[i - 1];\\n\\n            if (diff != currD) {\\n               len = i - start;\\n               ans += (len * (len - 3)) / 2 + 1;\\n               start = i - 1;\\n               diff = currD;\\n            }\\n\\n            //last index\\n            if (i == n - 1) {\\n               len = n - start;\\n               ans += (len * (len - 3)) / 2 + 1;\\n            }\\n         }\\n\\n         return ans;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815426,
                "title": "0-ms-c-solution-simple-math-detailed-explanation",
                "content": "**NOTE:** Please go through the entire explanation and **examples** to understand better\\n\\n**Pre-requisite:**\\nGiven an array of length **N**, then no.of subarrays of size **k** in that array = N-k+1\\n\\n**Intuition:**\\nIn this problem, we try to find the maximum length subarray whose consecutive elements difference is same and then find no.of subarrays possible with it. \\n\\nIf the length of that largest subarray is \\'n\\', then we need to find all subarrays of length 3, 4, 5, ...., n which can be calculated as:\\nNo.of subarrays of length 3 = n-3+1 = n-2\\nNo.of subarrays of length 4 = n-4+1 = n-3\\nNo.of subarrays of length 5 = n-5+1 = n-4\\n.\\n.\\nNo.of subarrays of length n-1 = n-(n-1)+1 = 2\\nNo.of subarrays of length n = n-n+1 = 1\\n\\nThe total sum of all these subarrays = 1+2+3+....+ n-2 = ((n-2) * (n-1))/2\\n\\n**Example 1:** [1,2,3,4,6,7,8,-1,-2]\\nLet\\'s find the maximum length subarray whose consecutive elements difference is same. \\nWe can find that there are 3 maximum length subarrays possible.\\n* 1st subarray = [1,2,3,4] \\n\\t* No.of subarrays formed using this subarray = (4-2) * (4-1)/2 = 3\\n\\t* The 3 subarrays are [1,2,3], [2,3,4], [1,2,3,4]\\n* 2nd subarray = [6,7,8]\\n\\t* No.of subarrays formed using this subarray = (3-2) * (3-1)/2 = 1\\n\\t* The subarray is [6,7,8]\\n* 3rd subarray = [-1,-2]\\n\\t* No.of subarrays formed using this subarray = 0\\n\\t* Because it is of not length atleast 3\\n\\nTotal no.of subarrays = 3 + 1 = 4\\n\\n**Example 2:** [1,2,3,6,8,10,12,14,-1,-2,-3,-4]\\nWe can find that there are 3 maximum length subarrays possible\\n* 1st subarray = [1,2,3]\\n\\t* No.of subarrays formed using it = (3-2) * (3-1)/2 = 1\\n* 2nd subarray = [6,8,10,12,14] \\n\\t* No.of subarrays formed using it = (5-2) * (5-1)/2 = 6\\n* 3rd subarray = [-1,-2,-3,-4]\\n\\t* No.of subarrays formed using it = (4-2) * (4-1)/2 = 3\\n\\nTotal no.of subarrays = 1 + 6 + 3 = 10\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        // If array size is less than 3, then the subarray is not possible\\n        if(nums.size() < 3){\\n            return 0;\\n        }\\n        \\n\\t\\t// Stores the final answer\\n        int ans = 0;\\n\\t\\t\\n        int diff = nums[1]-nums[0];\\n        // \\'n\\' stores the max length of the subarray in which diff is same \\n\\t\\t// Initially, there are two elements (nums[0], nums[1]) in the subarray\\n        int n = 2;\\n       \\n        for(int i=2; i<nums.size(); i++){\\n            // If the difference is same as previous difference, then subarray length increases\\n            if(nums[i]-nums[i-1] == diff){\\n                n++;\\n            }\\n            else{\\n                // Find the no.of subarrays possible  \\n                if(n >= 3){\\n                    ans += ((n-2)*(n-1))/2;\\n                }\\n                // Update the difference and length\\n\\t\\t\\t\\tdiff = nums[i]-nums[i-1];\\n                n = 2;\\n            }\\n        }\\n\\t\\t// This is to check for the ending subarray \\n        if(n >= 3){\\n            ans += ((n-2)*(n-1))/2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        // If array size is less than 3, then the subarray is not possible\\n        if(nums.size() < 3){\\n            return 0;\\n        }\\n        \\n\\t\\t// Stores the final answer\\n        int ans = 0;\\n\\t\\t\\n        int diff = nums[1]-nums[0];\\n        // \\'n\\' stores the max length of the subarray in which diff is same \\n\\t\\t// Initially, there are two elements (nums[0], nums[1]) in the subarray\\n        int n = 2;\\n       \\n        for(int i=2; i<nums.size(); i++){\\n            // If the difference is same as previous difference, then subarray length increases\\n            if(nums[i]-nums[i-1] == diff){\\n                n++;\\n            }\\n            else{\\n                // Find the no.of subarrays possible  \\n                if(n >= 3){\\n                    ans += ((n-2)*(n-1))/2;\\n                }\\n                // Update the difference and length\\n\\t\\t\\t\\tdiff = nums[i]-nums[i-1];\\n                n = 2;\\n            }\\n        }\\n\\t\\t// This is to check for the ending subarray \\n        if(n >= 3){\\n            ans += ((n-2)*(n-1))/2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1815248,
                "title": "daily-leetcode-challenge-3rd-march-c-o-n-solution",
                "content": "In this problem, minimum three elements are required. So, we start calculating no. of subarrays from 2nd index. If we find equal difference between last 3 consecutive numbers, we increase the count by 1 but if difference between last 4/5 consecutive numbers are equal then we just take no. of subarray of last index element and add 1 to it (since previous sequence is continue and 1 new sequence is coming).\\n\\nLet\\'s understand the logic through an example:\\nnums [] = 5,  8, 12, 16, 20, 24, 25, 28, 31\\nstart with 2nd index:\\n**index -> num[i] - num[i-1] == num[i-1] - num[i-2] : count**\\n2 -> 12 - 8 (4) != 8-5 (4) : 0 \\n3 -> 16-12 (4) ==12-8(4) : 1\\n4 -> 20-16(4) == 16-12(4) : 1(previous index) + 1 = 2;\\n5 -> 24 -20(4) == 20-16(4) : 2 (previous index) +1 = 3;\\n6 -> 25 - 24 (1) != 24-10(4) : 0;\\n7 -> 28-25 (3) != 25-24(1) : 0;\\n8 -> 31-28 (3) == 28-25(3) : 1;\\n\\nSo, total no. of subarrays = 0+1+2+3+0+0+1 = 7\\n\\n**Code: **\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) \\n    {\\n        int n = nums.size(), count=0; \\n        vector<int> subarray(n);\\n        \\n        for(int i=2; i<n; i++)\\n        {\\n            //checking difference for 2 consecutive pairs\\n            if((nums[i]-nums[i-1]) == nums[i-1]-nums[i-2]) \\n            {\\n                //if difference is same it will add no. of previous subarray + add 1 new subarray\\n                subarray[i] += subarray[i-1]+1;\\n                count += subarray[i];\\n            }\\n        }\\n        return count;\\n            \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) \\n    {\\n        int n = nums.size(), count=0; \\n        vector<int> subarray(n);\\n        \\n        for(int i=2; i<n; i++)\\n        {\\n            //checking difference for 2 consecutive pairs\\n            if((nums[i]-nums[i-1]) == nums[i-1]-nums[i-2]) \\n            {\\n                //if difference is same it will add no. of previous subarray + add 1 new subarray\\n                subarray[i] += subarray[i-1]+1;\\n                count += subarray[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1815142,
                "title": "explained-perfect-o-n-solution",
                "content": "* we will first find a 3 integer subarray which has common diff, thus it will initilize our result.\\n* we\\'ll keep a commondiff of current subarray that we are inspecting, current size of curr sub array\\n* whenever new diff is not equals to currdiff w\\'ll update current subarray size as 2 and currdiff as new diff obtained\\n* now take 1 2 3 4 5 6 7 8 9 as example here \\n* 123 is our first subarray and commonff =1, currszie = 3\\n* in next iteration curr size will be 4 thus we can make 4-3+1 i.e 2 new sub array from it as 1234, 234, thus result will be +2\\n* in next iteration currsize will be 5 thus new array that can be made from it will be 5-3+1 = 3 i.e 12345,2345,345 thus keep on doing so\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int res = 0, currsize = 0, currdiff=0;\\n        int i=0;\\n        bool toggle = true;\\n        for(i=2; i<nums.size() && toggle; i++){\\n            if(nums[i]-nums[i-1] == nums[i-1] - nums[i-2]){\\n                toggle = false;\\n                currsize =3;\\n                currdiff = nums[i]-nums[i-1];\\n                res+=1;\\n            }\\n        }\\n        for(i--; i<nums.size()-1; i++){\\n            if(nums[i+1] - nums[i] == currdiff){\\n                currsize++;\\n                if(currsize>=3){\\n                res+=currsize-2;\\n                }\\n            }\\n            else{\\n                currsize = 2;\\n                currdiff = nums[i+1]-nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n**Do upvote asap**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int res = 0, currsize = 0, currdiff=0;\\n        int i=0;\\n        bool toggle = true;\\n        for(i=2; i<nums.size() && toggle; i++){\\n            if(nums[i]-nums[i-1] == nums[i-1] - nums[i-2]){\\n                toggle = false;\\n                currsize =3;\\n                currdiff = nums[i]-nums[i-1];\\n                res+=1;\\n            }\\n        }\\n        for(i--; i<nums.size()-1; i++){\\n            if(nums[i+1] - nums[i] == currdiff){\\n                currsize++;\\n                if(currsize>=3){\\n                res+=currsize-2;\\n                }\\n            }\\n            else{\\n                currsize = 2;\\n                currdiff = nums[i+1]-nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814918,
                "title": "java-code-dp-with-notes",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        int res = 0;\\n        \\n        for(int i = 2; i < nums.length; i++){\\n            \\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nNotes link: https://github.com/rizonkumar/LeetCode-Notes/blob/main/413.pdf",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        int res = 0;\\n        \\n        for(int i = 2; i < nums.length; i++){\\n            \\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814512,
                "title": "c-0ms-faster-then-100-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/bf9c8761-8340-46d6-bc18-3567e41fa84a_1646275046.7233868.png)\\n```\\nint numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)  //if size is less then 3 then it can\\'t be a Arithmetic\\n            return 0;\\n        int res=0;\\n        for(int i=0;i<nums.size()-2;i++) // loop from 1st to 3rd last element\\n        {\\n            int d = nums[i+1]-nums[i] // difference of 2 element \\n            //An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\\n            for(int j=i+2;j<nums.size();j++) // loop from 3rd to last element \\n            {\\n                if(nums[j]-nums[j-1]==d)  // we will increase j and if the diffrence between 2 elements stay equal then is a Arithmetic.\\n                    res++;\\n                else\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Upvote, if you find helpful**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size() < 3)  //if size is less then 3 then it can\\'t be a Arithmetic\\n            return 0;\\n        int res=0;\\n        for(int i=0;i<nums.size()-2;i++) // loop from 1st to 3rd last element\\n        {\\n            int d = nums[i+1]-nums[i] // difference of 2 element \\n            //An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\\n            for(int j=i+2;j<nums.size();j++) // loop from 3rd to last element \\n            {\\n                if(nums[j]-nums[j-1]==d)  // we will increase j and if the diffrence between 2 elements stay equal then is a Arithmetic.\\n                    res++;\\n                else\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814350,
                "title": "python-faster-than-85",
                "content": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        def num_ways(len):\\n            return (len - 2) * (len - 1) // 2\\n            \\n        result = 0\\n        prev_delta = float(\"inf\")\\n        cur_len = 0\\n        for i in range(1, len(nums)):\\n            delta = nums[i] - nums[i - 1]\\n            if delta == prev_delta:\\n                cur_len += 1\\n            else:\\n                if cur_len >= 3:\\n                    result += num_ways(cur_len)\\n                cur_len = 2\\n                prev_delta = delta\\n        if cur_len >= 3:\\n            result += num_ways(cur_len)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        def num_ways(len):\\n            return (len - 2) * (len - 1) // 2\\n            \\n        result = 0\\n        prev_delta = float(\"inf\")\\n        cur_len = 0\\n        for i in range(1, len(nums)):\\n            delta = nums[i] - nums[i - 1]\\n            if delta == prev_delta:\\n                cur_len += 1\\n            else:\\n                if cur_len >= 3:\\n                    result += num_ways(cur_len)\\n                cur_len = 2\\n                prev_delta = delta\\n        if cur_len >= 3:\\n            result += num_ways(cur_len)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593166,
                "title": "using-dynamic-programming-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        int d = nums[1] - nums[0];\\n        int dp[n];\\n        dp[0] = 1;\\n        dp[1] = 2;\\n        int ret = 0;\\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i] == nums[i-1] + d)\\n                dp[i] = dp[i-1]+1;\\n            else\\n            {\\n                d = nums[i] - nums[i-1];\\n                dp[i] = 2;\\n            }\\n            if(dp[i] > 2)\\n                ret += (dp[i]-3+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        int d = nums[1] - nums[0];\\n        int dp[n];\\n        dp[0] = 1;\\n        dp[1] = 2;\\n        int ret = 0;\\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i] == nums[i-1] + d)\\n                dp[i] = dp[i-1]+1;\\n            else\\n            {\\n                d = nums[i] - nums[i-1];\\n                dp[i] = 2;\\n            }\\n            if(dp[i] > 2)\\n                ret += (dp[i]-3+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465530,
                "title": "math-dp-brute-force-all-three-aproaches",
                "content": "# **Mathematical Solution**\\n***Fastest Solution***\\n\\n*Logic for curr(curr-3)/2*\\nIf there is an subarray, satisfying the conditions given, having ***N*** elements then\\n1. how many subarray of size 3 are possible from the given subarray = ***N - ( 3 - 1 )***\\n2. how many subarray of size 4 are possible from the given subarray = ***N - ( 4 - 1 )***\\n3. how many subarray of size 5 are possible from the given subarray = ***N - ( 5 - 1 )***\\n.\\n.\\n.\\n.\\nN.how many subarray of size N are possible from the given subarray = ***N - ( N - 1 )***\\n\\nwhich will sum to ***N * ( N - 2) + ( N - 1 ) * N /2***  = ***N * ( N - 3 ) / 2***\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++)nums[i]-=nums[i+1];\\n        // for(auto i:nums)cout<<i<<\" \";\\n        int curr=1;\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==nums[i-1])curr++;\\n            else{\\n                curr++;     //adding 1 to current because the actual value of curr will always be \\n\\t\\t\\t\\t\\t\\t\\t//one less since we are leaving out the first element of the subset in calculation\\n\\t\\t\\t\\t\\t\\t\\t// for eg : {2,4,6,8,11,12,14} will have the auxiliary array as {-2,-2,-2,-3,-1,-2,14}\\n\\t\\t\\t\\t\\t\\t\\t//so three consecutive -2 will depict {2,4,6,8} hence the curr++\\n                ans += ((curr*(curr-3))/2)+1;\\n                curr=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# **DP**\\n***Faster than Brute Force***\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int n=A.size();\\n        if(n<3){return 0;}\\n        int dp[n];\\n        dp[0]=0;\\n        dp[1]=0;\\n        int sum=0;\\n        for(int i=2;i<n;i++){\\n            if((A[i]-A[i-1])==(A[i-1]-A[i-2])){\\n                dp[i]=dp[i-1]+1;\\n            }else{\\n                dp[i]=0;\\n            }\\n            sum+=dp[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n\\n\\n# **Brute Force**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        bool flag=0;\\n        int n=nums.size();\\n        if(n<3)return 0;\\n        int ans=0;\\n        for (int len = 3; len <= n; len++)\\n        {   \\n            for (int i = 0; i <= n - len; i++)\\n            {\\n                flag=1;\\n                int j = i + len - 1;           \\n                for (int k = i; k <= j-2; k++)\\n                {\\n                    if((nums[k]-nums[k+1])!=(nums[k+1]-nums[k+2]))\\n                    {\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++)nums[i]-=nums[i+1];\\n        // for(auto i:nums)cout<<i<<\" \";\\n        int curr=1;\\n        int ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==nums[i-1])curr++;\\n            else{\\n                curr++;     //adding 1 to current because the actual value of curr will always be \\n\\t\\t\\t\\t\\t\\t\\t//one less since we are leaving out the first element of the subset in calculation\\n\\t\\t\\t\\t\\t\\t\\t// for eg : {2,4,6,8,11,12,14} will have the auxiliary array as {-2,-2,-2,-3,-1,-2,14}\\n\\t\\t\\t\\t\\t\\t\\t//so three consecutive -2 will depict {2,4,6,8} hence the curr++\\n                ans += ((curr*(curr-3))/2)+1;\\n                curr=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int n=A.size();\\n        if(n<3){return 0;}\\n        int dp[n];\\n        dp[0]=0;\\n        dp[1]=0;\\n        int sum=0;\\n        for(int i=2;i<n;i++){\\n            if((A[i]-A[i-1])==(A[i-1]-A[i-2])){\\n                dp[i]=dp[i-1]+1;\\n            }else{\\n                dp[i]=0;\\n            }\\n            sum+=dp[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        bool flag=0;\\n        int n=nums.size();\\n        if(n<3)return 0;\\n        int ans=0;\\n        for (int len = 3; len <= n; len++)\\n        {   \\n            for (int i = 0; i <= n - len; i++)\\n            {\\n                flag=1;\\n                int j = i + len - 1;           \\n                for (int k = i; k <= j-2; k++)\\n                {\\n                    if((nums[k]-nums[k+1])!=(nums[k+1]-nums[k+2]))\\n                    {\\n                        flag=0;\\n                        break;\\n                    }\\n                }\\n                if(flag)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1455672,
                "title": "c-easy-clean-solution-fastest-0ms-variable-size-sliding-window-dp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\t    // AP: Arithmetic Progression\\n        // Idea: Use sliding window of variable size (k) to solve this problem\\n        // Note: for an AP array/ window of size k, the total no. of AP subarrays with\\n        // size >= r are: (k - r + 1)*(k - r + 2) / 2 (i.e sum(k - r + 1) where 3 <= r <= k)\\n        // in our case: r = 3, thus for each AP window of size k, ans is: (k - 1) * (k - 2) / 3\\n        int size = nums.size();\\n        // handle simple case\\n        if (size <= 2) \\n            return 0;\\n        // init variables\\n        int commonDiff = nums[1] - nums[0], start = 0, end = 2, ans = 0, windowSize = 0;\\n        while (end < size) {\\n            // expand end of window if currSequence is AP\\n            while (end < size and nums[end] - nums[end - 1] == commonDiff)\\n                end++;\\n            // calc. no. of possible AP seq. for this window\\n            if ((windowSize = end - start) >= 3) // same as: (end - 1) - start + 1\\n                ans += (windowSize - 1) * (windowSize - 2) / 2;\\n            // if end is reached then return ans\\n            if (end == size) \\n                return ans;\\n            // update common difference of AP and start & end terms\\n            commonDiff = nums[end] - nums[end - 1], start = end - 1, end++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written a post on all C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\t    // AP: Arithmetic Progression\\n        // Idea: Use sliding window of variable size (k) to solve this problem\\n        // Note: for an AP array/ window of size k, the total no. of AP subarrays with\\n        // size >= r are: (k - r + 1)*(k - r + 2) / 2 (i.e sum(k - r + 1) where 3 <= r <= k)\\n        // in our case: r = 3, thus for each AP window of size k, ans is: (k - 1) * (k - 2) / 3\\n        int size = nums.size();\\n        // handle simple case\\n        if (size <= 2) \\n            return 0;\\n        // init variables\\n        int commonDiff = nums[1] - nums[0], start = 0, end = 2, ans = 0, windowSize = 0;\\n        while (end < size) {\\n            // expand end of window if currSequence is AP\\n            while (end < size and nums[end] - nums[end - 1] == commonDiff)\\n                end++;\\n            // calc. no. of possible AP seq. for this window\\n            if ((windowSize = end - start) >= 3) // same as: (end - 1) - start + 1\\n                ans += (windowSize - 1) * (windowSize - 2) / 2;\\n            // if end is reached then return ans\\n            if (end == size) \\n                return ans;\\n            // update common difference of AP and start & end terms\\n            commonDiff = nums[end] - nums[end - 1], start = end - 1, end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304802,
                "title": "easy-c-dp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        int result=0;\\n        if(n<3) return 0;\\n        for(int i =2; i<n; i++){\\n           if(nums[i]- nums[i-1] == nums[i-1] - nums[i-2]){\\n              dp[i] = dp[i-1] +1;\\n               result+= dp[i];\\n           }\\n            else dp[i] =0;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**comment if have doubt and please upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        int result=0;\\n        if(n<3) return 0;\\n        for(int i =2; i<n; i++){\\n           if(nums[i]- nums[i-1] == nums[i-1] - nums[i-2]){\\n              dp[i] = dp[i-1] +1;\\n               result+= dp[i];\\n           }\\n            else dp[i] =0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072367,
                "title": "c-o-n-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int res  = 0;\\n        deque<int> vec;\\n        for (int i = 1; i < A.size(); i++) {\\n            vec.push_back(A[i] - A[i - 1]);\\n            while (vec.front() != vec.back())\\n                vec.pop_front();\\n            res += max(0, (int)vec.size() - 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int res  = 0;\\n        deque<int> vec;\\n        for (int i = 1; i < A.size(); i++) {\\n            vec.push_back(A[i] - A[i - 1]);\\n            while (vec.front() != vec.back())\\n                vec.pop_front();\\n            res += max(0, (int)vec.size() - 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071189,
                "title": "c-0-ms-faster-than-100-00-o-n-super-simple-easy-understanding-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if ( A.size() < 3 ) return 0;\\n        int res = 0, counter = 2, lastDif = A[1] - A[0], index = 2, len = A.size();\\n        \\n        for(; index < len; ++index)\\n        {\\n            if ( lastDif == A[index] - A[index - 1] )\\n                ++counter;\\n            else\\n            {\\n                if ( counter >= 3 )\\n                    res += (counter - 1) * (counter - 2) / 2;\\n                counter = 2;\\n                lastDif = A[index] - A[index - 1];\\n            }\\n        }\\n        if ( counter >= 3 )\\n            res += (counter - 1) * (counter - 2) / 2;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        if ( A.size() < 3 ) return 0;\\n        int res = 0, counter = 2, lastDif = A[1] - A[0], index = 2, len = A.size();\\n        \\n        for(; index < len; ++index)\\n        {\\n            if ( lastDif == A[index] - A[index - 1] )\\n                ++counter;\\n            else\\n            {\\n                if ( counter >= 3 )\\n                    res += (counter - 1) * (counter - 2) / 2;\\n                counter = 2;\\n                lastDif = A[index] - A[index - 1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1071181,
                "title": "python-faster-than-97-99-o-n-super-simple-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        if len(A) < 3: return 0\\n        \\n        res, counter = 0, 2\\n        last_dif = A[1] - A[0]\\n        \\n        for index, num in enumerate(A[2:], 1):\\n            \\n            if last_dif == num - A[index]:\\n                counter += 1  \\n            else:\\n                if counter >= 3:\\n                    res += (counter - 1) * (counter - 2) // 2   \\n                counter = 2\\n                last_dif = num - A[index]\\n                \\n                \\n        if counter >= 3:\\n            res += (counter - 1) * (counter - 2) // 2\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        if len(A) < 3: return 0\\n        \\n        res, counter = 0, 2\\n        last_dif = A[1] - A[0]\\n        \\n        for index, num in enumerate(A[2:], 1):\\n            \\n            if last_dif == num - A[index]:\\n                counter += 1  \\n            else:\\n                if counter >= 3:\\n                    res += (counter - 1) * (counter - 2) // 2   \\n                counter = 2\\n                last_dif = num - A[index]\\n                \\n                \\n        if counter >= 3:\\n            res += (counter - 1) * (counter - 2) // 2\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1071117,
                "title": "python-easy-solution-beats-91",
                "content": "Time complexity: O(n)\\n\\nShort description:\\nThere is a loop with calculation a difference between the current element and the next one.\\nThe number of combinations will increase, if the current difference is equal to difference between the previous elements, otherwise the number of combinations will start over from zero. The answer is the total number of such combinations.   \\n\\nExample:\\n[1,2,3,4,6,8]\\nEL DIF LD COMB COUNT\\n1    1     0    0           0\\n2    1     1    1           1\\n3    1     1    2           3\\n4    2     1    0           3\\n6    2     2    1           4\\nAnswer: 4\\n\\nSolution:\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        count = comb = last_difference = 0\\n        for i in range(len(A)-1):\\n            difference= A[i+1] - A[i]\\n            if i != 0 and difference == last_difference: \\n                comb += 1\\n                count += comb\\n            else:\\n                comb = 0\\n            last_difference = difference\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        count = comb = last_difference = 0\\n        for i in range(len(A)-1):\\n            difference= A[i+1] - A[i]\\n            if i != 0 and difference == last_difference: \\n                comb += 1\\n                count += comb\\n            else:\\n                comb = 0\\n            last_difference = difference\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235051,
                "title": "1-ms-java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        if (A.length <3) {\\n            return 0;\\n        }\\n        int[] arr = new int[A.length-1];\\n        for (int i=0;i<arr.length;i++) {\\n            arr[i]=A[i+1]-A[i];\\n        }\\n        int c=1;\\n        int s=0;\\n        for (int i=0; i < arr.length-1;i++) {\\n            if (arr[i] == arr[i+1])\\n                c++;\\n            else{\\n                if(c>1)\\n                    s+=(c*(c-1))/2; \\n                c=1;\\n            }\\n        }\\n        if (c>1)\\n            s+=(c*(c-1))/2;\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        if (A.length <3) {\\n            return 0;\\n        }\\n        int[] arr = new int[A.length-1];\\n        for (int i=0;i<arr.length;i++) {\\n            arr[i]=A[i+1]-A[i];\\n        }\\n        int c=1;\\n        int s=0;\\n        for (int i=0; i < arr.length-1;i++) {\\n            if (arr[i] == arr[i+1])\\n                c++;\\n            else{\\n                if(c>1)\\n                    s+=(c*(c-1))/2; \\n                c=1;\\n            }\\n        }\\n        if (c>1)\\n            s+=(c*(c-1))/2;\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172316,
                "title": "scala-1-line-dp-o-n",
                "content": "```\n(2 until A.size).scan(0)((cur,j) => if (A(j) - A(j-1) == A(j-1) - A(j-2)) cur + 1 else 0).sum\n```",
                "solutionTags": [],
                "code": "```\n(2 until A.size).scan(0)((cur,j) => if (A(j) - A(j-1) == A(j-1) - A(j-2)) cur + 1 else 0).sum\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 119277,
                "title": "c-easy-to-understand-solution",
                "content": "I tried multiple approaches to solve this problem. Have a look.\\n\\n#### 1.2D DP Matrix Space:O(n^2) Time:O(n) (TIME LIMIT EXCEDED)\\n\\n```\\nclass Solution {\\npublic:\\n     inline bool consecutive(const vector<int>& A, const int& first,const int& second,const int& third, const int& fourth){\\n        return A[second] - A[first] == A[fourth]-A[third];\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int m = A.size();\\n        vector<vector<int> > dp(m,vector<int>(m,0));\\n        int count=0;\\n        \\n        //Check for Length=3\\n        for(int i=0;i<=(m-3);i++) {\\n            \\n                dp[i][i+2]=consecutive(A,i,i+1,i+1,i+2) ? 1 : 0;\\n                \\n                if(dp[i][i+2]) count++;\\n            \\n        }\\n        \\n       //Check for Length 4 to Length m\\n        for(int l=4;l<=m;l++) {\\n            for(int i=0;i<=(m-l);i++) {\\n                int j = i + l -1;\\n                \\n                dp[i][j] = dp[i][j-1] && consecutive(A,i,i+1,j-1,j) ? 1 : 0;\\n                if(dp[i][j]) count++;\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n#### 2.Single DP Array  Space:O(n) Time:O(n) (ACCEPTED)\\nThanks @vesion for the [solution](https://leetcode.com/problems/arithmetic-slices/discuss/90093/3ms-C++-Standard-DP-Solution-with-Very-Detailed-Explanation).\\n\\nThis is a really smart approach. \\nRemember this: **dp[i] represents the number of artihmatic sequences(AS) till A[i]**\\nSo lets see how it works for `testcase :  [0,1,2,3,4]`\\n`dp[0] = 0`  Since not 3 numbers\\n`dp[1] = 0` Since not 3 numbers\\n`dp[2] = 0 + 1`  Since [0,1,2] is an AS\\n`dp[3] = dp[2] + 1` Here dp[2] provides [0,1,2] and appending [3] gives dp[2] Arithmatic Subsequences = 1. Also [1,2,3] is an AS thats why we did +1.\\ndp[4] = dp[3] + 1 Here dp[3] provides [0,1,2,3] and [1,2,3] and appending [4] gives dp[3] AS =  2. Also [2,3,4] is an AS thats why we did +1\\n\\nHope you get the flow of it now\\n```\\nclass Solution {\\npublic:\\n    inline bool consecutive(const vector<int>& A, const int& first,const int& second,const int& third, const int& fourth){\\n        return A[second] - A[first] == A[fourth]-A[third];\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int m = A.size();\\n        if(m<3) return false;\\n        \\n        //Make a dp array where dp[i] signifies the Number of Artimetic Sequence till A[i]\\n        vector<int> dp(m);\\n        int count=0;\\n        \\n        //Aritmatic Sequnce has to be atleast 3 numbers\\n        dp[0]=0;\\n        dp[1]=0;\\n    \\n\\n       //Check for each A[i]\\n       for(int i=2;i<m;i++){\\n           dp[i] = consecutive(A,i,i-1,i-1,i-2) ? dp[i-1] + 1 : 0;\\n           count+=dp[i];\\n       }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n\\n\\n#### 3.DP Solution with only 1 Variable  Space:O(1) Time:O(n) (ACCEPTED)\\nThanks @thx2kevin for the [solution](https://leetcode.com/problems/arithmetic-slices/discuss/90093/3ms-C++-Standard-DP-Solution-with-Very-Detailed-Explanation/94649)\\n\\n```\\nclass Solution {\\npublic:\\n    inline bool consecutive(const vector<int>& A, const int& first,const int& second,const int& third, const int& fourth){\\n        return A[second] - A[first] == A[fourth]-A[third];\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int m = A.size();\\n        if(m<3) return false;\\n        \\n        int dp = 0;\\n        int count = 0;\\n        \\n\\n       //Check for each A[i]\\n       for(int i=2;i<m;i++){\\n           dp = consecutive(A,i,i-1,i-1,i-2) ? (dp + 1) : 0;\\n           count+=dp;\\n       }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     inline bool consecutive(const vector<int>& A, const int& first,const int& second,const int& third, const int& fourth){\\n        return A[second] - A[first] == A[fourth]-A[third];\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int m = A.size();\\n        vector<vector<int> > dp(m,vector<int>(m,0));\\n        int count=0;\\n        \\n        //Check for Length=3\\n        for(int i=0;i<=(m-3);i++) {\\n            \\n                dp[i][i+2]=consecutive(A,i,i+1,i+1,i+2) ? 1 : 0;\\n                \\n                if(dp[i][i+2]) count++;\\n            \\n        }\\n        \\n       //Check for Length 4 to Length m\\n        for(int l=4;l<=m;l++) {\\n            for(int i=0;i<=(m-l);i++) {\\n                int j = i + l -1;\\n                \\n                dp[i][j] = dp[i][j-1] && consecutive(A,i,i+1,j-1,j) ? 1 : 0;\\n                if(dp[i][j]) count++;\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    inline bool consecutive(const vector<int>& A, const int& first,const int& second,const int& third, const int& fourth){\\n        return A[second] - A[first] == A[fourth]-A[third];\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int m = A.size();\\n        if(m<3) return false;\\n        \\n        //Make a dp array where dp[i] signifies the Number of Artimetic Sequence till A[i]\\n        vector<int> dp(m);\\n        int count=0;\\n        \\n        //Aritmatic Sequnce has to be atleast 3 numbers\\n        dp[0]=0;\\n        dp[1]=0;\\n    \\n\\n       //Check for each A[i]\\n       for(int i=2;i<m;i++){\\n           dp[i] = consecutive(A,i,i-1,i-1,i-2) ? dp[i-1] + 1 : 0;\\n           count+=dp[i];\\n       }\\n\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    inline bool consecutive(const vector<int>& A, const int& first,const int& second,const int& third, const int& fourth){\\n        return A[second] - A[first] == A[fourth]-A[third];\\n    }\\n    \\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int m = A.size();\\n        if(m<3) return false;\\n        \\n        int dp = 0;\\n        int count = 0;\\n        \\n\\n       //Check for each A[i]\\n       for(int i=2;i<m;i++){\\n           dp = consecutive(A,i,i-1,i-1,i-2) ? (dp + 1) : 0;\\n           count+=dp;\\n       }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801121,
                "title": "java-easy-sliding-window-0ms-solution-o-n-tc",
                "content": "\\n######  This problem can be solved in O(N) time complexity and constant space. we are given an array , at first we will check whether our array length is greater than or equal to 3 , if not then we can directly return answer as 0\\n```\\n    if(nums.length<3){\\n        return 0;\\n    }\\n```\\n###### Then we need a two pointers i and j , i will be the starting index of subarrays and with j we will explore our array\\n###### Suppose the array is : [1,2,3,4,5] <br/> Assume we re now at nums[2]=3 the total arithmetic slice at this position will be 1 .... <br/> j-i+1 will give us the subarray length, now if we do (j-i+1 -2) i.e j-i-1 then we will get all the arithmetic slice of length >=3 from that position ....... check this pattern by analysing some testcase\\n```\\n    if(nums[j]-nums[j-1]==diff){\\n        if(j-i+1>=3){\\n            ans=ans+(j-i-1);\\n            }\\n        j++; \\n    }\\n```\\n###### If we\\'re on nums[3]=4 then total arithmetic slice from that index is 2 ..[1,2,3,4] and [2,3,4] Add this value to our main answer\\n###### If common diff from our subarray is not equal to nums[j]-nums[j-1] then we change our i value to j-1 and j++;\\n```\\n    diff=nums[j]-nums[j-1];\\n    i=j-1;\\n    j++;\\n```\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n---\\n\\n\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int i=0;\\n        int j=2;\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int diff=nums[1]-nums[0];\\n        int ans=0;\\n        while(j<nums.length){ \\n            if(nums[j]-nums[j-1]==diff){\\n                if(j-i+1>=3){\\n                    ans=ans+(j-i-1);\\n                }\\n                    j++; \\n            }else{\\n                diff=nums[j]-nums[j-1];\\n                i=j-1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Please UPVOTE the solution if this helps you <br/>\\n\\n![catmemer.jpg](https://assets.leetcode.com/users/images/8f3ccee1-a655-49a4-8d89-cd732f3e28e8_1690033815.5662167.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    if(nums.length<3){\\n        return 0;\\n    }\\n```\n```\\n    if(nums[j]-nums[j-1]==diff){\\n        if(j-i+1>=3){\\n            ans=ans+(j-i-1);\\n            }\\n        j++; \\n    }\\n```\n```\\n    diff=nums[j]-nums[j-1];\\n    i=j-1;\\n    j++;\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int i=0;\\n        int j=2;\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int diff=nums[1]-nums[0];\\n        int ans=0;\\n        while(j<nums.length){ \\n            if(nums[j]-nums[j-1]==diff){\\n                if(j-i+1>=3){\\n                    ans=ans+(j-i-1);\\n                }\\n                    j++; \\n            }else{\\n                diff=nums[j]-nums[j-1];\\n                i=j-1;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649166,
                "title": "arithmetic-slices-o-n-javascript-memory-70-42-meaningful-vars",
                "content": "![image](https://assets.leetcode.com/users/images/a4948bf0-35de-4425-831e-f8a578a098cb_1687019143.0423453.png)\\n\\n```\\nfunction findSumByCount(count) {\\n    if (count < 3) {\\n        return 0;\\n    }\\n    return (count - 2) * (count - 2 + 1) / 2;\\n}\\n\\nvar numberOfArithmeticSlices = function(nums) {\\n    let movingIndex = 1;\\n    let sum = 0;\\n    let count = 0;\\n    let previousDiff = null;\\n    let currentDiff = null;\\n    while (movingIndex < nums.length) {\\n        currentDiff = nums[movingIndex] - nums[movingIndex - 1];\\n        if (previousDiff === null) {\\n            previousDiff = currentDiff;\\n            count = 1;\\n        } else if (previousDiff !== currentDiff) {\\n            sum += findSumByIndex(count);\\n            currentDiff = null;\\n            previousDiff = null;\\n            count = 0;\\n            continue;\\n        }\\n        movingIndex++;\\n        count++;\\n    }\\n    sum += findSumByIndex(count);\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findSumByCount(count) {\\n    if (count < 3) {\\n        return 0;\\n    }\\n    return (count - 2) * (count - 2 + 1) / 2;\\n}\\n\\nvar numberOfArithmeticSlices = function(nums) {\\n    let movingIndex = 1;\\n    let sum = 0;\\n    let count = 0;\\n    let previousDiff = null;\\n    let currentDiff = null;\\n    while (movingIndex < nums.length) {\\n        currentDiff = nums[movingIndex] - nums[movingIndex - 1];\\n        if (previousDiff === null) {\\n            previousDiff = currentDiff;\\n            count = 1;\\n        } else if (previousDiff !== currentDiff) {\\n            sum += findSumByIndex(count);\\n            currentDiff = null;\\n            previousDiff = null;\\n            count = 0;\\n            continue;\\n        }\\n        movingIndex++;\\n        count++;\\n    }\\n    sum += findSumByIndex(count);\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339951,
                "title": "python-o-n",
                "content": "# Intuition\\nI thought about dp and math in my high school\\n\\n# Approach\\nIf the length of the input list is less than or equal to 2, there are no arithmetic slices, so we return 0.\\n\\n\\n\\n\\n\\n\\n1.We create a list dp of length n (the length of the input list) and initialize all its elements to 0. This list will store the number of arithmetic slices ending at each index.\\n\\n2.We set k to the difference between the last two elements of the input list, since any arithmetic slice must have this common difference.\\nWe iterate backwards through the input list, starting from the second to last element.\\n\\n3.For each element at index i, we check if the element and the element k positions ahead (i + 2) form an arithmetic slice with the element at index i + 1. If they do, we set dp[i] to dp[i + 1] + 1, since the number of arithmetic slices ending at index i is equal to the number ending at index i + 1 plus the new slice we just found.\\n\\n4.We update k to be the difference between the current element and the next element (nums[i + 1] - nums[i]), since this will be the common difference for the next arithmetic slice we might find.\\n\\n5.We return the sum of all the elements in dp, which gives us the total number of arithmetic slices in the input list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) # we iterate through the list once\\n\\n- Space complexity:\\nO(n) # The \"dp\" list takes up O(n) space in memory\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return 0\\n        dp = [0] * len(nums)\\n        k = nums[-1] - nums[-2] # \"k\" represents the common difference in the arithmetic progression formed by the input array\\n\\n        \\n\\n        for i in range(len(nums) -3, -1,-1):\\n            if nums[i] + k == nums[i + 1] == nums[i + 2] - k: \\n                dp[i] = dp[i + 1] + 1\\n            k = nums[i + 1] - nums[i]\\n        return sum(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return 0\\n        dp = [0] * len(nums)\\n        k = nums[-1] - nums[-2] # \"k\" represents the common difference in the arithmetic progression formed by the input array\\n\\n        \\n\\n        for i in range(len(nums) -3, -1,-1):\\n            if nums[i] + k == nums[i + 1] == nums[i + 2] - k: \\n                dp[i] = dp[i + 1] + 1\\n            k = nums[i + 1] - nums[i]\\n        return sum(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330650,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int tot=0;\\n        int cur=0;\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])\\n            {\\n                cur++;\\n                tot=tot+cur;\\n            }\\n            else\\n            {\\n                cur=0;\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int tot=0;\\n        int cur=0;\\n        for(int i=2;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])\\n            {\\n                cur++;\\n                tot=tot+cur;\\n            }\\n            else\\n            {\\n                cur=0;\\n            }\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324971,
                "title": "c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nsimple beginner level approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the size of nums is less then 3 no possible subarray just simply return 0.For every iteration we are just checking its differnce from previous no and if the difference is equal to previous differnece for which we are maitaining a variable prev then we are increasing the count .Here is an point to be noted that our count is increasing first time when subarray length is 3 and so on so in this way there will be no cases for subarrays whose lengths are less than 2.when the difference is not equal to previous difference we can get the subarrays by the formula count*(count+1)/2(verify it by taking some examples on your own) and we will add it in ans and will make the count 0. finally return the ans.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n            return 0;\\n        }\\n        int count=0,ans=0,prev=200001;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==prev){\\n                count++;\\n            }\\n            else{\\n                ans+=count*(count+1)/2;\\n                count=0;\\n            }\\n            prev=nums[i]-nums[i-1];\\n        }\\n        if(count>0){\\n            ans+=count*(count+1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n            return 0;\\n        }\\n        int count=0,ans=0,prev=200001;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==prev){\\n                count++;\\n            }\\n            else{\\n                ans+=count*(count+1)/2;\\n                count=0;\\n            }\\n            prev=nums[i]-nums[i-1];\\n        }\\n        if(count>0){\\n            ans+=count*(count+1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276810,
                "title": "easy-and-fast-solution-o-n-time-o-1-space",
                "content": "# Approach\\nTo solve the problem, we can iterate through the array and identify if the current element, along with the two next elements, form an arithmetic sequence. If it does, we increment a counter variable. If it doesn\\'t, we can calculate the number of arithmetic slices that were found so far using the formula (n*(n+1))/2, where n is the number of arithmetic slices found so far. We add this number to a result variable and reset the counter variable to zero. Finally, we return the total number of arithmetic slices found by adding the remaining count to the result variable.\\n\\n\\n# Complexity\\n- *Time complexity:*\\n**O(n) where n is the length of the input array. This is because we iterate through the array only once.**\\n\\n- *Space complexity:*\\n**O(1) as we only use constant space to store the sum and result variables.**\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n \\nvar numberOfArithmeticSlices = function(nums) {\\n    let sum=0,res=0;\\n    for(let i=0;i+2<nums.length;i++){\\n        if(nums[i+1]-nums[i]===nums[i+2]-nums[i+1]) sum++;\\n        else{\\n            res+=sum*(sum+1)/2;\\n            sum=0;\\n        }\\n    }\\n    return res+sum*(sum+1)/2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n \\nvar numberOfArithmeticSlices = function(nums) {\\n    let sum=0,res=0;\\n    for(let i=0;i+2<nums.length;i++){\\n        if(nums[i+1]-nums[i]===nums[i+2]-nums[i+1]) sum++;\\n        else{\\n            res+=sum*(sum+1)/2;\\n            sum=0;\\n        }\\n    }\\n    return res+sum*(sum+1)/2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262569,
                "title": "413-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We define a class Solution with a function numberOfArithmeticSlices that takes in an integer list nums and returns an integer representing the number of arithmetic slices in nums.\\n\\n2. We initialize a counter variable count to 0. This variable will keep track of the total number of arithmetic slices in nums.\\n\\n3. We also initialize a variable curr to 0. This variable will keep track of the current length of the arithmetic slice that we are checking.\\n\\n4. We iterate through the list nums starting from the third element, since we need at least three elements to form an arithmetic slice.\\n\\n5. For each element nums[i], we check if it is part of an arithmetic slice by comparing its difference with the previous element\\'s difference. If the difference is the same, then we know that the current element is part of an arithmetic slice.\\n\\n6. If the current element is part of an arithmetic slice, we increment the curr variable by 1, which represents the length of the current arithmetic slice.\\n\\n7. We also add the curr variable to the count variable to keep track of the total number of arithmetic slices.\\n\\n8. If the current element is not part of an arithmetic slice, we reset the curr variable to 0 since we are no longer in an arithmetic slice.\\n\\n9. After iterating through the entire list, we return the count variable, which represents the total number of arithmetic slices in the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        count = 0 # Initialize a counter for the number of arithmetic slices\\n        curr = 0 # Initialize a variable for the current length of the arithmetic slice\\n        \\n        for i in range(2, len(nums)):\\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\\n                curr += 1 # Increase the current length of the arithmetic slice\\n                count += curr # Add the current length to the total count of arithmetic slices\\n            else:\\n                curr = 0 # Reset the current length to 0 if the slice is not arithmetic\\n        \\n        return count # Return the total count of arithmetic slices\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        count = 0 # Initialize a counter for the number of arithmetic slices\\n        curr = 0 # Initialize a variable for the current length of the arithmetic slice\\n        \\n        for i in range(2, len(nums)):\\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\\n                curr += 1 # Increase the current length of the arithmetic slice\\n                count += curr # Add the current length to the total count of arithmetic slices\\n            else:\\n                curr = 0 # Reset the current length to 0 if the slice is not arithmetic\\n        \\n        return count # Return the total count of arithmetic slices\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124148,
                "title": "easy-solution-in-c-beats-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo know whether a subarray is arithmatic in nature,firstly we have to conclude that we have to compute the difference between consecutive elements and then analysize these differences.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic approach for this problem is to compute the difference between the consecutive elements in vector.Then after that we will observe the number of times the difference is repeating consecutively.\\nFor example our difference vector be 2,2,2,3,3,1 then from this will make an count vector which will store the count of consecutive differnces.For above example, 2 repeats 3 times then 3 repeats 2 times and the 1 is single. So our count vector will be like {3,2,1}.\\n\\nWith the help of count vector we can easily analyse that how many elements in original vector are in arithmatic sequence.\\n\\nAfter that we can mathematically find the number of subarray,which is equal to total subarrays of all sizes(i.e n(n+1)/2)-(number of subarrays of size 1)-(number of subarrays of size 2);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity will be O(n),n is nums size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity will be O(n),n is nums size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint numberOfArithmeticSlices(vector<int>& nums) {\\n    \\n    int n=nums.size();\\n     if(n<3) return 0;\\n    vector<int> ans;\\n    vector<int> count;\\n    for(int i=0;i<n-1;i++){\\n        ans.push_back((nums[i+1]-nums[i]));\\n    }\\n    int ct=1;\\n    for(int i=1;i<n-1;i++){\\n        if(ans[i]==ans[i-1]) ct++;\\n        else {count.push_back(ct);\\n        ct=1;\\n        }\\n    }\\n    count.push_back(ct);\\n    int sum=0;\\n    for(int i=0;i<count.size();i++){\\n       int k=count[i]+1;\\n       sum+=(k*k-3*k+2)/2;\\n    }\\n    return sum; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint numberOfArithmeticSlices(vector<int>& nums) {\\n    \\n    int n=nums.size();\\n     if(n<3) return 0;\\n    vector<int> ans;\\n    vector<int> count;\\n    for(int i=0;i<n-1;i++){\\n        ans.push_back((nums[i+1]-nums[i]));\\n    }\\n    int ct=1;\\n    for(int i=1;i<n-1;i++){\\n        if(ans[i]==ans[i-1]) ct++;\\n        else {count.push_back(ct);\\n        ct=1;\\n        }\\n    }\\n    count.push_back(ct);\\n    int sum=0;\\n    for(int i=0;i<count.size();i++){\\n       int k=count[i]+1;\\n       sum+=(k*k-3*k+2)/2;\\n    }\\n    return sum; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069503,
                "title": "c-solution-using-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ln= nums.size();\\n        if(ln<3)return 0;\\n        \\n        vector<int> diff;\\n        \\n        for(int i=1;i<ln;i++){\\n            diff.push_back(nums[i]-nums[i-1]);\\n        }\\n        \\n        ln--;\\n        int i=0,j=0;\\n        \\n        while(j<ln){\\n            while(j<ln && diff[j]==diff[i]){\\n                if(j!= i)ans+= (j-i);\\n                j++;\\n            }\\n            i=j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ln= nums.size();\\n        if(ln<3)return 0;\\n        \\n        vector<int> diff;\\n        \\n        for(int i=1;i<ln;i++){\\n            diff.push_back(nums[i]-nums[i-1]);\\n        }\\n        \\n        ln--;\\n        int i=0,j=0;\\n        \\n        while(j<ln){\\n            while(j<ln && diff[j]==diff[i]){\\n                if(j!= i)ans+= (j-i);\\n                j++;\\n            }\\n            i=j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049116,
                "title": "c-0ms-beats-100-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore all consecutive differences in vector \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first store all consecutive differences in vector and then \\ncaculate number of equal consecutive differences\\ni.e.\\nif while traversing in this Differences array we have 2 consecitve 1\\'s(or any other digit)\\nnum=2, no. of slices = 1\\nif while traversing we have 3 consecitve 1\\'s\\nnum=3, no. of slices = 3\\n similarly \\nnum=4, no. of slices = 6\\nnum=5, no. of slices = 10\\nnum=6, no. of slices = 15\\n\\nObservation : We have an increasing difference among these answers as 2,3,4,5 etc.\\n\\n\\n \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3) return 0;\\n        \\n        int finalAns=0;\\n        int n=nums.size();\\n        vector<int> helper;\\n        for(int i=1;i<nums.size();i++){\\n            int diff=nums[i]-nums[i-1];\\n            helper.push_back(diff);\\n        }\\n\\n        for(int i=0;i<n-1;i++){\\n            int j=i+1;\\n            while(j<n-1 && helper[i]==helper[j]) j++;\\n        \\n            int num=j-i;\\n            i=j-1; // moving the loop counter ahead of equal elements\\n            if(num==1) continue;\\n\\n            int ans=1;\\n            int value=2;\\n            for(int k=2;k<num;k++){\\n                ans+=value;\\n                value++;\\n            }\\n            finalAns+=ans;\\n        }\\n        return finalAns;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3) return 0;\\n        \\n        int finalAns=0;\\n        int n=nums.size();\\n        vector<int> helper;\\n        for(int i=1;i<nums.size();i++){\\n            int diff=nums[i]-nums[i-1];\\n            helper.push_back(diff);\\n        }\\n\\n        for(int i=0;i<n-1;i++){\\n            int j=i+1;\\n            while(j<n-1 && helper[i]==helper[j]) j++;\\n        \\n            int num=j-i;\\n            i=j-1; // moving the loop counter ahead of equal elements\\n            if(num==1) continue;\\n\\n            int ans=1;\\n            int value=2;\\n            for(int k=2;k<num;k++){\\n                ans+=value;\\n                value++;\\n            }\\n            finalAns+=ans;\\n        }\\n        return finalAns;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871076,
                "title": "continuing-the-ultimate-dynamic-programming-i-study-guide-another-dp-perspective-for-repetition",
                "content": "If you\\'re on the [Ultimate Dynamic Programming I Study Guide](https://leetcode.com/study-plan/dynamic-programming/), then **keep going**! Here is another explanation to, perhaps, help you remember. If you\\'re feeling like, \"bruh... but I still don\\'t get it\", then continue reading. I will try my best not to make this post monotonous.  \\n\\n# Intuition\\n\\nThis is a cool problem. We want to create an algorithm that examines the differences between consecutive numbers in our array/list input. All we have to do is see, at some point, if any three numbers, *which are next to eachother, have the same difference inbetween. Numbers 1, 3, 5 all have a difference of 2 inbetween. To get to 3 from 1, we add 2. To get to 5 from 3 we add 2. **So the intuition here is for us to first track the differences.**\\n\\nIf we have an array of differences, then maybe we could compare numbers and see if we have an \"arithmetic sequence\". For example:\\n\\n[1, 3, 5, 6, 7, 8]\\n\\nwould give us \\n\\n[2, 2, 1, 1, 1] -> **Our array of differences!**\\n\\nHow did we get that? Well, look at the first array of [1, 3, 5, 6, 7, 8]. If we start at 3 and subtract the number at the previous index, then we get 2. Similarly, if we look at 5 and subtract 3, we get 2 again, hence: [2, 2, 1, 1, 1]. Two numbers that are the same **and** next to eachother is a sequence.\\n\\n#### The Less Intuitive Part *\\n\\nAt this point we have our array of differences. This is where we **need**, as my College Algorithms Professor always said, **\"\\u2728some creativity\\uD83C\\uDF08........\"**. \\n\\nWhat we need here is some kind of formula that gets us to the right answer.\\n\\nLet\\'s think about some basic cases **in order to find a pattern**:\\n\\n1. [123] -> Obviously, we have just 1 seqeunce.\\n2. [1234] -> 3 sequences (our sequence of adding 1 continues)\\n3. [12345] -> 6 sequences \\n4. [123456] -> Now we have 10 \\n\\n123, 234, 345, 456, 1234, 2345, 3456, 12345, 23456, 123456 => 10 sequences\\n\\nOkay cool, but is there a pattern? The answer is **yes**. The first example gives us 1 for **one** 3-number sequence. The second example is increased by 2  or 1 * 2, giving us 3. The third example is increased by 3 or 1 * 3. The fourth example is increased by 4 or 1 * 4. \\n\\n#### The Pattern\\n\\nCan **you** see the pattern? If we just have **one** 3-number sequence, we can add 1 to some variable indicating that one sequence was found. If the pattern continues, then the sequence has extended to 4 numbers, giving us a 4-number sequence and the pattern continues for **two** times. \\n\\nRecall [123] -> 1 sequence. At this point we previously had 0 sequences (what we should have initialized our \"answer\" variable to). All we did here was add 0 to 1 * 1. \\n\\nRecall [1234] -> 3 sequences. To get to 3 we can add 1 from our first sequence to 1 * 2 to get **1 + 1 * 2** (because the sequence continues for a *second* time) which is 3. The **2** here represents our multiplier for a continued sequence. \\n\\nSo our **recurrence relation** ends up becoming \"the previous answer **plus** 1 **multiplied by** ***our multiplier***\". \\n\\n#### The Caveat\\n\\nSo if you\\'re following, we need to keep track of this multiplier. What is it initialized to? How do we know if there is a continued-sequence?\\n\\nGood questions.\\n\\nLet\\'s go back to my original example: [1, 3, 5, 6, 7, 8]\\n\\nThe differences are [2, 2, 1, 1, 1]. At the point that 2 changed to 1 in this array, our sequence of 2\\'s were broken. (Remember, two numbers here represents the difference of *three* numbers in the original array because we\\'re looking at the in-betweens \\uD83D\\uDE05 - which is why it will be less than our original array in length).\\n\\nSo, our algorithm needs a way to tell if the sequence was broken. Well, we know that the sequence was broken when the current number does not equal the last number. At that point, we can set our multiplier to 0, which will give us 1 * 0 in our equation, which means we don\\'t add another sequence (we add 0 sequences - which is what we want). Now try re-coding it!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\nWe can make improvements: constant space? one loop?\\n\\nPlease leave a comment of your code if you make any improvements! **Thanks for reading**~!\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfArithmeticSlices = function(nums) {\\n    if (nums.length < 3) return 0\\n  \\n    const diff = []\\n    \\n    /* fill our array of differences */\\n    for (let i = 1; i < nums.length; i++) {\\n      diff.push(nums[i] - nums[i - 1])\\n    }\\n\\n    /* if the first two numbers of our difference array are equal\\n     * then set our multiplier to 1\\n     * and also set our \"previous\" variable to 1\\n     * otherwise set both to 0 representing no sequence found yet\\n     */\\n \\n    let multiplier = diff[1] === diff[0] ? 1 : 0\\n    let dp = diff[1] === diff[0] ? 1 : 0 // our \"previous\" variable\\n  \\n    /* loop thru our differences from idx 2 (0 and 1 have been     \\n     * accounted for),\\n     * and check for continuing sequences\\n     */\\n    for (let i = 2; i < diff.length; i++) {\\n      if (diff[i] === diff[i - 1]) { // if equal, increment our multiplier\\n        multiplier++\\n      } else { // if not equal, set our multiplier back to 0\\n        multiplier = 0\\n      }\\n      \\n      dp = dp + 1 * multiplier // recurrence relation\\n    }\\n\\n    return dp // our \"previous\" variable\\n\\n}\\n```\\n\\nP.S.\\n\\nIf you found this post helpful, please up-vote so others can see it. Thank you \\uD83D\\uDE42\\uD83D\\uDE4F",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfArithmeticSlices = function(nums) {\\n    if (nums.length < 3) return 0\\n  \\n    const diff = []\\n    \\n    /* fill our array of differences */\\n    for (let i = 1; i < nums.length; i++) {\\n      diff.push(nums[i] - nums[i - 1])\\n    }\\n\\n    /* if the first two numbers of our difference array are equal\\n     * then set our multiplier to 1\\n     * and also set our \"previous\" variable to 1\\n     * otherwise set both to 0 representing no sequence found yet\\n     */\\n \\n    let multiplier = diff[1] === diff[0] ? 1 : 0\\n    let dp = diff[1] === diff[0] ? 1 : 0 // our \"previous\" variable\\n  \\n    /* loop thru our differences from idx 2 (0 and 1 have been     \\n     * accounted for),\\n     * and check for continuing sequences\\n     */\\n    for (let i = 2; i < diff.length; i++) {\\n      if (diff[i] === diff[i - 1]) { // if equal, increment our multiplier\\n        multiplier++\\n      } else { // if not equal, set our multiplier back to 0\\n        multiplier = 0\\n      }\\n      \\n      dp = dp + 1 * multiplier // recurrence relation\\n    }\\n\\n    return dp // our \"previous\" variable\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854399,
                "title": "java-dynamic-programming-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) return 0;\\n\\n        int[] dp = new int[n];\\n        int ans = 0;\\n\\n        for (int i = 2; i < n; i++) {\\n            if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) {\\n                dp[i] = dp[i - 1] + 1;\\n                ans += dp[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: (n)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) return 0;\\n\\n        int[] dp = new int[n];\\n        int ans = 0;\\n\\n        for (int i = 2; i < n; i++) {\\n            if ((nums[i] - nums[i - 1]) == (nums[i - 1] - nums[i - 2])) {\\n                dp[i] = dp[i - 1] + 1;\\n                ans += dp[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: (n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854200,
                "title": "413-arithmetic-slices",
                "content": "**Arithmetic Slices**\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n= nums.size();      //Size of nums\\n        int ans=0;              //initialising answer as 0 which will count the total no. of Arithmetic subarrays\\n        vector<int>temp(n,0);  //temp array for counting the number of arithmetic subarray \\n        \\n        //looping from 3rd element and checking if the common difference between 3rd and 2nd element is equal to 2nd and 1st element if yes then it\\'s a Arithemetic subarray.\\n\\t\\t\\n        for(int i=2;i<n;i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n                temp[i]= temp[i-1]+1; \\n                ans += temp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n= nums.size();      //Size of nums\\n        int ans=0;              //initialising answer as 0 which will count the total no. of Arithmetic subarrays\\n        vector<int>temp(n,0);  //temp array for counting the number of arithmetic subarray \\n        \\n        //looping from 3rd element and checking if the common difference between 3rd and 2nd element is equal to 2nd and 1st element if yes then it\\'s a Arithemetic subarray.\\n\\t\\t\\n        for(int i=2;i<n;i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n                temp[i]= temp[i-1]+1; \\n                ans += temp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794271,
                "title": "java-explanation-100-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first idea that can visit the head is a classic DP solution:\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int result = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n                dp[i] = dp[i - 1] + 1;\\n                result += dp[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nWhere time complexity is $$O(n)$$ and space complexity is $$O(n)$$\\n\\n# But!\\n<!-- Describe your approach to solving the problem. -->\\nWe can store the entire **dp** array in the **nums** array and it will look like this:\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums.length < 3) {\\n            return 0;\\n        }\\n        int result = 0;\\n\\n        int diff = nums[1] - nums[0];\\n        nums[0] = 0;\\n        for (int i = 2; i < nums.length; i++) {\\n            int temp = nums[i] - nums[i - 1];\\n            if (temp == diff) {\\n                nums[i-1] = nums[i-2] + 1;\\n                result += nums[i-1];\\n            } else {\\n                nums[i-1] = 0;\\n                diff = temp;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nWhere time complexity is $$O(n)$$ and space complexity is $$O(1)$$. Much better, but... looks ugly. \\nHere we need to ask the question, do we need to store the entire DP array at all? Nope!\\n# Code\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int result = 0;\\n        int counter = 0;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i - 1] - nums[i - 2] == nums[i] - nums[i - 1]) {\\n                counter++;\\n                result += counter;\\n            } else {\\n                counter = 0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nOr using the ternary operator:\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int result = 0;\\n        int counter = 0;\\n        for (int i = 2; i < nums.length; i++) {\\n            counter = nums[i - 1] - nums[i - 2] == nums[i] - nums[i - 1]? counter + 1: 0;\\n            result += counter;\\n        }\\n        return result;\\n    }\\n}\\n```\\nThe complexity of time and space is still O(n) and O(1), respectively.\\n# Perfect \\uD83D\\uDE0E",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int result = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n                dp[i] = dp[i - 1] + 1;\\n                result += dp[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums.length < 3) {\\n            return 0;\\n        }\\n        int result = 0;\\n\\n        int diff = nums[1] - nums[0];\\n        nums[0] = 0;\\n        for (int i = 2; i < nums.length; i++) {\\n            int temp = nums[i] - nums[i - 1];\\n            if (temp == diff) {\\n                nums[i-1] = nums[i-2] + 1;\\n                result += nums[i-1];\\n            } else {\\n                nums[i-1] = 0;\\n                diff = temp;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int result = 0;\\n        int counter = 0;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i - 1] - nums[i - 2] == nums[i] - nums[i - 1]) {\\n                counter++;\\n                result += counter;\\n            } else {\\n                counter = 0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int result = 0;\\n        int counter = 0;\\n        for (int i = 2; i < nums.length; i++) {\\n            counter = nums[i - 1] - nums[i - 2] == nums[i] - nums[i - 1]? counter + 1: 0;\\n            result += counter;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683488,
                "title": "python-dp-solution-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n\\t\\t#n is the number of times same differences occur between values\\n        #ans += n if diffs between nums[i] and num[i - 1] are the same a second time\\n        ans = n = 0\\n        if len(nums) > 2:\\n            prevDiff = nums[1] - nums[0]\\n            for i in range(2, len(nums)):\\n                curDiff = nums[i] - nums[i - 1]\\n                if curDiff == prevDiff:\\n                    n += 1\\n                    ans += n\\n                else:\\n                    n = 0\\n                prevDiff = curDiff\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n\\t\\t#n is the number of times same differences occur between values\\n        #ans += n if diffs between nums[i] and num[i - 1] are the same a second time\\n        ans = n = 0\\n        if len(nums) > 2:\\n            prevDiff = nums[1] - nums[0]\\n            for i in range(2, len(nums)):\\n                curDiff = nums[i] - nums[i - 1]\\n                if curDiff == prevDiff:\\n                    n += 1\\n                    ans += n\\n                else:\\n                    n = 0\\n                prevDiff = curDiff\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538598,
                "title": "javascript-dp-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfArithmeticSlices = function(nums) {\\n    const length = nums.length;\\n    let result = 0;\\n\\n    counting: for (let start = 0; start < length - 2; start++) {\\n        let numberOfConsElements = 1;\\n        let difference = null;\\n\\n        for (let j = start + 1; j < length; j++) {\\n            const currentDifference = nums[j] - nums[j - 1];\\n\\n            if (difference === null) {\\n                difference = currentDifference;\\n            } else if (difference !== currentDifference) {\\n                continue counting;\\n            }\\n            \\n            if (++numberOfConsElements >= 3) {\\n                result++;\\n            }\\n        }\\n    }  \\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfArithmeticSlices = function(nums) {\\n    const length = nums.length;\\n    let result = 0;\\n\\n    counting: for (let start = 0; start < length - 2; start++) {\\n        let numberOfConsElements = 1;\\n        let difference = null;\\n\\n        for (let j = start + 1; j < length; j++) {\\n            const currentDifference = nums[j] - nums[j - 1];\\n\\n            if (difference === null) {\\n                difference = currentDifference;\\n            } else if (difference !== currentDifference) {\\n                continue counting;\\n            }\\n            \\n            if (++numberOfConsElements >= 3) {\\n                result++;\\n            }\\n        }\\n    }  \\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2311912,
                "title": "python-easy-keep-track-of-last-difference-and-count-only-32-faster-though",
                "content": "```\\n/*\\n    approach:\\n    create a array that stores the difference of consecutive elements\\n    iterate over above array and count the number of values for which the difference is same\\n    example: given array = [1, 3, 5, 7, 8, 9, 10]\\n             difference  = [-1, 2, 2, 2, 1, 1, 1]\\n             keep count until the differece is same,\\n             difference of 2 is occuring 3 times, hence subarrays = 3\\n             difference of 1 is occuring 3 times, hence subarrays = 3\\n             ans = 3 + 3 = 6\\n */\\n```\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return 0\\n        last_diff = nums[1] - nums[0]\\n        count = 1\\n        ans = 0\\n        for i in range(2, len(nums)):\\n            if nums[i] - nums[i-1] == last_diff:\\n                count+=1\\n            else:\\n                ans+= count * (count-1) / 2\\n                last_diff = nums[i] - nums[i-1]\\n                count = 1\\n        return int(ans + count * (count-1)/2)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n    approach:\\n    create a array that stores the difference of consecutive elements\\n    iterate over above array and count the number of values for which the difference is same\\n    example: given array = [1, 3, 5, 7, 8, 9, 10]\\n             difference  = [-1, 2, 2, 2, 1, 1, 1]\\n             keep count until the differece is same,\\n             difference of 2 is occuring 3 times, hence subarrays = 3\\n             difference of 1 is occuring 3 times, hence subarrays = 3\\n             ans = 3 + 3 = 6\\n */\\n```\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return 0\\n        last_diff = nums[1] - nums[0]\\n        count = 1\\n        ans = 0\\n        for i in range(2, len(nums)):\\n            if nums[i] - nums[i-1] == last_diff:\\n                count+=1\\n            else:\\n                ans+= count * (count-1) / 2\\n                last_diff = nums[i] - nums[i-1]\\n                count = 1\\n        return int(ans + count * (count-1)/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287986,
                "title": "my-java-solution",
                "content": "```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n        if (nums.length < 3) return 0;\\n\\n        int difference = nums[1]-nums[0], tmp, consecutiveCount = 0, result = 0;\\n        for (int index = 1; index < nums.length - 1; index++) {\\n            tmp = nums[index+1] - nums[index];\\n            if (tmp != difference) {\\n                difference = tmp;\\n                consecutiveCount = 0;\\n            } else {\\n                consecutiveCount++;\\n                result += consecutiveCount;\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n        if (nums.length < 3) return 0;\\n\\n        int difference = nums[1]-nums[0], tmp, consecutiveCount = 0, result = 0;\\n        for (int index = 1; index < nums.length - 1; index++) {\\n            tmp = nums[index+1] - nums[index];\\n            if (tmp != difference) {\\n                difference = tmp;\\n                consecutiveCount = 0;\\n            } else {\\n                consecutiveCount++;\\n                result += consecutiveCount;\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2234274,
                "title": "java-in-depth-explanation-easy-to-implement",
                "content": "I provide two solutions here, **Brute Force** and **DP**. I think brute force is pretty much straightforward so we can come up w/ brute force solution during the interview first.\\n  \\n  **Intuition**\\n  We simply try all the combination within a nested for-loop.\\n  \\n  ```\\n  class Solution \\n{\\n    public int numberOfArithmeticSlices(int[] nums)\\n    {\\n        // O(n^2) time | O(1) space\\n        if(nums == null || nums.length <= 2)    return 0;\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i < nums.length-2; i++)\\n        {\\n            int diff = nums[i+1] - nums[i];\\n            \\n            for(int j = i+2; j < nums.length; j++)\\n            {\\n                if(nums[j] - nums[j-1] == diff)\\n                    res += 1;\\n                else\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Intuition**\\nFor DP, we need to use an equation `dp[i] = dp[i-1] + 1`. Let\\'s see the example below if `nums[ ] = [1, 2, 3, 4, 5]`\\n\\n```\\n[1, 2, 3]       --> [1, 2, 3] --> 1 combination.\\n[1, 2, 3, 4]    --> [2, 3, 4] and [1, 2, 3, 4] --> 2 more combinations\\n[1, 2, 3, 4, 5] --> [3, 4, 5], [2, 3, 4, 5], and [1, 2, 3, 4, 5] --> 3 more combinations.\\n```\\nTherefor, `sum += dp[i]` gives us all the possible combinations.\\n\\n```\\nclass Solution \\n{\\n    public int numberOfArithmeticSlices(int[] nums)\\n    {\\n        // O(n) time | O(n) space\\n        if(nums == null || nums.length <= 2)    return 0;\\n        \\n        // dp[i] represents to how many arithmetic sequences during the range [0,i]\\n        int[] dp = new int[nums.length];\\n        int res = 0;\\n        \\n        for(int i = 2; i < nums.length; i++)\\n        {\\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2])\\n                dp[i] = dp[i-1] + 1;\\n            \\n            res += dp[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  class Solution \\n{\\n    public int numberOfArithmeticSlices(int[] nums)\\n    {\\n        // O(n^2) time | O(1) space\\n        if(nums == null || nums.length <= 2)    return 0;\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i < nums.length-2; i++)\\n        {\\n            int diff = nums[i+1] - nums[i];\\n            \\n            for(int j = i+2; j < nums.length; j++)\\n            {\\n                if(nums[j] - nums[j-1] == diff)\\n                    res += 1;\\n                else\\n                    break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n[1, 2, 3]       --> [1, 2, 3] --> 1 combination.\\n[1, 2, 3, 4]    --> [2, 3, 4] and [1, 2, 3, 4] --> 2 more combinations\\n[1, 2, 3, 4, 5] --> [3, 4, 5], [2, 3, 4, 5], and [1, 2, 3, 4, 5] --> 3 more combinations.\\n```\n```\\nclass Solution \\n{\\n    public int numberOfArithmeticSlices(int[] nums)\\n    {\\n        // O(n) time | O(n) space\\n        if(nums == null || nums.length <= 2)    return 0;\\n        \\n        // dp[i] represents to how many arithmetic sequences during the range [0,i]\\n        int[] dp = new int[nums.length];\\n        int res = 0;\\n        \\n        for(int i = 2; i < nums.length; i++)\\n        {\\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2])\\n                dp[i] = dp[i-1] + 1;\\n            \\n            res += dp[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994462,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        map<int, int> mp;\\n        if(A.size()<3)\\n        {\\n            return 0;\\n        }\\n        int length=2;\\n        for(int i = 0 ; i < A.size()-2 ; i++)\\n        {\\n            if(A[i+1] - A[i] == A[i+2] - A[i+1])\\n            {\\n                length++;\\n            }\\n            else\\n            {\\n                mp[length]++;\\n                length = 2;\\n            }\\n        }\\n        if(length >2)\\n        {\\n            mp[length]++;\\n        }\\n        //map<int, int>::iterator it;\\n        int ans=0;\\n        for (auto it = mp.begin(); it != mp.end(); it++)\\n        {\\n            if(it->first >=3 )\\n            {\\n                int sum = 0;\\n                for(int i=1;i<=it->first-2;i++)\\n                {\\n                    sum+=i;\\n                }\\n                sum=sum*it->second;\\n                ans+=sum;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        map<int, int> mp;\\n        if(A.size()<3)\\n        {\\n            return 0;\\n        }\\n        int length=2;\\n        for(int i = 0 ; i < A.size()-2 ; i++)\\n        {\\n            if(A[i+1] - A[i] == A[i+2] - A[i+1])\\n            {\\n                length++;\\n            }\\n            else\\n            {\\n                mp[length]++;\\n                length = 2;\\n            }\\n        }\\n        if(length >2)\\n        {\\n            mp[length]++;\\n        }\\n        //map<int, int>::iterator it;\\n        int ans=0;\\n        for (auto it = mp.begin(); it != mp.end(); it++)\\n        {\\n            if(it->first >=3 )\\n            {\\n                int sum = 0;\\n                for(int i=1;i<=it->first-2;i++)\\n                {\\n                    sum+=i;\\n                }\\n                sum=sum*it->second;\\n                ans+=sum;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913559,
                "title": "c-dynamic-programming-solution",
                "content": "Solution -->\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,0);\\n        dp[0]=0;\\n        dp[1]=0;\\n        int ans=0;\\n        for(int i=2;i<nums.size();i++){\\n            int a=nums[i]-nums[i-1];\\n            int b=nums[i-1]-nums[i-2];\\n            if(a==b){\\n                dp[i]=1+dp[i-1];\\n                ans+=dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,0);\\n        dp[0]=0;\\n        dp[1]=0;\\n        int ans=0;\\n        for(int i=2;i<nums.size();i++){\\n            int a=nums[i]-nums[i-1];\\n            int b=nums[i-1]-nums[i-2];\\n            if(a==b){\\n                dp[i]=1+dp[i-1];\\n                ans+=dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898414,
                "title": "python-runtime-o-n-space-o-1-98-73-faster",
                "content": "```\\ndef numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        ans = 0\\n        if len(nums)<3:\\n            return 0\\n        d = nums[1] - nums[0]\\n        l = 0\\n        for i in range(2,len(nums)):\\n            if (nums[i] - nums[i-1]) == d:\\n                l +=1\\n                ans += l\\n            else:\\n                d = (nums[i] - nums[i-1])\\n                l = 0\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/82f1a0a2-61c2-43c1-a1ac-147a3dbcdec7_1648663319.136757.png)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        ans = 0\\n        if len(nums)<3:\\n            return 0\\n        d = nums[1] - nums[0]\\n        l = 0\\n        for i in range(2,len(nums)):\\n            if (nums[i] - nums[i-1]) == d:\\n                l +=1\\n                ans += l\\n            else:\\n                d = (nums[i] - nums[i-1])\\n                l = 0\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1872230,
                "title": "java-sliding-window-clean",
                "content": "At every r, we count how many valid slice that would end there\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int ans = 0;\\n        for (int l = 0, r = 2; r < nums.length; r++) {\\n            if (nums[r] - nums[r-1] != nums[r-1] - nums[r-2]) l = r - 1;\\n            else ans += r - l -1; // (r - l + 1) - (3) + 1\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int ans = 0;\\n        for (int l = 0, r = 2; r < nums.length; r++) {\\n            if (nums[r] - nums[r-1] != nums[r-1] - nums[r-2]) l = r - 1;\\n            else ans += r - l -1; // (r - l + 1) - (3) + 1\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864514,
                "title": "java-0ms-bottom-up-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length, res = 0;\\n        int[] dp = new int[n];\\n        for(int i=2;i<n;i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length, res = 0;\\n        int[] dp = new int[n];\\n        for(int i=2;i<n;i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822735,
                "title": "easy-c-unique-o-n-solution-one-simple-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==2)\\n            return 0;\\n     int i=0,j=1;\\n        int ans=0;\\n        int cd=nums[j]-nums[i];\\n        j++;\\n        while(j<nums.size())\\n        {if(j-i+1>=3&&nums[j]-nums[j-1]==cd)\\n            ans+=j-i-1;\\n         else if(cd!=nums[j]-nums[j-1])\\n         {i=j-1;cd=nums[j]-nums[j-1];}\\n         j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n##### Meaning of j-i-1:\\nNo of Subarray from index i to index j=sum(j-i+1) {increasing j from 0};\\nfor ex: [1,2,3,4]\\nno of subarray formed when i=0 and j=0 : j-i+1=1 ,i.e -[1] \\nwhen i=0 and j=1 : j-i+1=2 ,i.e -[1,2]& [2]\\nsimilarly i=0 and j=2 will give j-i+1=3 i.e-[1,2,3],[2,3],[3]\\nso no. subarray from i=0 to j=2  is (1+2+3)=6. i.e- [1]  [1,2]  [2]  [1,2,3]  [2,3]  [3].\\n\\nNow we need to find subarray whose length is greater than equals to 3\\nso we need to remove subarray of size 2 and 3.\\nfrom above example we can see ,there only occurs one subarray of size 1 and one of size 2.\\nso no. subarray whose length is greater than equals to 3 : (j-i+1)-2=(j-i-1).\\n \\n***DO UPVOTE IF U LIKE IT***\\n***Thanks*** ;)",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()==1||nums.size()==2)\\n            return 0;\\n     int i=0,j=1;\\n        int ans=0;\\n        int cd=nums[j]-nums[i];\\n        j++;\\n        while(j<nums.size())\\n        {if(j-i+1>=3&&nums[j]-nums[j-1]==cd)\\n            ans+=j-i-1;\\n         else if(cd!=nums[j]-nums[j-1])\\n         {i=j-1;cd=nums[j]-nums[j-1];}\\n         j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817579,
                "title": "python-dp-using-2-variables-with-clean-comments-o-n-o-1",
                "content": "```\\n# approach is to compare left and right difference and if they match update the result\\n# store the previous diff for reference and update the answer\\n\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums)<3:\\n            return 0\\n        ans,cnt = 0,1\\n        left_diff,right_diff = nums[1]-nums[0],None\\n        prev = None\\n        # run the iteration from index 1 to last index - 1\\n        \\n        for i in range(1,len(nums)-1):\\n            right_diff = nums[i+1]-nums[i]\\n    \\n            # [1,3,5] ans = 1,   [1,3,5,7] ans = 3, [1,3,5,7,9] ans = 6, [1,3,5,7,9,11] ans = 10\\n            # if we observe the answer keeps increasing like 1, 3, 6, 10\\n            # prev_answer+1, prev_answer+2, prev_answer+3,prev_answer+4\\n            if left_diff == right_diff:\\n                cnt = 1 + (cnt if prev is not None and prev==right_diff else 0)\\n                ans+=cnt\\n            prev = left_diff\\n            left_diff = right_diff\\n            \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n# approach is to compare left and right difference and if they match update the result\\n# store the previous diff for reference and update the answer\\n\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums)<3:\\n            return 0\\n        ans,cnt = 0,1\\n        left_diff,right_diff = nums[1]-nums[0],None\\n        prev = None\\n        # run the iteration from index 1 to last index - 1\\n        \\n        for i in range(1,len(nums)-1):\\n            right_diff = nums[i+1]-nums[i]\\n    \\n            # [1,3,5] ans = 1,   [1,3,5,7] ans = 3, [1,3,5,7,9] ans = 6, [1,3,5,7,9,11] ans = 10\\n            # if we observe the answer keeps increasing like 1, 3, 6, 10\\n            # prev_answer+1, prev_answer+2, prev_answer+3,prev_answer+4\\n            if left_diff == right_diff:\\n                cnt = 1 + (cnt if prev is not None and prev==right_diff else 0)\\n                ans+=cnt\\n            prev = left_diff\\n            left_diff = right_diff\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817204,
                "title": "c-solution-without-using-dp",
                "content": "```\\n\\n```class Solution {\\npublic:\\n  int ans=0;\\n  void fun(int x){\\n    int xx=0;\\n    for(int i=x;i>0;i--){\\n      xx+=i;\\n    }\\n     ans+=xx;\\n  }\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n\\t//step 1\\n        vector<int> a1;   // take a vector to store difference between a[i] and a[i-1]\\n      if(nums.size()==1) return 0;\\n      for(int i=1;i<nums.size();i++){\\n        a1.push_back(nums[i]-nums[i-1]);\\n      }\\n\\t  //step 2\\n\\t  \\n      vector<int> mp;  \\n      int cont=0;\\n      for(int i=0;i<a1.size()-1;i++){\\n        if(a1[i]==a1[i+1]){\\n          cont++;\\n        }\\n        else{\\n          mp.push_back(cont+1);  // push the count of number which are forming same difference and forming subsequence\\n          cont=0;\\n        }\\n      }\\n      mp.push_back(cont+1);\\n\\t  / *for example let assume a[]=\\n{3,6,9,12,15} \\nSo vector mp will store value as 4 \\nas  vector contain {3,3,3,3}\\n   3 from (6-3)\\n   3 from (9-6)\\n   3 from (12-9)\\n   3 from (15-12)  * /\\n   //Step 3\\n   / *\\n   now to count number of all the subsequence formed by subsequence having  same difference .\\n   let first understand with example\\n   3,6,9,12,15\\n   number of subsequence formed by 3 will be {[3,6,9,12,15],[3,6,9,12],[3,6,9]}\\n    number of subsequence formed by 6 will be {[6,9,12,15],[6,9,12]}\\n\\t number of subsequence formed by 9 will be {9,12,15]}\\n\\t as starting from 12 and 15 there will be no subsequence..\\n\\t So from above observation\\n\\t **(length of whole subsequence having same difference -3 +1)**\\n\\t here 3 is  subracted because min subsequence will be of length 3\\n\\t and plus 1 because we have also to  count subsequence whose length 3\\n\\t * /\\n      for(auto i:mp){\\n         int x=(i+1)-3+1;\\n         if(x>0) fun(x);\\n      }\\n      return ans;\\n    }\\n};\\n//If you understood and like the solution upvote it \\uD83D\\uDE0A.",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1817083,
                "title": "arithmatic-slices",
                "content": "class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n            return 0;\\n        }\\n        int prev=nums[0];\\n        int cur=nums[1];\\n        int dif=cur-prev;\\n        prev=cur;\\n        int ans=0;\\n        int count=2;\\n        for(int i=2;i<nums.size();i++){\\n\\t\\t\\n            cur=nums[i];\\n                   if(cur-prev==dif){\\n                       **   count++;**\\n                     }else{\\n                              if(count>=3){\\n                                   **ans=ans+((count-2)*(count-1))/2;**\\n                                   }\\n             \\n                       dif=cur-prev;\\n                      * count=2;*\\n                 }\\n\\t\\t\\t\\t \\n           ** prev=cur;**\\n            \\n        }\\n        if(count>=3){\\n            ans=ans+((count-2)*(count-1))/2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1816804,
                "title": "c-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n            return 0;\\n        }\\n        int ans=0;\\n        int count=1;\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                count++;\\n            }\\n            else{\\n                ans=ans+(count-1)*count/2;\\n                count=1;\\n            }\\n        }\\n        ans=ans+(count-1)*count/2;\\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nplz upvote if you understand\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n            return 0;\\n        }\\n        int ans=0;\\n        int count=1;\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                count++;\\n            }\\n            else{\\n                ans=ans+(count-1)*count/2;\\n                count=1;\\n            }\\n        }\\n        ans=ans+(count-1)*count/2;\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816419,
                "title": "100-fastest-c",
                "content": "If the array size is less than 3, it\\u2019s obvious that our answer is 0. Now starting from the 2nd index we can keep a counter to check the length (l) till  nums[i]-nums[i-1]==nums[i-1]-nums[i-2] is maintained. Whenever this condition is violated, we reset the counter to zero and add the no. of subarrays to our answer which would be  l*(l+1)/2.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans=0, l=0; \\n        \\n        for(int i=2;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])\\n                l++;                  \\n            else\\n            {\\n                ans+=l*(l+1)/2;\\n                l=0;\\n            }\\n        }\\n        if(l)\\n        ans+=l*(l+1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans=0, l=0; \\n        \\n        for(int i=2;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])\\n                l++;                  \\n            else\\n            {\\n                ans+=l*(l+1)/2;\\n                l=0;\\n            }\\n        }\\n        if(l)\\n        ans+=l*(l+1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816260,
                "title": "python-thought-process-from-o-n-2-to-o-n",
                "content": "The naive approach is to simply compute every possible consecutive subarray starting from every single element in the array, incrementing the ans everytime the subarray is extended.\\n\\nIt is then obvious that once the current element we encounter causes the current subarray to be invalid, we could just skip the entire group of elements in between the starting index and the current element, as any subarray which starts from these elements are also invalid. \\n\\nFor a valid subarray of length x, there are x*(x+1)/2 (Basic formula for 1+2+3+.....+n) total subarrays that are also valid. Nevertheless, after solving this question I realized that the better approach is probably adding the current sum everytime we visit the next element instead of using a formula later, but it was more intuitive to me when solving it.\\n\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n\\t    if(len(nums)<3):\\n\\t\\t\\treturn 0\\n        l,r,diff,ans,cur=0,2,nums[1]-nums[0],0,0\\n        while(r<len(nums)):\\n            if((nums[r]-nums[r-1])==diff):\\n                cur+=1\\n            else:\\n                ans+=(cur*(cur+1))//2\\n                cur=0\\n                l=r-1\\n                diff=nums[r]-nums[l]\\n            r+=1\\n        if(not cur==0):\\n            ans+=(cur*(cur+1))//2\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "The naive approach is to simply compute every possible consecutive subarray starting from every single element in the array, incrementing the ans everytime the subarray is extended.\\n\\nIt is then obvious that once the current element we encounter causes the current subarray to be invalid, we could just skip the entire group of elements in between the starting index and the current element, as any subarray which starts from these elements are also invalid. \\n\\nFor a valid subarray of length x, there are x*(x+1)/2 (Basic formula for 1+2+3+.....+n) total subarrays that are also valid. Nevertheless, after solving this question I realized that the better approach is probably adding the current sum everytime we visit the next element instead of using a formula later, but it was more intuitive to me when solving it.\\n\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n\\t    if(len(nums)<3):\\n\\t\\t\\treturn 0\\n        l,r,diff,ans,cur=0,2,nums[1]-nums[0],0,0\\n        while(r<len(nums)):\\n            if((nums[r]-nums[r-1])==diff):\\n                cur+=1\\n            else:\\n                ans+=(cur*(cur+1))//2\\n                cur=0\\n                l=r-1\\n                diff=nums[r]-nums[l]\\n            r+=1\\n        if(not cur==0):\\n            ans+=(cur*(cur+1))//2\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1815987,
                "title": "two-pointer-solution-very-detailed-explanation",
                "content": "Since the problem seemed sliding-window-like my first idea was to maintain two pointer `l` and `r`. `l` needs to be updated when we processed a valid arithmetic subarray and want to start scanning a new subarray.\\nI however wasn\\'t sure of how the count of arithmetic subarrays increases when adding one valid successor to an existent arithmetic subarray. So i took a look at the following example:\\n\\n`[3,5,7] => 1`\\n`[3,5,7,9] => 3`, because `[3,5,7], [5,7,9] and [3,5,7,9]` are valid\\n`[3,5,7,9,11] => 6`, additonally `[7,9,11]`, `[5,7,9,11]`, `[3,5,7,9,11]`\\n`[3,5,7,9,11,13] => 10`, additionally `[9,11,13]`,`[7,9,11,13]`,`[5,7,9,11,13]`, `[3,5,7,9,11,13]`\\n\\nAs we can see the number of found arithmetic subarrays increases by the previous arithmetic subarrays length. Let\\'s say `a[i:j]` is an arithmetic subarray with `k` arithmetic slices. We know that when we find a valid successor at `a[j+1]` that our resulting slices count will be `k+((j+1)-i)-1=k+j-i`.\\n\\nNow we know how to calculate the result. There are three main cases that need to be considered. I will show through an example why each case works:\\n1. Arithmetic slice has always the same difference ` -> [1,2,3,4,5,6,7]`.\\n2. Two non-overlapping arithmetic sequences exist in the array `-> [1,2,3,8,9,10]`.\\n3. Two overlapping arithmetic sequences exist in the array `-> [5,3,1,2,3]`.\\n\\nExample scenarios:\\n\\n**1. Arithmetic subarray has always the same difference**\\n\\n1. Step: `l=0`, `r=2`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 1 (`r-l-1=2-0-1`) to our result. Increase `r=3`\\n2. Step: `l=0`, `r=3`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 2 (`r-l-1=3-0-1`) to our result. Increase `r=4`\\n3. Step: `l=0`, `r=4`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 3 (`r-l-1=4-0-1`) to our result. Increase `r=5`\\n4. Step `l=0`,`r=5`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 4 (`r-l-1=5-0-1`) to our result. Increase `r=6`\\n5. Step `l=0`,`r=6`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 5 (`r-l-1=6-0-1`) to our result. Increase `r=7`\\n6. Return result of `1+2+3+4+5=15`\\n\\n**2. Two non-overlapping arithmetic sequences exist in the array**\\n\\n1. Step: `l=0`, `r=2`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 1 (`r-l-1=2-0-1`) to our result. Increase `r=3`\\n2. Step: `l=0`, `r=3`, `lastDiff=-1`, `currentDiff=-5` => Since `lastDiff!=currentDiff` we set `l=r-1=2` and update `lastDiff=currentDiff=-5`. Increase `r=4`\\n3. Step: `l=2`, `r=4`, `lastDiff=-5`, `currentDiff=-1` => Since `lastDiff!=currentDiff` we set `l=r-1=3` and update `lastDiff=currentDiff=-1`. Increase `r=5`\\n4. Step: `l=3` `r=5` `lastDiff= -1` `currentDiff=-1` => Since `lastDiff==currentDiff` we add 1 (`r-l-1=5-3-1`) to our result. Increase `r=6`\\n4. Return result of `1+1=2`\\n\\n**2. Two overlapping arithmetic sequences exist in the array**\\n\\n1. Step: `l=0`, `r=2`, `lastDiff=2`, `currentDiff=2` => Since `lastDiff==currentDiff` we add 1 (`r-l-1=2-0-1`) to our result. Increase `r=3`\\n2. Step: `l=0`, `r=3`, `lastDiff=2`, `currentDiff=-1` => Since `lastDiff!=currentDiff` we set `l=r-1=2` and update `lastDiff=currentDiff=-1`. Increase `r=4`\\n3. Step: `l=2`, `r=4`, `lastDiff=-1`, `currentDiff=-1` => Since `lastDiff==currentDiff` we add 1 (`r-l-1=4-2-1`) to our result. Increase `r=5`\\n4. Return result of `1+1=2`\\n\\n\\nFinally the code:\\n```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n\\tif(nums.length < 3) return 0;\\n\\tint result = 0;\\n\\tint l = 0;\\n\\tint lastDiff = nums[0] - nums[1];\\n\\tfor( int r = 2; r < nums.length; r++ ){\\n\\t\\tint currentDiff = nums[r-1] - nums[r];\\n\\t\\tif( currentDiff != lastDiff ){\\n\\t\\t\\tl = r - 1;\\n\\t\\t\\tlastDiff = currentDiff;\\n\\t\\t} else {\\n\\t\\t\\tresult += (r-l)-1;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n\\tif(nums.length < 3) return 0;\\n\\tint result = 0;\\n\\tint l = 0;\\n\\tint lastDiff = nums[0] - nums[1];\\n\\tfor( int r = 2; r < nums.length; r++ ){\\n\\t\\tint currentDiff = nums[r-1] - nums[r];\\n\\t\\tif( currentDiff != lastDiff ){\\n\\t\\t\\tl = r - 1;\\n\\t\\t\\tlastDiff = currentDiff;\\n\\t\\t} else {\\n\\t\\t\\tresult += (r-l)-1;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815857,
                "title": "0ms-c-standard-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n        return 0;\\n    }\\n    int ans=0;\\n    vector<int> dp(nums.size(),0);\\n    for(int i=2;i<nums.size();i++){\\n        if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n            dp[i]=dp[i-1] + 1;\\n            ans+=dp[i];\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3){\\n        return 0;\\n    }\\n    int ans=0;\\n    vector<int> dp(nums.size(),0);\\n    for(int i=2;i<nums.size();i++){\\n        if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n            dp[i]=dp[i-1] + 1;\\n            ans+=dp[i];\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815757,
                "title": "c-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3) return 0;\\n        \\n        int count = 0;\\n        int prev_diff = nums[1] - nums[0];\\n        \\n              \\n        int ans = 0;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           int diff = nums[i+1]-nums[i];\\n            \\n           if(diff == prev_diff){\\n               count++;\\n           }\\n            \\n           else{\\n              \\n               prev_diff = nums[i+1]-nums[i];\\n               int n = count+2;\\n               if(n==3) ans +=1;\\n               else if(n>3){\\n                   ans += ((n-1)*(n-2))/2; \\n               }\\n               count = 0;\\n               \\n           } \\n              \\n        }\\n        \\n        int n = count+2;\\n        if(n==3) ans +=1;\\n        else if(n>3){\\n            ans += ((n-1)*(n-2))/2; \\n        }\\n        count = 0;\\n       \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3) return 0;\\n        \\n        int count = 0;\\n        int prev_diff = nums[1] - nums[0];\\n        \\n              \\n        int ans = 0;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           int diff = nums[i+1]-nums[i];\\n            \\n           if(diff == prev_diff){\\n               count++;\\n           }\\n            \\n           else{\\n              \\n               prev_diff = nums[i+1]-nums[i];\\n               int n = count+2;\\n               if(n==3) ans +=1;\\n               else if(n>3){\\n                   ans += ((n-1)*(n-2))/2; \\n               }\\n               count = 0;\\n               \\n           } \\n              \\n        }\\n        \\n        int n = count+2;\\n        if(n==3) ans +=1;\\n        else if(n>3){\\n            ans += ((n-1)*(n-2))/2; \\n        }\\n        count = 0;\\n       \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815518,
                "title": "sliding-window-c",
                "content": "```\\n int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return 0;\\n        int start=0;\\n        int end=2;\\n        int streak=0;\\n        int count=0;\\n        while(end<nums.size()){\\n            if(nums[end]-nums[end-1]==nums[end-1]-nums[start]){\\n                count+=1;\\n                count+=streak;\\n                streak++;\\n                \\n            }\\n            else{\\n                streak=0;\\n            }\\n            start++;\\n            end++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return 0;\\n        int start=0;\\n        int end=2;\\n        int streak=0;\\n        int count=0;\\n        while(end<nums.size()){\\n            if(nums[end]-nums[end-1]==nums[end-1]-nums[start]){\\n                count+=1;\\n                count+=streak;\\n                streak++;\\n                \\n            }\\n            else{\\n                streak=0;\\n            }\\n            start++;\\n            end++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815048,
                "title": "javascript-maths-sum-of-1-to-n-formula-n-n-1-2",
                "content": "Problems has to be divided into 2 simple parts:\\n1. Identify continuous sub arrays with same diff, accumulate their lengths in an array in linear fashion. **o(n)**\\n2. Iterate through those subarray length\\'s array and using **n(n+1)/2** formula.\\n\\nFor e.g. 1,2,3,4,5,6,7 array, length = 7; \\n        Number possibilities of having 3+ consecutive numbers\\' unique group\\n        **Length = 3**:  (Count = 5)\\n        1,2,3\\n        2,3,4\\n        3,4,5\\n        4,5,6\\n        5,6,7        \\n        **Length = 4**:  (Count = 4)\\n        1,2,3,4\\n        2,3,4,5\\n        3,4,5,6\\n        4,5,6,7\\n        **Length = 5:**  (Count = 3)\\n        1,2,3,4,5\\n        2,3,4,5,6\\n        3,4,5,6,7        \\n        **Length = 6:** (Count = 2)\\n        1,2,3,4,5,6\\n        2,3,4,5,6,7\\n         **Length = 7**   (Count = 1)\\n        1,2,3,4,5,6,7\\n        So **total = 5 + 4 + 3 + 2 + 1** which is sum of 1 to 5 numbers. \\n        So, always to get unique groups of c+ numbers in array of n numbers is \\n        (n - c + 1) * (n - c + 1 + 1) / 2;\\n\\t\\t\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfArithmeticSlices = function(nums) {\\n    if (nums.length < 3) {\\n        return 0;\\n    }\\n    \\n    /* windows will gather the continuous sub array length which are having equal diffs */\\n    let windows = [];\\n    let diff, count;\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        /* Get the first diff for reference */\\n        diff = nums[i] - nums[i - 1];\\n        count = 1; /* By default, we are assuming that with given diff, we got atleast 1 pair */\\n        \\n        /* \\n         * Loop till next numbers which are having same diff \\n         * For e.g. 1, 2, 3, 4, 5 -> This will iterate till 4th index and gather the \\n         *  subarray length in `windows` array. \\n        */\\n        while(nums[i + 1] - nums[i] === diff) {\\n            i++;\\n            count++;\\n        }               \\n        \\n        /* For 3 numbers with same diff, count will be 2. Count will always be less than sub array length of same diff numbers */\\n        if (count >= 2) {\\n            /* Push the correct sub array length increamenting it by 1. */\\n            /* For e.g. 1, 4,5,6, 8 array, subarray will be 4,5,6. For which count will be 2 which is 1 less than the required subarray length*/\\n            windows.push(count + 1);\\n        }\\n    }\\n        \\n    return windows.reduce((total, windowSize) => total + getPossibility(windowSize, 3), 0);\\n};\\n\\n\\nconst getPossibility = (fullLength, segmentLength = 3) => {\\n    const n = fullLength - segmentLength + 1;\\n    return n * (n + 1) / 2;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar numberOfArithmeticSlices = function(nums) {\\n    if (nums.length < 3) {\\n        return 0;\\n    }\\n    \\n    /* windows will gather the continuous sub array length which are having equal diffs */\\n    let windows = [];\\n    let diff, count;\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        /* Get the first diff for reference */\\n        diff = nums[i] - nums[i - 1];\\n        count = 1; /* By default, we are assuming that with given diff, we got atleast 1 pair */\\n        \\n        /* \\n         * Loop till next numbers which are having same diff \\n         * For e.g. 1, 2, 3, 4, 5 -> This will iterate till 4th index and gather the \\n         *  subarray length in `windows` array. \\n        */\\n        while(nums[i + 1] - nums[i] === diff) {\\n            i++;\\n            count++;\\n        }               \\n        \\n        /* For 3 numbers with same diff, count will be 2. Count will always be less than sub array length of same diff numbers */\\n        if (count >= 2) {\\n            /* Push the correct sub array length increamenting it by 1. */\\n            /* For e.g. 1, 4,5,6, 8 array, subarray will be 4,5,6. For which count will be 2 which is 1 less than the required subarray length*/\\n            windows.push(count + 1);\\n        }\\n    }\\n        \\n    return windows.reduce((total, windowSize) => total + getPossibility(windowSize, 3), 0);\\n};\\n\\n\\nconst getPossibility = (fullLength, segmentLength = 3) => {\\n    const n = fullLength - segmentLength + 1;\\n    return n * (n + 1) / 2;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815015,
                "title": "2-java-solution-with-explaination-brute-force-to-dp",
                "content": "**Approach 1- Brute force**\\n\\nIterate for each length combination starting from k =3 till length. and keep on updating answer.\\n```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n\\t\\tint res = 0;\\n\\t\\t//check total number of ap of k length\\n\\t\\tfor (int k = 3; k <= nums.length; k++) {\\n\\t\\t\\tres += totalAP(nums, k);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\nprivate int totalAP(int[] nums, int k) {\\n\\t\\tint ans = 0;\\n\\t\\t//sliding window of k size\\n\\t\\tfor (int i = k - 1; i < nums.length; i++) {\\n\\t\\t\\tint diff1 = nums[i - k + 2] - nums[i - k + 1];\\n            int count = k-2;\\n            //loop to check elements are in ap of k length starting from ith index\\n\\t\\t\\tfor (int j = i; count > 0; j--, count--) {\\n\\t\\t\\t\\t//if not same break loop\\n                if( diff1 != nums[j] - nums[j - 1]) {\\n                    break;\\n                } \\n\\t\\t\\t}\\n\\t\\t\\t//if all elements are in ap increase ans\\n\\t\\t\\tif (count==0) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```\\n**Approach 2 -> DP**\\n\\nwe can make use of property that if currently running sequence is ap then adding one more element to that sequence will increase the total number of slices by current no of sequence in current sum.\\ntake two variables -> curr to hold the current sequence count \\nsum to hold the answer\\n\\n     Example -\\n\\t now suppose input is [0,1,2,3,4].\\n\\t  for first 3 elements in ap = curr=1; [0,1,2]\\n\\t  on reading 3, curr=2 and sum=1+2=3.  [0,1,2],[1,2,3],[0,1,2,3] \\n\\t  on reading 4, curr=3 and sum=3+3=6.\\n\\t  [0,1,2],[1,2,3],[0,1,2,3],[0,1,2,3,4],[2,3,4],[0,1,2,3,4,5]\\n\\nFor case where ap sequence breaks just set current total to 0 again for fresh count.\\n```\\npublic int numberOfArithmeticSlicesOptimized(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tint curr = 1;\\n\\t\\tfor (int i = 2; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n\\t\\t\\t\\tsum += curr;\\n                curr++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int numberOfArithmeticSlices(int[] nums) {\\n\\t\\tint res = 0;\\n\\t\\t//check total number of ap of k length\\n\\t\\tfor (int k = 3; k <= nums.length; k++) {\\n\\t\\t\\tres += totalAP(nums, k);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\nprivate int totalAP(int[] nums, int k) {\\n\\t\\tint ans = 0;\\n\\t\\t//sliding window of k size\\n\\t\\tfor (int i = k - 1; i < nums.length; i++) {\\n\\t\\t\\tint diff1 = nums[i - k + 2] - nums[i - k + 1];\\n            int count = k-2;\\n            //loop to check elements are in ap of k length starting from ith index\\n\\t\\t\\tfor (int j = i; count > 0; j--, count--) {\\n\\t\\t\\t\\t//if not same break loop\\n                if( diff1 != nums[j] - nums[j - 1]) {\\n                    break;\\n                } \\n\\t\\t\\t}\\n\\t\\t\\t//if all elements are in ap increase ans\\n\\t\\t\\tif (count==0) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```\n```\\npublic int numberOfArithmeticSlicesOptimized(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tint curr = 1;\\n\\t\\tfor (int i = 2; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\\n\\t\\t\\t\\tsum += curr;\\n                curr++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814901,
                "title": "java-100-fast-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length < 3)\\n            return 0; //base case\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < nums.length - 2; i++){\\n            \\n            int difference = nums[i+1]-nums[i];\\n            int start = i + 1;\\n            int end = i + 2;\\n            \\n            while(end < nums.length){\\n            int currDifference = nums[end]-nums[start];\\n            if(currDifference == difference){\\n                result++;   \\n                end++;\\n                start++;\\n            }\\n            else\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length < 3)\\n            return 0; //base case\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < nums.length - 2; i++){\\n            \\n            int difference = nums[i+1]-nums[i];\\n            int start = i + 1;\\n            int end = i + 2;\\n            \\n            while(end < nums.length){\\n            int currDifference = nums[end]-nums[start];\\n            if(currDifference == difference){\\n                result++;   \\n                end++;\\n                start++;\\n            }\\n            else\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814889,
                "title": "daily-leetcoding-challenge-march-day-3",
                "content": "class Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        \\n        dp=[0]*len(nums)\\n        ans=0\\n        for i in range(2,len(nums)):\\n            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:\\n                dp[i]=1+dp[i-1]\\n                ans+=dp[i]\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        \\n        dp=[0]*len(nums)\\n        ans=0\\n        for i in range(2,len(nums)):\\n            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:\\n                dp[i]=1+dp[i-1]\\n                ans+=dp[i]\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1814684,
                "title": "413-arithmetic-slices-0-ms-easy-solution",
                "content": "* We need to find the **arithmetic subarray**(*contiguous*).\\n* Also in the provided sample test case and problem description we have a condition that **minumum 3 elements should be present** which is handled through a sample test case.\\n\\n**HANDLING MINIMUM SIZE :**\\n```\\nif(nums.size() < 3)  \\n   return 0;\\n```\\n\\n**CODE:**\\n```\\n        if(nums.size() < 3)  \\n           return 0;\\n        int res=0,cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]-nums[i-1]==nums[i+1]-nums[i]) cnt++;\\n            else {\\n                res+=(cnt*(cnt+1)/2);\\n                cnt=0;\\n            }\\n        }\\n        res+=(cnt*(cnt+1)/2);\\n        return res;\\n```\\n\\nHere **nums[i]-nums[i-1]==nums[i+1]-nums[i]** is derived from the general AP condition ie;\\na, b, c are in A.P if \\n**b-a == c-b** \\nwhere *a = nums[i-1] ,b = nums[i], c = nums[i+1]*\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(nums.size() < 3)  \\n   return 0;\\n```\n```\\n        if(nums.size() < 3)  \\n           return 0;\\n        int res=0,cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]-nums[i-1]==nums[i+1]-nums[i]) cnt++;\\n            else {\\n                res+=(cnt*(cnt+1)/2);\\n                cnt=0;\\n            }\\n        }\\n        res+=(cnt*(cnt+1)/2);\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814610,
                "title": "c-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<=2){ // here if vector size is less then 3 then we simply return 0\\n            return 0;\\n        }\\n        int c=0;\\n        for(int i=0;i<=nums.size()-3;i++){ //  here we are traversing whole array\\n            int x=nums[i+1]-nums[i];\\n            for(int j=i+2;j<nums.size();j++){\\n                if(nums[j]-nums[j-1]==x){\\n                    c++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<=2){ // here if vector size is less then 3 then we simply return 0\\n            return 0;\\n        }\\n        int c=0;\\n        for(int i=0;i<=nums.size()-3;i++){ //  here we are traversing whole array\\n            int x=nums[i+1]-nums[i];\\n            for(int j=i+2;j<nums.size();j++){\\n                if(nums[j]-nums[j-1]==x){\\n                    c++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814567,
                "title": "java-o-n-and-o-1-space-0ms",
                "content": "\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length < 3) return 0;\\n        int cur = 0;\\n        int sum = 0;\\n        for(int i = 2 ; i < nums.length ; i++){\\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]){\\n                cur++; \\n                sum = sum + cur; \\n            } else{\\n                cur = 0;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length < 3) return 0;\\n        int cur = 0;\\n        int sum = 0;\\n        for(int i = 2 ; i < nums.length ; i++){\\n            if(nums[i] - nums[i-1] == nums[i-1] - nums[i-2]){\\n                cur++; \\n                sum = sum + cur; \\n            } else{\\n                cur = 0;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1814559,
                "title": "arithmetic-slices-python",
                "content": "**Runtime: 32 ms, faster than 98.00% of Python3 online submissions for Arithmetic Slices.**\\n\\n**Memory Usage: 14.1 MB, less than 75.02% of Python3 online submissions for Arithmetic Slices.**\\n\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums):\\n        sum = 0\\n        curr = 0\\n        for i in range(2,len(nums)):\\n            if (nums[i]-nums[i-1] == nums[i-1]-nums[i-2]):\\n                curr += 1\\n                sum += curr\\n            else:\\n                curr = 0;\\n        return sum;\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums):\\n        sum = 0\\n        curr = 0\\n        for i in range(2,len(nums)):\\n            if (nums[i]-nums[i-1] == nums[i-1]-nums[i-2]):\\n                curr += 1\\n                sum += curr\\n            else:\\n                curr = 0;\\n        return sum;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814440,
                "title": "c-solution-100-faster-two-pointer",
                "content": "![image](https://assets.leetcode.com/users/images/413efbaf-9077-4ac4-b302-b0caa61e1a93_1646272609.8341084.png)\\n```\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int l=0,r=1,ans=0;\\n        while(r<nums.size()){\\n            int d=nums[r]-nums[l],adder=1;\\n            while(r<nums.size() && nums[r]-nums[r-1]==d){\\n                if((r-l)+1>=3)\\n                    ans+=(adder++); \\n                r++;               \\n            }\\n            l=r-1;\\n        }\\n        return ans;\\n    }\\n\\t```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int l=0,r=1,ans=0;\\n        while(r<nums.size()){\\n            int d=nums[r]-nums[l],adder=1;\\n            while(r<nums.size() && nums[r]-nums[r-1]==d){\\n                if((r-l)+1>=3)\\n                    ans+=(adder++); \\n                r++;               \\n            }\\n            l=r-1;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759613,
                "title": "4ms-without-dp-o-n-2-cp-clean-code",
                "content": "class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        if(n<3) return 0;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<n-2; i++)\\n        {\\n            int diff = nums[i+1]-nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(nums[j]-nums[j-1] != diff)\\n                    break;\\n                else \\n                {\\n                    (j-i+1>=3) ? cnt++ : 0;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        if(n<3) return 0;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<n-2; i++)\\n        {\\n            int diff = nums[i+1]-nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(nums[j]-nums[j-1] != diff)\\n                    break;\\n                else \\n                {\\n                    (j-i+1>=3) ? cnt++ : 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1756955,
                "title": "simple-java-dp-solution-6-lines-with-explanation-0ms",
                "content": "# Logic for using DP:\\n\\n1. For every 3 elements that are in arithmic, the count is always 1.\\neg:- 1,2,3 \\npossibilities: **1,2,3**\\n\\n2. When you add the 4th element to it, the count is 1 + 2 = 3. It increase by 2 as you can count all the subarrays from 1 to 3 and include the 4th element in 2 ways.\\neg:- 1,2,3,4\\nprev possibilities : 1,2,3 \\npossibilities with addition of 4 to it: 1,**2,3,4**  and  **1,2,3,4**\\n\\n3. When you add one more element to it (say 5), the count is 3 + 3. The possibilities increase by 3 this time as you can include 5 in 3 more ways.\\neg:- 1,2,3,4,5\\nprev poss: 1,2,3 and 2,3,4 and 1,2,3,4\\nnew poss: 1,2,**3,4,5** and  1,**2,3,4,5**  and **1,2,3,4,5**\\n\\t\\t\\t\\t\\t\\n4. On addition of 6, the possibilites become 6 + 4 = 10\\neg:- 1,2,3,4,5,6\\nprev poss: 1,2,3 and 2,3,4 and 1,2,3,4 and 1,2,3,4,5 and  1,2,3,4,5  and 1,2,3,4,5\\nnew poss: 1,2,3,**4,5,6** and 1,2,**3,4,5,6** and 1,**2,3,4,5,6** and **1,2,3,4,5,6** \\n\\nObserving the pattern above, you realise that the increase in the number of possibilities is due to the fact that you can use the last added digit with i-1 ( where i = current index) more possibilities from the start of the arithmetic series( i.e 1)\\n\\nIf we add 7 (i = 6) to our example we can compute the count to be:\\n\\n\\tprev + i - start\\n\\tcount(6) + 6 - 1 \\n\\t10 + 6 - 1\\n\\t15\\n\\nIf we add 8 (i=7)\\n```\\nprev + i - start\\ncount(7) + 7 - 1\\n15 + 6\\n21\\n```\\n\\t\\n\\t\\nBut we also need to take into account the fact that any time, our difference might change and we could start a new arithmetic series.\\n\\neg:- 1,2,3,6,8,9\\npossibilities:- 1,2,3 and 6,8,9\\n\\neg:- 1,2,3,6,8,9,11\\npossibilities:- **1,2,3**,6,8,9,11 and 1,2,3,**6,8,9**,11 and 1,2,3,6 **,8,9,11** and 1,2,3 **6,8,9,11**\\ncount = 4\\n\\nFor the above examples, a new arithmetic series of difference 2 has been started from the index 3. The addition rules for the new series remain the same, just the starting index needs to be updated to 3 as you cannot include the elements before index 3 in the count. \\n\\t\\neg:- 1,2,3,6,8,9,11,13\\n\\n```\\ncount + i - start\\n4 + 7 - 3 \\n8\\n```\\n\\nHere (i - start) usually gives us the number of different combinations we can add out last element to ( which is the number of elements between the current index and the start of the arithmetic)\\n\\nHence, we need to store two variables. \\n1. Count:- sum of all the subarray that have been possible ( dp variable) to which you add the current possibilities\\n2. Start index:- Initialized to 1 and changes whenever you start a new arithmetic series\\n\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] a) {\\n\\t\\n\\t// need minimum 3 elements in subarray\\n        if(a.length <= 2) return 0;\\n\\t\\n        int count =0, start = 1;\\n\\t\\t\\n        for(int i=2;i<a.length;i++){\\n\\t\\t\\n\\t\\t// If the arithmetic condition is true, we can use our formula to add the current element to the list\\n            if(a[i] - a[i-1] == a[i-1] - a[i-2] )  count += i - start;\\n            \\n\\t\\t// if we acquire a new difference, the prev arithmetic series will end and  we can start checking for the new difference by making new arithmetic series\\t\\t\\t\\n\\t\\t//we mark the start of the new arithmetic series\\n            else start = i; \\n        }     \\n\\t\\t\\n\\t\\t// return the total subarrays possible i.e the count\\n        return count;   \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nprev + i - start\\ncount(7) + 7 - 1\\n15 + 6\\n21\\n```\n```\\ncount + i - start\\n4 + 7 - 3 \\n8\\n```\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] a) {\\n\\t\\n\\t// need minimum 3 elements in subarray\\n        if(a.length <= 2) return 0;\\n\\t\\n        int count =0, start = 1;\\n\\t\\t\\n        for(int i=2;i<a.length;i++){\\n\\t\\t\\n\\t\\t// If the arithmetic condition is true, we can use our formula to add the current element to the list\\n            if(a[i] - a[i-1] == a[i-1] - a[i-2] )  count += i - start;\\n            \\n\\t\\t// if we acquire a new difference, the prev arithmetic series will end and  we can start checking for the new difference by making new arithmetic series\\t\\t\\t\\n\\t\\t//we mark the start of the new arithmetic series\\n            else start = i; \\n        }     \\n\\t\\t\\n\\t\\t// return the total subarrays possible i.e the count\\n        return count;   \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756324,
                "title": "c-dp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //map\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int count = 0; \\n        if(nums.size() <3) return count; \\n        \\n        vector<int> dp(nums.size()+1);\\n        dp[0] = 0;\\n        dp[1] = 0;\\n        for(int i = 2; i<nums.size();i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n               dp[i] = dp[i-1] + 1;\\n               count += dp[i];\\n            }\\n        }\\n        \\n        // for( int i : dp){\\n        //     cout << i << endl;\\n        // }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //map\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int count = 0; \\n        if(nums.size() <3) return count; \\n        \\n        vector<int> dp(nums.size()+1);\\n        dp[0] = 0;\\n        dp[1] = 0;\\n        for(int i = 2; i<nums.size();i++){\\n            if(nums[i]-nums[i-1] == nums[i-1]-nums[i-2]){\\n               dp[i] = dp[i-1] + 1;\\n               count += dp[i];\\n            }\\n        }\\n        \\n        // for( int i : dp){\\n        //     cout << i << endl;\\n        // }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1749067,
                "title": "c-backtracking-beats-64",
                "content": "```\\nclass Solution {\\nprivate:\\n    void backtrack(int &ans,vector<int>&curr,int index,vector<int>&nums){\\n        if(index>=nums.size()){\\n            return;\\n        } else if(index==0){\\n            for(int i=index;i<nums.size();i++){\\n                curr.push_back(nums[i]);\\n                backtrack(ans,curr,i+1,nums);\\n                curr.pop_back();\\n            }\\n        } else if(curr.size()<2){\\n            curr.push_back(nums[index]);\\n            backtrack(ans,curr,index+1,nums);\\n            curr.pop_back();\\n        } else {\\n            int n=curr.size();\\n            if(curr[n-1]-curr[n-2]==nums[index]-curr[n-1]){\\n                ans++;\\n                curr.push_back(nums[index]);\\n                backtrack(ans,curr,index+1,nums);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans=0;\\n        vector<int>curr;\\n        backtrack(ans,curr,0,nums);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\nprivate:\\n    void backtrack(int &ans,vector<int>&curr,int index,vector<int>&nums){\\n        if(index>=nums.size()){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1728582,
                "title": "c-easy-solution-sliding-window-tc-o-n-sc-o-1",
                "content": "Using a sliding window find all the arithmetic substrings and store the number of arithmetic substrings which can be formed by it.\\nAnd that is your answer.\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n(size(nums)), count(0);\\n        \\n        for (auto start=0, end=0, cnt=1, diff=INT_MAX; end<n;)\\n        {\\n            if (end-start == 0) end++;\\n            else if (diff == INT_MAX)   diff = nums[end]-nums[start];\\n            else if (nums[end]-nums[end-1] == diff)  {\\n                if (++end-start > 2)    count += cnt++;\\n            }\\n            else    start = --end, diff = INT_MAX, cnt = 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        \\n        int n(size(nums)), count(0);\\n        \\n        for (auto start=0, end=0, cnt=1, diff=INT_MAX; end<n;)\\n        {\\n            if (end-start == 0) end++;\\n            else if (diff == INT_MAX)   diff = nums[end]-nums[start];\\n            else if (nums[end]-nums[end-1] == diff)  {\\n                if (++end-start > 2)    count += cnt++;\\n            }\\n            else    start = --end, diff = INT_MAX, cnt = 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676078,
                "title": "simple-python-solution-using-mathematics",
                "content": "Lets take an example [4,2,7,10,13,15,17,19].\\n\\nHere are two arithmetic sequences 7,10,13 (difference = 2) and 13,15,17,19 (difference = 3). (Note that, 13, 15, 17 is also an arithmetic sequence of difference = 3 but it is the part the sequence 13,15,17,19 and we are taking the longest one as for now.\\n\\nHere, 7,10,13 has 3 elements.\\n13,15,17,19 has 4 elements.\\n\\nOnly one sequence can be made from 7,10,13 (i=3) that is ****7,10,13**** itself.\\nFrom, 13, 15, 17, 19(i=4), following sequences can be made:\\n****13, 15, 17\\n15, 17, 19\\n13, 15, 17, 19****\\n\\nSo, for i=3, ans1=1 and for i=4, ans2= 3. So, ans = 1+ 3 = 4\\nThe general formula for this is:\\n****((i+1)*(i+1-3) - (i*(i+1))//2+3)**\\n\\n****Code:****\\n```class Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        count=2\\n        arr=[]\\n        for i in range(2,n):\\n            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:\\n                count+=1\\n            else:\\n                if count>2:\\n                    arr.append(count)\\n                count=2\\n        if count>2:\\n            arr.append(count)\\n        print(arr)\\n        ans=0\\n        for i in arr:\\n            ans+= ((i+1)*(i+1-3) - (i*(i+1))//2+3)\\n        return ans",
                "solutionTags": [],
                "code": "Lets take an example [4,2,7,10,13,15,17,19].\\n\\nHere are two arithmetic sequences 7,10,13 (difference = 2) and 13,15,17,19 (difference = 3). (Note that, 13, 15, 17 is also an arithmetic sequence of difference = 3 but it is the part the sequence 13,15,17,19 and we are taking the longest one as for now.\\n\\nHere, 7,10,13 has 3 elements.\\n13,15,17,19 has 4 elements.\\n\\nOnly one sequence can be made from 7,10,13 (i=3) that is ****7,10,13**** itself.\\nFrom, 13, 15, 17, 19(i=4), following sequences can be made:\\n****13, 15, 17\\n15, 17, 19\\n13, 15, 17, 19****\\n\\nSo, for i=3, ans1=1 and for i=4, ans2= 3. So, ans = 1+ 3 = 4\\nThe general formula for this is:\\n****((i+1)*(i+1-3) - (i*(i+1))//2+3)**\\n\\n****Code:****\\n```class Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        count=2\\n        arr=[]\\n        for i in range(2,n):\\n            if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]:\\n                count+=1\\n            else:\\n                if count>2:\\n                    arr.append(count)\\n                count=2\\n        if count>2:\\n            arr.append(count)\\n        print(arr)\\n        ans=0\\n        for i in arr:\\n            ans+= ((i+1)*(i+1-3) - (i*(i+1))//2+3)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1593174,
                "title": "without-using-extra-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        int d = nums[1] - nums[0];\\n        int l = 2;\\n        int ret = 0;\\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i] == nums[i-1] + d)\\n                l++;\\n            else\\n            {\\n                d = nums[i] - nums[i-1];\\n                l = 2;\\n            }\\n            if(l > 2)\\n                ret += (l-3+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        int d = nums[1] - nums[0];\\n        int l = 2;\\n        int ret = 0;\\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i] == nums[i-1] + d)\\n                l++;\\n            else\\n            {\\n                d = nums[i] - nums[i-1];\\n                l = 2;\\n            }\\n            if(l > 2)\\n                ret += (l-3+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543145,
                "title": "java-solution",
                "content": "//cheak for every possibility\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int count = 0;\\n        if(nums.length < 3)\\n            return 0;\\n        \\n        for(int i=2; i<nums.length; i++){\\n            for(int j=0; j<=i; j++){\\n                if(i-j<2)\\n                    break;\\n                if(isArrayValid(nums, j, i)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean isArrayValid(int[] array, int start, int end){\\n        int difference = array[start+1] - array[start];\\n        for(int i=start+2; i<=end; i++){\\n            if(array[i]-array[i-1] != difference)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int count = 0;\\n        if(nums.length < 3)\\n            return 0;\\n        \\n        for(int i=2; i<nums.length; i++){\\n            for(int j=0; j<=i; j++){\\n                if(i-j<2)\\n                    break;\\n                if(isArrayValid(nums, j, i)){\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1523465,
                "title": "c-100-simple-dp-solution",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Arithmetic Slices.\\nMemory Usage: 7.4 MB, less than 53.64% of C++ online submissions for Arithmetic Slices.**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=2){return 0;}  \\n        vector<int> dp(n,0); \\n        dp[0] = dp[1] = 0;\\n        if(nums[1]-nums[0]==nums[2]-nums[1]){\\n            dp[2] = 1;\\n        }else{\\n            dp[2] = 0;   \\n        }\\n        \\n        int prev = nums[2]-nums[1];\\n        for(int i=3;i<n;i++){\\n            if(prev == nums[i]-nums[i-1]){\\n                dp[i] = dp[i-1] + 1;\\n            }else{\\n                prev = nums[i]-nums[i-1];\\n            }\\n        }\\n        int sum = 0;\\n        return accumulate(dp.begin(),dp.end(),sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=2){return 0;}  \\n        vector<int> dp(n,0); \\n        dp[0] = dp[1] = 0;\\n        if(nums[1]-nums[0]==nums[2]-nums[1]){\\n            dp[2] = 1;\\n        }else{\\n            dp[2] = 0;   \\n        }\\n        \\n        int prev = nums[2]-nums[1];\\n        for(int i=3;i<n;i++){\\n            if(prev == nums[i]-nums[i-1]){\\n                dp[i] = dp[i-1] + 1;\\n            }else{\\n                prev = nums[i]-nums[i-1];\\n            }\\n        }\\n        int sum = 0;\\n        return accumulate(dp.begin(),dp.end(),sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508745,
                "title": "java-0ms-beat-100-solution-o-1-space-math-iteration-no-dp",
                "content": "As we know, given the length of an arithmetic array, total number of arithmetic subarrays is fixed:\\n\\n```\\nlength         number_of_subArrays, with different sizes\\n                  3           4           5           6      ... \\n\\t\\t\\t\\t  \\n3                 1\\n4                 2     +     1\\n5                 3     +     2     +     1\\n6                 4     +     3     +     2     +     1\\n...               ...\\n...               ...\\nn                 n-2   +    n-3    +     n-4        ...     = (n - 2) * (n - 1) / 2 \\n```\\nIterate and find start/end point of each arithmetic array. then do math.\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if(nums.length < 3) return 0; \\n        int len = nums.length, start = 0, diff = nums[1] - nums[0];\\n        int count = 0;\\n        for(int end = 1; end < len; ++end) {\\n            if(nums[end] - nums[end - 1] != diff) {\\n                if(end - start >= 3)\\n                    count += (end - start - 2) * (end - start - 1) / 2;\\n                \\n                start = end - 1;\\n                diff = nums[end] - nums[start];\\n            }\\n        }\\n        if(len - start >= 3)\\n            count += (len - start - 2) * (len - start - 1) / 2;\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nlength         number_of_subArrays, with different sizes\\n                  3           4           5           6      ... \\n\\t\\t\\t\\t  \\n3                 1\\n4                 2     +     1\\n5                 3     +     2     +     1\\n6                 4     +     3     +     2     +     1\\n...               ...\\n...               ...\\nn                 n-2   +    n-3    +     n-4        ...     = (n - 2) * (n - 1) / 2 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475945,
                "title": "90-speed-90-space-python-solution-with-code-comments",
                "content": "We use a dynamic programming array, it takes additional O(n) space and runs in O(n) time as we make 1 pass over the array in linear time and a second pass to sum the total. This can be reduced to one pass by using a count variable to track the current total instead of summing the dp array at the end.\\n\\nThis can be further optimized to O(1) space by just using 2 variables - count : to track total and prev: to track prev dp[i-1] instead of requiring a second array.\\n\\n\\'\\'\\'\\n\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int: \\n        # We only concern ourselves with cases of size >= 3, however the problem can have input size 1\\n\\t\\tif len(nums) < 3: return 0\\n        \\n\\t\\t#Initialize the DP array to 0 with same length as input\\n        dp = [0] * len(nums)\\n        \\n\\t\\t# We calculate only the possibilities of 3rd+ index, since 0 or 1 are invalid length\\n        for i in range(2, len(nums)):\\n\\t\\t\\t# Check for diff of n-n1-n2 == same\\n            if nums[i]-nums[i-1] == nums[i-1]-nums[i-2]:\\n\\t\\t\\t\\t# The below code covers all 3 use cases\\n\\t\\t\\t\\t# Case 1: new sequence, i=2  [0,1,2], previous dp == 0, so current counter is 1\\n\\t\\t\\t\\t# Case 2: existing sequence, i =3, current sequence = [0,1,2,3], then we sum [0,1,2,3] and [1,2,3]\\n\\t\\t\\t\\t# Case 3: invalid sequence - this IF block will be skipped, and dp[i] remains 0\\n                dp[i] = dp[i-1] + 1\\n                \\n\\t\\t# Return the sum total of sequences at each index [i] in the DP array\\n        return sum(dp)\\n\\t\\t\\n\\t\\t\\nSample using O(1) constant space instead:\\n\\n\\n\\tdef numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums) < 3: return 0\\n\\n        prev = 0\\n        count = 0\\n\\n\\t\\t# We calculate only the possibilities of 3rd+ index, since 0 or 1 are invalid length\\n        for i in range(2, len(nums)):\\n            # Check for diff of n-n1-n2 == same\\n            if nums[i]-nums[i-1] == nums[i-1]-nums[i-2]:\\n                # The below code covers all 3 use cases\\n                # Case 1: new sequence, i=2  [0,1,2], previous dp == 0, so current counter is 1\\n                # Case 2: existing sequence, i =3, current sequence = [0,1,2,3], then we sum [0,1,2,3] and [1,2,3]\\n                prev = prev + 1\\n                count += prev\\n            else:\\n\\t\\t\\t\\t# Case 3: invalid sequence - this IF block will be skipped, and prev is set to 0 to reset the dp[i-1]\\n                prev = 0\\n\\n\\t\\t# Return the count which we have been tracking over our loop\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "We use a dynamic programming array, it takes additional O(n) space and runs in O(n) time as we make 1 pass over the array in linear time and a second pass to sum the total. This can be reduced to one pass by using a count variable to track the current total instead of summing the dp array at the end.\\n\\nThis can be further optimized to O(1) space by just using 2 variables - count : to track total and prev: to track prev dp[i-1] instead of requiring a second array.\\n\\n\\'\\'\\'\\n\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int: \\n        # We only concern ourselves with cases of size >= 3, however the problem can have input size 1\\n\\t\\tif len(nums) < 3: return 0\\n        \\n\\t\\t#Initialize the DP array to 0 with same length as input\\n        dp = [0] * len(nums)\\n        \\n\\t\\t# We calculate only the possibilities of 3rd+ index, since 0 or 1 are invalid length\\n        for i in range(2, len(nums)):\\n\\t\\t\\t# Check for diff of n-n1-n2 == same\\n            if nums[i]-nums[i-1] == nums[i-1]-nums[i-2]:\\n\\t\\t\\t\\t# The below code covers all 3 use cases\\n\\t\\t\\t\\t# Case 1: new sequence, i=2  [0,1,2], previous dp == 0, so current counter is 1\\n\\t\\t\\t\\t# Case 2: existing sequence, i =3, current sequence = [0,1,2,3], then we sum [0,1,2,3] and [1,2,3]\\n\\t\\t\\t\\t# Case 3: invalid sequence - this IF block will be skipped, and dp[i] remains 0\\n                dp[i] = dp[i-1] + 1\\n                \\n\\t\\t# Return the sum total of sequences at each index [i] in the DP array\\n        return sum(dp)\\n\\t\\t\\n\\t\\t\\nSample using O(1) constant space instead:\\n\\n\\n\\tdef numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        if len(nums) < 3: return 0\\n\\n        prev = 0\\n        count = 0\\n\\n\\t\\t# We calculate only the possibilities of 3rd+ index, since 0 or 1 are invalid length\\n        for i in range(2, len(nums)):\\n            # Check for diff of n-n1-n2 == same\\n            if nums[i]-nums[i-1] == nums[i-1]-nums[i-2]:\\n                # The below code covers all 3 use cases\\n                # Case 1: new sequence, i=2  [0,1,2], previous dp == 0, so current counter is 1\\n                # Case 2: existing sequence, i =3, current sequence = [0,1,2,3], then we sum [0,1,2,3] and [1,2,3]\\n                prev = prev + 1\\n                count += prev\\n            else:\\n\\t\\t\\t\\t# Case 3: invalid sequence - this IF block will be skipped, and prev is set to 0 to reset the dp[i-1]\\n                prev = 0\\n\\n\\t\\t# Return the count which we have been tracking over our loop\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 1469377,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        vector<int>dp(nums.size(),0);\\n        int ans = 0;\\n        for(int i = 2;i<nums.size();i++)\\n        {\\n            if((nums[i]-nums[i-1])==(nums[i-1]-nums[i-2])) dp[i] = 1+dp[i-1];\\n            ans += dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        vector<int>dp(nums.size(),0);\\n        int ans = 0;\\n        for(int i = 2;i<nums.size();i++)\\n        {\\n            if((nums[i]-nums[i-1])==(nums[i-1]-nums[i-2])) dp[i] = 1+dp[i-1];\\n            ans += dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462896,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return 0;\\n        int n=nums.size();\\n        int cnt=0;\\n        int ans=0;\\n        for(int i=2;i<n;i++)\\n        {\\n           if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])\\n               cnt++;\\n            else{\\n                ans+=(cnt*(cnt+1)/2);\\n                cnt=0;\\n            }\\n        }\\n        return ans+(cnt*(cnt+1)/2);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return 0;\\n        int n=nums.size();\\n        int cnt=0;\\n        int ans=0;\\n        for(int i=2;i<n;i++)\\n        {\\n           if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])\\n               cnt++;\\n            else{\\n                ans+=(cnt*(cnt+1)/2);\\n                cnt=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1456835,
                "title": "c-very-easy-o-1-space-explained",
                "content": "**Idea:**\\n\\nIt\\'s obviously very easy to find the difference between consecutive elements of an array, so it should also be a simple matter to iterate through the input array (A) and use a variable (diff) to keep track of what the most recently seen difference is and another variable (count) to keep track of how many consecutive elements make up the current streak.\\n\\nSome basic math will tell us that the number of possible combinations for a given count is a triangular number: with 4 numbers, for example, it\\'s possible to make up 10 (1+2+3+4) different number combinations ranging in length from 1 to 4.\\n\\nThe problem states that our minimum slice is 3 numbers, but since 3 numbers is actually 2 differences, and we\\'re dealing with differences, we\\'ll use 2 instead of 3 here. The number of 2+ length combinations is just a 0-indexed triangular number instead of a 1-indexed triangular number. So as in our earlier example, 4 consecutive differences yields 6 (0+1+2+3) possible combinations.\\n\\nBut rather than obtaining a count and then using the 0-indexed triangular number equation (n * (n - 1) / 2), we can just build this triangular number iteratively, since we\\'re iterating anyway.\\n\\nNormally, when building a triangular number iteratively, you would first increment the count and then add that count to the ans. In this case, we can either start the count at -1, or wait until after adding count to ans to increment count.\\n\\nDoing this, we can find our answer easily in O(n) time with minimal processing overhead.\\n\\n**Implementation:**\\n\\nTechnically, this problem doesn\\'t list a constraint for the values in A. Since we\\'re storing the difference between two elements in a variable, that could cause problems if the numbers range too broadly.\\n\\nTo get around that, we\\'d have to perform even more array calls on each iteration to avoid storing the differences in variables.\\n\\nOtherwise, we\\'d have to set the initial diff to A[1] - A[0], the initial count to 1, start our iteration at i = 2, and lead with an if statement to prevent situations where those array calls go out-of-bounds.\\n\\n\\n\\n\\n**O(n) Space**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans; vector<int>dp(nums.size());\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp[i]=dp[i-1]+1;\\n                ans+=dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**O(1) Space Optimized**\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans=0,dp1=0,dp2=0;\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp2+=dp1+1;\\n                ans+=dp2;\\n            }\\n            dp1=dp2;\\n            dp2=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans; vector<int>dp(nums.size());\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp[i]=dp[i-1]+1;\\n                ans+=dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int ans=0,dp1=0,dp2=0;\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2]){\\n                dp2+=dp1+1;\\n                ans+=dp2;\\n            }\\n            dp1=dp2;\\n            dp2=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421224,
                "title": "python-o-n-solution-using-simple-math",
                "content": "Main idea is to find all continuous sequence.\\nFor example, `[1,2,3,4,5,7,9,12]`\\nHere we have two such sequences: `[1,2,3,4,5]` and `[5,7,9]`\\n\\nNow we just need to calculate number of slices for each sequence of length > 3.\\nExample: `[1,2,3,4,5]`\\nHere, number of slices of length 5 = 1\\nnumber of slices of length 4 = 2\\nnumber of slices of length 3 = 3\\n\\nThus we can observe that for sequence of length k, number of slices = `1 + 2 + ... + (k-2)`\\nWhich equals `(k-2)(k-2+1)/2  =  (k-2)(k-1)/2` \\n\\n```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        index = 1\\n        output = 0\\n        while index < n:\\n            count = 1\\n            diff = nums[index]-nums[index-1]\\n            while index < n and nums[index]-nums[index-1] == diff:\\n                count += 1\\n                index += 1\\n            if count >= 3:\\n                output += (count-2)*(count-1)//2\\n            \\n        return output\\n```\\n\\nUpvote if it helps :)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        index = 1\\n        output = 0\\n        while index < n:\\n            count = 1\\n            diff = nums[index]-nums[index-1]\\n            while index < n and nums[index]-nums[index-1] == diff:\\n                count += 1\\n                index += 1\\n            if count >= 3:\\n                output += (count-2)*(count-1)//2\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398310,
                "title": "java-3-ways-to-solve-arithmetic-slices",
                "content": "Solution 1\\n```\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\npublic class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        final int N = nums.length;\\n        int[] dp = new int[N];\\n        int res = 0;\\n        for (int i = 2; i < N; i++) {\\n            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nSolution 2\\n```\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution2 {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        final int N = nums.length;\\n        int res = 0, len = 0;\\n        for (int i = 2; i < N; i++) {\\n            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\\n                len++;\\n                res += len;\\n            } else {\\n                len = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nSolution 3\\n```\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        final int N = nums.length;\\n        int res = 0;\\n        for (int i = 2; i < N; i++) {\\n            int len = 1;\\n            while (i < N && nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\\n                i++;\\n                len++;\\n            }\\n            if (len >= 2) {\\n                res += (len-1) * len / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\npublic class Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        final int N = nums.length;\\n        int[] dp = new int[N];\\n        int res = 0;\\n        for (int i = 2; i < N; i++) {\\n            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\\n                dp[i] = dp[i-1] + 1;\\n                res += dp[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution2 {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        final int N = nums.length;\\n        int res = 0, len = 0;\\n        for (int i = 2; i < N; i++) {\\n            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\\n                len++;\\n                res += len;\\n            } else {\\n                len = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        final int N = nums.length;\\n        int res = 0;\\n        for (int i = 2; i < N; i++) {\\n            int len = 1;\\n            while (i < N && nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {\\n                i++;\\n                len++;\\n            }\\n            if (len >= 2) {\\n                res += (len-1) * len / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343471,
                "title": "the-best-worst-method-to-solve-this-problem-using-dp-mcm",
                "content": "This is a variation of matrix chain multiplication.\\n```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3) return 0;\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for(int i = 0; i < n; i++) dp[i][i] = nums[i];\\n        for(int i = 0; i < n - 1; i++){\\n            int j = i + 1;\\n            dp[i][j] = dp[i + 1][j] - dp[i][j - 1];\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++){\\n            int j = i + 2;\\n            if(dp[i + 1][j] == dp[i][j - 1]) dp[i][j] = 1;\\n            else{\\n                dp[i][j] = 0;\\n            }\\n        }\\n        for(int len = 4; len <= n; len++){\\n            for(int i = 0; i < n - len + 1; i++){\\n                int j = i + len - 1;\\n                if(dp[i + 1][j] == dp[i][j - 1] && dp[i + 1][j] != 0) dp[i][j] = dp[i + 1][j] + 1;\\n                else{\\n                    dp[i][j] = dp[i + 1][j];\\n                }\\n            }\\n        }\\n        for(int i = 2; i < n; i++){\\n            ans += dp[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3) return 0;\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for(int i = 0; i < n; i++) dp[i][i] = nums[i];\\n        for(int i = 0; i < n - 1; i++){\\n            int j = i + 1;\\n            dp[i][j] = dp[i + 1][j] - dp[i][j - 1];\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++){\\n            int j = i + 2;\\n            if(dp[i + 1][j] == dp[i][j - 1]) dp[i][j] = 1;\\n            else{\\n                dp[i][j] = 0;\\n            }\\n        }\\n        for(int len = 4; len <= n; len++){\\n            for(int i = 0; i < n - len + 1; i++){\\n                int j = i + len - 1;\\n                if(dp[i + 1][j] == dp[i][j - 1] && dp[i + 1][j] != 0) dp[i][j] = dp[i + 1][j] + 1;\\n                else{\\n                    dp[i][j] = dp[i + 1][j];\\n                }\\n            }\\n        }\\n        for(int i = 2; i < n; i++){\\n            ans += dp[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072158,
                "title": "recursive-java-solution-with-explanation-how-recursion-is-working-here",
                "content": "class Solution {\\n    int numOfArthSlices = 0;\\n    public int numberOfArithmeticSlices(int[] A) {\\n        slices(A, A.length-1);\\n        return numOfArthSlices;\\n    }\\n    \\n    public int slices(int[] a, int i) {\\n        if(i < 2)\\n            return 0;\\n        int ap = 0;\\n        if(a[i]-a[i-1] == a[i-1]-a[i-2]) {\\n            ap = 1 + slices(a, i-1);\\n            numOfArthSlices = numOfArthSlices + ap;\\n        }\\n        else\\n            slices(a, i-1);\\n        return ap;\\n    }\\n}\\n\\n/*understand how this recursion is working so below is the order in which recursion happens\\n[step 1] s(a,i=3) {ap= 1+s(a,i=2) sum ?}\\n[step 2] s(a,i=2) {ap = 1+s(a,i=1) sum ?}\\n[step 3] s(a,i=1) return 0 \\n\\nso the approach here is if we have 3 elements in ap with a common difference of d then if include one more element and it also has a common difference of d then that means the new number of slices will be 1 more than whatever number of slices we had till these first 3 elements and if the newly added element does not have the same common difference d then there is no point of seeing more elements with start as the first element of these 3 elements and hence we move forward by 1 element and start again\\n\\nthis is a top down approach now if you see at \\n[step 3] then you will see the sum is 0 and ap is 0 there array is [1,2,3,4]\\n[step 2] then you will see the sum is 1 and ap is 1 there array is [1,2,3]\\n[step 1] then you will see the sum is 3 and ap is 2 there array is [1,2]\\n\\nin [step 1] we have 2 elements [1,2] and then we include 1 more element in [step 2] that is [1,2,3] and see if it has the same d as these 2 elements if yes the we will have ap = 1 more then that we had with just 2 elements therefore ap = 1+slices(a,2(lenght if the array which means i = 1))\\n\\nsimilarly in [step 2] we have 3 elements that is[1,2,3] and then we include 1 more same as above explanation  and now the array becomes [1,2,3,4]\\n*/",
                "solutionTags": [],
                "code": "class Solution {\\n    int numOfArthSlices = 0;\\n    public int numberOfArithmeticSlices(int[] A) {\\n        slices(A, A.length-1);\\n        return numOfArthSlices;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1071566,
                "title": "c-maths-100-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        //return 0 if A is empty\\n\\t\\t\\n        if(A.size()==0){\\n            return 0;\\n        }\\n\\n\\n        //take a variable count to store the answer\\n        int count = 0 ;\\n        \\n        //counter will keep the count of consecutive occuring same difference\\n        //lastNum will keep track of last difference\\n        int lastNum = INT_MAX , counter = 1;\\n\\n        for(int i=0 ; i<A.size()-1  ;  i++ ){\\n            \\n            //val is difference of two consecutive numbers \\n            int val =  A[i]  -  A[i+1]  ;\\n            if(val == lastNum){\\n                //if val is same as last num , increase the counter\\n                counter++;\\n            }else{\\n                //if val is not same as last num then , \\n                // use it like this\\n                //for ex we have counter = 3 , then we have 3 times occurance of same difference\\n                //let it is 2 , 2 , 2\\n                // so we can have these options [2,2] , [2,2] , [2,2,2]\\n                //this means sum of natural numbers till counter-1\\n                //hence formula is n*(n+1)/2 , put counter-1 in formula\\n                //we get ans = (counter-1)*(counter)/2\\n                \\n                count  +=   ( (counter)*(counter-1) )/2;\\n                lastNum = val;\\n                counter = 1;\\n            }\\n            \\n        }\\n\\n        count  +=   ((counter)*(counter-1))/2;\\n        \\n        //return ans\\n        return  count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        //return 0 if A is empty\\n\\t\\t\\n        if(A.size()==0){\\n            return 0;\\n        }\\n\\n\\n        //take a variable count to store the answer\\n        int count = 0 ;\\n        \\n        //counter will keep the count of consecutive occuring same difference\\n        //lastNum will keep track of last difference\\n        int lastNum = INT_MAX , counter = 1;\\n\\n        for(int i=0 ; i<A.size()-1  ;  i++ ){\\n            \\n            //val is difference of two consecutive numbers \\n            int val =  A[i]  -  A[i+1]  ;\\n            if(val == lastNum){\\n                //if val is same as last num , increase the counter\\n                counter++;\\n            }else{\\n                //if val is not same as last num then , \\n                // use it like this\\n                //for ex we have counter = 3 , then we have 3 times occurance of same difference\\n                //let it is 2 , 2 , 2\\n                // so we can have these options [2,2] , [2,2] , [2,2,2]\\n                //this means sum of natural numbers till counter-1\\n                //hence formula is n*(n+1)/2 , put counter-1 in formula\\n                //we get ans = (counter-1)*(counter)/2\\n                \\n                count  +=   ( (counter)*(counter-1) )/2;\\n                lastNum = val;\\n                counter = 1;\\n            }\\n            \\n        }\\n\\n        count  +=   ((counter)*(counter-1))/2;\\n        \\n        //return ans\\n        return  count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071517,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nint numberOfArithmeticSlices(int* A, int len){\\n        if(len<3)return 0;\\n        int temp[len-1];\\n        for(int i=1;i<len;i++){\\n                temp[i-1]=A[i]-A[i-1];\\n        }\\n        int result=0,k=1;\\n        for(int i=1;i<len-1;i++){\\n                if(temp[i]==temp[i-1]){\\n                        k++;\\n                }else{\\n                        result += (k*(k-1))/2;\\n                        k=1;\\n                }\\n        }\\n        result += k*(k-1)/2;\\n        return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfArithmeticSlices(int* A, int len){\\n        if(len<3)return 0;\\n        int temp[len-1];\\n        for(int i=1;i<len;i++){\\n                temp[i-1]=A[i]-A[i-1];\\n        }\\n        int result=0,k=1;\\n        for(int i=1;i<len-1;i++){\\n                if(temp[i]==temp[i-1]){\\n                        k++;\\n                }else{\\n                        result += (k*(k-1))/2;\\n                        k=1;\\n                }\\n        }\\n        result += k*(k-1)/2;\\n        return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071127,
                "title": "js-python-java-c-easy-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nIt\\'s obviously very easy to find the difference between consecutive elements of an array, so it should also be a simple matter to iterate through the input array (**A**) and use a variable (**diff**) to keep track of what the most recently seen difference is and another variable (**count**) to keep track of how many consecutive elements make up the current streak.\\n\\nSome basic math will tell us that the number of possible combinations for a given **count** is a triangular number: with **4** numbers, for example, it\\'s possible to make up **10** (**1+2+3+4**) different number combinations ranging in length from **1** to **4**.\\n\\nThe problem states that our minimum slice is **3** numbers, but since **3** numbers is actually **2** differences, and we\\'re dealing with differences, we\\'ll use **2** instead of **3** here. The number of **2+** length combinations is just a **0-indexed triangular number** instead of a **1-indexed triangular number**. So as in our earlier example, **4** consecutive differences yields **6** (**0+1+2+3**) possible combinations.\\n\\nBut rather than obtaining a **count** and then using the 0-indexed triangular number equation (**n * (n - 1) / 2**), we can just build this triangular number iteratively, since we\\'re iterating anyway.\\n\\nNormally, when building a triangular number iteratively, you would *first* increment the **count** and *then* add that **count** to the **ans**. In this case, we can either start the **count** at **-1**, or wait until *after* adding **count** to **ans** to increment **count**.\\n\\nDoing this, we can find our answer easily in O(n) time with minimal processing overhead.\\n\\n---\\n\\n***Implementation:***\\n\\nTechnically, this problem doesn\\'t list a constraint for the values in **A**. Since we\\'re storing the difference between two elements in a variable, that could cause problems if the numbers range too broadly.\\n\\nTo get around that, we\\'d have to perform even more array calls on each iteration to avoid storing the differences in variables.\\n\\nAlso, Java and C++ have typed variables, so we can just use the max int value for the starting value of **diff**.\\n\\nOtherwise, we\\'d have to set the initial **diff** to **A[1] - A[0]**, the initial **count** to **1**, start our iteration at **i = 2**, and lead with an **if** statement to prevent situations where those array calls go out-of-bounds.\\n\\nGiven all of that, I opted for the somewhat safe assumption that there\\'s some kind of reasonable constraint, but I figured it would be wise to at least point that out here.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.3MB** (beats 96% / 74%).\\n```javascript\\nvar numberOfArithmeticSlices = function(A) {\\n    let count = 0, diff, ans = 0\\n    for (let i = 1; i < A.length; i++) {\\n        let newDiff = A[i] - A[i-1]\\n        if (newDiff === diff) ans += count++\\n        else diff = newDiff, count = 1\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 100% / 100%).\\n```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        count, ans, diff = 0, 0, None\\n        for i in range(1, len(A)):\\n            newDiff = A[i] - A[i-1]\\n            if newDiff == diff:\\n                ans += count\\n                count += 1\\n            else:\\n                diff = newDiff\\n                count = 1\\n        return ans\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int count = 0, ans = 0, diff = Integer.MAX_VALUE;\\n        for (int i = 1; i < A.length; i++) {\\n            int newDiff = A[i] - A[i-1];\\n            if (newDiff == diff) ans += count++;\\n            else {\\n                diff = newDiff;\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.2MB** (beats 100% / 87%).\\n```c++\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int count = 0, ans = 0, diff = INT_MAX;\\n        for (int i = 1; i < A.size(); i++) {\\n            int newDiff = A[i] - A[i-1];\\n            if (newDiff == diff) ans += count++;\\n            else {\\n                diff = newDiff;\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar numberOfArithmeticSlices = function(A) {\\n    let count = 0, diff, ans = 0\\n    for (let i = 1; i < A.length; i++) {\\n        let newDiff = A[i] - A[i-1]\\n        if (newDiff === diff) ans += count++\\n        else diff = newDiff, count = 1\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        count, ans, diff = 0, 0, None\\n        for i in range(1, len(A)):\\n            newDiff = A[i] - A[i-1]\\n            if newDiff == diff:\\n                ans += count\\n                count += 1\\n            else:\\n                diff = newDiff\\n                count = 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] A) {\\n        int count = 0, ans = 0, diff = Integer.MAX_VALUE;\\n        for (int i = 1; i < A.length; i++) {\\n            int newDiff = A[i] - A[i-1];\\n            if (newDiff == diff) ans += count++;\\n            else {\\n                diff = newDiff;\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) {\\n        int count = 0, ans = 0, diff = INT_MAX;\\n        for (int i = 1; i < A.size(); i++) {\\n            int newDiff = A[i] - A[i-1];\\n            if (newDiff == diff) ans += count++;\\n            else {\\n                diff = newDiff;\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071069,
                "title": "o-n-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) \\n    {\\n        int ans=0,sz=A.size();\\n        if(sz<=2)\\n        {\\n            return 0;\\n        }\\n        int dp[sz];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=2;i<sz;i++)\\n        {\\n            if(A[i]-A[i-1]==A[i-1]-A[i-2])\\n            {\\n                dp[i]=dp[i-1]+1;\\n                ans+=dp[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArithmeticSlices(vector<int>& A) \\n    {\\n        int ans=0,sz=A.size();\\n        if(sz<=2)\\n        {\\n            return 0;\\n        }\\n        int dp[sz];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=2;i<sz;i++)\\n        {\\n            if(A[i]-A[i-1]==A[i-1]-A[i-2])\\n            {\\n                dp[i]=dp[i-1]+1;\\n                ans+=dp[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071020,
                "title": "java-o-n-sliding-window-0ms-faster-than-100-easy-with-explain-in-detail",
                "content": "idea is to take a window of 3 three adjacent numbers with same common diff and try to entend the window \\nas far as possible . and while extending the window check if the window size >= 3 , if yes then for every iteration of extending the window we will have = i - 2 - start + 1 sub arrays , this formula is an observation\\n\\nidea for formula is that conisder [1,2,3,4]\\nfor i == 2 , we need 3 numbers , ie the number should start for i - 2 ie 0 \\nso for i = 2 and start = 0 how many windows we can have of size 3 ? \\n[1,2,3] , i - 2 - start + 1  = 1 subarray\\n\\nagain for i = 3 we need atleast 3 numbers in window , we can have more but we need minimum 3 number so how many windows we can have for i = 3 and start = 0 ?\\n[1 , 2 ,3 ,4 ] , [2 , 3 , 4]  , i - 2 - start + 1  = 2 subarray\\n\\n so see for any i if we know the start index from where the window might start we can have atmost i - 2 - start + 1\\n windows \\n \\n now the ans would be the sum of  number of all such sub arrays for every valid i  \\n \\n this is similar to asking -> given an index i and a starting position , how may sub arrays can be formed which include the index i \\n\\n consider -> [1,2,3,4]  , s = 0  and i = 2 \\n \\n we can see there are 3 subarays [1,2,3] , [2,3] and [3]  which include i = 2 and the number is is equal to i - s + 1 \\n \\n so for every valid i in a series we need to calculate the all such subaraays which include i - 2 th index starting from \\n the beginning index of the series \\n and ans is the cumulative sum of all such sub arrays\\n \\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length ;\\n        if(n < 3)\\n            return 0 ;\\n        int cnt = 0 , start = 0;\\n        for(int i = 1 ; i < n ; i++){\\n            \\n            if(i + 1 < n && nums[i] - nums[i - 1] == nums[i + 1] - nums[i]){\\n                start = i - 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// try to extend the window as far as possible while the condition is satisfied \\n\\t\\t\\t\\t\\n                while(i + 1 < n && nums[i] - nums[i - 1] == nums[i + 1] - nums[i]){\\n                    i++;\\n                    if(i - start + 1 > 2)\\n                        cnt += i - 2 - start + 1;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] nums) {\\n        int n = nums.length ;\\n        if(n < 3)\\n            return 0 ;\\n        int cnt = 0 , start = 0;\\n        for(int i = 1 ; i < n ; i++){\\n            \\n            if(i + 1 < n && nums[i] - nums[i - 1] == nums[i + 1] - nums[i]){\\n                start = i - 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// try to extend the window as far as possible while the condition is satisfied \\n\\t\\t\\t\\t\\n                while(i + 1 < n && nums[i] - nums[i - 1] == nums[i + 1] - nums[i]){\\n                    i++;\\n                    if(i - start + 1 > 2)\\n                        cnt += i - 2 - start + 1;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071018,
                "title": "rust-solution-using-formula",
                "content": "```rust\\nimpl Solution {\\n    pub fn number_of_arithmetic_slices(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut n = 0;\\n        for i in 2..a.len() {\\n            if a[i] - a[i - 1] == a[i - 1] - a[i - 2] {\\n                n += 1;\\n            } else {\\n                answer += n * (n + 1) / 2;\\n                n = 0;\\n            }\\n        }\\n        answer + n * (n + 1) / 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn number_of_arithmetic_slices(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut n = 0;\\n        for i in 2..a.len() {\\n            if a[i] - a[i - 1] == a[i - 1] - a[i - 2] {\\n                n += 1;\\n            } else {\\n                answer += n * (n + 1) / 2;\\n                n = 0;\\n            }\\n        }\\n        answer + n * (n + 1) / 2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025130,
                "title": "sliding-window",
                "content": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        l = 0\\n        res = 0\\n        for r, num in enumerate(A):\\n            if r - l < 2:\\n                continue\\n            if num - A[r-1] == A[l+1] - A[l]:\\n                res += r - l - 1\\n            else:\\n                l = r - 1\\n        return res\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, A: List[int]) -> int:\\n        l = 0\\n        res = 0\\n        for r, num in enumerate(A):\\n            if r - l < 2:\\n                continue\\n            if num - A[r-1] == A[l+1] - A[l]:\\n                res += r - l - 1\\n            else:\\n                l = r - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914941,
                "title": "413-arithmetic-slices-java",
                "content": "My Zero ms code-java\\n```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] array) \\n    {\\n        int d=0;\\n\\t   int c=0;\\n\\t   for(int i=0;i<array.length-1;i++)\\n\\t   {   d=array[i]-array[i+1];\\n\\t\\t   for(int j=i+1;j<array.length-1;j++)\\n\\t\\t   {\\n\\t\\t\\t   if(d==array[j]-array[j+1])\\n\\t\\t\\t\\t ++c;\\n\\t\\t\\t   else\\n\\t\\t\\t\\t   break;\\n\\t\\t   }\\n\\t   }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArithmeticSlices(int[] array) \\n    {\\n        int d=0;\\n\\t   int c=0;\\n\\t   for(int i=0;i<array.length-1;i++)\\n\\t   {   d=array[i]-array[i+1];\\n\\t\\t   for(int j=i+1;j<array.length-1;j++)\\n\\t\\t   {\\n\\t\\t\\t   if(d==array[j]-array[j+1])\\n\\t\\t\\t\\t ++c;\\n\\t\\t\\t   else\\n\\t\\t\\t\\t   break;\\n\\t\\t   }\\n\\t   }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566425,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1571690,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1571689,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1680825,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1847496,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1958861,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1919134,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1800855,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1986432,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1911092,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566425,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1571690,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1571689,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1680825,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1847496,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1958861,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1919134,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1800855,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1986432,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            },
            {
                "id": 1911092,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/arithmetic-slices/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force \n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Recursion\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Constant Space Dynamic Programming\n\n  \n**Approach 6:** Using Formula\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "shenrf22",
                        "content": "I want to say that the description is a little bit of confused. \\nFor example, [1,2,3,4,5]\\nthe answer is 6: [1,2,3][2,3,4][3,4,5][1,2,3,4][2,3,4,5][1,2,3,4,5]\\nWhat about the [1,3,5] ?\\nDo we allow to construct the array this way?"
                    },
                    {
                        "username": "Sajib67",
                        "content": "should return only the number of sub-array(continuous segment of array)"
                    },
                    {
                        "username": "user0709Y",
                        "content": "only consecutive number"
                    },
                    {
                        "username": "Frank1993",
                        "content": "I am confused with this problem, suppose we have [1,2,3,4,5,6] as inputs, then we can get these slice:\\n\\n[1,2,3]\\n[2,3,4]\\n[3,4,5]\\n[4,5,6]\\n[1,2,3,4]\\n[2,3,4,5]\\n[3,4,5,6]\\n[1,2,3,4,5]\\n[2,3,4,5,6]\\n[1,2,3,4,5,6]\\n[1,3,5]\\n[2,4,6]\\n\\nit has 12 slices, is there any problem ?\\n\\nThanks a lot"
                    },
                    {
                        "username": "taricpinkfriend",
                        "content": "subarrays are defined to be *contiguous* in the question.\nfor example, the subarrays `[1,3,5],[2,4,6]` listed above are not contiguous."
                    },
                    {
                        "username": "steve_godly",
                        "content": "All 15 / 15 test cases are passed, however it shows a time limit exceeded error."
                    },
                    {
                        "username": "namandt",
                        "content": "VERY POORLY STATED DESCRIPTION OF THE PROBLEM\n\n `An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.`\n\n\nlets take an example [1, 3, 5]\ndifference b/w any two consecutive elements\nNow lets take any two consecutive elements -> [1, 3]\nnow difference of it = 1 - 3 = -2 = |-2| = 2\n\nok its 2.\n\ndifference between any two consecutive elements is same.\n\nsame to what???????\n\nI found two consecutive elements -> [1, 3]. its difference is same?\nsame to fucking what?????\n\n\nDude whoever wrote the problem statement: PLS READ AFTER YOU WRITE .\n\nyou need to say that any two pair of consecutive elements have same difference!!!!!\n\nthere has to be two pair of consecutive elements to compare their FUCKING DIFFERENCE!!!\n\nI did not even understand the statement and saw 65% acceptance\nI meant like I didnt even understand the question thousands of hundreds have passed??\n\nHow on earth!!!\n\nEDIT1:\n\n\nhahaha.\nStill got it wrong!\n\nNow understood.\n\nthis difference has to be same across each and every consecutive elements!\n\nit makes me more mad!!!!\n\nSay \n`An integer array is called arithmetic if it consists of at least three elements and if the difference between EVERY FUCKING two consecutive elements is the same.`"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Tag says  dynamic programming but the first thing i thought  about while seeing the problem is sliding window, and solved it using the same too"
                    },
                    {
                        "username": "sodablockgaming",
                        "content": "Same. Technically, I suppose that the sliding window solution has one sliding window and then one pointer. The sliding window to check each batch of 3 numbers, and then a pointer that extends past the right bound of the window for as long as the slice remains valid."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach:-** ***(0ms)***\\n\\n- Initialize variables: Set the length of the input array nums to n and initialize the count variable to 0.\\n\\n- Check if the array length is less than 3: If n is less than 3, there won\\'t be any arithmetic slices. Return 0 as the result.\\n\\n- Iterate through the array: Start a loop from index 0 to n - 2. This loop represents the possible starting indices of arithmetic slices.\\n\\n- Calculate the difference: For each index i, calculate the difference between nums[i + 1] and nums[i]. Store this difference in the variable diff.\\n\\n- Find arithmetic slices: Start another loop from index i + 2 to the end of the array. This loop represents the possible ending indices of arithmetic slices.\\n\\n- Check the difference: For each index j, check if the difference between nums[j] and nums[j - 1] is equal to diff. If it is, increment the count variable.\\n\\n- Break the inner loop: If the difference between consecutive elements changes, break out of the inner loop since there won\\'t be any more arithmetic slices starting from this index.\\n\\n- Continue the outer loop: Continue the outer loop to check for more arithmetic slices starting from the next index.\\n\\n- Return the count: After the loops complete, return the count variable, which represents the total number of arithmetic slices in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-***\\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3605642/easiest-solution-beginner-friendly-0ms-two-loops/"
                    },
                    {
                        "username": "steeldebil",
                        "content": "I think this problem should be marked as simple, since the O(n^2) solution is ok, especially considering the series of medium problems \"best time to buy and sell stocks\""
                    },
                    {
                        "username": "xcesiv",
                        "content": "I agree, it felt more \"easy\" than \"medium\" as expected."
                    },
                    {
                        "username": "phalkey89",
                        "content": "for case [1,2,3,4,5]   o/p is 6\n(5-2)+(5-3)+(5-4)\n5+5+5 - (2+3+4)\n5*3 - ((1+2+3+4+5)-(1+5))\n(n*(n-2))-((((n+1)*n)/2) - (1+n))   !!\n\njust find the length of sequence (window)      \nwhich is n ,\nuse the above formula to get all the subarrays \n\nhttps://leetcode.com/problems/arithmetic-slices/solutions/3816544/n-n-2-n-1-n-2-1-n-simple-trick/"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[1,2,3,8,9,10]\\nwhy it should be 5 not 2?\\nThere are only two correct slices, [1,2,3] and [8,9,10].\\n\"the difference between any two consecutive elements is the same.\"\\nfor example, in subarray [2,3,8,9] the difference is not the same between any consecutive element. \\n\\n"
                    }
                ]
            }
        ]
    }
]