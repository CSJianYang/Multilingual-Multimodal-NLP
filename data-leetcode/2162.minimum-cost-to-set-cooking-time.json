[
    {
        "title": "Minimum Cost to Set Cooking Time",
        "question_content": "A generic microwave supports cooking times for:\n\n\tat least 1 second.\n\tat most 99 minutes and 99 seconds.\n\nTo set the cooking time, you push at most four digits. The microwave normalizes what you push as four digits by prepending zeroes. It interprets the first two digits as the minutes and the last two digits as the seconds. It then adds them up as the cooking time. For example,\n\n\tYou push 9 5 4 (three digits). It is normalized as 0954 and interpreted as 9 minutes and 54 seconds.\n\tYou push 0 0 0 8 (four digits). It is interpreted as 0 minutes and 8 seconds.\n\tYou push 8 0 9 0. It is interpreted as 80 minutes and 90 seconds.\n\tYou push 8 1 3 0. It is interpreted as 81 minutes and 30 seconds.\n\nYou are given integers startAt, moveCost, pushCost, and targetSeconds. Initially, your finger is on the digit startAt. Moving the finger above any specific digit costs moveCost units of fatigue. Pushing the digit below the finger once costs pushCost units of fatigue.\nThere can be multiple ways to set the microwave to cook for targetSeconds seconds but you are interested in the way with the minimum cost.\nReturn the minimum cost to set targetSeconds seconds of cooking time.\nRemember that one minute consists of 60 seconds.\n&nbsp;\nExample 1:\n\nInput: startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\nOutput: 6\nExplanation: The following are the possible ways to set the cooking time.\n- 1 0 0 0, interpreted as 10 minutes and 0 seconds.\n&nbsp; The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).\n&nbsp; The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n&nbsp; The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n&nbsp; The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n&nbsp; The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n&nbsp; The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.\n\nExample 2:\n\nInput: startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\nOutput: 6\nExplanation: The optimal way is to push two digits: 7 6, interpreted as 76 seconds.\nThe finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\nNote other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.\n\n&nbsp;\nConstraints:\n\n\t0 <= startAt <= 9\n\t1 <= moveCost, pushCost <= 105\n\t1 <= targetSeconds <= 6039",
        "solutions": [
            {
                "id": 1746988,
                "title": "python3-java-c-combinations-of-minutes-and-seconds-o-1",
                "content": "**Explanation**: \\n* The maximum possible minutes are: `targetSeconds` / 60\\n* Check for all possible minutes from 0 to `maxmins` and the corresponding seconds\\n* `cost` function returns the cost for given minutes and seconds\\n* `moveCost` is added to current cost if the finger position is not at the correct number\\n* `pushCost` is added for each character that is pushed\\n* Maintain the minimum cost and return it\\n\\n*Note*: We are multiplying `mins` by 100 to get it into the format of the microwave\\nLet\\'s say `mins` = 50,`secs` = 20\\nOn the microwave we want 5020\\nFor that we can do: 50 * 100 + 20 = 5020\\n<iframe src=\"https://leetcode.com/playground/eJoNqmaV/shared\" frameBorder=\"0\" width=\"780\" height=\"420\"></iframe>\\n\\nOn further inspection we can deduce that we only really have 2 cases:\\n`maxmins`, `secs`\\n`maxmins - 1`, `secs + 60`\\n<iframe src=\"https://leetcode.com/playground/VYzZV9Nh/shared\" frameBorder=\"0\" width=\"780\" height=\"370\"></iframe>\\n\\nSince maximum length of characters displayed on microwave = 4, `Time Complexity =  O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "**Explanation**: \\n* The maximum possible minutes are: `targetSeconds` / 60\\n* Check for all possible minutes from 0 to `maxmins` and the corresponding seconds\\n* `cost` function returns the cost for given minutes and seconds\\n* `moveCost` is added to current cost if the finger position is not at the correct number\\n* `pushCost` is added for each character that is pushed\\n* Maintain the minimum cost and return it\\n\\n*Note*: We are multiplying `mins` by 100 to get it into the format of the microwave\\nLet\\'s say `mins` = 50,`secs` = 20\\nOn the microwave we want 5020\\nFor that we can do: 50 * 100 + 20 = 5020\\n<iframe src=\"https://leetcode.com/playground/eJoNqmaV/shared\" frameBorder=\"0\" width=\"780\" height=\"420\"></iframe>\\n\\nOn further inspection we can deduce that we only really have 2 cases:\\n`maxmins`, `secs`\\n`maxmins - 1`, `secs + 60`\\n<iframe src=\"https://leetcode.com/playground/VYzZV9Nh/shared\" frameBorder=\"0\" width=\"780\" height=\"370\"></iframe>\\n\\nSince maximum length of characters displayed on microwave = 4, `Time Complexity =  O(1)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1747626,
                "title": "two-choices",
                "content": "We have only two choices:\\n1. Punch `minutes` and `seconds` as is,\\n2. or punch `minutes - 1` and `seconds + 60`.\\n\\nWe just need to check that the number of minutes and seconds is valid (positive and less than 99).\\n\\nFor example, for `6039` seconds, we can only use the second option (`99:99`), as the first option is invalid (`100:39`).\\n\\n**C++**\\n```cpp\\nint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    auto cost = [&](int pos, int m, int s){\\n        if (min(m, s) < 0 || max(m, s) > 99)\\n            return INT_MAX;\\n        int res = 0;\\n        for (auto digit : to_string(m * 100 + s)) {\\n            res += pushCost + (pos == digit - \\'0\\' ? 0 : moveCost);\\n            pos = digit - \\'0\\';\\n        }\\n        return res;\\n    };\\n    int m = targetSeconds / 60, s = targetSeconds % 60;\\n    return min(cost(startAt, m, s), cost(startAt, m - 1, s + 60));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    auto cost = [&](int pos, int m, int s){\\n        if (min(m, s) < 0 || max(m, s) > 99)\\n            return INT_MAX;\\n        int res = 0;\\n        for (auto digit : to_string(m * 100 + s)) {\\n            res += pushCost + (pos == digit - \\'0\\' ? 0 : moveCost);\\n            pos = digit - \\'0\\';\\n        }\\n        return res;\\n    };\\n    int m = targetSeconds / 60, s = targetSeconds % 60;\\n    return min(cost(startAt, m, s), cost(startAt, m - 1, s + 60));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747352,
                "title": "c-brute-force-solution-with-detailed-explanation",
                "content": "The main aim of the solution is to generate all possible ways to generate the required time, and then calculating the cost of each of them while returning the minimum one. \\n\\n***Note***: I am not actually generating all the possible outcomes, like for target as 600second, when taken as 9 mins 60 second, the possible buttons to be pushed can be *\"0960\"* and *\"960\"*. But I am not generating *\"0960\"* as it will require pushing an extra button which will obviously increase the cost, so no point in considering it. \\n\\n**Explaination of Code** \\nSection 1:\\nHere the target seconds are reduced till they are 2 digits or less, if they are of 3 digits or more, they can not be put in the timer as only 2 digits are allowed in microwave for seconds. \\nEg: for 600 seconds will reduced to 9 mins, 60 second, (mins = 9, tar = 60)\\n\\nSection 2:\\nHere I am generating different ways of pushing buttons in form of string by reducing seconds(*tar*) and increasing minutes(*mins*)\\nEg: \"960\" is pushed as a possible string in vector *ways*, mins = 10, and tar = 0, which leads to exiting the loop\\n\\nSection 3:\\nSection 2 ends when seconds are less than 60(*tar<60*), So now, if there is a possible way(mins < 100) that can be consi, I am storing it in the *ways* vector\\nEg: \"1000\" is pushed as a possible string in vector *ways*\\n\\nSection 4:\\nFor all possible ways(strings in *ways*) we calculate the cost, and then return the minimum one\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int start, int move, int push, int tar) {\\n        vector<string> ways;\\n        int mins = 0; \\n\\t\\t\\n\\t\\t//Section 1\\n        while(tar >= 100)\\n        {\\n            mins++;\\n            tar -= 60;\\n        }\\n        string s = \"\";\\n        \\n\\t\\t\\n\\t\\t//Section 2\\n        while(tar >= 60)\\n        {\\n            s = \"\";\\n            if(mins != 0)\\n                s += to_string(mins);\\n            s += to_string(tar);\\n            ways.push_back(s);\\n            tar -= 60;\\n            mins++;\\n        }\\n        \\n\\t\\t//Section 3\\n        s = \"\";\\n        if(mins >= 100)\\n            goto section4;\\n        if(mins != 0)\\n            s += to_string(mins);\\n        if(tar >= 10)\\n            s += to_string(tar);\\n        else if(tar>0 and tar < 10)\\n        {\\n            if(mins != 0)\\n                s += \"0\" + to_string(tar);\\n            else s += to_string(tar);\\n        }\\n        else if(tar == 0)\\n            s += \"00\";\\n        ways.push_back(s);\\n        \\n\\t\\t\\n\\t\\t//Section 4\\n        section4:\\n        int ans = INT_MAX; \\n        for(auto s : ways)\\n        {\\n            //cout<<s<<\" \";\\n            int len = s.size(); \\n            int sub = 0; \\n            char cur = to_string(start)[0];\\n            for(int i =0; i<len; i++)\\n            {\\n                if(cur != s[i])\\n                {\\n                    sub += move;\\n                    cur = s[i];\\n                }\\n                sub += push;\\n            }\\n            //cout<<sub<<endl;\\n            ans = min(ans, sub);\\n        }\\n        \\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int start, int move, int push, int tar) {\\n        vector<string> ways;\\n        int mins = 0; \\n\\t\\t\\n\\t\\t//Section 1\\n        while(tar >= 100)\\n        {\\n            mins++;\\n            tar -= 60;\\n        }\\n        string s = \"\";\\n        \\n\\t\\t\\n\\t\\t//Section 2\\n        while(tar >= 60)\\n        {\\n            s = \"\";\\n            if(mins != 0)\\n                s += to_string(mins);\\n            s += to_string(tar);\\n            ways.push_back(s);\\n            tar -= 60;\\n            mins++;\\n        }\\n        \\n\\t\\t//Section 3\\n        s = \"\";\\n        if(mins >= 100)\\n            goto section4;\\n        if(mins != 0)\\n            s += to_string(mins);\\n        if(tar >= 10)\\n            s += to_string(tar);\\n        else if(tar>0 and tar < 10)\\n        {\\n            if(mins != 0)\\n                s += \"0\" + to_string(tar);\\n            else s += to_string(tar);\\n        }\\n        else if(tar == 0)\\n            s += \"00\";\\n        ways.push_back(s);\\n        \\n\\t\\t\\n\\t\\t//Section 4\\n        section4:\\n        int ans = INT_MAX; \\n        for(auto s : ways)\\n        {\\n            //cout<<s<<\" \";\\n            int len = s.size(); \\n            int sub = 0; \\n            char cur = to_string(start)[0];\\n            for(int i =0; i<len; i++)\\n            {\\n                if(cur != s[i])\\n                {\\n                    sub += move;\\n                    cur = s[i];\\n                }\\n                sub += push;\\n            }\\n            //cout<<sub<<endl;\\n            ans = min(ans, sub);\\n        }\\n        \\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1747163,
                "title": "java-easy-brute-force-short-and-understandable-code",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int tar) {\\n     \\n        int min=tar/60, sec=tar%60, minCost=(moveCost+pushCost)*4;\\n        \\n        if(min>99) { min--; sec+=60; } // this is required to do because if tar>=6000 then min is 100 which is not possible as it atmost can be 99mins\\n        \\n        while(min>=0&&sec<=99) { // this while loop will work for atmost 2 iterations\\n            tar=min*100+sec;\\n            char arr[]=(\"\"+tar).toCharArray();\\n            int sameMove=0;\\n            for(int i=0;i<arr.length-1;i++)\\n                if(arr[i]==arr[i+1])\\n                    sameMove++;\\n            if(startAt==arr[0]-\\'0\\')\\n                minCost=Math.min(minCost,pushCost*arr.length+moveCost*(arr.length-1-sameMove));\\n            else\\n                minCost=Math.min(minCost,pushCost*arr.length+moveCost*(arr.length-sameMove));\\n            min--; sec+=60;\\n        }\\n        return minCost;\\n    }\\n}\\n````\\nI really hope you like the solution!!!\\nIf it was helpful then please **upvote** it:))",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int tar) {\\n     \\n        int min=tar/60, sec=tar%60, minCost=(moveCost+pushCost)*4;\\n        \\n        if(min>99) { min--; sec+=60; } // this is required to do because if tar>=6000 then min is 100 which is not possible as it atmost can be 99mins\\n        \\n        while(min>=0&&sec<=99) { // this while loop will work for atmost 2 iterations\\n            tar=min*100+sec;\\n            char arr[]=(\"\"+tar).toCharArray();\\n            int sameMove=0;\\n            for(int i=0;i<arr.length-1;i++)\\n                if(arr[i]==arr[i+1])\\n                    sameMove++;\\n            if(startAt==arr[0]-\\'0\\')\\n                minCost=Math.min(minCost,pushCost*arr.length+moveCost*(arr.length-1-sameMove));\\n            else\\n                minCost=Math.min(minCost,pushCost*arr.length+moveCost*(arr.length-sameMove));\\n            min--; sec+=60;\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746996,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def count_cost(minutes, seconds): # Calculates cost for certain configuration of minutes and seconds\\n            time = f\\'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}\\' # mm:ss\\n            time = time.lstrip(\\'0\\') # since 0\\'s are prepended we remove the 0\\'s to the left to minimize cost\\n            t = [int(i) for i in time]\\n            current = startAt\\n            cost = 0\\n            for i in t:\\n                if i != current:\\n                    current = i\\n                    cost += moveCost\\n                cost += pushCost\\n            return cost\\n        ans = float(\\'inf\\')\\n        for m in range(100): # Check which [mm:ss] configuration works out\\n            for s in range(100):\\n                if m * 60 + s == targetSeconds: \\n                    ans = min(ans, count_cost(m, s))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def count_cost(minutes, seconds): # Calculates cost for certain configuration of minutes and seconds\\n            time = f\\'{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}\\' # mm:ss\\n            time = time.lstrip(\\'0\\') # since 0\\'s are prepended we remove the 0\\'s to the left to minimize cost\\n            t = [int(i) for i in time]\\n            current = startAt\\n            cost = 0\\n            for i in t:\\n                if i != current:\\n                    current = i\\n                    cost += moveCost\\n                cost += pushCost\\n            return cost\\n        ans = float(\\'inf\\')\\n        for m in range(100): # Check which [mm:ss] configuration works out\\n            for s in range(100):\\n                if m * 60 + s == targetSeconds: \\n                    ans = min(ans, count_cost(m, s))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747026,
                "title": "c-all-combination-brute-force-easy-readable",
                "content": "```\\nclass Solution {\\npublic:\\n    //finding answer of every possible minute that equal to targetSecond\\n    int solve(vector<int> &a,int sa, int mc, int pc){\\n        int ans = 0;\\n        if(a[0] != sa){\\n            ans += mc;\\n        }\\n        ans += pc;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i] != a[i-1]){\\n                ans += mc;\\n            }\\n            ans += pc;\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    int minCostSetTime(int sa, int mc, int pc, int ts) {\\n        int cost = 1e8;\\n        //trying all permutation\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                int min = i*10+j; // minutes\\n                for(int k=0;k<=9;k++){\\n                    for(int l=0;l<=9;l++){\\n\\t\\t\\t\\t\\t    int sec = k*10 + l;//seconds\\n                        vector<int> ans;\\n                        int m = min*60 + sec; \\n                        if(m == ts){\\n                            ans.emplace_back(i);\\n                            ans.emplace_back(j);\\n                            ans.emplace_back(k);\\n                            ans.emplace_back(l);\\n                            cost = min(cost,solve(ans,sa,mc,pc));\\n                             while(ans[0] == 0){\\n                                 ans.erase(ans.begin());\\n                                 cost = min(cost,solve(ans,sa,mc,pc));\\n                             }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //finding answer of every possible minute that equal to targetSecond\\n    int solve(vector<int> &a,int sa, int mc, int pc){\\n        int ans = 0;\\n        if(a[0] != sa){\\n            ans += mc;\\n        }\\n        ans += pc;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i] != a[i-1]){\\n                ans += mc;\\n            }\\n            ans += pc;\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    int minCostSetTime(int sa, int mc, int pc, int ts) {\\n        int cost = 1e8;\\n        //trying all permutation\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                int min = i*10+j; // minutes\\n                for(int k=0;k<=9;k++){\\n                    for(int l=0;l<=9;l++){\\n\\t\\t\\t\\t\\t    int sec = k*10 + l;//seconds\\n                        vector<int> ans;\\n                        int m = min*60 + sec; \\n                        if(m == ts){\\n                            ans.emplace_back(i);\\n                            ans.emplace_back(j);\\n                            ans.emplace_back(k);\\n                            ans.emplace_back(l);\\n                            cost = min(cost,solve(ans,sa,mc,pc));\\n                             while(ans[0] == 0){\\n                                 ans.erase(ans.begin());\\n                                 cost = min(cost,solve(ans,sa,mc,pc));\\n                             }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747317,
                "title": "java-solution-brute-force-all-edge-cases-explained",
                "content": "Brute Force Solution\\n0(1)Time And Space Complexity\\n****\\n\\tclass Solution {\\n\\t\\tpublic int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) \\n\\t\\t{\\n\\t\\t\\tchar st=(char)(startAt+\\'0\\');\\n\\t\\t\\tif(ts<60)\\n\\t\\t\\t\\treturn cost(st,ts+\"\",moveCost,pushCost);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint min=ts/60;\\n\\t\\t\\t\\tint sec=ts%60;\\n\\t\\t\\t\\tString s1=\"\",s2=\"\",or=\"\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(ts<=99)\\n\\t\\t\\t\\t\\tor=ts+\"\";  // Orignal time in second;\\n\\n\\t\\t\\t\\tif(min==100)  //If time >=100 min than convert in 00:99 second format\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmin--;\\n\\t\\t\\t\\t\\tsec+=60;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(sec<10)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts1=min+\"0\"+sec;  //Time in 60 second format\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts1=min+\"\"+sec;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(sec<=39)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmin--;\\n\\t\\t\\t\\t\\tsec+=60;\\n\\t\\t\\t\\t\\ts2=min+\"\"+sec;  //If time can be represened in 00:99 seconds Format\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tint ans=Math.min(cost(st,or,moveCost,pushCost),Math.min(cost(st,s1,moveCost,pushCost),cost(st,s2,moveCost,pushCost)));\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}  \\n\\t\\t}\\n\\n\\t\\tpublic int cost(char st,String s,int moveCost, int pushCost)\\n\\t\\t{\\n\\t\\t\\tif(s.length()==0)\\n\\t\\t\\t\\treturn Integer.MAX_VALUE;\\n\\n\\t\\t\\tint push=s.length();\\n\\t\\t\\tint move=1;\\n\\t\\t\\tfor(int i=0;i<push-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s.charAt(i)!=s.charAt(i+1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmove++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(st==s.charAt(0))\\n\\t\\t\\t\\tmove--;\\n\\n\\t\\t\\treturn (move*moveCost)+(push*pushCost);    \\n\\t\\t}\\n\\t}\\n\\t****",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) \\n\\t\\t{\\n\\t\\t\\tchar st=(char)(startAt+\\'0\\');\\n\\t\\t\\tif(ts<60)\\n\\t\\t\\t\\treturn cost(st,ts+\"\",moveCost,pushCost);\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint min=ts/60;\\n\\t\\t\\t\\tint sec=ts%60;\\n\\t\\t\\t\\tString s1=\"\",s2=\"\",or=\"\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(ts<=99)\\n\\t\\t\\t\\t\\tor=ts+\"\";  // Orignal time in second;\\n\\n\\t\\t\\t\\tif(min==100)  //If time >=100 min than convert in 00:99 second format\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmin--;\\n\\t\\t\\t\\t\\tsec+=60;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1747222,
                "title": "python-be-careful-with-some-annoying-edge-cases",
                "content": "Convert targetseconds to **mm:ss** first.\\nWe need to consider at most two cases:\\n- If **mm < 100**, we should consider the cost of **mm:ss**.\\n- If the current **mm > 1** and **ss < 40**, meaning we should consider the cost of **mm-1:ss+60**.\\n\\nWe should also be careful of the string of seconds:\\n- If **mm > 0**, then ss **must** have a length of 2. For example, **7** should be written as **07**.\\n- If **mm = 0**, then ss can have length of 1.\\n\\nThen we just iterate over the string of **mmss** and calculate the total costs.\\n\\n**Python**\\n```\\ndef minCostSetTime(self, start: int, mC: int, pC: int, TS: int) -> int:\\n        def helper(mins, secs):\\n            pre, cost, ss = str(start), 0, str(secs)\\n            if mins != 0:\\n                if len(ss) < 2:\\n                    ss = \"0\" + ss\\n                ss = str(mins) + ss            \\n            for ch in ss:\\n                if ch != pre:\\n                    cost += mC\\n                cost += pC\\n                pre = ch\\n            return cost\\n\\n        mins, secs = divmod(TS, 60)\\n        ans = math.inf\\n        \\n        if mins < 100:\\n            ans = min(ans, helper(mins, secs))\\n        if secs < 40:\\n            ans = min(ans, helper(mins - 1, secs + 60))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minCostSetTime(self, start: int, mC: int, pC: int, TS: int) -> int:\\n        def helper(mins, secs):\\n            pre, cost, ss = str(start), 0, str(secs)\\n            if mins != 0:\\n                if len(ss) < 2:\\n                    ss = \"0\" + ss\\n                ss = str(mins) + ss            \\n            for ch in ss:\\n                if ch != pre:\\n                    cost += mC\\n                cost += pC\\n                pre = ch\\n            return cost\\n\\n        mins, secs = divmod(TS, 60)\\n        ans = math.inf\\n        \\n        if mins < 100:\\n            ans = min(ans, helper(mins, secs))\\n        if secs < 40:\\n            ans = min(ans, helper(mins - 1, secs + 60))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1747295,
                "title": "o-1-complete-explanation-with-examples-6-total-cases-c",
                "content": "There are total 6 edge cases possible. \\nLet me explain with examples for clear understanding\\n\\nI\\'m making a string, which will represent time of microwave display.\\n```\\nseconds = targetSeconds%60;\\nminutes = targetSeconds/60;\\n```\\n```\\nstring = minutes + seconds\\n```\\n\\nWhen we have targetSeconds = 611, then it is - 10 minutes and 11 seconds == \"10:11\".\\nBut it can also be written as \"9:71\", as total number of seconds remain same.\\n\\nNote1 : If minutes <= 9, lest say minutes=8, then it can also be written as \"08\", which is a new pattern representing same time.\\nNote2 : if seconds <= 39, then a pattern with (minute-1) can be formed as shown in above example, but if seconds are > 39, then that can\\'t be represent in this way.\\n\\nTotal 6 cases are there, I represented them as string p1, p2, p3, p4,p5, p6\\nBy seeing the code, its self explanatory that what different cases these strings are holding. Also, see the below examples.\\n\\nWhen targetSeconds = 76  == 1 min + 16 sec\\n```\\np1 = 116      ==   1:16\\np4 = 0116     ==   01:16\\np2 = 076\\np3 = 0076\\np5 = 76\\np6 = \\n```\\n\\nWhen targetSeconds = 6039  ==  100 min + 39 sec\\n```\\np1 = \\np4 = \\np2 = 9999\\np3 = \\np5 = \\np6 = \\n```\\n\\nWhen targetSeconds = 600  == 10 min\\n```\\np1 = 1000\\np4 = \\np2 = 960\\np3 = 0960\\np5 = \\np6 = \\n```\\n\\nWhen targetSeconds = 19  == 19 sec\\n```\\np1 = 019\\np4 = 0019\\np2 = \\np3 = \\np5 = \\np6 = 19\\n```\\n\\n# CODE \\n\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int seconds = targetSeconds%60;\\n        int minutes = targetSeconds/60;\\n        \\n        string p1=\"\", p2=\"\", p3=\"\", p4=\"\",p5=\"\", p6=\"\";\\n        \\n        p1 = to_string(minutes);\\n        if(seconds <= 9) p1 += \"0\";\\n        p1 += to_string(seconds);\\n        \\n        if(minutes == 100) p1=\"\";\\n        \\n        if(minutes <= 9){\\n            p4=\"0\";\\n            p4 += p1;\\n        }\\n        \\n        if(seconds <= 39 and minutes >= 1){\\n            p2 = to_string(minutes-1);\\n            p2 += to_string(60 + seconds);\\n        }\\n        \\n        if(p2.length() > 0){\\n            if(minutes - 1 <= 9){\\n                p3 = \"0\";\\n                p3 += p2;\\n            }\\n            if(minutes-1 == 0){\\n                p5 = to_string(60+seconds);\\n            }\\n        }\\n        \\n        if(minutes == 0) p6=to_string(seconds);\\n        \\n        \\n        vector<string>arr;\\n        if(p1.size() > 0) arr.push_back(p1);    \\n        if(p2.size() > 0) arr.push_back(p2);\\n        if(p3.size() > 0) arr.push_back(p3);\\n        if(p4.size() > 0) arr.push_back(p4);\\n        if(p5.size() > 0) arr.push_back(p5);\\n        if(p6.size() > 0) arr.push_back(p6);\\n\\n        \\n\\t\\t// now, the main calculation according to question\\n        int mn = INT_MAX;\\n        int cost;\\n        for(string str : arr){\\n            int x = str[0]-\\'0\\';\\n            cost = 0;\\n            if(startAt == x) cost += pushCost;\\n            else cost += moveCost + pushCost;\\n            \\n            for(int i=1; i<str.length(); i++){\\n                if(str[i] == str[i-1]) cost += pushCost;\\n                else cost += moveCost + pushCost;\\n            }\\n            mn = min(cost, mn);\\n        }\\n        \\n        return mn;\\n    }\\n};\\n```\\n\\nI know that its a frustrating question. Most of my time was spent in it. \\n\\n**Please Upvote**",
                "solutionTags": [],
                "code": "```\\nseconds = targetSeconds%60;\\nminutes = targetSeconds/60;\\n```\n```\\nstring = minutes + seconds\\n```\n```\\np1 = 116      ==   1:16\\np4 = 0116     ==   01:16\\np2 = 076\\np3 = 0076\\np5 = 76\\np6 = \\n```\n```\\np1 = \\np4 = \\np2 = 9999\\np3 = \\np5 = \\np6 = \\n```\n```\\np1 = 1000\\np4 = \\np2 = 960\\np3 = 0960\\np5 = \\np6 = \\n```\n```\\np1 = 019\\np4 = 0019\\np2 = \\np3 = \\np5 = \\np6 = 19\\n```\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int seconds = targetSeconds%60;\\n        int minutes = targetSeconds/60;\\n        \\n        string p1=\"\", p2=\"\", p3=\"\", p4=\"\",p5=\"\", p6=\"\";\\n        \\n        p1 = to_string(minutes);\\n        if(seconds <= 9) p1 += \"0\";\\n        p1 += to_string(seconds);\\n        \\n        if(minutes == 100) p1=\"\";\\n        \\n        if(minutes <= 9){\\n            p4=\"0\";\\n            p4 += p1;\\n        }\\n        \\n        if(seconds <= 39 and minutes >= 1){\\n            p2 = to_string(minutes-1);\\n            p2 += to_string(60 + seconds);\\n        }\\n        \\n        if(p2.length() > 0){\\n            if(minutes - 1 <= 9){\\n                p3 = \"0\";\\n                p3 += p2;\\n            }\\n            if(minutes-1 == 0){\\n                p5 = to_string(60+seconds);\\n            }\\n        }\\n        \\n        if(minutes == 0) p6=to_string(seconds);\\n        \\n        \\n        vector<string>arr;\\n        if(p1.size() > 0) arr.push_back(p1);    \\n        if(p2.size() > 0) arr.push_back(p2);\\n        if(p3.size() > 0) arr.push_back(p3);\\n        if(p4.size() > 0) arr.push_back(p4);\\n        if(p5.size() > 0) arr.push_back(p5);\\n        if(p6.size() > 0) arr.push_back(p6);\\n\\n        \\n\\t\\t// now, the main calculation according to question\\n        int mn = INT_MAX;\\n        int cost;\\n        for(string str : arr){\\n            int x = str[0]-\\'0\\';\\n            cost = 0;\\n            if(startAt == x) cost += pushCost;\\n            else cost += moveCost + pushCost;\\n            \\n            for(int i=1; i<str.length(); i++){\\n                if(str[i] == str[i-1]) cost += pushCost;\\n                else cost += moveCost + pushCost;\\n            }\\n            mn = min(cost, mn);\\n        }\\n        \\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747178,
                "title": "easy-to-understand-well-explained-dfs-clean-code-complexity-analysis",
                "content": "Just do as question said :\\nStart from 0 : \\n1. And if you\\'re currently at the button which has previously pressed or it\\'s the begginging then you\\'ll spend just only pressCost.\\n2. Else, you need to move first you\\'re desire button(moveCost) and than you need to press it(pressCost). I.e. moveCost+pressCost.\\n3. Now, In recursion if you moved from a button to a new button than you must update the lastPressedButton also so that you wouldn\\'t need to invest move cost again.\\n4. Find the min from all the possibilites.\\n\\nNow you need handle those cases who are not incrementing in terms of number \\ne.g. 000 you can add one more 0 i.e. 0000 but it is still 0. \\nSo to handle this you can use how many times you have pushed the number and atmost you can push 4 times because \\nmicrowave supports cooking times for:\\n* at least 1 second.\\n* at most 99 minutes and 99 seconds.\\n```\\nclass Solution {\\npublic:\\n    bool isEqual(int source, int target) {\\n    \\n      // Convert source to sec\\n      int min = source/100;\\n      int sec = source%100;\\n      return (min*60+sec) == target;\\n    }\\n\\n\\tlong solve(int curr, int moveCost, int pressCost, int target, int lastPressedButton, int times=0) {\\n        \\n        // Handle Overflow conditions\\n        if(curr>9999 || times>4) {\\n            return INT_MAX;\\n        }\\n\\n        // If we get target than no need to do anything\\n        if(isEqual(curr,target)) {\\n            return 0;\\n        }\\n\\n        long res=INT_MAX;\\n        \\n        // Now start from 0-th button and keep pressing one by one\\n        for(int i=0;i<10;i++) {\\n            long ans = (pressCost+(i!=lastPressedButton)*moveCost) + solve(curr*10+i, moveCost, pressCost, target, i, times+1);\\n            res = min(res,ans);\\n        }\\n        return res;\\n    }\\n\\n\\tint minCostSetTime(int start, int moveCost, int pressCost, int target) {\\n\\t\\treturn solve(0, moveCost, pressCost, target, start);\\n\\t}\\n};\\n```\\n\\n# Time Complexity : \\nSo we\\'re are pressing for each button for every move.\\nSo atmost there can be 4 move i.e. <9999  or log(1e5)base10\\nAnd for one move cost will be 10.\\nSo for 4 move cost will be 10^4.\\nSo more formally in the worst case (10^ log(1e5)base10).\\n\\n# Space Complexity :\\nSo we are not using any extra space except recursion stack.\\nSo at any point time what will be the maximum number of function which would have been pushed?\\n1. Since, Each step we are incrementing by one digit or pushing one button.\\n2. So at worst case I have been pushed all the button(atmost 4 button).\\n\\nSo overall stack size would be atmost of 4 i.e. constant.\\n\\n**Feel free to correct me if I was wrong any where. And please upvote if you find it usefull.\\nHappy Coding!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqual(int source, int target) {\\n    \\n      // Convert source to sec\\n      int min = source/100;\\n      int sec = source%100;\\n      return (min*60+sec) == target;\\n    }\\n\\n\\tlong solve(int curr, int moveCost, int pressCost, int target, int lastPressedButton, int times=0) {\\n        \\n        // Handle Overflow conditions\\n        if(curr>9999 || times>4) {\\n            return INT_MAX;\\n        }\\n\\n        // If we get target than no need to do anything\\n        if(isEqual(curr,target)) {\\n            return 0;\\n        }\\n\\n        long res=INT_MAX;\\n        \\n        // Now start from 0-th button and keep pressing one by one\\n        for(int i=0;i<10;i++) {\\n            long ans = (pressCost+(i!=lastPressedButton)*moveCost) + solve(curr*10+i, moveCost, pressCost, target, i, times+1);\\n            res = min(res,ans);\\n        }\\n        return res;\\n    }\\n\\n\\tint minCostSetTime(int start, int moveCost, int pressCost, int target) {\\n\\t\\treturn solve(0, moveCost, pressCost, target, start);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747002,
                "title": "c-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        vector<string> v;\\n        if(target < 100){\\n            v.push_back(to_string(target));\\n            int m = target / 60, sc = target % 60;\\n            string ssc = \"\";\\n            if(sc < 10){\\n                ssc += \\'0\\';\\n                ssc += to_string(sc);\\n            }else{\\n                ssc = to_string(sc);\\n            }\\n            v.push_back(to_string(m)+ssc);\\n        }else{\\n            int m = target / 60, sc = target % 60;\\n            if(m < 100){\\n                string ssc = \"\";\\n                if(sc < 10){\\n                    ssc += \\'0\\';\\n                    ssc += to_string(sc);\\n                }else{\\n                    ssc = to_string(sc);\\n                }\\n                v.push_back(to_string(m)+ssc);\\n            }\\n            if(60 + sc < 100){\\n                v.push_back(to_string(m-1)+ to_string(sc+60));\\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int i=0; i<v.size(); i++){\\n            int cost = 0, cur = startAt;\\n            for(int j=0; j<v[i].size(); j++){\\n                if(v[i][j]-\\'0\\' != cur){\\n                    cost += moveCost;\\n                    cur = v[i][j]-\\'0\\';\\n                }\\n                cost += pushCost;\\n            }\\n            res = min(res, cost);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        vector<string> v;\\n        if(target < 100){\\n            v.push_back(to_string(target));\\n            int m = target / 60, sc = target % 60;\\n            string ssc = \"\";\\n            if(sc < 10){\\n                ssc += \\'0\\';\\n                ssc += to_string(sc);\\n            }else{\\n                ssc = to_string(sc);\\n            }\\n            v.push_back(to_string(m)+ssc);\\n        }else{\\n            int m = target / 60, sc = target % 60;\\n            if(m < 100){\\n                string ssc = \"\";\\n                if(sc < 10){\\n                    ssc += \\'0\\';\\n                    ssc += to_string(sc);\\n                }else{\\n                    ssc = to_string(sc);\\n                }\\n                v.push_back(to_string(m)+ssc);\\n            }\\n            if(60 + sc < 100){\\n                v.push_back(to_string(m-1)+ to_string(sc+60));\\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int i=0; i<v.size(); i++){\\n            int cost = 0, cur = startAt;\\n            for(int j=0; j<v[i].size(); j++){\\n                if(v[i][j]-\\'0\\' != cur){\\n                    cost += moveCost;\\n                    cur = v[i][j]-\\'0\\';\\n                }\\n                cost += pushCost;\\n            }\\n            res = min(res, cost);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747333,
                "title": "c-python-java-direct-o-1-space-time-0-ms-faster-than-100-modular-concise-short",
                "content": "**C++: (0ms , faster than 100% in time)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int calc(int min, int sec, int s, int m, int p){\\n        if(min>99 || sec>99 || min<0 || sec<0) return INT_MAX;   \\n        \\n        vector<int> v = {min/10, min%10, sec/10, sec%10};\\n        vector<int> vv;\\n\\t\\t\\n        int i=0;\\n        while(i<4 && v[i]==0) i++;\\n        \\n        // if(i==4) return 0; // not req as 0000 not possible acc to test case\\n        \\n        for(; i<4; i++) vv.push_back(v[i]);\\n\\n        int cost=0;\\n        for(int e: vv){\\n            if(e!=s) cost+=m;\\n            s=e;\\n            cost+=p;\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    int minCostSetTime(int s, int m, int p, int t) {\\n        int mins=t/60;\\n        int secs= t-60*mins;\\n        return min(calc(mins, secs, s, m, p), calc(mins-1, secs+60, s, m, p));\\n    }\\n};\\n```\\n\\n**Java: (faster than 100% in time)**\\n```\\nclass Solution {\\n    \\n    public int calc(int min, int sec, int s, int m, int p){\\n        if(min>99 || sec>99 || min<0 || sec<0) return Integer.MAX_VALUE;   \\n        \\n        int[] v = new int[]{min/10, min%10, sec/10, sec%10};        \\n        List<Integer> vv = new ArrayList<Integer>();\\n        int i=0;\\n        while(i<4 && v[i]==0) i++;\\n        \\n        for(; i<4; i++){\\n            vv.add(v[i]);\\n        }\\n\\n        int cost=0;\\n        for(int e: vv){\\n            if(e!=s) cost+=m;\\n            s=e;\\n            cost+=p;\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    public int minCostSetTime(int s, int m, int p, int t) {\\n        int mins=t/60;\\n        int secs= t- 60*mins;\\n        return Math.min(calc(mins, secs,s, m, p), calc(mins-1, secs+60,s,m,p));        \\n    }\\n}\\n```\\n\\n**Python: (faster than 100% in time & space both)**\\n```\\nclass Solution(object):\\n    \\n    def calc(self, min, sec, s,m,p):\\n        if(min>99 or sec>99 or min<0 or sec<0):\\n            return sys.maxint\\n    \\n        l=[min/10, min%10, sec/10, sec%10]\\n        ll=[]\\n        i=0\\n        while(i<4 and l[i]==0):\\n            i+=1\\n        \\n        for j in range(i,4):\\n            ll.append(l[j])\\n            \\n        cost=0\\n        \\n        for e in ll:\\n            if(e!=s):\\n                cost+=m\\n            s=e\\n            cost+=p\\n        \\n        return cost;        \\n     \\n    def minCostSetTime(self, s, m, p, t):\\n        mins= t/60\\n        secs= t- 60*mins\\n        return min(self.calc(mins, secs, s, m, p), self.calc(mins-1, secs+60, s, m, p))\\n```\\n\\n**Time Complexity Analysis:**\\nTime: O(1) \\nSpace: O(1) \\n\\n**Please upvote if you liked it.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calc(int min, int sec, int s, int m, int p){\\n        if(min>99 || sec>99 || min<0 || sec<0) return INT_MAX;   \\n        \\n        vector<int> v = {min/10, min%10, sec/10, sec%10};\\n        vector<int> vv;\\n\\t\\t\\n        int i=0;\\n        while(i<4 && v[i]==0) i++;\\n        \\n        // if(i==4) return 0; // not req as 0000 not possible acc to test case\\n        \\n        for(; i<4; i++) vv.push_back(v[i]);\\n\\n        int cost=0;\\n        for(int e: vv){\\n            if(e!=s) cost+=m;\\n            s=e;\\n            cost+=p;\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    int minCostSetTime(int s, int m, int p, int t) {\\n        int mins=t/60;\\n        int secs= t-60*mins;\\n        return min(calc(mins, secs, s, m, p), calc(mins-1, secs+60, s, m, p));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    public int calc(int min, int sec, int s, int m, int p){\\n        if(min>99 || sec>99 || min<0 || sec<0) return Integer.MAX_VALUE;   \\n        \\n        int[] v = new int[]{min/10, min%10, sec/10, sec%10};        \\n        List<Integer> vv = new ArrayList<Integer>();\\n        int i=0;\\n        while(i<4 && v[i]==0) i++;\\n        \\n        for(; i<4; i++){\\n            vv.add(v[i]);\\n        }\\n\\n        int cost=0;\\n        for(int e: vv){\\n            if(e!=s) cost+=m;\\n            s=e;\\n            cost+=p;\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    public int minCostSetTime(int s, int m, int p, int t) {\\n        int mins=t/60;\\n        int secs= t- 60*mins;\\n        return Math.min(calc(mins, secs,s, m, p), calc(mins-1, secs+60,s,m,p));        \\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    \\n    def calc(self, min, sec, s,m,p):\\n        if(min>99 or sec>99 or min<0 or sec<0):\\n            return sys.maxint\\n    \\n        l=[min/10, min%10, sec/10, sec%10]\\n        ll=[]\\n        i=0\\n        while(i<4 and l[i]==0):\\n            i+=1\\n        \\n        for j in range(i,4):\\n            ll.append(l[j])\\n            \\n        cost=0\\n        \\n        for e in ll:\\n            if(e!=s):\\n                cost+=m\\n            s=e\\n            cost+=p\\n        \\n        return cost;        \\n     \\n    def minCostSetTime(self, s, m, p, t):\\n        mins= t/60\\n        secs= t- 60*mins\\n        return min(self.calc(mins, secs, s, m, p), self.calc(mins-1, secs+60, s, m, p))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747139,
                "title": "c-o-1-time-and-space-solution",
                "content": "**Some points to remember**\\n* We can have atmost 99 minutes and atleast 00 minutes in minutes dial\\n* We can have atmost 99 seconds and atleast 00 seconds in seconds dial \\n\\nLet **mins = targetSeconds/60** and **secs = targetSeconds%60**, then we just need to check for minutes={mins-1, min}. This can easily be understood with the following example,\\n\\n**Example** : *startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600*\\nHere, mins = 6000/60 = 100 and secs = 6000%60 = 0\\nmins = 100, which cannot be entered into the minutes dial, so we decrease value of *mins* and add 60 to *secs*.\\nThen, min=99, secs=60, and after calculation, we get cost=10. Again, decreasing the value of *mins* and increasing *secs*, \\nwe get min=98, secs=120. But, *secs=120* is not valid.\\nThis way the previous values of minutes and seconds will not be valid inputs, so we stop here.\\n\\nI hope the approach is clear, if you have any doubts then feel free to ask in the comments.\\n**Plz upvote if you liked it!!**\\n\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mins = targetSeconds/60;\\n        int secs = targetSeconds%60;\\n        \\n\\t\\twhile(mins>99) {    // to ensure that \\'minutes\\' remain smaller than 100 and accordingly adding \\'seconds\\'\\n            mins--;\\n            secs += 60;\\n        }\\n        \\n        int ans = INT_MAX;\\n        while(mins>=0 and secs<100) {    // as \\'minutes\\' are decreasing and \\'seconds\\' are increasing\\n            string s = (mins == 0 ? \"\" : to_string(mins));\\n            if(mins > 0) {\\n                if(secs == 0)\\n                    s += \"00\";\\n                else if(secs < 10)\\n                    s += \"0\" + to_string(secs);\\n                else\\n                    s += to_string(secs);\\n            }\\n            else    // when \\'minutes\\'=0, then we just need to enter the digits of \\'seconds\\' in microwave dial\\n                s += (secs==0 ? \"\" : to_string(secs));\\n\\n            int t=0;\\n\\t\\t\\tchar previousCharacter = startAt+\\'0\\';\\n            for(auto i: s) {\\n                if(previousCharacter == i)    // no need to move from current character, just press the key\\n                    t += pushCost;\\n                else\\n                    t += moveCost + pushCost;\\n\\t\\t\\t\\tpreviousCharacter = i;\\n            }\\n            ans = min(ans, t);\\n            mins--;\\n            secs += 60;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mins = targetSeconds/60;\\n        int secs = targetSeconds%60;\\n        \\n\\t\\twhile(mins>99) {    // to ensure that \\'minutes\\' remain smaller than 100 and accordingly adding \\'seconds\\'\\n            mins--;\\n            secs += 60;\\n        }\\n        \\n        int ans = INT_MAX;\\n        while(mins>=0 and secs<100) {    // as \\'minutes\\' are decreasing and \\'seconds\\' are increasing\\n            string s = (mins == 0 ? \"\" : to_string(mins));\\n            if(mins > 0) {\\n                if(secs == 0)\\n                    s += \"00\";\\n                else if(secs < 10)\\n                    s += \"0\" + to_string(secs);\\n                else\\n                    s += to_string(secs);\\n            }\\n            else    // when \\'minutes\\'=0, then we just need to enter the digits of \\'seconds\\' in microwave dial\\n                s += (secs==0 ? \"\" : to_string(secs));\\n\\n            int t=0;\\n\\t\\t\\tchar previousCharacter = startAt+\\'0\\';\\n            for(auto i: s) {\\n                if(previousCharacter == i)    // no need to move from current character, just press the key\\n                    t += pushCost;\\n                else\\n                    t += moveCost + pushCost;\\n\\t\\t\\t\\tpreviousCharacter = i;\\n            }\\n            ans = min(ans, t);\\n            mins--;\\n            secs += 60;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747070,
                "title": "c-simple-solution-brute-force",
                "content": "We know that maximum seconds we can make through last two digits is 99 so lets try all comibantions from making 0 to 99 and remaining seconds by using minute digits.\\n\\nIf you need further clarification please comment it down.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getCost(string s,int start,int move,int push)\\n    {\\n        int c = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i == 0)\\n            {\\n\\t\\t\\t    // if not the start digit\\n                if((s[i] - \\'0\\') != start)\\n                {\\n                    c += move;\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// if digit is not same as prev then we need to move\\n                if(s[i] != s[i-1])\\n                {\\n                    c += move;\\n                }\\n            }\\n            c += push;\\n        }\\n        return c;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int ans = 100000000;\\n        for(int i=0;i<100;i++)\\n        {\\n            if(targetSeconds < i)\\n                break;\\n\\n            int x = targetSeconds - i;\\n\\n            if(x % 60 == 0)\\n            {\\n\\n                string s;\\n                if(i < 10)\\n                {\\n                    s += \"0\";\\n                }\\n                s += to_string(i);\\n\\n\\n                int m = x / 60;\\n\\t\\t\\t\\t// minute digits cannot exceed 2\\n                if(m >= 100)\\n                    continue;\\n                if(m > 0){\\n                    s = to_string(m) + s;\\n                    ans = min(ans,getCost(s,startAt, moveCost, pushCost));\\n                }\\n                else\\n                {\\n                    if(i < 10)\\n                    {\\n                        ans = min(ans,getCost(to_string(i),startAt, moveCost, pushCost));\\n                    }\\n                    else\\n                    {\\n                        ans = min(ans,getCost(s,startAt, moveCost, pushCost));\\n                    }\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getCost(string s,int start,int move,int push)\\n    {\\n        int c = 0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i == 0)\\n            {\\n\\t\\t\\t    // if not the start digit\\n                if((s[i] - \\'0\\') != start)\\n                {\\n                    c += move;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3359766,
                "title": "python-3-8-lines-t-m-97-81",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n\\n        def cost(m: int,s: int)-> int:\\n\\n            if not(0 <= m <= 99 and 0 <= s <= 99): return inf\\n\\n            display = str(startAt)+str(100*m+s)\\n\\n            moves  = sum(display[i]!=display[i-1] for i in range(1,len(display)))\\n            pushes = len(display)-1\\n            \\n            return moveCost*moves + pushCost*pushes\\n        \\n\\n        mins, secs = divmod(targetSeconds,60)\\n            \\n        return  min(cost(mins,secs),cost(mins-1,secs+60))\\n```\\n[https://leetcode.com/problems/minimum-cost-to-set-cooking-time/submissions/925094755/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n\\n        def cost(m: int,s: int)-> int:\\n\\n            if not(0 <= m <= 99 and 0 <= s <= 99): return inf\\n\\n            display = str(startAt)+str(100*m+s)\\n\\n            moves  = sum(display[i]!=display[i-1] for i in range(1,len(display)))\\n            pushes = len(display)-1\\n            \\n            return moveCost*moves + pushCost*pushes\\n        \\n\\n        mins, secs = divmod(targetSeconds,60)\\n            \\n        return  min(cost(mins,secs),cost(mins-1,secs+60))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587046,
                "title": "java-solution-with-example-and-comments",
                "content": "We have 2 option. \\n1. minutes:seconds\\n2. minutes-1:60+seconds\\nFor Exmaple\\n10:00 can be represented as \\n10:00 or 9:60\\nWe then convert to microve time by multiplying 100 to minutes\\n```\\n10:00-> 10*100+0 = 1000\\n9:60--> 9*100+60 = 960\\n```\\n\\n\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60;//Convert targetseconds to minutes and seconds\\n        int seconds = targetSeconds%60;\\n        //We have 2 option\\n        return Math.min(findMinCost(startAt,moveCost,pushCost,minutes,seconds),\\n                        findMinCost(startAt,moveCost,pushCost,minutes-1,60+seconds));\\n    }\\n    public int findMinCost(int startAt, int moveCost, int pushCost, int minutes, int seconds){\\n        if(seconds< 0 || minutes<0 || minutes>99 || seconds>99){\\n            return Integer.MAX_VALUE;\\n        }\\n        int minCost = 0;\\n        int microwaveTime = (minutes*100)+seconds;//So avoid leading zeros 6:10 --->610\\n        char digits[] = String.valueOf(microwaveTime).toCharArray();\\n        for(char digitChar : digits){\\n            int digit = digitChar -\\'0\\';\\n            minCost = minCost+ pushCost + (startAt==digit?0:moveCost);//if the current digit is different then previous one we need to add a move cost since we move to a different position\\n            startAt = digit;\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n10:00-> 10*100+0 = 1000\\n9:60--> 9*100+60 = 960\\n```\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60;//Convert targetseconds to minutes and seconds\\n        int seconds = targetSeconds%60;\\n        //We have 2 option\\n        return Math.min(findMinCost(startAt,moveCost,pushCost,minutes,seconds),\\n                        findMinCost(startAt,moveCost,pushCost,minutes-1,60+seconds));\\n    }\\n    public int findMinCost(int startAt, int moveCost, int pushCost, int minutes, int seconds){\\n        if(seconds< 0 || minutes<0 || minutes>99 || seconds>99){\\n            return Integer.MAX_VALUE;\\n        }\\n        int minCost = 0;\\n        int microwaveTime = (minutes*100)+seconds;//So avoid leading zeros 6:10 --->610\\n        char digits[] = String.valueOf(microwaveTime).toCharArray();\\n        for(char digitChar : digits){\\n            int digit = digitChar -\\'0\\';\\n            minCost = minCost+ pushCost + (startAt==digit?0:moveCost);//if the current digit is different then previous one we need to add a move cost since we move to a different position\\n            startAt = digit;\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749553,
                "title": "easy-to-understand-js-solution-with-explanation",
                "content": "Intuition:\\n\\nThe idea is first we need to think that in how many ways we can get targetSeconds so that we can maintain the constraint of mm:ss i.e 99:99. And from those ways we need one possible combination such that we get less tired(moving + pushing those buttons).\\n\\n**Example 1:**  if we have targetSeconds of 400 seconds:\\n\\n```\\n1st way       400 sec ( _ _ : _ _) i.e ( 0 0: 400 )\\n              -60\\n              -----\\n2nd way       340 sec ( _ _ : _ _) i.e ( 0 1: 340 ) <--- cannot be arranged here\\n              -60\\n\\t\\t\\t  -----\\n3rd way       280 sec ( _ _ : _ _) i.e ( 0 2: 280 )<-- neither here\\n              -60\\n              -----\\n4th way       220 sec ( _ _: _ _) i.e ( 0 3: 220 ) <-- neither here\\n              -60\\n             -----\\n5th way.      160 sec ( _ _: _ _) i.e ( 0 4: 160 ) <-- neither here\\n              -60\\n              -----\\n6th           100 sec ( _ _: _ _) i.e ( 0 5: 100 ) <-- neither here\\n              -60\\n              -----\\n               40 sec ( 0 6: 4 0) <-- here we can achieve our constraint ( <=99: <=99 )\\n```\\n\\nHence we can see that 1 to 5 can not be part of minimum cost as they do not follow our constraint of ( <=99: <=99 ). For these we simply continue and for 6 we generate our cost, which will be the minimum.\\n\\n\\n**Example 2:**  targetSeconds of 99 seconds:\\n```\\n1st way   99 sec ( _ _ : _ _) i.e ( 0 0: 99 )  <-- can be arranged in mm:ss\\n         -60\\n\\t\\t -----\\n2n way    39 sec ( _ 1 : _ _) i.e ( 0 1: 39 )  <-- can be arranged in mm:ss\\n```\\n\\nHence we see 1 and 2 both fulfill our criteria of ( <=99: <=99 ) and both of them will contribute to our minimum cost logic\\n\\n**CODE**\\n\\n```\\n/**\\n * @param {number} startAt\\n * @param {number} moveCost\\n * @param {number} pushCost\\n * @param {number} targetSeconds\\n * @return {number}\\n */\\nvar minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let cost = Infinity;\\n    \\n    let maxMinutes = Math.floor(targetSeconds / 60);\\n    \\n    for(let min = 0; min <= maxMinutes; min++) {\\n        let secs = targetSeconds - min * 60;\\n        \\n        if (secs > 99 || min > 99) continue;\\n        \\n        let buttons = String(100 * min + secs);\\n        let prev = Number(buttons[0]);\\n        \\n        let sum = 0;\\n        \\n        //start index will vary according to startAt pointer\\n        let start = 0;\\n        \\n        //If startAt is equal to first button, we need to add pushCost fatigue\\n        if(prev === startAt) {\\n            sum += pushCost;\\n            start = 1;\\n         } else {\\n            //Else we need to add moveCost fatigue\\n            sum += moveCost;\\n         }\\n        \\n        for(let i = start; i < buttons.length; i++) {\\n            let button = Number(buttons[i]);\\n            \\n            if(button !== prev) {\\n                sum += moveCost + pushCost;\\n            } else {\\n                sum += pushCost;\\n            }\\n            \\n            prev = button;\\n        }\\n        \\n        cost = Math.min(cost, sum)\\n    }\\n    \\n    return cost;\\n};\\n```\\n\\nNote: This is JS version of https://leetcode.com/problems/minimum-cost-to-set-cooking-time/discuss/1746988/Python3-Java-C%2B%2B-Combinations-of-Minutes-and-Seconds-O(1) Solution\\n\\nHope it helps!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n1st way       400 sec ( _ _ : _ _) i.e ( 0 0: 400 )\\n              -60\\n              -----\\n2nd way       340 sec ( _ _ : _ _) i.e ( 0 1: 340 ) <--- cannot be arranged here\\n              -60\\n\\t\\t\\t  -----\\n3rd way       280 sec ( _ _ : _ _) i.e ( 0 2: 280 )<-- neither here\\n              -60\\n              -----\\n4th way       220 sec ( _ _: _ _) i.e ( 0 3: 220 ) <-- neither here\\n              -60\\n             -----\\n5th way.      160 sec ( _ _: _ _) i.e ( 0 4: 160 ) <-- neither here\\n              -60\\n              -----\\n6th           100 sec ( _ _: _ _) i.e ( 0 5: 100 ) <-- neither here\\n              -60\\n              -----\\n               40 sec ( 0 6: 4 0) <-- here we can achieve our constraint ( <=99: <=99 )\\n```\n```\\n1st way   99 sec ( _ _ : _ _) i.e ( 0 0: 99 )  <-- can be arranged in mm:ss\\n         -60\\n\\t\\t -----\\n2n way    39 sec ( _ 1 : _ _) i.e ( 0 1: 39 )  <-- can be arranged in mm:ss\\n```\n```\\n/**\\n * @param {number} startAt\\n * @param {number} moveCost\\n * @param {number} pushCost\\n * @param {number} targetSeconds\\n * @return {number}\\n */\\nvar minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let cost = Infinity;\\n    \\n    let maxMinutes = Math.floor(targetSeconds / 60);\\n    \\n    for(let min = 0; min <= maxMinutes; min++) {\\n        let secs = targetSeconds - min * 60;\\n        \\n        if (secs > 99 || min > 99) continue;\\n        \\n        let buttons = String(100 * min + secs);\\n        let prev = Number(buttons[0]);\\n        \\n        let sum = 0;\\n        \\n        //start index will vary according to startAt pointer\\n        let start = 0;\\n        \\n        //If startAt is equal to first button, we need to add pushCost fatigue\\n        if(prev === startAt) {\\n            sum += pushCost;\\n            start = 1;\\n         } else {\\n            //Else we need to add moveCost fatigue\\n            sum += moveCost;\\n         }\\n        \\n        for(let i = start; i < buttons.length; i++) {\\n            let button = Number(buttons[i]);\\n            \\n            if(button !== prev) {\\n                sum += moveCost + pushCost;\\n            } else {\\n                sum += pushCost;\\n            }\\n            \\n            prev = button;\\n        }\\n        \\n        cost = Math.min(cost, sum)\\n    }\\n    \\n    return cost;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747087,
                "title": "c-simulation-o-1-time",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nOnly two cases, `minute = 0, second = target` and `minute = m, second = target - m * 60`. We need to make sure both `minute` and `second` are in range `[0, 100)`.\\n\\nFor a given pair of `minute, second`, we calculate the cost and use the minimum cost as the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-cost-to-set-cooking-time/\\n// Author: github.com/lzl124631x\\n// Time: O(1) since `target` is at most 6039\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        int ans = INT_MAX, minute = 0;\\n        auto cost = [&](int m, int s) {\\n            auto d = to_string(m * 100 + s); // append seconds to minutes and get the digits\\n            int x = startAt, ans = 0;\\n            for (int i = 0; i < d.size(); ++i) { // simulate the time setting process\\n                if (x != d[i] - \\'0\\') ans += moveCost, x = d[i] - \\'0\\';\\n                ans += pushCost;\\n            }\\n            return ans;\\n        };\\n        while (target >= 0) {\\n            if (target < 100 && minute < 100) {\\n                ans = min(ans, cost(minute, target));\\n            }\\n            target -= 60;\\n            minute++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-cost-to-set-cooking-time/\\n// Author: github.com/lzl124631x\\n// Time: O(1) since `target` is at most 6039\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        int ans = INT_MAX, minute = 0;\\n        auto cost = [&](int m, int s) {\\n            auto d = to_string(m * 100 + s); // append seconds to minutes and get the digits\\n            int x = startAt, ans = 0;\\n            for (int i = 0; i < d.size(); ++i) { // simulate the time setting process\\n                if (x != d[i] - \\'0\\') ans += moveCost, x = d[i] - \\'0\\';\\n                ans += pushCost;\\n            }\\n            return ans;\\n        };\\n        while (target >= 0) {\\n            if (target < 100 && minute < 100) {\\n                ans = min(ans, cost(minute, target));\\n            }\\n            target -= 60;\\n            minute++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747006,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n   //Make a list of digits to be pressed. If (minutes>=100 then list=null) || (seconds>=100 then list=null)\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60;\\n        int seconds = targetSeconds%60;\\n        List<Integer> time1 = calculateTimeArray(minutes,seconds);\\n        List<Integer> time2 =  calculateTimeArray(minutes-1,seconds+60);\\n        return Math.min(calculateCost(startAt,moveCost,pushCost,time1),calculateCost(startAt,moveCost,pushCost,time2));\\n    }\\n    public int calculateCost(int startAt,int moveCost, int pushCost, List<Integer> time){\\n        if(time==null) return Integer.MAX_VALUE;\\n        int cost=0,index=0;\\n        while(time.get(index)==0) index++; //Always skip starting zeros even if you are at zero as they cost pushCost\\n        int currentPosition = startAt;\\n        while(index<=3){\\n            if(currentPosition==time.get(index)) cost+=pushCost;\\n            else{\\n                currentPosition=time.get(index);\\n                cost+=pushCost+moveCost;\\n            }\\n            index++;\\n        }\\n        return cost;\\n    }\\n    public List<Integer> calculateTimeArray(int minutes, int seconds){\\n        if(minutes>=100 || seconds>=100) return null;\\n        List<Integer> time = new ArrayList<>();\\n        time.add(minutes/10);\\n        time.add(minutes%10);\\n        time.add(seconds/10);\\n        time.add(seconds%10);\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   //Make a list of digits to be pressed. If (minutes>=100 then list=null) || (seconds>=100 then list=null)\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60;\\n        int seconds = targetSeconds%60;\\n        List<Integer> time1 = calculateTimeArray(minutes,seconds);\\n        List<Integer> time2 =  calculateTimeArray(minutes-1,seconds+60);\\n        return Math.min(calculateCost(startAt,moveCost,pushCost,time1),calculateCost(startAt,moveCost,pushCost,time2));\\n    }\\n    public int calculateCost(int startAt,int moveCost, int pushCost, List<Integer> time){\\n        if(time==null) return Integer.MAX_VALUE;\\n        int cost=0,index=0;\\n        while(time.get(index)==0) index++; //Always skip starting zeros even if you are at zero as they cost pushCost\\n        int currentPosition = startAt;\\n        while(index<=3){\\n            if(currentPosition==time.get(index)) cost+=pushCost;\\n            else{\\n                currentPosition=time.get(index);\\n                cost+=pushCost+moveCost;\\n            }\\n            index++;\\n        }\\n        return cost;\\n    }\\n    public List<Integer> calculateTimeArray(int minutes, int seconds){\\n        if(minutes>=100 || seconds>=100) return null;\\n        List<Integer> time = new ArrayList<>();\\n        time.add(minutes/10);\\n        time.add(minutes%10);\\n        time.add(seconds/10);\\n        time.add(seconds%10);\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132797,
                "title": "python-simple-solution-with-comments-and-beats-80",
                "content": "```\\n\\'\\'\\'\\nThis is relatively simple\\n\\n1. Convert target to minutes and seconds and get the string representation\\n2. Since seconds can exceed 60, it may be possible to get a shorter string representation by increasing seconds by 60 and decreasing the \\n\\tminutes by 1. \\n3. For each string representation calculate cost and return the minimum of the two\\n4. Edge case: If the number of minutes is greater than 100 the cost can be set to inf\\n\\n\\'\\'\\'\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        mins = targetSeconds//60\\n        secs = targetSeconds%60\\n        \\n        def getCost(s, startAt, moveCost, pushCost):\\n            if len(s) > 4:\\n                return float(\"inf\")\\n            cost = len(s)*pushCost\\n            for ch in s:\\n                if ch != startAt:\\n                    cost += moveCost\\n                startAt = ch\\n            return cost\\n        \\n        def getStringRepresentation(mins, secs):\\n            s = \"\"\\n            if mins > 0:\\n                s  += str(mins)\\n            if secs < 10 and mins > 0:\\n                s += \"0\"+str(secs) # Note this step. Obvious but important\\n            else:\\n                s += str(secs)\\n                \\n            return s\\n        \\n        s1 = getStringRepresentation(mins, secs)\\n        c1 = getCost(s1, str(startAt), moveCost, pushCost)\\n        \\n        if secs + 60 < 100 and mins > 0:\\n            secs += 60\\n            mins -= 1\\n            \\n        s2 = getStringRepresentation(mins, secs)\\n        if s1 != s2:\\n            c2 = getCost(s2, str(startAt), moveCost, pushCost)\\n            return min(c1, c2)\\n        return c1",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nThis is relatively simple\\n\\n1. Convert target to minutes and seconds and get the string representation\\n2. Since seconds can exceed 60, it may be possible to get a shorter string representation by increasing seconds by 60 and decreasing the \\n\\tminutes by 1. \\n3. For each string representation calculate cost and return the minimum of the two\\n4. Edge case: If the number of minutes is greater than 100 the cost can be set to inf\\n\\n\\'\\'\\'\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        mins = targetSeconds//60\\n        secs = targetSeconds%60\\n        \\n        def getCost(s, startAt, moveCost, pushCost):\\n            if len(s) > 4:\\n                return float(\"inf\")\\n            cost = len(s)*pushCost\\n            for ch in s:\\n                if ch != startAt:\\n                    cost += moveCost\\n                startAt = ch\\n            return cost\\n        \\n        def getStringRepresentation(mins, secs):\\n            s = \"\"\\n            if mins > 0:\\n                s  += str(mins)\\n            if secs < 10 and mins > 0:\\n                s += \"0\"+str(secs) # Note this step. Obvious but important\\n            else:\\n                s += str(secs)\\n                \\n            return s\\n        \\n        s1 = getStringRepresentation(mins, secs)\\n        c1 = getCost(s1, str(startAt), moveCost, pushCost)\\n        \\n        if secs + 60 < 100 and mins > 0:\\n            secs += 60\\n            mins -= 1\\n            \\n        s2 = getStringRepresentation(mins, secs)\\n        if s1 != s2:\\n            c2 = getCost(s2, str(startAt), moveCost, pushCost)\\n            return min(c1, c2)\\n        return c1",
                "codeTag": "Java"
            },
            {
                "id": 1777416,
                "title": "all-cases-explained-in-depth-the-best-explanation-you-will-come-across",
                "content": "Let us break it down into steps:\\n1. step 1 convert the given input *targetSeconds* into minutes and seconds:\\n![image](https://assets.leetcode.com/users/images/f0b69582-f37d-4861-956b-134ae3cb56dd_1645074224.8194745.png)\\n2. step 2 generate all the permuatations for the input:\\n* \\tThere are some things we need to take care of\\n* \\tmin<=99 && sec<=99 as mentioned in the ques.\\n* \\tleading zeroes in minutes are of no use as they will just increase our cost as we would need an extra push and move (ex: 9min 60 sec ---> \"9:60\" and \"09:60\", the first is definetely better so no need for checking second one).\\n* \\tfor an input at most 2 unique permuations will be produced, as we can reduce 1min and add 60 to seconds. cant do it twice as sec<=99.\\n3. Cases, when we produce string equivalent of a valid input\\n* if(mins==0) we need no leading zeroes so we just put seconds into string\\n* if(mins>0){\\n\\t\\tif(secs==0) we need an extra zero to be added at last(9min 0 sec ---> \"9:00\")\\n\\t\\tif(secs<10) we need extra zero before the second value(9min 6sec--->\"9:06\")\\n\\t\\t}\\n![image](https://assets.leetcode.com/users/images/18304ddf-16ff-4ad4-a52c-6b41c10ae31e_1645074863.678407.png)\\n\\n4. step 4. for each produced permuatation computing the cost.\\n![image](https://assets.leetcode.com/users/images/9c577b75-b3b3-4504-a0be-9cf86c09dc8d_1645074955.522471.png)\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        // step 1 convert targetSeconds to minutes\\n        int min = target/60;\\n        int sec = target%60;\\n        \\n        // step 2. go through the permutations\\n        ArrayList<String> list = new ArrayList<String>();\\n        // a input can have atmost 2 permutations\\n        for(int i=0;i<2;i++)\\n        {\\n            // a input is valid only if min<=99 && sec<=99\\n            if(min<100&&sec<100){\\n            String mins = String.valueOf(min);\\n            String secs = String.valueOf(sec);\\n            if(min==0) list.add(new String(secs)); // we need no leading zeroes\\n            else\\n                {\\n                    if(sec==0) // need a extra zero at end\\n                    list.add(new String(mins+secs+\"0\"));\\n                    else if(sec<10) // need a zero berfore second\\n                    list.add(new String(mins+\"0\"+secs));\\n                    else // everything is fine\\n                    list.add(new String(mins+secs));\\n                }\\n            }\\n            // second permuation is taking a minute out and adding it to seconds\\n            min--;\\n            sec+=60;\\n        }\\n        // System.out.println(list);\\n        int res = Integer.MAX_VALUE;\\n        // computing result\\n        for(String str: list)\\n        {\\n            int cost = 0;\\n            char prev = \\'$\\';\\n            for(int i=0;i<str.length();i++)\\n            {\\n                char ch = str.charAt(i);\\n                int chi = ch-\\'0\\';\\n                // if first integer is same as startAt only pushCost is added\\n                if(i==0&&chi==startAt)\\n                {\\n                    prev = ch;\\n                    cost+=pushCost;\\n                    continue;\\n                }\\n                // if curr is same as prev only pushcost is added\\n                if(prev==ch)\\n                {\\n                     prev = ch;\\n                    cost+=pushCost;\\n                }\\n                // if prev is not same moveCost and pushCost both are added\\n                else\\n                {\\n                     prev = ch;\\n                    cost+=pushCost+moveCost;\\n                }\\n            }\\n            res = Math.min(res,cost);\\n            // System.out.println(cost);\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        // step 1 convert targetSeconds to minutes\\n        int min = target/60;\\n        int sec = target%60;\\n        \\n        // step 2. go through the permutations\\n        ArrayList<String> list = new ArrayList<String>();\\n        // a input can have atmost 2 permutations\\n        for(int i=0;i<2;i++)\\n        {\\n            // a input is valid only if min<=99 && sec<=99\\n            if(min<100&&sec<100){\\n            String mins = String.valueOf(min);\\n            String secs = String.valueOf(sec);\\n            if(min==0) list.add(new String(secs)); // we need no leading zeroes\\n            else\\n                {\\n                    if(sec==0) // need a extra zero at end\\n                    list.add(new String(mins+secs+\"0\"));\\n                    else if(sec<10) // need a zero berfore second\\n                    list.add(new String(mins+\"0\"+secs));\\n                    else // everything is fine\\n                    list.add(new String(mins+secs));\\n                }\\n            }\\n            // second permuation is taking a minute out and adding it to seconds\\n            min--;\\n            sec+=60;\\n        }\\n        // System.out.println(list);\\n        int res = Integer.MAX_VALUE;\\n        // computing result\\n        for(String str: list)\\n        {\\n            int cost = 0;\\n            char prev = \\'$\\';\\n            for(int i=0;i<str.length();i++)\\n            {\\n                char ch = str.charAt(i);\\n                int chi = ch-\\'0\\';\\n                // if first integer is same as startAt only pushCost is added\\n                if(i==0&&chi==startAt)\\n                {\\n                    prev = ch;\\n                    cost+=pushCost;\\n                    continue;\\n                }\\n                // if curr is same as prev only pushcost is added\\n                if(prev==ch)\\n                {\\n                     prev = ch;\\n                    cost+=pushCost;\\n                }\\n                // if prev is not same moveCost and pushCost both are added\\n                else\\n                {\\n                     prev = ch;\\n                    cost+=pushCost+moveCost;\\n                }\\n            }\\n            res = Math.min(res,cost);\\n            // System.out.println(cost);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777364,
                "title": "java-only-two-options-clean-code-0ms",
                "content": "What a weird question.\\nOnly two options:\\n\\n\\t1. (minute, second)\\n\\t2. (minute - 1, second + 60)\\n\\nRemember to check boundary. Also, only press 0 when there is **any** previous number that is not 0.\\n\\t\\n```Java\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int m = targetSeconds / 60;\\n        int s = targetSeconds % 60;\\n        int one = find(startAt, moveCost, pushCost, m, s);\\n        int two = find(startAt, moveCost, pushCost, m - 1, s + 60);\\n        if (s >= 40 || m == 0) return one;\\n        if (m >  99) return two;\\n        return Math.min(one, two);\\n    }\\n\\n    private int find(int i, int c, int p, int m, int s){\\n        int ans = 0;\\n        int[] data = new int[]{0, i}; //prev key sum, prev key\\n        ans += each(c, p, m / 10, data);\\n        ans += each(c, p, m % 10, data);\\n        ans += each(c, p, s / 10, data);\\n        ans += each(c, p, s % 10, data);\\n        return ans;\\n    }\\n\\n    private int each(int c, int p, int key, int[] data){\\n        data[0] += key;\\n        if (data[0] == 0) return 0;\\n        int ans = (data[1] == key? p : p + c);\\n        data[1] = key;\\n        return ans;\\n    }\\n}\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int m = targetSeconds / 60;\\n        int s = targetSeconds % 60;\\n        int one = find(startAt, moveCost, pushCost, m, s);\\n        int two = find(startAt, moveCost, pushCost, m - 1, s + 60);\\n        if (s >= 40 || m == 0) return one;\\n        if (m >  99) return two;\\n        return Math.min(one, two);\\n    }\\n\\n    private int find(int i, int c, int p, int m, int s){\\n        int ans = 0;\\n        int[] data = new int[]{0, i}; //prev key sum, prev key\\n        ans += each(c, p, m / 10, data);\\n        ans += each(c, p, m % 10, data);\\n        ans += each(c, p, s / 10, data);\\n        ans += each(c, p, s % 10, data);\\n        return ans;\\n    }\\n\\n    private int each(int c, int p, int key, int[] data){\\n        data[0] += key;\\n        if (data[0] == 0) return 0;\\n        int ans = (data[1] == key? p : p + c);\\n        data[1] = key;\\n        return ans;\\n    }\\n}\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747567,
                "title": "c-simple-approach-brute-force",
                "content": "IDEA: Generating all possible ways by which we can get the target seconds, as question suggests there is only 4 digit number so its not too difficult to try all possible ways.\\n\\nAfter generating all possible ways, just splitting them into digits and calculate the cost.\\n\\nCode (Easy Understanding):\\n- set is because 0543 and 543 should be considered once.\\n\\n```\\nclass Solution {\\n    #define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    set<int> generateNumbers(int n){\\n        set<int> ss;\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int k = 0;k<=9;k++){\\n                    for(int l=0;l<=9;l++){\\n                        int minutes = i*10 + j;\\n                        int seconds = k*10 + l;\\n                        if((minutes*60 + seconds) == n){\\n                            ss.insert(minutes*100 + seconds);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ss;\\n    }\\n    \\n    vector<vector<int>> convert(set<int>& ss){\\n        vector<vector<int>> allPossible;\\n          for(auto val : ss){\\n            vector<int> vec;\\n            while(val){\\n              vec.push_back(val%10);\\n              val = val/10;\\n            }\\n            reverse(vec.begin(),vec.end());\\n            allPossible.push_back(vec);\\n          }\\n        return allPossible;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        auto allPossible = generateNumbers(targetSeconds);\\n        auto possible = convert(allPossible);\\n        vector<int> costs;\\n        for(auto& vec:possible){\\n            int cost = 0;\\n            int st = startAt;\\n            for(auto&val:vec){\\n                if(st == val){\\n                    cost += pushCost;\\n                }else{\\n                    cost += moveCost;\\n                    cost += pushCost;\\n                    st = val;\\n                }\\n            }\\n            costs.emplace_back(cost);\\n        }\\n        return *min_element(costs.begin(),costs.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    #define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    set<int> generateNumbers(int n){\\n        set<int> ss;\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int k = 0;k<=9;k++){\\n                    for(int l=0;l<=9;l++){\\n                        int minutes = i*10 + j;\\n                        int seconds = k*10 + l;\\n                        if((minutes*60 + seconds) == n){\\n                            ss.insert(minutes*100 + seconds);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ss;\\n    }\\n    \\n    vector<vector<int>> convert(set<int>& ss){\\n        vector<vector<int>> allPossible;\\n          for(auto val : ss){\\n            vector<int> vec;\\n            while(val){\\n              vec.push_back(val%10);\\n              val = val/10;\\n            }\\n            reverse(vec.begin(),vec.end());\\n            allPossible.push_back(vec);\\n          }\\n        return allPossible;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        auto allPossible = generateNumbers(targetSeconds);\\n        auto possible = convert(allPossible);\\n        vector<int> costs;\\n        for(auto& vec:possible){\\n            int cost = 0;\\n            int st = startAt;\\n            for(auto&val:vec){\\n                if(st == val){\\n                    cost += pushCost;\\n                }else{\\n                    cost += moveCost;\\n                    cost += pushCost;\\n                    st = val;\\n                }\\n            }\\n            costs.emplace_back(cost);\\n        }\\n        return *min_element(costs.begin(),costs.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1747373,
                "title": "c-100-fast-looks-lengthy-but-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min1=targetSeconds/60;\\n        int sec1=targetSeconds%60;\\n        int min2=min1-1;\\n        int sec2=targetSeconds-(min2*60);\\n        //cout<<min1<<sec1<<\" \"<<min2<<sec2;\\n        string str1=\"0000\";\\n        int i=1;\\n        if(sec1<=99 && min1<=99){\\n            while(min1){\\n                int val=min1%10;\\n                str1[i--]=val+\\'0\\';\\n                min1/=10;\\n            }\\n             i=3;\\n            while(sec1){\\n                int val=sec1%10;\\n                str1[i--]=val+\\'0\\';\\n                sec1/=10;\\n            }\\n        }\\n        \\n        \\n        string str2=\"0000\";\\n        if(sec2 <= 99 && min2<=99){\\n                int i=1;\\n            while(min2){\\n                int val=min2%10;\\n                str2[i--]=val+\\'0\\';\\n                min2/=10;\\n            }\\n             i=3;\\n            while(sec2){\\n                int val=sec2%10;\\n                str2[i--]=val+\\'0\\';\\n                sec2/=10;\\n            }\\n        }\\n        //cout<<str1<<\" \"<<str2<<endl;\\n        \\n        \\n        //cost for str1\\n        int flag=0;\\n        i=0;\\n        char sa=startAt+\\'0\\';\\n        long cost1=0;\\n        while(i<str1.size()){\\n            if(flag==0 && str1[i]==\\'0\\'){\\n                i++;continue;\\n            }else{\\n                flag=1;\\n                if(sa!=str1[i]){\\n                    cost1+=(moveCost+pushCost);\\n                    sa=str1[i];\\n                }else\\n                    cost1+=pushCost;\\n                \\n                i++;\\n            }\\n            \\n        }\\n        \\n        //cost for str2\\n        flag=0;\\n        i=0;\\n        sa=startAt+\\'0\\';\\n        long cost2=0;\\n         while(i<str2.size()){\\n            if(flag==0 && str2[i]==\\'0\\'){\\n                i++;continue;\\n            }else{\\n                flag=1;\\n                if(sa!=str2[i]){\\n                    cost2+=(moveCost+pushCost);\\n                    sa=str2[i];\\n                }else\\n                    cost2+=pushCost;\\n                \\n                i++;\\n            }\\n            \\n        }\\n        //cout<<cost1<<\" \"<<cost2<<endl;\\n        if(cost1==0)return cost2;\\n        if(cost2==0)return cost1;\\n        return min(cost1,cost2);\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min1=targetSeconds/60;\\n        int sec1=targetSeconds%60;\\n        int min2=min1-1;\\n        int sec2=targetSeconds-(min2*60);\\n        //cout<<min1<<sec1<<\" \"<<min2<<sec2;\\n        string str1=\"0000\";\\n        int i=1;\\n        if(sec1<=99 && min1<=99){\\n            while(min1){\\n                int val=min1%10;\\n                str1[i--]=val+\\'0\\';\\n                min1/=10;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1747272,
                "title": "python3-beats-100-time",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        poss = [(targetSeconds // 60, targetSeconds % 60)]  # store possibilities as (minutes, seconds)\\n        \\n        if poss[0][0] > 99:  # for when targetSeconds >= 6000\\n            poss = [(99, poss[0][1]+60)]\\n            \\n        if poss[0][0] >= 1 and (poss[0][1]+60) <= 99:\\n\\t\\t\\t# adding a second possibility e.g. (01, 16) -> (0, 76)\\n            poss.append((poss[0][0]-1, poss[0][1]+60))\\n            \\n        costs = list()\\n        \\n        for i in poss:\\n            curr_start = startAt\\n            curr_cost = 0\\n            \\n            minutes = str(i[0])\\n            if i[0] != 0:  # 0s are prepended, so no need to push 0s\\n                for j in minutes:\\n                    if int(j) != curr_start:\\n                        curr_cost += moveCost\\n                        curr_start = int(j)\\n                    curr_cost += pushCost\\n                    \\n            seconds = str(i[1])\\n            if len(seconds) == 1 and i[0] != 0:  # seconds is a single digit, prepend a \"0\" to it\\n                seconds = \"0\" + seconds\\n            \\n            for j in seconds:\\n                if int(j) != curr_start:\\n                    curr_cost += moveCost\\n                    curr_start = int(j)\\n                curr_cost += pushCost\\n            costs.append(curr_cost)\\n            \\n        return min(costs)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        poss = [(targetSeconds // 60, targetSeconds % 60)]  # store possibilities as (minutes, seconds)\\n        \\n        if poss[0][0] > 99:  # for when targetSeconds >= 6000\\n            poss = [(99, poss[0][1]+60)]\\n            \\n        if poss[0][0] >= 1 and (poss[0][1]+60) <= 99:\\n\\t\\t\\t# adding a second possibility e.g. (01, 16) -> (0, 76)\\n            poss.append((poss[0][0]-1, poss[0][1]+60))\\n            \\n        costs = list()\\n        \\n        for i in poss:\\n            curr_start = startAt\\n            curr_cost = 0\\n            \\n            minutes = str(i[0])\\n            if i[0] != 0:  # 0s are prepended, so no need to push 0s\\n                for j in minutes:\\n                    if int(j) != curr_start:\\n                        curr_cost += moveCost\\n                        curr_start = int(j)\\n                    curr_cost += pushCost\\n                    \\n            seconds = str(i[1])\\n            if len(seconds) == 1 and i[0] != 0:  # seconds is a single digit, prepend a \"0\" to it\\n                seconds = \"0\" + seconds\\n            \\n            for j in seconds:\\n                if int(j) != curr_start:\\n                    curr_cost += moveCost\\n                    curr_start = int(j)\\n                curr_cost += pushCost\\n            costs.append(curr_cost)\\n            \\n        return min(costs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747212,
                "title": "tips-for-those-who-got-lot-of-wa-python",
                "content": "I know this problem is very poor and deceptive. But a lot of us have wasted a lot of time in the contest on this. So solution for those legends. Keep grinding\\n\\n```\\ndef minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        \\n        secs = targetSeconds%60\\n        mins = targetSeconds//60\\n        cost = float(\\'inf\\')\\n        booli = False\\n        \\n        # print(mins,secs)\\n        if secs==0:\\n            time1 = str(mins) + \\'00\\'\\n            time2 = str(mins - 1) + \\'60\\'\\n            if mins >= 99:\\n                    time1 = time2 = str(mins - 1) + str(secs + 60)\\n        else:\\n            print(mins)\\n            if mins<=1:\\n                # print(\\'here\\')\\n                time = str(targetSeconds)\\n                if int(time) <= 99:\\n                    booli = True\\n            if 1<=secs <=9:\\n                time1 = str(mins) +\\'0\\' + str(secs)\\n                time2 = str(mins - 1) + str(secs + 60)\\n                if mins >= 99:\\n                    time1 = time2 = str(mins - 1) + str(secs + 60)\\n            elif 10<= secs <= 39:\\n                time1 = str(mins) + str(secs)\\n                time2 = str(mins - 1) + str(secs + 60)\\n                if mins >= 99:\\n                    time1 = time2 = str(mins - 1) + str(secs + 60)\\n            else:\\n                if mins <=99:\\n                    time1 = str(mins) + str(secs)\\n                    time2 = time1\\n                else:\\n                    time1=time2 = str(mins-1) + str(secs + 60)\\n        \\n        arr = [time1,time2]\\n        if booli:\\n            arr.append(time)\\n        # print(arr)\\n        for ele in arr:\\n            if str(startAt)==ele[0]:\\n                curr = pushCost\\n            else:\\n                curr = moveCost+pushCost\\n            for i in range(1,len(ele)):\\n                if ele[i] == ele[i-1]:\\n                    curr += pushCost\\n                else:\\n                    curr += moveCost + pushCost\\n            print(curr,ele)\\n            cost = min(cost,curr)\\n                \\n        return cost\\n```\\nSorry for contest quality code. Took me a lot of debugging.",
                "solutionTags": [],
                "code": "```\\ndef minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        \\n        secs = targetSeconds%60\\n        mins = targetSeconds//60\\n        cost = float(\\'inf\\')\\n        booli = False\\n        \\n        # print(mins,secs)\\n        if secs==0:\\n            time1 = str(mins) + \\'00\\'\\n            time2 = str(mins - 1) + \\'60\\'\\n            if mins >= 99:\\n                    time1 = time2 = str(mins - 1) + str(secs + 60)\\n        else:\\n            print(mins)\\n            if mins<=1:\\n                # print(\\'here\\')\\n                time = str(targetSeconds)\\n                if int(time) <= 99:\\n                    booli = True\\n            if 1<=secs <=9:\\n                time1 = str(mins) +\\'0\\' + str(secs)\\n                time2 = str(mins - 1) + str(secs + 60)\\n                if mins >= 99:\\n                    time1 = time2 = str(mins - 1) + str(secs + 60)\\n            elif 10<= secs <= 39:\\n                time1 = str(mins) + str(secs)\\n                time2 = str(mins - 1) + str(secs + 60)\\n                if mins >= 99:\\n                    time1 = time2 = str(mins - 1) + str(secs + 60)\\n            else:\\n                if mins <=99:\\n                    time1 = str(mins) + str(secs)\\n                    time2 = time1\\n                else:\\n                    time1=time2 = str(mins-1) + str(secs + 60)\\n        \\n        arr = [time1,time2]\\n        if booli:\\n            arr.append(time)\\n        # print(arr)\\n        for ele in arr:\\n            if str(startAt)==ele[0]:\\n                curr = pushCost\\n            else:\\n                curr = moveCost+pushCost\\n            for i in range(1,len(ele)):\\n                if ele[i] == ele[i-1]:\\n                    curr += pushCost\\n                else:\\n                    curr += moveCost + pushCost\\n            print(curr,ele)\\n            cost = min(cost,curr)\\n                \\n        return cost\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1747187,
                "title": "python-3-solution-and-explanation-edge-cases-sucks",
                "content": "\\n# [Python 3] Solution and Explanation\\uD83D\\uDE24Edge Cases Sucks \\uD83D\\uDE24\\n\\n## MAIN IDEA\\nWe make targetSeconds into a list to store which buttons we have to press on, and then **calculateCost** to calculate actual cost finally return min cost.\\n\\n## Cases\\n> 1\\uFE0F\\u20E3 If **targetSeconds < 100** we can directly append a buttonList bt sperate digit in targetSeconds\\n> 2\\uFE0F\\u20E3 We calculate seconds into minutes + remain seconds, but be careful minutes will **greater than 100** \\uD83D\\uDE24 we have to round it down to seconds.\\n> 3\\uFE0F\\u20E3 In the example we could make 10:00 to 9:60 when second part is **smaller than 40** (dont have to carry in) and **minutes greater than 1**\\n\\n## Complexity Analysis\\n* Time : O(1)\\n* Space: O(1)\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        buttons = []\\n        if targetSeconds < 100:\\n            buttons.append([int(c) for c in str(targetSeconds)])\\n            \\n        minTargets = targetSeconds // 60 * 100 + targetSeconds % 60\\n        if minTargets // 100 < 100:\\n            buttons.append([int(c) for c in str(minTargets)])\\n            \\n        if minTargets % 100 < 40 and minTargets > 200:\\n            newTarget = minTargets - 100 + 60\\n            buttons.append([int(c) for c in str(newTarget)])\\n            \\n        minCost = float(\\'inf\\')\\n        \\n        for buttonList in buttons:\\n            currentCost = self.calculateCost(startAt, moveCost, pushCost, buttonList)\\n            minCost = min(minCost, currentCost)\\n        return minCost\\n            \\n            \\n    def calculateCost(self, startAt, moveCost, pushCost, targetButtons):\\n        cost = 0\\n        for button in targetButtons:\\n            if button != startAt:\\n                cost += moveCost\\n                startAt = button\\n            cost += pushCost\\n        return cost\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        buttons = []\\n        if targetSeconds < 100:\\n            buttons.append([int(c) for c in str(targetSeconds)])\\n            \\n        minTargets = targetSeconds // 60 * 100 + targetSeconds % 60\\n        if minTargets // 100 < 100:\\n            buttons.append([int(c) for c in str(minTargets)])\\n            \\n        if minTargets % 100 < 40 and minTargets > 200:\\n            newTarget = minTargets - 100 + 60\\n            buttons.append([int(c) for c in str(newTarget)])\\n            \\n        minCost = float(\\'inf\\')\\n        \\n        for buttonList in buttons:\\n            currentCost = self.calculateCost(startAt, moveCost, pushCost, buttonList)\\n            minCost = min(minCost, currentCost)\\n        return minCost\\n            \\n            \\n    def calculateCost(self, startAt, moveCost, pushCost, targetButtons):\\n        cost = 0\\n        for button in targetButtons:\\n            if button != startAt:\\n                cost += moveCost\\n                startAt = button\\n            cost += pushCost\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747168,
                "title": "java-not-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n    {\\n            int min1 = 0, min2 = 0;\\n            int[] num1 = new int[4]; // Storing each digits\\n            num1[0] = (targetSeconds/60)/10;\\n            num1[1] = (targetSeconds/60)%10;\\n            num1[2] = (targetSeconds%60)/10;\\n            num1[3] = (targetSeconds%60)%10;\\n            if(targetSeconds >= 6000) // Upper limit is 99 minutes\\n            {\\n                num1[0] = 9;\\n                num1[1] = 9;\\n                num1[2] += 6;\\n            }\\n            int cur = 3; \\n            int cur_dig = startAt; // Stores last pressed number\\n            boolean zero = true; // To avoid leading zeroes\\n            while(cur >= 0)\\n            {\\n                if(num1[3-cur] != 0)\\n                    zero = false;\\n                if(zero && num1[3-cur] == 0) // Leading zeroes\\n                {\\n                    cur--;\\n                    continue;\\n                }\\n                min1 += minCost(cur_dig, moveCost, pushCost, num1[3-cur]);\\n                cur_dig = num1[3-cur];\\n                cur--;\\n            }\\n            cur = 3;\\n            if(targetSeconds < 60 || targetSeconds >= 5980 || num1[2]>=4) // Cases where only one way to reach the duration\\n                return min1;\\n            if(num1[1] == 0) // If minutes are 10,20,30 etc, next would be 9,19,29 and so on\\n            {\\n                num1[1] = 9;\\n                num1[0]--;\\n            }\\n            else // If not 10,20,30, then simply one lesser, e.g. 19 -> 18\\n                num1[1]--;\\n            num1[2]+=6;\\n            zero = true;\\n            cur_dig = startAt;\\n            while(cur >= 0)\\n            {                 \\n                if(num1[3-cur] != 0)\\n                    zero = false;\\n                if(zero && num1[3-cur] == 0)\\n                {\\n                    cur--;\\n                    continue;       \\n                }\\n                min2 += minCost(cur_dig, moveCost, pushCost, num1[3-cur]);\\n                cur_dig = num1[3-cur];\\n                cur--;\\n            }\\n            return Math.min(min1,min2);\\n    }\\n    private static int minCost(int cur,int move, int push, int target)\\n    {\\n        if(target != cur)\\n            return move+push;\\n        else\\n            return push;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n    {\\n            int min1 = 0, min2 = 0;\\n            int[] num1 = new int[4]; // Storing each digits\\n            num1[0] = (targetSeconds/60)/10;\\n            num1[1] = (targetSeconds/60)%10;\\n            num1[2] = (targetSeconds%60)/10;\\n            num1[3] = (targetSeconds%60)%10;\\n            if(targetSeconds >= 6000) // Upper limit is 99 minutes\\n            {\\n                num1[0] = 9;\\n                num1[1] = 9;\\n                num1[2] += 6;\\n            }\\n            int cur = 3; \\n            int cur_dig = startAt; // Stores last pressed number\\n            boolean zero = true; // To avoid leading zeroes\\n            while(cur >= 0)\\n            {\\n                if(num1[3-cur] != 0)\\n                    zero = false;\\n                if(zero && num1[3-cur] == 0) // Leading zeroes\\n                {\\n                    cur--;\\n                    continue;\\n                }\\n                min1 += minCost(cur_dig, moveCost, pushCost, num1[3-cur]);\\n                cur_dig = num1[3-cur];\\n                cur--;\\n            }\\n            cur = 3;\\n            if(targetSeconds < 60 || targetSeconds >= 5980 || num1[2]>=4) // Cases where only one way to reach the duration\\n                return min1;\\n            if(num1[1] == 0) // If minutes are 10,20,30 etc, next would be 9,19,29 and so on\\n            {\\n                num1[1] = 9;\\n                num1[0]--;\\n            }\\n            else // If not 10,20,30, then simply one lesser, e.g. 19 -> 18\\n                num1[1]--;\\n            num1[2]+=6;\\n            zero = true;\\n            cur_dig = startAt;\\n            while(cur >= 0)\\n            {                 \\n                if(num1[3-cur] != 0)\\n                    zero = false;\\n                if(zero && num1[3-cur] == 0)\\n                {\\n                    cur--;\\n                    continue;       \\n                }\\n                min2 += minCost(cur_dig, moveCost, pushCost, num1[3-cur]);\\n                cur_dig = num1[3-cur];\\n                cur--;\\n            }\\n            return Math.min(min1,min2);\\n    }\\n    private static int minCost(int cur,int move, int push, int target)\\n    {\\n        if(target != cur)\\n            return move+push;\\n        else\\n            return push;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747099,
                "title": "short-explained-solution-loop-through-each-possible-combination-o-1-time-space",
                "content": "Since there were many possible ways to write the number and that would have been a tedious task to find all so simply check all the possible combinations you can put on microwave \\n\\n* The crux was to check all the possible ways from 0001 to 9999 \\n* If you find the number of seconds equal to target seconds.\\n* Count how many energy  you need to  make this possible combination.\\n\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n    int ans=INT_MAX;\\n    for(int i=1;i<=9999;i++)\\n    {\\n        int seconds=((i/100)*60)+(i%100);// count number of seconds\\n    \\n        if(seconds!=targetSeconds)// check whether no. of  seconds are equal to target seconds or not\\n            continue;\\n        \\n        int start=startAt,count=0,j=0;// start time \\n        string s=to_string(i); // i converted the  combination to string so that i can loop through it easily \\n        while(j<s.size()) // part where i calculated the number of points\\n        {\\n            if(s[j]!=start+\\'0\\') // if start position is not thedesired position\\n                count+=moveCost+pushCost;\\n            else\\n                count+=pushCost;  \\n            start=s[j++]-\\'0\\';  // change the start position\\n        }\\n        ans=min(ans,count);   \\n    }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n    int ans=INT_MAX;\\n    for(int i=1;i<=9999;i++)\\n    {\\n        int seconds=((i/100)*60)+(i%100);// count number of seconds\\n    \\n        if(seconds!=targetSeconds)// check whether no. of  seconds are equal to target seconds or not\\n            continue;\\n        \\n        int start=startAt,count=0,j=0;// start time \\n        string s=to_string(i); // i converted the  combination to string so that i can loop through it easily \\n        while(j<s.size()) // part where i calculated the number of points\\n        {\\n            if(s[j]!=start+\\'0\\') // if start position is not thedesired position\\n                count+=moveCost+pushCost;\\n            else\\n                count+=pushCost;  \\n            start=s[j++]-\\'0\\';  // change the start position\\n        }\\n        ans=min(ans,count);   \\n    }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747050,
                "title": "c-beats-100-time-only-2-cases-for-targetscore-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long compute(int start, int move, int push, string target)\\n    {\\n        int len = target.size();\\n        long long cost = 0;\\n        int curr = start;  //keeps track of start point\\n        \\n        for(int i=0;i<len;i++)\\n        {\\n            int v1= target[i]-\\'0\\';\\n            \\n            if(curr==v1)\\n            {\\n                cost+= push;  //if the combination requires a digit at the current point, simply push it\\n            }else{\\n                cost+= move+push;  //otherwise, we move to the digit and push\\n            }\\n            curr=v1;\\n        }\\n        return cost;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n\\t\\t//There will be two-cases for Target Score ~ (Minutes:Seconds) OR ((Minutes-1):Seconds)\\n        int a = targetSeconds/60;\\n        int b = targetSeconds%60;\\n        \\n        vector<string> pos;\\n        \\n        string fin = \"\";\\n        \\n        if(a>99 && b<=39)  //If this is the case, then we only have one possibility that is to have both in minutes\\n        {\\n            a--;\\n            b+=60;\\n            fin= to_string(a) + to_string(b);\\n            pos.push_back(fin);\\n        }else{\\n\\t\\t\\n\\t\\t\\t//Case-1\\n            if(a!=0){\\n                fin = to_string(a);\\n            }\\n            string c = to_string(b);\\n            \\n            if(a!=0){                                //debug1\\n                while(c.size()!=2)  //Prepending Zeros for seconds if minutes are not 0\\n                {\\n                    c = \"0\" + c;   \\n                }\\n            }\\n            fin += c;\\n            pos.push_back(fin);\\n            \\n            int save= (targetSeconds- ((a-1)*60));  //this is to check if save is less than 99 as seconds cannot be greater than 99\\n            \\n            if((a-1)>=0 && save>=0 && save<= 99)  //debug2: if save is within range, we have another possibility\\n            {\\n                fin = \"\";\\n                if(a-1 !=0){\\n                    fin = to_string(a-1);\\n                }\\n                b+= 60;\\n                fin+= to_string(b);\\n                pos.push_back(fin);\\n            }\\n        }\\n        \\n        long long ans= INT_MAX;\\n        \\n\\t\\t//Now, for every possibility, simply check the cost and find minimum\\n        for(int i=0;i<pos.size();i++)\\n        {\\n            long long cost= compute(startAt, moveCost, pushCost, pos[i]);\\n            if(cost<ans)\\n            {\\n                ans=cost;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    long long compute(int start, int move, int push, string target)\\n    {\\n        int len = target.size();\\n        long long cost = 0;\\n        int curr = start;  //keeps track of start point\\n        \\n        for(int i=0;i<len;i++)\\n        {\\n            int v1= target[i]-\\'0\\';\\n            \\n            if(curr==v1)\\n            {\\n                cost+= push;  //if the combination requires a digit at the current point, simply push it\\n            }else{\\n                cost+= move+push;  //otherwise, we move to the digit and push\\n            }\\n            curr=v1;\\n        }\\n        return cost;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n\\t\\t//There will be two-cases for Target Score ~ (Minutes:Seconds) OR ((Minutes-1):Seconds)\\n        int a = targetSeconds/60;\\n        int b = targetSeconds%60;\\n        \\n        vector<string> pos;\\n        \\n        string fin = \"\";\\n        \\n        if(a>99 && b<=39)  //If this is the case, then we only have one possibility that is to have both in minutes\\n        {\\n            a--;\\n            b+=60;\\n            fin= to_string(a) + to_string(b);\\n            pos.push_back(fin);\\n        }else{\\n\\t\\t\\n\\t\\t\\t//Case-1\\n            if(a!=0){\\n                fin = to_string(a);\\n            }\\n            string c = to_string(b);\\n            \\n            if(a!=0){                                //debug1\\n                while(c.size()!=2)  //Prepending Zeros for seconds if minutes are not 0\\n                {\\n                    c = \"0\" + c;   \\n                }\\n            }\\n            fin += c;\\n            pos.push_back(fin);\\n            \\n            int save= (targetSeconds- ((a-1)*60));  //this is to check if save is less than 99 as seconds cannot be greater than 99\\n            \\n            if((a-1)>=0 && save>=0 && save<= 99)  //debug2: if save is within range, we have another possibility\\n            {\\n                fin = \"\";\\n                if(a-1 !=0){\\n                    fin = to_string(a-1);\\n                }\\n                b+= 60;\\n                fin+= to_string(b);\\n                pos.push_back(fin);\\n            }\\n        }\\n        \\n        long long ans= INT_MAX;\\n        \\n\\t\\t//Now, for every possibility, simply check the cost and find minimum\\n        for(int i=0;i<pos.size();i++)\\n        {\\n            long long cost= compute(startAt, moveCost, pushCost, pos[i]);\\n            if(cost<ans)\\n            {\\n                ans=cost;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383156,
                "title": "c-all-combination-simple-easy-readable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int mm1=targetSeconds;\\n        int ss1=0;\\n        mm1=mm1/60;\\n        ss1=targetSeconds%60;\\n        \\n        int mm2=-1,ss2=-1;\\n        \\n        if(ss1<=39){\\n            mm2=mm1-1;\\n            ss2=ss1+60;\\n        }\\n\\n//\\t\\tcout<<mm2<<\" \"<<ss2<<endl;\\n\\n\\t\\t\\n        \\n        int sum1=INT_MAX;\\n        int sum2=INT_MAX;\\n\\n        if(mm1<=99){\\n            string s1=\"\";\\n            if(ss1<10){\\n                s1=to_string(mm1)+\\'0\\'+to_string(ss1);\\n            }\\n            else{\\n                s1=to_string(mm1)+to_string(ss1);\\n            }\\n\\n            string t1=\"\";\\n            int flag=1;\\n            for(int i=0;i<s1.length();i++){\\n                if(flag==0){\\n                    t1=t1+s1[i];\\n                }\\n                if(flag==1 && s1[i]!=\\'0\\'){\\n                    flag=0;\\n                    t1=t1+s1[i];\\n                }\\n            }\\n            \\n            \\n    //\\t\\tcout<<t1<<endl;\\n            \\n\\n            sum1=0;\\n            if(int(t1[0]-48)==startAt){\\n                sum1=sum1+pushCost;\\n            }\\n            else{\\n                sum1=sum1+pushCost+moveCost;\\n            }\\n            for(int i=1;i<t1.length();i++){\\n                if(t1[i]==t1[i-1]){\\n                    sum1=sum1+pushCost;\\n                }\\n                else{\\n                    sum1=sum1+pushCost+moveCost;\\n                }\\n            }\\n        }\\n\\n\\n        if(mm2!=-1){\\n            sum2=0;\\n            string s2=to_string(mm2)+to_string(ss2);\\n\\t\\t\\tstring t2=\"\";\\n\\t\\t\\tint flag=1;\\n\\t\\t\\tfor(int i=0;i<s2.length();i++){\\n\\t\\t\\t\\tif(flag==0){\\n\\t\\t\\t\\t\\tt2=t2+s2[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag==1 && s2[i]!=\\'0\\'){\\n\\t\\t\\t\\t\\tflag=0;\\n\\t\\t\\t\\t\\tt2=t2+s2[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n//\\t\\t\\tcout<<t2<<endl;\\n            if(int(t2[0]-48)==startAt){\\n                sum2=sum2+pushCost;\\n            }\\n\\t\\t\\telse{\\n\\t\\t\\t\\tsum2=sum2+pushCost+moveCost;\\n\\t\\t\\t}\\n            for(int i=1;i<t2.length();i++){\\n                if(t2[i]==t2[i-1]){\\n                    sum2=sum2+pushCost;\\n                }\\n                else{\\n                    sum2=sum2+pushCost+moveCost;\\n                }\\n            }\\n            \\n        }\\n\\n        cout<<sum1<<\" \"<<sum2;\\n\\n        return min(sum1,sum2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int mm1=targetSeconds;\\n        int ss1=0;\\n        mm1=mm1/60;\\n        ss1=targetSeconds%60;\\n        \\n        int mm2=-1,ss2=-1;\\n        \\n        if(ss1<=39){\\n            mm2=mm1-1;\\n            ss2=ss1+60;\\n        }\\n\\n//\\t\\tcout<<mm2<<\" \"<<ss2<<endl;\\n\\n\\t\\t\\n        \\n        int sum1=INT_MAX;\\n        int sum2=INT_MAX;\\n\\n        if(mm1<=99){\\n            string s1=\"\";\\n            if(ss1<10){\\n                s1=to_string(mm1)+\\'0\\'+to_string(ss1);\\n            }\\n            else{\\n                s1=to_string(mm1)+to_string(ss1);\\n            }\\n\\n            string t1=\"\";\\n            int flag=1;\\n            for(int i=0;i<s1.length();i++){\\n                if(flag==0){\\n                    t1=t1+s1[i];\\n                }\\n                if(flag==1 && s1[i]!=\\'0\\'){\\n                    flag=0;\\n                    t1=t1+s1[i];\\n                }\\n            }\\n            \\n            \\n    //\\t\\tcout<<t1<<endl;\\n            \\n\\n            sum1=0;\\n            if(int(t1[0]-48)==startAt){\\n                sum1=sum1+pushCost;\\n            }\\n            else{\\n                sum1=sum1+pushCost+moveCost;\\n            }\\n            for(int i=1;i<t1.length();i++){\\n                if(t1[i]==t1[i-1]){\\n                    sum1=sum1+pushCost;\\n                }\\n                else{\\n                    sum1=sum1+pushCost+moveCost;\\n                }\\n            }\\n        }\\n\\n\\n        if(mm2!=-1){\\n            sum2=0;\\n            string s2=to_string(mm2)+to_string(ss2);\\n\\t\\t\\tstring t2=\"\";\\n\\t\\t\\tint flag=1;\\n\\t\\t\\tfor(int i=0;i<s2.length();i++){\\n\\t\\t\\t\\tif(flag==0){\\n\\t\\t\\t\\t\\tt2=t2+s2[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag==1 && s2[i]!=\\'0\\'){\\n\\t\\t\\t\\t\\tflag=0;\\n\\t\\t\\t\\t\\tt2=t2+s2[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n//\\t\\t\\tcout<<t2<<endl;\\n            if(int(t2[0]-48)==startAt){\\n                sum2=sum2+pushCost;\\n            }\\n\\t\\t\\telse{\\n\\t\\t\\t\\tsum2=sum2+pushCost+moveCost;\\n\\t\\t\\t}\\n            for(int i=1;i<t2.length();i++){\\n                if(t2[i]==t2[i-1]){\\n                    sum2=sum2+pushCost;\\n                }\\n                else{\\n                    sum2=sum2+pushCost+moveCost;\\n                }\\n            }\\n            \\n        }\\n\\n        cout<<sum1<<\" \"<<sum2;\\n\\n        return min(sum1,sum2);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2499878,
                "title": "python-sharing-my-simple-solution",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def cost(s):\\n            ans = 0\\n            prev_pos = startAt\\n            for i in range(len(s)):\\n                if prev_pos != int(s[i]):\\n                    prev_pos = int(s[i])\\n                    ans += moveCost\\n                ans += pushCost\\n            return ans\\n        secs = targetSeconds % 60\\n        mins = (targetSeconds - secs) // 60\\n        c = sys.maxsize\\n        if mins < 100:\\n            c = min(c, cost(str(mins * 100 + secs)))\\n        if mins > 0 and secs < 40:\\n            c = min(c, cost(str((mins - 1) * 100 + (secs + 60))))\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def cost(s):\\n            ans = 0\\n            prev_pos = startAt\\n            for i in range(len(s)):\\n                if prev_pos != int(s[i]):\\n                    prev_pos = int(s[i])\\n                    ans += moveCost\\n                ans += pushCost\\n            return ans\\n        secs = targetSeconds % 60\\n        mins = (targetSeconds - secs) // 60\\n        c = sys.maxsize\\n        if mins < 100:\\n            c = min(c, cost(str(mins * 100 + secs)))\\n        if mins > 0 and secs < 40:\\n            c = min(c, cost(str((mins - 1) * 100 + (secs + 60))))\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442510,
                "title": "java-0ms-with-explanation",
                "content": "Implement a function that calculates the cost given mins & secs.\\n```\\nclass Solution {\\n    int moveCost = 0, pushCost = 0;\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        this.moveCost = moveCost;\\n        this.pushCost = pushCost;\\n        int mins = targetSeconds / 60;\\n        int secs = targetSeconds % 60;\\n        // edge case: mins == 100. The only possible representation is 99:xx, xx = secs + 60\\n        if (mins == 100) {\\n            return cost(mins - 1, secs + 60, startAt);\\n        } \\n        \\n        // Multiple representations case: when mins is not 0, and secs is less than 40. \\n        // eg: 5:12 has two representations: 1. 5:12 (regular) 2. 4: 72 (mins - 1, secs + 60)        \\n        if (mins != 0 && secs < 40) {\\n            return Math.min(cost(mins, secs, startAt), cost(mins - 1, secs + 60, startAt));\\n        } \\n        // Note when mins == 0, only one representation exists (0, secs);\\n        // Or when secs >= 40, only one representation exists b/c if we add 60 to secs, the \\n        // results will exceeds 100, which is invalid.\\n        return cost(mins, secs, startAt);\\n    }\\n    \\n    private int cost(int mins, int secs, int startAt) {\\n        int res = 0;\\n        // When mins >= 10, first digit is valid\\n        if (mins >= 10) {\\n            int firstDigit = mins / 10;\\n            if (firstDigit != startAt) {\\n                startAt = firstDigit;\\n                res += moveCost;\\n            }\\n            res += pushCost;\\n        }\\n        // When mins != 0, then the second digit is valid\\n        if (mins != 0) {\\n            int secondDigit = mins % 10;\\n            if (startAt != secondDigit) {\\n                startAt = secondDigit;\\n                res += moveCost;\\n            }\\n            res += pushCost;\\n        }\\n        \\n        // When mins is not 0 or secs >= 10, the third digit is valid\\n        if (secs >= 10 || mins != 0) {\\n            int thirdDigit = secs / 10;\\n            if (startAt != thirdDigit) {\\n                startAt = thirdDigit;\\n                res += moveCost;\\n            }\\n            res += pushCost;\\n        }\\n        \\n        // The last digit is always valid\\n        if (startAt != (secs % 10)) res += moveCost;\\n        res += pushCost;\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int moveCost = 0, pushCost = 0;\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        this.moveCost = moveCost;\\n        this.pushCost = pushCost;\\n        int mins = targetSeconds / 60;\\n        int secs = targetSeconds % 60;\\n        // edge case: mins == 100. The only possible representation is 99:xx, xx = secs + 60\\n        if (mins == 100) {\\n            return cost(mins - 1, secs + 60, startAt);\\n        } \\n        \\n        // Multiple representations case: when mins is not 0, and secs is less than 40. \\n        // eg: 5:12 has two representations: 1. 5:12 (regular) 2. 4: 72 (mins - 1, secs + 60)        \\n        if (mins != 0 && secs < 40) {\\n            return Math.min(cost(mins, secs, startAt), cost(mins - 1, secs + 60, startAt));\\n        } \\n        // Note when mins == 0, only one representation exists (0, secs);\\n        // Or when secs >= 40, only one representation exists b/c if we add 60 to secs, the \\n        // results will exceeds 100, which is invalid.\\n        return cost(mins, secs, startAt);\\n    }\\n    \\n    private int cost(int mins, int secs, int startAt) {\\n        int res = 0;\\n        // When mins >= 10, first digit is valid\\n        if (mins >= 10) {\\n            int firstDigit = mins / 10;\\n            if (firstDigit != startAt) {\\n                startAt = firstDigit;\\n                res += moveCost;\\n            }\\n            res += pushCost;\\n        }\\n        // When mins != 0, then the second digit is valid\\n        if (mins != 0) {\\n            int secondDigit = mins % 10;\\n            if (startAt != secondDigit) {\\n                startAt = secondDigit;\\n                res += moveCost;\\n            }\\n            res += pushCost;\\n        }\\n        \\n        // When mins is not 0 or secs >= 10, the third digit is valid\\n        if (secs >= 10 || mins != 0) {\\n            int thirdDigit = secs / 10;\\n            if (startAt != thirdDigit) {\\n                startAt = thirdDigit;\\n                res += moveCost;\\n            }\\n            res += pushCost;\\n        }\\n        \\n        // The last digit is always valid\\n        if (startAt != (secs % 10)) res += moveCost;\\n        res += pushCost;\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315928,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def calculatecost(digits, start, mc,pc):\\n            a= len(digits)\\n            if(digits[0]==str(start)):\\n                cost=pc\\n            else:\\n                cost= pc+mc\\n            for i in range(1,a):\\n                if(digits[i-1]==digits[i]):\\n                    cost+=pc\\n                else:\\n                    cost += pc+mc    \\n            return cost\\n        minutes= targetSeconds//60\\n        seconds=targetSeconds%60\\n        cost=2**31-1\\n        if(minutes<=99):\\n            digits1= str(minutes*100+seconds)\\n            cost=calculatecost(digits1, startAt, moveCost,pushCost)\\n        if seconds<=39:\\n            digits2=str((minutes-1)*100+seconds+60)\\n            cost= min(cost,calculatecost(digits2, startAt, moveCost,pushCost))\\n        return cost\\n    \\n            \\n       \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def calculatecost(digits, start, mc,pc):\\n            a= len(digits)\\n            if(digits[0]==str(start)):\\n                cost=pc\\n            else:\\n                cost= pc+mc\\n            for i in range(1,a):\\n                if(digits[i-1]==digits[i]):\\n                    cost+=pc\\n                else:\\n                    cost += pc+mc    \\n            return cost\\n        minutes= targetSeconds//60\\n        seconds=targetSeconds%60\\n        cost=2**31-1\\n        if(minutes<=99):\\n            digits1= str(minutes*100+seconds)\\n            cost=calculatecost(digits1, startAt, moveCost,pushCost)\\n        if seconds<=39:\\n            digits2=str((minutes-1)*100+seconds+60)\\n            cost= min(cost,calculatecost(digits2, startAt, moveCost,pushCost))\\n        return cost\\n    \\n            \\n       \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2315562,
                "title": "java-easy-to-understand-with-explanation-o-1-time",
                "content": "Intuition - \\nWe have only two choices:\\n\\nPunch minutes and seconds as is,\\nor punch minutes - 1 and seconds + 60.\\nWe just need to check that the number of minutes and seconds is valid (positive and less than 99).\\n\\nFor example, for 6039 seconds, we can only use the second option (99:99), as the first option is invalid (100:39).\\n\\nso we create a method that takes minutes, seconds or minutes-1, seconds+60.\\nto convert minutes and seconds to microwave time - microwaveTime = (minutes * 100) + seconds\\ndigit - \\'0\\' to convert the char to integer\\nif the current digit is same as our previous finger position, we don\\'t need to move our finger again so move cost is 0. \\n\\ntime - O(1), space O(1)\\n\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int minutes = targetSeconds/60;\\n        int seconds = targetSeconds%60;\\n        \\n        return Math.min(getCost(startAt, minutes, seconds, moveCost, pushCost), getCost(startAt, minutes-1, seconds+60, moveCost, pushCost));\\n    }\\n    \\n    public int getCost(int startAt, int minutes, int seconds, int moveCost, int pushCost) {\\n        \\n        if(Math.min(minutes, seconds) < 0  || Math.max(minutes, seconds) > 99) return Integer.MAX_VALUE;\\n        \\n        int minCost = 0;\\n        \\n        int microwaveTime = (minutes * 100) + seconds;\\n        char[] digits = String.valueOf(microwaveTime).toCharArray();\\n        \\n        for(char digit : digits) {\\n        \\n    //  digit - \\'0\\' to convert the char to integer\\n            int digitInteger = digit - \\'0\\';\\n            \\n    // if the current digit is same as our previous finger position, we don\\'t need to move our finger again so move cost is 0. \\n            minCost = minCost + pushCost + (startAt == digitInteger ? 0 : moveCost);\\n            \\n            // assigning the startAt position as the previous position.\\n            startAt = digitInteger;\\n        }\\n        return minCost;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int minutes = targetSeconds/60;\\n        int seconds = targetSeconds%60;\\n        \\n        return Math.min(getCost(startAt, minutes, seconds, moveCost, pushCost), getCost(startAt, minutes-1, seconds+60, moveCost, pushCost));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1858137,
                "title": "c-0ms-faster-than-100-00-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        string min1 = to_string(targetSeconds/60);\\n        string sec1 = to_string(targetSeconds%60);\\n        if(min1==\"0\")\\n            min1 = \"\";\\n        \\n        if(min1!=\"\" && sec1.size()==1)\\n            sec1 = \\'0\\' + sec1;\\n        cout<<min1<<sec1<<endl;\\n        \\n        string min2 = \"\";\\n        string sec2 = \"\";\\n\\n        if(min1 != \"\")  {\\n            min2 = to_string(stoi(min1) - 1);\\n            sec2 = to_string(stoi(sec1) + 60);    \\n        }\\n        \\n        if(sec2 != \"\" && stoi(sec2)>99)  {\\n            min2 = \"\";\\n            sec2 = \"\";\\n        }\\n        if(min2==\"0\")\\n            min2 = \"\";\\n        \\n         if(min2!=\"\" && sec2.size()==1)\\n            sec2 = \\'0\\' + sec2;\\n        \\n                cout<<min2<<sec2<<endl;\\n\\n        \\n        int cost1 = 0;\\n        int cost2 = 0;\\n        int st = startAt;\\n        \\n        for(auto &i: min1)  {\\n            if(st != (i-\\'0\\'))\\n                cost1+=moveCost;\\n            st = i-\\'0\\';\\n            cost1 += pushCost;\\n        }\\n        for(auto &i: sec1)  {\\n            if(st != (i-\\'0\\'))\\n                cost1+=moveCost;\\n            st = i-\\'0\\';\\n            cost1 += pushCost;\\n        }\\n        \\n        st = startAt;\\n        \\n        for(auto &i: min2)  {\\n            if(st != (i-\\'0\\'))\\n                cost2+=moveCost;\\n            st = i-\\'0\\';\\n            cost2 += pushCost;\\n        }\\n        for(auto &i: sec2)  {\\n            if(st != (i-\\'0\\'))\\n                cost2+=moveCost;\\n            st = i-\\'0\\';\\n            cost2 += pushCost;\\n        }\\n        if(min1.size() + sec1.size() >4)  {\\n            min1 = \"\";\\n            sec1 = \"\";\\n        }\\n        if(min2.size() + sec2.size() >4)  {\\n            min2 = \"\";\\n            sec2 = \"\";\\n        }\\n        \\n        if(min2==\"\" && sec2==\"\")\\n            cost2 = INT_MAX;\\n        if(min1==\"\" && sec1==\"\")\\n            cost1 = INT_MAX;\\n        int cost = min(cost1, cost2);\\n        \\n        return cost;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        string min1 = to_string(targetSeconds/60);\\n        string sec1 = to_string(targetSeconds%60);\\n        if(min1==\"0\")\\n            min1 = \"\";\\n        \\n        if(min1!=\"\" && sec1.size()==1)\\n            sec1 = \\'0\\' + sec1;\\n        cout<<min1<<sec1<<endl;\\n        \\n        string min2 = \"\";\\n        string sec2 = \"\";\\n\\n        if(min1 != \"\")  {\\n            min2 = to_string(stoi(min1) - 1);\\n            sec2 = to_string(stoi(sec1) + 60);    \\n        }\\n        \\n        if(sec2 != \"\" && stoi(sec2)>99)  {\\n            min2 = \"\";\\n            sec2 = \"\";\\n        }\\n        if(min2==\"0\")\\n            min2 = \"\";\\n        \\n         if(min2!=\"\" && sec2.size()==1)\\n            sec2 = \\'0\\' + sec2;\\n        \\n                cout<<min2<<sec2<<endl;\\n\\n        \\n        int cost1 = 0;\\n        int cost2 = 0;\\n        int st = startAt;\\n        \\n        for(auto &i: min1)  {\\n            if(st != (i-\\'0\\'))\\n                cost1+=moveCost;\\n            st = i-\\'0\\';\\n            cost1 += pushCost;\\n        }\\n        for(auto &i: sec1)  {\\n            if(st != (i-\\'0\\'))\\n                cost1+=moveCost;\\n            st = i-\\'0\\';\\n            cost1 += pushCost;\\n        }\\n        \\n        st = startAt;\\n        \\n        for(auto &i: min2)  {\\n            if(st != (i-\\'0\\'))\\n                cost2+=moveCost;\\n            st = i-\\'0\\';\\n            cost2 += pushCost;\\n        }\\n        for(auto &i: sec2)  {\\n            if(st != (i-\\'0\\'))\\n                cost2+=moveCost;\\n            st = i-\\'0\\';\\n            cost2 += pushCost;\\n        }\\n        if(min1.size() + sec1.size() >4)  {\\n            min1 = \"\";\\n            sec1 = \"\";\\n        }\\n        if(min2.size() + sec2.size() >4)  {\\n            min2 = \"\";\\n            sec2 = \"\";\\n        }\\n        \\n        if(min2==\"\" && sec2==\"\")\\n            cost2 = INT_MAX;\\n        if(min1==\"\" && sec1==\"\")\\n            cost1 = INT_MAX;\\n        int cost = min(cost1, cost2);\\n        \\n        return cost;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1803377,
                "title": "java-easy-to-understand-comments-1-ms-faster-than-91-15-41-mb-less-than-60-77",
                "content": "```\\npublic int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        \\n        // note: 1 second <= targetSeconds <= 99min and 99sec\\n        \\n        if (min == 100) {   // if minutes is 100, only one way to display this\\n            return getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min - 1, sec + 60);\\n        }\\n        \\n        if (sec + 60 <= 99 && min > 0) {    //  if targetSeconds can be displayed 2 way, return the min cost between them\\n            return Math.min(getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min, sec),\\n                            getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min - 1, sec + 60));\\n        }\\n        // targetSeconds can only be displayed 1 way, return the cost of fatigue for this way\\n        return getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min, sec);        \\n    }\\n    \\n    // parses through minutes digits and seconds digits and sums the cost of fatigue for each action taken\\n    public int getMinCostSetTime(int lastPressed, int moveCost, int pushCost, int targetSeconds, int min, int sec) {\\n        int cost = 0;\\n        if (min > 0) {  // if minutes are 0, then we do not need to press any thing for those digits\\n            if (min / 10 > 0) {     // check 1st digit of minutes\\n                if (lastPressed != min / 10) {  // checking if our finger is on the last/startAt number\\n                    cost += moveCost;\\n                    lastPressed = min / 10;     // track prev pressed number\\n                }\\n                cost += pushCost;\\n            }\\n            if (lastPressed != min % 10) {  // checks 2nd digit of minutes\\n                cost += moveCost;\\n                lastPressed = min % 10;\\n            }\\n            cost += pushCost;\\n        }\\n        \\n        if (min != 0 || sec / 10 != 0) {    // if minutes = 0 and the 1st digit of seconds is 0, we can skip, otherwise:\\n            if (lastPressed != sec / 10) {\\n                cost += moveCost;\\n                lastPressed = sec / 10;\\n            }\\n            cost += pushCost;\\n        }\\n        // no checks here because we will always print this because targetSeconds >= 1\\n        if (lastPressed != sec % 10) cost += moveCost;\\n        cost += pushCost;\\n        \\n        return cost;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        \\n        // note: 1 second <= targetSeconds <= 99min and 99sec\\n        \\n        if (min == 100) {   // if minutes is 100, only one way to display this\\n            return getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min - 1, sec + 60);\\n        }\\n        \\n        if (sec + 60 <= 99 && min > 0) {    //  if targetSeconds can be displayed 2 way, return the min cost between them\\n            return Math.min(getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min, sec),\\n                            getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min - 1, sec + 60));\\n        }\\n        // targetSeconds can only be displayed 1 way, return the cost of fatigue for this way\\n        return getMinCostSetTime(startAt, moveCost, pushCost, targetSeconds, min, sec);        \\n    }\\n    \\n    // parses through minutes digits and seconds digits and sums the cost of fatigue for each action taken\\n    public int getMinCostSetTime(int lastPressed, int moveCost, int pushCost, int targetSeconds, int min, int sec) {\\n        int cost = 0;\\n        if (min > 0) {  // if minutes are 0, then we do not need to press any thing for those digits\\n            if (min / 10 > 0) {     // check 1st digit of minutes\\n                if (lastPressed != min / 10) {  // checking if our finger is on the last/startAt number\\n                    cost += moveCost;\\n                    lastPressed = min / 10;     // track prev pressed number\\n                }\\n                cost += pushCost;\\n            }\\n            if (lastPressed != min % 10) {  // checks 2nd digit of minutes\\n                cost += moveCost;\\n                lastPressed = min % 10;\\n            }\\n            cost += pushCost;\\n        }\\n        \\n        if (min != 0 || sec / 10 != 0) {    // if minutes = 0 and the 1st digit of seconds is 0, we can skip, otherwise:\\n            if (lastPressed != sec / 10) {\\n                cost += moveCost;\\n                lastPressed = sec / 10;\\n            }\\n            cost += pushCost;\\n        }\\n        // no checks here because we will always print this because targetSeconds >= 1\\n        if (lastPressed != sec % 10) cost += moveCost;\\n        cost += pushCost;\\n        \\n        return cost;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1782107,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getSeconds(int time) {\\n        int a = time % 10;\\n        time /= 10;\\n        int b = time % 10;\\n        time /= 10;\\n        int c = time % 10;\\n        time /= 10;\\n        int d = time % 10;\\n        time /= 10;\\n        int seconds = b * 10 + a;\\n        int minutes = d * 10 + c;\\n        return minutes * 60 + seconds;\\n    }\\n    int ans = 1e9 + 7;\\n    void dfs(int current, int time, int moveCost, int pushCost, int targetSeconds, int pos, int cost) {\\n        if(pos == 4) {\\n            if(targetSeconds == getSeconds(time)) {\\n                ans = min(ans, cost);\\n            }\\n            return;\\n        }\\n        if(targetSeconds == getSeconds(time)) {\\n            ans = min(ans, cost);\\n        }\\n        for(int i = 0; i < 10; i++) {\\n            if(current == i) {\\n                dfs(current, time * 10 + i, moveCost, pushCost, targetSeconds, pos + 1, cost + pushCost);\\n            }\\n            else {\\n                dfs(i, time * 10 + i, moveCost, pushCost, targetSeconds, pos + 1, cost + moveCost + pushCost);\\n            }\\n        }\\n        \\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        dfs(startAt, 0, moveCost, pushCost, targetSeconds, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSeconds(int time) {\\n        int a = time % 10;\\n        time /= 10;\\n        int b = time % 10;\\n        time /= 10;\\n        int c = time % 10;\\n        time /= 10;\\n        int d = time % 10;\\n        time /= 10;\\n        int seconds = b * 10 + a;\\n        int minutes = d * 10 + c;\\n        return minutes * 60 + seconds;\\n    }\\n    int ans = 1e9 + 7;\\n    void dfs(int current, int time, int moveCost, int pushCost, int targetSeconds, int pos, int cost) {\\n        if(pos == 4) {\\n            if(targetSeconds == getSeconds(time)) {\\n                ans = min(ans, cost);\\n            }\\n            return;\\n        }\\n        if(targetSeconds == getSeconds(time)) {\\n            ans = min(ans, cost);\\n        }\\n        for(int i = 0; i < 10; i++) {\\n            if(current == i) {\\n                dfs(current, time * 10 + i, moveCost, pushCost, targetSeconds, pos + 1, cost + pushCost);\\n            }\\n            else {\\n                dfs(i, time * 10 + i, moveCost, pushCost, targetSeconds, pos + 1, cost + moveCost + pushCost);\\n            }\\n        }\\n        \\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        dfs(startAt, 0, moveCost, pushCost, targetSeconds, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756060,
                "title": "java-easy-solution-o-1-tc",
                "content": "```\\nclass Solution {\\n    void helper(int data[],int min,int sec){\\n        data[1]=min%10;\\n        data[0]=(min/10)%10;\\n        data[3]=sec%10;\\n        data[2]=(sec/10)%10;\\n    }\\n   \\n    int getCost(int current,int mcost,int pcost,int data[]){\\n        int p=0,cost=0;\\n        while(p<4&&data[p]==0)p++;\\n        while(p<4){\\n        if(data[p]==current){\\n            cost+=pcost;\\n        }\\n        else{\\n            cost+=(pcost+mcost);\\n            current=data[p];\\n        }\\n            p++;\\n            \\n    }\\n        return cost;\\n    }\\n \\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int seconds) {\\n        int min=seconds/60;\\n        int sec=seconds%60;\\n        int res=Integer.MAX_VALUE;\\n        int data[]=new int[4];\\n        if(min>=1&&sec<=39){\\n            \\nhelper(data,min-1,sec+60);\\n            res=getCost(startAt,moveCost,pushCost,data);\\n        }\\n        helper(data,min,sec);\\n        if(min<=99)\\n        res=Math.min(res,getCost(startAt,moveCost,pushCost,data));\\n        return res;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(int data[],int min,int sec){\\n        data[1]=min%10;\\n        data[0]=(min/10)%10;\\n        data[3]=sec%10;\\n        data[2]=(sec/10)%10;\\n    }\\n   \\n    int getCost(int current,int mcost,int pcost,int data[]){\\n        int p=0,cost=0;\\n        while(p<4&&data[p]==0)p++;\\n        while(p<4){\\n        if(data[p]==current){\\n            cost+=pcost;\\n        }\\n        else{\\n            cost+=(pcost+mcost);\\n            current=data[p];\\n        }\\n            p++;\\n            \\n    }\\n        return cost;\\n    }\\n \\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int seconds) {\\n        int min=seconds/60;\\n        int sec=seconds%60;\\n        int res=Integer.MAX_VALUE;\\n        int data[]=new int[4];\\n        if(min>=1&&sec<=39){\\n            \\nhelper(data,min-1,sec+60);\\n            res=getCost(startAt,moveCost,pushCost,data);\\n        }\\n        helper(data,min,sec);\\n        if(min<=99)\\n        res=Math.min(res,getCost(startAt,moveCost,pushCost,data));\\n        return res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751559,
                "title": "java-simple-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) {\\n        int min = ts / 60; \\n        int sec = ts % 60;\\n        \\n        if(min > 99){\\n            min--;\\n            sec += 60;\\n        }\\n\\t\\t\\n        int ans = Integer.MAX_VALUE;\\n        while(min >=0 && sec <= 99){\\n            ans = Math.min(ans, cost(startAt, moveCost, pushCost, (min * 100) + sec));\\n            min--;\\n            sec+=60;\\n        }\\n        return ans;\\n    }\\n    \\n    int cost(int start, int move, int push, int time){\\n        List<Integer> list = new ArrayList<>();\\n        while(time != 0){\\n            list.add(time%10);\\n            time = time/10;\\n        }\\n        int res = 0;\\n        for(int i = list.size()-1; i>=0; i--){\\n            if(list.get(i) == start){\\n                res += push;\\n                continue;\\n            }\\n            \\n            res += move + push;\\n            start = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) {\\n        int min = ts / 60; \\n        int sec = ts % 60;\\n        \\n        if(min > 99){\\n            min--;\\n            sec += 60;\\n        }\\n\\t\\t\\n        int ans = Integer.MAX_VALUE;\\n        while(min >=0 && sec <= 99){\\n            ans = Math.min(ans, cost(startAt, moveCost, pushCost, (min * 100) + sec));\\n            min--;\\n            sec+=60;\\n        }\\n        return ans;\\n    }\\n    \\n    int cost(int start, int move, int push, int time){\\n        List<Integer> list = new ArrayList<>();\\n        while(time != 0){\\n            list.add(time%10);\\n            time = time/10;\\n        }\\n        int res = 0;\\n        for(int i = list.size()-1; i>=0; i--){\\n            if(list.get(i) == start){\\n                res += push;\\n                continue;\\n            }\\n            \\n            res += move + push;\\n            start = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750892,
                "title": "c-solution-bruteforce-easy-to-read",
                "content": "There are 2 choices either take the exact time that is 669 seconds can be written as 11 minutes and 09 seconds or we can write it as 10 minutes and 69 seconds. \\nAnd there would be some edge cases that such as:\\n If minutes are greater than 99 then we cannot take 100 minutes and 39 seconds we need to take 99 minutes and 99 seconds.....\\n\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans=INT_MAX;       \\n        \\n        string x = to_string(targetSeconds/60),y = to_string(targetSeconds%60);\\n        int tmp=0,tmp1=startAt;\\n        if(x.length() == 1 && x[0] != \\'0\\')\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(x.length() == 2)\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (x[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        \\n        if(y.length() == 1)\\n        {\\n            if(x[0] != \\'0\\')\\n            {\\n                if(tmp1 != 0)\\n                    tmp += moveCost,tmp1 = 0;\\n                tmp += pushCost;\\n            }\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(y.length() == 2)\\n        {\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (y[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        if(x.length() < 3)\\n            ans = min(ans,tmp);\\n        \\n        tmp=0;\\n        if(((targetSeconds%60) + 60) > 99 || targetSeconds/60 == 0)\\n            return ans;\\n\\n        x = to_string(max(0,(targetSeconds/60) - 1)),y = to_string((targetSeconds%60) + 60);\\n        tmp1=startAt;\\n\\n        if(x.length() == 1 && x[0] != \\'0\\')\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(x.length() == 2)\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (x[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        if(y.length() == 1)\\n        {\\n            if(x[0] != \\'0\\')\\n            {\\n                if(tmp1 != 0)\\n                    tmp += moveCost,tmp1 = 0;\\n                tmp += pushCost;\\n            }\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(y.length() == 2)\\n        {\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (y[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        ans = min(ans,tmp);\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans=INT_MAX;       \\n        \\n        string x = to_string(targetSeconds/60),y = to_string(targetSeconds%60);\\n        int tmp=0,tmp1=startAt;\\n        if(x.length() == 1 && x[0] != \\'0\\')\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(x.length() == 2)\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (x[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        \\n        if(y.length() == 1)\\n        {\\n            if(x[0] != \\'0\\')\\n            {\\n                if(tmp1 != 0)\\n                    tmp += moveCost,tmp1 = 0;\\n                tmp += pushCost;\\n            }\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(y.length() == 2)\\n        {\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (y[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        if(x.length() < 3)\\n            ans = min(ans,tmp);\\n        \\n        tmp=0;\\n        if(((targetSeconds%60) + 60) > 99 || targetSeconds/60 == 0)\\n            return ans;\\n\\n        x = to_string(max(0,(targetSeconds/60) - 1)),y = to_string((targetSeconds%60) + 60);\\n        tmp1=startAt;\\n\\n        if(x.length() == 1 && x[0] != \\'0\\')\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(x.length() == 2)\\n        {\\n            if(tmp1 != (x[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (x[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = x[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        if(y.length() == 1)\\n        {\\n            if(x[0] != \\'0\\')\\n            {\\n                if(tmp1 != 0)\\n                    tmp += moveCost,tmp1 = 0;\\n                tmp += pushCost;\\n            }\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n        }\\n        else if(y.length() == 2)\\n        {\\n            if(tmp1 != (y[0]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[0]-\\'0\\';\\n            tmp += pushCost;\\n            \\n            if(tmp1 != (y[1]-\\'0\\'))\\n                tmp += moveCost,tmp1 = y[1]-\\'0\\';\\n            tmp += pushCost;   \\n        }\\n        ans = min(ans,tmp);\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749503,
                "title": "c-easy-readable-short-code",
                "content": "### 2 possible time settings, compare cost of both\\n1. Minutes = time/60 , seconds = time%60\\n2. Minutes = time/60 - 1 , seconds = time%60 + 60\\n\\nNote :  Also check if minutes and seconds are in the display range i.e. [1,99]\\n\\n```\\nclass Solution {\\n    int s,m,p,t;\\n    \\n    int computeCost(int &Min,int &sec){\\n        string a1 = (Min>0) ? to_string(Min) : \"\";\\n        if(sec <= 9 && Min != 0) a1 += \"0\" + to_string(sec);\\n        else a1 += to_string(sec);\\n        \\n        int cost = ((a1[0]-\\'0\\') != s) ? m : 0;\\n        int i = 0;\\n        while(i < a1.size()){\\n            cost += p;\\n            if(i>0 && a1[i-1] != a1[i]) cost += m;\\n            i++;\\n        }\\n        return cost;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int start, int move, int push, int time) {\\n        s = start , m = move, p = push , t = time;\\n        int M = t/60 , S = t%60 , cost = INT_MAX;\\n        for(int i = -1 ; i<=0 ; i++){\\n            int Min = M+i , sec = S -60*i;\\n            if(Min<0 || Min>99 || sec>99 || sec<0) continue;\\n            cost = min(cost , computeCost(Min,sec));\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int s,m,p,t;\\n    \\n    int computeCost(int &Min,int &sec){\\n        string a1 = (Min>0) ? to_string(Min) : \"\";\\n        if(sec <= 9 && Min != 0) a1 += \"0\" + to_string(sec);\\n        else a1 += to_string(sec);\\n        \\n        int cost = ((a1[0]-\\'0\\') != s) ? m : 0;\\n        int i = 0;\\n        while(i < a1.size()){\\n            cost += p;\\n            if(i>0 && a1[i-1] != a1[i]) cost += m;\\n            i++;\\n        }\\n        return cost;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int start, int move, int push, int time) {\\n        s = start , m = move, p = push , t = time;\\n        int M = t/60 , S = t%60 , cost = INT_MAX;\\n        for(int i = -1 ; i<=0 ; i++){\\n            int Min = M+i , sec = S -60*i;\\n            if(Min<0 || Min>99 || sec>99 || sec<0) continue;\\n            cost = min(cost , computeCost(Min,sec));\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747876,
                "title": "java-easy-to-understand-with-explanation-100",
                "content": "First Find minutes and seconds from targetSeconds\\nlike -> minutes = targetSeconds / 60  and seconds = targetSeconds % 60\\n\\n\\nConsider the condition that minutes can\\'t exceed 99 and similar with seconds\\nif minutes > 99 then subtract -1 and add 60 to seconds. \\nCreate time number by using the minutes and seconds for better understating check this:\\n\\n\\n![image](https://assets.leetcode.com/users/images/083f41e3-e817-4bc6-95b8-81e7630aaad3_1644090307.6726065.jpeg)\\n\\nAfter creating the number find its cost by comparing each value with startAt(s)\\n* Check Leading Zeros\\n* If array value is equal to startAt(s) then add pushCost(p) to the ans \\n* Else add moveCost and pushCost to the ans and **don\\'t forget to change the startAt(s)**\\n\\nNow reduce the minutes by 1 and add increment seconds by 60 and do the same proces \\n* only If minutes >= 0 and seconds <= 99\\n\\nafter that compare values and return minimum value.\\n\\n![image](https://assets.leetcode.com/users/images/36e983c3-ce67-40ec-bbf2-83aa49bad25e_1644090753.7913172.jpeg)\\n\\n\\n\\n**Check My Code Below**\\n```\\nclass Solution {\\n    public int minCostSetTime(int s, int m, int p, int target){\\n        int ans = Integer.MAX_VALUE;\\n        int min = target/60;\\n        int sec = target%60;\\n        if(min > 99){\\n            min -= 1;\\n            sec += 60;\\n        }\\n        while(min >= 0 && sec <= 99){\\n            int res = 0;\\n            int check = s;\\n            int[] arr = new int[4];\\n            arr[0] = min/10;\\n            arr[1] = min%10;\\n            arr[2] = sec/10;\\n            arr[3] = sec%10;\\n            boolean isZero = false;\\n            for(int i=0; i<4; i++){\\n                if(arr[i] == 0 && !isZero){\\n                    continue;\\n                }\\n                isZero = true;\\n                if(arr[i] == check){\\n                    res += p;\\n                }\\n                else{\\n                    res += m + p;\\n                    check = arr[i];\\n                }\\n            }\\n            min -= 1;\\n            sec += 60;\\n            ans = Math.min(res, ans);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\nHope It helps. If you like this Explaination please UpVote ! Happy Coding",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int s, int m, int p, int target){\\n        int ans = Integer.MAX_VALUE;\\n        int min = target/60;\\n        int sec = target%60;\\n        if(min > 99){\\n            min -= 1;\\n            sec += 60;\\n        }\\n        while(min >= 0 && sec <= 99){\\n            int res = 0;\\n            int check = s;\\n            int[] arr = new int[4];\\n            arr[0] = min/10;\\n            arr[1] = min%10;\\n            arr[2] = sec/10;\\n            arr[3] = sec%10;\\n            boolean isZero = false;\\n            for(int i=0; i<4; i++){\\n                if(arr[i] == 0 && !isZero){\\n                    continue;\\n                }\\n                isZero = true;\\n                if(arr[i] == check){\\n                    res += p;\\n                }\\n                else{\\n                    res += m + p;\\n                    check = arr[i];\\n                }\\n            }\\n            min -= 1;\\n            sec += 60;\\n            ans = Math.min(res, ans);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747835,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int sa, int mc, int pc, int ts) {\\n        int mnMin=ts/60,mnSec=ts%60;\\n        int mnMin1=ts/60,mnSec1=ts%60;\\n        if(mnSec1<40 && mnMin1!=0){\\n            mnSec1=mnSec+60;\\n            mnMin1--;\\n        }\\n        string s1=\"\",s2=\"\";\\n        s1=to_string(mnMin*100+mnSec);\\n        s2=to_string(mnMin1*100+mnSec1);\\n        int a1=0,a2=0,t=sa,c0=0;\\n        for(auto &x:s1){\\n            if(sa==x-\\'0\\'){\\n                a1+=pc;\\n            }\\n            else{\\n                a1+=pc+mc;\\n                sa=x-\\'0\\';\\n            }\\n        }\\n        sa=t;t=sa;\\n        c0=0;\\n        for(auto &x:s2){       \\n            if(sa==(x-\\'0\\')){\\n                a2+=pc;\\n            }\\n            else{\\n                a2+=pc+mc;\\n                sa=x-\\'0\\';\\n            }\\n        }\\n        if(mnMin==100)\\n            return a2;\\n        return min(a1,a2);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minCostSetTime(int sa, int mc, int pc, int ts) {\\n        int mnMin=ts/60,mnSec=ts%60;\\n        int mnMin1=ts/60,mnSec1=ts%60;\\n        if(mnSec1<40 && mnMin1!=0){\\n            mnSec1=mnSec+60;\\n            mnMin1--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1747804,
                "title": "c-explanation-100-0ms",
                "content": "\\n Approach:\\n Handle two cases separately :\\n case:1 --> targetSeconds<100\\n case:2 --> targetSeconds>=100\\n\\n  find all possible time expressions\\n  then check move and push conditions for each expressions\\n  and output minimum of them.\\n\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int start, int mC, int pC, int tS) {\\n        \\n         int ans=INT_MAX;\\n        if(tS<100)\\n        {\\n            vector<string> vt;  // all possible time expressions\\n            \\n            string s= to_string(tS);\\n            while(s.size()<=4)\\n            {\\n                vt.push_back(s);\\n                s= \"0\"+s;\\n            }\\n            \\n            int x= tS/60;\\n            int rem= tS%60;\\n            if(x!=0)\\n            {\\n                string p1= to_string(x);\\n                string p2= to_string(rem);\\n                while(p2.size()!=2)\\n                {\\n                    p2= \"0\"+p2;\\n                }\\n                vt.push_back(p1+p2);\\n                if(p1.size()==1) vt.push_back(\"0\"+p1+p2);\\n            }\\n            \\n            int tmp=0;\\n            for(int i=0; i<vt.size(); i++)\\n            {\\n                tmp= start;\\n                int cost=0;\\n                for(auto ch: vt[i])\\n                {\\n                    if(tmp!=(ch-\\'0\\') )  // we have to move + push\\n                    {\\n                        cost+=(mC+pC);\\n                        tmp= (ch-\\'0\\');\\n                    }\\n                    else cost+= pC;     // we have to only push\\n                }\\n                ans= min(ans,cost);\\n            }\\n            \\n        }\\n        else  \\n        {\\n            vector<string> vt;  // all possible time expressions\\n            \\n            int x= tS/60;\\n            int rem= tS%60;\\n            if(x==100)      // IMP case take tS=6039---> x=100, rem=39\\n            {\\n                x--;\\n                rem+=60;\\n            }\\n            \\n                string p1= to_string(x);\\n                string p2= to_string(rem);\\n                while(p2.size()!=2)\\n                {\\n                    p2= \"0\"+p2;\\n                }\\n                vt.push_back(p1+p2);\\n                if(p1.size()==1) vt.push_back(\"0\"+p1+p2);\\n                \\n                if(rem+60 <=99)  //  IMP step \\n                {\\n                    x--;\\n                    rem+= 60;\\n                    if(x==0)\\n                    {\\n                         string tt= to_string(rem);\\n                         while(tt.size()<=4)\\n                         {\\n                           vt.push_back(tt);\\n                           tt= \"0\"+ tt;\\n                         }\\n                    }\\n                    else\\n                    {\\n                          string g1= to_string(x);\\n                          string g2= to_string(rem);\\n                         \\n                          vt.push_back(g1+g2);\\n                          if(g1.size()==1) vt.push_back(\"0\"+g1+g2);\\n                    }\\n                }\\n            \\n               \\n            int tmp=0;\\n            for(int i=0; i<vt.size(); i++)\\n            {\\n                tmp= start;\\n                int cost=0;\\n                for(auto ch: vt[i])\\n                {\\n                    if(tmp!=(ch-\\'0\\') )\\n                    {\\n                        cost+=(mC+pC);\\n                        tmp= (ch-\\'0\\');\\n                    }\\n                    else cost+= pC;\\n                }\\n                ans= min(ans,cost);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int start, int mC, int pC, int tS) {\\n        \\n         int ans=INT_MAX;\\n        if(tS<100)\\n        {\\n            vector<string> vt;  // all possible time expressions\\n            \\n            string s= to_string(tS);\\n            while(s.size()<=4)\\n            {\\n                vt.push_back(s);\\n                s= \"0\"+s;\\n            }\\n            \\n            int x= tS/60;\\n            int rem= tS%60;\\n            if(x!=0)\\n            {\\n                string p1= to_string(x);\\n                string p2= to_string(rem);\\n                while(p2.size()!=2)\\n                {\\n                    p2= \"0\"+p2;\\n                }\\n                vt.push_back(p1+p2);\\n                if(p1.size()==1) vt.push_back(\"0\"+p1+p2);\\n            }\\n            \\n            int tmp=0;\\n            for(int i=0; i<vt.size(); i++)\\n            {\\n                tmp= start;\\n                int cost=0;\\n                for(auto ch: vt[i])\\n                {\\n                    if(tmp!=(ch-\\'0\\') )  // we have to move + push\\n                    {\\n                        cost+=(mC+pC);\\n                        tmp= (ch-\\'0\\');\\n                    }\\n                    else cost+= pC;     // we have to only push\\n                }\\n                ans= min(ans,cost);\\n            }\\n            \\n        }\\n        else  \\n        {\\n            vector<string> vt;  // all possible time expressions\\n            \\n            int x= tS/60;\\n            int rem= tS%60;\\n            if(x==100)      // IMP case take tS=6039---> x=100, rem=39\\n            {\\n                x--;\\n                rem+=60;\\n            }\\n            \\n                string p1= to_string(x);\\n                string p2= to_string(rem);\\n                while(p2.size()!=2)\\n                {\\n                    p2= \"0\"+p2;\\n                }\\n                vt.push_back(p1+p2);\\n                if(p1.size()==1) vt.push_back(\"0\"+p1+p2);\\n                \\n                if(rem+60 <=99)  //  IMP step \\n                {\\n                    x--;\\n                    rem+= 60;\\n                    if(x==0)\\n                    {\\n                         string tt= to_string(rem);\\n                         while(tt.size()<=4)\\n                         {\\n                           vt.push_back(tt);\\n                           tt= \"0\"+ tt;\\n                         }\\n                    }\\n                    else\\n                    {\\n                          string g1= to_string(x);\\n                          string g2= to_string(rem);\\n                         \\n                          vt.push_back(g1+g2);\\n                          if(g1.size()==1) vt.push_back(\"0\"+g1+g2);\\n                    }\\n                }\\n            \\n               \\n            int tmp=0;\\n            for(int i=0; i<vt.size(); i++)\\n            {\\n                tmp= start;\\n                int cost=0;\\n                for(auto ch: vt[i])\\n                {\\n                    if(tmp!=(ch-\\'0\\') )\\n                    {\\n                        cost+=(mC+pC);\\n                        tmp= (ch-\\'0\\');\\n                    }\\n                    else cost+= pC;\\n                }\\n                ans= min(ans,cost);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747791,
                "title": "o-1-sc-tc-simple-easy-c-solution",
                "content": "\\nFor any given targetSeconds given we will have ony two possible times \\n\\n\\t1)  targetSecoond/60    :    targetSecoond%60\\n\\t2)  targetSecoond/60 - 1   :    targetSecoond%60   + 60\\nSo we just need to calculate these two time and check whether they are valid or not i.e lies between 00:00 and 99:99.\\n\\nAfter that we can cacluate the cost for all the valid times (atmost two) by ignoring all the leading zeroes.\\n\\n\\tTime Complexity  : O(1)\\n\\tSpace Complecity : O(1)\\n\\n\\n```\\nvoid numtovec(int n, vector<int> &v)\\n{\\n   v.push_back(n / 10);\\n   v.push_back(n % 10);\\n}\\n\\nint ans(int x, vector<int> &time, int moveCost, int pushCost)\\n{\\n   int cst = 0, j, i;\\n   for (j = 0; j < time.size(); j++)\\n      if (time[j] != 0)\\n         break;\\n   for (i = j; i < time.size(); i++)\\n   {\\n      if (time[i] != x)\\n         cst += moveCost;\\n      cst += pushCost;\\n      x = time[i];\\n   }\\n   return cst;\\n}\\nclass Solution {\\npublic:\\n   int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n      vector<int> time1, time2;\\n\\n      // Time 1\\n      int minute1 = targetSeconds / 60, second1 = targetSeconds % 60;\\n      numtovec(minute1, time1);\\n      numtovec(second1, time1);\\n      int cost1 = ans(startAt, time1, moveCost, pushCost);\\n\\n      //Time 2\\n      int minute2 = minute1 - 1, second2 = second1 + 60;\\n      numtovec(minute2, time2);\\n      numtovec(second2, time2);\\n      int cost2 = ans(startAt, time2, moveCost, pushCost);\\n\\n\\n      if (minute1 < 0 || minute1 > 99 || second1 < 0 || second1 > 99)\\n         cost1 = INT_MAX;\\n      if (minute2 < 0 || minute2 > 99 || second2 < 0 || second2 > 99)\\n         cost2 = INT_MAX;\\n      return min(cost1, cost2);\\n   }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid numtovec(int n, vector<int> &v)\\n{\\n   v.push_back(n / 10);\\n   v.push_back(n % 10);\\n}\\n\\nint ans(int x, vector<int> &time, int moveCost, int pushCost)\\n{\\n   int cst = 0, j, i;\\n   for (j = 0; j < time.size(); j++)\\n      if (time[j] != 0)\\n         break;\\n   for (i = j; i < time.size(); i++)\\n   {\\n      if (time[i] != x)\\n         cst += moveCost;\\n      cst += pushCost;\\n      x = time[i];\\n   }\\n   return cst;\\n}\\nclass Solution {\\npublic:\\n   int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n      vector<int> time1, time2;\\n\\n      // Time 1\\n      int minute1 = targetSeconds / 60, second1 = targetSeconds % 60;\\n      numtovec(minute1, time1);\\n      numtovec(second1, time1);\\n      int cost1 = ans(startAt, time1, moveCost, pushCost);\\n\\n      //Time 2\\n      int minute2 = minute1 - 1, second2 = second1 + 60;\\n      numtovec(minute2, time2);\\n      numtovec(second2, time2);\\n      int cost2 = ans(startAt, time2, moveCost, pushCost);\\n\\n\\n      if (minute1 < 0 || minute1 > 99 || second1 < 0 || second1 > 99)\\n         cost1 = INT_MAX;\\n      if (minute2 < 0 || minute2 > 99 || second2 < 0 || second2 > 99)\\n         cost2 = INT_MAX;\\n      return min(cost1, cost2);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747764,
                "title": "c-solution-beginner-friendly-explanation-with-code-o-1-solution",
                "content": "\\nThe approach for this question is to generate all representations for the time and find the minimum cost.\\n\\n*Firstly, we convert the time as follows*:\\n```\\nseconds = targetSeconds%60;\\nminutes = targetSeconds/60;\\n```\\n\\n*This method always gives us seconds < 60.*\\n\\n***Edge Case:***\\n\\n* ***When we have minutes = 100, i.e, targetSeconds >= 6000.***\\nSince, we can only represent 99 as max value for minutes, Here, we are forced to use 100 as 99 and add 60 seconds to seconds part ( This is the reason why targetSeconds <= 6039 is a constraint as max time is 9999 ).\\n\\nWe can observe that since 1 minute can be subtracted and 60 seconds can be added to seconds part gives us at most two representations of targetSeconds possible.\\n\\n**The situation where two types of representations are possible:**\\n\\nHere, second representation is possible when we reduce minutes by 1 and add the same 60 seconds to the seconds part. Hence, \\n\\n*CONDITION:*                         \\n```\\nminutes >=1  AND seconds <= 39  AND  minutes<100\\n``` \\n\\nHere, **minutes>=1** as minutes-1 cannot be negative and adding 60 seconds to seconds part should be <=99. Hence, **seconds <= 39** as seconds + 60 <= 99. **minutes=100** are the edge cases handled seperately.\\n\\n**NOTE:** \\n\\n*In this question we should **only consider combinations with no leading zeroes as input in the string** such as \"960\" will only be considered and \"0960\" will not be considered. The latter will require pushing an extra button which increses the cost, so it will give higher cost.*\\n\\n### CODE:\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int secs = targetSeconds%60;\\n        int mins = targetSeconds/60;\\n        \\n        string type1=\"\", type2=\"\";\\n        \\n        // If mins is 0 then we won\\'t take any string from mins \\n        // as it only increases push cost\\n        if(mins==0) type1 = to_string(secs);\\n\\n        // If mins < 100  we convert into normal time format\\n        else if(mins<100){\\n            type1 = to_string(mins);\\n            if(secs<=9) type1 += \"0\";\\n            type1 += to_string(secs);\\n        }\\n\\n        // If min=100 we have to represent it as 99:xy format\\n        else{\\n            type1 = \"99\";\\n            type1 += to_string(secs + 60);\\n        }\\n             \\n        // Condition where two types can be present   \\n        if(mins>=1 && mins<100 && secs<=39){\\n            if(mins-1==0) type2 = to_string(secs+60); //limiting leading zeroes\\n            else{\\n                type2 = to_string(mins-1);\\n                type2 += to_string(secs+60);\\n            }\\n        }\\n        \\n        \\n        int i = 1;\\n        vector<string>arr;\\n        arr.push_back(type1);   \\n        // If type2 is there push in array \\n        if(type2.size() > 0){ \\n            arr.push_back(type2);\\n            i++;\\n        }\\n\\n        int mini = INT_MAX;\\n        int totalCost = 0;\\n        \\n        while(i--){\\n            \\n            int n = arr[i][0]-\\'0\\';\\n            totalCost = pushCost;\\n            if(startAt != n) totalCost += moveCost;\\n            \\n            int j = 1;\\n            \\n            while(j < arr[i].size() ){\\n                if(arr[i][j] != arr[i][j-1]) totalCost += moveCost;\\n                totalCost += pushCost;\\n                j++;\\n            }\\n            \\n            mini = min(totalCost, mini);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```\\n\\n*Hope you liked the explanation!!*\\n\\n**Thanks for reading!!**\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nseconds = targetSeconds%60;\\nminutes = targetSeconds/60;\\n```\n```\\nminutes >=1  AND seconds <= 39  AND  minutes<100\\n```\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int secs = targetSeconds%60;\\n        int mins = targetSeconds/60;\\n        \\n        string type1=\"\", type2=\"\";\\n        \\n        // If mins is 0 then we won\\'t take any string from mins \\n        // as it only increases push cost\\n        if(mins==0) type1 = to_string(secs);\\n\\n        // If mins < 100  we convert into normal time format\\n        else if(mins<100){\\n            type1 = to_string(mins);\\n            if(secs<=9) type1 += \"0\";\\n            type1 += to_string(secs);\\n        }\\n\\n        // If min=100 we have to represent it as 99:xy format\\n        else{\\n            type1 = \"99\";\\n            type1 += to_string(secs + 60);\\n        }\\n             \\n        // Condition where two types can be present   \\n        if(mins>=1 && mins<100 && secs<=39){\\n            if(mins-1==0) type2 = to_string(secs+60); //limiting leading zeroes\\n            else{\\n                type2 = to_string(mins-1);\\n                type2 += to_string(secs+60);\\n            }\\n        }\\n        \\n        \\n        int i = 1;\\n        vector<string>arr;\\n        arr.push_back(type1);   \\n        // If type2 is there push in array \\n        if(type2.size() > 0){ \\n            arr.push_back(type2);\\n            i++;\\n        }\\n\\n        int mini = INT_MAX;\\n        int totalCost = 0;\\n        \\n        while(i--){\\n            \\n            int n = arr[i][0]-\\'0\\';\\n            totalCost = pushCost;\\n            if(startAt != n) totalCost += moveCost;\\n            \\n            int j = 1;\\n            \\n            while(j < arr[i].size() ){\\n                if(arr[i][j] != arr[i][j-1]) totalCost += moveCost;\\n                totalCost += pushCost;\\n                j++;\\n            }\\n            \\n            mini = min(totalCost, mini);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747725,
                "title": "easy-java-solution-1ms-solution",
                "content": "1. There are atmost two possible combinations for any targetSeconds\\n\\teg. targetSeconds = 745\\n\\tminutes = 745/60 = 12;\\n\\tseconds = 745%12 = 25;\\n\\t=> first combination 12:25\\n\\t\\n\\tNow since after adding 60 to seconds, it wont exceed 99, we can have\\n\\tcombination of (minutes-1, seconds+60)\\n\\t=> second combination 11:85\\n\\t\\n\\tcost = min(costOfFirstCombination, costOfSecondCombination);\\n\\t\\n\\tInside findCost function, we first store the minutes and seconds in an array\\n\\ttime[] = {1,2,2,5}\\n\\t-If we initially have any zeroes, we leave them as it is\\n\\t-If start is same as current digit, we don\\'t need to move, we just need to push that button\\n\\t-if start is not same as current digit, then we need to do both, move and push , so we add both of its cost\\n\\t-and we set the startAt as the current digit, so if the next digit is same as the current digit, we don\\'t move anywhere.\\n\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60;\\n        int seconds = targetSeconds%60;\\n        int cost = Integer.MAX_VALUE;\\n\\n        cost = Math.min(\\n                findCost(minutes, seconds, startAt, moveCost, pushCost),\\n                findCost(minutes-1, seconds+60, startAt, moveCost, pushCost)); \\n\\t\\t\\t\\n        return cost;\\n    }\\n    \\n    int findCost(int minutes, int seconds, int startAt, int moveCost, int pushCost){\\n        if(minutes>99 || seconds>99) return Integer.MAX_VALUE;\\n        int[] time = new int[4];\\n        time[1] = minutes%10;\\n        time[0] = minutes/10;\\n        \\n        time[3] = seconds%10;\\n        time[2] = seconds/10;\\n        \\n        boolean flag = false; \\n        //flag for checking if first digit occured\\n\\t\\t//so that we skip only the trailing zeroes, not the inclusive zeroes\\n        //00:76, if this is the case, we need to ignore first two zeroes\\n        //12:00, we can\\'t ignore any zeroes here\\n        //09:60, we just ignore first zero\\n        int cost = 0;\\n        \\n        for(int i=0; i<4; i++){\\n            if(time[i]==0 && !flag){\\n                continue;\\n            }\\n            else if(time[i]==startAt){\\n                flag = true;\\n                cost += pushCost;\\n            }\\n            else{\\n                flag = true;\\n                cost += pushCost + moveCost;\\n                startAt = time[i];\\n            }\\n        }\\n        \\n        return cost;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60;\\n        int seconds = targetSeconds%60;\\n        int cost = Integer.MAX_VALUE;\\n\\n        cost = Math.min(\\n                findCost(minutes, seconds, startAt, moveCost, pushCost),\\n                findCost(minutes-1, seconds+60, startAt, moveCost, pushCost)); \\n\\t\\t\\t\\n        return cost;\\n    }\\n    \\n    int findCost(int minutes, int seconds, int startAt, int moveCost, int pushCost){\\n        if(minutes>99 || seconds>99) return Integer.MAX_VALUE;\\n        int[] time = new int[4];\\n        time[1] = minutes%10;\\n        time[0] = minutes/10;\\n        \\n        time[3] = seconds%10;\\n        time[2] = seconds/10;\\n        \\n        boolean flag = false; \\n        //flag for checking if first digit occured\\n\\t\\t//so that we skip only the trailing zeroes, not the inclusive zeroes\\n        //00:76, if this is the case, we need to ignore first two zeroes\\n        //12:00, we can\\'t ignore any zeroes here\\n        //09:60, we just ignore first zero\\n        int cost = 0;\\n        \\n        for(int i=0; i<4; i++){\\n            if(time[i]==0 && !flag){\\n                continue;\\n            }\\n            else if(time[i]==startAt){\\n                flag = true;\\n                cost += pushCost;\\n            }\\n            else{\\n                flag = true;\\n                cost += pushCost + moveCost;\\n                startAt = time[i];\\n            }\\n        }\\n        \\n        return cost;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747624,
                "title": "java-easy-solution-100-maximum-two-possible-ways",
                "content": "Solution : **Minimum(cost of all possible ways)**\\n\\nMinimum Possible Ways : ONE(1) => **minutes : seconds**\\nMaximum Possible Ways : TWO(2) => (1) **minutes : seconds** and (2) **(minutes-1) : (seconds+60)**\\n\\n**Intuition behind maximum possible ways**:\\n\\nWays to write 99 seconds =>  01:39 and 00:99\\nBut, 1:39 and :99 are also valid.\\nSo, maximum possible ways comes to be FOUR(4).\\n\\nWait, If you carefully observer 01:39 and 1:39\\nYou always find 1:39 as minimum solution, as extra ZEROs(0) will always add extra pushCost and moveCost.\\n\\nThus, we can neglect possible ways with prepending zeroes.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    \\n       //minutes\\n       int min=targetSeconds/60;\\n       //seconds\\n       int sec=targetSeconds%60;\\n            \\n       int ans=Integer.MAX_VALUE;\\n       Integer n=0;\\n        \\n        //Edge case: When minutes exceeds 99 \\n        //e.g., targetSeconds=6008 => Only one possible way 99:68\\n        if(min>99){ min=99; sec+=60; }\\n            \\n        //When rem <= 39, Two ways are possible : (1) min:rem (2) min-1:rem+60 \\n        //e.g., targetSeconds=500 => (1) 8:20 (2) 7:80\\n        if (sec <= 39) {\\n            //calculating cost for (2) min-1:rem+60\\n            Integer m=(min-1)*100+sec+60;\\n            ans=Math.min(ans,cost(startAt,moveCost, pushCost,m.toString().toCharArray()));\\n        }   \\n        \\n        //calculating cost for (1) min:rem\\n        n=min*100+sec;\\n        //finding minimun b/w (1) and (2), if (2) exists    \\n        ans=Math.min(ans,cost(startAt,moveCost, pushCost, n.toString().toCharArray()));\\n        \\n        \\n        return ans;\\n    }\\n    \\n    //cost(1,2,1,{\\'1\\',\\'0\\',\\'0\\',\\'0\\'}) => returns 6\\n    //cost(1,2,1,{\\'9,\\'6\\',\\'0\\'}) =>returns 9\\n    public int cost(int startAt,int moveCost, int pushCost, char num[]){\\n        \\n        int ans=pushCost*num.length;\\n        \\n        for(char c: num){\\n            if(startAt!=c-\\'0\\'){\\n                ans+=moveCost; \\n                startAt=c-\\'0\\';\\n            }\\n        }\\n        return ans;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    \\n       //minutes\\n       int min=targetSeconds/60;\\n       //seconds\\n       int sec=targetSeconds%60;\\n            \\n       int ans=Integer.MAX_VALUE;\\n       Integer n=0;\\n        \\n        //Edge case: When minutes exceeds 99 \\n        //e.g., targetSeconds=6008 => Only one possible way 99:68\\n        if(min>99){ min=99; sec+=60; }\\n            \\n        //When rem <= 39, Two ways are possible : (1) min:rem (2) min-1:rem+60 \\n        //e.g., targetSeconds=500 => (1) 8:20 (2) 7:80\\n        if (sec <= 39) {\\n            //calculating cost for (2) min-1:rem+60\\n            Integer m=(min-1)*100+sec+60;\\n            ans=Math.min(ans,cost(startAt,moveCost, pushCost,m.toString().toCharArray()));\\n        }   \\n        \\n        //calculating cost for (1) min:rem\\n        n=min*100+sec;\\n        //finding minimun b/w (1) and (2), if (2) exists    \\n        ans=Math.min(ans,cost(startAt,moveCost, pushCost, n.toString().toCharArray()));\\n        \\n        \\n        return ans;\\n    }\\n    \\n    //cost(1,2,1,{\\'1\\',\\'0\\',\\'0\\',\\'0\\'}) => returns 6\\n    //cost(1,2,1,{\\'9,\\'6\\',\\'0\\'}) =>returns 9\\n    public int cost(int startAt,int moveCost, int pushCost, char num[]){\\n        \\n        int ans=pushCost*num.length;\\n        \\n        for(char c: num){\\n            if(startAt!=c-\\'0\\'){\\n                ans+=moveCost; \\n                startAt=c-\\'0\\';\\n            }\\n        }\\n        return ans;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747592,
                "title": "runtime-32-ms-python3-deep-explanation-with-comments",
                "content": "we will divide this into parts ok! first part if 0<target<10 and second part 10<target<100 and third part greater than 100.\\n**First Part:**\\n\\t\\tThe maximum cost will be let max_cost=1*(moveCost +pushCost) for any case go check by ourself once. So if  startAt==targetseconds means we are not making move cost so we return max_cost -moveCost else return max_cost.Easy Right.\\n\\n**Second Part**\\n\\t\\t\\tThe maximun cost will be let max_cost=2*(moveCost+pushCost) for any case. We will use\\n\\t\\t\\tsome function to return count if recently  pushed is repeated. for example look below  function.For example:let\\'s take target=99 and startAt=9 using below function we get q=2 check it by ourself. From q it says that q no of moveCost are additional in max_cost so we remove q*moveCost from max_cost.Easy right.\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/3483970f-31e6-4cfd-90c3-2ab1afd4eaa5_1644083818.9248292.png)\\n\\n**Third Case:**\\n\\tGet the maximum and minimun minutes from below code as show i=max and j=min:\\n\\t![image](https://assets.leetcode.com/users/images/2b21e808-50c5-4c88-9313-b2ecc5d7b69e_1644083910.1455026.png)\\n\\n**Case 1: j<10**\\n\\t\\t\\t\\t\\t\\tHere maximum cost is 3*(moveCost+pushCost) check it by ourself. It same as second part here we are going to run loop for k in range( j , min(i,9)+1) # we are only considering 0<k<10#.\\n\\t\\t\\t\\t\\t\\tHere k=mins and to get remaining seconds h=abs(targetSeconds-(k*60)) and finally update h with str(k)+str(h)#mins+seconds# and remaining is same as second part except we need to \\nupdate self.z=startAt to compare new k.\\n**Case 2:i>=10:**\\n\\t\\t\\t\\t\\t\\t\\tHere max_cost=4*(move_Cost+push_Cost) and same as case 1 but for loop range(max(10,j),i+1)# i should be greater than 9#\\n\\n```class Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        #fun to find count of previous push\\n        def leng(t):\\n            q=0\\n            if t==self.z:\\n                q+=1\\n            return q\\n        self.z=startAt\\n        #i=max of minutes\\n        i=targetSeconds//60\\n        if i>99:\\n            i=int(99)\\n        #j=min of minutes\\n        j=math.ceil((targetSeconds-99)/60)\\n        if j<0:\\n            j=0\\n        #return value mi\\n        mi=float(inf)\\n        #first part\\n        if targetSeconds<10:\\n            #max cost\\n            m=1*(moveCost+pushCost)\\n            if startAt==targetSeconds:\\n                m-=moveCost\\n            return m\\n        #second part\\n        if targetSeconds<100:\\n            #max cost\\n            m=2*(moveCost+pushCost)\\n            h=targetSeconds\\n            q=0\\n            for b in str(h):\\n                q+=leng(int(b))\\n                self.z=int(b)\\n            mi=m-q*(moveCost)\\n        #third part case1\\n        if j<10:\\n            #max cost\\n            m=3*(moveCost+pushCost)\\n            #k sholud be in range(0,10) \\n            for k in range(j,min(i,9)+1):\\n                h=abs(targetSeconds-(k*60))\\n                #h=0 but in pratical it should be 00\\n                if h==0:\\n                    h=\\'00\\'\\n                #if h ==single b=digit in pratical it sholud be 0prefixed\\n                elif h<10:\\n                    h=str(\\'0\\')+str(h)\\n                #mins+seconds\\n                h=str(k)+str(h)\\n                q=0\\n                for b in str(h):\\n                    q+=leng(int(b))\\n                    self.z=int(b)\\n                #self.z=startAt because we need to restart for next iteration\\n                self.z=startAt\\n                y=m-q*(moveCost)\\n                mi=min(y,mi)\\n        if i>=10:\\n            #max cost\\n            m=4*(moveCost+pushCost)\\n            for k in range(max(10,j),i+1):\\n                h=abs(targetSeconds-(k*60))\\n                #h=0 but in pratical it should be 00\\n                if h==0:\\n                    h=\\'00\\'\\n                #if h ==single b=digit in pratical it sholud be 0prefixed\\n                elif h<10:\\n                    h=str(\\'0\\')+str(h)\\n                #mins+seconds\\n                h=str(k)+str(h)\\n                q=0\\n                for i in h:\\n                    q+=leng(int(i))\\n                    self.z=int(i)\\n                #self.z=startAt because we need to restart for next iteration\\n                self.z=startAt\\n                y=m-q*(moveCost)\\n                k=int(k//10)\\n                mi=min(y,mi)\\n        \\n        return mi\\n       \\n ```\\n **PLEASE UPVOTE  MY FRIEND YOU WON\\'T LOOSE NOTHING BY UPVOTING!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        #fun to find count of previous push\\n        def leng(t):\\n            q=0\\n            if t==self.z:\\n                q+=1\\n            return q\\n        self.z=startAt\\n        #i=max of minutes\\n        i=targetSeconds//60\\n        if i>99:\\n            i=int(99)\\n        #j=min of minutes\\n        j=math.ceil((targetSeconds-99)/60)\\n        if j<0:\\n            j=0\\n        #return value mi\\n        mi=float(inf)\\n        #first part\\n        if targetSeconds<10:\\n            #max cost\\n            m=1*(moveCost+pushCost)\\n            if startAt==targetSeconds:\\n                m-=moveCost\\n            return m\\n        #second part\\n        if targetSeconds<100:\\n            #max cost\\n            m=2*(moveCost+pushCost)\\n            h=targetSeconds\\n            q=0\\n            for b in str(h):\\n                q+=leng(int(b))\\n                self.z=int(b)\\n            mi=m-q*(moveCost)\\n        #third part case1\\n        if j<10:\\n            #max cost\\n            m=3*(moveCost+pushCost)\\n            #k sholud be in range(0,10) \\n            for k in range(j,min(i,9)+1):\\n                h=abs(targetSeconds-(k*60))\\n                #h=0 but in pratical it should be 00\\n                if h==0:\\n                    h=\\'00\\'\\n                #if h ==single b=digit in pratical it sholud be 0prefixed\\n                elif h<10:\\n                    h=str(\\'0\\')+str(h)\\n                #mins+seconds\\n                h=str(k)+str(h)\\n                q=0\\n                for b in str(h):\\n                    q+=leng(int(b))\\n                    self.z=int(b)\\n                #self.z=startAt because we need to restart for next iteration\\n                self.z=startAt\\n                y=m-q*(moveCost)\\n                mi=min(y,mi)\\n        if i>=10:\\n            #max cost\\n            m=4*(moveCost+pushCost)\\n            for k in range(max(10,j),i+1):\\n                h=abs(targetSeconds-(k*60))\\n                #h=0 but in pratical it should be 00\\n                if h==0:\\n                    h=\\'00\\'\\n                #if h ==single b=digit in pratical it sholud be 0prefixed\\n                elif h<10:\\n                    h=str(\\'0\\')+str(h)\\n                #mins+seconds\\n                h=str(k)+str(h)\\n                q=0\\n                for i in h:\\n                    q+=leng(int(i))\\n                    self.z=int(i)\\n                #self.z=startAt because we need to restart for next iteration\\n                self.z=startAt\\n                y=m-q*(moveCost)\\n                k=int(k//10)\\n                mi=min(y,mi)\\n        \\n        return mi\\n       \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1747548,
                "title": "java-min-cost-of-up-to-2-possible-options-o-1",
                "content": "Only up to 2 ways of setting the cooking time exist (ignoring those with explicitly pressed leading zeros) - just calculate their cost and pick the smallest.\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans= Integer.MAX_VALUE, mins= targetSeconds/60, secs= targetSeconds%60;\\n        if(mins>0 && secs<40) // solution exists with >= 60 seconds\\n            ans= cost(startAt, moveCost, pushCost, mins-1, secs+60);\\n        if(mins<100) //solution exists with <60 seconds\\n            ans= Math.min(ans, cost(startAt, moveCost, pushCost, mins, secs));\\n        return ans;\\n    }\\n    \\n    int cost(int startAt, int moveCost, int pushCost, int mins, int secs){\\n        int i=0, ans= 0, dig[]= {mins/10, mins%10, secs/10, secs%10};\\n        while(dig[i]==0) i++; // skip initial zeros\\n        for(int curr= startAt; i<4; curr= dig[i++]) // calculate cost of digits\\n            ans+= pushCost + (dig[i]!=curr ? moveCost : 0);\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans= Integer.MAX_VALUE, mins= targetSeconds/60, secs= targetSeconds%60;\\n        if(mins>0 && secs<40) // solution exists with >= 60 seconds\\n            ans= cost(startAt, moveCost, pushCost, mins-1, secs+60);\\n        if(mins<100) //solution exists with <60 seconds\\n            ans= Math.min(ans, cost(startAt, moveCost, pushCost, mins, secs));\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1747427,
                "title": "java-easy",
                "content": "We have two choices:\\n* Convert `targetSeconds` to minutes and seconds as is\\n* Convert `targetSeconds` to minutes and seconds and try to move one minute to seconds (if we have a room)\\n\\n**Hidden test case**: `minCostSetTime(0,1,1,6039)` - 99 mins, 99 seconds\\nThe result is 100 mins 39 seconds, if we convert to minutes and seconds as is => We need to check if we use 4 digits only\\n\\n```\\npublic int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\tint mins = targetSeconds / 60;\\n\\tint secs = targetSeconds % 60;\\n\\n\\t// convert to minutes and seconds as is\\n\\tint res = getCost(mins * 100 + secs, startAt, moveCost, pushCost);\\n\\n\\t// try to move one minute to seconds\\n\\tif (secs + 60 <= 99 && mins > 0) {\\n\\t\\tres = Math.min(res, getCost((mins - 1) * 100 + (secs + 60), startAt, moveCost, pushCost));\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int getCost(int targetSeconds, int startAt, int moveCost, int pushCost) {\\n\\t// hidden test case, we can only have 4 digits, minCostSetTime(0,1,1,6039)\\n\\tif (targetSeconds > 9999) {\\n\\t\\treturn Integer.MAX_VALUE;\\n\\t}\\n\\tint res = 0;\\n\\tvar ch = String.valueOf(targetSeconds).toCharArray();\\n\\tvar pre = (char) (startAt + \\'0\\');\\n\\tfor (int i = 0; i < ch.length; i++) {\\n\\t\\tif (ch[i] != pre) {\\n\\t\\t\\tres += moveCost;\\n\\t\\t}\\n\\t\\tres += pushCost;\\n\\t\\tpre = ch[i];\\n\\t}\\n\\treturn res;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\tint mins = targetSeconds / 60;\\n\\tint secs = targetSeconds % 60;\\n\\n\\t// convert to minutes and seconds as is\\n\\tint res = getCost(mins * 100 + secs, startAt, moveCost, pushCost);\\n\\n\\t// try to move one minute to seconds\\n\\tif (secs + 60 <= 99 && mins > 0) {\\n\\t\\tres = Math.min(res, getCost((mins - 1) * 100 + (secs + 60), startAt, moveCost, pushCost));\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int getCost(int targetSeconds, int startAt, int moveCost, int pushCost) {\\n\\t// hidden test case, we can only have 4 digits, minCostSetTime(0,1,1,6039)\\n\\tif (targetSeconds > 9999) {\\n\\t\\treturn Integer.MAX_VALUE;\\n\\t}\\n\\tint res = 0;\\n\\tvar ch = String.valueOf(targetSeconds).toCharArray();\\n\\tvar pre = (char) (startAt + \\'0\\');\\n\\tfor (int i = 0; i < ch.length; i++) {\\n\\t\\tif (ch[i] != pre) {\\n\\t\\t\\tres += moveCost;\\n\\t\\t}\\n\\t\\tres += pushCost;\\n\\t\\tpre = ch[i];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747419,
                "title": "javascript-dfs-backtracking-build-clock-string-792ms",
                "content": "```\\nlet start, mc, pc, res, sec;\\nconst minCostSetTime = (startAt, moveCost, pushCost, targetSeconds) => {\\n    start = startAt, mc = moveCost, pc = pushCost, res = Number.MAX_SAFE_INTEGER, sec = targetSeconds;\\n    dfs(0, \\'\\');\\n    return res;\\n};\\n\\nconst dfs = (idx, cur) => {\\n    if (cur.length > 4) return;\\n    if (cur.length == 1 || cur.length == 2) { // length is 1 or 2, only can be minutes  like \"76\", \"9\"\\n        if (cur - \\'0\\' == sec) res = Math.min(res, cal(cur))\\n    }\\n    if (cur.length == 4 || cur.length == 3) { // length is 3 or 4, calculate hours and seconds\\n        let h, m;\\n        if (cur.length == 3) {\\n            h = cur.slice(0, 1) - \\'0\\';\\n            m = cur.slice(1) - \\'0\\';\\n        } else {\\n            h = cur.slice(0, 2) - \\'0\\';\\n            m = cur.slice(2) - \\'0\\';\\n        }\\n        if (h * 60 + m == sec) res = Math.min(res, cal(cur))\\n    }\\n    for (let i = 0; i < 10; i++) { // build clock string\\n        cur += i + \\'\\';\\n        dfs(i, cur);\\n        cur = cur.slice(0, -1);\\n    }\\n};\\n\\nconst cal = (s) => { // calculate built clock string seconds\\n    let sum = 0, pre = start;\\n    for (const c of s) {\\n        if (c - \\'0\\' != pre) {\\n            sum += mc;\\n        }\\n        sum += pc;\\n        pre = c - \\'0\\';\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet start, mc, pc, res, sec;\\nconst minCostSetTime = (startAt, moveCost, pushCost, targetSeconds) => {\\n    start = startAt, mc = moveCost, pc = pushCost, res = Number.MAX_SAFE_INTEGER, sec = targetSeconds;\\n    dfs(0, \\'\\');\\n    return res;\\n};\\n\\nconst dfs = (idx, cur) => {\\n    if (cur.length > 4) return;\\n    if (cur.length == 1 || cur.length == 2) { // length is 1 or 2, only can be minutes  like \"76\", \"9\"\\n        if (cur - \\'0\\' == sec) res = Math.min(res, cal(cur))\\n    }\\n    if (cur.length == 4 || cur.length == 3) { // length is 3 or 4, calculate hours and seconds\\n        let h, m;\\n        if (cur.length == 3) {\\n            h = cur.slice(0, 1) - \\'0\\';\\n            m = cur.slice(1) - \\'0\\';\\n        } else {\\n            h = cur.slice(0, 2) - \\'0\\';\\n            m = cur.slice(2) - \\'0\\';\\n        }\\n        if (h * 60 + m == sec) res = Math.min(res, cal(cur))\\n    }\\n    for (let i = 0; i < 10; i++) { // build clock string\\n        cur += i + \\'\\';\\n        dfs(i, cur);\\n        cur = cur.slice(0, -1);\\n    }\\n};\\n\\nconst cal = (s) => { // calculate built clock string seconds\\n    let sum = 0, pre = start;\\n    for (const c of s) {\\n        if (c - \\'0\\' != pre) {\\n            sum += mc;\\n        }\\n        sum += pc;\\n        pre = c - \\'0\\';\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747414,
                "title": "python3-dijkstra",
                "content": "Formalize as a graph problem and interpret (time, digit) as a node, where time is the current cooking time and digit is the digit we have our finger on. The cost of an edge is dependent on whether we use the digit we have our finger on or not. Now apply Dijkstra for sparse graphs.\\n\\n```python\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        if targetSeconds == 0:\\n            return 0\\n        \\n        def newState(state, digit):\\n            return \"\".join([state[1:], str(digit)])\\n            \\n        def stateSecs(state):    \\n            minutes = int(state[:2])\\n            secs = int(state[2:])\\n            return minutes * 60 + secs\\n            \\n        def neighs(state, finger_digit):\\n            for i in range(10):\\n                new_state = newState(state, i)\\n                if i == finger_digit:\\n                    yield (new_state, i, pushCost)\\n                else:    \\n                    yield (new_state, i, pushCost + moveCost)\\n            \\n            \\n        INF = float(\"inf\")    \\n        distance = defaultdict(lambda: INF)        \\n        distance[(\"0000\", startAt)] = 0\\n        heap = [(0, startAt, \"0000\")]\\n        while heap:\\n            d, figdig, state = heapq.heappop(heap)\\n            if stateSecs(state) == targetSeconds:\\n                return d\\n            \\n            if d == distance[(state, figdig)]: \\n                for new_state, new_finger, cost in neighs(state, figdig):\\n                    trydist = d + cost\\n                    if trydist < distance[(new_state, new_finger)]:\\n                        distance[(new_state, new_finger)] = trydist\\n                        heapq.heappush(heap, (trydist, new_finger, new_state))\\n        return -1  \\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        if targetSeconds == 0:\\n            return 0\\n        \\n        def newState(state, digit):\\n            return \"\".join([state[1:], str(digit)])\\n            \\n        def stateSecs(state):    \\n            minutes = int(state[:2])\\n            secs = int(state[2:])\\n            return minutes * 60 + secs\\n            \\n        def neighs(state, finger_digit):\\n            for i in range(10):\\n                new_state = newState(state, i)\\n                if i == finger_digit:\\n                    yield (new_state, i, pushCost)\\n                else:    \\n                    yield (new_state, i, pushCost + moveCost)\\n            \\n            \\n        INF = float(\"inf\")    \\n        distance = defaultdict(lambda: INF)        \\n        distance[(\"0000\", startAt)] = 0\\n        heap = [(0, startAt, \"0000\")]\\n        while heap:\\n            d, figdig, state = heapq.heappop(heap)\\n            if stateSecs(state) == targetSeconds:\\n                return d\\n            \\n            if d == distance[(state, figdig)]: \\n                for new_state, new_finger, cost in neighs(state, figdig):\\n                    trydist = d + cost\\n                    if trydist < distance[(new_state, new_finger)]:\\n                        distance[(new_state, new_finger)] = trydist\\n                        heapq.heappush(heap, (trydist, new_finger, new_state))\\n        return -1  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747350,
                "title": "simple-c-sol-beats-100-all-edge-cases-explained",
                "content": "\\n--Just need to take care of edge cases in this problem, problem is easy\\n\\n\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        \\n        int cost=INT_MAX, m=targetSeconds/60, n=targetSeconds%60, tc=0, prev=startAt;\\n        if(m>=100) m=m-1, n=n+60; \\n        \\n        int m1=m-1, n1=n+60;\\n        vector<int> v1,v2;\\n    \\n       // cout<<m<<\" \"<<n<<endl;\\n        \\n        while(m)\\n        {\\n            int r=m%10;\\n            v1.push_back(r);\\n            m/=10;\\n        }\\n        reverse(v1.begin(), v1.end());\\n        \\n        while(n)\\n        {\\n            int r=n%10;\\n            v2.push_back(r);\\n            n/=10;\\n        }\\n        \\n        if(v1.size()>0 and v2.size()<2)\\n        {\\n            if(v2.size()==0) \\n            {\\n                v2.push_back(0);\\n                v2.push_back(0);\\n            }\\n            else v2.push_back(0);\\n        }\\n        reverse(v2.begin(), v2.end());\\n        \\n        \\n        for(int i=0; i<v2.size(); i++) v1.push_back(v2[i]);\\n        \\n        \\n       // for(int i=0; i<v1.size(); i++) cout<<v1[i]<<\" \";   \\n        //cout<<endl;\\n        \\n        for(int i=0; i<v1.size(); i++)\\n        {\\n            if(v1[i]==prev) tc+=pushCost;\\n            else\\n            {\\n                tc+=moveCost;\\n                prev=v1[i];\\n                tc+=pushCost;\\n            }\\n        }\\n        cost=min(tc,cost);\\n    \\n        \\n        // cout<<m1<<\" \"<<n1<<endl;\\n        // if we can represent the time by decresing 1 hr and incresing 60 seconds.\\n        if(m1>=0 and n1<100)\\n        {\\n           // cout<<m1<<\" \"<<n1<<endl;\\n            \\n            vector<int> v3,v4;\\n            while(m1)\\n            {\\n                int r=m1%10;\\n                v3.push_back(r);\\n                m1/=10;\\n            }\\n            reverse(v3.begin(), v3.end());\\n        \\n            while(n1)\\n            {\\n                int r=n1%10;\\n                v4.push_back(r);\\n                n1/=10;\\n            }\\n            if(v3.size()>0 and v4.size()<2)\\n            {\\n                if(v4.size()==0) \\n                {\\n                    v4.push_back(0);\\n                    v4.push_back(0);\\n                }\\n                else v4.push_back(0);\\n            }\\n            reverse(v4.begin(), v4.end());\\n        \\n            for(int i=0; i<v2.size(); i++) v3.push_back(v4[i]);\\n            \\n            //for(int i=0; i<v3.size(); i++) cout<<v3[i]<<\" \"; \\n            \\n            tc=0, prev=startAt;\\n            for(int i=0; i<v3.size(); i++)\\n            {\\n                if(v3[i]==prev) tc+=pushCost;\\n                else\\n                {\\n                    tc+=moveCost;\\n                    prev=v3[i];\\n                    tc+=pushCost;\\n                }\\n            }   \\n            cost=min(tc,cost);\\n        }\\n        return cost;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        \\n        int cost=INT_MAX, m=targetSeconds/60, n=targetSeconds%60, tc=0, prev=startAt;\\n        if(m>=100) m=m-1, n=n+60; \\n        \\n        int m1=m-1, n1=n+60;\\n        vector<int> v1,v2;\\n    \\n       // cout<<m<<\" \"<<n<<endl;\\n        \\n        while(m)\\n        {\\n            int r=m%10;\\n            v1.push_back(r);\\n            m/=10;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1747329,
                "title": "c-recursive-solution-beats-100-0ms",
                "content": "Here is my brute force recursive solution that beats 100%\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dp(int moveCost, int pushCost, int targetSeconds, int lastDigit, int idx)\\n    {\\n        if (targetSeconds < 0)\\n            return INT_MAX;\\n        \\n        if (idx == 1) {\\n            if (targetSeconds >= 10) {\\n                return INT_MAX;\\n            }else{\\n                return lastDigit == targetSeconds ? pushCost : pushCost + moveCost;\\n            }\\n        }\\n        \\n        if (targetSeconds == 0)\\n            return dp(moveCost, pushCost, targetSeconds, 0, idx - 1) + (lastDigit == 0 ? pushCost : pushCost + moveCost);\\n        \\n        int m = idx == 4 ? 60*10 : (idx == 3 ? 60 : (idx == 2 ? 10 : 1));\\n        int result = INT_MAX;\\n        \\n        for (int i = 0; i <= 9; i++) {\\n            if (m * i <= targetSeconds) {\\n                int cost = dp(moveCost, pushCost, targetSeconds - m * i, i, idx - 1);\\n                if (cost != INT_MAX) {\\n                    result = min(result, cost + (lastDigit == i ? pushCost : pushCost + moveCost));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mn = INT_MAX;\\n        for (int i = 4; i >= 1; i--) {\\n            mn = min(mn, dp(moveCost, pushCost, targetSeconds, startAt, i));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp(int moveCost, int pushCost, int targetSeconds, int lastDigit, int idx)\\n    {\\n        if (targetSeconds < 0)\\n            return INT_MAX;\\n        \\n        if (idx == 1) {\\n            if (targetSeconds >= 10) {\\n                return INT_MAX;\\n            }else{\\n                return lastDigit == targetSeconds ? pushCost : pushCost + moveCost;\\n            }\\n        }\\n        \\n        if (targetSeconds == 0)\\n            return dp(moveCost, pushCost, targetSeconds, 0, idx - 1) + (lastDigit == 0 ? pushCost : pushCost + moveCost);\\n        \\n        int m = idx == 4 ? 60*10 : (idx == 3 ? 60 : (idx == 2 ? 10 : 1));\\n        int result = INT_MAX;\\n        \\n        for (int i = 0; i <= 9; i++) {\\n            if (m * i <= targetSeconds) {\\n                int cost = dp(moveCost, pushCost, targetSeconds - m * i, i, idx - 1);\\n                if (cost != INT_MAX) {\\n                    result = min(result, cost + (lastDigit == i ? pushCost : pushCost + moveCost));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mn = INT_MAX;\\n        for (int i = 4; i >= 1; i--) {\\n            mn = min(mn, dp(moveCost, pushCost, targetSeconds, startAt, i));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747324,
                "title": "c-min-max-logic-o-1-time-complexity-solution-and-o-1-space-100-faster",
                "content": "Logic is explained in code, we need to check minimum minute that can be possible and maximum minute that can be possible.\\n\\n```\\n int cal(int minute, int second, int pc, int mc, int sa) {\\n  int cost = 0;\\n\\n  // m2 represent second digit of minute, m1 represent first digit of minute\\n  int m2 = minute % 10;\\n  minute /= 10;\\n  int m1 = minute % 10;\\n\\n// s2 represent second digit of minute, s1 represent first digit of minute\\n  int s2 = second % 10;\\n  second /= 10;\\n  int s1 = second % 10;\\n\\n/* check if first digit of minute is >0 ,\\n  if no, then we don\\'t type \\'0\\' because it will auto normalize, \\n  if Yes, then check whether start at is same as first digit(m1),\\n      if no, then increment cost by move cost+push cost\\n      if yes, then increment cost by push cost\\n      set start at to m1\\n*/ \\n  if (m1 > 0) {\\n    if (sa != m1) {\\n      cost += pc + mc;\\n    } else {\\n      cost += pc;\\n    }\\n    sa = m1;\\n  }\\n  \\n/* check if second digit of minute is >0 or we have typed first digit m1 of minute (then cost>0) ,\\n  if no, then we don\\'t type \\'0\\' because it will auto normalize, \\n  if Yes, then check whether start at is same as second digit(m2),\\n      if no, then increment cost by move cost+push cost\\n      if yes, then increment cost by push cost\\n      set start at to m2\\n*/\\n  if (m2 > 0 || cost > 0) {\\n    if (sa != m2) {\\n      cost += pc + mc;\\n    } else {\\n      cost += pc;\\n    }\\n    sa = m2;\\n  }\\n\\n  /*Just like minute we also need to check whether we need to type s1 and s2 , if we already typed previous digit (that means cost>0)\\n  then we have no choice except typing s1 and s2, else if cost==0 that means m1=0,m2=0, so if s1=0 then we don\\'t type s1 else we need to type \\n  it . At the end we always have to type s2 because there can always be second for example 00:01, 00:55.let take 00:00 ,even if we start at 0\\n  then also without pushing(typing) 0 it cannot normalize to 00:00 so, we have to push last digit of second ie s2 */\\n  if (s1 > 0 || cost > 0) {\\n    if (sa != s1) {\\n      cost += pc + mc;\\n    } else {\\n      cost += pc;\\n    }\\n    sa = s1;\\n  }\\n\\n  if (sa != s2) {\\n    cost += pc + mc;\\n  } else {\\n    cost += pc;\\n  }\\n  sa = s2;\\n\\n  return cost;\\n}\\nint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n  // Lmin denote minimum minute that we can set to form given tarrget Second\\n  int lmin = 0;\\n  if (targetSeconds > 99) lmin = ceil((1.0 * (targetSeconds - 99)) / 60);\\n\\n  //Rmin denote maximum minute that we can set to form  given target Second \\n  int rmin = targetSeconds / 60;\\n  rmin = min(99, rmin);\\n\\n\\n  // Taking Minute from lmin to rmin and computing Second required to form Target Second And Then finding operation needed\\n  int ans = INT_MAX;\\n  for (int i = lmin; i <= rmin; i++) {\\n    int sec = targetSeconds - i * 60;\\n    int op = cal(i, sec, pushCost, moveCost, startAt);\\n    ans = min(op, ans);\\n  }\\n  return ans;\\n}\\n```\\n\\nTime Complexity: O(1)\\nminimum minute always be ceil(1.0*targetSeconds-99)/60)\\nmaximum minute always be floor(targetSeconds/60)\\n\\ndifference in between always be <=2 so loop will always for loop run 2times,\\nnow each loop iteration call cal function which calculate operation needed that is basically O(1)\\n\\nSpace Complexity: O(1) because no extra space used",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n int cal(int minute, int second, int pc, int mc, int sa) {\\n  int cost = 0;\\n\\n  // m2 represent second digit of minute, m1 represent first digit of minute\\n  int m2 = minute % 10;\\n  minute /= 10;\\n  int m1 = minute % 10;\\n\\n// s2 represent second digit of minute, s1 represent first digit of minute\\n  int s2 = second % 10;\\n  second /= 10;\\n  int s1 = second % 10;\\n\\n/* check if first digit of minute is >0 ,\\n  if no, then we don\\'t type \\'0\\' because it will auto normalize, \\n  if Yes, then check whether start at is same as first digit(m1),\\n      if no, then increment cost by move cost+push cost\\n      if yes, then increment cost by push cost\\n      set start at to m1\\n*/ \\n  if (m1 > 0) {\\n    if (sa != m1) {\\n      cost += pc + mc;\\n    } else {\\n      cost += pc;\\n    }\\n    sa = m1;\\n  }\\n  \\n/* check if second digit of minute is >0 or we have typed first digit m1 of minute (then cost>0) ,\\n  if no, then we don\\'t type \\'0\\' because it will auto normalize, \\n  if Yes, then check whether start at is same as second digit(m2),\\n      if no, then increment cost by move cost+push cost\\n      if yes, then increment cost by push cost\\n      set start at to m2\\n*/\\n  if (m2 > 0 || cost > 0) {\\n    if (sa != m2) {\\n      cost += pc + mc;\\n    } else {\\n      cost += pc;\\n    }\\n    sa = m2;\\n  }\\n\\n  /*Just like minute we also need to check whether we need to type s1 and s2 , if we already typed previous digit (that means cost>0)\\n  then we have no choice except typing s1 and s2, else if cost==0 that means m1=0,m2=0, so if s1=0 then we don\\'t type s1 else we need to type \\n  it . At the end we always have to type s2 because there can always be second for example 00:01, 00:55.let take 00:00 ,even if we start at 0\\n  then also without pushing(typing) 0 it cannot normalize to 00:00 so, we have to push last digit of second ie s2 */\\n  if (s1 > 0 || cost > 0) {\\n    if (sa != s1) {\\n      cost += pc + mc;\\n    } else {\\n      cost += pc;\\n    }\\n    sa = s1;\\n  }\\n\\n  if (sa != s2) {\\n    cost += pc + mc;\\n  } else {\\n    cost += pc;\\n  }\\n  sa = s2;\\n\\n  return cost;\\n}\\nint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n  // Lmin denote minimum minute that we can set to form given tarrget Second\\n  int lmin = 0;\\n  if (targetSeconds > 99) lmin = ceil((1.0 * (targetSeconds - 99)) / 60);\\n\\n  //Rmin denote maximum minute that we can set to form  given target Second \\n  int rmin = targetSeconds / 60;\\n  rmin = min(99, rmin);\\n\\n\\n  // Taking Minute from lmin to rmin and computing Second required to form Target Second And Then finding operation needed\\n  int ans = INT_MAX;\\n  for (int i = lmin; i <= rmin; i++) {\\n    int sec = targetSeconds - i * 60;\\n    int op = cal(i, sec, pushCost, moveCost, startAt);\\n    ans = min(op, ans);\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747238,
                "title": "jav-all-possible-permutation",
                "content": "```\\nclass Solution {\\n    public int solve(List<Integer> list, int startAt, int moveCost, int pushCost){\\n        int res = 0;\\n        if(list.get(0) != startAt){\\n            res+=moveCost;\\n        }\\n        res+=pushCost;\\n        \\n        for(int i=1; i<list.size(); i++){\\n            if(list.get(i) != list.get(i-1))\\n                res+=moveCost;\\n            res+=pushCost;\\n        }\\n        return res;\\n    }\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost=(int) 1e8;\\n        /*\\n            Just make all possible combinations of 4 digit number from 0-9\\n            \\n        */\\n        for(int i=0; i<=9; i++){\\n            for(int j=0; j<=9; j++){\\n                for(int k=0; k<=9; k++){\\n                    for(int l=0; l<=9; l++){\\n                        \\n                        List<Integer> list=new ArrayList<>();\\n                        \\n                        int sec = i*10*60 + j*60 + k*10 + l;\\n                        \\n                        if(sec == targetSeconds){\\n                            list.add(i);\\n                            list.add(j);\\n                            list.add(k);\\n                            list.add(l);\\n                            \\n                            cost=Math.min(cost, solve(list, startAt, moveCost, pushCost));\\n                            \\n                            while(list.get(0) == 0){\\n                                list.remove(0);\\n                                cost=Math.min(cost, solve(list, startAt, moveCost, pushCost));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(List<Integer> list, int startAt, int moveCost, int pushCost){\\n        int res = 0;\\n        if(list.get(0) != startAt){\\n            res+=moveCost;\\n        }\\n        res+=pushCost;\\n        \\n        for(int i=1; i<list.size(); i++){\\n            if(list.get(i) != list.get(i-1))\\n                res+=moveCost;\\n            res+=pushCost;\\n        }\\n        return res;\\n    }\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost=(int) 1e8;\\n        /*\\n            Just make all possible combinations of 4 digit number from 0-9\\n            \\n        */\\n        for(int i=0; i<=9; i++){\\n            for(int j=0; j<=9; j++){\\n                for(int k=0; k<=9; k++){\\n                    for(int l=0; l<=9; l++){\\n                        \\n                        List<Integer> list=new ArrayList<>();\\n                        \\n                        int sec = i*10*60 + j*60 + k*10 + l;\\n                        \\n                        if(sec == targetSeconds){\\n                            list.add(i);\\n                            list.add(j);\\n                            list.add(k);\\n                            list.add(l);\\n                            \\n                            cost=Math.min(cost, solve(list, startAt, moveCost, pushCost));\\n                            \\n                            while(list.get(0) == 0){\\n                                list.remove(0);\\n                                cost=Math.min(cost, solve(list, startAt, moveCost, pushCost));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747159,
                "title": "typescript-javascript-solution",
                "content": "Simple, but tons of corner cases. :/\\nI send wrong solutions 3 times during contest... All in all -- love this problem :)\\n\\n```\\nfunction minCostSetTime(\\n    startAt: number,\\n    moveCost: number,\\n    pushCost: number,\\n    targetSeconds: number,\\n): number {\\n    const mins = Math.floor(targetSeconds / 60);\\n    const seconds = targetSeconds % 60;\\n    const options = [\\n        `${\\n            mins > 0 ? mins : \\'\\' // avoid \\'0\\'\\n         }${\\n            `${seconds}`.padStart(mins > 0 ? 2 : 0, \\'0\\') // avoid \"12\" for 1 minutes 2 seconds AND \\'01\\' for 0 minutes 1 seconds\\n         }`\\n    ];\\n    \\n    if (targetSeconds > 59 && (seconds + 60 <= 99)) { // remember: we can dial 1 minute 30 seconds as \"160\" OR \"90\" as long as seconds are below 99\\n        options.push(`${\\n            (mins - 1) > 0 ? mins - 1 : \\'\\' // once again avoid \"0\"\\n        }${\\n            seconds + 60 // no need to check here, since we know that number is double digits\\n        }`);\\n    }\\n    \\n    let minSum = Infinity;\\n\\n    for (const option of options) {\\n        if (option.length > 4) continue; // will ensure that we only accept 100 minutes 00 seconds as 9960 :/\\n        let optionSum = 0;\\n        let current = `${startAt}`;\\n        for (let i = 0; i < option.length; i++) {\\n            const n = option[i];\\n            if (n !== current) {\\n                optionSum += moveCost;\\n                current = n;\\n            }\\n            optionSum += pushCost;\\n        }\\n        if (optionSum < minSum) {\\n            minSum = optionSum;\\n        }\\n    }\\n    return minSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minCostSetTime(\\n    startAt: number,\\n    moveCost: number,\\n    pushCost: number,\\n    targetSeconds: number,\\n): number {\\n    const mins = Math.floor(targetSeconds / 60);\\n    const seconds = targetSeconds % 60;\\n    const options = [\\n        `${\\n            mins > 0 ? mins : \\'\\' // avoid \\'0\\'\\n         }${\\n            `${seconds}`.padStart(mins > 0 ? 2 : 0, \\'0\\') // avoid \"12\" for 1 minutes 2 seconds AND \\'01\\' for 0 minutes 1 seconds\\n         }`\\n    ];\\n    \\n    if (targetSeconds > 59 && (seconds + 60 <= 99)) { // remember: we can dial 1 minute 30 seconds as \"160\" OR \"90\" as long as seconds are below 99\\n        options.push(`${\\n            (mins - 1) > 0 ? mins - 1 : \\'\\' // once again avoid \"0\"\\n        }${\\n            seconds + 60 // no need to check here, since we know that number is double digits\\n        }`);\\n    }\\n    \\n    let minSum = Infinity;\\n\\n    for (const option of options) {\\n        if (option.length > 4) continue; // will ensure that we only accept 100 minutes 00 seconds as 9960 :/\\n        let optionSum = 0;\\n        let current = `${startAt}`;\\n        for (let i = 0; i < option.length; i++) {\\n            const n = option[i];\\n            if (n !== current) {\\n                optionSum += moveCost;\\n                current = n;\\n            }\\n            optionSum += pushCost;\\n        }\\n        if (optionSum < minSum) {\\n            minSum = optionSum;\\n        }\\n    }\\n    return minSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747119,
                "title": "c-evaluate-all-possible-mins-and-seconds-combination-for-target",
                "content": "```\\npublic class Solution {\\n    public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mins = targetSeconds/60;\\n        int sec = targetSeconds%60;\\n        int ans = int.MaxValue;\\n        if(mins>99){\\n            sec=targetSeconds-5940;\\n            mins=99;\\n        }\\n    \\n        while(sec<100 && mins>=0){\\n            ans = Math.Min(ans,Calculate(mins,sec,startAt,moveCost,pushCost));\\n            mins--;\\n            sec+=60;\\n        }\\n        return ans;\\n        \\n    }\\n    public int Calculate(int mins,int sec,int startAt, int moveCost, int pushCost){\\n        char prev = startAt.ToString()[0];\\n        string ssec = sec<10 && mins>0 ? \"0\"+sec : sec.ToString();\\n        string smins = mins.ToString();\\n        int ans=0;\\n        if(mins>0){\\n            for(int i=0;i<smins.Length;i++){\\n              if(prev!=smins[i]) ans+=moveCost;\\n              prev = smins[i];\\n             ans+=pushCost;\\n            }\\n        }\\n        for(int i=0;i<ssec.Length;i++){\\n            if(prev!=ssec[i]) ans+=moveCost;\\n            prev = ssec[i];\\n            ans+=pushCost;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mins = targetSeconds/60;\\n        int sec = targetSeconds%60;\\n        int ans = int.MaxValue;\\n        if(mins>99){\\n            sec=targetSeconds-5940;\\n            mins=99;\\n        }\\n    \\n        while(sec<100 && mins>=0){\\n            ans = Math.Min(ans,Calculate(mins,sec,startAt,moveCost,pushCost));\\n            mins--;\\n            sec+=60;\\n        }\\n        return ans;\\n        \\n    }\\n    public int Calculate(int mins,int sec,int startAt, int moveCost, int pushCost){\\n        char prev = startAt.ToString()[0];\\n        string ssec = sec<10 && mins>0 ? \"0\"+sec : sec.ToString();\\n        string smins = mins.ToString();\\n        int ans=0;\\n        if(mins>0){\\n            for(int i=0;i<smins.Length;i++){\\n              if(prev!=smins[i]) ans+=moveCost;\\n              prev = smins[i];\\n             ans+=pushCost;\\n            }\\n        }\\n        for(int i=0;i<ssec.Length;i++){\\n            if(prev!=ssec[i]) ans+=moveCost;\\n            prev = ssec[i];\\n            ans+=pushCost;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747117,
                "title": "c-just-loop-through-each-possible-seconds",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n    {\\n        int result = int.MaxValue;\\n        \\n        for (int i = 0; i <= 99 && i <= targetSeconds; i++)\\n        {           \\n            if ((targetSeconds - i) % 60 == 0)\\n            {\\n                int m = ((targetSeconds - i) / 60) * 100 + i;\\n\\n                int onM = m switch\\n                {\\n                    < 10 => oneDigit(startAt, moveCost, pushCost, m),\\n                    < 100 => twoDigit(startAt, moveCost, pushCost, m),\\n                    < 1000 => threeDigit(startAt, moveCost, pushCost, m),\\n                    < 10000 => fourDigit(startAt, moveCost, pushCost, m),\\n                    _ => int.MaxValue\\n                };\\n\\n                result = Math.Min(result, onM);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int oneDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        int digit = num % 10;\\n        return (startAt == digit ? 0 : moveCost) + pushCost;\\n    }\\n\\n    private int twoDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        int first = num / 10;\\n        int second = num % 10;\\n        return (startAt == first ? 0 : moveCost) + (first == second ? 0 : moveCost) + 2 * pushCost;\\n    }\\n\\n    private int threeDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        List<int> digits = new List<int>();\\n        while (num > 0)\\n        {\\n            digits.Add(num % 10);\\n            num /= 10;\\n        }\\n\\n        int first = digits[^1];\\n        int second = digits[^2];\\n        int third = digits[^3];\\n        int current = (startAt == first ? 0 : moveCost) + (first == second ? 0 : moveCost)\\n                 + (second == third ? 0 : moveCost) + 3 * pushCost;\\n\\n        return current;\\n    }\\n\\n    private int fourDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        List<int> digits = new List<int>();\\n        while (num > 0)\\n        {\\n            digits.Add(num % 10);\\n            num /= 10;\\n        }\\n\\n        int first = digits[^1];\\n        int second = digits[^2];\\n        int third = digits[^3];\\n        int fourth = digits[^4];\\n        int current = (startAt == first ? 0 : moveCost) + (first == second ? 0 : moveCost)\\n                 + (second == third ? 0 : moveCost) + (third == fourth ? 0 : moveCost)\\n                 + 4 * pushCost;\\n\\n        return current;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n    {\\n        int result = int.MaxValue;\\n        \\n        for (int i = 0; i <= 99 && i <= targetSeconds; i++)\\n        {           \\n            if ((targetSeconds - i) % 60 == 0)\\n            {\\n                int m = ((targetSeconds - i) / 60) * 100 + i;\\n\\n                int onM = m switch\\n                {\\n                    < 10 => oneDigit(startAt, moveCost, pushCost, m),\\n                    < 100 => twoDigit(startAt, moveCost, pushCost, m),\\n                    < 1000 => threeDigit(startAt, moveCost, pushCost, m),\\n                    < 10000 => fourDigit(startAt, moveCost, pushCost, m),\\n                    _ => int.MaxValue\\n                };\\n\\n                result = Math.Min(result, onM);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\n    private int oneDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        int digit = num % 10;\\n        return (startAt == digit ? 0 : moveCost) + pushCost;\\n    }\\n\\n    private int twoDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        int first = num / 10;\\n        int second = num % 10;\\n        return (startAt == first ? 0 : moveCost) + (first == second ? 0 : moveCost) + 2 * pushCost;\\n    }\\n\\n    private int threeDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        List<int> digits = new List<int>();\\n        while (num > 0)\\n        {\\n            digits.Add(num % 10);\\n            num /= 10;\\n        }\\n\\n        int first = digits[^1];\\n        int second = digits[^2];\\n        int third = digits[^3];\\n        int current = (startAt == first ? 0 : moveCost) + (first == second ? 0 : moveCost)\\n                 + (second == third ? 0 : moveCost) + 3 * pushCost;\\n\\n        return current;\\n    }\\n\\n    private int fourDigit(int startAt, int moveCost, int pushCost, int num)\\n    {\\n        List<int> digits = new List<int>();\\n        while (num > 0)\\n        {\\n            digits.Add(num % 10);\\n            num /= 10;\\n        }\\n\\n        int first = digits[^1];\\n        int second = digits[^2];\\n        int third = digits[^3];\\n        int fourth = digits[^4];\\n        int current = (startAt == first ? 0 : moveCost) + (first == second ? 0 : moveCost)\\n                 + (second == third ? 0 : moveCost) + (third == fourth ? 0 : moveCost)\\n                 + 4 * pushCost;\\n\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747111,
                "title": "java-solution-precompute-everything-short-explanation",
                "content": "I am checking for every clockTime starting from 00:01 to 99:99 in the oven what is the total seconds and store it in a hashmap.\\n\\nSo my HashMap stores every possible way to reach a targetSecond.\\n\\nexample : hasmap[76] = { 076 , 76 , 0076 , 0116 , 116 };\\n\\nNext as per the targetSecond in problemStatement i simply iterate over the values and return the answer :)\\n\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans = Integer.MAX_VALUE;\\n        int maxLen = 4;\\n        HashMap<Integer , List<String>> map = new HashMap<>();\\n        for (int i=1 ; i<=9999 ; i++) {\\n            int seconds = getSeconds(i);\\n            if (!map.containsKey(seconds)) {\\n                map.put(seconds, new ArrayList<>());\\n            }\\n            map.get(seconds).add(String.valueOf(i));\\n            int paddedZeroes = maxLen - String.valueOf(i).length();\\n            String s = \"\"+i;\\n            for (int k=0 ; k<paddedZeroes ; k++) {\\n                s = \"0\"+s;\\n                map.get(seconds).add(s);\\n            }\\n        }\\n\\n        for (String unit : map.get(targetSeconds)) {\\n            char ch[] = unit.toCharArray();\\n            int currentCost = 0;\\n            int prevDigit = startAt;\\n            for (int k = 0; k < ch.length; k++) {\\n                if (ch[k] - \\'0\\' != prevDigit) {\\n                    currentCost += moveCost;\\n                }\\n                currentCost += pushCost;\\n                prevDigit = ch[k] - \\'0\\';\\n            }\\n            ans = Math.min(ans, currentCost);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int getSeconds(int i) {\\n        String s = \"\"+i;\\n        if (s.length() <= 2)\\n            return i;\\n        if (s.length() == 3) {\\n            String min = s.substring(0, 1);\\n            String sec = s.substring(1);\\n            return Integer.parseInt(min) * 60 + Integer.parseInt(sec);\\n        } else {\\n            String min = s.substring(0, 2);\\n            String sec = s.substring(2);\\n            return Integer.parseInt(min) * 60 + Integer.parseInt(sec);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans = Integer.MAX_VALUE;\\n        int maxLen = 4;\\n        HashMap<Integer , List<String>> map = new HashMap<>();\\n        for (int i=1 ; i<=9999 ; i++) {\\n            int seconds = getSeconds(i);\\n            if (!map.containsKey(seconds)) {\\n                map.put(seconds, new ArrayList<>());\\n            }\\n            map.get(seconds).add(String.valueOf(i));\\n            int paddedZeroes = maxLen - String.valueOf(i).length();\\n            String s = \"\"+i;\\n            for (int k=0 ; k<paddedZeroes ; k++) {\\n                s = \"0\"+s;\\n                map.get(seconds).add(s);\\n            }\\n        }\\n\\n        for (String unit : map.get(targetSeconds)) {\\n            char ch[] = unit.toCharArray();\\n            int currentCost = 0;\\n            int prevDigit = startAt;\\n            for (int k = 0; k < ch.length; k++) {\\n                if (ch[k] - \\'0\\' != prevDigit) {\\n                    currentCost += moveCost;\\n                }\\n                currentCost += pushCost;\\n                prevDigit = ch[k] - \\'0\\';\\n            }\\n            ans = Math.min(ans, currentCost);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int getSeconds(int i) {\\n        String s = \"\"+i;\\n        if (s.length() <= 2)\\n            return i;\\n        if (s.length() == 3) {\\n            String min = s.substring(0, 1);\\n            String sec = s.substring(1);\\n            return Integer.parseInt(min) * 60 + Integer.parseInt(sec);\\n        } else {\\n            String min = s.substring(0, 2);\\n            String sec = s.substring(2);\\n            return Integer.parseInt(min) * 60 + Integer.parseInt(sec);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747053,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        long out = Long.MAX_VALUE;\\n        if(min < 100)\\n            out = Math.min(out, getCost(startAt, moveCost, pushCost, min * 100 + sec)); \\n        if(sec < 40 && min > 0){\\n            out = Math.min(out, getCost(startAt, moveCost, pushCost, (min-1) *100 + (sec + 60)));\\n        }\\n        return (int)out;\\n    }\\n    \\n    private long getCost(int n, int moveCost, int pushCost, int x){\\n        long sum = 0;\\n    \\tfor(int i=1;i<4;i++) {\\n    \\t\\tint d = (int)Math.pow(10, i);\\n    \\t\\tif(x / d == 0) {\\n    \\t\\t\\tx %= d;\\n    \\t\\t}else {\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\tString s = String.valueOf(x);\\n    \\tfor(char c : s.toCharArray()) {\\n    \\t\\tint e = c-\\'0\\';\\n    \\t\\tif(e != n) {\\n    \\t\\t\\tsum += moveCost + pushCost;\\n    \\t\\t}else {\\n    \\t\\t\\tsum += pushCost;\\n    \\t\\t}\\n    \\t\\tn = e;\\n    \\t}\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        long out = Long.MAX_VALUE;\\n        if(min < 100)\\n            out = Math.min(out, getCost(startAt, moveCost, pushCost, min * 100 + sec)); \\n        if(sec < 40 && min > 0){\\n            out = Math.min(out, getCost(startAt, moveCost, pushCost, (min-1) *100 + (sec + 60)));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3994236,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minCostSetTime(int startAt, int moveCost, int pushCost,\\n                     int targetSeconds) {\\n    int ans = INT_MAX;\\n    int mins = targetSeconds > 5999 ? 99 : targetSeconds / 60;\\n    int secs = targetSeconds - mins * 60;\\n\\n    auto getCost = [&](int mins, int secs) -> int {\\n      int cost = 0;\\n      char curr = \\'0\\' + startAt;\\n      for (const char c : to_string(mins * 100 + secs))\\n        if (c == curr) {\\n          cost += pushCost;\\n        } else {\\n          cost += moveCost + pushCost;\\n          curr = c;\\n        }\\n      return cost;\\n    };\\n\\n    while (secs < 100) {\\n      ans = min(ans, getCost(mins, secs));\\n      --mins;\\n      secs += 60;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minCostSetTime(int startAt, int moveCost, int pushCost,\\n                     int targetSeconds) {\\n    int ans = INT_MAX;\\n    int mins = targetSeconds > 5999 ? 99 : targetSeconds / 60;\\n    int secs = targetSeconds - mins * 60;\\n\\n    auto getCost = [&](int mins, int secs) -> int {\\n      int cost = 0;\\n      char curr = \\'0\\' + startAt;\\n      for (const char c : to_string(mins * 100 + secs))\\n        if (c == curr) {\\n          cost += pushCost;\\n        } else {\\n          cost += moveCost + pushCost;\\n          curr = c;\\n        }\\n      return cost;\\n    };\\n\\n    while (secs < 100) {\\n      ans = min(ans, getCost(mins, secs));\\n      --mins;\\n      secs += 60;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971907,
                "title": "simple-c-with-explanation-faster-than-100-tc-o-1-sc-o-1",
                "content": "# Intuition\\nAfter looking at few examples it can be easily seen that there will be broadly two possible cases. And we will calculate cost of these two cases and find the minimum of the two. \\n\\n1. Split our seconds to `mm:ss` -> Do this in a strict way  \\n2. If we can add few more seconds to `:ss` part  \\n\\nFor 1st case we just need to calculate how many minutes are there in targetSeconds, and what is the remaining number of seconds. (This is our case-1, but we also need to make sure that minutes does not exceed 99 minutes)\\n\\nFor 2nd case, we need to check if we can add one extra minute (60 seconds) to our current remaining seconds (it should not exceed 99 seconds). \\n\\nOther than these we will not worry about prepending zeros since there is no cost associated with it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Used to calculate the cost to reach from startAt -> val (by updating startAt to val)\\n    int findCost(int &startAt,int moveCost,int pushCost,int val){\\n        int ans = 0;\\n        if(startAt!=val){\\n            ans+=moveCost;\\n        }\\n        ans+=pushCost;\\n        startAt = val;\\n        return ans;\\n    }\\n\\n    // Find cost to reach given minute and second. \\n    int findMinCost(int startAt,int moveCost,int pushCost,int min,int sec){\\n        if(min==0 && sec==0) return 0;\\n        int ans = 0;\\n        int m0 = min%10, m1 = min/10, s0 = sec%10, s1 = sec/10;\\n        // This array helps in avoiding prepending zeros calculation\\n        vector <int> time = {m1,m0,s1,s0};\\n        \\n        int ind = 0;\\n        while(ind<4 && time[ind]==0) ind++;\\n        for(int i=ind;i<4;i++){\\n            ans+=findCost(startAt,moveCost,pushCost,time[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min1 = targetSeconds/60;\\n        int sec1 = targetSeconds%60;\\n        \\n        int min2 = -1, sec2=-1;\\n        if(min1 >=1 && sec1+60 <=99){\\n            min2 = min1-1;\\n            sec2 = sec1+60;\\n        }\\n\\n        int ans = INT_MAX;\\n        if(min1<100)\\n            ans = findMinCost(startAt,moveCost,pushCost,min1,sec1);\\n        if(min2!=-1)\\n            ans = min(ans,findMinCost(startAt,moveCost,pushCost,min2,sec2));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Used to calculate the cost to reach from startAt -> val (by updating startAt to val)\\n    int findCost(int &startAt,int moveCost,int pushCost,int val){\\n        int ans = 0;\\n        if(startAt!=val){\\n            ans+=moveCost;\\n        }\\n        ans+=pushCost;\\n        startAt = val;\\n        return ans;\\n    }\\n\\n    // Find cost to reach given minute and second. \\n    int findMinCost(int startAt,int moveCost,int pushCost,int min,int sec){\\n        if(min==0 && sec==0) return 0;\\n        int ans = 0;\\n        int m0 = min%10, m1 = min/10, s0 = sec%10, s1 = sec/10;\\n        // This array helps in avoiding prepending zeros calculation\\n        vector <int> time = {m1,m0,s1,s0};\\n        \\n        int ind = 0;\\n        while(ind<4 && time[ind]==0) ind++;\\n        for(int i=ind;i<4;i++){\\n            ans+=findCost(startAt,moveCost,pushCost,time[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min1 = targetSeconds/60;\\n        int sec1 = targetSeconds%60;\\n        \\n        int min2 = -1, sec2=-1;\\n        if(min1 >=1 && sec1+60 <=99){\\n            min2 = min1-1;\\n            sec2 = sec1+60;\\n        }\\n\\n        int ans = INT_MAX;\\n        if(min1<100)\\n            ans = findMinCost(startAt,moveCost,pushCost,min1,sec1);\\n        if(min2!=-1)\\n            ans = min(ans,findMinCost(startAt,moveCost,pushCost,min2,sec2));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558644,
                "title": "c-python-solution-with-explanation",
                "content": "First, we can transform targetSeconds into ```minute: second``` where ```second < 60```, another choice is to transform a minute into 60 second,\\n```minute-1: second+60```, and return min cost between two choices.\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        auto cost = [&] (int pos, int minute, int second) {\\n            if (min(minute, second) < 0 || max(minute, second) > 99) return INT_MAX;\\n            int cost = 0;\\n            for (auto ch: to_string(minute * 100 + second)) {\\n                cost += pushCost + (pos != ch - \\'0\\'? moveCost: 0);\\n                pos = ch - \\'0\\';\\n            }\\n            return cost;\\n        };\\n        int m = targetSeconds / 60, s = targetSeconds % 60; \\n        return min(cost(startAt, m, s), cost(startAt, m-1, s+60));\\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def cost(pos, minute, second):\\n            if min(minute, second) < 0 or max(minute, second) > 99: return float(\\'inf\\')\\n            cost = 0\\n            for ch in str(minute * 100 + second):\\n                cost += pushCost + (moveCost if int(ch) != pos else 0)\\n                pos = int(ch)\\n            return cost\\n        minute, second = targetSeconds // 60, targetSeconds % 60\\n        return min(cost(startAt, minute, second), cost(startAt, minute-1, second+60))\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```minute: second```\n```second < 60```\n```minute-1: second+60```\n```cpp\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        auto cost = [&] (int pos, int minute, int second) {\\n            if (min(minute, second) < 0 || max(minute, second) > 99) return INT_MAX;\\n            int cost = 0;\\n            for (auto ch: to_string(minute * 100 + second)) {\\n                cost += pushCost + (pos != ch - \\'0\\'? moveCost: 0);\\n                pos = ch - \\'0\\';\\n            }\\n            return cost;\\n        };\\n        int m = targetSeconds / 60, s = targetSeconds % 60; \\n        return min(cost(startAt, m, s), cost(startAt, m-1, s+60));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def cost(pos, minute, second):\\n            if min(minute, second) < 0 or max(minute, second) > 99: return float(\\'inf\\')\\n            cost = 0\\n            for ch in str(minute * 100 + second):\\n                cost += pushCost + (moveCost if int(ch) != pos else 0)\\n                pos = int(ch)\\n            return cost\\n        minute, second = targetSeconds // 60, targetSeconds % 60\\n        return min(cost(startAt, minute, second), cost(startAt, minute-1, second+60))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529797,
                "title": "0ms-beat-100-tc-o-1-sc-o-1-most-efficient-simplest-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is only one way to format a **standard form** $$mm:ss$$ for a given time duration (the `targetSeconds`), when we specify that $$ss$$ is less than 60.\\n\\nThere might be an **alternative form** when $ss$ of the standard form is less than 40. That is by converting 1 minute to 60 seconds.\\n\\nWe just need to try both forms and find the smallest cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nconstexpr int kFactors[] = {600, 60, 10, 1};\\n\\nclass Solution {\\npublic:\\n  int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    start_at_ = startAt + \\'0\\';\\n    move_cost_ = moveCost;\\n    push_cost_ = pushCost;\\n\\n    // Find the standard form first.\\n    string sequence = \"0000\";\\n    for (int i = 0; i < 4; ++i) {\\n      auto r = std::div(targetSeconds, kFactors[i]);\\n      sequence[i] = r.quot + \\'0\\';\\n      targetSeconds = r.rem;\\n    }\\n    int cost = 10\\'000\\'000;\\n    // Large `targetSeconds` generates bad stardard form,\\n    // for example 6540 => [10 9 0 0]\\n    // In that case only the alternative form below applies.\\n    if (sequence[0] <= \\'9\\') {\\n      cost = CostOf(sequence);\\n    }\\n\\n    // Now we try to use the alternative form.\\n    if (sequence[2] <= \\'3\\') {\\n      sequence[2] += 6;\\n      if (--sequence[1] < \\'0\\') {  // handles carry\\n        sequence[1] += 10;\\n        --sequence[0];\\n      }\\n      if (sequence[0] >= \\'0\\') {  // Validates the form after carry.\\n        cost = min(cost, CostOf(sequence));\\n      }\\n    }\\n    return cost;\\n  }\\n\\n  int CostOf(string_view sequence) const {\\n    int cost = 0;\\n    char d = start_at_;\\n    for (char c : sequence) {\\n      if (c == \\'0\\' && cost == 0) {\\n        // Ignores leading 0s\\n        continue;\\n      }\\n      cost += push_cost_ + (d == c ? 0 : move_cost_);\\n      d = c;\\n    }\\n    // cout << \"cost of [\" << sequence << \"] = \" << cost << endl;\\n    return cost;\\n  }\\n\\n private:\\n  char start_at_;\\n  int move_cost_;\\n  int push_cost_;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconstexpr int kFactors[] = {600, 60, 10, 1};\\n\\nclass Solution {\\npublic:\\n  int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    start_at_ = startAt + \\'0\\';\\n    move_cost_ = moveCost;\\n    push_cost_ = pushCost;\\n\\n    // Find the standard form first.\\n    string sequence = \"0000\";\\n    for (int i = 0; i < 4; ++i) {\\n      auto r = std::div(targetSeconds, kFactors[i]);\\n      sequence[i] = r.quot + \\'0\\';\\n      targetSeconds = r.rem;\\n    }\\n    int cost = 10\\'000\\'000;\\n    // Large `targetSeconds` generates bad stardard form,\\n    // for example 6540 => [10 9 0 0]\\n    // In that case only the alternative form below applies.\\n    if (sequence[0] <= \\'9\\') {\\n      cost = CostOf(sequence);\\n    }\\n\\n    // Now we try to use the alternative form.\\n    if (sequence[2] <= \\'3\\') {\\n      sequence[2] += 6;\\n      if (--sequence[1] < \\'0\\') {  // handles carry\\n        sequence[1] += 10;\\n        --sequence[0];\\n      }\\n      if (sequence[0] >= \\'0\\') {  // Validates the form after carry.\\n        cost = min(cost, CostOf(sequence));\\n      }\\n    }\\n    return cost;\\n  }\\n\\n  int CostOf(string_view sequence) const {\\n    int cost = 0;\\n    char d = start_at_;\\n    for (char c : sequence) {\\n      if (c == \\'0\\' && cost == 0) {\\n        // Ignores leading 0s\\n        continue;\\n      }\\n      cost += push_cost_ + (d == c ? 0 : move_cost_);\\n      d = c;\\n    }\\n    // cout << \"cost of [\" << sequence << \"] = \" << cost << endl;\\n    return cost;\\n  }\\n\\n private:\\n  char start_at_;\\n  int move_cost_;\\n  int push_cost_;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3525622,
                "title": "100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int targetsec=targetSeconds/60;\\n         int time=targetSeconds%60;\\n         if(targetsec==100){\\n            targetsec=targetsec-1;\\n            time+=60;\\n         }\\n         \\n\\n        int mincost=1000000;\\n        int i=2;\\n        while(i>0){\\n            if(targetsec==100){\\n                i--;\\n                continue;\\n            }\\n            int mincost1=0;\\n        if(targetsec==0){\\n           \\n            int moves=0;\\n            int pushes=0;\\n            if(time>=10){\\n                moves=2;\\n            moves-=time/10==startAt?1:0;\\n            moves-=time/10==time%10?1:0;\\n             pushes=2;\\n            }\\n            else{\\n            moves=time%10==startAt?0:1;\\n            pushes=1;\\n            }\\n            \\n                mincost1=pushes*pushCost+moves*moveCost;\\n                if(time>=60){\\n                    targetsec=1;\\n                    time=time%60;\\n\\n                }\\n                else{\\n                    \\n                    i--;\\n                }\\n        }\\n        else if(targetsec>=1){\\n            \\n            int moves=0;\\n            int pushes=0;\\n            if(targetsec>=10){\\n                moves=4;\\n            }\\n            else{\\n                moves=3;\\n            }\\n                if(targetsec<10){\\n                    moves-=targetsec==startAt?1:0;\\n                }\\n                else{\\n                    moves-=targetsec/10==startAt?1:0;\\n                    moves-=targetsec/10==targetsec%10?1:0;\\n                }\\n                \\n                if(time<10){\\n                    moves-=targetsec%10==0?1:0;\\n                    moves-=time==0?1:0;\\n                }\\n                else{\\n               moves-=targetsec%10==time/10?1:0;\\n                moves-=time/10==time%10?1:0;\\n                }\\n\\n                pushes=targetsec<10?3:4;\\n            if(time<=39){\\n               \\n                targetsec-=1;\\n                time=time+60;\\n            }\\n            else if(time>=60){\\n                targetsec+=1;\\n                time=time-60;\\n            }\\n            else{\\n                i--;\\n            }\\n            \\n             mincost1=pushes*pushCost+moves*moveCost;\\n             \\n        }\\n        mincost=Math.min(mincost,mincost1);\\n        i--;\\n        }\\n        return mincost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int targetsec=targetSeconds/60;\\n         int time=targetSeconds%60;\\n         if(targetsec==100){\\n            targetsec=targetsec-1;\\n            time+=60;\\n         }\\n         \\n\\n        int mincost=1000000;\\n        int i=2;\\n        while(i>0){\\n            if(targetsec==100){\\n                i--;\\n                continue;\\n            }\\n            int mincost1=0;\\n        if(targetsec==0){\\n           \\n            int moves=0;\\n            int pushes=0;\\n            if(time>=10){\\n                moves=2;\\n            moves-=time/10==startAt?1:0;\\n            moves-=time/10==time%10?1:0;\\n             pushes=2;\\n            }\\n            else{\\n            moves=time%10==startAt?0:1;\\n            pushes=1;\\n            }\\n            \\n                mincost1=pushes*pushCost+moves*moveCost;\\n                if(time>=60){\\n                    targetsec=1;\\n                    time=time%60;\\n\\n                }\\n                else{\\n                    \\n                    i--;\\n                }\\n        }\\n        else if(targetsec>=1){\\n            \\n            int moves=0;\\n            int pushes=0;\\n            if(targetsec>=10){\\n                moves=4;\\n            }\\n            else{\\n                moves=3;\\n            }\\n                if(targetsec<10){\\n                    moves-=targetsec==startAt?1:0;\\n                }\\n                else{\\n                    moves-=targetsec/10==startAt?1:0;\\n                    moves-=targetsec/10==targetsec%10?1:0;\\n                }\\n                \\n                if(time<10){\\n                    moves-=targetsec%10==0?1:0;\\n                    moves-=time==0?1:0;\\n                }\\n                else{\\n               moves-=targetsec%10==time/10?1:0;\\n                moves-=time/10==time%10?1:0;\\n                }\\n\\n                pushes=targetsec<10?3:4;\\n            if(time<=39){\\n               \\n                targetsec-=1;\\n                time=time+60;\\n            }\\n            else if(time>=60){\\n                targetsec+=1;\\n                time=time-60;\\n            }\\n            else{\\n                i--;\\n            }\\n            \\n             mincost1=pushes*pushCost+moves*moveCost;\\n             \\n        }\\n        mincost=Math.min(mincost,mincost1);\\n        i--;\\n        }\\n        return mincost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433559,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n private:\\n  static constexpr int seconds_per_minute = 60;\\n  static constexpr int base = 10;\\n  static constexpr int upper = 99;\\n  \\n public:\\n  int minCostSetTime(const int startAt,\\n                     const int moveCost,\\n                     const int pushCost,\\n                     const int targetSeconds) {\\n    const int minutes = targetSeconds / seconds_per_minute;\\n    const int seconds = targetSeconds % seconds_per_minute;\\n    int ret = get_cost(startAt, moveCost, pushCost, minutes, seconds);\\n    if (minutes > 0 && seconds + seconds_per_minute <= upper) {\\n      ret = min(ret, get_cost(startAt, moveCost, pushCost, minutes - 1, seconds + seconds_per_minute));\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_cost(const int start,\\n               const int move_cost,\\n               const int push_cost,\\n               const int minutes,\\n               const int seconds) {\\n    if (minutes > upper) {\\n      return numeric_limits<int>::max();\\n    }\\n\\n    int ret = 0;\\n    int previous = start;\\n    bool leading_zero = true;\\n    for (const int digit : {minutes / base,\\n                            minutes % base,\\n                            seconds / base,\\n                            seconds % base}) {\\n      if (leading_zero && digit == 0) {\\n        // ignore the leading zeros\\n        continue;\\n      }\\n      \\n      leading_zero = false;\\n      ret += (previous != digit ? move_cost : 0) + push_cost;\\n      previous = digit;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  static constexpr int seconds_per_minute = 60;\\n  static constexpr int base = 10;\\n  static constexpr int upper = 99;\\n  \\n public:\\n  int minCostSetTime(const int startAt,\\n                     const int moveCost,\\n                     const int pushCost,\\n                     const int targetSeconds) {\\n    const int minutes = targetSeconds / seconds_per_minute;\\n    const int seconds = targetSeconds % seconds_per_minute;\\n    int ret = get_cost(startAt, moveCost, pushCost, minutes, seconds);\\n    if (minutes > 0 && seconds + seconds_per_minute <= upper) {\\n      ret = min(ret, get_cost(startAt, moveCost, pushCost, minutes - 1, seconds + seconds_per_minute));\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_cost(const int start,\\n               const int move_cost,\\n               const int push_cost,\\n               const int minutes,\\n               const int seconds) {\\n    if (minutes > upper) {\\n      return numeric_limits<int>::max();\\n    }\\n\\n    int ret = 0;\\n    int previous = start;\\n    bool leading_zero = true;\\n    for (const int digit : {minutes / base,\\n                            minutes % base,\\n                            seconds / base,\\n                            seconds % base}) {\\n      if (leading_zero && digit == 0) {\\n        // ignore the leading zeros\\n        continue;\\n      }\\n      \\n      leading_zero = false;\\n      ret += (previous != digit ? move_cost : 0) + push_cost;\\n      previous = digit;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381103,
                "title": "step-by-step-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        vector<int> seconds;\\n\\n        int i=0;\\n        while((targetSeconds-(i*60))>=0){\\n            if((targetSeconds-(i*60))<100 && ((i*100)+(targetSeconds-(i*60)))<=9999){\\n                seconds.push_back((i*100)+(targetSeconds-(i*60)));\\n            }\\n            i++;\\n        }\\n\\n        int count=INT_MAX;\\n        for(auto val:seconds){\\n            int start=startAt;\\n            vector<int> number;\\n            while(val>0){\\n                number.push_back(val%10);\\n                val=val/10;\\n            }\\n            int countTemp = 0;\\n            for(int i=number.size()-1;i>=0;i--){\\n                if(start!=number[i]){\\n                    start=number[i];\\n                    countTemp+=moveCost;\\n                }\\n                countTemp+=pushCost;\\n            }\\n            if(count>countTemp){\\n                count=countTemp;\\n            }\\n        }\\n\\n\\n\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        vector<int> seconds;\\n\\n        int i=0;\\n        while((targetSeconds-(i*60))>=0){\\n            if((targetSeconds-(i*60))<100 && ((i*100)+(targetSeconds-(i*60)))<=9999){\\n                seconds.push_back((i*100)+(targetSeconds-(i*60)));\\n            }\\n            i++;\\n        }\\n\\n        int count=INT_MAX;\\n        for(auto val:seconds){\\n            int start=startAt;\\n            vector<int> number;\\n            while(val>0){\\n                number.push_back(val%10);\\n                val=val/10;\\n            }\\n            int countTemp = 0;\\n            for(int i=number.size()-1;i>=0;i--){\\n                if(start!=number[i]){\\n                    start=number[i];\\n                    countTemp+=moveCost;\\n                }\\n                countTemp+=pushCost;\\n            }\\n            if(count>countTemp){\\n                count=countTemp;\\n            }\\n        }\\n\\n\\n\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358654,
                "title": "c-very-easy-solution-beat-100-o-1",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        int min = target/60;\\n        int sec = target%60;\\n        int flag = 0;\\n        string s1 =\"\";\\n        if( min>0 )\\n        {\\n            if( min>99)\\n            {\\n                s1 = to_string( min-1 ) + to_string( sec+60 );\\n                flag = 1;\\n            }\\n            else if( sec>9 )\\n            {\\n                s1 = to_string( min ) + to_string( sec );\\n            }\\n            else\\n            {\\n                s1 = to_string( min ) + \\'0\\' + to_string( sec );\\n            }\\n        }\\n        else\\n        {\\n            s1 =to_string( sec );\\n        }\\n        //cout<<s1<<endl;\\n        string s2 = \"\";\\n        if( min>0 && (sec + 60)<=99 && flag==0)\\n        {\\n            if( min-1 > 0 )\\n            {\\n                s2 = to_string( min-1 ) + to_string( sec+60 );\\n            }\\n            else\\n            {\\n                s2 = to_string( sec+60 );\\n            }\\n        }\\n        else\\n        {\\n            flag=1;\\n        }\\n        //cout<<s2<<endl;\\n        int count = 0;\\n        int n=s1.size();\\n        if( startAt == (int(s1[0])-48) )\\n        {\\n            count = count + pushCost;\\n        }\\n        else\\n        {\\n            count = count + pushCost + moveCost;\\n        }\\n        for( int i=1 ; i<n ; i++ )\\n        {\\n            if( s1[i] == s1[i-1] )\\n            {\\n                count = count + pushCost;\\n            }\\n            else\\n            {\\n                count = count + pushCost + moveCost;\\n            }\\n        }\\n        if( flag==1 )\\n        {\\n            return count;\\n        }\\n        int count2 = 0;\\n        int m=s2.size();\\n        if( startAt == (int(s2[0])-48) )\\n        {\\n            count2 = count2 + pushCost;\\n        }\\n        else\\n        {\\n            count2 = count2 + pushCost + moveCost;\\n        }\\n        for( int i=1 ; i<m ; i++ )\\n        {\\n            if( s2[i] == s2[i-1] )\\n            {\\n                count2 = count2 + pushCost;\\n            }\\n            else\\n            {\\n                count2 = count2 + pushCost + moveCost;\\n            }\\n        }\\n        if( count>count2 )\\n        {\\n            return count2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        int min = target/60;\\n        int sec = target%60;\\n        int flag = 0;\\n        string s1 =\"\";\\n        if( min>0 )\\n        {\\n            if( min>99)\\n            {\\n                s1 = to_string( min-1 ) + to_string( sec+60 );\\n                flag = 1;\\n            }\\n            else if( sec>9 )\\n            {\\n                s1 = to_string( min ) + to_string( sec );\\n            }\\n            else\\n            {\\n                s1 = to_string( min ) + \\'0\\' + to_string( sec );\\n            }\\n        }\\n        else\\n        {\\n            s1 =to_string( sec );\\n        }\\n        //cout<<s1<<endl;\\n        string s2 = \"\";\\n        if( min>0 && (sec + 60)<=99 && flag==0)\\n        {\\n            if( min-1 > 0 )\\n            {\\n                s2 = to_string( min-1 ) + to_string( sec+60 );\\n            }\\n            else\\n            {\\n                s2 = to_string( sec+60 );\\n            }\\n        }\\n        else\\n        {\\n            flag=1;\\n        }\\n        //cout<<s2<<endl;\\n        int count = 0;\\n        int n=s1.size();\\n        if( startAt == (int(s1[0])-48) )\\n        {\\n            count = count + pushCost;\\n        }\\n        else\\n        {\\n            count = count + pushCost + moveCost;\\n        }\\n        for( int i=1 ; i<n ; i++ )\\n        {\\n            if( s1[i] == s1[i-1] )\\n            {\\n                count = count + pushCost;\\n            }\\n            else\\n            {\\n                count = count + pushCost + moveCost;\\n            }\\n        }\\n        if( flag==1 )\\n        {\\n            return count;\\n        }\\n        int count2 = 0;\\n        int m=s2.size();\\n        if( startAt == (int(s2[0])-48) )\\n        {\\n            count2 = count2 + pushCost;\\n        }\\n        else\\n        {\\n            count2 = count2 + pushCost + moveCost;\\n        }\\n        for( int i=1 ; i<m ; i++ )\\n        {\\n            if( s2[i] == s2[i-1] )\\n            {\\n                count2 = count2 + pushCost;\\n            }\\n            else\\n            {\\n                count2 = count2 + pushCost + moveCost;\\n            }\\n        }\\n        if( count>count2 )\\n        {\\n            return count2;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3294605,
                "title": "simple-solution-o-1",
                "content": "here only two timing are needed to evalaute \\nfirst: -   a = targetSeconds /60 minutes , b = targetSeconds %60 seccond;\\nsecond:-  c = a>=1?a-1:a ,   d = a>=1?b+60:b      ternary operator used here\\nthen find the operaton for both and take minimum\\n```\\nclass Solution {\\n    public int minCostSetTime(int s, int m, int p, int t) {\\n        int output = Integer.MAX_VALUE;\\n        int a = t/60,b = t%60, c = a>=1?a-1:a , d = a>=1?b+60:b;\\n        String s1=Integer.toString(a),s2=Integer.toString(b), s3=Integer.toString(c),s4=Integer.toString(d);\\n        s1 = a>9?s1:\"0\"+s1;s2 = b>9?s2:\"0\"+s2;s3 = c>9?s3:\"0\"+s3;s4 = d>9?s4:\"0\"+s4;\\n        String op = s1+s2,yo = s3+s4;\\n        char ch[] = op.toCharArray(),ck[] = yo.toCharArray();\\n        int cal = 0,tot=0; boolean check = false;\\n        if(op.length()<5){for(int i=0;i<4;i++){\\n            if((ch[i]-\\'0\\')>0) check = true;\\n            if(check) cal += (((cal==0?s:(ch[i-1]-\\'0\\'))-(ch[i]-\\'0\\'))!=0?m:0)+p;\\n            \\n        }\\n        check = false;output = Math.min(output,cal);}\\n        if(yo.length()<5) { for(int i=0;i<4;i++){\\n            if((ck[i]-\\'0\\')>0) check = true;\\n            if(check) tot += (((tot==0?s:(ck[i-1]-\\'0\\'))-(ck[i]-\\'0\\'))!=0?m:0)+p; \\n            \\n        }\\n        output = Math.min(output,tot);}\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minCostSetTime(int s, int m, int p, int t) {\\n        int output = Integer.MAX_VALUE;\\n        int a = t/60,b = t%60, c = a>=1?a-1:a , d = a>=1?b+60:b;\\n        String s1=Integer.toString(a),s2=Integer.toString(b), s3=Integer.toString(c),s4=Integer.toString(d);\\n        s1 = a>9?s1:\"0\"+s1;s2 = b>9?s2:\"0\"+s2;s3 = c>9?s3:\"0\"+s3;s4 = d>9?s4:\"0\"+s4;\\n        String op = s1+s2,yo = s3+s4;\\n        char ch[] = op.toCharArray(),ck[] = yo.toCharArray();\\n        int cal = 0,tot=0; boolean check = false;\\n        if(op.length()<5){for(int i=0;i<4;i++){\\n            if((ch[i]-\\'0\\')>0) check = true;\\n            if(check) cal += (((cal==0?s:(ch[i-1]-\\'0\\'))-(ch[i]-\\'0\\'))!=0?m:0)+p;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3256046,
                "title": "js-javascript-simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} startAt\\n * @param {number} moveCost\\n * @param {number} pushCost\\n * @param {number} targetSeconds\\n * @return {number}\\n */\\nvar minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let min = Math.trunc(targetSeconds / 60)   \\n    let sec = targetSeconds % 60\\n    let minRes = Infinity \\n    if (min <= 99) check(min, sec)\\n    if (min > 0 && sec <= 39 && min <= 100) check(min - 1, sec + 60)\\n    return minRes\\n\\n    function check(min, sec){\\n        let str = (min === 0 ? \"\" : String(min)) + (min === 0 ? String(sec) : String(sec).padStart(2, \\'0\\'))\\n        let currentRes = 0\\n        let newStart = startAt\\n        for (let i = 0; i < str.length; i++){\\n            if (newStart != str[i]){\\n                newStart = +str[i]\\n                currentRes += moveCost\\n            } \\n            currentRes += pushCost\\n        }\\n        minRes = Math.min(currentRes, minRes)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} startAt\\n * @param {number} moveCost\\n * @param {number} pushCost\\n * @param {number} targetSeconds\\n * @return {number}\\n */\\nvar minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {\\n    let min = Math.trunc(targetSeconds / 60)   \\n    let sec = targetSeconds % 60\\n    let minRes = Infinity \\n    if (min <= 99) check(min, sec)\\n    if (min > 0 && sec <= 39 && min <= 100) check(min - 1, sec + 60)\\n    return minRes\\n\\n    function check(min, sec){\\n        let str = (min === 0 ? \"\" : String(min)) + (min === 0 ? String(sec) : String(sec).padStart(2, \\'0\\'))\\n        let currentRes = 0\\n        let newStart = startAt\\n        for (let i = 0; i < str.length; i++){\\n            if (newStart != str[i]){\\n                newStart = +str[i]\\n                currentRes += moveCost\\n            } \\n            currentRes += pushCost\\n        }\\n        minRes = Math.min(currentRes, minRes)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3255557,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):\\n        mins, secs = divmod(targetSeconds,60)\\n\\n        def cost(m,s):\\n            ans = (moveCost + pushCost)*4\\n\\n            if 0 <= m < 100  and 0 <= s < 100:\\n                str1 = str(startAt) + str(100*m + s)\\n                ans = sum(pushCost + moveCost*(str1[i] != str1[i+1]) for i in range(len(str1)-1))\\n\\n            return ans\\n\\n        return min(cost(mins,secs),cost(mins-1,secs+60))\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):\\n        mins, secs = divmod(targetSeconds,60)\\n\\n        def cost(m,s):\\n            ans = (moveCost + pushCost)*4\\n\\n            if 0 <= m < 100  and 0 <= s < 100:\\n                str1 = str(startAt) + str(100*m + s)\\n                ans = sum(pushCost + moveCost*(str1[i] != str1[i+1]) for i in range(len(str1)-1))\\n\\n            return ans\\n\\n        return min(cost(mins,secs),cost(mins-1,secs+60))\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255121,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_cost_set_time(start_at: i32, move_cost: i32, push_cost: i32, target_seconds: i32) -> i32 {\\n        let cost = |mut pos: i32, m: i32, s: i32| {\\n            if m.min(s) < 0 || m.max(s) > 99 {\\n                return i32::MAX;\\n            }\\n            let mut res = 0;\\n            let s_v = format!(\"{}\", m * 100 + s);\\n            for digit in s_v.chars() {\\n                let idx = digit as i32 - \\'0\\' as i32;\\n                res += push_cost + (if pos == idx { 0 } else { move_cost });\\n                pos = idx;\\n            }\\n            res\\n        };\\n        let m = target_seconds / 60;\\n        let s = target_seconds % 60;\\n        cost(start_at, m, s).min(cost(start_at, m - 1, s + 60))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost_set_time(start_at: i32, move_cost: i32, push_cost: i32, target_seconds: i32) -> i32 {\\n        let cost = |mut pos: i32, m: i32, s: i32| {\\n            if m.min(s) < 0 || m.max(s) > 99 {\\n                return i32::MAX;\\n            }\\n            let mut res = 0;\\n            let s_v = format!(\"{}\", m * 100 + s);\\n            for digit in s_v.chars() {\\n                let idx = digit as i32 - \\'0\\' as i32;\\n                res += push_cost + (if pos == idx { 0 } else { move_cost });\\n                pos = idx;\\n            }\\n            res\\n        };\\n        let m = target_seconds / 60;\\n        let s = target_seconds % 60;\\n        cost(start_at, m, s).min(cost(start_at, m - 1, s + 60))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158279,
                "title": "python-simple-solution",
                "content": "```\\ndef minCostSetTime(self, sta: int, mcost: int, pcost: int, tar: int) -> int:\\n\\tmins, secs = divmod(tar, 60)\\n\\tdef cost(m, s):\\n\\t\\tans = (mcost+pcost)*4\\n\\t\\tif 0<=m<100 and 0<=s<100:\\n\\t\\t\\tts = str(sta)+str(m*100+s)\\n\\t\\t\\tans = sum(pcost+mcost*(ts[i]!=ts[i+1]) for i in range(len(ts)-1))\\n\\t\\treturn ans\\n\\treturn min(cost(mins, secs), cost(mins-1, secs+60))\\n```",
                "solutionTags": [],
                "code": "```\\ndef minCostSetTime(self, sta: int, mcost: int, pcost: int, tar: int) -> int:\\n\\tmins, secs = divmod(tar, 60)\\n\\tdef cost(m, s):\\n\\t\\tans = (mcost+pcost)*4\\n\\t\\tif 0<=m<100 and 0<=s<100:\\n\\t\\t\\tts = str(sta)+str(m*100+s)\\n\\t\\t\\tans = sum(pcost+mcost*(ts[i]!=ts[i+1]) for i in range(len(ts)-1))\\n\\t\\treturn ans\\n\\treturn min(cost(mins, secs), cost(mins-1, secs+60))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3025794,
                "title": "python-o-1-many-if-cases",
                "content": "\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        if targetSeconds < 10:\\n            if targetSeconds == startAt:\\n                return pushCost\\n            else:\\n                return pushCost + moveCost\\n        elif targetSeconds < 60:\\n            n1 = targetSeconds // 10\\n            n2 = targetSeconds % 10\\n            a1 = self.minCostSetTime(startAt, moveCost, pushCost, n1)\\n            a2 = self.minCostSetTime(n1, moveCost, pushCost, n2)\\n            return a1 + a2\\n        else:\\n            # option 1\\n            mm = targetSeconds // 60\\n            ss = targetSeconds % 60\\n            n1 = mm // 10\\n            n2 = mm % 10\\n            s1 = ss // 10\\n            s2 = ss % 10\\n            ans1 = 0\\n            if n1 > 0:\\n                ans1 += self.minCostSetTime(startAt, moveCost, pushCost, n1)\\n                ans1 += self.minCostSetTime(n1, moveCost, pushCost, n2)\\n            else:\\n                ans1 += self.minCostSetTime(startAt, moveCost, pushCost, n2)\\n            ans1 += self.minCostSetTime(n2, moveCost, pushCost, s1)\\n            ans1 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            # option 2\\n            if ss > 39:\\n                return ans1\\n            mm -= 1\\n            ss += 60\\n            n1 = mm // 10\\n            n2 = mm % 10\\n            s1 = ss // 10\\n            s2 = ss % 10\\n            ans2 = 0\\n            if n1 > 0:\\n                ans2 += self.minCostSetTime(startAt, moveCost, pushCost, n1)\\n                ans2 += self.minCostSetTime(n1, moveCost, pushCost, n2)\\n                ans2 += self.minCostSetTime(n2, moveCost, pushCost, s1)\\n                ans2 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            elif n2 > 0:\\n                ans2 += self.minCostSetTime(startAt, moveCost, pushCost, n2)\\n                ans2 += self.minCostSetTime(n2, moveCost, pushCost, s1)\\n                ans2 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            else:\\n                ans2 += self.minCostSetTime(startAt, moveCost, pushCost, s1)\\n                ans2 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            \\n            return min(ans1, ans2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        if targetSeconds < 10:\\n            if targetSeconds == startAt:\\n                return pushCost\\n            else:\\n                return pushCost + moveCost\\n        elif targetSeconds < 60:\\n            n1 = targetSeconds // 10\\n            n2 = targetSeconds % 10\\n            a1 = self.minCostSetTime(startAt, moveCost, pushCost, n1)\\n            a2 = self.minCostSetTime(n1, moveCost, pushCost, n2)\\n            return a1 + a2\\n        else:\\n            # option 1\\n            mm = targetSeconds // 60\\n            ss = targetSeconds % 60\\n            n1 = mm // 10\\n            n2 = mm % 10\\n            s1 = ss // 10\\n            s2 = ss % 10\\n            ans1 = 0\\n            if n1 > 0:\\n                ans1 += self.minCostSetTime(startAt, moveCost, pushCost, n1)\\n                ans1 += self.minCostSetTime(n1, moveCost, pushCost, n2)\\n            else:\\n                ans1 += self.minCostSetTime(startAt, moveCost, pushCost, n2)\\n            ans1 += self.minCostSetTime(n2, moveCost, pushCost, s1)\\n            ans1 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            # option 2\\n            if ss > 39:\\n                return ans1\\n            mm -= 1\\n            ss += 60\\n            n1 = mm // 10\\n            n2 = mm % 10\\n            s1 = ss // 10\\n            s2 = ss % 10\\n            ans2 = 0\\n            if n1 > 0:\\n                ans2 += self.minCostSetTime(startAt, moveCost, pushCost, n1)\\n                ans2 += self.minCostSetTime(n1, moveCost, pushCost, n2)\\n                ans2 += self.minCostSetTime(n2, moveCost, pushCost, s1)\\n                ans2 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            elif n2 > 0:\\n                ans2 += self.minCostSetTime(startAt, moveCost, pushCost, n2)\\n                ans2 += self.minCostSetTime(n2, moveCost, pushCost, s1)\\n                ans2 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            else:\\n                ans2 += self.minCostSetTime(startAt, moveCost, pushCost, s1)\\n                ans2 += self.minCostSetTime(s1, moveCost, pushCost, s2)\\n            \\n            return min(ans1, ans2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985827,
                "title": "swift-brute-force",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minCostSetTime(_ startAt: Int, _ moveCost: Int, _ pushCost: Int, _ targetSeconds: Int) -> Int {\\n        var minCost = Int.max\\n        var maxMinute = targetSeconds/60\\n        for i in 0...maxMinute {\\n            var second = targetSeconds - i * 60\\n            if second > 99 || i > 99 {\\n                continue\\n            }\\n            let targetTime = String(i * 100 + second)\\n            let localCost = getProcessTime(Array(targetTime), startAt, moveCost, pushCost)\\n            minCost = min(minCost, localCost)\\n        }\\n        return minCost\\n    }\\n\\n    func getProcessTime(_ targetInput: [Character], _ startAt: Int, _ moveCost: Int, _ pushCost: Int) -> Int {\\n        var cost = 0\\n        var current = startAt\\n        for input in targetInput {\\n            if let inputNum = Int(String(input)) {\\n                if inputNum == current {\\n                    cost += pushCost\\n                } else {\\n                    cost += (pushCost + moveCost)\\n                    current = inputNum\\n                }\\n            }\\n        }\\n        return cost\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minCostSetTime(_ startAt: Int, _ moveCost: Int, _ pushCost: Int, _ targetSeconds: Int) -> Int {\\n        var minCost = Int.max\\n        var maxMinute = targetSeconds/60\\n        for i in 0...maxMinute {\\n            var second = targetSeconds - i * 60\\n            if second > 99 || i > 99 {\\n                continue\\n            }\\n            let targetTime = String(i * 100 + second)\\n            let localCost = getProcessTime(Array(targetTime), startAt, moveCost, pushCost)\\n            minCost = min(minCost, localCost)\\n        }\\n        return minCost\\n    }\\n\\n    func getProcessTime(_ targetInput: [Character], _ startAt: Int, _ moveCost: Int, _ pushCost: Int) -> Int {\\n        var cost = 0\\n        var current = startAt\\n        for input in targetInput {\\n            if let inputNum = Int(String(input)) {\\n                if inputNum == current {\\n                    cost += pushCost\\n                } else {\\n                    cost += (pushCost + moveCost)\\n                    current = inputNum\\n                }\\n            }\\n        }\\n        return cost\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958712,
                "title": "beats-80-for-python-submissions-pretty-much-bruteforce",
                "content": "\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        self.res = 2**31\\n        self.f(startAt, moveCost, pushCost,targetSeconds)\\n        return self.res\\n    def cost (self,startAt, moveCost, pushCost, s):\\n        total = 0 \\n        if s[0]==str(startAt):total +=pushCost \\n        elif s[0]!=startAt:total +=pushCost + moveCost \\n        for i in range(1,len(s)):\\n            if s[i]==s[i-1]:total +=pushCost \\n            else:total +=pushCost + moveCost \\n        return total \\n    def f(self,startAt, moveCost, pushCost, seconds):\\n        if seconds <=10:\\n            res = str(seconds)\\n            self.res = min(self.res,self.cost(startAt,moveCost,pushCost,res))\\n        else:\\n            for i in range(0,100):\\n                res = \\'\\'\\n                remaining= seconds - (i * 60) \\n                if 0<=remaining<100:\\n                    if i!=0:res +=str(i)\\n                    if remaining==0:res +=\\'00\\'\\n                    elif 0<remaining < 10 : res +=\\'0\\'+str(remaining )\\n                    elif remaining >=10 : res +=str(remaining)\\n                    self.res = min(self.res,self.cost(startAt,moveCost,pushCost,res))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        self.res = 2**31\\n        self.f(startAt, moveCost, pushCost,targetSeconds)\\n        return self.res\\n    def cost (self,startAt, moveCost, pushCost, s):\\n        total = 0 \\n        if s[0]==str(startAt):total +=pushCost \\n        elif s[0]!=startAt:total +=pushCost + moveCost \\n        for i in range(1,len(s)):\\n            if s[i]==s[i-1]:total +=pushCost \\n            else:total +=pushCost + moveCost \\n        return total \\n    def f(self,startAt, moveCost, pushCost, seconds):\\n        if seconds <=10:\\n            res = str(seconds)\\n            self.res = min(self.res,self.cost(startAt,moveCost,pushCost,res))\\n        else:\\n            for i in range(0,100):\\n                res = \\'\\'\\n                remaining= seconds - (i * 60) \\n                if 0<=remaining<100:\\n                    if i!=0:res +=str(i)\\n                    if remaining==0:res +=\\'00\\'\\n                    elif 0<remaining < 10 : res +=\\'0\\'+str(remaining )\\n                    elif remaining >=10 : res +=str(remaining)\\n                    self.res = min(self.res,self.cost(startAt,moveCost,pushCost,res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877633,
                "title": "java-solution-o-1",
                "content": "```\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int seconds = targetSeconds;\\n        int minutes = 0;\\n        if(seconds > 99) {\\n            int minNeed = (seconds - 99) / 60;\\n            if((seconds - 99) % 60 != 0) {\\n                minNeed++;\\n            }\\n            seconds = seconds - minNeed * 60;\\n            minutes = minNeed;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        while (seconds >= 0 && minutes <= 99) {\\n            int val = minutes * 100 + seconds;\\n            res = Math.min(res, getCost(startAt, val, moveCost, pushCost));\\n            seconds -= 60;\\n            minutes++;\\n        }\\n        return res;\\n    }\\n    \\n    private int getCost(int startAt, int val, int moveCost, int pushCost) {\\n        int last = startAt;\\n        int filled = 0;\\n        int cost = 0;\\n        for (int pos = 3; pos >= 0; pos--) {\\n            int num = (int) (val / Math.pow(10, pos));\\n            if(num == 0 && filled == 0) continue;\\n            val -= num * Math.pow(10, pos);\\n            if(num != last) {\\n                cost += moveCost; \\n                last = num;\\n            }\\n            if (num > 0) {\\n                filled = Math.max(filled, pos + 1);\\n            }\\n        }\\n        return cost + filled * pushCost;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int seconds = targetSeconds;\\n        int minutes = 0;\\n        if(seconds > 99) {\\n            int minNeed = (seconds - 99) / 60;\\n            if((seconds - 99) % 60 != 0) {\\n                minNeed++;\\n            }\\n            seconds = seconds - minNeed * 60;\\n            minutes = minNeed;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        while (seconds >= 0 && minutes <= 99) {\\n            int val = minutes * 100 + seconds;\\n            res = Math.min(res, getCost(startAt, val, moveCost, pushCost));\\n            seconds -= 60;\\n            minutes++;\\n        }\\n        return res;\\n    }\\n    \\n    private int getCost(int startAt, int val, int moveCost, int pushCost) {\\n        int last = startAt;\\n        int filled = 0;\\n        int cost = 0;\\n        for (int pos = 3; pos >= 0; pos--) {\\n            int num = (int) (val / Math.pow(10, pos));\\n            if(num == 0 && filled == 0) continue;\\n            val -= num * Math.pow(10, pos);\\n            if(num != last) {\\n                cost += moveCost; \\n                last = num;\\n            }\\n            if (num > 0) {\\n                filled = Math.max(filled, pos + 1);\\n            }\\n        }\\n        return cost + filled * pushCost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751627,
                "title": "python-straightforward-solution-with-comment-explanation",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        times, m, s = [], 0, targetSeconds\\n        while s >= 0:\\n            # If the minutes and the seconds are in the correct range, add it\\n            # with left zero padding.\\n            if 0 <= m <= 99 and 0 <= s <= 99:\\n                interpreted = f\"{m:0>2d}{s:0>2d}\"\\n                \\n                # Try any number of leading zeros of the interpreted times.\\n                while interpreted[0] == \\'0\\':\\n                    times.append(f\"{startAt}{interpreted}\")\\n                    interpreted = interpreted[1:]\\n                times.append(f\"{startAt}{interpreted}\")\\n            m += 1\\n            s -= 60\\n            \\n        ans = float(\\'inf\\')\\n        for t in times:\\n            curCost = 0\\n            for i in range(len(t) - 1):\\n                # If we have two different consecutive numbers, increment cost\\n                # by moveCost.\\n                if t[i] != t[i + 1]: curCost += moveCost\\n                curCost += pushCost\\n            \\n            # Update the answer with fewer costs.\\n            ans = min(ans, curCost)\\n        return ans  \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        times, m, s = [], 0, targetSeconds\\n        while s >= 0:\\n            # If the minutes and the seconds are in the correct range, add it\\n            # with left zero padding.\\n            if 0 <= m <= 99 and 0 <= s <= 99:\\n                interpreted = f\"{m:0>2d}{s:0>2d}\"\\n                \\n                # Try any number of leading zeros of the interpreted times.\\n                while interpreted[0] == \\'0\\':\\n                    times.append(f\"{startAt}{interpreted}\")\\n                    interpreted = interpreted[1:]\\n                times.append(f\"{startAt}{interpreted}\")\\n            m += 1\\n            s -= 60\\n            \\n        ans = float(\\'inf\\')\\n        for t in times:\\n            curCost = 0\\n            for i in range(len(t) - 1):\\n                # If we have two different consecutive numbers, increment cost\\n                # by moveCost.\\n                if t[i] != t[i + 1]: curCost += moveCost\\n                curCost += pushCost\\n            \\n            # Update the answer with fewer costs.\\n            ans = min(ans, curCost)\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655313,
                "title": "dead-simple-o-1",
                "content": "So I could not solve this question by my own first and had to look at the discuss answers, which I improved upon to O(1).\\nOriginal brute-force solution: https://leetcode.com/problems/minimum-cost-to-set-cooking-time/discuss/1746996/Simple-Python-Solution\\n\\nHere is optimal solution:\\nThe core idea is that we have a **function that calculates cost given two parameters: minutes and seconds.**\\nAfter that we just need to run all possible configurations of minutes and seconds (derived from given targetSeconds) through this function.\\n\\n**Step 1. Create all possible configurations of minutes and seconds from targetSeconds.**\\nThere are always either 1 or 2 configurations of any targetSeconds.\\n\\ne.g. 231 seconds can only be represented as 3 minutes and 51 seconds (3:51). It has only one configuration because the seconds part is bigger than 39 (the maximum value of seconds is 99, so 60 + 39).\\ne.g. 197 seconds can be represented as: 2:77 or 3:17. This has two configurations because 3:17 is less than 39. So we can subtract one minute from 3 and add 60 to 17 => resulting in 2:77.\\n\\n```\\n    def create_configs(targetSeconds):\\n        res = []\\n        minutes = targetSeconds // 60\\n        seconds = targetSeconds % 60\\n        if 0 <= minutes < 100: # here is it important to avoid 100 minutes since max value is 99.\\n            res.append((minutes, seconds))\\n        if seconds < 40:\\n            minutes = minutes - 1\\n            seconds += 60\\n            if 0 <= minutes < 100: # avoiding minutes being less than 0\\n                res.append((minutes, seconds))\\n\\n        return res\\n```\\n\\n**Step 2. Calculate cost of created configurations**\\nWe calculating cost as follows:\\n- remove pending zeroes\\n- convert minutes and seconds to list with separate digits. e.g. 7:55 becomes [7,5,5]\\n- iterate over list left to right\\n- if current position is not the same as in list -> move (increment cost of moving)\\n- push the digit (increment cost of pushing)\\n\\n```\\n    def calc_cost(minutes, seconds, startAt, pushCost, moveCost) -> int:\\n        full_form = f\"{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}\"\\n        full_form = full_form.lstrip(\"0\")\\n\\n        li = [int(x) for x in full_form]\\n        cost = 0\\n        current = startAt\\n        for num in li:\\n            if num != current:\\n                cost += moveCost\\n                current = num\\n            cost += pushCost\\n\\n        return cost\\n```\\n\\n\\n**Overall solution:**\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n\\n        min_cost = float(\"inf\")\\n        li = self.create_configs(targetSeconds)\\n        for minutes, seconds in li:\\n            min_cost = min(min_cost, self.calc_cost(minutes, seconds, startAt, pushCost, moveCost))\\n\\n        return min_cost\\n\\n    def create_configs(self, targetSeconds):\\n        res = []\\n        minutes = targetSeconds // 60\\n        seconds = targetSeconds % 60\\n        if 0 <= minutes < 100:\\n            res.append((minutes, seconds))\\n        if seconds < 40:\\n            minutes = minutes - 1\\n            seconds += 60\\n            if 0 <= minutes < 100:\\n                res.append((minutes, seconds))\\n\\n        return res\\n\\n    def calc_cost(self, minutes, seconds, startAt, pushCost, moveCost) -> int:\\n        full_form = f\"{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}\"\\n        full_form = full_form.lstrip(\"0\")\\n\\n        li = [int(x) for x in full_form]\\n        cost = 0\\n        current = startAt\\n        for num in li:\\n            if num != current:\\n                cost += moveCost\\n                current = num\\n            cost += pushCost\\n\\n        return cost\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def create_configs(targetSeconds):\\n        res = []\\n        minutes = targetSeconds // 60\\n        seconds = targetSeconds % 60\\n        if 0 <= minutes < 100: # here is it important to avoid 100 minutes since max value is 99.\\n            res.append((minutes, seconds))\\n        if seconds < 40:\\n            minutes = minutes - 1\\n            seconds += 60\\n            if 0 <= minutes < 100: # avoiding minutes being less than 0\\n                res.append((minutes, seconds))\\n\\n        return res\\n```\n```\\n    def calc_cost(minutes, seconds, startAt, pushCost, moveCost) -> int:\\n        full_form = f\"{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}\"\\n        full_form = full_form.lstrip(\"0\")\\n\\n        li = [int(x) for x in full_form]\\n        cost = 0\\n        current = startAt\\n        for num in li:\\n            if num != current:\\n                cost += moveCost\\n                current = num\\n            cost += pushCost\\n\\n        return cost\\n```\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n\\n        min_cost = float(\"inf\")\\n        li = self.create_configs(targetSeconds)\\n        for minutes, seconds in li:\\n            min_cost = min(min_cost, self.calc_cost(minutes, seconds, startAt, pushCost, moveCost))\\n\\n        return min_cost\\n\\n    def create_configs(self, targetSeconds):\\n        res = []\\n        minutes = targetSeconds // 60\\n        seconds = targetSeconds % 60\\n        if 0 <= minutes < 100:\\n            res.append((minutes, seconds))\\n        if seconds < 40:\\n            minutes = minutes - 1\\n            seconds += 60\\n            if 0 <= minutes < 100:\\n                res.append((minutes, seconds))\\n\\n        return res\\n\\n    def calc_cost(self, minutes, seconds, startAt, pushCost, moveCost) -> int:\\n        full_form = f\"{minutes // 10}{minutes % 10}{seconds // 10}{seconds % 10}\"\\n        full_form = full_form.lstrip(\"0\")\\n\\n        li = [int(x) for x in full_form]\\n        cost = 0\\n        current = startAt\\n        for num in li:\\n            if num != current:\\n                cost += moveCost\\n                current = num\\n            cost += pushCost\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615729,
                "title": "c-100-runtime-2-cases-easy-to-understand",
                "content": "Given the setup of the problem, there are only **2** ways to decompose `targetSeconds` to the form `MM:SS`\\n- Use the normal time representation `mm:ss`, `mm < 60` and `ss < 60`\\n- Borrow 1 minute to seconds to have `mm-1:ss+60`\\n\\nThere will **NOT** be a third way because in case 1 we do not have enough seconds (`ss<60`) for an additional minute, and in case 2 we do not have enough seconds left (`60 + 60 + ss > 99`) to borrow another minute.\\n\\n**Code**:\\n```\\nclass Solution {\\nprivate:\\n    int digits[4]; // buffer to store digits\\n    int computeCost(int minutes, int seconds, int startAt, int moveCost, int pushCost) {\\n\\t\\t// get all digits\\n        digits[0] = minutes / 10, digits[1] = minutes % 10;\\n        digits[2] = seconds / 10, digits[3] = seconds % 10;\\n        int index = 0;\\n        while (index < 4 && !digits[index]) index++; // iterate until no zero\\n        int last_digit = startAt, cost = 0;\\n        while (index < 4) {\\n            if (last_digit != digits[index]) cost += moveCost; // different digits, move cost\\n            cost += pushCost;\\n            last_digit = digits[index];\\n            index++;\\n        }\\n        return cost;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds / 60; // get minutes\\n        int seconds = targetSeconds % 60; // get seconds\\n        int cost1 = INT_MAX; // case 1 cost\\n        if (minutes < 100) // if minutes greater than 100, we must transform to case 2\\n            cost1 = computeCost(minutes, seconds, startAt, moveCost, pushCost);\\n        int cost2 = INT_MAX;\\n        if (seconds <= 39) // if seconds larget than 39, we cannot go for case 2\\n            cost2 = computeCost(minutes - 1, seconds + 60, startAt, moveCost, pushCost);\\n        return min(cost1, cost2); // choose the best case\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int digits[4]; // buffer to store digits\\n    int computeCost(int minutes, int seconds, int startAt, int moveCost, int pushCost) {\\n\\t\\t// get all digits\\n        digits[0] = minutes / 10, digits[1] = minutes % 10;\\n        digits[2] = seconds / 10, digits[3] = seconds % 10;\\n        int index = 0;\\n        while (index < 4 && !digits[index]) index++; // iterate until no zero\\n        int last_digit = startAt, cost = 0;\\n        while (index < 4) {\\n            if (last_digit != digits[index]) cost += moveCost; // different digits, move cost\\n            cost += pushCost;\\n            last_digit = digits[index];\\n            index++;\\n        }\\n        return cost;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds / 60; // get minutes\\n        int seconds = targetSeconds % 60; // get seconds\\n        int cost1 = INT_MAX; // case 1 cost\\n        if (minutes < 100) // if minutes greater than 100, we must transform to case 2\\n            cost1 = computeCost(minutes, seconds, startAt, moveCost, pushCost);\\n        int cost2 = INT_MAX;\\n        if (seconds <= 39) // if seconds larget than 39, we cannot go for case 2\\n            cost2 = computeCost(minutes - 1, seconds + 60, startAt, moveCost, pushCost);\\n        return min(cost1, cost2); // choose the best case\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581710,
                "title": "c-0ms-fastest-solution-2-choices-only",
                "content": "Code with comments\\n```\\n# define MINFACTOR 60\\n# define DECFACTOR 10\\n# define MAXSECONDS 99\\n# define MAXDIGITS 4\\n\\nclass Solution {\\n    \\n    int calCost(int startAt, int moveCost, int pushCost, vector<int> target) {\\n        int cost = 0;\\n        int cur = startAt;\\n        bool start0 = true;\\n        for(int i=0; i<MAXDIGITS; i++) {\\n            if(target[i] == 0 && start0) {\\n                continue;\\n            } else {\\n                start0 = false;\\n                if(target[i] == cur) cost += pushCost;\\n                else {\\n                    cur = target[i];\\n                    cost += moveCost + pushCost;\\n                }\\n            }\\n        }\\n        return cost;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        // Initialise the 2 cases with MAX values\\n        int cost1 = INT_MAX, cost2 = INT_MAX;\\n        \\n        // calculate minutes and seconds\\n        int min = targetSeconds/MINFACTOR;\\n        int sec = targetSeconds % MINFACTOR;\\n        \\n        // if min are within the microwave range, calculate cost 1\\n        if(min <= 99) {\\n            cost1 = calCost(startAt, moveCost, pushCost, {min/DECFACTOR, min%DECFACTOR, sec/DECFACTOR, sec%DECFACTOR});\\n        }\\n        \\n        // since sec can be <= 99, so add minutes to seconds only till seconds <= 99\\n        // We can add min to seconds only once as 2min * 60 = 120 sec which is greater than 99\\n        min -= 1; \\n        sec += MINFACTOR;\\n        if(sec <= MAXSECONDS && min >= 0) {           \\n            cost2 = calCost(startAt, moveCost, pushCost, {min/DECFACTOR, min%DECFACTOR, sec/DECFACTOR, sec%DECFACTOR});\\n        } \\n        \\n        // retrun min of above 2\\n        return (cost1 < cost2) ? cost1 : cost2;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# define MINFACTOR 60\\n# define DECFACTOR 10\\n# define MAXSECONDS 99\\n# define MAXDIGITS 4\\n\\nclass Solution {\\n    \\n    int calCost(int startAt, int moveCost, int pushCost, vector<int> target) {\\n        int cost = 0;\\n        int cur = startAt;\\n        bool start0 = true;\\n        for(int i=0; i<MAXDIGITS; i++) {\\n            if(target[i] == 0 && start0) {\\n                continue;\\n            } else {\\n                start0 = false;\\n                if(target[i] == cur) cost += pushCost;\\n                else {\\n                    cur = target[i];\\n                    cost += moveCost + pushCost;\\n                }\\n            }\\n        }\\n        return cost;\\n    }\\n    \\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        // Initialise the 2 cases with MAX values\\n        int cost1 = INT_MAX, cost2 = INT_MAX;\\n        \\n        // calculate minutes and seconds\\n        int min = targetSeconds/MINFACTOR;\\n        int sec = targetSeconds % MINFACTOR;\\n        \\n        // if min are within the microwave range, calculate cost 1\\n        if(min <= 99) {\\n            cost1 = calCost(startAt, moveCost, pushCost, {min/DECFACTOR, min%DECFACTOR, sec/DECFACTOR, sec%DECFACTOR});\\n        }\\n        \\n        // since sec can be <= 99, so add minutes to seconds only till seconds <= 99\\n        // We can add min to seconds only once as 2min * 60 = 120 sec which is greater than 99\\n        min -= 1; \\n        sec += MINFACTOR;\\n        if(sec <= MAXSECONDS && min >= 0) {           \\n            cost2 = calCost(startAt, moveCost, pushCost, {min/DECFACTOR, min%DECFACTOR, sec/DECFACTOR, sec%DECFACTOR});\\n        } \\n        \\n        // retrun min of above 2\\n        return (cost1 < cost2) ? cost1 : cost2;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547392,
                "title": "0ms-c-production-ready-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    using Digits = std::array<int, 4>;\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {        \\n        const auto d = std::div(targetSeconds, 60);\\n        const auto minutes = d.quot;\\n        const auto seconds = d.rem;\\n        \\n        auto min = std::numeric_limits<int>::max();\\n        \\n        if (minutes < 100) { // All is over 6000s = 100 min => 100:00 - cannot be displayed, we should use 99:60 form instead\\n            min = minCost(minutes, seconds, startAt, moveCost, pushCost);    \\n        }\\n        \\n        if (minutes > 0 && seconds < 40) { // 01:39 => 00:99 case\\n            const auto cost = minCost(minutes - 1, seconds + 60, startAt, moveCost, pushCost);\\n            if (cost < min) {\\n                min = cost;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n    \\n    int minCost(int minutes, int seconds, int startAt, int moveCost, int pushCost) {\\n        const auto dm = std::div(minutes, 10);\\n        const auto ds = std::div(seconds, 10);\\n        const Digits digits = { dm.quot, dm.rem, ds.quot, ds.rem };\\n        \\n        auto it = digits.begin();\\n        while (*it == 0) { // ignore leading zeros\\n            ++it;\\n        }\\n        \\n        auto sum = 0;\\n        for ( ; it != digits.end(); ++it) {\\n            const auto digit = *it;\\n            if (digit != startAt) {\\n                sum += moveCost;\\n                startAt = digit;\\n            }\\n            sum += pushCost;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using Digits = std::array<int, 4>;\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {        \\n        const auto d = std::div(targetSeconds, 60);\\n        const auto minutes = d.quot;\\n        const auto seconds = d.rem;\\n        \\n        auto min = std::numeric_limits<int>::max();\\n        \\n        if (minutes < 100) { // All is over 6000s = 100 min => 100:00 - cannot be displayed, we should use 99:60 form instead\\n            min = minCost(minutes, seconds, startAt, moveCost, pushCost);    \\n        }\\n        \\n        if (minutes > 0 && seconds < 40) { // 01:39 => 00:99 case\\n            const auto cost = minCost(minutes - 1, seconds + 60, startAt, moveCost, pushCost);\\n            if (cost < min) {\\n                min = cost;\\n            }\\n        }\\n        \\n        return min;\\n    }\\n    \\n    int minCost(int minutes, int seconds, int startAt, int moveCost, int pushCost) {\\n        const auto dm = std::div(minutes, 10);\\n        const auto ds = std::div(seconds, 10);\\n        const Digits digits = { dm.quot, dm.rem, ds.quot, ds.rem };\\n        \\n        auto it = digits.begin();\\n        while (*it == 0) { // ignore leading zeros\\n            ++it;\\n        }\\n        \\n        auto sum = 0;\\n        for ( ; it != digits.end(); ++it) {\\n            const auto digit = *it;\\n            if (digit != startAt) {\\n                sum += moveCost;\\n                startAt = digit;\\n            }\\n            sum += pushCost;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448054,
                "title": "c-direct-easy-brute-force-solution-no-edge-cases-intuition",
                "content": "Basic brute force, considering all time frames from 00.00 to 99.99 at each time when our time becomes equal to the target we calculate the cost and store the minumum.\\nuse of vectors can be avoided but for better readability let there be. \\n```\\nclass Solution {\\npublic:\\n    int cal(int st, int mc, int pc, int tar){\\n\\t//for calculating the cost\\n        int ans=0;\\n        vector<int>v;\\n        while(tar){\\n            v.push_back(tar%10);\\n            tar/=10;\\n        }\\n        reverse(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=st){\\n                ans+=mc;\\n                st=v[i];\\n            }\\n            ans+=pc;\\n        }\\n        return ans;\\n    }\\n    int minCostSetTime(int st, int mc, int pc, int tar) {\\n        int mt=INT_MAX;\\n        for(int hr=0;hr<100;hr++){\\n            for(int mn=0;mn<100;mn++){\\n                int t=hr*60+mn;\\n                if(t==tar){\\n                    int a=hr*100+mn; //converting time in form hhmm\\n                    mt=min(mt,cal(st,mc,pc,a));\\n                }\\n            }\\n        }\\n        return mt;\\n    }\\n};\\n```\\n**Do UPVOTE if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(int st, int mc, int pc, int tar){\\n\\t//for calculating the cost\\n        int ans=0;\\n        vector<int>v;\\n        while(tar){\\n            v.push_back(tar%10);\\n            tar/=10;\\n        }\\n        reverse(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]!=st){\\n                ans+=mc;\\n                st=v[i];\\n            }\\n            ans+=pc;\\n        }\\n        return ans;\\n    }\\n    int minCostSetTime(int st, int mc, int pc, int tar) {\\n        int mt=INT_MAX;\\n        for(int hr=0;hr<100;hr++){\\n            for(int mn=0;mn<100;mn++){\\n                int t=hr*60+mn;\\n                if(t==tar){\\n                    int a=hr*100+mn; //converting time in form hhmm\\n                    mt=min(mt,cal(st,mc,pc,a));\\n                }\\n            }\\n        }\\n        return mt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385338,
                "title": "clean-java-code",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        int mi = Math.min(99, target / 60);\\n        int sec = target - mi * 60;\\n        int ans = Integer.MAX_VALUE;\\n        for(int m = mi; m >= 0; m--) {\\n            int s = sec + (mi - m) * 60;\\n            if(s < 0 || s > 99) continue;\\n            ans = Math.min(ans, calc(m, s, moveCost, pushCost, startAt));\\n        }\\n        return ans;\\n    }\\n    \\n    int calc(int m, int s, int move, int push, int st) {\\n        int[] arr = {m/10, m%10, s/10, s%10};\\n        int i = 0;\\n        for(; i < 4; i++) {\\n            if(arr[i] != 0) break;\\n        }\\n        int ret = 0;\\n        while(i < 4) {\\n            if(st == arr[i]) {\\n                ret += push;\\n            }\\n            else {\\n                ret += move + push;\\n                st = arr[i];\\n            }\\n            i++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n        int mi = Math.min(99, target / 60);\\n        int sec = target - mi * 60;\\n        int ans = Integer.MAX_VALUE;\\n        for(int m = mi; m >= 0; m--) {\\n            int s = sec + (mi - m) * 60;\\n            if(s < 0 || s > 99) continue;\\n            ans = Math.min(ans, calc(m, s, moveCost, pushCost, startAt));\\n        }\\n        return ans;\\n    }\\n    \\n    int calc(int m, int s, int move, int push, int st) {\\n        int[] arr = {m/10, m%10, s/10, s%10};\\n        int i = 0;\\n        for(; i < 4; i++) {\\n            if(arr[i] != 0) break;\\n        }\\n        int ret = 0;\\n        while(i < 4) {\\n            if(st == arr[i]) {\\n                ret += push;\\n            }\\n            else {\\n                ret += move + push;\\n                st = arr[i];\\n            }\\n            i++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379236,
                "title": "golang-100",
                "content": "```\\nfunc minCostSetTime(startAt int, moveCost int, pushCost int, targetSeconds int) int {\\n    num := Make(targetSeconds)\\n    ans := math.MaxInt64\\n    fmt.Println(num)\\n    for _, v := range num {\\n        t := 0\\n        if v[0] == 0 {\\n            t = Count(startAt, moveCost, pushCost, v[1], true)\\n        } else {\\n            t = Count(startAt, moveCost, pushCost, v[0], true) + Count(v[0]% 10, moveCost, pushCost, v[1], false)\\n        }\\n        if t < ans {\\n            ans = t\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc Count(s int, m int, p int, t int, is bool) int {\\n    ans := 0\\n    if t < 10 {\\n        if is {\\n            if t == s {\\n                return p\\n            }\\n            return m + p\\n        } else {\\n            if 0 == s {\\n                ans += p\\n            } else {\\n                ans += (p + m)\\n            }\\n            if t == 0 {\\n                ans += p\\n            } else {\\n                ans += (p + m)\\n            }\\n            return ans\\n        }\\n    }\\n    \\n    if t / 10 == s {\\n        ans += p\\n    } else {\\n        ans += (p + m)\\n    }\\n    if t / 10 == t % 10 {\\n        ans += p\\n    } else {\\n        ans += (p + m)\\n    }\\n    return ans\\n}\\n\\nfunc Make(s int) [][]int {\\n    t := s\\n    num := [][]int{}\\n    tt := []int{t / 60, t % 60}\\n    num = append(num, tt)\\n    if tt[1] + 60 < 100 && tt[0] > 0 {\\n        num = append(num, []int{tt[0]-1, tt[1] + 60})\\n    }\\n    if t / 60 > 99 {\\n        num = num[1:]\\n    }\\n    return num\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minCostSetTime(startAt int, moveCost int, pushCost int, targetSeconds int) int {\\n    num := Make(targetSeconds)\\n    ans := math.MaxInt64\\n    fmt.Println(num)\\n    for _, v := range num {\\n        t := 0\\n        if v[0] == 0 {\\n            t = Count(startAt, moveCost, pushCost, v[1], true)\\n        } else {\\n            t = Count(startAt, moveCost, pushCost, v[0], true) + Count(v[0]% 10, moveCost, pushCost, v[1], false)\\n        }\\n        if t < ans {\\n            ans = t\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc Count(s int, m int, p int, t int, is bool) int {\\n    ans := 0\\n    if t < 10 {\\n        if is {\\n            if t == s {\\n                return p\\n            }\\n            return m + p\\n        } else {\\n            if 0 == s {\\n                ans += p\\n            } else {\\n                ans += (p + m)\\n            }\\n            if t == 0 {\\n                ans += p\\n            } else {\\n                ans += (p + m)\\n            }\\n            return ans\\n        }\\n    }\\n    \\n    if t / 10 == s {\\n        ans += p\\n    } else {\\n        ans += (p + m)\\n    }\\n    if t / 10 == t % 10 {\\n        ans += p\\n    } else {\\n        ans += (p + m)\\n    }\\n    return ans\\n}\\n\\nfunc Make(s int) [][]int {\\n    t := s\\n    num := [][]int{}\\n    tt := []int{t / 60, t % 60}\\n    num = append(num, tt)\\n    if tt[1] + 60 < 100 && tt[0] > 0 {\\n        num = append(num, []int{tt[0]-1, tt[1] + 60})\\n    }\\n    if t / 60 > 99 {\\n        num = num[1:]\\n    }\\n    return num\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341482,
                "title": "sweet-simple-to-understand-0ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculateCost(int startAt, string number, int moveCost, int pushCost)\\n    {\\n        int cost = 0;\\n        \\n        for(int i=0; i<number.size(); i++)\\n        {\\n            int currDig = number[i]-\\'0\\';\\n            if(currDig == startAt)\\n            {\\n                cost += pushCost;\\n            }\\n            else\\n            {\\n                cost += (pushCost + moveCost);\\n            }\\n            startAt = currDig;\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        if(targetSeconds < 60)\\n        {\\n            return calculateCost(startAt, to_string(targetSeconds), moveCost, pushCost);\\n        }\\n        else\\n        {\\n            int ans = INT_MAX;\\n            int seconds = targetSeconds % 60;\\n            int hours = targetSeconds / 60;\\n            \\n            if(hours <= 99)\\n            {\\n            ans = min(ans, calculateCost(startAt, to_string(hours*100 + seconds), moveCost, pushCost));\\n            }\\n            \\n            if ((seconds + 60) <= 99)\\n            {\\n                ans = min(ans, calculateCost(startAt, to_string((hours-1)*100 + seconds + 60) , moveCost, pushCost));\\n            }\\n            \\n            return ans;\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculateCost(int startAt, string number, int moveCost, int pushCost)\\n    {\\n        int cost = 0;\\n        \\n        for(int i=0; i<number.size(); i++)\\n        {\\n            int currDig = number[i]-\\'0\\';\\n            if(currDig == startAt)\\n            {\\n                cost += pushCost;\\n            }\\n            else\\n            {\\n                cost += (pushCost + moveCost);\\n            }\\n            startAt = currDig;\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        if(targetSeconds < 60)\\n        {\\n            return calculateCost(startAt, to_string(targetSeconds), moveCost, pushCost);\\n        }\\n        else\\n        {\\n            int ans = INT_MAX;\\n            int seconds = targetSeconds % 60;\\n            int hours = targetSeconds / 60;\\n            \\n            if(hours <= 99)\\n            {\\n            ans = min(ans, calculateCost(startAt, to_string(hours*100 + seconds), moveCost, pushCost));\\n            }\\n            \\n            if ((seconds + 60) <= 99)\\n            {\\n                ans = min(ans, calculateCost(startAt, to_string((hours-1)*100 + seconds + 60) , moveCost, pushCost));\\n            }\\n            \\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318547,
                "title": "c-solution-easy-to-understand",
                "content": "Code is a little bit longer and has more functions but much easier to understand and debug.\\nTime = O(1) (All loops run at max 4 times)\\nSpace = O(1)\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Minimum Cost to Set Cooking Time.\\nMemory Usage: 6 MB, less than 22.29% of C++ online submissions for Minimum Cost to Set Cooking Time.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void buildDigits(vector<int>& digits, int minutes, int seconds) {\\n        digits.clear();\\n        digits.push_back(minutes/10);\\n        digits.push_back(minutes%10);\\n        digits.push_back(seconds/10);\\n        digits.push_back(seconds%10);\\n        removePrependingZeros(digits);\\n    }\\n    void removePrependingZeros(vector<int>& digits) {\\n        while(!digits.empty()) {\\n            if(digits[0] != 0) return;\\n            digits.erase(digits.begin());\\n        }\\n    }\\n\\t\\n    bool anotherCostExists(int minutes, int seconds) {\\n\\t    return (minutes>0 && seconds + 60 <100);\\n    }\\n\\n    int getCost(vector<int>& digits, int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost = 0;\\n        int pos = startAt;\\n        for(int i=0; i< digits.size(); i++) {\\n            cost += moveCost *(pos != digits[i]) + pushCost;\\n            pos = digits[i];\\n                }\\n        return cost;\\n    }\\n\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost1 = INT_MAX;\\n        int cost2 = INT_MAX;\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n        vector<int> digits;\\n        if(minutes < 100) {\\n            buildDigits(digits, minutes, seconds);\\n            cost1 = getCost(digits, startAt, moveCost, pushCost, targetSeconds);\\n        }\\n        if(anotherCostExists(minutes, seconds)) {\\n\\t        buildDigits(digits, minutes-1, seconds+60);\\n        \\tcost2 = getCost(digits, startAt, moveCost, pushCost, targetSeconds);\\n        }\\n        return min(cost1, cost2);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void buildDigits(vector<int>& digits, int minutes, int seconds) {\\n        digits.clear();\\n        digits.push_back(minutes/10);\\n        digits.push_back(minutes%10);\\n        digits.push_back(seconds/10);\\n        digits.push_back(seconds%10);\\n        removePrependingZeros(digits);\\n    }\\n    void removePrependingZeros(vector<int>& digits) {\\n        while(!digits.empty()) {\\n            if(digits[0] != 0) return;\\n            digits.erase(digits.begin());\\n        }\\n    }\\n\\t\\n    bool anotherCostExists(int minutes, int seconds) {\\n\\t    return (minutes>0 && seconds + 60 <100);\\n    }\\n\\n    int getCost(vector<int>& digits, int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost = 0;\\n        int pos = startAt;\\n        for(int i=0; i< digits.size(); i++) {\\n            cost += moveCost *(pos != digits[i]) + pushCost;\\n            pos = digits[i];\\n                }\\n        return cost;\\n    }\\n\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost1 = INT_MAX;\\n        int cost2 = INT_MAX;\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n        vector<int> digits;\\n        if(minutes < 100) {\\n            buildDigits(digits, minutes, seconds);\\n            cost1 = getCost(digits, startAt, moveCost, pushCost, targetSeconds);\\n        }\\n        if(anotherCostExists(minutes, seconds)) {\\n\\t        buildDigits(digits, minutes-1, seconds+60);\\n        \\tcost2 = getCost(digits, startAt, moveCost, pushCost, targetSeconds);\\n        }\\n        return min(cost1, cost2);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272550,
                "title": "python-straightforward-o-1",
                "content": "class Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        possible_str_list=[]\\n        target_min=targetSeconds//60\\n        target_sec=targetSeconds%60\\n        \\n        while(0<=target_min <=100 and target_sec<=99):\\n\\n            min_str = \\'0\\' + str(target_min) if target_min<10 else str(target_min)\\n            sec_str = \\'0\\' + str(target_sec) if target_sec<10 else str(target_sec)\\n            tmp_str = min_str + sec_str\\n            \\n            if 0<=target_min<=99:\\n                possible_str_list.append(tmp_str)\\n            target_min-=1\\n            target_sec+=60\\n        \\n        print(possible_str_list)\\n        min_cost=math.inf\\n\\n        \\n        for possible_str in possible_str_list:\\n            tmp_sum=0\\n            startAt_tmp=str(startAt)\\n            start_flag=False\\n            for idx in range(len(possible_str)):\\n                if possible_str[idx]==\\'0\\' and not start_flag:\\n                    continue\\n                else:\\n                    start_flag=True\\n\\n                \\n                if startAt_tmp==possible_str[idx]:\\n                    tmp_sum+=pushCost\\n                else:\\n                    startAt_tmp=possible_str[idx]\\n                    tmp_sum+=moveCost\\n                    tmp_sum+=pushCost\\n            \\n            min_cost=min(tmp_sum, min_cost)\\n        \\n        return min_cost\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        possible_str_list=[]\\n        target_min=targetSeconds//60\\n        target_sec=targetSeconds%60\\n        \\n        while(0<=target_min <=100 and target_sec<=99):\\n\\n            min_str = \\'0\\' + str(target_min) if target_min<10 else str(target_min)\\n            sec_str = \\'0\\' + str(target_sec) if target_sec<10 else str(target_sec)\\n            tmp_str = min_str + sec_str\\n            \\n            if 0<=target_min<=99:\\n                possible_str_list.append(tmp_str)\\n            target_min-=1\\n            target_sec+=60\\n        \\n        print(possible_str_list)\\n        min_cost=math.inf\\n\\n        \\n        for possible_str in possible_str_list:\\n            tmp_sum=0\\n            startAt_tmp=str(startAt)\\n            start_flag=False\\n            for idx in range(len(possible_str)):\\n                if possible_str[idx]==\\'0\\' and not start_flag:\\n                    continue\\n                else:\\n                    start_flag=True\\n\\n                \\n                if startAt_tmp==possible_str[idx]:\\n                    tmp_sum+=pushCost\\n                else:\\n                    startAt_tmp=possible_str[idx]\\n                    tmp_sum+=moveCost\\n                    tmp_sum+=pushCost\\n            \\n            min_cost=min(tmp_sum, min_cost)\\n        \\n        return min_cost\\n",
                "codeTag": "Java"
            },
            {
                "id": 2202668,
                "title": "c-constant-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string getTime(int min, int sec)\\n    {\\n        string minsString = \"\";\\n        string secondsString = to_string(sec);\\n        if (min > 0)\\n        {\\n            minsString = to_string(min);\\n            if (sec < 10)\\n            {\\n                secondsString = \\'0\\' + secondsString;\\n            }\\n        }\\n        \\n        return minsString + secondsString;\\n    }\\n    \\n    int getCost(string num, int start, int moveCost, int pushCost)\\n    {\\n        int cost = num.length() * pushCost;\\n        \\n        for (int i = 0; i < num.size(); i++)\\n        {\\n            if (i == 0 && num[i] - \\'0\\' != start)\\n            {\\n                cost += moveCost;\\n            }\\n            else if (i > 0 && num[i] != num[i-1])\\n            {\\n                cost += moveCost;\\n            }\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n        int minCost = INT_MAX;\\n        int mins = targetSeconds/60;\\n        int secs = targetSeconds%60;\\n        \\n        if (mins < 100)\\n        {\\n             minCost = min(minCost, getCost(getTime(mins, secs), startAt, moveCost, pushCost));\\n        }\\n        \\n        if (mins - 1 >= 0 && secs + 60 <= 99)\\n        {\\n            minCost= min(minCost, getCost(getTime(mins - 1, secs + 60), startAt, moveCost, pushCost));\\n        }\\n        \\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string getTime(int min, int sec)\\n    {\\n        string minsString = \"\";\\n        string secondsString = to_string(sec);\\n        if (min > 0)\\n        {\\n            minsString = to_string(min);\\n            if (sec < 10)\\n            {\\n                secondsString = \\'0\\' + secondsString;\\n            }\\n        }\\n        \\n        return minsString + secondsString;\\n    }\\n    \\n    int getCost(string num, int start, int moveCost, int pushCost)\\n    {\\n        int cost = num.length() * pushCost;\\n        \\n        for (int i = 0; i < num.size(); i++)\\n        {\\n            if (i == 0 && num[i] - \\'0\\' != start)\\n            {\\n                cost += moveCost;\\n            }\\n            else if (i > 0 && num[i] != num[i-1])\\n            {\\n                cost += moveCost;\\n            }\\n        }\\n        \\n        return cost;\\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n        int minCost = INT_MAX;\\n        int mins = targetSeconds/60;\\n        int secs = targetSeconds%60;\\n        \\n        if (mins < 100)\\n        {\\n             minCost = min(minCost, getCost(getTime(mins, secs), startAt, moveCost, pushCost));\\n        }\\n        \\n        if (mins - 1 >= 0 && secs + 60 <= 99)\\n        {\\n            minCost= min(minCost, getCost(getTime(mins - 1, secs + 60), startAt, moveCost, pushCost));\\n        }\\n        \\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163591,
                "title": "c-generating-all-possible-strings",
                "content": "Generating all the possible strings then finding minimum cost along them.\\n\\n```\\nclass Solution {\\npublic:\\n    int findCost(int startAt, int moveCost, int pushCost,string& s){\\n        if((s[0]-\\'0\\') == 0) s.erase(0,1);\\n        // cout<<\"string is \"<<s<<endl;\\n        int ans;\\n        // cout<<s[0]-\\'0\\'<<\" -- \"<<startAt<<endl;\\n        if(s[0]-\\'0\\' == startAt) ans = 0;\\n        else ans = moveCost;\\n        ans+=pushCost;\\n        \\n        for(int i=1;i<s.size();i++){\\n            if(s[i] == s[i-1]){\\n                ans+=pushCost;\\n            }\\n            else{\\n                ans += pushCost;\\n                ans += moveCost;\\n            }\\n        }\\n        // cout<<ans<<endl;\\n        return ans;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n         int ans = INT_MAX;\\n        int mins = target / 60;\\n        int remSecs = target % 60;\\n        \\n        string temp1 = to_string(mins);\\n        if(remSecs == 0) temp1 += \"00\";\\n        else if(remSecs < 10){\\n            temp1 += \"0\";\\n            temp1 += to_string(remSecs);\\n        }\\n        else temp1 += to_string(remSecs);\\n        // cout<<temp1<<endl;  \\n        if(temp1.size()<=4)\\n            ans = min(ans,findCost(startAt,moveCost,pushCost,temp1));\\n        \\n        if(target < 99){\\n            string temp2 = to_string(target);\\n            // cout<<temp2<<endl;\\n            if(temp2.size()<=4)\\n                ans = min(ans,findCost(startAt,moveCost,pushCost,temp2));\\n        }\\n        \\n        \\n        if(remSecs < 40){\\n            mins = mins-1;\\n            string temp3 = to_string(mins);\\n            int var = 60+remSecs;\\n            temp3 += to_string(var);\\n            // cout<<temp3<<endl;\\n            if(temp3.size()<=4)\\n                ans = min(ans,findCost(startAt,moveCost,pushCost,temp3));\\n        }  \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCost(int startAt, int moveCost, int pushCost,string& s){\\n        if((s[0]-\\'0\\') == 0) s.erase(0,1);\\n        // cout<<\"string is \"<<s<<endl;\\n        int ans;\\n        // cout<<s[0]-\\'0\\'<<\" -- \"<<startAt<<endl;\\n        if(s[0]-\\'0\\' == startAt) ans = 0;\\n        else ans = moveCost;\\n        ans+=pushCost;\\n        \\n        for(int i=1;i<s.size();i++){\\n            if(s[i] == s[i-1]){\\n                ans+=pushCost;\\n            }\\n            else{\\n                ans += pushCost;\\n                ans += moveCost;\\n            }\\n        }\\n        // cout<<ans<<endl;\\n        return ans;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int target) {\\n         int ans = INT_MAX;\\n        int mins = target / 60;\\n        int remSecs = target % 60;\\n        \\n        string temp1 = to_string(mins);\\n        if(remSecs == 0) temp1 += \"00\";\\n        else if(remSecs < 10){\\n            temp1 += \"0\";\\n            temp1 += to_string(remSecs);\\n        }\\n        else temp1 += to_string(remSecs);\\n        // cout<<temp1<<endl;  \\n        if(temp1.size()<=4)\\n            ans = min(ans,findCost(startAt,moveCost,pushCost,temp1));\\n        \\n        if(target < 99){\\n            string temp2 = to_string(target);\\n            // cout<<temp2<<endl;\\n            if(temp2.size()<=4)\\n                ans = min(ans,findCost(startAt,moveCost,pushCost,temp2));\\n        }\\n        \\n        \\n        if(remSecs < 40){\\n            mins = mins-1;\\n            string temp3 = to_string(mins);\\n            int var = 60+remSecs;\\n            temp3 += to_string(var);\\n            // cout<<temp3<<endl;\\n            if(temp3.size()<=4)\\n                ans = min(ans,findCost(startAt,moveCost,pushCost,temp3));\\n        }  \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2159638,
                "title": "using-stack-java",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        List<String> times = getTimes(targetSeconds);\\n        \\n     \\n        int minTotalCost = Integer.MAX_VALUE;\\n        \\n        for(String time : times){\\n            minTotalCost = Math.min(minTotalCost, getCost(time, startAt, moveCost, pushCost));\\n        }\\n        \\n        return minTotalCost;\\n    }\\n    \\n    \\n    public int getCost(String time, int startAt, int moveCost, int pushCost){\\n        Queue<Character> queue = new LinkedList<>();\\n        for(char c : time.toCharArray()){\\n            queue.add(c);\\n        }\\n        \\n        int totalCost = 0;\\n        char startChar = (char)(startAt + \\'0\\');\\n        while(!queue.isEmpty()){\\n            char nextChar = queue.poll();\\n            if(nextChar != startChar){\\n                totalCost += moveCost;\\n            }\\n            totalCost += pushCost;\\n            startChar = nextChar;\\n        }\\n        return totalCost;\\n    }\\n    \\n    public List<String> getTimes(int targetSeconds){\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        // Get the minutes\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds - (minutes * 60);\\n        String secondsStr = String.format(\"%02d\", seconds);\\n  \\n        if(minutes == 0)\\n            result.add(\"\" + seconds);\\n        else if (minutes <= 99)\\n            result.add(minutes + secondsStr);\\n            \\n        // Check if the seconds are below 40\\n        if(seconds < 40 && minutes > 0){\\n            minutes--;\\n            seconds += 60;            \\n            if(minutes == 0)\\n                result.add(\"\" + seconds);\\n            else if (minutes <= 99)\\n                result.add(minutes + \"\" + seconds);\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        List<String> times = getTimes(targetSeconds);\\n        \\n     \\n        int minTotalCost = Integer.MAX_VALUE;\\n        \\n        for(String time : times){\\n            minTotalCost = Math.min(minTotalCost, getCost(time, startAt, moveCost, pushCost));\\n        }\\n        \\n        return minTotalCost;\\n    }\\n    \\n    \\n    public int getCost(String time, int startAt, int moveCost, int pushCost){\\n        Queue<Character> queue = new LinkedList<>();\\n        for(char c : time.toCharArray()){\\n            queue.add(c);\\n        }\\n        \\n        int totalCost = 0;\\n        char startChar = (char)(startAt + \\'0\\');\\n        while(!queue.isEmpty()){\\n            char nextChar = queue.poll();\\n            if(nextChar != startChar){\\n                totalCost += moveCost;\\n            }\\n            totalCost += pushCost;\\n            startChar = nextChar;\\n        }\\n        return totalCost;\\n    }\\n    \\n    public List<String> getTimes(int targetSeconds){\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        // Get the minutes\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds - (minutes * 60);\\n        String secondsStr = String.format(\"%02d\", seconds);\\n  \\n        if(minutes == 0)\\n            result.add(\"\" + seconds);\\n        else if (minutes <= 99)\\n            result.add(minutes + secondsStr);\\n            \\n        // Check if the seconds are below 40\\n        if(seconds < 40 && minutes > 0){\\n            minutes--;\\n            seconds += 60;            \\n            if(minutes == 0)\\n                result.add(\"\" + seconds);\\n            else if (minutes <= 99)\\n                result.add(minutes + \"\" + seconds);\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158309,
                "title": "simple-java-solution-beats-97-42-solutions-o-1-time-o-1-space",
                "content": "```\\n class Solution {\\n      \\n\\t  int minTime = Integer.MAX_VALUE;\\n     public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n\\n        int editMins = Integer.MAX_VALUE;\\n        int editSecs = Integer.MAX_VALUE;\\n\\n        if (seconds <= 39 && minutes > 0) {\\n            editMins = minutes - 1;\\n            editSecs = seconds + 60;\\n        }\\n        if (minutes <= 99)\\n            findTime(minutes, seconds, startAt, moveCost, pushCost);\\n        if (editMins != Integer.MAX_VALUE)\\n            findTime(editMins, editSecs, startAt, moveCost, pushCost);\\n\\n        return minTime;\\n    }\\n\\n    private void findTime(int minutes, int seconds, int startAt, int moveCost, int pushCost) {\\n        int time = 0;\\n        if (minutes > 0) {\\n            if (minutes <= 9) {\\n                time += startAt == minutes ? pushCost : moveCost + pushCost;\\n                startAt = minutes;\\n            } else {\\n                int first = minutes / 10;\\n                int second = minutes % 10;\\n                time += startAt == first ? pushCost : moveCost + pushCost;\\n                startAt = first;\\n                time += startAt == second ? pushCost : moveCost + pushCost;\\n                startAt = second;\\n            }\\n        }\\n\\n\\n        int first = seconds / 10;\\n        int second = seconds % 10;\\n        if (minutes > 0 || first > 0) {\\n            time += startAt == first ? pushCost : moveCost + pushCost;\\n            startAt = first;\\n        }\\n        time += startAt == second ? pushCost : moveCost + pushCost;\\n\\n        minTime = Math.min(time, minTime);\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n      \\n\\t  int minTime = Integer.MAX_VALUE;\\n     public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n\\n        int editMins = Integer.MAX_VALUE;\\n        int editSecs = Integer.MAX_VALUE;\\n\\n        if (seconds <= 39 && minutes > 0) {\\n            editMins = minutes - 1;\\n            editSecs = seconds + 60;\\n        }\\n        if (minutes <= 99)\\n            findTime(minutes, seconds, startAt, moveCost, pushCost);\\n        if (editMins != Integer.MAX_VALUE)\\n            findTime(editMins, editSecs, startAt, moveCost, pushCost);\\n\\n        return minTime;\\n    }\\n\\n    private void findTime(int minutes, int seconds, int startAt, int moveCost, int pushCost) {\\n        int time = 0;\\n        if (minutes > 0) {\\n            if (minutes <= 9) {\\n                time += startAt == minutes ? pushCost : moveCost + pushCost;\\n                startAt = minutes;\\n            } else {\\n                int first = minutes / 10;\\n                int second = minutes % 10;\\n                time += startAt == first ? pushCost : moveCost + pushCost;\\n                startAt = first;\\n                time += startAt == second ? pushCost : moveCost + pushCost;\\n                startAt = second;\\n            }\\n        }\\n\\n\\n        int first = seconds / 10;\\n        int second = seconds % 10;\\n        if (minutes > 0 || first > 0) {\\n            time += startAt == first ? pushCost : moveCost + pushCost;\\n            startAt = first;\\n        }\\n        time += startAt == second ? pushCost : moveCost + pushCost;\\n\\n        minTime = Math.min(time, minTime);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146235,
                "title": "java-solution-faster-than-100",
                "content": "\\tpublic int minutesCost(int minutes, int startAt, int moveCost, int pushCost){\\n        int firstDigit = minutes / 10;\\n        int secondDigit = minutes % 10;\\n        \\n        int cost = 0;\\n        \\n        if (firstDigit == startAt){\\n            cost += pushCost;\\n        }\\n        else {\\n            cost += pushCost + moveCost;\\n        }\\n        \\n        if (secondDigit == firstDigit){\\n            cost += pushCost;\\n        }\\n        else {\\n            cost += pushCost + moveCost;\\n        }\\n        \\n        return cost;\\n    } \\n    \\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        if (targetSeconds < 10){\\n            int cost = pushCost;\\n            if (startAt != targetSeconds) cost += moveCost;\\n            \\n            return cost;\\n        }\\n        \\n        if (targetSeconds <= 99){\\n            int secondsCost = minutesCost(targetSeconds, startAt, moveCost, pushCost);\\n            \\n            min = secondsCost;\\n        }\\n        \\n        int optMin = targetSeconds/60;\\n        if (optMin > 99) optMin = 99;\\n        for (int i=0; i<=optMin; ++i){\\n            int secs = i*60;\\n            \\n            int diff = targetSeconds - secs;\\n            \\n            if (diff >=0 & diff <= 99){\\n                \\n                int initCost = 0;\\n                if (i < 10){\\n                    if (i != startAt){\\n                        initCost = pushCost + moveCost;\\n                    }\\n                    else if (i != 0) initCost = pushCost;\\n                }\\n                else initCost = minutesCost(i, startAt, moveCost, pushCost);\\n                \\n                int secondsCost = minutesCost(diff, (i%10), moveCost, pushCost);\\n                \\n                int cost = initCost + secondsCost;\\n                \\n                min = Math.min(min, cost);\\n            }\\n        }\\n        \\n        return min;        \\n    }",
                "solutionTags": [],
                "code": "\\tpublic int minutesCost(int minutes, int startAt, int moveCost, int pushCost){\\n        int firstDigit = minutes / 10;\\n        int secondDigit = minutes % 10;\\n        \\n        int cost = 0;\\n        \\n        if (firstDigit == startAt){\\n            cost += pushCost;\\n        }\\n        else {\\n            cost += pushCost + moveCost;\\n        }\\n        \\n        if (secondDigit == firstDigit){\\n            cost += pushCost;\\n        }\\n        else {\\n            cost += pushCost + moveCost;\\n        }\\n        \\n        return cost;\\n    } \\n    \\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        if (targetSeconds < 10){\\n            int cost = pushCost;\\n            if (startAt != targetSeconds) cost += moveCost;\\n            \\n            return cost;\\n        }\\n        \\n        if (targetSeconds <= 99){\\n            int secondsCost = minutesCost(targetSeconds, startAt, moveCost, pushCost);\\n            \\n            min = secondsCost;\\n        }\\n        \\n        int optMin = targetSeconds/60;\\n        if (optMin > 99) optMin = 99;\\n        for (int i=0; i<=optMin; ++i){\\n            int secs = i*60;\\n            \\n            int diff = targetSeconds - secs;\\n            \\n            if (diff >=0 & diff <= 99){\\n                \\n                int initCost = 0;\\n                if (i < 10){\\n                    if (i != startAt){\\n                        initCost = pushCost + moveCost;\\n                    }\\n                    else if (i != 0) initCost = pushCost;\\n                }\\n                else initCost = minutesCost(i, startAt, moveCost, pushCost);\\n                \\n                int secondsCost = minutesCost(diff, (i%10), moveCost, pushCost);\\n                \\n                int cost = initCost + secondsCost;\\n                \\n                min = Math.min(min, cost);\\n            }\\n        }\\n        \\n        return min;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2124302,
                "title": "c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        List<string> possible_times = new List<string>();\\n        public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n        {\\n            int minutes = targetSeconds / 60;\\n            int seconds = targetSeconds % 60;\\n            int cost = Int32.MaxValue;\\n            if (minutes == 100 && seconds < 40)\\n            {\\n                AddPossibleTimes(minutes - 1, seconds + 60);\\n            }\\n            else\\n            {\\n                AddPossibleTimes(minutes, seconds);\\n                if (minutes > 0 && seconds < 40)\\n                {\\n                    AddPossibleTimes(minutes - 1, seconds + 60);\\n                }\\n            }\\n\\n            foreach (var time in possible_times)\\n            {\\n                int currentCost = 0;\\n                char prev_char = startAt.ToString()[0];\\n                foreach (var cur_char in time)\\n                {\\n                    if (prev_char != cur_char)\\n                        currentCost += moveCost + pushCost;\\n                    else\\n                        currentCost += pushCost;\\n\\n                    prev_char = cur_char;\\n                }\\n                cost = Math.Min(cost, currentCost);\\n            }\\n\\n            return cost;\\n        }\\n\\n        private void AddPossibleTimes(int minutes, int seconds)\\n        {\\n            int minutes_tens_place = minutes / 10;\\n            int minutes_units_place = minutes % 10;\\n            int seconds_tens_place = seconds / 10;\\n            int seconds_units_place = seconds % 10;\\n\\n            if (minutes_tens_place > 0)\\n            {\\n                possible_times.Add(minutes.ToString() + seconds_tens_place.ToString() + seconds_units_place.ToString());\\n            }\\n            else if (minutes_units_place > 0)\\n            {\\n                possible_times.Add(0.ToString() + minutes_units_place.ToString() + seconds_tens_place.ToString() + seconds_units_place.ToString());\\n                possible_times.Add(minutes_units_place.ToString() + seconds_tens_place.ToString() + seconds_units_place.ToString());\\n            }\\n            else if (seconds_tens_place > 0)\\n            {\\n                possible_times.Add(seconds_tens_place.ToString() + seconds_units_place.ToString());\\n            }\\n            else if (seconds_units_place > 0)\\n            {\\n                possible_times.Add(0.ToString() + seconds_units_place.ToString());\\n                possible_times.Add(seconds_units_place.ToString());\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        List<string> possible_times = new List<string>();\\n        public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n        {\\n            int minutes = targetSeconds / 60;\\n            int seconds = targetSeconds % 60;\\n            int cost = Int32.MaxValue;\\n            if (minutes == 100 && seconds < 40)\\n            {\\n                AddPossibleTimes(minutes - 1, seconds + 60);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2100470,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int getCost(char currNumC, int moveCost, int pushCost, int tarMin, int tarSec) {\\n        int cost = 0;\\n        string minStr = to_string(tarMin);\\n        string secStr = to_string(tarSec);\\n        \\n        if (minStr != \"0\") {\\n            for (char &minC : minStr) {\\n                if (currNumC != minC) {\\n                    currNumC = minC;\\n                    cost += moveCost;\\n                }\\n                cost += pushCost;\\n            }\\n            if (secStr.size() < 2) {\\n                secStr += \\'0\\';\\n                swap(secStr[0], secStr[1]);\\n            }\\n        }\\n\\n        for (char &secC : secStr) {\\n            if (currNumC != secC) {\\n                currNumC = secC;\\n                cost += moveCost;\\n            }\\n            cost += pushCost;\\n        }\\n        return cost;\\n    }\\npublic:\\n    int minCostSetTime(int currNum, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n        \\n        while (minutes >= 100) {\\n            if (seconds >= 40) {\\n                return -1;\\n            }\\n            minutes -= 1;\\n            seconds += 60;\\n        }\\n        \\n        int res = INT_MAX;\\n        char startNumC = \\'0\\' + currNum;\\n        while (minutes < 100 && seconds < 100) {\\n            res = min(res, getCost(startNumC, moveCost, pushCost, minutes, seconds));\\n            minutes -= 1;\\n            seconds += 60;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getCost(char currNumC, int moveCost, int pushCost, int tarMin, int tarSec) {\\n        int cost = 0;\\n        string minStr = to_string(tarMin);\\n        string secStr = to_string(tarSec);\\n        \\n        if (minStr != \"0\") {\\n            for (char &minC : minStr) {\\n                if (currNumC != minC) {\\n                    currNumC = minC;\\n                    cost += moveCost;\\n                }\\n                cost += pushCost;\\n            }\\n            if (secStr.size() < 2) {\\n                secStr += \\'0\\';\\n                swap(secStr[0], secStr[1]);\\n            }\\n        }\\n\\n        for (char &secC : secStr) {\\n            if (currNumC != secC) {\\n                currNumC = secC;\\n                cost += moveCost;\\n            }\\n            cost += pushCost;\\n        }\\n        return cost;\\n    }\\npublic:\\n    int minCostSetTime(int currNum, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n        \\n        while (minutes >= 100) {\\n            if (seconds >= 40) {\\n                return -1;\\n            }\\n            minutes -= 1;\\n            seconds += 60;\\n        }\\n        \\n        int res = INT_MAX;\\n        char startNumC = \\'0\\' + currNum;\\n        while (minutes < 100 && seconds < 100) {\\n            res = min(res, getCost(startNumC, moveCost, pushCost, minutes, seconds));\\n            minutes -= 1;\\n            seconds += 60;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097810,
                "title": "js-long-code-using-pure-array",
                "content": "```\\nfunction fourDigitTime(secs) {\\n    let array1 = []\\n    let array2 = []\\n\\n    let minute = Math.floor(secs / 60)\\n    let second = secs % 60;\\n    if (minute < 10) {\\n        array1.push(0, minute)\\n    } else {\\n        array1.push(Math.floor(minute / 10), minute % 10)\\n    }\\n\\n    if (second < 10) {\\n        array1.push(0, second)\\n    } else {\\n        array1.push(Math.floor(second / 10), second % 10)\\n    }\\n\\n    while (array1[0] === 0) {\\n        array1.shift()\\n    }\\n\\n\\n    if (second < 40 && minute !== 0) {\\n\\n        minute--;\\n        second += 60;\\n        if (minute < 10) {\\n            array2.push(0, minute)\\n        } else {\\n            array2.push(Math.floor(minute / 10), minute % 10)\\n        }\\n\\n        if (second < 10) {\\n            array2.push(0, second)\\n        } else {\\n            array2.push(Math.floor(second / 10), second % 10)\\n        }\\n        while (array2[0] === 0) {\\n            array2.shift()\\n        }\\n    }\\n    \\n    if (array1[0] < 10) {\\n        return [array1, array2]\\n    } else {\\n        return [array2, []]\\n    }\\n}\\n\\n\\n\\nvar minCostSetTime = function (startAt, moveCost, pushCost, targetSeconds) {\\n    \\n    times = fourDigitTime(targetSeconds)\\n\\n    let minCost1 = 0;\\n    let minCost2 = 0;\\n    // startAt = 0, moveCost = 2, pushCost = 1, targetSeconds = 500\\n    let firstTime = times[0]   // [1, 0, 0, 0]\\n    if (firstTime[0] !== startAt) minCost1+=moveCost;\\n    for (let i = 0; i < firstTime.length; i++) {\\n        minCost1 += pushCost;\\n        if (firstTime[i] !== firstTime[i + 1] && firstTime[i + 1] !== undefined) {\\n            minCost1 += moveCost;\\n            \\n        }\\n    }\\n\\n    if (times[1].length !== 0) {\\n        let secondTime = times[1]   // [1, 0, 0, 0]\\n        if (secondTime[0] !== startAt) minCost2+=moveCost;\\n        for (let i = 0; i < secondTime.length; i++) {\\n            minCost2 += pushCost;\\n            if (secondTime[i] !== secondTime[i + 1] && secondTime[i + 1] !== undefined) {\\n                minCost2 += moveCost;\\n            }\\n        }\\n        console.log(minCost1, minCost2)\\n        return Math.min(minCost1, minCost2)\\n    }\\n    \\n    return minCost1\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunction fourDigitTime(secs) {\\n    let array1 = []\\n    let array2 = []\\n\\n    let minute = Math.floor(secs / 60)\\n    let second = secs % 60;\\n    if (minute < 10) {\\n        array1.push(0, minute)\\n    } else {\\n        array1.push(Math.floor(minute / 10), minute % 10)\\n    }\\n\\n    if (second < 10) {\\n        array1.push(0, second)\\n    } else {\\n        array1.push(Math.floor(second / 10), second % 10)\\n    }\\n\\n    while (array1[0] === 0) {\\n        array1.shift()\\n    }\\n\\n\\n    if (second < 40 && minute !== 0) {\\n\\n        minute--;\\n        second += 60;\\n        if (minute < 10) {\\n            array2.push(0, minute)\\n        } else {\\n            array2.push(Math.floor(minute / 10), minute % 10)\\n        }\\n\\n        if (second < 10) {\\n            array2.push(0, second)\\n        } else {\\n            array2.push(Math.floor(second / 10), second % 10)\\n        }\\n        while (array2[0] === 0) {\\n            array2.shift()\\n        }\\n    }\\n    \\n    if (array1[0] < 10) {\\n        return [array1, array2]\\n    } else {\\n        return [array2, []]\\n    }\\n}\\n\\n\\n\\nvar minCostSetTime = function (startAt, moveCost, pushCost, targetSeconds) {\\n    \\n    times = fourDigitTime(targetSeconds)\\n\\n    let minCost1 = 0;\\n    let minCost2 = 0;\\n    // startAt = 0, moveCost = 2, pushCost = 1, targetSeconds = 500\\n    let firstTime = times[0]   // [1, 0, 0, 0]\\n    if (firstTime[0] !== startAt) minCost1+=moveCost;\\n    for (let i = 0; i < firstTime.length; i++) {\\n        minCost1 += pushCost;\\n        if (firstTime[i] !== firstTime[i + 1] && firstTime[i + 1] !== undefined) {\\n            minCost1 += moveCost;\\n            \\n        }\\n    }\\n\\n    if (times[1].length !== 0) {\\n        let secondTime = times[1]   // [1, 0, 0, 0]\\n        if (secondTime[0] !== startAt) minCost2+=moveCost;\\n        for (let i = 0; i < secondTime.length; i++) {\\n            minCost2 += pushCost;\\n            if (secondTime[i] !== secondTime[i + 1] && secondTime[i + 1] !== undefined) {\\n                minCost2 += moveCost;\\n            }\\n        }\\n        console.log(minCost1, minCost2)\\n        return Math.min(minCost1, minCost2)\\n    }\\n    \\n    return minCost1\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052043,
                "title": "easy-understanding-python",
                "content": "```\\n        choices = []\\n        \\n        mm = targetSeconds // 60\\n        ss = targetSeconds - mm * 60        \\n        if mm < 100:\\n            choices.append(str(mm if mm != 0 else \\'\\') + (str(ss).zfill(2) if mm > 0 else str(ss)))\\n        \\n        if mm > 0 and ss < 40: # 100 - 60\\n            mm -= 1\\n            ss += 60    \\n        if mm < 100:\\n            choices.append(str(mm if mm != 0 else \\'\\')  + (str(ss).zfill(2) if mm > 0 else str(ss)))\\n        \\n        min_cost = math.inf\\n        for choice in choices:\\n            prev = str(startAt)\\n            total_cost = 0\\n            \\n            for curr in choice:\\n                total_cost += moveCost if prev != curr else 0\\n                total_cost += pushCost\\n                prev = curr\\n\\n            min_cost = min(min_cost, total_cost)\\n\\n        return min_cost\\n```",
                "solutionTags": [],
                "code": "```\\n        choices = []\\n        \\n        mm = targetSeconds // 60\\n        ss = targetSeconds - mm * 60        \\n        if mm < 100:\\n            choices.append(str(mm if mm != 0 else \\'\\') + (str(ss).zfill(2) if mm > 0 else str(ss)))\\n        \\n        if mm > 0 and ss < 40: # 100 - 60\\n            mm -= 1\\n            ss += 60    \\n        if mm < 100:\\n            choices.append(str(mm if mm != 0 else \\'\\')  + (str(ss).zfill(2) if mm > 0 else str(ss)))\\n        \\n        min_cost = math.inf\\n        for choice in choices:\\n            prev = str(startAt)\\n            total_cost = 0\\n            \\n            for curr in choice:\\n                total_cost += moveCost if prev != curr else 0\\n                total_cost += pushCost\\n                prev = curr\\n\\n            min_cost = min(min_cost, total_cost)\\n\\n        return min_cost\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980499,
                "title": "easy-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void func(list<string>& l, string s) {\\n        if (s.length() == 4) {\\n            l.push_back(s);\\n            return;\\n        }\\n        for (char ch = \\'0\\';ch <= \\'9\\';++ch) {\\n            s.push_back(ch);\\n            func(l, s);\\n            s.pop_back();\\n        }\\n    }\\n\\n    bool feasible(const string& s, int tar) {\\n        int sec = stoi(s.substr(2, 2));\\n        int min = stoi(s.substr(0, 2));\\n        sec += min * 60;\\n        return sec == tar;\\n    }\\n\\n    int price(string& s, int move, int push, int start, int tar) {\\n        reverse(s.begin(), s.end());\\n        while (!s.empty() && s.back() == \\'0\\') s.pop_back();\\n        reverse(s.begin(), s.end());\\n        if (s.empty()) return 0;\\n        char pre = \\'0\\' + start;\\n        int res = 0;\\n        for (const char& ch : s) {\\n            if (ch != pre) {\\n                res += move;\\n                pre = ch;\\n            }\\n            res += push;\\n        }\\n        return res;\\n    }\\n\\n    int minCostSetTime(int start, int move, int push, int tar) {\\n        list<string>l;\\n        func(l, \"\");\\n        int res = INT_MAX;\\n        for (string& s : l)\\n            if (feasible(s, tar))\\n                res = min(res, price(s, move, push, start, tar));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(list<string>& l, string s) {\\n        if (s.length() == 4) {\\n            l.push_back(s);\\n            return;\\n        }\\n        for (char ch = \\'0\\';ch <= \\'9\\';++ch) {\\n            s.push_back(ch);\\n            func(l, s);\\n            s.pop_back();\\n        }\\n    }\\n\\n    bool feasible(const string& s, int tar) {\\n        int sec = stoi(s.substr(2, 2));\\n        int min = stoi(s.substr(0, 2));\\n        sec += min * 60;\\n        return sec == tar;\\n    }\\n\\n    int price(string& s, int move, int push, int start, int tar) {\\n        reverse(s.begin(), s.end());\\n        while (!s.empty() && s.back() == \\'0\\') s.pop_back();\\n        reverse(s.begin(), s.end());\\n        if (s.empty()) return 0;\\n        char pre = \\'0\\' + start;\\n        int res = 0;\\n        for (const char& ch : s) {\\n            if (ch != pre) {\\n                res += move;\\n                pre = ch;\\n            }\\n            res += push;\\n        }\\n        return res;\\n    }\\n\\n    int minCostSetTime(int start, int move, int push, int tar) {\\n        list<string>l;\\n        func(l, \"\");\\n        int res = INT_MAX;\\n        for (string& s : l)\\n            if (feasible(s, tar))\\n                res = min(res, price(s, move, push, start, tar));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937576,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int getCost(int curr, int moveCost, int pushCost, int tarMin, int tarSec) {\\n        string tar = (tarMin > 0 ? to_string(tarMin) : \"\") + (tarMin > 0 && tarSec < 10 ? \"0\" : \"\") + to_string(tarSec);\\n        int cost = 0;\\n        \\n        for (char &c : tar) {\\n            int val = c - \\'0\\';\\n            if (curr != val) {\\n                cost += moveCost;\\n                curr = val;\\n            }\\n            cost += pushCost;\\n        }\\n        return cost;\\n    }\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int res = INT_MAX;\\n        \\n        int miniute = targetSeconds > 100 ? (targetSeconds - 100) / 60 + 1 : 0;\\n        int seconds = targetSeconds - miniute * 60;\\n        while (miniute < 100 && seconds >= 0) {\\n            if (seconds < 100) {\\n                res = min(res, getCost(startAt, moveCost, pushCost, miniute, seconds));\\n            }\\n            seconds -= 60;\\n            miniute += 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getCost(int curr, int moveCost, int pushCost, int tarMin, int tarSec) {\\n        string tar = (tarMin > 0 ? to_string(tarMin) : \"\") + (tarMin > 0 && tarSec < 10 ? \"0\" : \"\") + to_string(tarSec);\\n        int cost = 0;\\n        \\n        for (char &c : tar) {\\n            int val = c - \\'0\\';\\n            if (curr != val) {\\n                cost += moveCost;\\n                curr = val;\\n            }\\n            cost += pushCost;\\n        }\\n        return cost;\\n    }\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int res = INT_MAX;\\n        \\n        int miniute = targetSeconds > 100 ? (targetSeconds - 100) / 60 + 1 : 0;\\n        int seconds = targetSeconds - miniute * 60;\\n        while (miniute < 100 && seconds >= 0) {\\n            if (seconds < 100) {\\n                res = min(res, getCost(startAt, moveCost, pushCost, miniute, seconds));\\n            }\\n            seconds -= 60;\\n            miniute += 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929105,
                "title": "the-description-wants-to-confuse-you",
                "content": "There are just two choices\\n\\n1. minutes and seconds \"naturally\"\\n2. `minutes - 1` and `seconds + 60`. -> *which i\\'ve never seen on a real device*\\n\\n```\\nclass Solution {\\n    fun minCostSetTime(startAt: Int, moveCost: Int, pushCost: Int, targetSeconds: Int): Int {\\n        fun checkCost(time: String) = time.dropWhile{it == \\'0\\'}.let{\\n            it.count()*pushCost + // push Costs\\n            (it.zipWithNext(){a,b -> a != b}.filter{it}.count() // moving from button to button costs\\n             + if (startAt.digitToChar() != it.first()) 1 else 0)*moveCost // +1 if not starting at the right button\\n        }\\n        val variant1 = if (targetSeconds < 6000) checkCost((targetSeconds/60).toString() + (targetSeconds%60).toString().padStart(2,\\'0\\')) else Int.MAX_VALUE // variant 1, like 10:00 in the first example\\n        val variant2 = if (targetSeconds >= 60 && (targetSeconds%60+60 < 100)) checkCost((targetSeconds/60-1).toString() + (targetSeconds%60+60).toString().padStart(2,\\'0\\')) else Int.MAX_VALUE // variant 2, like 9:60 in the first example\\n        return minOf(variant1, variant2)\\n    }\\n}\\n\\n// Leetcode seriously why do I pay you for premium? This part we only need because leetcode doesn\\'t bother to update kotlin and still uses a version belonging to pre industrialization times\\npublic fun Int.digitToChar(): Char {\\n    if (this in 0..9) {\\n        return \\'0\\' + this\\n    }\\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minCostSetTime(startAt: Int, moveCost: Int, pushCost: Int, targetSeconds: Int): Int {\\n        fun checkCost(time: String) = time.dropWhile{it == \\'0\\'}.let{\\n            it.count()*pushCost + // push Costs\\n            (it.zipWithNext(){a,b -> a != b}.filter{it}.count() // moving from button to button costs\\n             + if (startAt.digitToChar() != it.first()) 1 else 0)*moveCost // +1 if not starting at the right button\\n        }\\n        val variant1 = if (targetSeconds < 6000) checkCost((targetSeconds/60).toString() + (targetSeconds%60).toString().padStart(2,\\'0\\')) else Int.MAX_VALUE // variant 1, like 10:00 in the first example\\n        val variant2 = if (targetSeconds >= 60 && (targetSeconds%60+60 < 100)) checkCost((targetSeconds/60-1).toString() + (targetSeconds%60+60).toString().padStart(2,\\'0\\')) else Int.MAX_VALUE // variant 2, like 9:60 in the first example\\n        return minOf(variant1, variant2)\\n    }\\n}\\n\\n// Leetcode seriously why do I pay you for premium? This part we only need because leetcode doesn\\'t bother to update kotlin and still uses a version belonging to pre industrialization times\\npublic fun Int.digitToChar(): Char {\\n    if (this in 0..9) {\\n        return \\'0\\' + this\\n    }\\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857929,
                "title": "mincost-to-set-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int start , int move , int push , int left , int right)\\n    {\\n        \\n        int f1 = left/10 , f2 = left%10   , s1 = right/10 , s2 = right%10 ;\\n        int ans = 0;\\n        int check = start;\\n        \\n        if(f1)\\n        {\\n            ans+= (check==f1?0:move) + push;\\n            check = f1;\\n        }\\n        \\n        if(f1 || f2)\\n        {\\n            ans+= (check==f2?0:move) + push;\\n            check = f2;\\n        }\\n        \\n        if(f1||f2||s1)\\n        {\\n            ans+= (check==s1?0:move) + push;\\n            check = s1;\\n        }\\n        \\n        ans+= (check==s2?0:move) + push;\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n    {\\n        int ans = INT_MAX;\\n        if(targetSeconds<60)\\n        {\\n           return  solve(startAt , moveCost , pushCost ,  0 ,targetSeconds);\\n        }\\n        \\n        int left = targetSeconds/60 , right = targetSeconds%60;\\n        \\n        if(left<=99)\\n        {\\n           ans = solve(startAt , moveCost , pushCost ,  left , right);\\n        }\\n        \\n        left--;\\n        right+=60;\\n        if(right<=99)\\n        ans = min(ans , solve(startAt , moveCost , pushCost ,  left ,right));\\n    \\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int start , int move , int push , int left , int right)\\n    {\\n        \\n        int f1 = left/10 , f2 = left%10   , s1 = right/10 , s2 = right%10 ;\\n        int ans = 0;\\n        int check = start;\\n        \\n        if(f1)\\n        {\\n            ans+= (check==f1?0:move) + push;\\n            check = f1;\\n        }\\n        \\n        if(f1 || f2)\\n        {\\n            ans+= (check==f2?0:move) + push;\\n            check = f2;\\n        }\\n        \\n        if(f1||f2||s1)\\n        {\\n            ans+= (check==s1?0:move) + push;\\n            check = s1;\\n        }\\n        \\n        ans+= (check==s2?0:move) + push;\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds)\\n    {\\n        int ans = INT_MAX;\\n        if(targetSeconds<60)\\n        {\\n           return  solve(startAt , moveCost , pushCost ,  0 ,targetSeconds);\\n        }\\n        \\n        int left = targetSeconds/60 , right = targetSeconds%60;\\n        \\n        if(left<=99)\\n        {\\n           ans = solve(startAt , moveCost , pushCost ,  left , right);\\n        }\\n        \\n        left--;\\n        right+=60;\\n        if(right<=99)\\n        ans = min(ans , solve(startAt , moveCost , pushCost ,  left ,right));\\n    \\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852149,
                "title": "brute-force-no-trick-but-clear-logic",
                "content": "Step by step following the hints, no smart tricks.\\nI think this clean code might worth sharing.\\n\\n```\\nint cost(int mm, int ss, int idx, int mc, int pc)\\n{\\n\\t// use this array to represent the 4 digits.\\n\\tint mmss[4] = {mm / 10, mm % 10, ss / 10, ss % 10};\\n\\tint c = 0;\\n\\tint i = 0;\\n\\t\\n\\t// skip leading 0s, if there are any.\\n\\twhile (i < 4 && mmss[i] == 0)\\n\\t\\t++ i;\\n\\t\\n\\t// if (i == 4) ;\\n\\t// this should never happen according to constraints.\\n\\t\\n\\t// for the rest digits\\n\\twhile (i < 4)\\n\\t{\\n\\t\\t// if the digit differs from the current position of finger, i.e. *idx*, then it must move\\n\\t\\t// and thus produces cost.\\n\\t\\tif (idx != mmss[i])\\n\\t\\t{\\n\\t\\t\\tidx = mmss[i];\\n\\t\\t\\tc += mc;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// press the button with cost.\\n\\t\\tc += pc;\\n\\t\\t\\n\\t\\t// move to next digit.\\n\\t\\t++ i;\\n\\t}\\n\\t\\n\\treturn c;\\n}\\n\\nint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\tint ret = INT_MAX;\\n\\tint c = 0;\\n\\tint ss = targetSeconds;\\n\\t\\n\\t// Try every possible combination of mm and ss.\\n\\t// the mm goes from 00 to 99 and every time when mm increase 1, ss should decrease 60.\\n\\tfor (int mm = 0; mm < 100 && ss >= 0; ++mm, ss -= 60)\\n\\t{\\n\\t\\t// if there are more than 99 seconds left, this combination won\\'t work.\\n\\t\\tif (ss > 99)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// calculate the cost of each combination.\\n\\t\\tc = cost(mm, ss, startAt, moveCost, pushCost);\\n\\t\\t\\n\\t\\t// update the minimal cost.\\n\\t\\tret = min(ret, c);\\n\\t}\\n\\t\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cost(int mm, int ss, int idx, int mc, int pc)\\n{\\n\\t// use this array to represent the 4 digits.\\n\\tint mmss[4] = {mm / 10, mm % 10, ss / 10, ss % 10};\\n\\tint c = 0;\\n\\tint i = 0;\\n\\t\\n\\t// skip leading 0s, if there are any.\\n\\twhile (i < 4 && mmss[i] == 0)\\n\\t\\t++ i;\\n\\t\\n\\t// if (i == 4) ;\\n\\t// this should never happen according to constraints.\\n\\t\\n\\t// for the rest digits\\n\\twhile (i < 4)\\n\\t{\\n\\t\\t// if the digit differs from the current position of finger, i.e. *idx*, then it must move\\n\\t\\t// and thus produces cost.\\n\\t\\tif (idx != mmss[i])\\n\\t\\t{\\n\\t\\t\\tidx = mmss[i];\\n\\t\\t\\tc += mc;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// press the button with cost.\\n\\t\\tc += pc;\\n\\t\\t\\n\\t\\t// move to next digit.\\n\\t\\t++ i;\\n\\t}\\n\\t\\n\\treturn c;\\n}\\n\\nint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\tint ret = INT_MAX;\\n\\tint c = 0;\\n\\tint ss = targetSeconds;\\n\\t\\n\\t// Try every possible combination of mm and ss.\\n\\t// the mm goes from 00 to 99 and every time when mm increase 1, ss should decrease 60.\\n\\tfor (int mm = 0; mm < 100 && ss >= 0; ++mm, ss -= 60)\\n\\t{\\n\\t\\t// if there are more than 99 seconds left, this combination won\\'t work.\\n\\t\\tif (ss > 99)\\n\\t\\t\\tcontinue;\\n\\t\\t\\n\\t\\t// calculate the cost of each combination.\\n\\t\\tc = cost(mm, ss, startAt, moveCost, pushCost);\\n\\t\\t\\n\\t\\t// update the minimal cost.\\n\\t\\tret = min(ret, c);\\n\\t}\\n\\t\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851361,
                "title": "c-detailed-explanation-two-choices-2162",
                "content": "There are only two choices any one of them will be minimum because the zeroes will be prepended so for minutes less than 10 we can only use one push and remaining two pushes for seconds which will reduce the cost.\\n\\n1. Calculate the number of minutes and number of remaining seconds from the given target seconds\\n2. **First Choice:** As we have to enter atmost 4 digits so we cannot enter 100 minutes as target seconds can go beyond 100 minutes so we need to check if minutes are less than 100 then proceed to calculate the cost\\n3. **Second Choice:** If the minutes are greater than 0 and seconds are less than 40 (because atmost 99 seconds can be entered) we can enter one minute as 60 seconds and calculate the cost\\n4. To calculate the cost we pass the numbers to be entered as an integer for convinience and seperate them as digits later using an array then calculate the cost\\n5. Return minimum of both results if possible (As per the given constraints atleast one choice can happen)\\n\\n```\\nclass Solution {\\npublic:\\n    int getCost(int curr,int move,int push,int val){\\n        vector<int>v;\\n        while(val > 0){\\n            v.push_back(val%10);\\n            val = val/10;\\n        }\\n        int res = 0;\\n        for(int i=v.size()-1;i>=0;i--){\\n            if(curr != v[i]){res += move; curr = v[i];}\\n            res += push;\\n        }\\n        return res;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60,seconds = targetSeconds%60;\\n        int res = INT_MAX;\\n        if(minutes < 100){res = min(res,getCost(startAt,moveCost,pushCost,minutes*100 + seconds));}\\n        if(minutes>0 && seconds<40){res = min(res,getCost(startAt,moveCost,pushCost,(minutes-1)*100 + seconds+60));}\\n        return res;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCost(int curr,int move,int push,int val){\\n        vector<int>v;\\n        while(val > 0){\\n            v.push_back(val%10);\\n            val = val/10;\\n        }\\n        int res = 0;\\n        for(int i=v.size()-1;i>=0;i--){\\n            if(curr != v[i]){res += move; curr = v[i];}\\n            res += push;\\n        }\\n        return res;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minutes = targetSeconds/60,seconds = targetSeconds%60;\\n        int res = INT_MAX;\\n        if(minutes < 100){res = min(res,getCost(startAt,moveCost,pushCost,minutes*100 + seconds));}\\n        if(minutes>0 && seconds<40){res = min(res,getCost(startAt,moveCost,pushCost,(minutes-1)*100 + seconds+60));}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808311,
                "title": "java-simple-solution-process-degit-one-by-one",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        // how many minutes can we have?\\n        int res = Integer.MAX_VALUE;\\n        int minMin = (targetSeconds - 99) >= 0 ? (targetSeconds - 99) / 60 : 0;\\n        if((targetSeconds - 99) % 60 > 0) minMin++;\\n        int maxMin = (targetSeconds / 60) > 99 ? 99 : (targetSeconds / 60);\\n        for(int i = minMin; i <= maxMin; i++) {\\n            int[] arr = new int[4];\\n            int second = targetSeconds - 60 * i;\\n            arr[0] = i / 10;\\n            arr[1] = i % 10;\\n            arr[2] = second / 10;\\n            arr[3] = second % 10;\\n            // System.out.println(arr[0]+\" \"+arr[1]+\" \"+arr[2]+\" \"+arr[3]);\\n            int tmp = count(startAt, moveCost, pushCost, arr);\\n            // System.out.println(tmp);\\n            if(tmp < res) {\\n                res = tmp;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int count(int startAt, int moveCost, int pushCost, int[] arr) {\\n        int i = 0;\\n        int res = 0;\\n\\t\\t// Skip all the leading zeros\\n        while(i < 4 && arr[i] == 0) i++;\\n        int pre = startAt;\\n        while(i < 4) {\\n            res = (pre == arr[i]) ? (res + pushCost) : (res + pushCost + moveCost);\\n            pre = arr[i];\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        // how many minutes can we have?\\n        int res = Integer.MAX_VALUE;\\n        int minMin = (targetSeconds - 99) >= 0 ? (targetSeconds - 99) / 60 : 0;\\n        if((targetSeconds - 99) % 60 > 0) minMin++;\\n        int maxMin = (targetSeconds / 60) > 99 ? 99 : (targetSeconds / 60);\\n        for(int i = minMin; i <= maxMin; i++) {\\n            int[] arr = new int[4];\\n            int second = targetSeconds - 60 * i;\\n            arr[0] = i / 10;\\n            arr[1] = i % 10;\\n            arr[2] = second / 10;\\n            arr[3] = second % 10;\\n            // System.out.println(arr[0]+\" \"+arr[1]+\" \"+arr[2]+\" \"+arr[3]);\\n            int tmp = count(startAt, moveCost, pushCost, arr);\\n            // System.out.println(tmp);\\n            if(tmp < res) {\\n                res = tmp;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int count(int startAt, int moveCost, int pushCost, int[] arr) {\\n        int i = 0;\\n        int res = 0;\\n\\t\\t// Skip all the leading zeros\\n        while(i < 4 && arr[i] == 0) i++;\\n        int pre = startAt;\\n        while(i < 4) {\\n            res = (pre == arr[i]) ? (res + pushCost) : (res + pushCost + moveCost);\\n            pre = arr[i];\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802000,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 1e9+7;\\n    int getTime(int n)\\n    {\\n        int a = n%10;\\n        n=n/10;\\n        int b = n%10;\\n        n=n/10;\\n        int c = n%10;\\n        n=n/10;\\n        int d = n%10;\\n        int seconds = a+(10*b);\\n        int minutes = c+(10*d);\\n        return 60*minutes + seconds;\\n    }\\n    void dfs(int startAt, int moveCost, int pushCost, int targetSeconds, int counter, int time, int cost)\\n    {\\n        if(counter==4)\\n        {\\n            if(targetSeconds == getTime(time))\\n                ans=min(ans, cost);\\n            return;\\n        }\\n        if(targetSeconds == getTime(time))\\n                ans=min(ans, cost);\\n           // return;\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(i == startAt)\\n            {\\n                dfs(i, moveCost, pushCost, targetSeconds, counter + 1, time*10 + i, cost+pushCost);\\n            }\\n            else\\n            {\\n                dfs(i, moveCost, pushCost, targetSeconds, counter + 1, time*10 + i, cost+moveCost+pushCost);\\n            }\\n        }\\n        return;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        dfs(startAt, moveCost, pushCost, targetSeconds, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 1e9+7;\\n    int getTime(int n)\\n    {\\n        int a = n%10;\\n        n=n/10;\\n        int b = n%10;\\n        n=n/10;\\n        int c = n%10;\\n        n=n/10;\\n        int d = n%10;\\n        int seconds = a+(10*b);\\n        int minutes = c+(10*d);\\n        return 60*minutes + seconds;\\n    }\\n    void dfs(int startAt, int moveCost, int pushCost, int targetSeconds, int counter, int time, int cost)\\n    {\\n        if(counter==4)\\n        {\\n            if(targetSeconds == getTime(time))\\n                ans=min(ans, cost);\\n            return;\\n        }\\n        if(targetSeconds == getTime(time))\\n                ans=min(ans, cost);\\n           // return;\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(i == startAt)\\n            {\\n                dfs(i, moveCost, pushCost, targetSeconds, counter + 1, time*10 + i, cost+pushCost);\\n            }\\n            else\\n            {\\n                dfs(i, moveCost, pushCost, targetSeconds, counter + 1, time*10 + i, cost+moveCost+pushCost);\\n            }\\n        }\\n        return;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        dfs(startAt, moveCost, pushCost, targetSeconds, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797321,
                "title": "python-3-straightforward",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        minn=targetSeconds//60\\n        secc=targetSeconds%60\\n        if minn>99:\\n            minn=99\\n            secc+=60\\n        op2=-1\\n        if minn>0:\\n            if secc==0:\\n                op1=str(minn)+\"00\"\\n            elif secc<10:\\n                op1=str(minn)+\"0\"+str(secc)\\n            else:\\n                op1=str(minn)+str(secc)\\n            if secc<=39:\\n                if minn==1:\\n                    op2=str(secc+60)\\n                else:\\n                    op2=str(minn-1)+str(secc+60)\\n        else:\\n            if secc==0:\\n                return 0\\n            elif secc<10:\\n                op1=str(secc)\\n            else:\\n                op1=str(secc)\\n        cost=0\\n        prev=str(startAt)\\n        for c in list(op1):\\n            if c != prev:\\n                cost+=moveCost\\n                prev=c\\n            cost+=pushCost\\n        minCost=cost\\n        \\n        if op2!=-1:\\n            cost=0\\n            prev=str(startAt)\\n            for c in list(op2):\\n                if c != prev:\\n                    cost+=moveCost\\n                    prev=c\\n                cost+=pushCost\\n            minCost=min(minCost,cost)\\n        \\n        return minCost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        minn=targetSeconds//60\\n        secc=targetSeconds%60\\n        if minn>99:\\n            minn=99\\n            secc+=60\\n        op2=-1\\n        if minn>0:\\n            if secc==0:\\n                op1=str(minn)+\"00\"\\n            elif secc<10:\\n                op1=str(minn)+\"0\"+str(secc)\\n            else:\\n                op1=str(minn)+str(secc)\\n            if secc<=39:\\n                if minn==1:\\n                    op2=str(secc+60)\\n                else:\\n                    op2=str(minn-1)+str(secc+60)\\n        else:\\n            if secc==0:\\n                return 0\\n            elif secc<10:\\n                op1=str(secc)\\n            else:\\n                op1=str(secc)\\n        cost=0\\n        prev=str(startAt)\\n        for c in list(op1):\\n            if c != prev:\\n                cost+=moveCost\\n                prev=c\\n            cost+=pushCost\\n        minCost=cost\\n        \\n        if op2!=-1:\\n            cost=0\\n            prev=str(startAt)\\n            for c in list(op2):\\n                if c != prev:\\n                    cost+=moveCost\\n                    prev=c\\n                cost+=pushCost\\n            minCost=min(minCost,cost)\\n        \\n        return minCost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786658,
                "title": "python-simple-solution-99-55",
                "content": "Explanation:\\n    Get minutes and second using:  ```m, s = divmod(targetSeconds, 60)```\\n    We have max 2 ways to set the microwave:\\n* \\t`a) m minutes and s seconds, which can be represented as: m*100+s (e.g. 15 min 5 sec == 15*100+5 = 1505)`\\n* \\t`b) m-1 minutes and s+60 seconds, which can be represented as: (m-1)*100+(s+60) (e.g. 15 min 5 sec == 14*100+65 = 1465)`\\n    \\nand we have 4 special cases:\\n1. `when m==0, we can\\'t have -1 minutes so case b) should be skipped`\\n1. `when s>39, we can\\'t have 100 or more secs, because secs can take max 2 digits, so case b) should be skipped`\\n1. `when m>99, we can\\'t have 100 minutes, because mins can take max 2 digits, so case a) should be skipped`\\n1. `in all other cases bouth a) and b) are valid and we should compare cost of each case`\\n        \\nTo count total cost:\\n        We know that for each digit we need to spend `pushCost` units: `cost = pushCost*len(digits)`\\n        Then loop through digits and if curr digit is not equal to `startAt`,  spend `moveCost` units and change `startAt` to curr digit\\n    \\n\\t\\t\\n\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def totalCost(digits, startAt):\\n            cost = pushCost*len(digits)\\n            for digit in digits:\\n                if digit != startAt:\\n                    cost += moveCost\\n                    startAt = digit\\n            return cost\\n\\n        m, s = divmod(targetSeconds, 60)\\n        startAt = str(startAt)\\n        if m == 0 or s > 39:\\n            return totalCost(str(m*100+s), startAt)\\n        elif m > 99:\\n            return totalCost(str((m-1)*100+s+60), startAt)\\n        else:\\n            return min(totalCost(str(m*100+s), startAt), totalCost(str((m-1)*100+s+60), startAt))\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```m, s = divmod(targetSeconds, 60)```\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def totalCost(digits, startAt):\\n            cost = pushCost*len(digits)\\n            for digit in digits:\\n                if digit != startAt:\\n                    cost += moveCost\\n                    startAt = digit\\n            return cost\\n\\n        m, s = divmod(targetSeconds, 60)\\n        startAt = str(startAt)\\n        if m == 0 or s > 39:\\n            return totalCost(str(m*100+s), startAt)\\n        elif m > 99:\\n            return totalCost(str((m-1)*100+s+60), startAt)\\n        else:\\n            return min(totalCost(str(m*100+s), startAt), totalCost(str((m-1)*100+s+60), startAt))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776256,
                "title": "c-solution",
                "content": "Time O(len(pushCost)) Space O(4*2) = O(1)\\n```\\npublic class Solution {\\n    public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        var ts=new List<string>();\\n        int min=targetSeconds/60,sec=targetSeconds%60;\\n        ts.Add((min>0?(min).ToString():\"\")+((min>0&&sec<10)?\"0\":\"\")+(sec).ToString());\\n        if(ts[0].Length>4)\\n            ts.RemoveAt(0);\\n        if(min>0&&sec+60<=99)\\n            ts.Add(((min>1)?(min-1).ToString():\"\")+(sec+60).ToString());\\n        int ret=int.MaxValue;\\n        foreach(var t in ts)\\n        {\\n            Console.WriteLine(t);\\n            ret=Math.Min(ret,helper(t,startAt,moveCost,pushCost));\\n        }\\n        return ret;\\n    }\\n    public int helper(string str,int startAt,int moveCost,int pushCost)\\n    {\\n        int ret=0;\\n        for(int i=0;i<str.Length;i++)\\n        {\\n            int cur=str[i]-\\'0\\';\\n            ret+=(cur!=startAt)?moveCost:0;\\n            ret+=pushCost;\\n\\n            startAt=cur;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        var ts=new List<string>();\\n        int min=targetSeconds/60,sec=targetSeconds%60;\\n        ts.Add((min>0?(min).ToString():\"\")+((min>0&&sec<10)?\"0\":\"\")+(sec).ToString());\\n        if(ts[0].Length>4)\\n            ts.RemoveAt(0);\\n        if(min>0&&sec+60<=99)\\n            ts.Add(((min>1)?(min-1).ToString():\"\")+(sec+60).ToString());\\n        int ret=int.MaxValue;\\n        foreach(var t in ts)\\n        {\\n            Console.WriteLine(t);\\n            ret=Math.Min(ret,helper(t,startAt,moveCost,pushCost));\\n        }\\n        return ret;\\n    }\\n    public int helper(string str,int startAt,int moveCost,int pushCost)\\n    {\\n        int ret=0;\\n        for(int i=0;i<str.Length;i++)\\n        {\\n            int cur=str[i]-\\'0\\';\\n            ret+=(cur!=startAt)?moveCost:0;\\n            ret+=pushCost;\\n\\n            startAt=cur;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764976,
                "title": "javascript-simple-solution-explain",
                "content": "```\\nvar minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {   \\n    let min = [];\\n    let sec = [];\\n    const arrTime = [];\\n\\t\\n    // Format to min:sec\\n    min[0] = Math.floor(targetSeconds / 60).toString()\\n    sec[0] = (targetSeconds - min * 60).toString().padStart(2, \\'0\\');\\n   \\n   // Format to second way if has minute\\n    if(+sec + 60 < 100) {\\n        min[1] = min[0] - 1;\\n        sec[1] = +sec[0] + 60;\\n    }\\n    \\n\\t// Put to array time all potential format \\n    for(let i = 0; i < min.length; i++) {\\n        if(+min[i] > 99) continue;\\n        arrTime.push(`${min[i]}${sec[i]}`);\\n    }\\n    if(targetSeconds < 100) {\\n        arrTime.push(`${targetSeconds}`)\\n    }\\n    \\n    const resCount = []; // store count each time format\\n\\n    for(let j = 0; j < arrTime.length;j++) {\\n        let count = 0;\\n        let currAt = startAt;\\n        for(let i = 0; i < arrTime[j].length; i++) {\\n            if(currAt === +arrTime[j][i]) {\\n                count += pushCost\\n            } else {\\n                count += moveCost + pushCost;\\n                currAt = +arrTime[j][i];\\n            }\\n        }\\n        resCount.push(count)\\n    }\\n\\n    return Math.min(...resCount)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minCostSetTime = function(startAt, moveCost, pushCost, targetSeconds) {   \\n    let min = [];\\n    let sec = [];\\n    const arrTime = [];\\n\\t\\n    // Format to min:sec\\n    min[0] = Math.floor(targetSeconds / 60).toString()\\n    sec[0] = (targetSeconds - min * 60).toString().padStart(2, \\'0\\');\\n   \\n   // Format to second way if has minute\\n    if(+sec + 60 < 100) {\\n        min[1] = min[0] - 1;\\n        sec[1] = +sec[0] + 60;\\n    }\\n    \\n\\t// Put to array time all potential format \\n    for(let i = 0; i < min.length; i++) {\\n        if(+min[i] > 99) continue;\\n        arrTime.push(`${min[i]}${sec[i]}`);\\n    }\\n    if(targetSeconds < 100) {\\n        arrTime.push(`${targetSeconds}`)\\n    }\\n    \\n    const resCount = []; // store count each time format\\n\\n    for(let j = 0; j < arrTime.length;j++) {\\n        let count = 0;\\n        let currAt = startAt;\\n        for(let i = 0; i < arrTime[j].length; i++) {\\n            if(currAt === +arrTime[j][i]) {\\n                count += pushCost\\n            } else {\\n                count += moveCost + pushCost;\\n                currAt = +arrTime[j][i];\\n            }\\n        }\\n        resCount.push(count)\\n    }\\n\\n    return Math.min(...resCount)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761599,
                "title": "python3-brute-force-easy-and-readable",
                "content": "Brute force is accepted here\\nLoop through all the numbers where 0 < n < 10000 and if the current number matches targetSeconds then we check its total cost\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        best = float(\\'inf\\')\\n        \\n        def is_valid(i):\\n            m, s = int(i[:2]), int(i[2:])\\n            if m * 60 + s == targetSeconds:\\n                return True\\n            return False\\n            \\n        def get_value(x, s):\\n            cost = 0\\n            for char in x:\\n                if char != s:\\n                    cost += moveCost\\n                    s = char\\n                cost += pushCost\\n            return cost\\n        \\n        for i in range(10000):\\n            I = str(i).zfill(4)\\n            if is_valid(I):\\n                best = min(get_value(str(i), str(startAt)), best)\\n                \\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        best = float(\\'inf\\')\\n        \\n        def is_valid(i):\\n            m, s = int(i[:2]), int(i[2:])\\n            if m * 60 + s == targetSeconds:\\n                return True\\n            return False\\n            \\n        def get_value(x, s):\\n            cost = 0\\n            for char in x:\\n                if char != s:\\n                    cost += moveCost\\n                    s = char\\n                cost += pushCost\\n            return cost\\n        \\n        for i in range(10000):\\n            I = str(i).zfill(4)\\n            if is_valid(I):\\n                best = min(get_value(str(i), str(startAt)), best)\\n                \\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761491,
                "title": "brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> calCost(int& moveCost, int& pushCost, int startAt, string val) {\\n        int cost = 0;\\n        for(int i = 0 ; i<val.size(); i++) {\\n            int num = val[i]-\\'0\\';\\n            if (num != startAt) {\\n                startAt = num;\\n                cost += moveCost;\\n            }\\n            cost += pushCost;\\n        }\\n\\n        while(val.size() != 4) {\\n            val = \"0\" + val;\\n        }\\n        int seconds = (val[2] - \\'0\\') * 10 + (val[3] - \\'0\\')\\n            + ((val[0]-\\'0\\')*10 + (val[1]-\\'0\\')) * 60;\\n\\n        return {seconds, cost};\\n    }\\n    void generate(string val, int& startAt, int& moveCost, int& pushCost, int& minCost, int& targetSeconds, int counter = 0) {\\n        if(counter == 4) {\\n            auto data = calCost(moveCost, pushCost, startAt, val);\\n            if (data.first == targetSeconds) {\\n                minCost = min(minCost, data.second);\\n            }\\n            return ;\\n        }\\n\\n        generate(val, startAt, moveCost, pushCost, minCost, targetSeconds, counter + 1);\\n        for (int i = 0; i<10; i++) {\\n            generate(val + to_string(i), startAt, moveCost, pushCost, minCost, targetSeconds, counter + 1);\\n        }\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minCost = 1e9 + 7;\\n        generate(\"\", startAt, moveCost, pushCost, minCost, targetSeconds);\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> calCost(int& moveCost, int& pushCost, int startAt, string val) {\\n        int cost = 0;\\n        for(int i = 0 ; i<val.size(); i++) {\\n            int num = val[i]-\\'0\\';\\n            if (num != startAt) {\\n                startAt = num;\\n                cost += moveCost;\\n            }\\n            cost += pushCost;\\n        }\\n\\n        while(val.size() != 4) {\\n            val = \"0\" + val;\\n        }\\n        int seconds = (val[2] - \\'0\\') * 10 + (val[3] - \\'0\\')\\n            + ((val[0]-\\'0\\')*10 + (val[1]-\\'0\\')) * 60;\\n\\n        return {seconds, cost};\\n    }\\n    void generate(string val, int& startAt, int& moveCost, int& pushCost, int& minCost, int& targetSeconds, int counter = 0) {\\n        if(counter == 4) {\\n            auto data = calCost(moveCost, pushCost, startAt, val);\\n            if (data.first == targetSeconds) {\\n                minCost = min(minCost, data.second);\\n            }\\n            return ;\\n        }\\n\\n        generate(val, startAt, moveCost, pushCost, minCost, targetSeconds, counter + 1);\\n        for (int i = 0; i<10; i++) {\\n            generate(val + to_string(i), startAt, moveCost, pushCost, minCost, targetSeconds, counter + 1);\\n        }\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minCost = 1e9 + 7;\\n        generate(\"\", startAt, moveCost, pushCost, minCost, targetSeconds);\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760905,
                "title": "wrong-solution",
                "content": "Have a look it at this test case -\\n>startAt = 1\\n>moveCost = 5\\n>pushCost = 1\\n>TargetSeconds = 3\\n\\nThe Solution outcome is 6 - apparently, moving to position 3 (cost = 5) then pushing it (cost = 1)\\nMy Approach:\\nPush 1, the machine will register it as 1 second, do it 2 more times. Total cost = 3/-\\n\\nCorrect me if i am wrong ?",
                "solutionTags": [],
                "code": "Have a look it at this test case -\\n>startAt = 1\\n>moveCost = 5\\n>pushCost = 1\\n>TargetSeconds = 3\\n\\nThe Solution outcome is 6 - apparently, moving to position 3 (cost = 5) then pushing it (cost = 1)\\nMy Approach:\\nPush 1, the machine will register it as 1 second, do it 2 more times. Total cost = 3/-\\n\\nCorrect me if i am wrong ?",
                "codeTag": "Unknown"
            },
            {
                "id": 1760010,
                "title": "dew-it-simple-and-modular",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int start, int move, int push, int t) {\\n        int minutes = t/60, seconds = t%60;\\n        return Math.min(\\n            dewIt(start, move, push, minutes, seconds),\\n            dewIt(start, move, push, minutes - 1, seconds + 60)\\n        );\\n    }\\n    \\n    private int dewIt(int start, int move, int push, int minutes, int seconds) {\\n        if(minutes < -1 || minutes > 99 || seconds < -1 || seconds > 99)\\n            return Integer.MAX_VALUE;\\n        return compute(start, move, push, extractAllDigits(minutes, seconds));\\n    }\\n    \\n    private List<Integer> extractAllDigits(int a, int b) {\\n        List<Integer> list = extract(a, true, true);\\n        list.addAll(extract(b, false, list.isEmpty()));\\n        return list;\\n    }\\n    \\n    private List<Integer> extract(int n, boolean minutes, boolean noLeading) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        int maxDigCount = minutes ? 0 : (noLeading ? 1 : 2);\\n        for(int i=0; i<maxDigCount || n>0; ++i, n /= 10)\\n            list.addFirst(n % 10);\\n        return list;\\n    }\\n    \\n    private int compute(int last, int move, int push, List<Integer> list) {\\n        int ans = 0;\\n        for(int x: list) {\\n            if(x != last) {\\n                ans += move;\\n                last = x;\\n            }\\n            ans += push;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int start, int move, int push, int t) {\\n        int minutes = t/60, seconds = t%60;\\n        return Math.min(\\n            dewIt(start, move, push, minutes, seconds),\\n            dewIt(start, move, push, minutes - 1, seconds + 60)\\n        );\\n    }\\n    \\n    private int dewIt(int start, int move, int push, int minutes, int seconds) {\\n        if(minutes < -1 || minutes > 99 || seconds < -1 || seconds > 99)\\n            return Integer.MAX_VALUE;\\n        return compute(start, move, push, extractAllDigits(minutes, seconds));\\n    }\\n    \\n    private List<Integer> extractAllDigits(int a, int b) {\\n        List<Integer> list = extract(a, true, true);\\n        list.addAll(extract(b, false, list.isEmpty()));\\n        return list;\\n    }\\n    \\n    private List<Integer> extract(int n, boolean minutes, boolean noLeading) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        int maxDigCount = minutes ? 0 : (noLeading ? 1 : 2);\\n        for(int i=0; i<maxDigCount || n>0; ++i, n /= 10)\\n            list.addFirst(n % 10);\\n        return list;\\n    }\\n    \\n    private int compute(int last, int move, int push, List<Integer> list) {\\n        int ans = 0;\\n        for(int x: list) {\\n            if(x != last) {\\n                ans += move;\\n                last = x;\\n            }\\n            ans += push;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759275,
                "title": "python-1-find-possible-cases-then-follow-rules",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        \\n        minVal = sys.maxsize;\\n        cases = self.genCases( targetSeconds);\\n\\t\\t#find cases and calculate cost of each. Keep the cheapest each time:\\n        for case in cases:\\n            minVal = min( minVal, self.readCases( case, moveCost, pushCost, startAt ) );\\n        return minVal;\\n\\n    def genCases(self, sec ):\\n        cases = [];\\n        # Case where no adjustment is needed for minutes\\n        if sec <= 99:\\n            cases.append( str( sec ));\\n        \\n        #adjust for minutes where seconds is below 60\\n        if (sec//60) <= 99:\\n            cases.append( str( sec // 60 ) + str( sec % 60 ).zfill(2) );\\n            \\n        #adjust for minutes where seconds is between and including 60 - 99\\n        if (sec % 60) <= 39 and sec > 99:\\n            cases.append( str( ( sec - 60 ) // 60 ) + str( (sec % 60) + 60 ).zfill(2) );\\n        return cases;\\n    \\n    def readCases( self, case, mCost, pCost, startAt):\\n        total = 0;\\n        # prev keeps track of where the finger was last\\n        prev = str( startAt );\\n        for i in range( len ( case ) ):\\n            # if we are not at the digit of the last press. We add the moving cost\\n            if not (case[ i ] == prev):\\n                total += mCost;\\n            #we add the press cost and then assign prev to teh digit we just used\\n            total += pCost;\\n            prev = case[ i ];\\n        return total;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        \\n        minVal = sys.maxsize;\\n        cases = self.genCases( targetSeconds);\\n\\t\\t#find cases and calculate cost of each. Keep the cheapest each time:\\n        for case in cases:\\n            minVal = min( minVal, self.readCases( case, moveCost, pushCost, startAt ) );\\n        return minVal;\\n\\n    def genCases(self, sec ):\\n        cases = [];\\n        # Case where no adjustment is needed for minutes\\n        if sec <= 99:\\n            cases.append( str( sec ));\\n        \\n        #adjust for minutes where seconds is below 60\\n        if (sec//60) <= 99:\\n            cases.append( str( sec // 60 ) + str( sec % 60 ).zfill(2) );\\n            \\n        #adjust for minutes where seconds is between and including 60 - 99\\n        if (sec % 60) <= 39 and sec > 99:\\n            cases.append( str( ( sec - 60 ) // 60 ) + str( (sec % 60) + 60 ).zfill(2) );\\n        return cases;\\n    \\n    def readCases( self, case, mCost, pCost, startAt):\\n        total = 0;\\n        # prev keeps track of where the finger was last\\n        prev = str( startAt );\\n        for i in range( len ( case ) ):\\n            # if we are not at the digit of the last press. We add the moving cost\\n            if not (case[ i ] == prev):\\n                total += mCost;\\n            #we add the press cost and then assign prev to teh digit we just used\\n            total += pCost;\\n            prev = case[ i ];\\n        return total;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758788,
                "title": "cooking-time-as-string-80-speed",
                "content": "![image](https://assets.leetcode.com/users/images/484bb26b-df58-43d5-947f-dfb09edb400f_1644428963.3013275.png)\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        start_c, min_cost = str(startAt), inf\\n\\n        def cost(t: str) -> int:\\n            return (pushCost * len(t) + moveCost *\\n                    sum(a != b for a, b in zip(start_c + t, t)))\\n\\n        for minutes in range(max(0, targetSeconds - 99) // 60,\\n                             ceil(targetSeconds / 60) + 1):\\n            seconds = targetSeconds - minutes * 60\\n            if -1 < minutes < 100 and -1 < seconds < 100:\\n                set_time = str(minutes) if minutes else \"\"\\n                set_time += f\"{seconds:0>2d}\" if set_time else f\"{seconds}\"\\n                min_cost = min(min_cost, cost(set_time))\\n\\n        return min_cost\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        start_c, min_cost = str(startAt), inf\\n\\n        def cost(t: str) -> int:\\n            return (pushCost * len(t) + moveCost *\\n                    sum(a != b for a, b in zip(start_c + t, t)))\\n\\n        for minutes in range(max(0, targetSeconds - 99) // 60,\\n                             ceil(targetSeconds / 60) + 1):\\n            seconds = targetSeconds - minutes * 60\\n            if -1 < minutes < 100 and -1 < seconds < 100:\\n                set_time = str(minutes) if minutes else \"\"\\n                set_time += f\"{seconds:0>2d}\" if set_time else f\"{seconds}\"\\n                min_cost = min(min_cost, cost(set_time))\\n\\n        return min_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756138,
                "title": "bruteforce",
                "content": "Hard coded just to see how deep the rabbit hole goes LOL\\n\\nFor an elegant solution, you can refer to tojuna\\'s solution [here](https://leetcode.com/problems/minimum-cost-to-set-cooking-time/discuss/1746988/Python3-Java-C%2B%2B-Combinations-of-Minutes-and-Seconds-O(1)). The second approach is really neat!\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        combos = self.generateCombo(targetSeconds)\\n        scores = [self.calculateCost(startAt, moveCost, pushCost, combo) for combo in combos]\\n        return min(scores)     \\n    \\n    def calculateCost(self, start, moveCost, pushCost, combo):\\n        res = 0\\n        pressed = False\\n        # Pressing first_button only if it is non-zero\\n        if combo // 1000 > 0:\\n            pressed = True\\n            step_1 = combo // 1000\\n            if step_1 != start:\\n                res += moveCost\\n            res += pushCost\\n        \\n        combo %= 1000\\n        \\n        step_2 = combo // 100\\n        if pressed == True:\\n            if step_2 != step_1:\\n                res += moveCost\\n            res += pushCost\\n        if pressed == False:\\n            if step_2 == 0:\\n                pass\\n            else:\\n                pressed = True\\n                if step_2 != start:\\n                    res += moveCost\\n                res += pushCost\\n        \\n        combo %= 100\\n        \\n        step_3 = combo // 10\\n        if pressed == True:\\n            if step_3 != step_2:\\n                res += moveCost\\n            res += pushCost\\n        if pressed == False:\\n            if step_3 == 0:\\n                pass\\n            else:\\n                pressed = True\\n                if step_3 != start:\\n                    res += moveCost\\n                res += pushCost\\n        \\n        combo %= 10\\n        \\n        if pressed == True:\\n            if combo != step_3:\\n                res += moveCost\\n            res += pushCost\\n        if pressed == False:\\n            if combo == 0:\\n                pass\\n            else:\\n                pressed = True\\n                if combo != start:\\n                    res += moveCost\\n                res += pushCost\\n        \\n        return res\\n            \\n\\n    def generateCombo(self, targetSeconds):\\n        \\n        idx_1 = targetSeconds % 10\\n        targetSeconds -= idx_1\\n        \\n        if targetSeconds <= 50:\\n            idx_2 = [targetSeconds / 10]\\n            targetSeconds = [0]\\n        else:\\n            # means 60 or greater\\n            idx_2 = [(targetSeconds % 60)/10, (targetSeconds % 60)/10 + 6]\\n            targetSeconds = [targetSeconds - idx_2[0] * 10, targetSeconds - idx_2[1] * 10]\\n        \\n        if idx_2[-1] >= 10:\\n            idx_2.pop()\\n            targetSeconds.pop()\\n        \\n        first_two = []\\n        for num in targetSeconds:\\n            first_two.append(num / 60)\\n        \\n        res = []\\n        for i, j in zip(first_two, idx_2):\\n            res.append(int(i * 100 + j * 10 + idx_1))\\n        \\n        res = [num for num in res if num < 10000]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        combos = self.generateCombo(targetSeconds)\\n        scores = [self.calculateCost(startAt, moveCost, pushCost, combo) for combo in combos]\\n        return min(scores)     \\n    \\n    def calculateCost(self, start, moveCost, pushCost, combo):\\n        res = 0\\n        pressed = False\\n        # Pressing first_button only if it is non-zero\\n        if combo // 1000 > 0:\\n            pressed = True\\n            step_1 = combo // 1000\\n            if step_1 != start:\\n                res += moveCost\\n            res += pushCost\\n        \\n        combo %= 1000\\n        \\n        step_2 = combo // 100\\n        if pressed == True:\\n            if step_2 != step_1:\\n                res += moveCost\\n            res += pushCost\\n        if pressed == False:\\n            if step_2 == 0:\\n                pass\\n            else:\\n                pressed = True\\n                if step_2 != start:\\n                    res += moveCost\\n                res += pushCost\\n        \\n        combo %= 100\\n        \\n        step_3 = combo // 10\\n        if pressed == True:\\n            if step_3 != step_2:\\n                res += moveCost\\n            res += pushCost\\n        if pressed == False:\\n            if step_3 == 0:\\n                pass\\n            else:\\n                pressed = True\\n                if step_3 != start:\\n                    res += moveCost\\n                res += pushCost\\n        \\n        combo %= 10\\n        \\n        if pressed == True:\\n            if combo != step_3:\\n                res += moveCost\\n            res += pushCost\\n        if pressed == False:\\n            if combo == 0:\\n                pass\\n            else:\\n                pressed = True\\n                if combo != start:\\n                    res += moveCost\\n                res += pushCost\\n        \\n        return res\\n            \\n\\n    def generateCombo(self, targetSeconds):\\n        \\n        idx_1 = targetSeconds % 10\\n        targetSeconds -= idx_1\\n        \\n        if targetSeconds <= 50:\\n            idx_2 = [targetSeconds / 10]\\n            targetSeconds = [0]\\n        else:\\n            # means 60 or greater\\n            idx_2 = [(targetSeconds % 60)/10, (targetSeconds % 60)/10 + 6]\\n            targetSeconds = [targetSeconds - idx_2[0] * 10, targetSeconds - idx_2[1] * 10]\\n        \\n        if idx_2[-1] >= 10:\\n            idx_2.pop()\\n            targetSeconds.pop()\\n        \\n        first_two = []\\n        for num in targetSeconds:\\n            first_two.append(num / 60)\\n        \\n        res = []\\n        for i, j in zip(first_two, idx_2):\\n            res.append(int(i * 100 + j * 10 + idx_1))\\n        \\n        res = [num for num in res if num < 10000]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755930,
                "title": "python-naive-easy-understanding-solution",
                "content": "The very important thing we need to understand, \\nThere are only two time strings that is needed, rest are absurd.\\n\\nLets take an example,\\ntargetSeconds = 142\\npossible time strings are:\\n1. Take the highest minutes possible from the given targetSeconds\\n```=>  2 min 22 sec  | s = 222```\\n\\n2. Take the highest seconds possible from the given targetSeconds\\n```=>  1 min 82 sec | s = 182```\\n\\n\\nSo we only need to calculate the cost for these two only. Rest of all time strings are absurd right.\\nNow we have to decide the edge cases:\\n1. what if minutes is not 0 and seconds  is of single digit.\\nexample: 61 sec\\none possible way is ```=> 1 min 1 sec```\\nWe cant write 1 sec as only a SINGLE DIGIT we need to add 0 at the start\\n```=> 1 min 1 sec | s = 101```\\n\\n***Hope I am able to explain my approach. For any doubt please drop a comment.***\\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        \\n        \\n        def calculateCost(mins, secs):\\n            cost, st = 0, str(startAt)\\n            if mins > 99: return 9999999999\\n\\t\\t\\t# calculating the time string\\n            s = \\'\\'\\n            if mins: s += str(mins) + (\\'\\' if secs // 10 else \\'0\\')\\n            s += str(secs)\\n            #calculating the cost from time string \\'s\\'\\n            for i in s:\\n                cost += pushCost\\n                if i != st: cost += moveCost\\n                st = i\\n            \\n            return cost\\n            \\n            \\n        mins = targetSeconds // 60\\n        secs = targetSeconds % 60\\n        ans1 = calculateCost(mins, secs)              #first calculating the cost using the highest minutes possible\\n        \\n        if mins and secs + 60 < 100:             \\n            mins -= 1\\n            secs += 60\\n            ans2 = calculateCost(mins, secs)          #calculating the cost for highest second possible\\n            return min(ans1, ans2)\\n        return ans1\\n```",
                "solutionTags": [],
                "code": "```=>  2 min 22 sec  | s = 222```\n```=>  1 min 82 sec | s = 182```\n```=> 1 min 1 sec```\n```=> 1 min 1 sec | s = 101```\n```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        \\n        \\n        def calculateCost(mins, secs):\\n            cost, st = 0, str(startAt)\\n            if mins > 99: return 9999999999\\n\\t\\t\\t# calculating the time string\\n            s = \\'\\'\\n            if mins: s += str(mins) + (\\'\\' if secs // 10 else \\'0\\')\\n            s += str(secs)\\n            #calculating the cost from time string \\'s\\'\\n            for i in s:\\n                cost += pushCost\\n                if i != st: cost += moveCost\\n                st = i\\n            \\n            return cost\\n            \\n            \\n        mins = targetSeconds // 60\\n        secs = targetSeconds % 60\\n        ans1 = calculateCost(mins, secs)              #first calculating the cost using the highest minutes possible\\n        \\n        if mins and secs + 60 < 100:             \\n            mins -= 1\\n            secs += 60\\n            ans2 = calculateCost(mins, secs)          #calculating the cost for highest second possible\\n            return min(ans1, ans2)\\n        return ans1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755762,
                "title": "greedy-solution",
                "content": "we can ignore start with 0\\nso we can make as string(minute * 100 + seconds) and string((minute - 1) * 100 + seconds + 60) is best way\\n\\n```C++\\nclass Solution {\\n    int solution(int st, int& mv, int& push, int mi, int sec) {\\n        if(mi >= 100) return INT_MAX;\\n        string seq = to_string(mi * 100 + sec);\\n        int res = 0;\\n        for(auto& ch : seq) {\\n            if((ch & 0b1111) != st) res += mv;\\n            res += push;\\n            st = (ch & 0b1111);\\n        }\\n        return res;\\n    }\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mi = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        return min(solution(startAt, moveCost, pushCost, mi, sec),\\n                   mi and sec <= 39 ? solution(startAt, moveCost, pushCost, mi - 1, sec + 60) : INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\n    int solution(int st, int& mv, int& push, int mi, int sec) {\\n        if(mi >= 100) return INT_MAX;\\n        string seq = to_string(mi * 100 + sec);\\n        int res = 0;\\n        for(auto& ch : seq) {\\n            if((ch & 0b1111) != st) res += mv;\\n            res += push;\\n            st = (ch & 0b1111);\\n        }\\n        return res;\\n    }\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int mi = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        return min(solution(startAt, moveCost, pushCost, mi, sec),\\n                   mi and sec <= 39 ? solution(startAt, moveCost, pushCost, mi - 1, sec + 60) : INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755491,
                "title": "c-easy-solution-100-beat-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int m1 = targetSeconds/60;\\n        int s1= targetSeconds%60;\\n        string uu= to_string(s1);\\n        if(s1<10)\\n        {\\n            uu.insert(uu.begin(),\\'0\\');\\n        }\\n        string ss = to_string(m1)+uu;\\n        int ans1=INT_MAX;\\n        bool kk = false;\\n        int y = startAt;\\n        int ans2= INT_MAX;\\n        int ans3 = INT_MAX;\\n        if(m1<100)\\n        {\\n            ans1=0;\\n            for(int i=0;i<ss.size();i++)\\n            {\\n                if(ss[i]==\\'0\\' && kk==false)\\n                { \\n                    continue;\\n                }\\n                else\\n                {\\n                    kk=true;\\n                    if(ss[i]-\\'0\\'==y)\\n                    {\\n                        ans1+=pushCost;\\n                    }\\n                    else\\n                    {\\n                        ans1+=moveCost;\\n                        ans1+=pushCost;\\n                        y = ss[i]-\\'0\\';\\n                    }\\n                }\\n            }\\n        }\\n        if(s1<=39 && m1>=1)\\n        {\\n            int jj = m1-1;\\n            ans2=0;\\n            int oo=s1;\\n            oo+=60;\\n            string ll = to_string(jj)+to_string(oo);\\n            bool bb = false;\\n            y=startAt;\\n            for(int i=0;i<ll.size();i++)\\n            {\\n                if(ll[i]==\\'0\\' && bb==false)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bb=true;\\n                    if(ll[i]-\\'0\\'==y)\\n                    {\\n                        ans2+=pushCost;\\n                    }\\n                    else\\n                    {\\n                        ans2+=moveCost;\\n                        ans2+=pushCost;\\n                        y = ll[i]-\\'0\\';\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(targetSeconds<100)\\n        {\\n            ans3=0;\\n            string pp = to_string(targetSeconds);\\n            y=startAt;\\n            for(int i=0;i<pp.size();i++)\\n            {\\n                if(pp[i]-\\'0\\'==y)\\n                {\\n                    ans3+=pushCost;\\n                }\\n                else\\n                {\\n                    ans3+=moveCost;\\n                    ans3+=pushCost;\\n                    y = pp[i]-\\'0\\';\\n                }\\n            }\\n        }\\n        int oo = min(ans1,ans2);\\n        return min(oo,ans3);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int m1 = targetSeconds/60;\\n        int s1= targetSeconds%60;\\n        string uu= to_string(s1);\\n        if(s1<10)\\n        {\\n            uu.insert(uu.begin(),\\'0\\');\\n        }\\n        string ss = to_string(m1)+uu;\\n        int ans1=INT_MAX;\\n        bool kk = false;\\n        int y = startAt;\\n        int ans2= INT_MAX;\\n        int ans3 = INT_MAX;\\n        if(m1<100)\\n        {\\n            ans1=0;\\n            for(int i=0;i<ss.size();i++)\\n            {\\n                if(ss[i]==\\'0\\' && kk==false)\\n                { \\n                    continue;\\n                }\\n                else\\n                {\\n                    kk=true;\\n                    if(ss[i]-\\'0\\'==y)\\n                    {\\n                        ans1+=pushCost;\\n                    }\\n                    else\\n                    {\\n                        ans1+=moveCost;\\n                        ans1+=pushCost;\\n                        y = ss[i]-\\'0\\';\\n                    }\\n                }\\n            }\\n        }\\n        if(s1<=39 && m1>=1)\\n        {\\n            int jj = m1-1;\\n            ans2=0;\\n            int oo=s1;\\n            oo+=60;\\n            string ll = to_string(jj)+to_string(oo);\\n            bool bb = false;\\n            y=startAt;\\n            for(int i=0;i<ll.size();i++)\\n            {\\n                if(ll[i]==\\'0\\' && bb==false)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bb=true;\\n                    if(ll[i]-\\'0\\'==y)\\n                    {\\n                        ans2+=pushCost;\\n                    }\\n                    else\\n                    {\\n                        ans2+=moveCost;\\n                        ans2+=pushCost;\\n                        y = ll[i]-\\'0\\';\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(targetSeconds<100)\\n        {\\n            ans3=0;\\n            string pp = to_string(targetSeconds);\\n            y=startAt;\\n            for(int i=0;i<pp.size();i++)\\n            {\\n                if(pp[i]-\\'0\\'==y)\\n                {\\n                    ans3+=pushCost;\\n                }\\n                else\\n                {\\n                    ans3+=moveCost;\\n                    ans3+=pushCost;\\n                    y = pp[i]-\\'0\\';\\n                }\\n            }\\n        }\\n        int oo = min(ans1,ans2);\\n        return min(oo,ans3);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754439,
                "title": "generate-all-possible-time-representations-then-find-minimum",
                "content": "My approach was to first generate all possible and valid time representations for a given number of seconds (this was by far the hardest and most annoying part of this problem) then loop through all of the valid time representations and find the minimum cost (which was fairly straightforward).\\n\\n```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\t\\t// get all valid time representations for a given targetSeconds\\n        ArrayList<String> l = generateTime(targetSeconds);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t// for each time\\n        for(String s: l) {\\n            int cost = 0, pos = startAt;\\n\\t\\t\\t// loop through characters in current time\\n            for(char c: s.toCharArray()) {\\n\\t\\t\\t\\t// get position of the current character\\n                int cur = c - \\'0\\';\\n\\t\\t\\t\\t// if you\\'re currently not in that position add moveCost\\n                if(cur != pos)\\n                    cost += moveCost;\\n\\t\\t\\t\\t// add pushCost\\n                cost += pushCost;\\n\\t\\t\\t\\t// set current position to the position of the current character\\n                pos = cur;\\n            }\\n\\t\\t\\t// compare current cost with minimum cost\\n            min = Math.min(min, cost);\\n        }\\n        return min;\\n    }\\n    \\n    public ArrayList<String> generateTime(int targetSeconds) {\\n        ArrayList<String> l = new ArrayList<>();\\n\\t\\t// get maximum number of minutes possible given targetSeconds\\n        int minutes = targetSeconds / 60;\\n\\t\\t// loop through all possible minutes starting with minute 0\\n        for(int i = 0; i <= minutes && i < 100; i ++) {\\n\\t\\t\\t// calculate remaining seconds given current minute\\n            int min = i, sec = targetSeconds - 60*min;\\n\\t\\t\\t// per given conditions, seconds must be < 100\\n            if(sec >= 100) continue;\\n\\t\\t\\t// no need to add leading zeros; pressing leading zeros will needlessly increase the cost\\n            if(min == 0) l.add(sec + \"\");\\n\\t\\t\\t// e.g. 12:00 case\\n            else if(sec == 0) l.add(min + \"00\"); \\n\\t\\t\\t// e.g. 16:05 case\\n            else if(sec < 10) l.add(min + \"0\" + sec); \\n            else l.add(min + \"\" + sec);\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\t\\t// get all valid time representations for a given targetSeconds\\n        ArrayList<String> l = generateTime(targetSeconds);\\n        int min = Integer.MAX_VALUE;\\n\\t\\t// for each time\\n        for(String s: l) {\\n            int cost = 0, pos = startAt;\\n\\t\\t\\t// loop through characters in current time\\n            for(char c: s.toCharArray()) {\\n\\t\\t\\t\\t// get position of the current character\\n                int cur = c - \\'0\\';\\n\\t\\t\\t\\t// if you\\'re currently not in that position add moveCost\\n                if(cur != pos)\\n                    cost += moveCost;\\n\\t\\t\\t\\t// add pushCost\\n                cost += pushCost;\\n\\t\\t\\t\\t// set current position to the position of the current character\\n                pos = cur;\\n            }\\n\\t\\t\\t// compare current cost with minimum cost\\n            min = Math.min(min, cost);\\n        }\\n        return min;\\n    }\\n    \\n    public ArrayList<String> generateTime(int targetSeconds) {\\n        ArrayList<String> l = new ArrayList<>();\\n\\t\\t// get maximum number of minutes possible given targetSeconds\\n        int minutes = targetSeconds / 60;\\n\\t\\t// loop through all possible minutes starting with minute 0\\n        for(int i = 0; i <= minutes && i < 100; i ++) {\\n\\t\\t\\t// calculate remaining seconds given current minute\\n            int min = i, sec = targetSeconds - 60*min;\\n\\t\\t\\t// per given conditions, seconds must be < 100\\n            if(sec >= 100) continue;\\n\\t\\t\\t// no need to add leading zeros; pressing leading zeros will needlessly increase the cost\\n            if(min == 0) l.add(sec + \"\");\\n\\t\\t\\t// e.g. 12:00 case\\n            else if(sec == 0) l.add(min + \"00\"); \\n\\t\\t\\t// e.g. 16:05 case\\n            else if(sec < 10) l.add(min + \"0\" + sec); \\n            else l.add(min + \"\" + sec);\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753553,
                "title": "simple-solution-using-c",
                "content": "**Note that there are two ways to achieve the solution.**\\nEither the count is minutes and seconds or it is minutes + 1, seconds.\\nWe convert the cummulative time in seconds into string and then traverse the string and on each digit we reach, we will add cost of pushing button and also our job will be to check whether we are already at that digit or not. If not then we have to add cost of moving to the answer. Return the minimum of the two possible states by passing them in the helper method shown below.\\n**Please upvote if you like the solution.**\\n```\\nclass Solution {\\npublic:\\n    int helper(int start,int minutes,int seconds,int pushCost,int moveCost){\\n        if(min(minutes,seconds) < 0 || max(minutes,seconds) > 99)\\n            return INT_MAX;\\n        int ans = 0;\\n        string temp = to_string(minutes*100 + seconds);\\n        for(auto i : temp){\\n            ans += pushCost + (start == i - \\'0\\' ? 0 : moveCost);\\n            start = i - \\'0\\';\\n        }\\n        return ans;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int m = targetSeconds/60;\\n        int s = targetSeconds%60;\\n        return min(helper(startAt,m,s,pushCost,moveCost),helper(startAt,m - 1,s + 60,pushCost,moveCost));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int start,int minutes,int seconds,int pushCost,int moveCost){\\n        if(min(minutes,seconds) < 0 || max(minutes,seconds) > 99)\\n            return INT_MAX;\\n        int ans = 0;\\n        string temp = to_string(minutes*100 + seconds);\\n        for(auto i : temp){\\n            ans += pushCost + (start == i - \\'0\\' ? 0 : moveCost);\\n            start = i - \\'0\\';\\n        }\\n        return ans;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int m = targetSeconds/60;\\n        int s = targetSeconds%60;\\n        return min(helper(startAt,m,s,pushCost,moveCost),helper(startAt,m - 1,s + 60,pushCost,moveCost));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753169,
                "title": "simple-code",
                "content": "```\\nclass Solution {\\n        static private int func(int cur, int move, int push, int min, int sec) {\\n        char start = \\'0\\';\\n        start += cur;\\n        String mn = \"\", sc = \"\";\\n        if (min > 0)\\n            mn += min;\\n        if (!mn.isEmpty() || sec > 0)\\n            sc += sec;\\n        if(sc.equals(\"0\"))\\n            sc=\"00\";\\n        if(!mn.isEmpty() && sec<10)\\n            sc=\"0\"+sec;\\n        int res = 0;\\n        for (char ch : mn.toCharArray()) {\\n            if (ch != start) {\\n                start = ch;\\n                res += move;\\n            }\\n            res += push;\\n        }\\n        for (char ch : sc.toCharArray()) {\\n            if (ch != start) {\\n                start = ch;\\n                res += move;\\n            }\\n            res += push;\\n        }\\n        return res;\\n    }\\n\\n    static public int minCostSetTime(int start, int move, int push, int tar) {\\n        int min = tar / 60, sec = tar % 60;\\n        if (tar < 60)\\n            return func(start, move, push, min, sec);\\n        if (tar < 100)\\n            return Math.min(func(start, move, push, min, sec), func(start, move, push, min - 1, sec + 60));\\n        int res = Integer.MAX_VALUE;\\n        if (min < 100)\\n            res = Math.min(res, func(start, move, push, min, sec));\\n        --min;\\n        sec += 60;\\n        if(sec<100)\\n            res=Math.min(res, func(start, move, push, min, sec));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n        static private int func(int cur, int move, int push, int min, int sec) {\\n        char start = \\'0\\';\\n        start += cur;\\n        String mn = \"\", sc = \"\";\\n        if (min > 0)\\n            mn += min;\\n        if (!mn.isEmpty() || sec > 0)\\n            sc += sec;\\n        if(sc.equals(\"0\"))\\n            sc=\"00\";\\n        if(!mn.isEmpty() && sec<10)\\n            sc=\"0\"+sec;\\n        int res = 0;\\n        for (char ch : mn.toCharArray()) {\\n            if (ch != start) {\\n                start = ch;\\n                res += move;\\n            }\\n            res += push;\\n        }\\n        for (char ch : sc.toCharArray()) {\\n            if (ch != start) {\\n                start = ch;\\n                res += move;\\n            }\\n            res += push;\\n        }\\n        return res;\\n    }\\n\\n    static public int minCostSetTime(int start, int move, int push, int tar) {\\n        int min = tar / 60, sec = tar % 60;\\n        if (tar < 60)\\n            return func(start, move, push, min, sec);\\n        if (tar < 100)\\n            return Math.min(func(start, move, push, min, sec), func(start, move, push, min - 1, sec + 60));\\n        int res = Integer.MAX_VALUE;\\n        if (min < 100)\\n            res = Math.min(res, func(start, move, push, min, sec));\\n        --min;\\n        sec += 60;\\n        if(sec<100)\\n            res=Math.min(res, func(start, move, push, min, sec));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752908,
                "title": "differenct-combinations-for-a-particular-input",
                "content": "### *for a particular input of seconds it could be valued as min:seconds in different ways , and for one particular value differenct ways of representation can be there, for an example:- 8x60+02i.e, 482(INPUT) * 482 can be valued in min:sec as 8:02 or 7:60+2 i.e, 7:62 because here the seconds limit may go beyond 60 at max 99 , hence a particular value of seconds may be represented in two values of min:seconds if the secondsi.e, INPUT%60 is <=39 \\n### *and for one particular value there may exist different form example 8:02 can be represented as 08:02 but leading zeroes will always should be neglected as an extra digit will cost more only irrespective of finger location and cost  **\\n\\n```def removeLeadingzeroes(list1):\\n    x1=0\\n    while(1==1):\\n        if(list1[x1]==\"0\"):\\n            list1.pop(x1)\\n        else:\\n            break\\n            \\ndef evaluate(list1,start,move,push):\\n    \\n    removeLeadingzeroes(list1)\\n    s=\"\"\\n    for x in range(len(list1)):\\n        s+=str(list1[x])\\n    last=start\\n    count=0\\n    list1=list(s)\\n    removeLeadingzeroes(list1)\\n    s=\"\".join(list1)\\n    if(len(s)>=5):\\n        return(10**9)\\n    \\n    for x in range(len(s)):\\n        if(int(s[x])==last):\\n            count+=push\\n        else:\\n            count+=push+move\\n        last=int(s[x])\\n    return(count)\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        remainder=targetSeconds%60\\n        val1=10**9\\n        if(remainder<=39):\\n            #way1\\n            print(\"here\")\\n            minutes=targetSeconds//60\\n            seconds=targetSeconds%60\\n            if(minutes<=9 and minutes>=0):\\n                #way11\\n                string1=[]\\n                string1.append(0)\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                if(minutes==0):\\n                    string1=[]\\n                    if(seconds<=9):\\n                        string1.append(0)\\n                    string1.append(seconds)\\n                    val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            else:\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                \\n            #way2\\n            minutes=minutes-1\\n            if(minutes<0):\\n                return(val1)\\n            seconds=seconds+60\\n            if(minutes<=9):\\n                #way11\\n                string1=[]\\n                string1.append(0)\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                if(minutes==0):\\n                    string1=[]\\n                    if(seconds<=9):\\n                        string1.append(0)\\n                    string1.append(seconds)\\n                    val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            else:\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            \\n        else:\\n            minutes=targetSeconds//60\\n            seconds=targetSeconds%60\\n            print(minutes,seconds)\\n            if(minutes<=9):\\n                #way11\\n                string1=[]\\n                string1.append(0)\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                if(minutes==0):\\n                    string1=[]\\n                    if(seconds<=9):\\n                        string1.append(0)\\n                    string1.append(seconds)\\n                    val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            else:\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n        return(val1)``",
                "solutionTags": [],
                "code": "### *for a particular input of seconds it could be valued as min:seconds in different ways , and for one particular value differenct ways of representation can be there, for an example:- 8x60+02i.e, 482(INPUT) * 482 can be valued in min:sec as 8:02 or 7:60+2 i.e, 7:62 because here the seconds limit may go beyond 60 at max 99 , hence a particular value of seconds may be represented in two values of min:seconds if the secondsi.e, INPUT%60 is <=39 \\n### *and for one particular value there may exist different form example 8:02 can be represented as 08:02 but leading zeroes will always should be neglected as an extra digit will cost more only irrespective of finger location and cost  **\\n\\n```def removeLeadingzeroes(list1):\\n    x1=0\\n    while(1==1):\\n        if(list1[x1]==\"0\"):\\n            list1.pop(x1)\\n        else:\\n            break\\n            \\ndef evaluate(list1,start,move,push):\\n    \\n    removeLeadingzeroes(list1)\\n    s=\"\"\\n    for x in range(len(list1)):\\n        s+=str(list1[x])\\n    last=start\\n    count=0\\n    list1=list(s)\\n    removeLeadingzeroes(list1)\\n    s=\"\".join(list1)\\n    if(len(s)>=5):\\n        return(10**9)\\n    \\n    for x in range(len(s)):\\n        if(int(s[x])==last):\\n            count+=push\\n        else:\\n            count+=push+move\\n        last=int(s[x])\\n    return(count)\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        remainder=targetSeconds%60\\n        val1=10**9\\n        if(remainder<=39):\\n            #way1\\n            print(\"here\")\\n            minutes=targetSeconds//60\\n            seconds=targetSeconds%60\\n            if(minutes<=9 and minutes>=0):\\n                #way11\\n                string1=[]\\n                string1.append(0)\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                if(minutes==0):\\n                    string1=[]\\n                    if(seconds<=9):\\n                        string1.append(0)\\n                    string1.append(seconds)\\n                    val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            else:\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                \\n            #way2\\n            minutes=minutes-1\\n            if(minutes<0):\\n                return(val1)\\n            seconds=seconds+60\\n            if(minutes<=9):\\n                #way11\\n                string1=[]\\n                string1.append(0)\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                if(minutes==0):\\n                    string1=[]\\n                    if(seconds<=9):\\n                        string1.append(0)\\n                    string1.append(seconds)\\n                    val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            else:\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            \\n        else:\\n            minutes=targetSeconds//60\\n            seconds=targetSeconds%60\\n            print(minutes,seconds)\\n            if(minutes<=9):\\n                #way11\\n                string1=[]\\n                string1.append(0)\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n                if(minutes==0):\\n                    string1=[]\\n                    if(seconds<=9):\\n                        string1.append(0)\\n                    string1.append(seconds)\\n                    val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n            else:\\n                string1=[]\\n                string1.append(minutes)\\n                if(seconds<=9):\\n                    string1.append(0)\\n                string1.append(seconds)\\n                val1=min(val1,evaluate(string1,startAt,moveCost,pushCost))\\n        return(val1)``",
                "codeTag": "Java"
            },
            {
                "id": 1752650,
                "title": "java-sol-1ms",
                "content": "public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min=targetSeconds/60;\\n        int sec=targetSeconds%60;\\n        long cost=Integer.MAX_VALUE ;\\n        while(true){\\n            if(sec>99) break;\\n            int time=min*100+sec;\\n            \\n            String str=String.valueOf(time);\\n            if(str.length()<=4){\\n            char[] ch=str.toCharArray();\\n            int a=startAt;\\n            long ans=0;\\n            for(int i =0;i<ch.length;i++){\\n                int b=ch[i]-\\'0\\';\\n                if(b==a) ans+=pushCost;\\n                else {\\n                    ans +=(moveCost+pushCost);\\n                    a=b;\\n                }\\n            }\\n            cost=Math.min(cost,ans);\\n            //System.out.println(time+\" \"+ans); \\n            }\\n            min--;\\n            sec+=60;\\n        }\\n        return (int)(cost);\\n    }",
                "solutionTags": [],
                "code": "public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int min=targetSeconds/60;\\n        int sec=targetSeconds%60;\\n        long cost=Integer.MAX_VALUE ;\\n        while(true){\\n            if(sec>99) break;\\n            int time=min*100+sec;\\n            \\n            String str=String.valueOf(time);\\n            if(str.length()<=4){\\n            char[] ch=str.toCharArray();\\n            int a=startAt;\\n            long ans=0;\\n            for(int i =0;i<ch.length;i++){\\n                int b=ch[i]-\\'0\\';\\n                if(b==a) ans+=pushCost;\\n                else {\\n                    ans +=(moveCost+pushCost);\\n                    a=b;\\n                }\\n            }\\n            cost=Math.min(cost,ans);\\n            //System.out.println(time+\" \"+ans); \\n            }\\n            min--;\\n            sec+=60;\\n        }\\n        return (int)(cost);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1752173,
                "title": "perhaps-the-most-straight-forward-way",
                "content": "```\\nclass Solution {\\npublic:\\n   int minCostSetTime(int st, int mt, int pt, int ts) {\\n\\n    int m=0,s=0;\\n    \\n    int ans1=INT_MAX;\\n    int ans2=INT_MAX;\\n    \\n\\n\\n    m=ts/60;\\n    s=ts%60;\\n    char st1;\\n       string time;\\n     int c1=0,c2=0;\\n        if(m<=99){\\n\\n       \\n        st1=st+\\'0\\';\\n        time=\"\";\\n        if(m>0){\\n            time+=to_string(m);\\n            \\n            if(s<=9)\\n                time+=\\'0\\';\\n        }\\n        \\n        \\n        \\n        time+=to_string(s);\\n\\n        for(int i=0;i<time.length();i++){\\n\\n            if(time[i]!=st1){\\n               \\n                c1++;\\n                st1=time[i];\\n            }\\n            c2++;\\n        }\\n        cout<<time<<\" \";\\n\\n\\n\\n        ans1=c1*mt+c2*pt;\\n\\n        cout<<ans1<<endl;\\n    }\\n\\n    \\n\\n    \\n\\n    if(s+60<=99 && m>0){\\n\\n        m--;\\n        s=s+60;\\n        c1=0,c2=0;\\n        st1=st+\\'0\\';\\n        time=\"\";\\n        if(m>0)\\n        time+=to_string(m);\\n        \\n        time+=to_string(s);\\n\\n        for(int i=0;i<time.length();i++){\\n\\n            if(time[i]!=st1){\\n                c1++;\\n                st1=time[i];\\n            }\\n            c2++;\\n        }\\n        cout<<time<<\" \";\\n\\n        ans2=c1*mt+c2*pt;\\n        cout<<ans2<<endl;\\n\\n    }\\n\\n\\n\\n   \\n    \\n    return min(ans1,ans2);\\n    \\n        \\n}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int minCostSetTime(int st, int mt, int pt, int ts) {\\n\\n    int m=0,s=0;\\n    \\n    int ans1=INT_MAX;\\n    int ans2=INT_MAX;\\n    \\n\\n\\n    m=ts/60;\\n    s=ts%60;\\n    char st1;\\n       string time;\\n     int c1=0,c2=0;\\n        if(m<=99){\\n\\n       \\n        st1=st+\\'0\\';\\n        time=\"\";\\n        if(m>0){\\n            time+=to_string(m);\\n            \\n            if(s<=9)\\n                time+=\\'0\\';\\n        }\\n        \\n        \\n        \\n        time+=to_string(s);\\n\\n        for(int i=0;i<time.length();i++){\\n\\n            if(time[i]!=st1){\\n               \\n                c1++;\\n                st1=time[i];\\n            }\\n            c2++;\\n        }\\n        cout<<time<<\" \";\\n\\n\\n\\n        ans1=c1*mt+c2*pt;\\n\\n        cout<<ans1<<endl;\\n    }\\n\\n    \\n\\n    \\n\\n    if(s+60<=99 && m>0){\\n\\n        m--;\\n        s=s+60;\\n        c1=0,c2=0;\\n        st1=st+\\'0\\';\\n        time=\"\";\\n        if(m>0)\\n        time+=to_string(m);\\n        \\n        time+=to_string(s);\\n\\n        for(int i=0;i<time.length();i++){\\n\\n            if(time[i]!=st1){\\n                c1++;\\n                st1=time[i];\\n            }\\n            c2++;\\n        }\\n        cout<<time<<\" \";\\n\\n        ans2=c1*mt+c2*pt;\\n        cout<<ans2<<endl;\\n\\n    }\\n\\n\\n\\n   \\n    \\n    return min(ans1,ans2);\\n    \\n        \\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1751778,
                "title": "c-simple-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int fun(int t,int m,int s,int p,int moveCost) {\\n        int cost=0,z,q=m,k; \\n        while(q>=0) {\\n                k=t/pow(10,q);\\n                if(s!=k) \\n                    cost+=moveCost;\\n                s=k;\\n                z=pow(10,q);\\n                t=t%z;\\n                q--;\\n            }\\n        cost+=(m+1)*p;\\n        return cost;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int cost = 0, mini = targetSeconds / 60, sec = targetSeconds % 60, time = mini * 100 + sec, m = 0; /* m=(no.of digits in time)-1 */\\n             if (mini < 100) {\\n                if(mini >= 10)\\n                    m = 3;\\n                else if (mini > 0)\\n                    m = 2;\\n                else if(sec>=10)\\n\\t\\t\\t\\t\\tm = 1;\\n                cost = fun(time, m, startAt, pushCost, moveCost);\\n             }     \\n            if((mini > 0 && sec <= 39 )|| mini >= 100) {\\n                time = (mini - 1) * 100 + 60 + sec;\\n                if(mini - 1 >= 10)\\n                    m = 3;\\n                else if(mini - 1 > 0)\\n                    m = 2;\\n                else m = 1;\\n                int f = fun(time, m, startAt, pushCost, moveCost);\\n                if(cost>0)\\n                    cost = min( cost, f);\\n                else cost = f;\\n            }\\n         return cost;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1751566,
                "title": "java-solution-brute-force-o-9999",
                "content": "```\\n    class Solution {\\n        public int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) {\\n            int min = Integer.MAX_VALUE;\\n            for (int i = 0; i <= 9999; i++)\\n                if ((i / 100) * 60 + i % 100 == ts)\\n                    min = Math.min(min, f(new int[]{i < 1000 ? -1 : i / 1000, i < 100 ? -1 : (i % 1000) / 100, i < 10 ? -1 : (i % 100) / 10, i % 10}, startAt, moveCost, pushCost));\\n            return min;\\n        }\\n\\n        int f(int[] arr, int st, int mo, int pu) {\\n            int cur = st;\\n            int cost = 0;\\n            for (int i = 0; i < arr.length; i++) {\\n                if (arr[i] < 0) continue;\\n                if (arr[i] != cur) cost += mo;\\n                cost += pu;\\n                cur = arr[i];\\n            }\\n            return cost;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n        public int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) {\\n            int min = Integer.MAX_VALUE;\\n            for (int i = 0; i <= 9999; i++)\\n                if ((i / 100) * 60 + i % 100 == ts)\\n                    min = Math.min(min, f(new int[]{i < 1000 ? -1 : i / 1000, i < 100 ? -1 : (i % 1000) / 100, i < 10 ? -1 : (i % 100) / 10, i % 10}, startAt, moveCost, pushCost));\\n            return min;\\n        }\\n\\n        int f(int[] arr, int st, int mo, int pu) {\\n            int cur = st;\\n            int cost = 0;\\n            for (int i = 0; i < arr.length; i++) {\\n                if (arr[i] < 0) continue;\\n                if (arr[i] != cur) cost += mo;\\n                cost += pu;\\n                cur = arr[i];\\n            }\\n            return cost;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751465,
                "title": "golang-0ms-solution",
                "content": "```go\\nfunc minCostSetTime(startAt int, moveCost int, pushCost int, targetSeconds int) int {\\n\\tminutes1, seconds1, cost1, cost2 := targetSeconds/60, targetSeconds%60, math.MaxInt32, math.MaxInt32\\n\\tif minutes1 < 100 {\\n\\t\\t// I got WA here, minutes1 must less than 100 :(\\n\\t\\tcost1 = minCostSetTimeHelper(startAt, moveCost, pushCost, minutes1, seconds1)\\n\\t}\\n\\tif seconds1 <= 39 && minutes1 > 0 {\\n\\t\\tminutes2, seconds2 := minutes1-1, seconds1+60\\n\\t\\tcost2 = minCostSetTimeHelper(startAt, moveCost, pushCost, minutes2, seconds2)\\n\\t}\\n\\treturn min(cost1, cost2)\\n}\\n\\nfunc minCostSetTimeHelper(fingerAt, moveCost, pushCost, targetMinutes, targetSeconds int) int {\\n\\tcost := 0\\n\\tif targetMinutes > 0 {\\n\\t\\thigh, low := targetMinutes/10, targetMinutes%10\\n\\t\\tif high != 0 {\\n\\t\\t\\tif high != fingerAt {\\n\\t\\t\\t\\tcost += moveCost\\n\\t\\t\\t\\tfingerAt = high\\n\\t\\t\\t}\\n\\t\\t\\tcost += pushCost\\n\\t\\t}\\n\\t\\tif low != fingerAt {\\n\\t\\t\\tcost += moveCost\\n\\t\\t\\tfingerAt = low\\n\\t\\t}\\n\\t\\tcost += pushCost\\n\\t}\\n\\thigh, low := targetSeconds/10, targetSeconds%10\\n\\tif high != 0 || (high == 0 && targetMinutes != 0) {\\n\\t\\tif high != fingerAt {\\n\\t\\t\\tcost += moveCost\\n\\t\\t\\tfingerAt = high\\n\\t\\t}\\n\\t\\tcost += pushCost\\n\\t}\\n\\tif low != fingerAt {\\n\\t\\tcost += moveCost\\n\\t\\tfingerAt = low\\n\\t}\\n\\tcost += pushCost\\n\\treturn cost\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minCostSetTime(startAt int, moveCost int, pushCost int, targetSeconds int) int {\\n\\tminutes1, seconds1, cost1, cost2 := targetSeconds/60, targetSeconds%60, math.MaxInt32, math.MaxInt32\\n\\tif minutes1 < 100 {\\n\\t\\t// I got WA here, minutes1 must less than 100 :(\\n\\t\\tcost1 = minCostSetTimeHelper(startAt, moveCost, pushCost, minutes1, seconds1)\\n\\t}\\n\\tif seconds1 <= 39 && minutes1 > 0 {\\n\\t\\tminutes2, seconds2 := minutes1-1, seconds1+60\\n\\t\\tcost2 = minCostSetTimeHelper(startAt, moveCost, pushCost, minutes2, seconds2)\\n\\t}\\n\\treturn min(cost1, cost2)\\n}\\n\\nfunc minCostSetTimeHelper(fingerAt, moveCost, pushCost, targetMinutes, targetSeconds int) int {\\n\\tcost := 0\\n\\tif targetMinutes > 0 {\\n\\t\\thigh, low := targetMinutes/10, targetMinutes%10\\n\\t\\tif high != 0 {\\n\\t\\t\\tif high != fingerAt {\\n\\t\\t\\t\\tcost += moveCost\\n\\t\\t\\t\\tfingerAt = high\\n\\t\\t\\t}\\n\\t\\t\\tcost += pushCost\\n\\t\\t}\\n\\t\\tif low != fingerAt {\\n\\t\\t\\tcost += moveCost\\n\\t\\t\\tfingerAt = low\\n\\t\\t}\\n\\t\\tcost += pushCost\\n\\t}\\n\\thigh, low := targetSeconds/10, targetSeconds%10\\n\\tif high != 0 || (high == 0 && targetMinutes != 0) {\\n\\t\\tif high != fingerAt {\\n\\t\\t\\tcost += moveCost\\n\\t\\t\\tfingerAt = high\\n\\t\\t}\\n\\t\\tcost += pushCost\\n\\t}\\n\\tif low != fingerAt {\\n\\t\\tcost += moveCost\\n\\t\\tfingerAt = low\\n\\t}\\n\\tcost += pushCost\\n\\treturn cost\\n}\\n\\nfunc min(values ...int) int {\\n\\tminValue := math.MaxInt64\\n\\tfor _, v := range values {\\n\\t\\tif v < minValue {\\n\\t\\t\\tminValue = v\\n\\t\\t}\\n\\t}\\n\\treturn minValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1750815,
                "title": "python-o-1",
                "content": "```\\nclass Solution:                       \\n    def calculate_cost(self, mins, secs, curr_at):            \\n        time = str(mins * 100 + secs)\\n        result = self.costs[0] * len(time)\\n        for d in time:\\n            if curr_at != int(d): result += self.costs[1]\\n            curr_at = int(d)            \\n        return result\\n    \\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        minutes = targetSeconds // 60\\n        seconds = targetSeconds % 60\\n        self.costs = [pushCost,moveCost]\\n        \\n        min_cost = math.inf\\n\\n        if seconds + 60 <= 99 and minutes - 1 >= 0: \\n            min_cost = min(min_cost, self.calculate_cost(minutes - 1, seconds + 60, startAt))\\n        if max(seconds, minutes) <= 99:         \\n            min_cost = min(min_cost, self.calculate_cost(minutes, seconds, startAt))\\n                                        \\n        return min_cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:                       \\n    def calculate_cost(self, mins, secs, curr_at):            \\n        time = str(mins * 100 + secs)\\n        result = self.costs[0] * len(time)\\n        for d in time:\\n            if curr_at != int(d): result += self.costs[1]\\n            curr_at = int(d)            \\n        return result\\n    \\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        minutes = targetSeconds // 60\\n        seconds = targetSeconds % 60\\n        self.costs = [pushCost,moveCost]\\n        \\n        min_cost = math.inf\\n\\n        if seconds + 60 <= 99 and minutes - 1 >= 0: \\n            min_cost = min(min_cost, self.calculate_cost(minutes - 1, seconds + 60, startAt))\\n        if max(seconds, minutes) <= 99:         \\n            min_cost = min(min_cost, self.calculate_cost(minutes, seconds, startAt))\\n                                        \\n        return min_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750635,
                "title": "faster-100-less-code-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n\\t\\t{\\n\\t\\t\\tint mn = 1e9;\\n\\t\\t\\tfor(int i=0 ; i<=9 ; i++)\\n\\t\\t\\t\\tfor(int j=0 ; j<=9 ; j++)\\n\\t\\t\\t\\t\\tfor(int k=0 ; k<=9 ; k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint x = (i * 10 + j) * 60 + k * 10;\\n\\t\\t\\t\\t\\t\\t\\tint l = targetSeconds - x; \\n\\t\\t\\t\\t\\t\\t\\tif(l >= 0 && l <= 9) \\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i)? 0 : (i == startAt)? pushCost : pushCost + moveCost;\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i && !j)? 0 : (!i && j)? ((j==startAt)? pushCost : moveCost+pushCost) : (i==j)?pushCost : moveCost+pushCost;\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i && !j && !k)? 0 : (!i && !j && k)? ((k==startAt)? pushCost : moveCost+pushCost) : (k==j)?pushCost : moveCost+pushCost;\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i && !j && !k && !l)?0: (!i&&!j&&!k&&l)?((l==startAt)? pushCost : moveCost+pushCost) : (k==l)?pushCost : moveCost+pushCost;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmn = min(mn, ans);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn mn;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n\\t\\t{\\n\\t\\t\\tint mn = 1e9;\\n\\t\\t\\tfor(int i=0 ; i<=9 ; i++)\\n\\t\\t\\t\\tfor(int j=0 ; j<=9 ; j++)\\n\\t\\t\\t\\t\\tfor(int k=0 ; k<=9 ; k++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint x = (i * 10 + j) * 60 + k * 10;\\n\\t\\t\\t\\t\\t\\t\\tint l = targetSeconds - x; \\n\\t\\t\\t\\t\\t\\t\\tif(l >= 0 && l <= 9) \\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i)? 0 : (i == startAt)? pushCost : pushCost + moveCost;\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i && !j)? 0 : (!i && j)? ((j==startAt)? pushCost : moveCost+pushCost) : (i==j)?pushCost : moveCost+pushCost;\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i && !j && !k)? 0 : (!i && !j && k)? ((k==startAt)? pushCost : moveCost+pushCost) : (k==j)?pushCost : moveCost+pushCost;\\n\\t\\t\\t\\t\\t\\t\\t\\tans += (!i && !j && !k && !l)?0: (!i&&!j&&!k&&l)?((l==startAt)? pushCost : moveCost+pushCost) : (k==l)?pushCost : moveCost+pushCost;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmn = min(mn, ans);\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1750453,
                "title": "c-2162-minimum-cost-to-set-cooking-time",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minute = targetSeconds/60, second = targetSeconds%60; \\n        int ans = INT_MAX; \\n        for (auto& [m, s] : vector<pair<int, int>>{{minute, second}, {minute-1, second+60}}) {\\n            if (0 <= m && m < 100 && s < 100) {\\n                int cost = 0, prev = startAt; \\n                bool found = false; \\n                for (auto& x : {m/10, m%10, s/10, s%10}) \\n                    if (x || found) {\\n                        if (x != prev) {cost += moveCost; prev = x;}\\n                        cost += pushCost; \\n                        found = true; \\n                    }\\n                ans = min(ans, cost); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minute = targetSeconds/60, second = targetSeconds%60; \\n        int ans = INT_MAX; \\n        for (auto& [m, s] : vector<pair<int, int>>{{minute, second}, {minute-1, second+60}}) {\\n            if (0 <= m && m < 100 && s < 100) {\\n                int cost = 0, prev = startAt; \\n                bool found = false; \\n                for (auto& x : {m/10, m%10, s/10, s%10}) \\n                    if (x || found) {\\n                        if (x != prev) {cost += moveCost; prev = x;}\\n                        cost += pushCost; \\n                        found = true; \\n                    }\\n                ans = min(ans, cost); \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750365,
                "title": "0ms-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getCost(int s,int move, int push, int mini, int sec)\\n    {\\n        int ans=0;\\n        int target=(mini*100)+sec;\\n        vector<int> a;\\n        while(target)\\n        {\\n            a.push_back(target%10);\\n            target/=10;\\n        }\\n        reverse(a.begin(),a.end());\\n        int n=a.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(a[i]==s)\\n            {\\n                ans=ans+push;\\n            }\\n            else\\n            {\\n                ans=ans+(move+push);\\n                s=a[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) {\\n       int ans=INT_MAX;\\n       int mini=ts/60;\\n            int sec=ts%60;\\n       if(ts>99)\\n       {\\n           \\n           if(mini<=99)\\n           {\\n               ans=min(ans,getCost(startAt, moveCost, pushCost, mini, sec));\\n           }\\n           mini=mini-1;\\n           sec=sec+60;\\n           if(sec<=99)\\n           {\\n               ans=min(ans,getCost(startAt, moveCost, pushCost, mini, sec));\\n           }\\n       }\\n        else\\n        {\\n            ans=min(ans,getCost(startAt, moveCost, pushCost, 0, ts));\\n            if(ts>=60)\\n            {\\n                 ans=min(ans,getCost(startAt, moveCost, pushCost, 1, sec));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCost(int s,int move, int push, int mini, int sec)\\n    {\\n        int ans=0;\\n        int target=(mini*100)+sec;\\n        vector<int> a;\\n        while(target)\\n        {\\n            a.push_back(target%10);\\n            target/=10;\\n        }\\n        reverse(a.begin(),a.end());\\n        int n=a.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(a[i]==s)\\n            {\\n                ans=ans+push;\\n            }\\n            else\\n            {\\n                ans=ans+(move+push);\\n                s=a[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int ts) {\\n       int ans=INT_MAX;\\n       int mini=ts/60;\\n            int sec=ts%60;\\n       if(ts>99)\\n       {\\n           \\n           if(mini<=99)\\n           {\\n               ans=min(ans,getCost(startAt, moveCost, pushCost, mini, sec));\\n           }\\n           mini=mini-1;\\n           sec=sec+60;\\n           if(sec<=99)\\n           {\\n               ans=min(ans,getCost(startAt, moveCost, pushCost, mini, sec));\\n           }\\n       }\\n        else\\n        {\\n            ans=min(ans,getCost(startAt, moveCost, pushCost, 0, ts));\\n            if(ts>=60)\\n            {\\n                 ans=min(ans,getCost(startAt, moveCost, pushCost, 1, sec));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750190,
                "title": "my-solution-pass-only-212-225-help-why",
                "content": "class Solution {\\n    public int getTime(String currTime,int startAt,int moveCost,int pushCost){\\n       int currPos = startAt;\\n        int cost =0;\\n       for(char c: currTime.toCharArray()){\\n           cost+= pushCost;\\n           int requried_pos = c-\\'0\\';\\n           if(requried_pos != currPos){\\n               cost+= moveCost;\\n               currPos = requried_pos;\\n           }\\n       }\\n        return cost;\\n    }\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int ans = Integer.MAX_VALUE;\\n        for(char pos1=\\'0\\';pos1<=\\'9\\';pos1++){\\n            for(char pos2=\\'0\\';pos2<=\\'9\\';pos2++){\\n            for(char pos3=\\'0\\';pos3<=\\'9\\';pos3++){\\n            for(char pos4=\\'0\\';pos4<=\\'9\\';pos4++){\\n                \\n                int total_second = ((pos1 -\\'0\\')*10 + (pos2 -\\'0\\'))*60 + (pos3-\\'0\\')*10 + (pos4-\\'0\\');\\n                \\n                if(total_second != targetSeconds){\\n                    continue;\\n                }\\n                \\n                String currTime =\"\";\\n                currTime += pos1;\\n                currTime += pos2;\\n                currTime += pos3;\\n                currTime += pos4;\\n                ans = Math.min(ans,getTime(currTime,startAt,moveCost,pushCost));\\n                \\n                while(!currTime.isEmpty() && currTime.charAt(0) == \\'0\\'){\\n                    currTime = currTime.replace(\"0\",\"\");\\n                     ans = Math.min(ans,getTime(currTime,startAt,moveCost,pushCost));\\n                }\\n            \\n        }\\n        }\\n        }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getTime(String currTime,int startAt,int moveCost,int pushCost){\\n       int currPos = startAt;\\n        int cost =0;\\n       for(char c: currTime.toCharArray()){\\n           cost+= pushCost;\\n           int requried_pos = c-\\'0\\';\\n           if(requried_pos != currPos){\\n               cost+= moveCost;\\n               currPos = requried_pos;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1750157,
                "title": "clear-bfs-solution-python",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def convert(s):\\n            # converts time string into seconds\\n            sec, minutes = int(s[:2][::-1]) if s[:2] else 0, int(s[2:][::-1]) if s[2:] else 0\\n            return sec+minutes*60\\n        \\n        q = deque([[\"\", startAt, 0]])\\n        ans = float(\\'inf\\')\\n        while q:\\n            time, pos, cost = q.popleft()\\n\\n            #convert time, if time > target, skip\\n            curSec = convert(time)\\n            if curSec == targetSeconds:\\n                ans = min(cost, ans)\\n            elif curSec < targetSeconds and len(time) < 4:\\n                #try all ways\\n                for i in range(10):\\n                    if i != pos:\\n                        q.append([str(i)+time, i, cost+moveCost+pushCost])\\n                q.append([str(pos)+time, pos, cost+pushCost])\\n                \\n        return ans\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, targetSeconds: int) -> int:\\n        def convert(s):\\n            # converts time string into seconds\\n            sec, minutes = int(s[:2][::-1]) if s[:2] else 0, int(s[2:][::-1]) if s[2:] else 0\\n            return sec+minutes*60\\n        \\n        q = deque([[\"\", startAt, 0]])\\n        ans = float(\\'inf\\')\\n        while q:\\n            time, pos, cost = q.popleft()\\n\\n            #convert time, if time > target, skip\\n            curSec = convert(time)\\n            if curSec == targetSeconds:\\n                ans = min(cost, ans)\\n            elif curSec < targetSeconds and len(time) < 4:\\n                #try all ways\\n                for i in range(10):\\n                    if i != pos:\\n                        q.append([str(i)+time, i, cost+moveCost+pushCost])\\n                q.append([str(pos)+time, pos, cost+pushCost])\\n                \\n        return ans\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750094,
                "title": "java-generate-all-possible-combinations",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        List<String> list = new ArrayList<>();\\n        if(targetSeconds<10){\\n            list.add(\"\"+targetSeconds);\\n        }\\n        for(int x = 0;x<100;x++){\\n            for(int y = 0;y<=99;y++){\\n                if(60*x+y == targetSeconds){\\n                  //  System.out.println(x+\" \"+y);\\n                    String toAppend = (y<10?\"0\"+y:y+\"\");\\n                    if(x==0){\\n                        list.add(x+\"\"+toAppend );\\n                        list.add(\"0\"+x+\"\"+toAppend);\\n                        list.add(toAppend);\\n                    }else if(x<10){\\n                        list.add(x+\"\"+toAppend );\\n                        list.add(\"0\"+x+\"\"+toAppend);\\n                    }else{\\n                        list.add(x+\"\"+toAppend);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(String str : list){\\n           // System.out.println(str+\" \"+calculate(str,startAt,moveCost,pushCost,0));\\n            ans = Math.min(ans,calculate(str,startAt,moveCost,pushCost,0));\\n        }\\n        return ans;\\n    }\\n    private int calculate(String str,int curr,int moveCost,int pushCost,int idx){\\n        if(idx>=str.length()){\\n            return 0;\\n        }\\n        if(curr!=Character.getNumericValue(str.charAt(idx))){\\n            return moveCost+pushCost+calculate(str,Character.getNumericValue(str.charAt(idx)),moveCost,pushCost,idx+1);\\n        }else{\\n            return pushCost+calculate(str,curr,moveCost,pushCost,idx+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        List<String> list = new ArrayList<>();\\n        if(targetSeconds<10){\\n            list.add(\"\"+targetSeconds);\\n        }\\n        for(int x = 0;x<100;x++){\\n            for(int y = 0;y<=99;y++){\\n                if(60*x+y == targetSeconds){\\n                  //  System.out.println(x+\" \"+y);\\n                    String toAppend = (y<10?\"0\"+y:y+\"\");\\n                    if(x==0){\\n                        list.add(x+\"\"+toAppend );\\n                        list.add(\"0\"+x+\"\"+toAppend);\\n                        list.add(toAppend);\\n                    }else if(x<10){\\n                        list.add(x+\"\"+toAppend );\\n                        list.add(\"0\"+x+\"\"+toAppend);\\n                    }else{\\n                        list.add(x+\"\"+toAppend);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(String str : list){\\n           // System.out.println(str+\" \"+calculate(str,startAt,moveCost,pushCost,0));\\n            ans = Math.min(ans,calculate(str,startAt,moveCost,pushCost,0));\\n        }\\n        return ans;\\n    }\\n    private int calculate(String str,int curr,int moveCost,int pushCost,int idx){\\n        if(idx>=str.length()){\\n            return 0;\\n        }\\n        if(curr!=Character.getNumericValue(str.charAt(idx))){\\n            return moveCost+pushCost+calculate(str,Character.getNumericValue(str.charAt(idx)),moveCost,pushCost,idx+1);\\n        }else{\\n            return pushCost+calculate(str,curr,moveCost,pushCost,idx+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749565,
                "title": "java-not-so-understandable-solution",
                "content": "```\\nclass Solution \\n{\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n        int minute = targetSeconds/60;\\n        int sec = targetSeconds - minute*60;\\n        ArrayList<String> type = new ArrayList<>();\\n        \\n        int m = minute;\\n        int s = sec;\\n        if(m >= 0 && m <= 99 &&  s>=0 && s <= 99)\\n        {\\n            if(s <= 9)\\n            {\\n                if(m > 0) type.add(m + \"0\" + sec);\\n                else type.add(sec + \"\");\\n            }\\n            else \\n            {\\n                if(m == 0) type.add(s + \"\");\\n                else type.add(m+ \"\" + s + \"\");\\n            }    \\n        }\\n        \\n        \\n        \\n        if(m-1 >= 0 && s+60 <= 99) \\n        {\\n            m--;\\n            s +=60;\\n            \\n            if(s <= 9)\\n            {\\n                if(m > 0) type.add(m + \"0\" + sec);\\n                else type.add(sec + \"\");\\n            }\\n            else \\n            {\\n                if(m == 0) type.add(s + \"\");\\n                else type.add(m+ \"\" + s + \"\");\\n            }\\n        }\\n        \\n        int min = (int)1e9;\\n        \\n        \\n        for(String ele : type)\\n        {\\n            int x = startAt;\\n            int temp = 0;\\n            for(int i = 0;i<ele.length();i++)\\n            {\\n                int y = Integer.parseInt(ele.charAt(i) + \"\");\\n                if(x == y) temp += pushCost;\\n                else\\n                {\\n                    x = y;\\n                    temp += pushCost + moveCost;\\n                }\\n                \\n            }\\n            min = Math.min(min,temp);\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n        int minute = targetSeconds/60;\\n        int sec = targetSeconds - minute*60;\\n        ArrayList<String> type = new ArrayList<>();\\n        \\n        int m = minute;\\n        int s = sec;\\n        if(m >= 0 && m <= 99 &&  s>=0 && s <= 99)\\n        {\\n            if(s <= 9)\\n            {\\n                if(m > 0) type.add(m + \"0\" + sec);\\n                else type.add(sec + \"\");\\n            }\\n            else \\n            {\\n                if(m == 0) type.add(s + \"\");\\n                else type.add(m+ \"\" + s + \"\");\\n            }    \\n        }\\n        \\n        \\n        \\n        if(m-1 >= 0 && s+60 <= 99) \\n        {\\n            m--;\\n            s +=60;\\n            \\n            if(s <= 9)\\n            {\\n                if(m > 0) type.add(m + \"0\" + sec);\\n                else type.add(sec + \"\");\\n            }\\n            else \\n            {\\n                if(m == 0) type.add(s + \"\");\\n                else type.add(m+ \"\" + s + \"\");\\n            }\\n        }\\n        \\n        int min = (int)1e9;\\n        \\n        \\n        for(String ele : type)\\n        {\\n            int x = startAt;\\n            int temp = 0;\\n            for(int i = 0;i<ele.length();i++)\\n            {\\n                int y = Integer.parseInt(ele.charAt(i) + \"\");\\n                if(x == y) temp += pushCost;\\n                else\\n                {\\n                    x = y;\\n                    temp += pushCost + moveCost;\\n                }\\n                \\n            }\\n            min = Math.min(min,temp);\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749487,
                "title": "classic-0-1-breadth-first-search",
                "content": "It\\'s a  classic 0-1 BFS problem. \\n\\n\\t1. If we chose to push the same button we are currently on, \\n\\t\\t its a 0 operation and we add it to the front of the Queue and the cost increases by pushCost. \\n\\n\\t2. Else we add it to the end of the Queue and the cost increases by moveCost+pushCost. \\n\\t\\n**Python 3**\\n\\n\\tdef  whatSec(arr):\\n\\t\\t// converts string to time in seconds\\n\\t\\t arr = \\'0\\'*(4-len(arr))+arr\\n\\t\\t left = len(arr)-1\\n\\t\\t sec = 0\\n\\t\\t while left>=0:\\n\\t\\t\\tif left==3:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec+= int(arr[left])\\n\\t\\t\\tif left==2:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec += int(arr[left])*10\\n\\n\\t\\t\\tif left==1:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec += int(arr[left])*60\\n\\t\\t\\tif left==0:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec += int(arr[left])*600\\n\\t\\t\\tleft-=1\\n\\t\\t return sec\\n\\n\\t Q = deque([[\\'\\',0]])\\n \\t ans = 1e19\\n     while Q:\\n            for _ in range(len(Q)):\\n                curr,cost = Q.popleft()\\n                if whatSec(curr)==targetSeconds:\\n                    ans = min(ans,cost)\\n                    break\\n                if len(curr)>=4:\\n                    continue\\n                for ch in \\'0123456789\\':\\n                    if curr==\\'\\':\\n                        if ch==str(startAt):\\n                            Q.appendleft([ch,cost+pushCost])\\n                        else:\\n                            Q.append([ch,cost+pushCost+moveCost])\\n                    else:\\n                        if ch==curr[-1]:\\n                            Q.appendleft([curr+ch,cost+pushCost])\\n                        else:\\n                            Q.append([curr+ch,cost+pushCost+moveCost])\\n\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "It\\'s a  classic 0-1 BFS problem. \\n\\n\\t1. If we chose to push the same button we are currently on, \\n\\t\\t its a 0 operation and we add it to the front of the Queue and the cost increases by pushCost. \\n\\n\\t2. Else we add it to the end of the Queue and the cost increases by moveCost+pushCost. \\n\\t\\n**Python 3**\\n\\n\\tdef  whatSec(arr):\\n\\t\\t// converts string to time in seconds\\n\\t\\t arr = \\'0\\'*(4-len(arr))+arr\\n\\t\\t left = len(arr)-1\\n\\t\\t sec = 0\\n\\t\\t while left>=0:\\n\\t\\t\\tif left==3:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec+= int(arr[left])\\n\\t\\t\\tif left==2:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec += int(arr[left])*10\\n\\n\\t\\t\\tif left==1:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec += int(arr[left])*60\\n\\t\\t\\tif left==0:\\n\\t\\t\\t\\tif arr[left]!=\\'0\\':\\n\\t\\t\\t\\t\\tsec += int(arr[left])*600\\n\\t\\t\\tleft-=1\\n\\t\\t return sec\\n\\n\\t Q = deque([[\\'\\',0]])\\n \\t ans = 1e19\\n     while Q:\\n            for _ in range(len(Q)):\\n                curr,cost = Q.popleft()\\n                if whatSec(curr)==targetSeconds:\\n                    ans = min(ans,cost)\\n                    break\\n                if len(curr)>=4:\\n                    continue\\n                for ch in \\'0123456789\\':\\n                    if curr==\\'\\':\\n                        if ch==str(startAt):\\n                            Q.appendleft([ch,cost+pushCost])\\n                        else:\\n                            Q.append([ch,cost+pushCost+moveCost])\\n                    else:\\n                        if ch==curr[-1]:\\n                            Q.appendleft([curr+ch,cost+pushCost])\\n                        else:\\n                            Q.append([curr+ch,cost+pushCost+moveCost])\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1749450,
                "title": "c-beat-100-two-methods-to-calculate-the-cost-shortest-code",
                "content": "```c++\\nclass Solution {\\n public:\\n  int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    int m = targetSeconds / 60;\\n    int s = targetSeconds % 60;\\n    int cost = INT_MAX;\\n    if (m <= 99) {\\n      cost = min(cost, getCostSetTime2(startAt, moveCost, pushCost, m * 100 + s));\\n    }\\n    if (m > 0 && s + 60 <= 99) {\\n      cost = min(cost, getCostSetTime2(startAt, moveCost, pushCost, (m - 1) * 100 + s + 60));\\n    }\\n    return cost;\\n  }\\n\\n private:\\n  int getCostSetTime1(int startAt, int moveCost, int pushCost, int target) {\\n    vector<int> nums;\\n    while (target) {\\n      nums.push_back(target % 10);\\n      target /= 10;\\n    }\\n\\n    int cost = 0;\\n    int prevNum = startAt;\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n      if (nums[i] != prevNum) {\\n        cost += moveCost;\\n        prevNum = nums[i];\\n      }\\n      cost += pushCost;\\n    }\\n    return cost;\\n  }\\n\\n  int getCostSetTime2(int startAt, int moveCost, int pushCost, int target) {\\n    int cost = 0;\\n    int prev = target % 10;\\n    while (target) {\\n      int num = target % 10;\\n      target /= 10;\\n      if (num != prev) {\\n        cost += moveCost;\\n        prev = num;\\n      }\\n      cost += pushCost;\\n    }\\n    if (startAt != prev) {\\n      cost += moveCost;\\n    }\\n    return cost;\\n  }\\n};\\n/*\\nTest cases:\\n1 2 1 600\\n0 1 2 76\\n0 9 18 460\\n1 9403 9402 6008\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n public:\\n  int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    int m = targetSeconds / 60;\\n    int s = targetSeconds % 60;\\n    int cost = INT_MAX;\\n    if (m <= 99) {\\n      cost = min(cost, getCostSetTime2(startAt, moveCost, pushCost, m * 100 + s));\\n    }\\n    if (m > 0 && s + 60 <= 99) {\\n      cost = min(cost, getCostSetTime2(startAt, moveCost, pushCost, (m - 1) * 100 + s + 60));\\n    }\\n    return cost;\\n  }\\n\\n private:\\n  int getCostSetTime1(int startAt, int moveCost, int pushCost, int target) {\\n    vector<int> nums;\\n    while (target) {\\n      nums.push_back(target % 10);\\n      target /= 10;\\n    }\\n\\n    int cost = 0;\\n    int prevNum = startAt;\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n      if (nums[i] != prevNum) {\\n        cost += moveCost;\\n        prevNum = nums[i];\\n      }\\n      cost += pushCost;\\n    }\\n    return cost;\\n  }\\n\\n  int getCostSetTime2(int startAt, int moveCost, int pushCost, int target) {\\n    int cost = 0;\\n    int prev = target % 10;\\n    while (target) {\\n      int num = target % 10;\\n      target /= 10;\\n      if (num != prev) {\\n        cost += moveCost;\\n        prev = num;\\n      }\\n      cost += pushCost;\\n    }\\n    if (startAt != prev) {\\n      cost += moveCost;\\n    }\\n    return cost;\\n  }\\n};\\n/*\\nTest cases:\\n1 2 1 600\\n0 1 2 76\\n0 9 18 460\\n1 9403 9402 6008\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749197,
                "title": "c-two-case-solution",
                "content": "class Solution {\\npublic:\\n   int solve(int s,int m,int p,int min,int sec){\\n        \\n\\t\\tint x = (min*100)+sec;\\n        vector<int>y;\\n        int c = 0;\\n        while(x){\\n            y.push_back(x%10);\\n            x/=10;\\n        }\\n        reverse(y.begin(),y.end());\\n        for(int i=0;i<y.size();i++){\\n            if(y[i]==s){\\n                c+=p;\\n            }else{\\n                c+=m;\\n                c+=p;\\n                s = y[i];\\n            }\\n        }\\n        return c;\\n    }\\n    int minCostSetTime(int s, int m, int p, int t) {\\n        int c = INT_MAX;\\n        if(t>99){\\n            int mn = t/60,sec =  t%60;\\n            if(mn<100){\\n                c = min(c,solve(s,m,p,mn,sec));\\n            }\\n            mn--;\\n            sec+=60;\\n            if(sec<=99){\\n                c = min(c,solve(s,m,p,mn,sec));\\n            }\\n        }else if(t<=99){\\n            c = min(c,solve(s,m,p,0,t));\\n            if(t>=60){\\n                c = min(c,solve(s,m,p,1,t%60));\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n   int solve(int s,int m,int p,int min,int sec){\\n        \\n\\t\\tint x = (min*100)+sec;\\n        vector<int>y;\\n        int c = 0;\\n        while(x){\\n            y.push_back(x%10);\\n            x/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1749095,
                "title": "mathematical-and-logical",
                "content": "//LOGIC IS VERY SIMPLE CALCULATING ALL POSSIBLE REPRESENTATION OF GIVEN TARGET SECONDS \\n    //FOR EXAMPLE :IF TARGET SECONDS IS 154 sec THAN IT CAN BE REPRESENTED AS (1 MIN 94 SEC ) && (2 MIN 34 SEC)\\n    //SO MAXIMUM MINUTES IT CAN HAVE IS 2 SO WE ARE LOOPING FROM O TO 2 AND DEDUCING REMAINING SECONDS IF REMAINING SECS IS >99 THAN WE CANT REPRESENT IT IN THAT WAY SO TAKE NEXT MIN \\n\\t\\n\\t\\n\\t``` \\n\\tclass Solution {\\npublic:\\n    int cost(int mins, int secs, int startAt, int moveCost, int pushCost) {\\n    string s = to_string(mins * 100 + secs); \\n        char curr = (char)(startAt + \\'0\\');\\n    int res = 0;\\n    for(auto c: s) {\\n        if (c == curr) res += pushCost;\\n        else {\\n            res += pushCost + moveCost;\\n            curr = c;\\n        }\\n    }\\n    return res;\\n}\\n    \\n    \\n  int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    int maxminutes = targetSeconds / 60, ans = 1e7;\\n    for (int mins = 0; mins <= maxminutes; mins++) {\\n        int secs = targetSeconds - mins * 60;// REMAINING SECONDS FROM TARGETSECONDS\\n        if (secs > 99 || mins > 99) \\n            continue;\\n        ans = min(ans, cost(mins, secs, startAt, moveCost, pushCost));\\n    }\\n    return ans;\\n}\\n};\\n ```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Brainteaser"
                ],
                "code": "``` \\n\\tclass Solution {\\npublic:\\n    int cost(int mins, int secs, int startAt, int moveCost, int pushCost) {\\n    string s = to_string(mins * 100 + secs); \\n        char curr = (char)(startAt + \\'0\\');\\n    int res = 0;\\n    for(auto c: s) {\\n        if (c == curr) res += pushCost;\\n        else {\\n            res += pushCost + moveCost;\\n            curr = c;\\n        }\\n    }\\n    return res;\\n}\\n    \\n    \\n  int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n    int maxminutes = targetSeconds / 60, ans = 1e7;\\n    for (int mins = 0; mins <= maxminutes; mins++) {\\n        int secs = targetSeconds - mins * 60;// REMAINING SECONDS FROM TARGETSECONDS\\n        if (secs > 99 || mins > 99) \\n            continue;\\n        ans = min(ans, cost(mins, secs, startAt, moveCost, pushCost));\\n    }\\n    return ans;\\n}\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1749079,
                "title": "java-easy-to-understand-tc-o-1-sc-o-1",
                "content": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t/*\\n\\t\\tfor all possible combination of digits\\n\\t\\t\\tcheck if this combination is equal to given targetSeconds\\n\\t\\t\\t\\tyes ->\\n\\t\\t\\t\\tthen,\\n\\t\\t\\t\\t\\tfind cost to cook\\n\\t\\t\\t\\t\\talso check if this cost is lesser than previous combination\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tno  -> leave it\\n\\t\\t*/\\n\\t\\t\\n\\t\\t//we can also nerrow down range\\n\\t\\t// 10 * 10 * 10 * 10  -> costant time work\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    for (int l = 0; l < 10; l++) {\\n                        int minutes = i * 10 + j;\\n                        int seconds = k * 10 + l;\\n                        \\n                        if (minutes * 60 + seconds == targetSeconds) {\\n                            min = Math.min(min, findCost(minutes * 100 + seconds, startAt, moveCost, pushCost));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return min;\\n    }\\n    \\n\\t//finding cost to press given number\\n\\t//constant time TC\\n    int findCost(int number, int startAt, int moveCost, int pushCost) {\\n        //System.out.print(number+\" \");\\n        int d[] = new int[4];\\n        d[3] = number % 10;\\n        number /= 10;\\n        \\n        d[2] = number % 10;\\n        number /= 10;\\n        \\n        d[1] = number % 10;\\n        number /= 10;\\n        \\n        d[0] = number % 10;\\n        number /= 10;\\n        \\n        int cost = 0, last = startAt;\\n        \\n        int i = 0;\\n        while (i < 4 && d[i] == 0) {\\n            i++;\\n        }\\n        for ( ; i < 4; i++) {\\n            if (d[i] != last) {\\n                cost += moveCost;\\n                last = d[i];\\n            }\\n            cost += pushCost;\\n            number /= 10;\\n        }\\n        //System.out.println(cost);\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t/*\\n\\t\\tfor all possible combination of digits\\n\\t\\t\\tcheck if this combination is equal to given targetSeconds\\n\\t\\t\\t\\tyes ->\\n\\t\\t\\t\\tthen,\\n\\t\\t\\t\\t\\tfind cost to cook\\n\\t\\t\\t\\t\\talso check if this cost is lesser than previous combination\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tno  -> leave it\\n\\t\\t*/\\n\\t\\t\\n\\t\\t//we can also nerrow down range\\n\\t\\t// 10 * 10 * 10 * 10  -> costant time work\\n        for (int i = 0; i < 10; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    for (int l = 0; l < 10; l++) {\\n                        int minutes = i * 10 + j;\\n                        int seconds = k * 10 + l;\\n                        \\n                        if (minutes * 60 + seconds == targetSeconds) {\\n                            min = Math.min(min, findCost(minutes * 100 + seconds, startAt, moveCost, pushCost));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        return min;\\n    }\\n    \\n\\t//finding cost to press given number\\n\\t//constant time TC\\n    int findCost(int number, int startAt, int moveCost, int pushCost) {\\n        //System.out.print(number+\" \");\\n        int d[] = new int[4];\\n        d[3] = number % 10;\\n        number /= 10;\\n        \\n        d[2] = number % 10;\\n        number /= 10;\\n        \\n        d[1] = number % 10;\\n        number /= 10;\\n        \\n        d[0] = number % 10;\\n        number /= 10;\\n        \\n        int cost = 0, last = startAt;\\n        \\n        int i = 0;\\n        while (i < 4 && d[i] == 0) {\\n            i++;\\n        }\\n        for ( ; i < 4; i++) {\\n            if (d[i] != last) {\\n                cost += moveCost;\\n                last = d[i];\\n            }\\n            cost += pushCost;\\n            number /= 10;\\n        }\\n        //System.out.println(cost);\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748828,
                "title": "python-solution-faster-than-87-5",
                "content": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, t: int) -> int:\\n        res = []\\n        minu,min_sec = divmod(t,60)\\n        if minu <= 99:\\n            res.append([minu,min_sec])\\n        if min_sec + 60 <= 99 and minu -1 >= 0:\\n            res.append([minu-1,min_sec + 60])\\n            \\n        _min = inf\\n        res2 = []\\n        for m,s in res:\\n            if s < 10:\\n                s = str(0) + str(s)\\n            res2.append(int(str(m) + str(s)))\\n        for r in res2:\\n            c = 0\\n            r = str(r)\\n            if startAt != int(r[0]):\\n                c+=moveCost\\n            c+=pushCost\\n            for i in range(1,len(r)):\\n                if r[i] != r[i-1]:\\n                    c += moveCost\\n                c += pushCost\\n            \\n            _min = min(_min,c)\\n        return _min\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCostSetTime(self, startAt: int, moveCost: int, pushCost: int, t: int) -> int:\\n        res = []\\n        minu,min_sec = divmod(t,60)\\n        if minu <= 99:\\n            res.append([minu,min_sec])\\n        if min_sec + 60 <= 99 and minu -1 >= 0:\\n            res.append([minu-1,min_sec + 60])\\n            \\n        _min = inf\\n        res2 = []\\n        for m,s in res:\\n            if s < 10:\\n                s = str(0) + str(s)\\n            res2.append(int(str(m) + str(s)))\\n        for r in res2:\\n            c = 0\\n            r = str(r)\\n            if startAt != int(r[0]):\\n                c+=moveCost\\n            c+=pushCost\\n            for i in range(1,len(r)):\\n                if r[i] != r[i-1]:\\n                    c += moveCost\\n                c += pushCost\\n            \\n            _min = min(_min,c)\\n        return _min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748347,
                "title": "javascript-2162-minimum-cost-to-set-cooking-time",
                "content": "---\\n\\n- **Biweekly Contest 71 answers**\\n  - Q1\\n    - https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/discuss/1748621/JavaScript-2160.-Minimum-Sum-of-Four-Digit-Number-After-Splitting-Digits\\n  - Q2\\n    - https://leetcode.com/problems/partition-array-according-to-given-pivot/discuss/1748639/JavaScript-2161.-Partition-Array-According-to-Given-Pivot\\n  - Q3\\n    - https://leetcode.com/problems/minimum-cost-to-set-cooking-time/discuss/1748347/JavaScript-2162.-Minimum-Cost-to-Set-Cooking-Time\\n    - **below**\\n\\n---\\n\\n- **Weekly Contest 279 answers**\\n  - Q1\\n    - https://leetcode.com/problems/sort-even-and-odd-indices-independently/discuss/1748670/JavaScript-2164.-Sort-Even-and-Odd-Indices-Independently\\n  - Q2\\n    - https://leetcode.com/problems/smallest-value-of-the-rearranged-number/discuss/1748702/JavaScript-2165.-Smallest-Value-of-the-Rearranged-Number\\n  - Q3\\n    - https://leetcode.com/problems/design-bitset/discuss/1748711/JavaScript-2166.-Design-Bitset\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar minCostSetTime = function (startAt, moveCost, pushCost, targetSeconds) {\\n\\n    function getCost(mins, secs, startAt, moveCost, pushCost) {\\n        if (secs < 0 || secs > 99 || mins < 0 || mins > 99) return Infinity;\\n\\n        let timeStr =\\n            (mins || \"\") +                        // don\\'t take 0 as mins\\n            (mins && secs <= 9 ? \"0\" : \"\") +      // if mins exist, prepend 0 to secs if < 10\\n            secs;\\n        let sum = 0;\\n        let prev = \"\" + startAt;\\n        for (let ch of timeStr) {\\n            if (ch === prev) {\\n                sum += pushCost;\\n            } else {\\n                sum += moveCost + pushCost;\\n            }\\n            prev = ch;\\n        }\\n        return sum;\\n    }\\n\\n    let mins = Math.trunc(targetSeconds / 60);\\n    let secs = targetSeconds % 60;\\n\\n    return Math.min(\\n        getCost(  mins,     secs,       startAt, moveCost, pushCost  ),\\n        getCost(  mins - 1, secs + 60,  startAt, moveCost, pushCost  )\\n    );\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minCostSetTime = function (startAt, moveCost, pushCost, targetSeconds) {\\n\\n    function getCost(mins, secs, startAt, moveCost, pushCost) {\\n        if (secs < 0 || secs > 99 || mins < 0 || mins > 99) return Infinity;\\n\\n        let timeStr =\\n            (mins || \"\") +                        // don\\'t take 0 as mins\\n            (mins && secs <= 9 ? \"0\" : \"\") +      // if mins exist, prepend 0 to secs if < 10\\n            secs;\\n        let sum = 0;\\n        let prev = \"\" + startAt;\\n        for (let ch of timeStr) {\\n            if (ch === prev) {\\n                sum += pushCost;\\n            } else {\\n                sum += moveCost + pushCost;\\n            }\\n            prev = ch;\\n        }\\n        return sum;\\n    }\\n\\n    let mins = Math.trunc(targetSeconds / 60);\\n    let secs = targetSeconds % 60;\\n\\n    return Math.min(\\n        getCost(  mins,     secs,       startAt, moveCost, pushCost  ),\\n        getCost(  mins - 1, secs + 60,  startAt, moveCost, pushCost  )\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748267,
                "title": "c-0ms",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void push(int num, int &pos, int &cost, int moveCost, int pushCost)\\n    {\\n        if(num == pos)\\n        {\\n            cost += pushCost;\\n        }\\n        else\\n        {\\n            pos = num;\\n            cost += moveCost;\\n            cost += pushCost;\\n        }\\n    }\\n    int getCost(int startAt, int moveCost, int pushCost, int minute, int sec)\\n    {\\n        int pos = startAt;\\n        int cost = 0;\\n        if(minute > 0)\\n        {\\n            if(minute < 10)//minute = 1~9\\n            {\\n                push(minute, pos, cost, moveCost, pushCost);\\n            }\\n            else//minute = 10~99\\n            {\\n                push(minute / 10, pos, cost, moveCost, pushCost);\\n                push(minute % 10, pos, cost, moveCost, pushCost);\\n            }\\n            if(sec > 0)//sec = 1~99\\n            {\\n                if(sec < 10)//sec = 1~9\\n                {\\n                    push(0, pos, cost, moveCost, pushCost);\\n                    push(sec, pos, cost, moveCost, pushCost);\\n                }\\n                else//sec = 10~99\\n                {\\n                    push(sec / 10, pos, cost, moveCost, pushCost);\\n                    push(sec % 10, pos, cost, moveCost, pushCost);\\n                }\\n            }\\n            else//sec = 0\\n            {\\n                push(0, pos, cost, moveCost, pushCost);\\n                push(0, pos, cost, moveCost, pushCost);\\n            }\\n        }\\n        else//minute = 0\\n        {\\n            if(sec > 0)//sec = 1~99\\n            {\\n                if(sec < 10)//sec = 1~9\\n                {\\n                    push(sec, pos, cost, moveCost, pushCost);\\n                }\\n                else//sec = 10~99\\n                {\\n                    push(sec / 10, pos, cost, moveCost, pushCost);\\n                    push(sec % 10, pos, cost, moveCost, pushCost);\\n                }\\n            }\\n            else//sec = 0\\n            {\\n                return 0;\\n            }\\n        }\\n        return cost;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n        int minute = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        int minCost;\\n        if(minute == 100)//exceed the digit\\n        {\\n            sec += 60;\\n            minute--;\\n        }\\n        minCost = getCost(startAt, moveCost, pushCost, minute, sec);\\n        if(sec + 60 <= 99 && minute > 0)//the 2th case\\n        {\\n            sec += 60;\\n            minute--;\\n            minCost = min(minCost, getCost(startAt, moveCost, pushCost, minute, sec));\\n        }\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void push(int num, int &pos, int &cost, int moveCost, int pushCost)\\n    {\\n        if(num == pos)\\n        {\\n            cost += pushCost;\\n        }\\n        else\\n        {\\n            pos = num;\\n            cost += moveCost;\\n            cost += pushCost;\\n        }\\n    }\\n    int getCost(int startAt, int moveCost, int pushCost, int minute, int sec)\\n    {\\n        int pos = startAt;\\n        int cost = 0;\\n        if(minute > 0)\\n        {\\n            if(minute < 10)//minute = 1~9\\n            {\\n                push(minute, pos, cost, moveCost, pushCost);\\n            }\\n            else//minute = 10~99\\n            {\\n                push(minute / 10, pos, cost, moveCost, pushCost);\\n                push(minute % 10, pos, cost, moveCost, pushCost);\\n            }\\n            if(sec > 0)//sec = 1~99\\n            {\\n                if(sec < 10)//sec = 1~9\\n                {\\n                    push(0, pos, cost, moveCost, pushCost);\\n                    push(sec, pos, cost, moveCost, pushCost);\\n                }\\n                else//sec = 10~99\\n                {\\n                    push(sec / 10, pos, cost, moveCost, pushCost);\\n                    push(sec % 10, pos, cost, moveCost, pushCost);\\n                }\\n            }\\n            else//sec = 0\\n            {\\n                push(0, pos, cost, moveCost, pushCost);\\n                push(0, pos, cost, moveCost, pushCost);\\n            }\\n        }\\n        else//minute = 0\\n        {\\n            if(sec > 0)//sec = 1~99\\n            {\\n                if(sec < 10)//sec = 1~9\\n                {\\n                    push(sec, pos, cost, moveCost, pushCost);\\n                }\\n                else//sec = 10~99\\n                {\\n                    push(sec / 10, pos, cost, moveCost, pushCost);\\n                    push(sec % 10, pos, cost, moveCost, pushCost);\\n                }\\n            }\\n            else//sec = 0\\n            {\\n                return 0;\\n            }\\n        }\\n        return cost;\\n    }\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) \\n    {\\n        int minute = targetSeconds / 60;\\n        int sec = targetSeconds % 60;\\n        int minCost;\\n        if(minute == 100)//exceed the digit\\n        {\\n            sec += 60;\\n            minute--;\\n        }\\n        minCost = getCost(startAt, moveCost, pushCost, minute, sec);\\n        if(sec + 60 <= 99 && minute > 0)//the 2th case\\n        {\\n            sec += 60;\\n            minute--;\\n            minCost = min(minCost, getCost(startAt, moveCost, pushCost, minute, sec));\\n        }\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748133,
                "title": "java-waste-of-time-problem",
                "content": "```\\n    // Author: Anand\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minS = Integer.MAX_VALUE;\\n\\n        int mins = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n\\n        if (mins > 99) {\\n            mins = 99;\\n            seconds += 60;\\n            if (seconds > 99){\\n                seconds = 99;\\n            }\\n        }\\n        \\n        int digits = 0;\\n        int copy = targetSeconds;\\n        List<Integer> dig = new ArrayList<>();\\n        while (copy > 0) {\\n            digits++;\\n            dig.add(copy % 10);\\n            copy /= 10;\\n        }\\n\\n        Collections.reverse(dig);\\n        if (digits <= 2) {\\n            int cost = 0;\\n            int curr = startAt;\\n            for (int d : dig) {\\n                if (curr != d) {\\n                    cost += moveCost; // move\\n                    cost += pushCost;// push\\n                    curr = d;\\n                } else {\\n                    cost += pushCost; // simply push\\n                }\\n            }\\n\\n            minS = Math.min(minS, cost);\\n        }\\n\\n        // 1st case \\n        minS = Math.min(cal(mins, seconds, startAt, moveCost, pushCost), minS);\\n\\n        if (seconds == 0) {\\n            minS = Math.min(cal(mins - 1, 60, startAt, moveCost, pushCost), minS);\\n        }\\n        \\n        // 2nd case\\n        if (seconds <= 39 && mins > 0){\\n             minS = Math.min(cal(mins - 1, 60+seconds, startAt, moveCost, pushCost), minS);\\n        }\\n\\n        return minS;\\n    }\\n\\n    private int cal(int mins, int seconds, int startAt, int moveCost, int pushCost) {\\n        int cost = 0;\\n        int curr = startAt;\\n\\n        String ms = String.valueOf(mins);\\n\\n        String ss = String.valueOf(seconds);\\n\\n        for (int i = 0; i < ms.length(); i++) {\\n            int d = Integer.parseInt(String.valueOf(ms.charAt(i)));\\n            if (curr != d) {\\n                cost += moveCost; // move\\n                cost += pushCost;// push\\n                curr = d;\\n            } else {\\n                cost += pushCost; // simply push\\n            }\\n        }\\n\\n        \\n        if (seconds == 0) {\\n            if (curr != 0) {\\n                cost += moveCost; // move\\n            }\\n            cost += (2*pushCost);// push 2 times\\n        } else {\\n            // if single digit then append zero\\n            if (seconds / 10 == 0) {\\n                if (curr != 0) {\\n                    cost += moveCost; // move\\n                }\\n                cost += pushCost;// push\\n                curr = 0;\\n            }\\n\\n            for (int i = 0; i < ss.length(); i++) {\\n                int d = Integer.parseInt(String.valueOf(ss.charAt(i)));\\n                if (curr != d) {\\n                    cost += moveCost; // move\\n                    cost += pushCost;// push\\n                    curr = d;\\n                } else {\\n                    cost += pushCost; // simply push\\n                }\\n            }\\n        }\\n        return cost;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Author: Anand\\n    public int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n        int minS = Integer.MAX_VALUE;\\n\\n        int mins = targetSeconds / 60;\\n        int seconds = targetSeconds % 60;\\n\\n        if (mins > 99) {\\n            mins = 99;\\n            seconds += 60;\\n            if (seconds > 99){\\n                seconds = 99;\\n            }\\n        }\\n        \\n        int digits = 0;\\n        int copy = targetSeconds;\\n        List<Integer> dig = new ArrayList<>();\\n        while (copy > 0) {\\n            digits++;\\n            dig.add(copy % 10);\\n            copy /= 10;\\n        }\\n\\n        Collections.reverse(dig);\\n        if (digits <= 2) {\\n            int cost = 0;\\n            int curr = startAt;\\n            for (int d : dig) {\\n                if (curr != d) {\\n                    cost += moveCost; // move\\n                    cost += pushCost;// push\\n                    curr = d;\\n                } else {\\n                    cost += pushCost; // simply push\\n                }\\n            }\\n\\n            minS = Math.min(minS, cost);\\n        }\\n\\n        // 1st case \\n        minS = Math.min(cal(mins, seconds, startAt, moveCost, pushCost), minS);\\n\\n        if (seconds == 0) {\\n            minS = Math.min(cal(mins - 1, 60, startAt, moveCost, pushCost), minS);\\n        }\\n        \\n        // 2nd case\\n        if (seconds <= 39 && mins > 0){\\n             minS = Math.min(cal(mins - 1, 60+seconds, startAt, moveCost, pushCost), minS);\\n        }\\n\\n        return minS;\\n    }\\n\\n    private int cal(int mins, int seconds, int startAt, int moveCost, int pushCost) {\\n        int cost = 0;\\n        int curr = startAt;\\n\\n        String ms = String.valueOf(mins);\\n\\n        String ss = String.valueOf(seconds);\\n\\n        for (int i = 0; i < ms.length(); i++) {\\n            int d = Integer.parseInt(String.valueOf(ms.charAt(i)));\\n            if (curr != d) {\\n                cost += moveCost; // move\\n                cost += pushCost;// push\\n                curr = d;\\n            } else {\\n                cost += pushCost; // simply push\\n            }\\n        }\\n\\n        \\n        if (seconds == 0) {\\n            if (curr != 0) {\\n                cost += moveCost; // move\\n            }\\n            cost += (2*pushCost);// push 2 times\\n        } else {\\n            // if single digit then append zero\\n            if (seconds / 10 == 0) {\\n                if (curr != 0) {\\n                    cost += moveCost; // move\\n                }\\n                cost += pushCost;// push\\n                curr = 0;\\n            }\\n\\n            for (int i = 0; i < ss.length(); i++) {\\n                int d = Integer.parseInt(String.valueOf(ss.charAt(i)));\\n                if (curr != d) {\\n                    cost += moveCost; // move\\n                    cost += pushCost;// push\\n                    curr = d;\\n                } else {\\n                    cost += pushCost; // simply push\\n                }\\n            }\\n        }\\n        return cost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747963,
                "title": "c-simple-brute-force-very-easyunderstanding",
                "content": "DO UPVOTE PLS :)) IF U FIND IT USEFUL, I\\'HAVE JUST STARTED TO POST.\\n\\n\\'\\'\\'class Solution {\\n\\npublic:\\n\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\t\\n        int ans=INT_MAX;\\n\\t\\t\\n        for(int m=0;m<=targetSeconds/60;m++)           //here m stands for minute ,here i am iterating minute so that i can get the min value of \\'m\\' to satisfy \\n\\t\\t//the condion.\\n\\t\\t\\n        {   \\n            int s=targetSeconds-60*m;           //here s stands for second ,after using \\'m\\' minutes how many seconds are left .\\n\\t\\t\\t\\n            if((m==0 && s==0) or (m>99 || s>99))         // cannot be zero and can\\'t exceed 99 min 99 sec\\n\\t\\t\\t\\n                continue;\\n            int num=m*100+s;           // making the min and sec digits as a single num\\n\\t\\t\\t\\n\\t\\t\\t\\n            vector<int>digi;\\n            while(num)\\n            {\\n                digi.push_back(num%10);\\n                num/=10;\\n            }\\n            reverse(digi.begin(),digi.end());\\n            int cost=pushCost;\\n            if(digi[0]!=startAt)         //checking where initialy the starting point is if its not the number\\n\\t\\t\\t//requird then we have to move our finger in order to achive that particular number for\\n\\t\\t\\t//cooking set.\\n\\t\\t\\t\\n              cost+=moveCost;\\n            for(int i=1;i<digi.size();i++)\\n            {\\n                if(digi[i]==digi[i-1]) cost+=pushCost;       // if last number is same as the next number then we dont have move our hand \\n                else\\n                    cost=cost+moveCost+pushCost;\\n            }\\n            ans=min(ans,cost);       // checing for evry \\'m\\' value which gives min value will be return\\n        }\\n        return ans;\\n    }\\n\\t\\n}; \\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {\\n\\t\\n        int ans=INT_MAX;\\n\\t\\t\\n        for(int m=0;m<=targetSeconds/60;m++)           //here m stands for minute ,here i am iterating minute so that i can get the min value of \\'m\\' to satisfy \\n\\t\\t//the condion.\\n\\t\\t\\n        {   \\n            int s=targetSeconds-60*m;           //here s stands for second ,after using \\'m\\' minutes how many seconds are left .\\n\\t\\t\\t\\n            if((m==0 && s==0) or (m>99 || s>99))         // cannot be zero and can\\'t exceed 99 min 99 sec\\n\\t\\t\\t\\n                continue;\\n            int num=m*100+s;           // making the min and sec digits as a single num\\n\\t\\t\\t\\n\\t\\t\\t\\n            vector<int>digi;\\n            while(num)\\n            {\\n                digi.push_back(num%10);\\n                num/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1747923,
                "title": "go-lang-0ms-solution",
                "content": "```\\nfunc minCostSetTime(startAt int, moveCost int, pushCost int, targetSeconds int) int {\\n    timeSeries := []string{}\\n    if targetSeconds <= 99 {\\n        timeSeries = append(timeSeries, \"\" + strconv.Itoa(targetSeconds))\\n    }\\n    \\n    minutes := int(targetSeconds / 60)\\n    seconds := targetSeconds % 60\\n    for minutes > 0 {\\n        if minutes < 100 && seconds < 100 {\\n            s := strconv.Itoa(seconds)\\n            if seconds < 10 {\\n                s = \"0\" + s\\n            }\\n\\n            timeSeries = append(timeSeries, strconv.Itoa(minutes) + s)\\n        }\\n        \\n        seconds += 60\\n        minutes--\\n    }\\n    \\n    if minutes == 0 && seconds > 0 {\\n        if seconds <= 99 {\\n            s := strconv.Itoa(seconds)\\n            if seconds < 10 {\\n                s = \"0\" + s\\n            }\\n\\n            timeSeries = append(timeSeries, \"\" + s)\\n            \\n        }\\n        \\n        // take back from seconds\\n        seconds -= 60\\n        minutes++\\n        s := strconv.Itoa(seconds)\\n        if seconds < 10 {\\n            s = \"0\" + s\\n        }\\n\\n        timeSeries = append(timeSeries, strconv.Itoa(minutes) + s)\\n    }\\n    \\n    min := math.MaxInt\\n    for _, time := range timeSeries {\\n        t := []rune(time)\\n        d := t[0]\\n        a, _ := strconv.ParseInt(string(d), 10, 32)\\n        cost := 0\\n        lastD := int(a)\\n        if int(a) != startAt {\\n            // move to start\\n            cost += moveCost\\n        }\\n        \\n        cost += pushCost\\n        for j := 1; j < len(t); j++ {\\n            d = t[j]\\n            a, _ = strconv.ParseInt(string(d), 10, 32)\\n            if lastD != int(a) {\\n                // move\\n                cost += moveCost\\n            }\\n\\n            cost += pushCost\\n            lastD = int(a)\\n        }\\n        \\n        min = Min(min, cost)\\n    }\\n    \\n    return min\\n}\\n\\nfunc Min(a, b int) int {\\n    if a > b {\\n        return b\\n    }\\n    \\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minCostSetTime(startAt int, moveCost int, pushCost int, targetSeconds int) int {\\n    timeSeries := []string{}\\n    if targetSeconds <= 99 {\\n        timeSeries = append(timeSeries, \"\" + strconv.Itoa(targetSeconds))\\n    }\\n    \\n    minutes := int(targetSeconds / 60)\\n    seconds := targetSeconds % 60\\n    for minutes > 0 {\\n        if minutes < 100 && seconds < 100 {\\n            s := strconv.Itoa(seconds)\\n            if seconds < 10 {\\n                s = \"0\" + s\\n            }\\n\\n            timeSeries = append(timeSeries, strconv.Itoa(minutes) + s)\\n        }\\n        \\n        seconds += 60\\n        minutes--\\n    }\\n    \\n    if minutes == 0 && seconds > 0 {\\n        if seconds <= 99 {\\n            s := strconv.Itoa(seconds)\\n            if seconds < 10 {\\n                s = \"0\" + s\\n            }\\n\\n            timeSeries = append(timeSeries, \"\" + s)\\n            \\n        }\\n        \\n        // take back from seconds\\n        seconds -= 60\\n        minutes++\\n        s := strconv.Itoa(seconds)\\n        if seconds < 10 {\\n            s = \"0\" + s\\n        }\\n\\n        timeSeries = append(timeSeries, strconv.Itoa(minutes) + s)\\n    }\\n    \\n    min := math.MaxInt\\n    for _, time := range timeSeries {\\n        t := []rune(time)\\n        d := t[0]\\n        a, _ := strconv.ParseInt(string(d), 10, 32)\\n        cost := 0\\n        lastD := int(a)\\n        if int(a) != startAt {\\n            // move to start\\n            cost += moveCost\\n        }\\n        \\n        cost += pushCost\\n        for j := 1; j < len(t); j++ {\\n            d = t[j]\\n            a, _ = strconv.ParseInt(string(d), 10, 32)\\n            if lastD != int(a) {\\n                // move\\n                cost += moveCost\\n            }\\n\\n            cost += pushCost\\n            lastD = int(a)\\n        }\\n        \\n        min = Min(min, cost)\\n    }\\n    \\n    return min\\n}\\n\\nfunc Min(a, b int) int {\\n    if a > b {\\n        return b\\n    }\\n    \\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568725,
                "content": [
                    {
                        "username": "csbalotiya",
                        "content": "Worst problem please support!!"
                    },
                    {
                        "username": "Java_Programmer_Ketan",
                        "content": "seconds 6039 was resulting in mintues to be equal to 100.."
                    },
                    {
                        "username": "Dendi_",
                        "content": "This is a simulation questions rather than an DSA question. Should not be asked in an interview because interviewer is supposed to judge your DSA skill and not simulation skills."
                    },
                    {
                        "username": "user3762tT",
                        "content": "I don\\'t get it either, time complexity is not relevant to that question"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Seconds clock going over 59 seconds upto 99 seconds was kind of frustrating to deal with."
                    }
                ]
            },
            {
                "id": 1565518,
                "content": [
                    {
                        "username": "csbalotiya",
                        "content": "Worst problem please support!!"
                    },
                    {
                        "username": "Java_Programmer_Ketan",
                        "content": "seconds 6039 was resulting in mintues to be equal to 100.."
                    },
                    {
                        "username": "Dendi_",
                        "content": "This is a simulation questions rather than an DSA question. Should not be asked in an interview because interviewer is supposed to judge your DSA skill and not simulation skills."
                    },
                    {
                        "username": "user3762tT",
                        "content": "I don\\'t get it either, time complexity is not relevant to that question"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Seconds clock going over 59 seconds upto 99 seconds was kind of frustrating to deal with."
                    }
                ]
            },
            {
                "id": 1820913,
                "content": [
                    {
                        "username": "csbalotiya",
                        "content": "Worst problem please support!!"
                    },
                    {
                        "username": "Java_Programmer_Ketan",
                        "content": "seconds 6039 was resulting in mintues to be equal to 100.."
                    },
                    {
                        "username": "Dendi_",
                        "content": "This is a simulation questions rather than an DSA question. Should not be asked in an interview because interviewer is supposed to judge your DSA skill and not simulation skills."
                    },
                    {
                        "username": "user3762tT",
                        "content": "I don\\'t get it either, time complexity is not relevant to that question"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Seconds clock going over 59 seconds upto 99 seconds was kind of frustrating to deal with."
                    }
                ]
            },
            {
                "id": 1750074,
                "content": [
                    {
                        "username": "csbalotiya",
                        "content": "Worst problem please support!!"
                    },
                    {
                        "username": "Java_Programmer_Ketan",
                        "content": "seconds 6039 was resulting in mintues to be equal to 100.."
                    },
                    {
                        "username": "Dendi_",
                        "content": "This is a simulation questions rather than an DSA question. Should not be asked in an interview because interviewer is supposed to judge your DSA skill and not simulation skills."
                    },
                    {
                        "username": "user3762tT",
                        "content": "I don\\'t get it either, time complexity is not relevant to that question"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Seconds clock going over 59 seconds upto 99 seconds was kind of frustrating to deal with."
                    }
                ]
            }
        ]
    }
]