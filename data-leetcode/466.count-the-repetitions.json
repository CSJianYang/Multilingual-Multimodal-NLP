[
    {
        "title": "Plus One",
        "question_content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n&nbsp;\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n&nbsp;\nConstraints:\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "solutions": [
            {
                "id": 24082,
                "title": "my-simple-java-solution",
                "content": "    public int[] plusOne(int[] digits) {\\n            \\n        int n = digits.length;\\n        for(int i=n-1; i>=0; i--) {\\n            if(digits[i] < 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            \\n            digits[i] = 0;\\n        }\\n        \\n        int[] newNumber = new int [n+1];\\n        newNumber[0] = 1;\\n        \\n        return newNumber;\\n    }",
                "solutionTags": [],
                "code": "    public int[] plusOne(int[] digits) {\\n            \\n        int n = digits.length;\\n        for(int i=n-1; i>=0; i--) {\\n            if(digits[i] < 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            \\n            digits[i] = 0;\\n        }\\n        \\n        int[] newNumber = new int [n+1];\\n        newNumber[0] = 1;\\n        \\n        return newNumber;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2706861,
                "title": "java-fastest-0ms-runtime-easy-and-elegant-solution",
                "content": "```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\\n\\n\\nexplanation\\n\\n```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t\\t// starting from extreme right--> if array[i] is less than 9 means can be added with 1\\n\\t\\t// i.e. [ 5,8 ]-->[ 5,9 ] or\\n\\t\\t//      [ 9,4 ]-->[ 9,5 ] or\\n\\t\\t//      [ 6,0 ]-->[ 6,1 ]\\n\\t\\t// and will directly return array\\n\\t}\\n\\tdigits[i] = 0;\\n\\t// if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\\n\\t// and we again revolve around loop to check for number if less than 9 or not\\n\\t// i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\\n\\t//      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\\n\\t// and will directly return array\\n}\\n\\n// if all number inside array are 9\\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\\n\\n\\n// to make like above we need to make new array of length--> n+1\\n// by default new array values are set to -->0 only\\n// thus just changed first value of array to 1 and return the array\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\\n\\n**TC O(n)\\nSC O(n)**\\n\\n\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```\n```\\nfor (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t\\t// starting from extreme right--> if array[i] is less than 9 means can be added with 1\\n\\t\\t// i.e. [ 5,8 ]-->[ 5,9 ] or\\n\\t\\t//      [ 9,4 ]-->[ 9,5 ] or\\n\\t\\t//      [ 6,0 ]-->[ 6,1 ]\\n\\t\\t// and will directly return array\\n\\t}\\n\\tdigits[i] = 0;\\n\\t// if array[i] is not less than 9, means it have to be 9 only then digit is changed to 0,\\n\\t// and we again revolve around loop to check for number if less than 9 or not\\n\\t// i.e. [ 5,9 ]-->[ 5,0 ]-loop->[ 6,0 ] or\\n\\t//      [ 1,9,9 ]-->[ 1,9,0 ]-loop->[ 1,0,0 ]-loop->[ 2,0,0 ]\\n\\t// and will directly return array\\n}\\n\\n// if all number inside array are 9\\n// i.e. [ 9,9,9,9 ] than according to above loop it will become [ 0,0,0,0 ]\\n// but we have to make it like this [ 9,9,9,9 ]-->[ 1,0,0,0,0 ]\\n\\n\\n// to make like above we need to make new array of length--> n+1\\n// by default new array values are set to -->0 only\\n// thus just changed first value of array to 1 and return the array\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054321,
                "title": "simple-c-solution-with-good-explanation",
                "content": "# Intuition\\nIf we thought that all elements of the vector is a number we need to increase it by 1. The input can be 100 digits so we must handle that through digits.\\n\\n# Approach\\nFirst we increment the first digit (last element) by 1, if it becomes 10 we make it 0 ans add 1 to the second digit.. until the last digit (first element), if it becoms 10 we make it 1 and push_back a leading zero.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i = n-1; i >= 0; i--){\\n            if(i == n-1)\\n                v[i]++;\\n            if(v[i] == 10){\\n                v[i] = 0;\\n                if(i != 0){\\n                    v[i-1]++;\\n                }\\n                else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nDon\\'t forget please :\\')\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/a6b046f8-0b13-4de1-95f9-78327b0dccba_1673782056.4431267.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i = n-1; i >= 0; i--){\\n            if(i == n-1)\\n                v[i]++;\\n            if(v[i] == 10){\\n                v[i] = 0;\\n                if(i != 0){\\n                    v[i-1]++;\\n                }\\n                else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723116,
                "title": "c-solution-with-intuitive-explanation",
                "content": "My solution is nothing special and isn\\'t clever at all.  I decided to post it since I thought the [\"official\" solution article from leetcode](https://leetcode.com/problems/plus-one/solution/) was very poorly written and confused me more, even after I solved it on my own.\\n\\nSo, I believe my comments below should explain the idea, but I want to add that it helps to test the more obscure test cases for this problem to understand the algorithm.  For example:\\n\\n- `[9]`\\n- `[9090]`\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```\\n\\nAs always, I look forward to comments and feedback. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24139,
                "title": "simple-java-solution",
                "content": "\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >=0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {\\n            int[] res = new int[digits.length+1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        return digits;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >=0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {\\n            int[] res = new int[digits.length+1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24085,
                "title": "simple-python-solution-with-explanation-plus-one",
                "content": "    def plusOne(digits):\\n        num = 0\\n        for i in range(len(digits)):\\n        \\tnum += digits[i] * pow(10, (len(digits)-1-i))\\n        return [int(i) for i in str(num+1)]\\n\\nWe're given a list of digits, and the idea here is to convert that list to an integer, *num*. So each digit is multiplied by the proper place value and added to *num*. For example, if *digits* = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to *num*. Then 8 is multiplied by 10^2 and added to *num*, and so on.\\n\\nThe last step is to add 1 to *num*, convert it to a list and return that list.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def plusOne(digits):\\n        num = 0\\n        for i in range(len(digits)):\\n        \\tnum += digits[i] * pow(10, (len(digits)-1-i))\\n        return [int(i) for i in str(num+1)]\\n\\nWe're given a list of digits, and the idea here is to convert that list to an integer, *num*. So each digit is multiplied by the proper place value and added to *num*. For example, if *digits* = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to *num*. Then 8 is multiplied by 10^2 and added to *num*, and so on.\\n\\nThe last step is to add 1 to *num*, convert it to a list and return that list.",
                "codeTag": "Python3"
            },
            {
                "id": 24289,
                "title": "java-concise-solution-with-early-return",
                "content": "    \\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        for (int i = digits.length-1; i>= 0; i--) {\\n            digits[i] += carry;\\n            if (digits[i] <= 9) // early return \\n                return digits;\\n            digits[i] = 0;\\n        }\\n        int[] ret = new int[digits.length+1];\\n        ret[0] = 1;\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        for (int i = digits.length-1; i>= 0; i--) {\\n            digits[i] += carry;\\n            if (digits[i] <= 9) // early return \\n                return digits;\\n            digits[i] = 0;\\n        }\\n        int[] ret = new int[digits.length+1];\\n        ret[0] = 1;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 438791,
                "title": "recursive-python-solution-98-87-speed-100-memory",
                "content": "While this can be solved with a one liner, I thought that it was also a good candidate for a simple little soliution that modfiies the values in the list without converting to different formats etc. Uses recursion to deal with adding 1 to 9.\\n```python\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if digits[-1] < 9:\\n            digits[-1] += 1\\n            return digits\\n        elif len(digits) == 1 and digits[0] == 9:\\n            return [1, 0]\\n        else:\\n            digits[-1] = 0\\n            digits[0:-1] = self.plusOne(digits[0:-1])\\n            return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if digits[-1] < 9:\\n            digits[-1] += 1\\n            return digits\\n        elif len(digits) == 1 and digits[0] == 9:\\n            return [1, 0]\\n        else:\\n            digits[-1] = 0\\n            digits[0:-1] = self.plusOne(digits[0:-1])\\n            return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24297,
                "title": "simple-direct-javascript-solution",
                "content": "    var plusOne = function(digits) {\\n    for(var i = digits.length - 1; i >= 0; i--){\\n         digits[i]++; \\n        if(digits[i] > 9){\\n            digits[i] = 0;\\n        }else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n    };\\n\\n\\nFirst, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array. \\n\\nLast, when running over for loop, I just put fill 1 in front of the array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var plusOne = function(digits) {\\n    for(var i = digits.length - 1; i >= 0; i--){\\n         digits[i]++; \\n        if(digits[i] > 9){\\n            digits[i] = 0;\\n        }else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n    };\\n\\n\\nFirst, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array. \\n\\nLast, when running over for loop, I just put fill 1 in front of the array.",
                "codeTag": "Unknown"
            },
            {
                "id": 3090372,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n       int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i)\\n      { \\n        if (digits[i] == 9)\\n            digits[i] = 0;\\n      else\\n      {  \\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    } \\n    \\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n       int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i)\\n      { \\n        if (digits[i] == 9)\\n            digits[i] = 0;\\n      else\\n      {  \\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    } \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24122,
                "title": "my-c-solution-with-few-lines",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            bool carry = true;\\n            \\n            for(int i=digits.size()-1; i >= 0 && carry; i--) {\\n                carry = (++digits[i]%=10) == 0;\\n            }\\n    \\n            if(carry) {\\n                digits.insert(digits.begin(), 1);\\n            }\\n        \\n            return digits;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            bool carry = true;\\n            \\n            for(int i=digits.size()-1; i >= 0 && carry; i--) {\\n                carry = (++digits[i]%=10) == 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24353,
                "title": "simple-javascript-solution",
                "content": "    var plusOne = function(digits) {\\n      for(var i = digits.length - 1; i >= 0; i--){\\n        if(++digits[i] > 9) digits[i] = 0;\\n        else return digits;\\n      }\\n      digits.unshift(1);\\n      return digits;\\n    };",
                "solutionTags": [],
                "code": "    var plusOne = function(digits) {\\n      for(var i = digits.length - 1; i >= 0; i--){\\n        if(++digits[i] > 9) digits[i] = 0;\\n        else return digits;\\n      }\\n      digits.unshift(1);\\n      return digits;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 24091,
                "title": "easy-python-solution-o-n",
                "content": "\\n    def plusOne(digits):\\n        digits[-1] += 1\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] != 10:\\n                break\\n            digits[i] = 0\\n            digits[i-1] += 1\\n        \\n        if digits[0] == 10:\\n            digits[0] = 0\\n            return [1] + digits\\n        return digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def plusOne(digits):\\n        digits[-1] += 1\\n        for i in range(len(digits)-1, 0, -1):\\n            if digits[i] != 10:\\n                break\\n            digits[i] = 0\\n            digits[i-1] += 1\\n        \\n        if digits[0] == 10:\\n            digits[0] = 0\\n            return [1] + digits\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 24090,
                "title": "python-simple-solution-using-recursion",
                "content": "    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(digits) == 0:\\n            digits = [1]\\n        elif digits[-1] == 9:\\n            digits = self.plusOne(digits[:-1])\\n            digits.extend([0])\\n        else:\\n            digits[-1] += 1\\n        return digits",
                "solutionTags": [],
                "code": "    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(digits) == 0:\\n            digits = [1]\\n        elif digits[-1] == 9:\\n            digits = self.plusOne(digits[:-1])\\n            digits.extend([0])\\n        else:\\n            digits[-1] += 1\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 485912,
                "title": "c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size() - 1;i >= 0;i--){\\n            if(digits[i] != 9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else\\n                digits[i] = 0;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size() - 1;i >= 0;i--){\\n            if(digits[i] != 9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else\\n                digits[i] = 0;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147127,
                "title": "javascript-simple-solution",
                "content": "```\\nvar plusOne = function(digits) {\\n  for(let i = digits.length - 1; i >= 0; i --){\\n    if(digits[i] === 9){\\n      digits[i] = 0;\\n    }\\n    else {\\n      digits[i] ++;\\n      return digits;\\n    }\\n  }\\n  return [1, ...digits];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar plusOne = function(digits) {\\n  for(let i = digits.length - 1; i >= 0; i --){\\n    if(digits[i] === 9){\\n      digits[i] = 0;\\n    }\\n    else {\\n      digits[i] ++;\\n      return digits;\\n    }\\n  }\\n  return [1, ...digits];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129110,
                "title": "simplest-python-approach-beats-99-5",
                "content": "# Intuition\\nOften the obvious approach is among the best. If you just convert to an integer and add one, it beats 98% of solutions.\\n\\n# Approach\\nInstead of looping across the list and accounting for random 9s, just convert to an integer and add one.  Then convert back to a list.\\n\\n# Complexity\\nThe time complexity is O(n) because we have to traverse the list exactly once then convert back to a list.\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)\\n\\n        temp = str(int(strings) +1)\\n\\n        return [int(temp[i]) for i in range(len(temp))]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        strings = \"\"\\n        for number in digits:\\n            strings += str(number)\\n\\n        temp = str(int(strings) +1)\\n\\n        return [int(temp[i]) for i in range(len(temp))]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383696,
                "title": "super-simple-java-solution-explained-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int len = digits.length; // length of array;\\n        \\n        // start the loop from last index;\\n        for (int i = len-1; i>=0; i--) {\\n            // if ith index is 9, that means there will be an overflow if we add 1\\n            // adding 1 will make it 10, so we set it to 0. and continue the loop; \\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }else {\\n                // if ith value is not 9 we just add 1 to it and return;\\n                digits[i] += 1;\\n                return digits;\\n            }     \\n        }\\n        \\n        // if we are here, that means all the value of the array were 9;\\n        // and they are 0 now;\\n        // example: [9,9,9,9], after loop becomes [0,0,0,0];\\n        // so we have to create a new array of +1 length of the previous.\\n        // and place 1 at 0th index;\\n        int[] arr = new int[len+1];\\n        arr[0] = 1;\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int len = digits.length; // length of array;\\n        \\n        // start the loop from last index;\\n        for (int i = len-1; i>=0; i--) {\\n            // if ith index is 9, that means there will be an overflow if we add 1\\n            // adding 1 will make it 10, so we set it to 0. and continue the loop; \\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3073756,
                "title": "one-line-js-solution-with-full-explanation-beginner-friendly",
                "content": "\\n# Approach\\nAs we are told we are given a large integer represented as an integer array. So we should use the BigInt type. Our first work is joining the numbers using join() method and of course we wrap it in BigInt and add BigInt(1). Because we can\\'t add regular number to bigInt, this is why we are using the bigInt type for 1 too. And we convert the BigInt to a string and split() it\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 65 ms\\nBeats 74.99%\\n\\n\\n- Space complexity:\\nMemor: 41.7 MB\\nBeats 81.73%\\n\\n# Code\\n```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    return (BigInt(digits.join(\"\")) + BigInt(1)).toString().split(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    return (BigInt(digits.join(\"\")) + BigInt(1)).toString().split(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674763,
                "title": "c-simple-solution",
                "content": "```\\n for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468139,
                "title": "python-3-one-line-solution-explained",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [x for x in str(int(\\'\\'.join(map(str, digits))) + 1)]\\n```\\n\\n1. `map(str, digits)` - applies funciton `str` to every element of the list, returning iterable object \\n2. `\\'\\'.join()` - joins all elements inside parentheses together, using empty separator, specified between `\\'\\'`\\n3. `int` converts joined string og digits to integer value\\n4. `+1` increases it\\n5. `str` converts new number into string\\n6. `[x for x in ...]` generates list of digits in string from step 5.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [x for x in str(int(\\'\\'.join(map(str, digits))) + 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758992,
                "title": "c-solution-that-passed-all-test-cases",
                "content": "C# Solution that passed all test cases\\n\\n```\\n        public int[] PlusOne(int[] digits)\\n        {\\n            int n = digits.Length;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                if (digits[i] < 9)\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n                digits[i] = 0;\\n            }\\n            int[] newNumber = new int[n + 1];\\n            newNumber[0] = 1;\\n\\n            return newNumber;\\n        }\\n\\t\\t\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public int[] PlusOne(int[] digits)\\n        {\\n            int n = digits.Length;\\n            for (int i = n - 1; i >= 0; i--)\\n            {\\n                if (digits[i] < 9)\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n                digits[i] = 0;\\n            }\\n            int[] newNumber = new int[n + 1];\\n            newNumber[0] = 1;\\n\\n            return newNumber;\\n        }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 409531,
                "title": "javascript-easy-to-understand-solution",
                "content": "```/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    for(let i = digits.length - 1; i>= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    digits.unshift(1)\\n    return digits\\n};```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n    for(let i = digits.length - 1; i>= 0; i--){\\n        if(digits[i] < 9){\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    digits.unshift(1)\\n    return digits\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 24294,
                "title": "golang-go-solution",
                "content": "    func plusOne(digits []int) []int {\\n        var n int = len(digits)\\n        for i:= n-1; i>=0; i--{\\n            if digits[i] < 9 {\\n                digits[i]+=1\\n                return digits\\n            } else {\\n                digits[i] = 0\\n            }\\n        }\\n        var a = make([]int,n+1)\\n        a[0] = 1\\n        return a\\n    \\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    func plusOne(digits []int) []int {\\n        var n int = len(digits)\\n        for i:= n-1; i>=0; i--{\\n            if digits[i] < 9 {\\n                digits[i]+=1\\n                return digits\\n            } else {\\n                digits[i] = 0\\n            }\\n        }\\n        var a = make([]int,n+1)\\n        a[0] = 1\\n        return a\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915685,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the digits.\\n    //   - space: O(n), where n is the length of the digits.\\n\\n    func plusOne(_ digits: [Int]) -> [Int] {\\n        var digits = digits\\n\\n        for i in (0..<digits.count).reversed() {\\n            guard digits[i] == 9 else {\\n                digits[i] += 1\\n                return digits\\n            }\\n\\n            digits[i] = 0\\n        }\\n\\n        digits.insert(1, at: 0)\\n        return digits\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the digits.\\n    //   - space: O(n), where n is the length of the digits.\\n\\n    func plusOne(_ digits: [Int]) -> [Int] {\\n        var digits = digits\\n\\n        for i in (0..<digits.count).reversed() {\\n            guard digits[i] == 9 else {\\n                digits[i] += 1\\n                return digits\\n            }\\n\\n            digits[i] = 0\\n        }\\n\\n        digits.insert(1, at: 0)\\n        return digits\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24320,
                "title": "java-recursion-solution",
                "content": "    public class Solution {\\n        public int[] plusOne(int[] digits) {\\n            return helper(digits,digits.length-1);\\n        }\\n        \\n        private int[] helper(int[] digits, int index){\\n            if(digits[index] < 9){\\n                digits[index]++;\\n                return digits;\\n            }else{\\n                if(index != 0){\\n                    digits[index] = 0;\\n                    return helper(digits,index-1);\\n                }else{\\n                    int[] res = new int[digits.length+1];\\n                    res[0] = 1;\\n                    return res;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] plusOne(int[] digits) {\\n            return helper(digits,digits.length-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 587672,
                "title": "javascript-simple-solution",
                "content": "Runtime: 52 ms, faster than 81.75% of JavaScript online submissions for Plus One.\\nMemory Usage: 33.8 MB, less than 55.32% of JavaScript online submissions for Plus One.\\n```\\nfunction plusOne(digits) {\\n  let co = true;\\n  for (let i = digits.length - 1; i >= 0 && co; i--) {\\n    digits[i]++;\\n    co = digits[i] >= 10;\\n    co && (digits[i] = 0);\\n  }\\n  co && digits.unshift(1);\\n  return digits;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction plusOne(digits) {\\n  let co = true;\\n  for (let i = digits.length - 1; i >= 0 && co; i--) {\\n    digits[i]++;\\n    co = digits[i] >= 10;\\n    co && (digits[i] = 0);\\n  }\\n  co && digits.unshift(1);\\n  return digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745099,
                "title": "one-for-loop-beats-93",
                "content": "# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]==9:\\n                digits[i]=0\\n            else:\\n                digits[i]+=1\\n                return digits\\n        return [1]+digits\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1,-1,-1):\\n            if digits[i]==9:\\n                digits[i]=0\\n            else:\\n                digits[i]+=1\\n                return digits\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727575,
                "title": "python-100-speed-one-liner-hardworking-way",
                "content": "**Python | 100% Speed | One Liner + Hardworking Way**\\n\\n**A) Python One-Liner**\\n\\nShameless Python One-Liner, O(n) solution.\\nDe-compressed Steps:\\n\\n1. The integer-array \"digits\" is first converted into a joined string: [1,2,3] -> \"123\".  ***Code:**   a = \\'\\'.join(map(str,digits))*\\n2. The joined string is then converted into an integer, and we add one.  ***Code:**   b = int(a)+1\\n3. Our new integer is re-converted into a string, and then into a list format. Finally, the INT operator is applied to each element of the list to obtain new integer digits ***Code:**   [ int(c) for c in str(b) ]  or  list(map(int,str(b)))\\n\\n```\\n# Version A: Outer Loop\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(x) for x in  str(int(\\'\\'.join(map(str,digits)))+1) ]\\n```\\n\\n```\\n# Version B: Pure Functions\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return list(map(int,str(int(\\'\\'.join(map(str,digits)))+1)))\\n```\\n\\n**B) Hardworking Digit Processing - O(1) space**\\n```\\n# Hard-Working Version: Manual Digit Check\\n# O(1) space, and O(1) time for most cases as well (with few chained 9\\'s in the lower digits)\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if not digits:\\n            return digits\\n        i = len(digits)-1\\n        digits[i] += 1\\n        while digits[i]==10:\\n            digits[i] = 0\\n            if i==0:\\n                digits.insert(0,1)\\n            else:\\n                digits[i-1] += 1\\n                i -= 1\\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Version A: Outer Loop\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(x) for x in  str(int(\\'\\'.join(map(str,digits)))+1) ]\\n```\n```\\n# Version B: Pure Functions\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return list(map(int,str(int(\\'\\'.join(map(str,digits)))+1)))\\n```\n```\\n# Hard-Working Version: Manual Digit Check\\n# O(1) space, and O(1) time for most cases as well (with few chained 9\\'s in the lower digits)\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        if not digits:\\n            return digits\\n        i = len(digits)-1\\n        digits[i] += 1\\n        while digits[i]==10:\\n            digits[i] = 0\\n            if i==0:\\n                digits.insert(0,1)\\n            else:\\n                digits[i-1] += 1\\n                i -= 1\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422298,
                "title": "python-solution-faster-than-97-02",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits[idx] != 9:\\n                digits[idx] += 1\\n                break\\n            else:\\n                digits[idx] = 0\\n        if digits[0] == 0:\\n            digits.insert(0, 1)\\n        return digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits[idx] != 9:\\n                digits[idx] += 1\\n                break\\n            else:\\n                digits[idx] = 0\\n        if digits[0] == 0:\\n            digits.insert(0, 1)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322882,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\\n        for x in digits.iter_mut().rev() {\\n            match *x == 9 {\\n                true => *x = 0,\\n                false => {\\n                    *x += 1;\\n                    return digits;\\n                }\\n            }\\n        }\\n        digits.insert(0, 1);\\n        digits\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\\n        for x in digits.iter_mut().rev() {\\n            match *x == 9 {\\n                true => *x = 0,\\n                false => {\\n                    *x += 1;\\n                    return digits;\\n                }\\n            }\\n        }\\n        digits.insert(0, 1);\\n        digits\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708232,
                "title": "easy-and-simplest-c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n= digits.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i]<9){\\n                digits[i]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;        \\n    }\\n};\\n```\\n![4i5ri4f9.png](https://assets.leetcode.com/users/images/280cc0bf-e1b5-417b-a72d-4ba7e737f34f_1688448157.4485767.png)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n= digits.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i]<9){\\n                digits[i]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722211,
                "title": "python-find-maximum-number-of-9-in-the-end-explained",
                "content": "How we can add `1` to given number? We need to find the biggest number of `9` in the end of our number, for example for number `5123521999235123999`, there will be three `9` in the end. `512352199923512`**3999**` + 1 = 512352199923512`**4000**: so we need to increase previous symbol by one and change all `9` after to `0`. Now, the steps of algorithm are to following:\\n\\n1. Let us add one `0` before our data to handle cases like `9`, `99`, `999`, ... \\n2. Find maximum number of `9`, starting from the end and moving to the left.\\n3. Change all found `9` in the end to `0` and previous digit increasy by `1`.\\n4. Handle border cases: if we have leading zero, remove it.\\n\\n**Complexity** time complexity is `O(n)`, where `n` is length of list. Additional space complexity is `O(1)`, because we edit input data directly.\\n\\n```\\nclass Solution:\\n    def plusOne(self, digits):\\n        digits = [0] + digits\\n        \\n        end = len(digits) - 1\\n        while digits[end] == 9:\\n            end -= 1\\n    \\n        digits[end] += 1\\n        digits[end+1:] = [0] * (len(digits)-1-end)\\n                   \\n        return digits if digits[0] != 0 else digits[1:]      \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        digits = [0] + digits\\n        \\n        end = len(digits) - 1\\n        while digits[end] == 9:\\n            end -= 1\\n    \\n        digits[end] += 1\\n        digits[end+1:] = [0] * (len(digits)-1-end)\\n                   \\n        return digits if digits[0] != 0 else digits[1:]      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954062,
                "title": "java-runtime-0-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to solving this problem involves adding one to the given integer represented by an array of digits. I\\'ll iterate through the array of digits from right to left, simulating the process of adding one to the number.\\n\\n# Approach\\nI will iterate through the array of digits from right to left. For each digit, I\\'ll check if it\\'s 9. If it\\'s 9, I\\'ll set it to 0 and continue iterating. If it\\'s not 9, I\\'ll increment it by one and immediately return the modified array. This is because there\\'s no need to carry over to the next digit in this case.\\n\\nIf the loop completes without returning, it means all digits were 9, and we need to add a new leading digit. I\\'ll create a new array with a length one more than the original array, set the first element to 1, and return the new array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the array of digits once, where \\'n\\' is the length of the array.\\n\\n- Space complexity: O(n) or O(n+1)\\n  In the worst case, the algorithm creates a new array with a length one more than the original array. Thus, the space complexity can be considered O(n+1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            } else {\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        \\n        int[] newDigits = new int[digits.length + 1];\\n        newDigits[0] = 1;\\n        return newDigits;\\n    }\\n        \\n\\n    }\\n\\n\\n\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                digits[i] = 0;\\n            } else {\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        \\n        int[] newDigits = new int[digits.length + 1];\\n        newDigits[0] = 1;\\n        return newDigits;\\n    }\\n        \\n\\n    }\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568113,
                "title": "easy-c-solution-o-n-time-complexity-just-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will see the last element as we have to add 1 to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start traversing through end.\\n2. If last element is not 9, just add 1 to it and return the vector.\\n3. If last element is 9, make it zero, move ahead (reverse order).\\n4. Now if this element is not 9, add 1 to it and return vector, otherwise if it is also 9, make it zero and repeat the 3rd and 4th steps.\\n5. Now, if the number is 999, then we have to make it 1000 (999 + 1 = 1000). So, push 0 to the last of our vector (0,0,0) so that it becomes (0,0,0,0) and make first element \\'1\\' => 1000.\\n6. This is how we add 1 to the number!\\n7. Thank You, Don\\'t forget to upvote :)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(v[i]<9){\\n                ++v[i];\\n                return v;\\n            }else{\\n                v[i] = 0;\\n            }\\n        }\\n\\n        v.push_back(0);      // to handle \\'999\\' => 999 + 1 = 1000\\n        v[0] = 1;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(v[i]<9){\\n                ++v[i];\\n                return v;\\n            }else{\\n                v[i] = 0;\\n            }\\n        }\\n\\n        v.push_back(0);      // to handle \\'999\\' => 999 + 1 = 1000\\n        v[0] = 1;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455692,
                "title": "java-100-faster-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/15360baf-39c0-45e7-b2e2-b8d6d07813d5_1682477226.014943.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        // Starting from the least significant digit (i.e., the last element of the array)\\n        for (int i = n - 1; i >= 0; i--) {\\n            // If the current digit is less than 9, we can add 1 to it and return the updated array\\n            if (digits[i] < 9) {\\n                digits[i]++; // Add 1 to the current digit\\n                return digits; // Return the updated array\\n            }\\n            // If the current digit is 9, we set it to 0 and continue with the next digit\\n            else {\\n                digits[i] = 0; // Set the current digit to 0\\n            }\\n        }\\n        // If we reach here, it means all digits were 9, so we need to create a new array with one more element\\n        int[] result = new int[n + 1]; // Create a new array with length n + 1\\n        result[0] = 1; // Set the first element to 1, since all other elements are 0 by default\\n        return result; // Return the new array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        // Starting from the least significant digit (i.e., the last element of the array)\\n        for (int i = n - 1; i >= 0; i--) {\\n            // If the current digit is less than 9, we can add 1 to it and return the updated array\\n            if (digits[i] < 9) {\\n                digits[i]++; // Add 1 to the current digit\\n                return digits; // Return the updated array\\n            }\\n            // If the current digit is 9, we set it to 0 and continue with the next digit\\n            else {\\n                digits[i] = 0; // Set the current digit to 0\\n            }\\n        }\\n        // If we reach here, it means all digits were 9, so we need to create a new array with one more element\\n        int[] result = new int[n + 1]; // Create a new array with length n + 1\\n        result[0] = 1; // Set the first element to 1, since all other elements are 0 by default\\n        return result; // Return the new array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614101,
                "title": "c-simple-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```\\n**Please upvote if you like the solution\\ncomment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529365,
                "title": "java-tc-o-n-sc-o-1-optimized-math-addition-simulation",
                "content": "```java\\n/**\\n * Simulate Math Addition\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1) --> Excluding the result space\\n *\\n * N = Length of input digits array.\\n */\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        if (digits == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = digits.length;\\n        if (len == 0) {\\n            return new int[] { 1 };\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n\\n        digits = new int[len + 1];\\n        digits[0] = 1;\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Simulate Math Addition\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1) --> Excluding the result space\\n *\\n * N = Length of input digits array.\\n */\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        if (digits == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = digits.length;\\n        if (len == 0) {\\n            return new int[] { 1 };\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n\\n        digits = new int[len + 1];\\n        digits[0] = 1;\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24310,
                "title": "python-solution-simple",
                "content": "\\n\\n    def plusOne(self, digits):\\n        for i in xrange(len(digits)-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n        return [1] + digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    def plusOne(self, digits):\\n        for i in xrange(len(digits)-1, -1, -1):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            digits[i] = 0\\n        return [1] + digits",
                "codeTag": "Python3"
            },
            {
                "id": 1286610,
                "title": "javascript-simple-iterative-solution-faster-than-92-65-72ms",
                "content": "```\\nvar plusOne = function(digits) {    \\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] !== 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n        if (i === 0) {\\n            digits.unshift(1);\\n            return digits;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar plusOne = function(digits) {    \\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] !== 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n        if (i === 0) {\\n            digits.unshift(1);\\n            return digits;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283271,
                "title": "100-fast-solution-in-golang-detailed-video-explanation-o-n",
                "content": "I have created a detailed video to explain the logic and the code for this problem you can have a look at it incase you want better understanding on how I came up with the approch\\n[Plus One| O(n) Solution by The Exception Handler](https://www.youtube.com/watch?v=mrYywKoIq-E&list=PL8-bdB4cHmXzuGvBnFmByq-4yyAy-ceaK&index=3)\\n\\n```\\nfunc plusOne(digits []int) []int {\\n    \\n\\tn := len(digits)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif digits[i] < 9 {\\n\\t\\t\\tdigits[i]++\\n\\t\\t\\treturn digits\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\n\\t}\\n\\tdigits = append([]int{1}, digits...)\\n\\treturn digits\\n}\\n```\\n\\nPlease upvote this solution in case you like the explaniation",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    \\n\\tn := len(digits)\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif digits[i] < 9 {\\n\\t\\t\\tdigits[i]++\\n\\t\\t\\treturn digits\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\n\\t}\\n\\tdigits = append([]int{1}, digits...)\\n\\treturn digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022733,
                "title": "kotlin",
                "content": "```\\nfun plusOne(digits: IntArray): IntArray {\\n        for (i in digits.size - 1 downTo 0) {\\n            digits[i] += 1\\n            if (digits[i] <= 9) return digits\\n            digits[i] = 0\\n        }\\n        val arr = IntArray(digits.size + 1)\\n        arr[0] = 1\\n\\n        return arr\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun plusOne(digits: IntArray): IntArray {\\n        for (i in digits.size - 1 downTo 0) {\\n            digits[i] += 1\\n            if (digits[i] <= 9) return digits\\n            digits[i] = 0\\n        }\\n        val arr = IntArray(digits.size + 1)\\n        arr[0] = 1\\n\\n        return arr\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832514,
                "title": "javascript-solution-66",
                "content": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nlet plusOne = function(digits) {\\n    for(let i=digits.length-1;i>=0;i--){\\n        digits[i]++;\\n        if(digits[i]>9){\\n            digits[i]=0;\\n        }\\n        else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```\\n**Runtime: 72 ms, faster than 83.48% of JavaScript online submissions for Plus One.**\\n\\n**Memory Usage: 37 MB, less than 9.82% of JavaScript online submissions for Plus One.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nlet plusOne = function(digits) {\\n    for(let i=digits.length-1;i>=0;i--){\\n        digits[i]++;\\n        if(digits[i]>9){\\n            digits[i]=0;\\n        }\\n        else{\\n            return digits;\\n        }\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24086,
                "title": "recursive-c-solution-3ms",
                "content": "```\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        if (digits.back() == 9)\\n        {\\n            digits.pop_back();\\n            digits = plusOne(digits);\\n            digits.push_back(0);\\n        }\\n        \\n        else if (digits.empty())\\n            digits.push_back(1);\\n\\n        else\\n            digits.back()++;\\n        \\n        return digits;\\n    }\\n```\\nIf the last digit is ```9```, we remove that ```9``` from the vector and add ```1``` to the vector without ```9```; essentially carrying the ```1```. After adding the ```1``` we put``` 0``` at the end of the vector, which will take the place of the ```9 ```from this particular recursion. Since the input is described as non-empty, we can assume the vector will only be empty if it was composed solely of 9's. Thus, we simply push_back ```1``` and return the vector.\\nThis allows for ```plusOne([9,9,9])``` to return ```[1,0,0,0]```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        if (digits.back() == 9)\\n        {\\n            digits.pop_back();\\n            digits = plusOne(digits);\\n            digits.push_back(0);\\n        }\\n        \\n        else if (digits.empty())\\n            digits.push_back(1);\\n\\n        else\\n            digits.back()++;\\n        \\n        return digits;\\n    }\\n```\n```9```\n```9```\n```1```\n```9```\n```1```\n```1```\n``` 0```\n```9 ```\n```1```\n```plusOne([9,9,9])```\n```[1,0,0,0]```",
                "codeTag": "Unknown"
            },
            {
                "id": 24125,
                "title": "0ms-java-solution",
                "content": "    public int[] plusOne(int[] digits) {\\n        int i = digits.length - 1;\\n        while(i >= 0){\\n            if(digits[i] == 9)\\n                digits[i--] = 0;\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        int[] array = new int[digits.length+1];\\n        array[0] = 1;\\n        return array;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] plusOne(int[] digits) {\\n        int i = digits.length - 1;\\n        while(i >= 0){\\n            if(digits[i] == 9)\\n                digits[i--] = 0;\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        int[] array = new int[digits.length+1];\\n        array[0] = 1;\\n        return array;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24416,
                "title": "share-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {   //\\u672a\\u8003\\u8651\\u524d\\u7f000\\u7684\\u60c5\\u51b5\\n            for(int i = digits.size() - 1; i >= 0; i--)   \\n            {\\n                if(digits[i] != 9)\\n                {\\n                    digits[i] ++;\\n                    break;\\n                }\\n                digits[i] = 0;\\n            }\\n            if(digits[0] == 0)\\n                digits.insert(digits.begin(), 1);\\n            return digits;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {   //\\u672a\\u8003\\u8651\\u524d\\u7f000\\u7684\\u60c5\\u51b5\\n            for(int i = digits.size() - 1; i >= 0; i--)   \\n            {\\n                if(digits[i] != 9)\\n                {\\n                    digits[i] ++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3032275,
                "title": "beats-98-7-solutions-easy-to-understand-single-for-loop-o-n-tc-in-python-by-bolt-coding",
                "content": "# Explanation\\nWe are iterating from back to the list as we need to add at the end. We are checking if the current digit is 9. That means we have to replace 9 with 0 and have a carry of 1. If thats not the case then we don\\'t have to iterate through whole loop, we can simply return the list of digit from there.\\n\\nIn case its running until the loop ends, that means all the digits are 9. So inorder to insert a 1 at 0 position we appened with an additional 0 at the end and changed digit[0] to 1. Now there are various ways to do the same, we can use insert method as well.\\n# Complexity\\n- Time complexity: O(n) as we are using a single loop and worst case if all the digits are 9 we have to iterate through whole loop \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) as we haven\\'t used any additional variable to store the number.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digit: List[int]) -> List[int]:\\n        for i in range(len(digit)-1, -1, -1):\\n            if digit[i] == 9:\\n                digit[i] = 0\\n            else:\\n                digit[i]+=1\\n                return digit\\n    \\n        digit.append(0)            \\n        digit[0] = 1\\n        return digit\\n        \\n\\n        \\n```\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digit: List[int]) -> List[int]:\\n        for i in range(len(digit)-1, -1, -1):\\n            if digit[i] == 9:\\n                digit[i] = 0\\n            else:\\n                digit[i]+=1\\n                return digit\\n    \\n        digit.append(0)            \\n        digit[0] = 1\\n        return digit\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331911,
                "title": "javascript-easy-solution",
                "content": "Easy to understand solution I found, not the fastest around, but nice for beginners like me :) \\n\\n```\\nvar plusOne = function(digits) {\\n    const fromArray = digits.join(\\'\\'); // get Digits out of Array\\n    const toInt = BigInt(fromArray) ; //Dont use parseInt, use BigInt instead :) \\n    const addOne = toInt + 1n; // add one! \\n    const result =  Array.from(String(addOne), Number); // return digits to array\\n    return result\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    const fromArray = digits.join(\\'\\'); // get Digits out of Array\\n    const toInt = BigInt(fromArray) ; //Dont use parseInt, use BigInt instead :) \\n    const addOne = toInt + 1n; // add one! \\n    const result =  Array.from(String(addOne), Number); // return digits to array\\n    return result\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24461,
                "title": "fastest-and-simplest-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            int i,j,carry=1;\\n            // traditional long addition..\\n            for(i=digits.size()-1;i>=0&&carry;i--){\\n                int sum=carry+digits[i];\\n                carry=sum/10;\\n                digits[i]=sum%10;\\n            }\\n            if(carry){ // if carry is 1, then digits must be all 99..999\\n                digits[0]=1;\\n                digits.push_back(0);\\n            }\\n            return digits;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int> &digits) {\\n            int i,j,carry=1;\\n            // traditional long addition..\\n            for(i=digits.size()-1;i>=0&&carry;i--){\\n                int sum=carry+digits[i];\\n                carry=sum/10;\\n                digits[i]=sum%10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2314145,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n\\n```\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNumber = new int [n+1];\\n    newNumber[0] = 1;\\n    \\n    return newNumber;\\n}\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNumber = new int [n+1];\\n    newNumber[0] = 1;\\n    \\n    return newNumber;\\n}\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188812,
                "title": "java-0ms-easy-100",
                "content": "If it helps, do an Upvote \\u2B06\\uFE0F\\uD83C\\uDD99 So others can also find it helpful\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(++digits[i] != 10) return digits;\\n            digits[i] = 0;\\n        }\\n        int [] res = new int[digits.length + 1];\\n        \\n        res[0] = 1;\\n        return res;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(++digits[i] != 10) return digits;\\n            digits[i] = 0;\\n        }\\n        int [] res = new int[digits.length + 1];\\n        \\n        res[0] = 1;\\n        return res;\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24174,
                "title": "simple-swift-solution",
                "content": "```\\nfunc plusOne(_ digits: [Int]) -> [Int] {\\n        var result = digits\\n        for i in (0..<result.count).reversed() {\\n            if result[i] != 9 {\\n                result[i] = result[i]+1\\n                return result\\n            } else {\\n                result[i] = 0\\n            }\\n        }\\n        if result.first == 0 {\\n            result.insert(1, at: 0)\\n        }\\n        return result\\n    }\\n```\\nExplanation: Loop from the end of the array to start. Just add 1 if the digit is not a 9, and return. If digit is a 9, replace it with a 0 and go to the previous digit - rinse an repeat. In the end, check if the first digit of the resulting array is a 0. If it is, that means that the number was of the form 9999... In this case, insert a 1 in the start.",
                "solutionTags": [],
                "code": "```\\nfunc plusOne(_ digits: [Int]) -> [Int] {\\n        var result = digits\\n        for i in (0..<result.count).reversed() {\\n            if result[i] != 9 {\\n                result[i] = result[i]+1\\n                return result\\n            } else {\\n                result[i] = 0\\n            }\\n        }\\n        if result.first == 0 {\\n            result.insert(1, at: 0)\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24349,
                "title": "simple-python-o-n-solution-without-converting-to-a-number",
                "content": "The idea here is to start from the right side.  As soon as we find a number that isn't 9 we can add 1 to it and return.  If the number is 9, we change it to 0 and continue until we find a number that is not 9 to carry the 1 to.  If we reach the end of array with all 9's we then insert the 1 in front of array. \\n\\n\\n     def plusOne(self, digits):\\n        for i in range(len(digits)-1, -1, -1):\\n            digits[i] = digits[i] + 1 if digits[i] < 9 else 0\\n            if digits[i]: \\n                return digits\\n        digits.insert(0, 1)\\n        return digits",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea here is to start from the right side.  As soon as we find a number that isn't 9 we can add 1 to it and return.  If the number is 9, we change it to 0 and continue until we find a number that is not 9 to carry the 1 to.  If we reach the end of array with all 9's we then insert the 1 in front of array. \\n\\n\\n     def plusOne(self, digits):\\n        for i in range(len(digits)-1, -1, -1):\\n            digits[i] = digits[i] + 1 if digits[i] < 9 else 0\\n            if digits[i]: \\n                return digits\\n        digits.insert(0, 1)\\n        return digits",
                "codeTag": "Python3"
            },
            {
                "id": 3624231,
                "title": "easy-approach-0ms-cpp-0-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust iterate from back instead of from front. Then keep adding and handling carry variable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust add as if adding a normal numbers\\nLike if you want to add 239 + 1 then first you do 9+1 = 10, then we take 0 and carry 1.\\nThis 0 above is 10%10 and 1 is 10/10. Thus, I have taken, digits[i] = add%10 and carry is add/10.\\n\\n\\nAt the end if the carry is not 0 --> Add an element in the vector at the frontend.\\nEx - 9 + 1 = 0 and carry 1\\nSo insert it at the beginning as 10 to make 9+1=10\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry = 1;\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            int add = digits[i] + carry;\\n            digits[i] = add%10;\\n            carry = add/10;\\n        }\\n        if(carry > 0){\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry = 1;\\n        for(int i=digits.size() - 1; i>=0; i--){\\n            int add = digits[i] + carry;\\n            digits[i] = add%10;\\n            carry = add/10;\\n        }\\n        if(carry > 0){\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159471,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        carry = 1\\n        for i in range(len(digits)-1, -1, -1):\\n            carry, digits[i] = divmod(digits[i]+carry, 10)\\n            if carry == 0:\\n                return digits\\n        return [1]+digits\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        carry = 1\\n        for i in range(len(digits)-1, -1, -1):\\n            carry, digits[i] = divmod(digits[i]+carry, 10)\\n            if carry == 0:\\n                return digits\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780735,
                "title": "java-solution-easy-to-undersatnd-explained-in-detail",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n * we started checking from back if last digit is less than 9 we simply add one one to the digit and return the digit.\\n *  otherwise the case will be last digit was 9 so we make the digit 0 as we know 9+1 = 10 so last digit in these cases need to be 0 so we do that.\\n *  here we create a new array of size input given to us +1 so that we can actually add 1 to beginning of our new array and we retuen the new array thats it.For ex:[9,9,9] = [1,0,0,0] in this case we need one more digit space as we need to carry 1 so in this way we do this.\\n\\n\\n**If it is helpful please do upvote,Happy coding!!\\n**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i=n-1;i>=0;i--){  \\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        int [] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i=n-1;i>=0;i--){  \\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n        int [] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557528,
                "title": "c-easy-solution",
                "content": "/// C# Code\\npublic int[] PlusOne(int[] digits) {\\n        for(int i=digits.Length-1;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        int[] result=new int[digits.Length+1];\\n        result[0]=1;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "/// C# Code\\npublic int[] PlusOne(int[] digits) {\\n        for(int i=digits.Length-1;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        int[] result=new int[digits.Length+1];\\n        result[0]=1;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 500774,
                "title": "simple-solution-faster-than-98-82",
                "content": "```\\n    public class Solution\\n    {\\n        public int[] PlusOne(int[] digits)\\n        {\\n            for (int i = digits.Length - 1; i >= 0; i--)\\n            {\\n                if (digits[i] == 9)\\n                {\\n                    digits[i] = 0;\\n                }\\n                else\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            }\\n            int[] newBigOne = new int[digits.Length + 1];\\n            newBigOne[0] = 1;\\n            return newBigOne;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int[] PlusOne(int[] digits)\\n        {\\n            for (int i = digits.Length - 1; i >= 0; i--)\\n            {\\n                if (digits[i] == 9)\\n                {\\n                    digits[i] = 0;\\n                }\\n                else\\n                {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            }\\n            int[] newBigOne = new int[digits.Length + 1];\\n            newBigOne[0] = 1;\\n            return newBigOne;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24333,
                "title": "accepted-easy-java-solution",
                "content": "    public static int[] plusOne(int[] digits) {\\n\\t        if(0==digits.length) return digits;\\n\\t\\t    for(int i=digits.length-1;i>=0;i--)\\n\\t\\t    {\\n\\t\\t        \\n\\t\\t       if(digits[i]!=9) {digits[i]++;return digits;}\\n\\t\\t   \\t   else\\tdigits[i]=0;\\n\\t\\t    }\\n\\t\\t  int[] result=new int[digits.length+1];\\n\\t\\t  result[0]=1; \\n\\t\\t  return result;   \\n\\t    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int[] plusOne(int[] digits) {\\n\\t        if(0==digits.length) return digits;\\n\\t\\t    for(int i=digits.length-1;i>=0;i--)\\n\\t\\t    {\\n\\t\\t        \\n\\t\\t       if(digits[i]!=9) {digits[i]++;return digits;}\\n\\t\\t   \\t   else\\tdigits[i]=0;\\n\\t\\t    }\\n\\t\\t  int[] result=new int[digits.length+1];\\n\\t\\t  result[0]=1; \\n\\t\\t  return result;   \\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24346,
                "title": "c-solution-with-comments",
                "content": "    \\n    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    int carry = 1, i = digitsSize;\\n    int* ret = (int*)malloc(sizeof(int)*(digitsSize+1));\\n    while (i > 0) {\\n        ret[i] = (digits[i-1]+carry)%10;\\n        carry = (digits[i-1]+carry)/10;\\n        i--;\\n    }\\n    if (!ret[1]) { \\n        // size increased 1, set the first digit\\n        ret[0] = 1;\\n        *returnSize = digitsSize+1;\\n        return ret;\\n    } else {\\n        *returnSize = digitsSize;\\n        return ret+1;\\n    }",
                "solutionTags": [],
                "code": "    \\n    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    int carry = 1, i = digitsSize;\\n    int* ret = (int*)malloc(sizeof(int)*(digitsSize+1));\\n    while (i > 0) {\\n        ret[i] = (digits[i-1]+carry)%10;\\n        carry = (digits[i-1]+carry)/10;\\n        i--;\\n    }\\n    if (!ret[1]) { \\n        // size increased 1, set the first digit\\n        ret[0] = 1;\\n        *returnSize = digitsSize+1;\\n        return ret;\\n    } else {\\n        *returnSize = digitsSize;\\n        return ret+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3192789,
                "title": "easy-solution-javascript",
                "content": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--){\\n        if(arr[i]<9){\\n            arr[i]++;\\n            return arr;\\n        }\\n        arr[i] = 0;\\n    }\\n    arr.unshift(1);\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--){\\n        if(arr[i]<9){\\n            arr[i]++;\\n            return arr;\\n        }\\n        arr[i] = 0;\\n    }\\n    arr.unshift(1);\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069349,
                "title": "python3-29ms-beats-95",
                "content": "![image.png](https://assets.leetcode.com/users/images/85217fc8-e205-4817-89aa-1d0fb37eae44_1675841089.4490588.png)\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        digits=digits[::-1]\\n        x=1\\n        ans=[]\\n        for i in range(len(digits)):\\n            ans+=[(digits[i]+x)%10]\\n            x=(digits[i]+x)//10\\n        if x:\\n            ans+=[x]\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        digits=digits[::-1]\\n        x=1\\n        ans=[]\\n        for i in range(len(digits)):\\n            ans+=[(digits[i]+x)%10]\\n            x=(digits[i]+x)//10\\n        if x:\\n            ans+=[x]\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520098,
                "title": "easy-javascript-solution",
                "content": "```\\n    // first join the digits with no space and add 1  \\n    let str = digits.join(\"\");\\n    let num = BigInt(str)+ BigInt(1);\\n    // convert the num into array\\n    num = num.toString().split(\\'\\').map((num) => parseInt(num));\\n    return num;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    // first join the digits with no space and add 1  \\n    let str = digits.join(\"\");\\n    let num = BigInt(str)+ BigInt(1);\\n    // convert the num into array\\n    num = num.toString().split(\\'\\').map((num) => parseInt(num));\\n    return num;",
                "codeTag": "Unknown"
            },
            {
                "id": 1794804,
                "title": "python3-one-line-simple-and-fastest-using-str-int-and-line-comprehension",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a=[str(i) for i in digits]\\n        a=\\'\\'.join(a)\\n        a=str(int(a)+1)\\n        return [int(i) for i in a]\\n\\n```\\n\\n**compressed into one line**\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(i) for i in str(int(\\'\\'.join([str(i) for i in digits]))+1)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a=[str(i) for i in digits]\\n        a=\\'\\'.join(a)\\n        a=str(int(a)+1)\\n        return [int(i) for i in a]\\n\\n```\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        return [int(i) for i in str(int(\\'\\'.join([str(i) for i in digits]))+1)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232867,
                "title": "js-faster-than-93-o-n",
                "content": "First we add 1 to the last element. \\nThen, we iteratively check starting from least significant to most significant if the digit is a 10. \\nIf it is, we set it to 0 and to the digit before it we add 1.\\nOnce we are done with this, we update the first digit if it\\'s a 10, adding a digit of 1 in front of it.\\n```\\nconst plusOne = (digits) => {\\n  const last = digits.length - 1;\\n  digits[last]++;\\n  for (let i = last; i > 0 && digits[i] === 10; i--) {\\n    digits[i] = 0;\\n    digits[i - 1]++;\\n  }\\n  if (digits[0] === 10) {\\n    digits[0] = 0;\\n    digits.unshift(1);\\n  }\\n  return digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst plusOne = (digits) => {\\n  const last = digits.length - 1;\\n  digits[last]++;\\n  for (let i = last; i > 0 && digits[i] === 10; i--) {\\n    digits[i] = 0;\\n    digits[i - 1]++;\\n  }\\n  if (digits[0] === 10) {\\n    digits[0] = 0;\\n    digits.unshift(1);\\n  }\\n  return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167759,
                "title": "go-solution",
                "content": "```\\nfunc plusOne(digits []int) []int {\\n    for i := len(digits)-1; i >= 0; i-- {\\n        if digits[i] < 9 {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    \\n    digits = append([]int{1}, digits...)\\n    \\n    return digits\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    for i := len(digits)-1; i >= 0; i-- {\\n        if digits[i] < 9 {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    \\n    digits = append([]int{1}, digits...)\\n    \\n    return digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24372,
                "title": "accepted-4ms-c-solution-easy-and-short",
                "content": "    class Solution {\\n    public:\\n        std::vector<int> plusOne(std::vector<int>& digits) {\\n            int pos = digits.size() - 1;\\n            while (pos >= 0 && digits[pos] == 9) {\\n                digits[pos] = 0;\\n                --pos;\\n            }\\n            if (pos == -1) {\\n                digits[0] = 1;\\n                digits.push_back(0);\\n            } else {\\n                ++digits[pos];\\n            }\\n            return digits;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::vector<int> plusOne(std::vector<int>& digits) {\\n            int pos = digits.size() - 1;\\n            while (pos >= 0 && digits[pos] == 9) {\\n                digits[pos] = 0;\\n                --pos;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3942526,
                "title": "java-simple-solution-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n         \\n        int i = 0;\\n        while (i <= digits.length - 1 && digits[digits.length - 1 - i] == 9) {\\n            i++;\\n        }\\n\\n        int[] output = (digits.length == i) ? new int[digits.length + 1] : new int[digits.length];\\n\\n        if (digits.length == i) {\\n            output[0] = 1;\\n        } else {\\n\\n            for (int j = 0; j <= digits.length - i - 1; j++) \\n            {\\n                output[j] = digits[j];\\n            }\\n\\n            output[digits.length - 1 - i] = digits[digits.length - i - 1] + 1;\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/f7abc399-3a52-4e17-850a-9fc8984ee6c9_1692645882.9655104.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n         \\n        int i = 0;\\n        while (i <= digits.length - 1 && digits[digits.length - 1 - i] == 9) {\\n            i++;\\n        }\\n\\n        int[] output = (digits.length == i) ? new int[digits.length + 1] : new int[digits.length];\\n\\n        if (digits.length == i) {\\n            output[0] = 1;\\n        } else {\\n\\n            for (int j = 0; j <= digits.length - i - 1; j++) \\n            {\\n                output[j] = digits[j];\\n            }\\n\\n            output[digits.length - 1 - i] = digits[digits.length - i - 1] + 1;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056619,
                "title": "c-properly-explained-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n\\n```\\n**Please upvote if it helped. Happy Coding**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { // traverse digits from the last element (least significant)\\n        // since we begin with the last digit, increasing that digit by one\\n        // results in overflow.  Therefore, all elements PRIOR to digits[0]\\n        // need to be considered since there may be additional nines between\\n        // digits[0], ... , digits[n].\\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n      // if the program runs to this point, each 9 is now a 0.\\n      // to get a correct solution, we need to add one more element with \\n      // a value of zero AND set digits[0] to 1 (in the most significant position)\\n      // to account for the carry digit.\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835091,
                "title": "c-most-optimal-solution-0ms-and-less-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s=digits.size()-1;    //Length of the vector \\n        while(s>=0){\\n            if(digits[s]<9){\\n                digits[s]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[s]=0;\\n                s--;\\n            }\\n        }\\n        vector<int> :: iterator iter=digits.begin();   //Inserting 1 if incase the number is [9],[9,9,9,9] etc\\n        digits.insert(iter,1);\\n        return digits;\\n    }\\n};\\n```\\n\\nPlease upvote if found useful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s=digits.size()-1;    //Length of the vector \\n        while(s>=0){\\n            if(digits[s]<9){\\n                digits[s]+=1;\\n                return digits;\\n            }\\n            else{\\n                digits[s]=0;\\n                s--;\\n            }\\n        }\\n        vector<int> :: iterator iter=digits.begin();   //Inserting 1 if incase the number is [9],[9,9,9,9] etc\\n        digits.insert(iter,1);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800794,
                "title": "fast-as-fuck-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n    }\\n};\\n```\\nupvote if useful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i = digits.size()-1; i>=0; i--){\\n                    if(digits[i]<9){\\n                    digits[i]++;\\n                    return digits;\\n                    }\\n                    else\\n                            digits[i] = 0;\\n                    \\n            }\\n            digits.push_back(0);\\n            digits[0] = 1;\\n            return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257638,
                "title": "very-easy-java-solution-100-fully-explained-and-understandable",
                "content": "```\\nclass Solution {\\n\\n    public int[] plusOne(int[] digits) {\\n        \\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            int[] res = new int[digits.length + 1];    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] plusOne(int[] digits) {\\n        \\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.length - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            int[] res = new int[digits.length + 1];    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117634,
                "title": "python-99-75-list-str-int-1-str-list",
                "content": "*Runtime: 20 ms, faster than 99.74% of Python3 online submissions for Plus One.\\nMemory Usage: 14 MB, less than 99.00% of Python3 online submissions for Plus One.*\\n\\nVariables named as writes are much faster than reads:\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a = \\'\\'.join(map(str, digits))\\n        b = int(a) + 1\\n        c = str(b)\\n        return list(map(int, c))\\n```\\nhttps://leetcode.com/submissions/detail/469908019/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        a = \\'\\'.join(map(str, digits))\\n        b = int(a) + 1\\n        c = str(b)\\n        return list(map(int, c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627432,
                "title": "simple-java-code-easy-approach-0ms-runtime",
                "content": "# Intuition\\nAs per the question given we need to increment the array value by one and return the resultant array with ith digit at ith position of that array For example: digits=[1,2,3] after adding one to this array i.e, 123+1=124 ...gives digits=[1,2,4] \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we need to notice that the input maybe given any large integer value so we cannot convert our array into number and increemnt and convert it back as an array instead i followed this follwing logic by taking one place and comparing whether its less than 9 or equal to 9.\\nif its equal to 9 go and check for next ith digit else increment this digit by one and return the array\\nFor better undertanding please see these below steps:\\n1. As its already an int[] array given the last element of the array will be considered as the units place of the number we need to add 1 for last digit if its less than 9\\n2. if the last element is greater than 9 we need to check for before element and increment if its less than 9..\\n3. if all the elements are 9 we need add another element to the array\\nfor example: [9,9] --> [1,0,0]\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    StringBuilder s=new StringBuilder();\\n    public int[] plusOne(int[] digits) {\\n        for(int i=(digits.length)-1;i >= 0;i--){\\n            if(digits[i]<9){\\n                digits[i]=digits[i]+1;\\n                return digits;\\n            }else if(digits[i]==9){\\n                digits[i]=0;\\n            }   \\n        }\\n        int[] newarr=new int[digits.length+1];\\n        newarr[0]=1;\\n        return newarr;\\n    }\\n}\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/239c196e-5f36-48cc-b148-20966d5a3f9f_1687449464.7053354.png)\\n\\n\\n\\n**Guys please upvote if you find my solution worthy!! Thanks!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder s=new StringBuilder();\\n    public int[] plusOne(int[] digits) {\\n        for(int i=(digits.length)-1;i >= 0;i--){\\n            if(digits[i]<9){\\n                digits[i]=digits[i]+1;\\n                return digits;\\n            }else if(digits[i]==9){\\n                digits[i]=0;\\n            }   \\n        }\\n        int[] newarr=new int[digits.length+1];\\n        newarr[0]=1;\\n        return newarr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946815,
                "title": "simple-backward-looping-with-c",
                "content": "# Intuition\\nThought about how we can minimize the amount of computation.\\n\\n# Approach\\nLoop backward. \\n\\n1. In case of 9, assign 0. That means we need to increment next digit.\\n2. The others increment and return the digits. \\n3. If the loop has been finished, that means, it requres additional digit. add it and return it.\\n\\nOnly the 3 cases requires additional Memory space and breaks before reach N.\\n\\n# Complexity\\n- Time complexity:\\nO(2N) = O(N).\\nNOTE: I don\\'t know the internal of Concat method. So that my guess.\\n\\n- Space complexity:\\nO(N): Probably, Linq might create a new List or equivalent.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n       for(int i = digits.Length - 1; i >= 0; i--) {\\n           if (digits[i] == 9) {\\n               digits[i] = 0;\\n           } else {\\n               digits[i]++;\\n               return digits;\\n           }\\n       } \\n       int[] firstOne = new int[] { 1 };\\n       return firstOne.Concat(digits).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n       for(int i = digits.Length - 1; i >= 0; i--) {\\n           if (digits[i] == 9) {\\n               digits[i] = 0;\\n           } else {\\n               digits[i]++;\\n               return digits;\\n           }\\n       } \\n       int[] firstOne = new int[] { 1 };\\n       return firstOne.Concat(digits).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711629,
                "title": "fastest-and-easiest-one-liner-faster-than-92-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/5c6d1d55-0730-49d9-a4d8-2d838174d939_1666035771.7792413.png)\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        d=int(\"\".join(map(str, digits)))\\n        d+=1\\n        return list(str(d))\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        d=int(\"\".join(map(str, digits)))\\n        d+=1\\n        return list(str(d))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543183,
                "title": "easy-java-solution-faster-than-100-users",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i =n-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n            \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for(int i =n-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n            \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754490,
                "title": "c-solution-fastest-with-least-time-complexity-and-constant-space",
                "content": "```\\n        //storing given array\\'s size in n\\n        int n = digits.size();\\n        \\n        //taking flag for putting a condition further in code\\n        bool flag = 0;\\n        \\n        //traversing from the last for incrementing with a condition i.e. digit should be < 9.\\n        for(int i = n-1; i>=0; i--){\\n            //checking condition whether digit < 9\\n            if(digits[i]<9){\\n                digits[i] = digits[i] + 1;\\n                flag = 1;\\n                break;\\n            }else{\\n                //if digit is not < 9, then we have to make it 0(coz 9 + 1 = 10(0 in this case, as we are taking ones place))\\n                digits[i] = 0;\\n            }\\n        }\\n        //checking if flag is still 0, if it is 0 then we have to insert 1 at the beginning\\n        if(flag==0){\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n        //storing given array\\'s size in n\\n        int n = digits.size();\\n        \\n        //taking flag for putting a condition further in code\\n        bool flag = 0;\\n        \\n        //traversing from the last for incrementing with a condition i.e. digit should be < 9.\\n        for(int i = n-1; i>=0; i--){\\n            //checking condition whether digit < 9\\n            if(digits[i]<9){\\n                digits[i] = digits[i] + 1;\\n                flag = 1;\\n                break;\\n            }else{\\n                //if digit is not < 9, then we have to make it 0(coz 9 + 1 = 10(0 in this case, as we are taking ones place))\\n                digits[i] = 0;\\n            }\\n        }\\n        //checking if flag is still 0, if it is 0 then we have to insert 1 at the beginning\\n        if(flag==0){\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 721895,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[] PlusOne(int[] digits) {\\n        int carrier = 1;\\n        \\n        for (int i = digits.Length - 1; i >= 0; i--)\\n        {\\n            int temp = digits[i] + carrier;\\n            \\n            digits[i] = temp % 10;\\n            carrier = temp / 10;\\n        }\\n        \\n        if (carrier == 1)\\n        {\\n            List<int> temp = new List<int>();\\n            \\n            temp.Add(carrier);\\n            \\n            foreach (var n in digits)\\n                temp.Add(n);\\n            \\n            return temp.ToArray();\\n        }\\n        \\n        return digits;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] PlusOne(int[] digits) {\\n        int carrier = 1;\\n        \\n        for (int i = digits.Length - 1; i >= 0; i--)\\n        {\\n            int temp = digits[i] + carrier;\\n            \\n            digits[i] = temp % 10;\\n            carrier = temp / 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 24150,
                "title": "a-few-lines-of-javascript",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        digits[i] = (digits[i] + 1) % 10;\\n        if (digits[i]) return digits;\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        digits[i] = (digits[i] + 1) % 10;\\n        if (digits[i]) return digits;\\n    }\\n    digits.unshift(1);\\n    return digits;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24338,
                "title": "simple-java-solution-no-copying-arrays",
                "content": "Start from the end. If the current number is less than 9, we won't have a carry: increment the digit and return the array. If we have a 9, then set the current to 0 and simply repeat with the next digit.\\n\\nHere's the kicker: if we complete the loop and don't return, this means that the whole array was set to 0! The answer must therefore be an array that's one bigger with the first number being 1. There's no need to copy to the new array since all numbers are by default initialized to 0.\\n\\n    public int[] plusOne(int[] digits) {\\n        if(digits == null || digits.length == 0){\\n            return new int[0];\\n        }\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{\\n                digits[i] = 0;\\n            }\\n        }\\n        \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Start from the end. If the current number is less than 9, we won't have a carry: increment the digit and return the array. If we have a 9, then set the current to 0 and simply repeat with the next digit.\\n\\nHere's the kicker: if we complete the loop and don't return, this means that the whole array was set to 0! The answer must therefore be an array that's one bigger with the first number being 1. There's no need to copy to the new array since all numbers are by default initialized to 0.\\n\\n    public int[] plusOne(int[] digits) {\\n        if(digits == null || digits.length == 0){\\n            return new int[0];\\n        }\\n        \\n        for(int i = digits.length - 1; i >= 0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{\\n                digits[i] = 0;\\n            }\\n        }\\n        \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24386,
                "title": "short-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> plusOne(vector<int>& digits) {\\n            for (int k = digits.size() - 1; k >= 0; --k) {\\n                if (digits[k] < 9) { \\n                    digits[k]++; \\n                    return digits; \\n                } else {\\n                    digits[k] = 0;\\n                }\\n            }\\n            digits[0] = 1, digits.push_back(0);\\n            return digits;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> plusOne(vector<int>& digits) {\\n            for (int k = digits.size() - 1; k >= 0; --k) {\\n                if (digits[k] < 9) { \\n                    digits[k]++; \\n                    return digits; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3138391,
                "title": "straightforward-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe initialize an empty string and fill it with the digits. Then we cast it to an integer and add one. we will then createa a new empty list and go through the characters of the typecasted number (so that its iterable) and append to the empty answer list. Finally, we return the list\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        string = \"\"\\n        for digit in digits:\\n            string += str(digit)\\n        number = int(string) + 1\\n        ans = []\\n        for digit in str(number):\\n            ans.append(int(digit))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        string = \"\"\\n        for digit in digits:\\n            string += str(digit)\\n        number = int(string) + 1\\n        ans = []\\n        for digit in str(number):\\n            ans.append(int(digit))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120632,
                "title": "python-simple-code-beat-100-explained",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        # Adjusting an array of digits into an integer\\n        digits_integer = int(\\'\\'.join(map(str,digits)))\\n        digits_integer +=1\\n        # Adjusting back an integer into an array of digits after plus 1\\n        return [int(x) for x in str(digits_integer)]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        # Adjusting an array of digits into an integer\\n        digits_integer = int(\\'\\'.join(map(str,digits)))\\n        digits_integer +=1\\n        # Adjusting back an integer into an array of digits after plus 1\\n        return [int(x) for x in str(digits_integer)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065579,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Intuition\\nI mean intially I just thought of it being like any other number, just increasing the right will increase the left if it carries over.\\nThat\\'s about it.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i {(int)digits.size()-1}; i >= 0; i--){\\n            if(digits.at(i)!=9){\\n                digits.at(i)++;\\n                break;\\n            }else{digits.at(i)=0;}\\n        }\\n        if(digits.at(0)==0){digits.insert(digits.begin(),1);}\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for(int i {(int)digits.size()-1}; i >= 0; i--){\\n            if(digits.at(i)!=9){\\n                digits.at(i)++;\\n                break;\\n            }else{digits.at(i)=0;}\\n        }\\n        if(digits.at(0)==0){digits.insert(digits.begin(),1);}\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683252,
                "title": "1-line-python",
                "content": "```\\nreturn [int(x) for x in str(int(\"\".join([str(x) for x in digits]))+1)]",
                "solutionTags": [],
                "code": "```\\nreturn [int(x) for x in str(int(\"\".join([str(x) for x in digits]))+1)]",
                "codeTag": "Unknown"
            },
            {
                "id": 2490947,
                "title": "python-easy-solution",
                "content": "```\\ndef plusOne(self, digits: List[int]) -> List[int]: # digits = [4,3,2,1]\\n        st_digits_list = [str(dig) for dig in digits] # [\\'4\\', \\'3\\', \\'2\\', \\'1\\']\\n        st_digits = \"\".join(st_digits_list) # \"4321\"\\n        num = int(st_digits) + 1 # 4322\\n        output= [int(n) for n in str(num)] # [4, 3, 2, 2]\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]: # digits = [4,3,2,1]\\n        st_digits_list = [str(dig) for dig in digits] # [\\'4\\', \\'3\\', \\'2\\', \\'1\\']\\n        st_digits = \"\".join(st_digits_list) # \"4321\"\\n        num = int(st_digits) + 1 # 4322\\n        output= [int(n) for n in str(num)] # [4, 3, 2, 2]\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2432426,
                "title": "java-script-using-only-for-loop-and-if-else-65-ms",
                "content": "//unshit is used to push 1 at front  of array//\\n//if you like it pls upvote//\\nvar plusOne = function(digits) {\\n   for(i=digits.length-1;i>=0;i--){\\n    if(digits[i]!==9){\\n        digits[i]=digits[i]+1;\\n      break;\\n  }\\n   else{\\ndigits[i]=0;\\nif(digits[0]==0){\\n    digits.unshift(1);\\n}\\n   }\\n}return digits;\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "//unshit is used to push 1 at front  of array//\\n//if you like it pls upvote//\\nvar plusOne = function(digits) {\\n   for(i=digits.length-1;i>=0;i--){\\n    if(digits[i]!==9){\\n        digits[i]=digits[i]+1;\\n      break;\\n  }\\n   else{\\ndigits[i]=0;\\nif(digits[0]==0){\\n    digits.unshift(1);\\n}\\n   }\\n}return digits;\\n};\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2370411,
                "title": "0-ms-java-solution",
                "content": "```\\nclass Solution {\\n   public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNo = new int [n+1];\\n    newNo[0] = 1;\\n    \\n    return newNo;\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int[] plusOne(int[] digits) {\\n        \\n    int n = digits.length;\\n    for(int i=n-1; i>=0; i--) {\\n        if(digits[i] < 9) {\\n            digits[i]++;\\n            return digits;\\n        }\\n        \\n        digits[i] = 0;\\n    }\\n    \\n    int[] newNo = new int [n+1];\\n    newNo[0] = 1;\\n    \\n    return newNo;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121244,
                "title": "python-concise-solution-with-divmod",
                "content": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        \\n        carry = 1\\n        \\n        for i in range(len(digits) - 1,-1,-1):\\n            carry, digits[i] = divmod(digits[i] + carry, 10)\\n        \\n        return [carry] + digits if carry else digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        \\n        carry = 1\\n        \\n        for i in range(len(digits) - 1,-1,-1):\\n            carry, digits[i] = divmod(digits[i] + carry, 10)\\n        \\n        return [carry] + digits if carry else digits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1463033,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        pointer = len(digits) - 1\\n        \\n        while digits[pointer] == 9:\\n            digits[pointer] = 0\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            digits.insert(0, 1)\\n        \\n        else:\\n            digits[pointer] += 1\\n        \\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        pointer = len(digits) - 1\\n        \\n        while digits[pointer] == 9:\\n            digits[pointer] = 0\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            digits.insert(0, 1)\\n        \\n        else:\\n            digits[pointer] += 1\\n        \\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808473,
                "title": "javascript",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i != -1; i--) {\\n        if (digits[i] != 9) {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    digits.unshift(1) //Getting here means everything was a 9, so it\\'s now all 0\\'s, meaning we should add a 1 in front.\\n    return digits\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length - 1; i != -1; i--) {\\n        if (digits[i] != 9) {\\n            digits[i] += 1\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    digits.unshift(1) //Getting here means everything was a 9, so it\\'s now all 0\\'s, meaning we should add a 1 in front.\\n    return digits\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24207,
                "title": "c-look-for-first-non-9-from-the-tail-backwards",
                "content": "    public int[] PlusOne(int[] digits) \\n    {\\n        int index = digits.Length - 1;\\n        while (index >= 0 && digits[index] == 9)\\n        {\\n            index--;\\n        }\\n        \\n        if (index < 0)\\n        {\\n            int[] res = new int[digits.Length + 1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        else\\n        {\\n            digits[index++]++;\\n            while (index < digits.Length)\\n            {\\n                digits[index++] = 0;\\n            }\\n            return digits;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public int[] PlusOne(int[] digits) \\n    {\\n        int index = digits.Length - 1;\\n        while (index >= 0 && digits[index] == 9)\\n        {\\n            index--;\\n        }\\n        \\n        if (index < 0)\\n        {\\n            int[] res = new int[digits.Length + 1];\\n            res[0] = 1;\\n            return res;\\n        }\\n        else\\n        {\\n            digits[index++]++;\\n            while (index < digits.Length)\\n            {\\n                digits[index++] = 0;\\n            }\\n            return digits;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24109,
                "title": "my-c-code-accepted-with-2-ms",
                "content": "    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n        if (digits == NULL)\\n        {\\n            return NULL;\\n        }\\n        int n = digitsSize-1;\\n        while(n >= 0)\\n        {\\n            if(digits[n] < 9)\\n            {\\n                digits[n]++;\\n                *returnSize = digitsSize;\\n                return digits;\\n            }else\\n            {\\n                digits[n] = 0;\\n                n--;\\n            }\\n        }\\n        \\n        int* newdigit = (int*)malloc((digitsSize+1) * sizeof(int));\\n        newdigit[0] = 1;\\n        for(int i = 1; i < (digitsSize+1); i++)\\n        {\\n            newdigit[i] = digits[i-1];\\n        }\\n        *returnSize = digitsSize+1;\\n        return newdigit;\\n    }",
                "solutionTags": [],
                "code": "    int* plusOne(int* digits, int digitsSize, int* returnSize) {\\n        if (digits == NULL)\\n        {\\n            return NULL;\\n        }\\n        int n = digitsSize-1;\\n        while(n >= 0)\\n        {\\n            if(digits[n] < 9)\\n            {\\n                digits[n]++;\\n                *returnSize = digitsSize;\\n                return digits;\\n            }else\\n            {\\n                digits[n] = 0;\\n                n--;\\n            }\\n        }\\n        \\n        int* newdigit = (int*)malloc((digitsSize+1) * sizeof(int));\\n        newdigit[0] = 1;\\n        for(int i = 1; i < (digitsSize+1); i++)\\n        {\\n            newdigit[i] = digits[i-1];\\n        }\\n        *returnSize = digitsSize+1;\\n        return newdigit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24458,
                "title": "my-accepted-java-solution",
                "content": "Hi everyone, this is my accepted Java solution. I used a while loop here so that I don't need to go through the entire array if it's not necessary. Basically, the code will start from the last index of the array and go backwards. if there is a carry-over value, then it will keep going, otherwise it will stop. After the traversing is done, it will check if the first digit is zero (9999 + 1 = 0000) and handle that case. Hope this helps :)\\n\\n    public int[] plusOne(int[] digits) {\\n        boolean carry = true;\\n        int index = digits.length - 1;\\n        while (carry && index > -1) {\\n            if (digits[index] == 9) {\\n                digits[index] = 0; // carry remains true\\n            } else {\\n                digits[index] += 1;\\n                carry = false;\\n            }\\n            index--;\\n        }\\n        if (digits[0] == 0) {\\n            int[] result = new int[digits.length + 1];\\n            result[0] = 1;\\n            for (int i = 1; i < digits.length; i++) {\\n                result[i] = digits[i - 1];\\n            }\\n            return result;\\n        }\\n        return digits;\\n    }",
                "solutionTags": [],
                "code": "Hi everyone, this is my accepted Java solution. I used a while loop here so that I don't need to go through the entire array if it's not necessary. Basically, the code will start from the last index of the array and go backwards. if there is a carry-over value, then it will keep going, otherwise it will stop. After the traversing is done, it will check if the first digit is zero (9999 + 1 = 0000) and handle that case. Hope this helps :)\\n\\n    public int[] plusOne(int[] digits) {\\n        boolean carry = true;\\n        int index = digits.length - 1;\\n        while (carry && index > -1) {\\n            if (digits[index] == 9) {\\n                digits[index] = 0; // carry remains true\\n            } else {\\n                digits[index] += 1;\\n                carry = false;\\n            }\\n            index--;\\n        }\\n        if (digits[0] == 0) {\\n            int[] result = new int[digits.length + 1];\\n            result[0] = 1;\\n            for (int i = 1; i < digits.length; i++) {\\n                result[i] = digits[i - 1];\\n            }\\n            return result;\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795230,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially wanted to make a function variable to keep track of wether we needed to carry and was attempting to handle the edge case for if we needed to increase the size of the array in an over complicated way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooping through the array starting at the last element, if a digit is a 9 we make it a zero and repeat. When we\\'re able to add 1 without going over 9 we should break there, because there is no more work left to do. If we dont\\'t find a number that isn\\'t 9 (meaning we never reach the else condition in the loop), we should then create a new array with 1 as the first element followed by the array digits that got turned to all 0\\'s.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n\\n    for(let i = digits.length - 1; i >= 0; i--) {\\n        if(digits[i] === 9) {\\n            digits[i] = 0\\n        }\\n        else {\\n            digits[i] += 1\\n            return digits\\n        }\\n    }\\n\\n    return [1, ...digits]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} digits\\n * @return {number[]}\\n */\\nvar plusOne = function(digits) {\\n\\n    for(let i = digits.length - 1; i >= 0; i--) {\\n        if(digits[i] === 9) {\\n            digits[i] = 0\\n        }\\n        else {\\n            digits[i] += 1\\n            return digits\\n        }\\n    }\\n\\n    return [1, ...digits]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3394130,
                "title": "clear-c-solution-let-s-find-best-solution-together",
                "content": "**`If you have any thought feel free leave a comment below`**\\n\\n# Code\\n```\\n/** Note: The returned array must be malloced, assume     */\\n/** caller calls free().                                  */\\nint *plusOne(int *digits, int digitsSize, int *returnSize) {\\n    *returnSize = digitsSize;\\n    int *plusOne = malloc(digitsSize * sizeof(int));\\n    if (plusOne == NULL)\\n        return (NULL);\\n    for (int i = 0; i < digitsSize; i++)\\n        plusOne[i] = digits[i];\\n    \\n    plusOne[digitsSize - 1]++;\\n    for (int i = digitsSize - 1; i - 1 >= 0; i--)\\n        if (plusOne[i] == 10) {\\n            plusOne[i] = 0;\\n            plusOne[i - 1]++;\\n        }\\n\\n    if (plusOne[0] == 10) {\\n        (*returnSize)++;\\n        plusOne = realloc(plusOne, *returnSize * sizeof(int));\\n        if (plusOne == NULL)\\n            return (NULL);\\n        memmove(plusOne + 1, plusOne, digitsSize * sizeof(int));\\n        plusOne[0] = 1;\\n        plusOne[1] = 0;\\n    }\\n    return (plusOne);\\n}\\n\\n```\\n1) In the first part we just take memory for return array, and copy source array there\\n2) In the second part we add one to the last element. Go through elements of array from the end and on 10, we split it\\n3) In the last part we work with first element equal to 10. If it is so, we need to realloc memory and move an array by one element\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/** Note: The returned array must be malloced, assume     */\\n/** caller calls free().                                  */\\nint *plusOne(int *digits, int digitsSize, int *returnSize) {\\n    *returnSize = digitsSize;\\n    int *plusOne = malloc(digitsSize * sizeof(int));\\n    if (plusOne == NULL)\\n        return (NULL);\\n    for (int i = 0; i < digitsSize; i++)\\n        plusOne[i] = digits[i];\\n    \\n    plusOne[digitsSize - 1]++;\\n    for (int i = digitsSize - 1; i - 1 >= 0; i--)\\n        if (plusOne[i] == 10) {\\n            plusOne[i] = 0;\\n            plusOne[i - 1]++;\\n        }\\n\\n    if (plusOne[0] == 10) {\\n        (*returnSize)++;\\n        plusOne = realloc(plusOne, *returnSize * sizeof(int));\\n        if (plusOne == NULL)\\n            return (NULL);\\n        memmove(plusOne + 1, plusOne, digitsSize * sizeof(int));\\n        plusOne[0] = 1;\\n        plusOne[1] = 0;\\n    }\\n    return (plusOne);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715491,
                "title": "javascript-solution",
                "content": "var plusOne = function (digits) {\\n    let arrToNumber =BigInt(digits.join(\\'\\'))\\n    let res = BigInt(arrToNumber + BigInt(1))\\n    let myFunc = res => Number(res);\\n\\n    var intArr = Array.from(String(res), myFunc);\\n    return intArr\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var plusOne = function (digits) {\\n    let arrToNumber =BigInt(digits.join(\\'\\'))\\n    let res = BigInt(arrToNumber + BigInt(1))\\n    let myFunc = res => Number(res);\\n\\n    var intArr = Array.from(String(res), myFunc);\\n    return intArr\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2526659,
                "title": "0-ms-java-solution-faster-than-100-simple-solution-within-20-lines",
                "content": "vote up if you like my solution or if it helps you !\\n\\n\\n```\\n    public static int[] plusOne (int[] digits) {\\n        int l = digits.length;\\n        if ( digits[l - 1] != 9 ) {\\n            digits[l - 1]++;\\n            return digits;\\n        } else {\\n            int[] temp = new int[l + 1];\\n            for ( int i = l - 1; i >= 0; i-- )\\n                if ( digits[i] == 9 ) {\\n                    digits[i] = i == 0 ? 1 : 0;\\n                    temp[i] = digits[i];\\n                } else {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            return temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static int[] plusOne (int[] digits) {\\n        int l = digits.length;\\n        if ( digits[l - 1] != 9 ) {\\n            digits[l - 1]++;\\n            return digits;\\n        } else {\\n            int[] temp = new int[l + 1];\\n            for ( int i = l - 1; i >= 0; i-- )\\n                if ( digits[i] == 9 ) {\\n                    digits[i] = i == 0 ? 1 : 0;\\n                    temp[i] = digits[i];\\n                } else {\\n                    digits[i]++;\\n                    return digits;\\n                }\\n            return temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474823,
                "title": "0ms-hacky-c-solution-tc-o-n-sc-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/a35c611d-a1fa-4ec5-b0ce-135364134343_1661608674.9935284.png)\\n\\nDon\\'t feel confused by looking at the solution complexity. Take a book and go through it once. Then you will get to know how **easy** it really is.\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        if(digits[n]!=9){                                  //If last element is not 9, simply add 1 to it and return\\n            digits[n]++;\\n        }\\n        else{\\n            digits[n]=0;                                   //If you reach here, it means the element is 9. Then make it 0 and follow ahead.\\n            for(int i=n-1; i>=0; i--){                     //Now check the previous element (if exists)\\n                if(digits[i]==9 && i-1>=0){                //If (previous) element is 9 and there is still an element previous to it, then make it 0 and follow ahead.\\n                    digits[i]=0;\\n                }\\n                else if(digits[i]!=9){                     //If (previous) element is not 9, add 1 to it and return the vector.\\n                    digits[i]+=1;\\n                    return digits;\\n                }\\n            }\\n            digits[0]=0;                                   //If you reach here, that means all elements in the vector are 9. (Think about it a little bit!). We made the rest of the elements 0. Now make the first element 0 and insert 1 at the beginning.\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;                                     //Return the final vector!!\\n    }\\n};\\n```\\nPS: If you made it through the process, congrats, you just added a drop to your ocean of knowledge :)\\n**Plz Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        if(digits[n]!=9){                                  //If last element is not 9, simply add 1 to it and return\\n            digits[n]++;\\n        }\\n        else{\\n            digits[n]=0;                                   //If you reach here, it means the element is 9. Then make it 0 and follow ahead.\\n            for(int i=n-1; i>=0; i--){                     //Now check the previous element (if exists)\\n                if(digits[i]==9 && i-1>=0){                //If (previous) element is 9 and there is still an element previous to it, then make it 0 and follow ahead.\\n                    digits[i]=0;\\n                }\\n                else if(digits[i]!=9){                     //If (previous) element is not 9, add 1 to it and return the vector.\\n                    digits[i]+=1;\\n                    return digits;\\n                }\\n            }\\n            digits[0]=0;                                   //If you reach here, that means all elements in the vector are 9. (Think about it a little bit!). We made the rest of the elements 0. Now make the first element 0 and insert 1 at the beginning.\\n            digits.insert(digits.begin(), 1);\\n        }\\n        return digits;                                     //Return the final vector!!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257688,
                "title": "very-easy-c-solution-100-fully-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.size() - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            vector<int>res(digits.size()+1,0);    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> plusOne(vector<int>& digits) {\\n        //To solve this, we take digits one by one from end to start..\\n        for (int i = digits.size() - 1; i >= 0; i--) {\\n            \\n            // If a digit is not equal to 9, we plus one directly and then quit the loop...\\n            if (digits[i] != 9) {\\n                digits[i]++;\\n                break;\\n                \\n            //if the digit is 9, we set it to 0, and continue the loop until\\n            //we encounter the number don\\'t equals to 9...\\n            } else {\\n                digits[i] = 0;\\n            }\\n        }\\n        if (digits[0] == 0) {      //it means, we need a bigger array to represent the number.\\n            vector<int>res(digits.size()+1,0);    //so we create a new array res...\\n            res[0] = 1;                                //and set res[0] to 1...\\n            return res;\\n        }\\n        return digits;      //return the digits...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044309,
                "title": "java-simplest-soln-shortest-soln-with-explanation",
                "content": "***If you like the code, Kindly Upvote***\\n\\n```\\nclass Solution {\\npublic int[] plusOne(int[] digits) {\\n    \\n    int carry = 1;\\n    \\n    for (int i = digits.length-1; i>= 0; i--) {\\n        digits[i] += carry;\\n        if (digits[i] != 10) // early return \\n            return digits;\\n        digits[i] = 0;\\n    }\\n    \\n\\t//if upper return statement didn\\'t run, it means [9],[9,9] type of test case is present.\\n\\t\\n    int[] ans = new int[digits.length+1]; \\n    ans[0] = 1; //As other elements will be 0, therefore only updating the 0th element\\n    return ans;\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int[] plusOne(int[] digits) {\\n    \\n    int carry = 1;\\n    \\n    for (int i = digits.length-1; i>= 0; i--) {\\n        digits[i] += carry;\\n        if (digits[i] != 10) // early return \\n            return digits;\\n        digits[i] = 0;\\n    }\\n    \\n\\t//if upper return statement didn\\'t run, it means [9],[9,9] type of test case is present.\\n\\t\\n    int[] ans = new int[digits.length+1]; \\n    ans[0] = 1; //As other elements will be 0, therefore only updating the 0th element\\n    return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839674,
                "title": "very-easy-python-solution-faster-than-97-48",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i, num in [*enumerate(digits)][::-1]:\\n            if num != 9:\\n                digits[i] += 1\\n                break\\n            digits[i] = 0\\n\\n        return [1] + digits if not digits[0] else digits\\n```\\n\\n\"Exploiting\" enumarte to iterate from end to start, and making one less check before returning a value.\\nIf the first number is ```0``` -> concatenate ```[1]``` to start of the list.\\nIf not -> just return digits.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i, num in [*enumerate(digits)][::-1]:\\n            if num != 9:\\n                digits[i] += 1\\n                break\\n            digits[i] = 0\\n\\n        return [1] + digits if not digits[0] else digits\\n```\n```0```\n```[1]```",
                "codeTag": "Java"
            },
            {
                "id": 1726820,
                "title": "simple-java-solution-with-explanation",
                "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        int n = digits.length; \\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;    // if a digit is less than 9, just add 1 and return the new digit array\\n                return digits;\\n            }else{\\n                digits[i] = 0; // if digit is 9, make it zero and in the next iteration the next value will get increment\\n            }           \\n        }\\n        \\n        // if we are here means, every digit in array was 9. So create a new array with +1 size and make first digit Zero.\\n        // exp:  99 => create new array of size 3 => make its first digit 1 => return new array => 100;\\n        \\n        int[] newDigit = new int[n+1];\\n        newDigit[0] = 1;\\n        \\n        return newDigit;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        int n = digits.length; \\n        \\n        for(int i=n-1; i>=0; i--){\\n            if(digits[i] < 9){\\n                digits[i]++;    // if a digit is less than 9, just add 1 and return the new digit array\\n                return digits;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667209,
                "title": "js",
                "content": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length -1; i >= 0; i--) {\\n        const curDigit = digits[i];\\n        if (curDigit < 9) {\\n            digits[i] = digits[i] + 1;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    return [1, ...digits];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar plusOne = function(digits) {\\n    for (let i = digits.length -1; i >= 0; i--) {\\n        const curDigit = digits[i];\\n        if (curDigit < 9) {\\n            digits[i] = digits[i] + 1;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    return [1, ...digits];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428535,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size(),carry=1;\\n        for(int i=n-1;i>=0;--i){\\n            int x = digits[i]+carry;\\n            digits[i]=x%10;\\n            carry = x/10;\\n            if(carry==0) break;\\n        }\\n        if(carry>0) digits.insert(digits.begin()+0,carry);\\n        return digits;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size(),carry=1;\\n        for(int i=n-1;i>=0;--i){\\n            int x = digits[i]+carry;\\n            digits[i]=x%10;\\n            carry = x/10;\\n            if(carry==0) break;\\n        }\\n        if(carry>0) digits.insert(digits.begin()+0,carry);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379354,
                "title": "c-0ms-100-faster-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        \\n        //\\n        int n  = digits.size() ;\\n\\n        while(1)\\n        {  // if the digit is not nine then simply add it\\n            if(digits[n-1]!= 9)\\n            {\\n                digits[n-1]++;\\n                return digits;\\n            }\\n\\t\\t\\t// if 9 then 9+1 is 10 we need the 0 only \\n            else \\n            {\\n                digits[n-1] = 0 ;\\n                --n;\\n            }\\n           // if all nine then first digit will be zero add one in the begining\\n            if(digits[0] == 0)\\n            {\\n                digits.insert(digits.begin(),1);\\n                return digits;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        \\n        //\\n        int n  = digits.size() ;\\n\\n        while(1)\\n        {  // if the digit is not nine then simply add it\\n            if(digits[n-1]!= 9)\\n            {\\n                digits[n-1]++;\\n                return digits;\\n            }\\n\\t\\t\\t// if 9 then 9+1 is 10 we need the 0 only \\n            else \\n            {\\n                digits[n-1] = 0 ;\\n                --n;\\n            }\\n           // if all nine then first digit will be zero add one in the begining\\n            if(digits[0] == 0)\\n            {\\n                digits.insert(digits.begin(),1);\\n                return digits;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123616,
                "title": "rust-iterator-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Plus One.\\nMemory Usage: 1.9 MB, less than 95.31% of Rust online submissions for Plus One.\\n```\\nimpl Solution {\\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\\n        let mut digits = digits;\\n        for v in digits.iter_mut().rev() {\\n            let sum = *v + 1;\\n            *v = sum % 10;\\n            if sum < 10 {\\n                return digits;\\n            }\\n        }\\n        [&vec![1], &digits[..]].concat()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn plus_one(digits: Vec<i32>) -> Vec<i32> {\\n        let mut digits = digits;\\n        for v in digits.iter_mut().rev() {\\n            let sum = *v + 1;\\n            *v = sum % 10;\\n            if sum < 10 {\\n                return digits;\\n            }\\n        }\\n        [&vec![1], &digits[..]].concat()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 722172,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i in reversed(range(len(digits))):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            else:\\n                digits[i] = 0\\n        return [1]+digits\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        for i in reversed(range(len(digits))):\\n            if digits[i] < 9:\\n                digits[i] += 1\\n                return digits\\n            else:\\n                digits[i] = 0\\n        return [1]+digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142730,
                "title": "simple-javascript-solution-es6",
                "content": "```\\nconst plusOne = digits => {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] < 9) {\\n            digits[i]++\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    return [1, ...digits]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst plusOne = digits => {\\n    for (let i = digits.length - 1; i >= 0; i--) {\\n        if (digits[i] < 9) {\\n            digits[i]++\\n            return digits\\n        }\\n        digits[i] = 0\\n    }\\n    return [1, ...digits]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24296,
                "title": "python-one-line-answer",
                "content": "    return list(map(int, str(int(''.join(map(str, digits)))+1)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return list(map(int, str(int(''.join(map(str, digits)))+1)))",
                "codeTag": "Unknown"
            },
            {
                "id": 24363,
                "title": "javascript-solution-sharing",
                "content": "    /**\\n     * note: [9] plus one [1, 0] // digits[0]=10\\n     */\\n    var plusOne = function(digits) {\\n        var carry = 1;\\n        for(var i=digits.length-1; i>=0; i--){\\n            digits[i] = digits[i] + carry;\\n            digits[i] = (digits[i]>=10)?(carry=1, digits[i]-10):(carry=0, digits[i]);\\n        }\\n        if(carry){ digits.unshift(1); } // note\\n        return digits;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    /**\\n     * note: [9] plus one [1, 0] // digits[0]=10\\n     */\\n    var plusOne = function(digits) {\\n        var carry = 1;\\n        for(var i=digits.length-1; i>=0; i--){\\n            digits[i] = digits[i] + carry;\\n            digits[i] = (digits[i]>=10)?(carry=1, digits[i]-10):(carry=0, digits[i]);\\n        }\\n        if(carry){ digits.unshift(1); } // note\\n        return digits;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 24432,
                "title": "my-accepted-java-solution",
                "content": "Just plus one to the last element in the digits , and judge every element then return \\n\\n\\n    public class Solution {\\n        public int[] plusOne(int[] digits) {\\n            digits[digits.length-1]+=1;\\n            for(int i=digits.length-1;i>0;i--)\\n            {\\n                if(digits[i]==10)\\n                {\\n                    digits[i]=0;\\n                    digits[i-1]+=1;\\n                }\\n            }\\n            if(digits[0]==10)\\n            {\\n                int[] res=new int[digits.length+1];\\n                digits[0]=0;\\n                res[0]=1;\\n                for(int i=1;i<res.length;i++)\\n                {\\n                    res[i]=digits[i-1];\\n                }\\n                return res;\\n            }\\n            return digits;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] plusOne(int[] digits) {\\n            digits[digits.length-1]+=1;\\n            for(int i=digits.length-1;i>0;i--)\\n            {\\n                if(digits[i]==10)\\n                {\\n                    digits[i]=0;\\n                    digits[i-1]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3792748,
                "title": "beats-100-explanation-optimized-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This concept is great, and we can imagine it well enough.\\n- We always add the number to another at the end, Ex: 1002 + 2 = 100***4*** \\n- If we get any carry we pass it to the next number from right to left.\\n- Similarly it\\'s an easy version of that.\\n##### Let\\'s dive deep into it:\\n- We have to just add 1 to the number whose digit are represented in array format.\\n###### - There can be only two cases:\\n1. The number = 9 (need to pass one as carry, and number will be equals to zero)\\n2. If number !=9 , number++;\\n\\n###### - The Special Case:\\n1. Let\\'s say the number is in form of 999, after adding 1, number= 1000 (**Need to increase the size of vector**: (v.push_back(0))\\n2. If not then come out of loop.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Iterate over the vector: \\n 1. if i==n-1, v[i]++\\n 2. then check if v[i]==10\\n  - v[i]=0\\n  - if(i!=0) v[i-1]++\\n  - else push_back 0, and v[i]=1; \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n##### We can more optimize it but it would have no effect on time complexity \\n# More optimized:\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& v) {\\n        int n = v.size();\\n        for(int i=n-1; i>=0; i--){\\n            if(i==n-1){\\n                v[i]++;\\n            }\\n            if(v[i]==10){\\n                v[i] = 0;\\n                if(i!=0){\\n                    v[i-1]++;\\n                }else{\\n                    v.push_back(0);\\n                    v[i] = 1;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510251,
                "title": "c-quick-addition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your timecomplexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short int i = digits.size() - 1;\\n        if (i >= 0) {\\n            while (i != -1) {\\n                digits[i] += 1;\\n                if (i == 0 && digits[i] == 10) {\\n                    digits[i] = 0;\\n                    digits.insert(digits.begin(), 1);\\n                }\\n                else if (digits[i] == 10) digits[i] = 0;\\n                else break;\\n                i--;\\n            }\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short int i = digits.size() - 1;\\n        if (i >= 0) {\\n            while (i != -1) {\\n                digits[i] += 1;\\n                if (i == 0 && digits[i] == 10) {\\n                    digits[i] = 0;\\n                    digits.insert(digits.begin(), 1);\\n                }\\n                else if (digits[i] == 10) digits[i] = 0;\\n                else break;\\n                i--;\\n            }\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473937,
                "title": "easy-to-understand-explained-part-by-part-without-reverse",
                "content": "\\n# Approach\\nwe have to add 1 at the last element ;\\nso we took a for loop which starts from the end;\\n\\nif the last digit is not 9 then we can easily add 1 with it .But for 9 we will get extra 1 carry. 9+0=10;\\nwe will handle that letter.\\n\\nfirst off all if our element is lesser then 9 .we will simply add 1 and break the loop and return .\\n \\n      if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\nif the digit is 9 then the sum will 10 .we have to put 0 and 1 carry will be added with prvious number .\\nexample : [1,2,9] -> [1,3,0]\\n \\n    else { digits[i]=0;}\\nif all the array becomes 0 .for example [9,9,9]+1 the result should be [1,0,0,0]\\nso we inserted \\'1\\' at the begining of the array\\n    \\n    if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\n            else { digits[i]=0;}\\n        }\\n        if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n        return digits;\\n    }\\n};\\n```\\n# please Upvote :(",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        \\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]=digits[i]+1;\\n                break;\\n            }\\n            else { digits[i]=0;}\\n        }\\n        if(digits[0]==0){\\n            digits.insert(digits.begin(),1);\\n        }\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176624,
                "title": "java-best-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int p=digits.length;\\n        for(int i=p-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n\\n        int arr[]=new int[p+1];\\n        arr[0]=1;\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int p=digits.length;\\n        for(int i=p-1;i>=0;i--){\\n            if(digits[i]<9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n\\n        int arr[]=new int[p+1];\\n        arr[0]=1;\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994509,
                "title": "recursive-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSaw a lot of iterative solutions, so I tried to think of a recursive one. As can be quickly deduce, the difficulty of this problem is dealing with the \"9\" digits, not just the ones in the last digit but all of them. In order to simplify the work, we recursively solve for this specific case, so that it does not matter how many \"9\"s we have.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur two base cases are when the **only** digit is \"9\" and when it is not \"9\". Otherwise, we recursively call this function for the rest of the digits, while accounting for our last digit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        last = digits[-1]\\n        if last == 9:\\n            if len(digits) == 1:\\n                return [1,0]\\n            return self.plusOne(digits[:-1]) + [0]\\n        digits[-1] += 1\\n        return digits\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        last = digits[-1]\\n        if last == 9:\\n            if len(digits) == 1:\\n                return [1,0]\\n            return self.plusOne(digits[:-1]) + [0]\\n        digits[-1] += 1\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765133,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { \\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n      int n = digits.size() - 1;\\n      \\n      for (int i = n; i >= 0; --i) { \\n        if (digits[i] == 9) {  \\n          digits[i] = 0;\\n        } else {  // current digit is not 9 so we can safely increment by one\\n          digits[i] += 1;\\n          return digits;\\n        }\\n      }\\n\\n      digits.push_back(0);\\n      digits[0] = 1;\\n      return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760321,
                "title": "golang-0ms-portugues-br-video",
                "content": "https://www.youtube.com/watch?v=Wx_dAxDFEZ4&ab_channel=Codando\\n\\n```\\nfunc plusOne(digits []int) []int {\\n    \\n    for i := len(digits) - 1; i >= 0; i--{\\n        \\n        if digits[i] < 9{\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    \\n    if digits[0] == 0{\\n        digits = append([]int{1}, digits...)\\n    }\\n    \\n    return digits\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc plusOne(digits []int) []int {\\n    \\n    for i := len(digits) - 1; i >= 0; i--{\\n        \\n        if digits[i] < 9{\\n            digits[i]++\\n            return digits\\n        }\\n        \\n        digits[i] = 0\\n    }\\n    \\n    if digits[0] == 0{\\n        digits = append([]int{1}, digits...)\\n    }\\n    \\n    return digits\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710251,
                "title": "typescript-oneliner-solution",
                "content": "`return Array.from((BigInt(digits.join(\\'\\')) + BigInt(\\'1\\')).toString(), Number)`",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "`return Array.from((BigInt(digits.join(\\'\\')) + BigInt(\\'1\\')).toString(), Number)`",
                "codeTag": "Unknown"
            },
            {
                "id": 2687851,
                "title": "plus-one-java-100-fast-solution",
                "content": "Hi Everyone\\nHere is the easy solution for the Plus One Question with explanation as in commented code.\\n\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        int n = digits.length;\\n\\t\\t// loop to add the digits\\n        for(int i=n-1; i>=0; i--) {\\n            digits[i] += carry;   // add carry in every digit\\n            carry = digits[i] / 10;   // update carry for next digit\\n            digits[i] = digits[i] % 10;   //  put remainder in the digit\\n        }\\n        if(carry == 1) {   // in case of carry, we need to return n+1 length array\\n            int[] res = new int[n+1];\\n            res[0] = 1;\\n\\t\\t\\t// assinging values of digit in new array\\n            for(int i=1; i<=n;i++) {\\n                res[i] = digits[i-1];\\n            }\\n            return res;\\n        }\\n        return digits;   // not a carry, we can send updated digit array\\n    }\\n}\\n```\\n\\nThanks & Happy Coding!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int carry = 1;\\n        int n = digits.length;\\n\\t\\t// loop to add the digits\\n        for(int i=n-1; i>=0; i--) {\\n            digits[i] += carry;   // add carry in every digit\\n            carry = digits[i] / 10;   // update carry for next digit\\n            digits[i] = digits[i] % 10;   //  put remainder in the digit\\n        }\\n        if(carry == 1) {   // in case of carry, we need to return n+1 length array\\n            int[] res = new int[n+1];\\n            res[0] = 1;\\n\\t\\t\\t// assinging values of digit in new array\\n            for(int i=1; i<=n;i++) {\\n                res[i] = digits[i-1];\\n            }\\n            return res;\\n        }\\n        return digits;   // not a carry, we can send updated digit array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680601,
                "title": "java-100-runtime-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n       int len=digits.length;\\n       for(int i=len-1;i>=0;i--){\\n           if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n           }\\n           digits[i]=0;\\n       }\\n        int[] newArr=new int[len+1];\\n        newArr[0]=1;\\n        return newArr;\\n    }\\n}\\n```\\n**please upvote if u like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n       int len=digits.length;\\n       for(int i=len-1;i>=0;i--){\\n           if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n           }\\n           digits[i]=0;\\n       }\\n        int[] newArr=new int[len+1];\\n        newArr[0]=1;\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666984,
                "title": "c-clean-o-1-space-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        //same as add 1\\n        int carry = 1;\\n        \\n        // propagate carry\\n        for (int i = digits.size() - 1; i >= 0; --i) {\\n            digits[i] += carry;\\n            carry = digits[i] / 10;\\n            digits[i] = digits[i] % 10;\\n        }\\n        \\n        // handle the last carry if any\\n        if (carry) {\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        //same as add 1\\n        int carry = 1;\\n        \\n        // propagate carry\\n        for (int i = digits.size() - 1; i >= 0; --i) {\\n            digits[i] += carry;\\n            carry = digits[i] / 10;\\n            digits[i] = digits[i] % 10;\\n        }\\n        \\n        // handle the last carry if any\\n        if (carry) {\\n            digits.insert(digits.begin(), carry);\\n        }\\n\\n        return digits;\\n    }\\n};\\n\\n/*\\nif (you like this) {\\n\\tplease upvote;\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574962,
                "title": "javascript-two-line-solution",
                "content": "```\\nvar plusOne = function (digits) {\\n  const arr = [...(BigInt(digits.join(\"\")) + BigInt(1)).toString()];\\n  return arr.map(Number);\\n};\\n```\\nWe have to use the **bigInt()**. <br>\\nBecause JS have a limited precision (2^53=9,007,199,254,740,992 for the biggest integer). And Test case `[6, 1, 4, 5, 3, 9, 0, 1, 9, 5, 1, 8, 6, 7, 0, 5, 5, 4, 3]` has passed that limit. As we cross the limit, we have to call the `bigInt()` function to to do precise calculation. And we can not add 1 directly to a `big-integer`. The number has to be the same type. Therefore, we have to add 1 like -  `bigInt(1)`. <br>",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar plusOne = function (digits) {\\n  const arr = [...(BigInt(digits.join(\"\")) + BigInt(1)).toString()];\\n  return arr.map(Number);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377251,
                "title": "c-solution-easy-fast-than-96",
                "content": "```\\nvector<int> plusOne(vector<int>& digits) {\\n\\tint n = digits.size(), i; \\n\\tfor (i = n-1; i>=0; i--) {\\n\\t\\tif(digits[i]!=9) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(i==-1) {\\n\\t\\tvector<int> v(n+1, 0);\\n\\t\\tv[0]=1;\\n\\t\\treturn v;\\n\\t}\\n\\tdigits[i]++;\\n\\tfor(int j = i+1; j<n; j++) \\n\\t\\tdigits[j] = 0;\\n\\treturn digits;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> plusOne(vector<int>& digits) {\\n\\tint n = digits.size(), i; \\n\\tfor (i = n-1; i>=0; i--) {\\n\\t\\tif(digits[i]!=9) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(i==-1) {\\n\\t\\tvector<int> v(n+1, 0);\\n\\t\\tv[0]=1;\\n\\t\\treturn v;\\n\\t}\\n\\tdigits[i]++;\\n\\tfor(int j = i+1; j<n; j++) \\n\\t\\tdigits[j] = 0;\\n\\treturn digits;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267126,
                "title": "go-easy-and-fast",
                "content": "```\\nfunc PlusOne(digits []int) []int {\\n\\tvar res int = 1\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\ts := digits[i]\\n\\t\\tif s+res <= 9 {\\n\\t\\t\\tdigits[i] += res\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\t\\tif i == 0 {\\n\\t\\t\\tdigits = append([]int{1}, digits...)\\n\\t\\t}\\n\\t}\\n\\treturn digits\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc PlusOne(digits []int) []int {\\n\\tvar res int = 1\\n\\tfor i := len(digits) - 1; i >= 0; i-- {\\n\\t\\ts := digits[i]\\n\\t\\tif s+res <= 9 {\\n\\t\\t\\tdigits[i] += res\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tdigits[i] = 0\\n\\t\\tif i == 0 {\\n\\t\\t\\tdigits = append([]int{1}, digits...)\\n\\t\\t}\\n\\t}\\n\\treturn digits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090046,
                "title": "ruby-solutions-elegant-ruby-pointer-using-modulus-and-recursion",
                "content": "## Elegant Ruby solution\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n```\\n\\n## Pointer with modulus solution\\n\\nThis is what a technical interview is looking for....\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    carryover, pointer = 1, -1\\n    \\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n        \\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n        \\n    digits\\nend\\n```\\n\\n## Recursiion of pointer with modulus solution\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n    \\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n    \\n    plus_one(digits, pointer - 1, sum / 10)\\nend\\n```\\n\\n## Benchmark\\n\\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_ruby_like(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_pointer(digits)\\n    carryover, pointer = 1, -1\\n\\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n\\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n\\n    digits\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_recursive(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n\\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n\\n    plus_one_recursive(digits, pointer - 1, sum / 10)\\nend\\n\\nrequire \\'benchmark\\'\\n\\nn = 1_000_000\\ntest_cases =\\n    [\\n        [1,2,3],\\n        [4,3,2,1],\\n        [9]\\n    ]\\n\\nBenchmark.bmbm do |x|\\n    x.report(\\'plus_one_ruby_like()\\') { n.times { |nth| plus_one_ruby_like(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_pointer()\\')  { n.times { |nth| plus_one_pointer(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_recursive()\\')  { n.times { |nth| plus_one_recursive(test_cases[nth % test_cases.length]) } }\\nend\\n```\\n\\nResult:\\n\\nRuby-like solution is slower due to the new object creations and transformation.\\n\\nThe pointer is faster since its updating the existing object, `digits`, in place.\\n\\nThis can be verified by calling `object_id` on the resulting object. The Ruby-like solution creates new objects, while the pointer solution result has the same `object_id` as the input.\\n\\n```\\nRehearsal --------------------------------------------------------\\nplus_one_ruby_like()   0.872726   0.003306   0.876032 (  0.876655)\\nplus_one_pointer()     0.176923   0.000899   0.177822 (  0.178070)\\nplus_one_recursive()   0.185491   0.000453   0.185944 (  0.185986)\\n----------------------------------------------- total: 1.239798sec\\n\\n                           user     system      total        real\\nplus_one_ruby_like()   1.449080   0.008460   1.457540 (  1.458386)\\nplus_one_pointer()     0.176361   0.001490   0.177851 (  0.178214)\\nplus_one_recursive()   0.188032   0.001648   0.189680 (  0.190059)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits)\\n    carryover, pointer = 1, -1\\n    \\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n        \\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n        \\n    digits\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n    \\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n    \\n    plus_one(digits, pointer - 1, sum / 10)\\nend\\n```\n```\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_ruby_like(digits)\\n    digits.join.to_i.next.digits.reverse\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_pointer(digits)\\n    carryover, pointer = 1, -1\\n\\n    while carryover.positive?\\n        break digits.unshift(carryover) if digits[pointer].nil?\\n\\n        sum = digits[pointer] + carryover\\n        carryover = sum / 10\\n        digits[pointer] = sum % 10\\n        pointer -= 1\\n    end\\n\\n    digits\\nend\\n\\n# @param {Integer[]} digits\\n# @return {Integer[]}\\ndef plus_one_recursive(digits, pointer = -1, carryover = 1)\\n    return digits if carryover.zero?\\n    return digits.unshift(carryover) if digits[pointer].nil?\\n\\n    sum = digits[pointer] + carryover\\n    digits[pointer] = sum % 10\\n\\n    plus_one_recursive(digits, pointer - 1, sum / 10)\\nend\\n\\nrequire \\'benchmark\\'\\n\\nn = 1_000_000\\ntest_cases =\\n    [\\n        [1,2,3],\\n        [4,3,2,1],\\n        [9]\\n    ]\\n\\nBenchmark.bmbm do |x|\\n    x.report(\\'plus_one_ruby_like()\\') { n.times { |nth| plus_one_ruby_like(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_pointer()\\')  { n.times { |nth| plus_one_pointer(test_cases[nth % test_cases.length]) } }\\n    x.report(\\'plus_one_recursive()\\')  { n.times { |nth| plus_one_recursive(test_cases[nth % test_cases.length]) } }\\nend\\n```\n```\\nRehearsal --------------------------------------------------------\\nplus_one_ruby_like()   0.872726   0.003306   0.876032 (  0.876655)\\nplus_one_pointer()     0.176923   0.000899   0.177822 (  0.178070)\\nplus_one_recursive()   0.185491   0.000453   0.185944 (  0.185986)\\n----------------------------------------------- total: 1.239798sec\\n\\n                           user     system      total        real\\nplus_one_ruby_like()   1.449080   0.008460   1.457540 (  1.458386)\\nplus_one_pointer()     0.176361   0.001490   0.177851 (  0.178214)\\nplus_one_recursive()   0.188032   0.001648   0.189680 (  0.190059)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2057867,
                "title": "php-solutions-in-one-line",
                "content": "```\\nfunction plusOne($digits) {\\n        return str_split(bcadd(1,implode($digits)));\\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction plusOne($digits) {\\n        return str_split(bcadd(1,implode($digits)));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031771,
                "title": "c-solution-two-approaches-easy-to-understand",
                "content": "**Approach 1 :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry=1,size=digits.size();\\n        for(int i=size-1;i>=0;i--) {\\n            int sum=digits[i]+carry;\\n            digits[i]=sum%10;\\n            carry=sum/10;\\n        }\\n        if(carry>0) digits.insert(digits.begin(),carry);\\n        return digits;\\n    }\\n};\\n```\\n\\n\\n**Approach 2 :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```\\n\\nIf you liked the solution then, please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int carry=1,size=digits.size();\\n        for(int i=size-1;i>=0;i--) {\\n            int sum=digits[i]+carry;\\n            digits[i]=sum%10;\\n            carry=sum/10;\\n        }\\n        if(carry>0) digits.insert(digits.begin(),carry);\\n        return digits;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        for (int i=digits.size()-1;i>=0;i--){\\n            if (digits[i]==9){\\n                digits[i]=0;\\n            }\\n            else{\\n                digits[i]++;\\n                return digits;\\n            }\\n        }\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478974,
                "title": "c-the-best-teacher-is-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size()-1;\\n        for(int i=n;i>=0;i--)\\n        {\\n            if(digits[i]<9)\\n            {\\n                digits[i]++;\\n                return digits;\\n            }\\n            digits[i]=0;\\n        }\\n        digits[0]=1;\\n        digits.push_back(0);\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368813,
                "title": "plus-one-easy-python-solution",
                "content": "If the last digit is any number from **0-8**, incrementing that by 1 will not cause any issue, making the case simple. In case the last digit is **9**, adding 1 will make it 10, so 9 will be replaced by 0 and addition of 1 to the previous number is to be done.\\n\\nConsider the example of 99 = [9,9] - adding 1 to last digit makes it 0 and 1 is added to previous digit and that again will become 0. Now since this is the first digit of the number (here in list format), 1 needs to be appended before it to finish the addition. This is done in the code blow. \\n\\n```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        n = len(digits)\\n        \\n        while n>0:\\n            if digits[n-1]==9:\\n                if (n-1) == 0:\\n                    digits[n-1] = 0\\n                    temp = [1] + digits\\n                    return temp\\n                else:\\n                    digits[n-1] = 0\\n                    n = n-1\\n            else:\\n                digits[n-1] += 1\\n                return digits\\n        \\n        return digits\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef plusOne(self, digits: List[int]) -> List[int]:\\n        n = len(digits)\\n        \\n        while n>0:\\n            if digits[n-1]==9:\\n                if (n-1) == 0:\\n                    digits[n-1] = 0\\n                    temp = [1] + digits\\n                    return temp\\n                else:\\n                    digits[n-1] = 0\\n                    n = n-1\\n            else:\\n                digits[n-1] += 1\\n                return digits\\n        \\n        return digits\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1290715,
                "title": "java-simple-0ms-faster-than-100-pure-logic-clean-efficient-explained",
                "content": "# **Please Upvote if you got any help from the provided solution!!!**\\n\\nBasic Idea behind this implementation is:\\n* Increment the element by 1 if it is not equal to 9 and return it. \\neg: 35 + 1 = 16, so we will increment the element 5 by 1 to make it 6 and return it as no further manipulation is required on element 3(from 38).\\n\\n* But if element is 9, then make that element as 0(zero).\\neg: 59 + 1 = 60, here we will make the element 9 as 0(zero) and in the next iteration increment the element 5(from 59) by 1 to make it 6 and return it.\\n\\n* But for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array so as to fit an extra element into it and return the newly created array.\\neg: If we have an array of length 4 and all elements consists of 9, then we need an array of length 5, so as to make the first element as 1(one) and remaining ones as 0\\'s(zeros).<br>\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9999  <-- here the number of digits are 4\\n<u>&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</u> \\n&nbsp;&nbsp;&nbsp;10000  <-- but after adding 1 to it the number of digits becomes 5 and for storing an extra element we need to create a new array of 1 length larger than the original one.\\n<hr><br>\\n\\n\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        final int len = digits.length;\\n        \\n        for(int index = len - 1; index >= 0; --index){\\n            if(digits[index] != 9){\\n                digits[index] += 1;  // if element is not equal to 9, then increment it by 1 and return it\\n                return digits; \\n            }\\n            digits[index] = 0; // else if element is 9, then make that element as 0(zero)\\n        }\\n        \\n        final int[] result = new int[len + 1]; //  for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array\\n        result[0] = 1; // making the 1st element as 1 and rest will be 0 as the default value of int is 0, so all elements will be 0 except for 1st element which will be 1\\n        return result;\\n    }\\n}\\n```\\n\\n# **Please Upvote if you got any help from the provided solution!!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\n        final int len = digits.length;\\n        \\n        for(int index = len - 1; index >= 0; --index){\\n            if(digits[index] != 9){\\n                digits[index] += 1;  // if element is not equal to 9, then increment it by 1 and return it\\n                return digits; \\n            }\\n            digits[index] = 0; // else if element is 9, then make that element as 0(zero)\\n        }\\n        \\n        final int[] result = new int[len + 1]; //  for cases where all elements are 9, then we have to create a new array of 1 larger length than the original array\\n        result[0] = 1; // making the 1st element as 1 and rest will be 0 as the default value of int is 0, so all elements will be 0 except for 1st element which will be 1\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207212,
                "title": "java-faster-than-100-easy-way",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\t\\t\\n\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (digits[i] < 9) { \\n\\t\\t\\t\\tdigits[i]++;\\n\\t\\t\\t\\treturn digits;\\n\\t\\t\\t} else { digits[i] = 0; }\\n\\t\\t}\\n        \\n        int[] temp = new int[digits.length + 1];\\n\\t\\ttemp[0] = 1;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        \\t\\t\\n\\t\\tfor (int i = digits.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (digits[i] < 9) { \\n\\t\\t\\t\\tdigits[i]++;\\n\\t\\t\\t\\treturn digits;\\n\\t\\t\\t} else { digits[i] = 0; }\\n\\t\\t}\\n        \\n        int[] temp = new int[digits.length + 1];\\n\\t\\ttemp[0] = 1;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694574,
                "title": "java-with-comments-easy-to-understand-100-time",
                "content": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for(int i=digits.length-1; i>=0; i--){\\n            if(digits[i]<9){\\n                //first non-9 will be incremented by 1 and then the result is returned\\n                digits[i] = digits[i] + 1;\\n                return digits;\\n            }\\n            //if it is 9, make it zero. we\\'re incrementing first non-9 above.\\n            digits[i] = 0;\\n        }\\n            \\n        //if we reached here that means we have a case where array consists of all nines.  \\n        //In that case, the array is all zeroes. we just need to make 0th position 1. \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        for(int i=digits.length-1; i>=0; i--){\\n            if(digits[i]<9){\\n                //first non-9 will be incremented by 1 and then the result is returned\\n                digits[i] = digits[i] + 1;\\n                return digits;\\n            }\\n            //if it is 9, make it zero. we\\'re incrementing first non-9 above.\\n            digits[i] = 0;\\n        }\\n            \\n        //if we reached here that means we have a case where array consists of all nines.  \\n        //In that case, the array is all zeroes. we just need to make 0th position 1. \\n        int[] result = new int[digits.length + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24438,
                "title": "my-c-code-check-9",
                "content": "    vector<int> plusOne(vector<int> &digits) {\\n        int i;\\n        for(i=digits.size()-1;i>=0;i--)\\n        {\\n            if(digits[i]!=9)\\n            {\\n                digits[i]++;\\n                break;\\n            }\\n            else\\n            {\\n                digits[i] = 0;\\n            }\\n        }\\n        if(!digits[0])\\n        {\\n            digits[0] = 1;\\n            digits.push_back(0);\\n        }\\n        return digits;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> plusOne(vector<int> &digits) {\\n        int i;\\n        for(i=digits.size()-1;i>=0;i--)\\n        {\\n            if(digits[i]!=9)\\n            {\\n                digits[i]++;\\n                break;\\n            }\\n            else\\n            {\\n                digits[i] = 0;\\n            }\\n        }\\n        if(!digits[0])\\n        {\\n            digits[0] = 1;\\n            digits.push_back(0);\\n        }\\n        return digits;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4087841,
                "title": "python-98-30-beats-2-approachs-simple-code",
                "content": "**If you got help from this,... Plz Upvote .. it encourage me**\\n\\n# Code\\n# Approach 1 (Array) -> 98.30 % beats\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1, -1, -1):\\n            if digits[i] == 9:\\n                digits[i] = 0\\n            else:\\n                digits[i] = digits[i] + 1\\n                return digits\\n        return [1] + digits \\n\\n        \\n```\\n\\n# Approach 2 (Convert list -> Number :: -> Addition +1 :: -> Number  -> List\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        # List -> Number\\n        n = 0\\n        for ele in digits:\\n            n = (n*10) + ele\\n        \\n        n = n+1\\n        \\n        # Number -> List\\n        digits = []\\n        while n > 0:\\n            digits.insert(0, n % 10)  \\n            n //= 10 \\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n\\n        for i in range(len(digits)-1, -1, -1):\\n            if digits[i] == 9:\\n                digits[i] = 0\\n            else:\\n                digits[i] = digits[i] + 1\\n                return digits\\n        return [1] + digits \\n\\n        \\n```\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        # List -> Number\\n        n = 0\\n        for ele in digits:\\n            n = (n*10) + ele\\n        \\n        n = n+1\\n        \\n        # Number -> List\\n        digits = []\\n        while n > 0:\\n            digits.insert(0, n % 10)  \\n            n //= 10 \\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075521,
                "title": "simple-and-easy-approach-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n //you have to traverse array until the element is not equal to 9\\n//from last index and add one if element is not equal to 9\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n//if whole array is nine the push_back one element and index[0]==1\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n //you have to traverse array until the element is not equal to 9\\n//from last index and add one if element is not equal to 9\\n        for(int i=digits.size()-1;i>=0;i--){\\n            if(digits[i]!=9){\\n                digits[i]++;\\n                return digits;\\n            }\\n            else{\\n                digits[i]=0;\\n            }\\n        }\\n//if whole array is nine the push_back one element and index[0]==1\\n        digits.push_back(0);\\n        digits[0]=1;\\n        return digits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959120,
                "title": "java-code-easy-to-under-stand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            digits[i]++;\\n            if (digits[i] < 10) {\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n       \\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n        for (int i = n - 1; i >= 0; i--) {\\n            digits[i]++;\\n            if (digits[i] < 10) {\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n       \\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934362,
                "title": "simple-easy-solution-in-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668116,
                "title": "intuitive-recursive-solution-run-time-o-n-space-o-1",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the last element is smaller than 9. -> ** add 1 to the last element**\\n\\nIf the last element is equal to 9. --> **change the value of the element to 0 (as we can\\'t store the value 10 in one digit, we have to carry 1 to the next digit)\\n\\nDecrease i by 1 (to iterate backward as we are using i as index) and decrease length by 1 (we need length as a reference to stop the recursion)\\n$$note:$$ we don\\'t need a \"carry\" variable as in every scenario it is going to be 1\\nCall the function again.\\n\\nWhen we call the function again, if the next digit is smaller than 9 we can just +1 the value of the element we are on.\\n\\nIf the element is 9 we can call our function again.\\nIf there is no element left (but we still have to add the $$carry$$, we add 1 as a new element to the list)\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        i = -1 #index to start from the end\\n        length = len(digits) \\n\\n        def Calculate(arr, i, length):\\n            if length != 0 and arr[i] != 9:\\n                arr[i] += 1 \\n            elif length > 0:\\n                arr[i] = 0\\n                length -= 1\\n                i -= 1\\n                Calculate(arr, i, length)\\n            else:\\n                arr.insert(0, 1) \\n        \\n        Calculate(digits, i, length)\\n        return digits\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        i = -1 #index to start from the end\\n        length = len(digits) \\n\\n        def Calculate(arr, i, length):\\n            if length != 0 and arr[i] != 9:\\n                arr[i] += 1 \\n            elif length > 0:\\n                arr[i] = 0\\n                length -= 1\\n                i -= 1\\n                Calculate(arr, i, length)\\n            else:\\n                arr.insert(0, 1) \\n        \\n        Calculate(digits, i, length)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606996,
                "title": "optimized-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size(); // Get the size of the digits array\\n        for (int i = n - 1; i >= 0; i--) { // Iterate over the digits array from right to left\\n            if (digits[i] < 9) { // Check if the current digit is less than 9\\n                digits[i]++; // If it is, increment the digit by 1\\n                return digits; // Return the modified array\\n            }\\n            digits[i] = 0; // Set the current digit to 0 since it was 9\\n        }\\n        digits.insert(digits.begin(), 1); // If all digits were 9, insert 1 at the beginning\\n        return digits; // Return the modified array\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size(); // Get the size of the digits array\\n        for (int i = n - 1; i >= 0; i--) { // Iterate over the digits array from right to left\\n            if (digits[i] < 9) { // Check if the current digit is less than 9\\n                digits[i]++; // If it is, increment the digit by 1\\n                return digits; // Return the modified array\\n            }\\n            digits[i] = 0; // Set the current digit to 0 since it was 9\\n        }\\n        digits.insert(digits.begin(), 1); // If all digits were 9, insert 1 at the beginning\\n        return digits; // Return the modified array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462162,
                "title": "add-one-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        int c=1;\\n        for(int i=d.size()-1;i>=0;i--)\\n        {\\n            int f=d[i]+c;\\n            d[i]=f%10;\\n            c=f/10;\\n        }\\n        if(c!=0)\\n        {\\n            reverse(d.begin(),d.end());\\n            d.push_back(c);\\n            reverse(d.begin(),d.end());\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        int c=1;\\n        for(int i=d.size()-1;i>=0;i--)\\n        {\\n            int f=d[i]+c;\\n            d[i]=f%10;\\n            c=f/10;\\n        }\\n        if(c!=0)\\n        {\\n            reverse(d.begin(),d.end());\\n            d.push_back(c);\\n            reverse(d.begin(),d.end());\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393850,
                "title": "increment-a-large-integer-represented-as-an-array-c-solution-easy-to-understand",
                "content": "# Intuition\\n![iages.jpeg](https://assets.leetcode.com/users/images/886eabe7-02a5-4004-a712-457c4c886152_1680957173.8068066.jpeg)\\n\\n\\n***We need to increment a large integer represented as an integer array by 1. One way to approach this problem is to iterate through the array from right to left and add 1 to each digit until we find a digit that is less than 10. If we reach the leftmost digit and it needs to be set to 0, we need to create a new array with one extra element and set the first element to 1.***\\n\\n# Approach\\n\\n***We will implement the approach mentioned in the intuition. We will start iterating through the array from right to left and increment each digit by 1. If the resulting digit is less than 10, we can return the modified array. Otherwise, we will set the current digit to 0 and continue with the next digit.If we reach the leftmost digit and it needs to be set to 0, we will create a new array with one extra element and set the first element to 1. We will return this new array as the result.***\\n\\n# Complexity\\n- Time complexity:\\n- \\n       O(N)\\n\\n- Space complexity:\\n- \\n       O(1)\\n       \\n\\n# Code\\n```\\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    for (int i = digitsSize - 1; i >= 0; i--) {\\n        digits[i]++;\\n        if (digits[i] < 10) {\\n            *returnSize = digitsSize;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\\n    result[0] = 1;\\n    for (int i = 1; i <= digitsSize; i++) {\\n        result[i] = 0;\\n    }\\n    *returnSize = digitsSize + 1;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\\n    for (int i = digitsSize - 1; i >= 0; i--) {\\n        digits[i]++;\\n        if (digits[i] < 10) {\\n            *returnSize = digitsSize;\\n            return digits;\\n        }\\n        digits[i] = 0;\\n    }\\n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\\n    result[0] = 1;\\n    for (int i = 1; i <= digitsSize; i++) {\\n        result[i] = 0;\\n    }\\n    *returnSize = digitsSize + 1;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298844,
                "title": "python-easiest-approach-beating-90-25",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/cfd19bd3-25de-4601-b4c4-24885a9e2151_1678857572.4187334.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        digits=[str(i) for i in digits]\\n        s=\\'\\'.join(digits)\\n        a=int(s)+1\\n        l=list(str(a))\\n        l=[int(i) for i in l]\\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def plusOne(self, digits):\\n        \"\"\"\\n        :type digits: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        digits=[str(i) for i in digits]\\n        s=\\'\\'.join(digits)\\n        a=int(s)+1\\n        l=list(str(a))\\n        l=[int(i) for i in l]\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260726,
                "title": "python3-95-fast",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- MSB to LSB is gives so increment in reverse manner.\\n- maintan carry variable to map if we have any previous overflow.\\n- at last if we have any carry left insert it to front of list.\\n- return digits.\\n\\n\\n![Screenshot 2023-03-05 204834.png](https://assets.leetcode.com/users/images/c7e27b34-d600-40e9-b750-d26fb8a3e99c_1678029545.3783138.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 0\\n        n = len(digits)\\n        for i in reversed(range(n)):\\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\\n            if val <= 9:\\n                digits[i] = val\\n                carry = 0\\n            else:\\n                carry = val // 10\\n                val -= 10\\n                digits[i] = val\\n        if carry:\\n            digits.insert(0, carry)\\n        return digits\\n```\\n# Please like and Comment below \\uD83D\\uDC4B\\u2267\\u25C9\\u1D25\\u25C9\\u2266",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 0\\n        n = len(digits)\\n        for i in reversed(range(n)):\\n            val = digits[i] + carry + 1 if i == n-1 else digits[i] + carry\\n            if val <= 9:\\n                digits[i] = val\\n                carry = 0\\n            else:\\n                carry = val // 10\\n                val -= 10\\n                digits[i] = val\\n        if carry:\\n            digits.insert(0, carry)\\n        return digits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137627,
                "title": "plus-one-o-n-time-complexity",
                "content": "# Intuition\\nTo not use Brute Force Approach and optimize the solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* for numbers less than or equal to 8 - can directly be incremented by 1.\\n* eg: 786 + 1= 787\\n* for number which is equal to 9 - will be replaced with 0 and generate a carry\\n* That carry will be further added to the beginning. \\n* eg: 9 + 1 = 0 carry generated  \\n* Now 1 will be placed in the beginning. \\n* Final array will be 10 \\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short i =0; // for smaller integers\\n        bool carry =0; // carry can be zero or one so used bool\\n        for(i=digits.size()-1;i>=0;--i){\\n            if(digits[i]<=8){ // for digits less than 8\\n                digits[i]++; // incremented by 1 directly\\n                carry =0; // no need of carry\\n                break; // increased the number by 1 and break\\n            }\\n            else{\\n                digits[i]=0; // else if the number is 9 , so replace the number by 0\\n                carry=1; // generate a carry 1\\n            }\\n        }\\n        if (carry) digits.insert(digits.begin(),1); // as number was increased by 1 there was 1 carry , carry will be placed in beginning \\n        return digits; // return the incremented digits as final output \\n    }\\nint main(){\\n    return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        short i =0; // for smaller integers\\n        bool carry =0; // carry can be zero or one so used bool\\n        for(i=digits.size()-1;i>=0;--i){\\n            if(digits[i]<=8){ // for digits less than 8\\n                digits[i]++; // incremented by 1 directly\\n                carry =0; // no need of carry\\n                break; // increased the number by 1 and break\\n            }\\n            else{\\n                digits[i]=0; // else if the number is 9 , so replace the number by 0\\n                carry=1; // generate a carry 1\\n            }\\n        }\\n        if (carry) digits.insert(digits.begin(),1); // as number was increased by 1 there was 1 carry , carry will be placed in beginning \\n        return digits; // return the incremented digits as final output \\n    }\\nint main(){\\n    return 0;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122017,
                "title": "simple-way-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int idx=digits.size()-1;\\n        while(idx>=0)\\n        {\\n            if(digits[idx]==9)\\n            {\\n                digits[idx]=0;\\n            }\\n            else\\n            {\\n                digits[idx]+=1;\\n                return digits;\\n            }\\n            idx--;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n        \\n        \\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int idx=digits.size()-1;\\n        while(idx>=0)\\n        {\\n            if(digits[idx]==9)\\n            {\\n                digits[idx]=0;\\n            }\\n            else\\n            {\\n                digits[idx]+=1;\\n                return digits;\\n            }\\n            idx--;\\n        }\\n        digits.insert(digits.begin(),1);\\n        return digits;\\n        \\n        \\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086740,
                "title": "beats-100-easy-beginner-friendly-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nHere,First we have to take two cases\\n1) if digit < 9\\n    casually increment digit[i];\\n2) if digit == 9\\n    here we find no of last occuring 9\\'s so,we increment just      before index of first 9 in given array order.\\n->apply for loop to get incrementing position\\ntwo cases\\n 1.if only one 9 i.e., {9} then we have update 9 to 1 and pushback 0;\\n 2. if no of 9\\'s > 1 (ex:499,87999)then we update the just before index of first consecutive 9 and update the remaining values 0f 9with for loop by 0\\n \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        #for storing last consecutive 9\\'s location appearing from reverse\\n        int a = 0;\\n\\n        if(digits[n-1] < 9){\\n            digits[n-1]++;\\n            return digits;\\n        }\\n\\n        if(digits[n-1]==9){\\n            #for finding last consective 9 from reverse\\n            for(int i = n-1; i>=0;i--){\\n               \\n                if(digits[i] == 9){\\n                    a  =  i;                 \\n                }\\n                else if(digits[i]<9){\\n                    break;\\n\\n                }\\n              \\n            }\\n            #updating 9\\'s with 1\\n            if(a == 0){\\n                digits[0] = 1;\\n                for(int i = 1;i<n;i++){\\n                    digits[i] = 0;\\n                }\\n                digits.push_back(0);\\n            }\\n            #updating 9\\'s with 0\\n            if(a>0){\\n                 digits[a-1]++;\\n                for(int i = a; i<n; i++){\\n                    digits[i] = 0;\\n                }\\n            }   \\n        }\\n        \\n      return digits;\\n    }\\n    \\n};\\n\\n```\\n\\n\\n![{C6536750-B4F1-492E-9ED4-046628FB312E}.png](https://assets.leetcode.com/users/images/6ae85fce-a91d-408f-bb91-87d599ad888f_1674403258.8890588.png)\\n\\n\\nIf u find it useful please upvote this solution.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        #for storing last consecutive 9\\'s location appearing from reverse\\n        int a = 0;\\n\\n        if(digits[n-1] < 9){\\n            digits[n-1]++;\\n            return digits;\\n        }\\n\\n        if(digits[n-1]==9){\\n            #for finding last consective 9 from reverse\\n            for(int i = n-1; i>=0;i--){\\n               \\n                if(digits[i] == 9){\\n                    a  =  i;                 \\n                }\\n                else if(digits[i]<9){\\n                    break;\\n\\n                }\\n              \\n            }\\n            #updating 9\\'s with 1\\n            if(a == 0){\\n                digits[0] = 1;\\n                for(int i = 1;i<n;i++){\\n                    digits[i] = 0;\\n                }\\n                digits.push_back(0);\\n            }\\n            #updating 9\\'s with 0\\n            if(a>0){\\n                 digits[a-1]++;\\n                for(int i = a; i<n; i++){\\n                    digits[i] = 0;\\n                }\\n            }   \\n        }\\n        \\n      return digits;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961997,
                "title": "100-beats-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        for(int i=d.size()-1;i>=0;i--)  {\\n          if(d[i]<9){\\n              d[i]++;\\n              return d;\\n          }\\n          else{\\n              d[i]=0;\\n          }\\n      }\\n        d.push_back(0);\\n        d[0]=1;\\n          \\n      \\n\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& d) {\\n        for(int i=d.size()-1;i>=0;i--)  {\\n          if(d[i]<9){\\n              d[i]++;\\n              return d;\\n          }\\n          else{\\n              d[i]=0;\\n          }\\n      }\\n        d.push_back(0);\\n        d[0]=1;\\n          \\n      \\n\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572510,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568525,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1663040,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1571826,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1779772,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1569392,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568886,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1659327,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568480,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1574979,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1572510,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568525,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1663040,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1571826,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1779772,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1569392,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568886,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1659327,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1568480,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1574979,
                "content": [
                    {
                        "username": "ShubhamDeshkar",
                        "content": "Leetcode has the worst of examples ever. They should give better explaination of the problem and it\\'s expected solution. This just wastes a lot of time to keep tweaking the code again and again by adjusting it to the test cases. This also lowers the confidence if you don\\'t get it right the first time.\\n\\nHey, Leetcode, improve yourself."
                    },
                    {
                        "username": "kelvin2602",
                        "content": "I dont think so, okay it can waste a lot of time to keep tweaking but, it trains the brain to know how to solve these problem, so the next time you have similar problem like this, you know how to do it, and you know how to solve it"
                    },
                    {
                        "username": "eduard92",
                        "content": "Its a good question, in an interview on a whiteboard or paper they might not even be that edgy, you don\\'t need to do it right first try."
                    },
                    {
                        "username": "eduard92",
                        "content": "I have seen worse than this, like way worse, just do +1 to last element and take in the consideration what will happen. Got 93/111 testcases first try without an IDE"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "[@signalskip](/signalskip) I would say the 4.7k dislikes would disagree with you. And it\\'s a bit needlessly insulting to assume that OP is simply making boilerplate code. Lastly, stating that you haven\\'t had issues without explaining how or giving your though process at least on this problem is very \"get good noob\" of you."
                    },
                    {
                        "username": "elysiumplain",
                        "content": "[@nitrogeno01](/nitrogeno01) One key objective of logistical programming puzzles is to teach you to learn to think about edge conditions. Test cases are there to provide further examples, or in some cases, to enable you to confirm your edge case belief.\n\nTry this process a few times and see if you improve your proposed solutions' \"coverage\"."
                    },
                    {
                        "username": "qiushile",
                        "content": "dude, just focus on the root cause, not just some test cases"
                    },
                    {
                        "username": "signalskip",
                        "content": "Going to have to disagree here. The point here is to write a code that will always work through the constraints listed on the description, not just the few test cases here. You shouldn\\'t aim to just satisfy the test cases, you should aim to answer the entire problem. I have never had an issue where I pass the test cases and not the submit cases."
                    },
                    {
                        "username": "nitrogeno01",
                        "content": "u are totally rigth after sometime coding and testing with the cases i submit and it always failed beacause the submit case is always kind of different"
                    },
                    {
                        "username": "naveen_425",
                        "content": "As per description \"You may assume the integer does not contain any leading zero, except the number 0 itself.\" but looks like this test case [0,0] is conflicting with description."
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Leetcode provides horrible examples, and they don\\'t fix them. Likely we will never get a response from them. I either find a DIFFERENT WEBSITE or i skip the problem"
                    },
                    {
                        "username": "user1628bq",
                        "content": "Guys, Help me with this test case [9,8,7,6,5,4,3,2,1,0].\\ndigits =[9,8,7,6,5,4,3,2,1,0]          60 / 111 testcases passed\\nOutput\\n[1,2,8,6,6,0,8,6,1,9]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]"
                    },
                    {
                        "username": "burmau",
                        "content": "Looks as though they were incrementing the largest digit at digit[i] instead of the largest integer itself."
                    },
                    {
                        "username": "drishtiphagwani7",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990) Thank you Ajay for coming up with this logic. I could easily solve this problem and could also handle all the edgy conditions."
                    },
                    {
                        "username": "Chand51200",
                        "content": "Cast it to long from int."
                    },
                    {
                        "username": "navneet_yadav0048",
                        "content": "use simple loop except reverse"
                    },
                    {
                        "username": "konaleelakrishna974",
                        "content": "[@Rajan kumar sah](/user1628bq) why don\\'t use list indexing concept and select last index value and increment by 1 and return the list."
                    },
                    {
                        "username": "ASHISH_BHAMBURE",
                        "content": "[@Ajay_Singh9990](/Ajay_Singh9990)  BUt how to implement it bro pls tell "
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9then update it zero and update previus index value by 1 if again previus inex is 9 then do same steps till i>=0 at the o th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "sumjains",
                        "content": "If you\\'re facing this error in Java, you can use BigInteger instead of int/long. That\\'ll surely help you pass all 111 testcases."
                    },
                    {
                        "username": "shivammafia0074",
                        "content": "hey i\\'m facing the same problem. Were u able to solve it?"
                    },
                    {
                        "username": "addlurumohanraj",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) do we need to use string for this? I used long and there is a test case more longer than int number"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "this is because you have exceeded max size of integer i.e,2147483647 hence the overflow error. Use long instead of int and at the time of inserting value in array cast long to int(as casting single digits won't give any problems).\nNOTE : It wont work if you exceed long limit hence optimal solution can be found in this discussion."
                    },
                    {
                        "username": "eitss813",
                        "content": "overflow issue"
                    },
                    {
                        "username": "wangyiman",
                        "content": "I can not understand the question."
                    },
                    {
                        "username": "tobilarry",
                        "content": "I want you to think about you do carry overs when performing addition operation."
                    },
                    {
                        "username": "BlakeE",
                        "content": "[@CT-7567](/CT-7567) If digits[0] = 9 i created a second array with a length of digits\\' length + 1. Otherwise i would keep it within digits and return digits"
                    },
                    {
                        "username": "TolunayM",
                        "content": "[@CT-7567](/CT-7567) No it\\'s not impossible but tricky."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sankarshbb](/sankarshbb) I haven\\'t attempted but I wonder the test case [9]? how to add one more element to array isn\\'t it impossible? "
                    },
                    {
                        "username": "sankarshbb",
                        "content": "Now thats a problem isnt it"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "bro why u using int ,long or any data type just check value in the array indexes and update value by zero and if end index value is 9 then update it \"zero\" and update previous index value by 1 if again previous index value  is 9 then do same steps when previus index element is not 9 then add 1 to them and return array \\n\\n if every previous element is 9 till  i>=0 at the 0 th index okay if all are 9,9,9,9, in array the make another array and  put 0th index value 1 and return if helpful then upvote me"
                    },
                    {
                        "username": "umair_fq",
                        "content": "Hi Ajay, thank you for your comment here in the description section. After reading your comment, I successfully make the program and get my all test cases passed."
                    },
                    {
                        "username": "Edward_Hu_New",
                        "content": "If not importing any JS library for long integer, what is the solution for numbers which exceed greater than 2^32-1?"
                    },
                    {
                        "username": "spicedNoodle",
                        "content": "let hugeInteger = BigInt(digits.join(\\'\\')) \\n\\nand now you have a nice big int you can work with :)"
                    },
                    {
                        "username": "battulasurendra",
                        "content": "we can use BigInt(num)"
                    },
                    {
                        "username": "1adityajoshi",
                        "content": "    def plusOne(self, digits): return [int(x) for x in str(int(''.join([str(x) for x in digits])) + 1)]"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "coolmalhar",
                        "content": "Time Complexity is O(n^2) : )\\n"
                    },
                    {
                        "username": "socraticDevBlog",
                        "content": "same thing but using more than one line ;)"
                    },
                    {
                        "username": "nandan_kumar07",
                        "content": "vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int n = digits.size();\\n        int r;\\n        long long int num = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            num += digits[i]*pow(10,n-1-i);\\n        }\\n        long long int new_num = num+1;\\n        while(new_num > 0)\\n        {\\n            r = new_num%10;\\n            ans.push_back(r);\\n            new_num = new_num/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n\\nWhy this is not working for test cases [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]"
                    },
                    {
                        "username": "_pranaymishra_",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same problem with me...can you help\\n"
                    },
                    {
                        "username": "Atif_32395",
                        "content": "you need to remove all element from vector,  write this one \"ans.clear()\" after this  statement \"long long int new_num = num+1;\""
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "because long long int has also limitations i.e, upto 20 digits at a time between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Naman_Gupta_01](/Naman_Gupta_01) same it passed 77 testcases but not more than that. I think we have to use BigDecimal instead of long (Java)"
                    },
                    {
                        "username": "Naman_Gupta_01",
                        "content": "mine not working on digits =\\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]"
                    },
                    {
                        "username": "l0lbeatth",
                        "content": "A new test case [0, 0] was addes some time, although this case is not consistent with problem statement."
                    },
                    {
                        "username": "fayyoz24",
                        "content": "a = \"\"\\nfor i in digits:\\n\\ta+=str(i)\\nb = int(a)+1\\nc = []\\nfor j in str(b):\\n\\tc.append(int(j))\\nreturn c"
                    },
                    {
                        "username": "amadio",
                        "content": "Do not post solutions here"
                    }
                ]
            },
            {
                "id": 1945414,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1570218,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1953534,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1570820,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 2028655,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1729564,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1718343,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1625339,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1573484,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1568626,
                "content": [
                    {
                        "username": "ravih19",
                        "content": "Guys!! Try solving the problem using 3 cases.\\na) Considering all the values are 9.\\nb) Considering the last digit is not 9.\\nc) Considering the last digit is 9.\\nThis will make the coding a bit easy for you"
                    },
                    {
                        "username": "Anuj_Nandal_",
                        "content": "what will be the solution for case a and c bro? will it be 10 or (1,0)  ---> last digit?"
                    },
                    {
                        "username": "grifmang",
                        "content": "`return [int(x) for x in str(int(\\'\\'.join(map(str, digits))) + 1)]`"
                    },
                    {
                        "username": "rasam1102",
                        "content": "I'll do you one better\n`list(map(int, list(str(int(\"\".join(map(str, digits))) + 1))))`"
                    },
                    {
                        "username": "8755600408",
                        "content": "perfect\\n"
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Why is the discussion section filled with people flexing their one liners?"
                    },
                    {
                        "username": "ajaykathrotiya1819",
                        "content": "ans=\\'\\'.join(str(i) for i in digits)\\nans=int(ans)+1 \\nreturn list(str(ans))"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "the leetcode interpreter is doing a shitty job, although my code works perfectly in visual code studio, here it\\'s showing a different answer"
                    },
                    {
                        "username": "ExPLICIT_27",
                        "content": "        plusone = digits[-1] + 1\\n        if len(str(plusone)) > 1:\\n            digits.pop()\\n            for i in str(plusone):\\n                digits.append(int(i))\\n        else:\\n            digits[-1] = plusone\\n        return digits\\n        # this is the code"
                    },
                    {
                        "username": "cyborg_king",
                        "content": "just consider it a basic sum problem,\\nhow a child add two multiple digit no.,\\nwhenever sum of two nos. exceeds 9, we used to carry forward 1.\\nRun a loop over the elements/digits of the list/array if carry for. is required. and return the result"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This isn\\'t an easy problem man ;) \\nnearly took 2-3 days to get to the logic in a right way  cheers ;) "
                    },
                    {
                        "username": "Omar211",
                        "content": "//why it is not working??\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n           \\n        int[] result = new int[digits.length];\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = digits[i];\\n        }\\n       if (result[result.length-1] == 9) {\\n        result[result.length-1] = 0;\\n        result[result.length-2] = result[result.length-2]+1;\\n       }\\n        else\\n        result[result.length-1]+=1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "GUSTAVOS07",
                        "content": "because it gets to a point where there is no element at result.length-2 and you should add another number to the list like 9  -> 10 to solve it you need to check if result.length-2 is >= 0 "
                    },
                    {
                        "username": "james_leetcode_2050",
                        "content": "For those who disliked, can you please share your reasons why you disliked this problem?"
                    },
                    {
                        "username": "lebaotoan89",
                        "content": "So can you share your reasons why you want to know their disliked reason men?\\n"
                    },
                    {
                        "username": "amestri890",
                        "content": "return [int(i) for i in str(int(\"\".join([str(x) for x in nums]))+1)]"
                    }
                ]
            },
            {
                "id": 1998273,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1996383,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1948881,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1772771,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572288,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572251,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1572202,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575637,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575354,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1575298,
                "content": [
                    {
                        "username": "elias_matar",
                        "content": "So much unnecessary computation being discussed.\\nStart from the end of the array and keep checking if the number is 9. As long as it is, replace it with 0.\\nAs soon as it isn\\'t 9, increment the current number with 1 and return the array.\\nIt is worth noting that the array should be expanded if the input is something like [9,9,9]."
                    },
                    {
                        "username": "hariharan94421",
                        "content": "you should not say the direct solution bro "
                    },
                    {
                        "username": "wadebutler",
                        "content": "I didn\\'t know BigInt() was a thing thank you comment section!"
                    },
                    {
                        "username": "BatMe",
                        "content": "      `        reverse(digits.begin(),digits.end());\\n\\n        int digit; int sum = 1; int carry = 0;\\n        vector<int>v;\\n\\n        for(int i = 0; i<digits.size();i++){\\n            sum+=digits[i]+carry;\\n\\n            if(sum == 0){\\n                v.push_back(digits[i]);\\n            }\\n            else{\\n            while(sum!=0){\\n                digit = sum%10;\\n                v.push_back(digit);\\n                carry = sum/10;\\n                sum = sum/10;\\n            }\\n            }\\n            \\n        }\\n\\n        reverse(v.begin(),v.end());\\n        return v; `\\n\\n\\nThis code is not working on the test case [9,9] help me what I need to change? One thing I notices is that in this case, sum!=0 thus 1 is pushed before which should instead be used as a carry. But i don\\'t know how to change it. "
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "undefitied",
                        "content": "Some Javascript:\\n1. Simple code:\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    let index = digits.length-1\\n    while (digits[index] === 9) {\\n        digits[index] = 0\\n        index--\\n    }\\n    \\n    if (index === -1) {\\n        digits.unshift(1)\\n    } else {\\n        digits[index]++        \\n    }\\n    \\n    return digits\\n};\\n```\\n2. Faster code, same principle\\n```\\nvar plusOne = function(digits) {\\n    let carryOver = 0\\n    \\n    if (digits[digits.length-1] === 9) {\\n        for (let i = digits.length-1; i>=0; i--) {\\n            const num = digits[i]\\n            if (num === 9) {\\n                digits[i] = 0\\n                carryOver = 1\\n            } else {\\n                digits[i] = num+carryOver\\n                carryOver = 0\\n                break\\n            }\\n        }\\n    } else {\\n        digits[digits.length-1]++\\n    }\\n    \\n    if (carryOver === 0) {\\n        return digits\\n    }\\n    \\n    digits.unshift(carryOver)\\n    \\n    return digits\\n};\\n```"
                    },
                    {
                        "username": "joycesmiling_leetcode",
                        "content": "Use python map\\n\\nnum = int(\\'\\'.join(map(str, digits))) + 1\\nreturn list(map(int,str(num)))"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "[int(i) for i in str(int(''.join([str(i) for i in digits])) + 1)] "
                    },
                    {
                        "username": "MiaMiaJin",
                        "content": "s = \\'\\'.join(map(str,digits))\\ni = int(s)+1\\nreturn list(map(int, str(i)))"
                    },
                    {
                        "username": "ClarieZHANG",
                        "content": "import math\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        math.floor(math.sqrt(x))"
                    },
                    {
                        "username": "themashcode",
                        "content": "const plusOne = digits => (BigInt(digits.join(\\'\\')) + 1n).toString().split(\\'\\')\\n"
                    },
                    {
                        "username": "PK071",
                        "content": "Why not use this.\\n\\nreturn list(str(int(\\'\\'.join([str(i) for i in digits]))+1))"
                    }
                ]
            },
            {
                "id": 1571908,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2075848,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2071032,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2069813,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2069121,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2067406,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2055166,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2054500,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2050421,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2047933,
                "content": [
                    {
                        "username": "desileetcoders",
                        "content": "Same as question"
                    },
                    {
                        "username": "Architag1503",
                        "content": "//In this solution we apply concept of add two arrays.\\n\\nclass Solution {\\n\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n//So we make the another vector which have value 1.\\n        vector<int> z={1};\\n//there may be the carry after adding .\\n        int carry=0;\\n        int i=digits.size()-1;\\n        int j=z.size()-1;\\n//we have to start from end \\n        while(i>=0 && j>=0)\\n        {\\n            int sum=digits[i]+z[j]+carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n            j--;\\n        }\\n // after adding 1 some part other vector is left and some carry is also left.\\n        while(i>=0)\\n        {\\n            int sum = digits[i] + carry;\\n            carry = sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n            i--;\\n        }\\n//there may be carry after ending also , so that carry is also added. Ex- [9,9]+[1]=[1,0,0]\\n        while(carry!=0)\\n        {\\n            int sum = carry;\\n            carry=sum/10;\\n            sum=sum%10;\\n            ans.push_back(sum);\\n        }\\n        \\n //at last we have to reverse the vector. If we not reverse the vector ans will come wrong.\\n//Ex-  [9,9,9,1]+[1]=[2,9,9,9]--->wrong   \\n        reverse(ans.begin() , ans.end());\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "AbhishekHi",
                        "content": "`for i in  digits: \\n            if digits.append(i):\\n                return digits\\n        `\\n\\nCan anyone improve this from here? \\n        \\n        "
                    },
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=digits.size()-1;\\n       \\n            while(i>=0&&digits[i]==9){\\n             digits[i]=0;\\n             i--;\\n            }\\n            if(i<0){\\n                digits.insert(digits.begin(),1);\\n            }else{\\n                digits[i]=digits[i]+1;\\n            }\\n           return digits;\\n        }\\n    \\n};"
                    },
                    {
                        "username": "salomanjames",
                        "content": "Can anyone explain if digits = {1,2,3,9};\\nwhat will be the output???"
                    },
                    {
                        "username": "tobilarry",
                        "content": "1240 \\n\\nTry and write an algorithm in such a way you will solve it in real life scenrio"
                    },
                    {
                        "username": "rockinganshu97",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> ans;\\n        int sum=0;\\n        int n=digits.size();\\n        for(int i=0;i<n;i++){\\n            sum = sum*10 +digits[i];\\n        }\\n        sum=sum+1;\\n        for(int i=0;i<n;i++){\\n            int rev=sum%10;\\n            ans.insert(ans.begin(), rev);\\n            sum=sum/10;\\n        }\\n       return ans;\\n        \\n    }\\n};\\n\\nwhy it is not working?"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "passed 61 /111 test case :[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]  can anyone explain?"
                    },
                    {
                        "username": "chickenTandoori",
                        "content": "Improve your test cases..!!"
                    },
                    {
                        "username": "Pranav2132",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int start=0;\\n        int t=digits[digits.size()-1];\\n        int n=digits.size();\\n        for(int i=0; i<n; i++){\\n        if(digits[i]!=t){\\n           cout<<digits[i];\\n        }\\n      }\\n        cout<<t+1; \\n    }\\n    \\n    \\n}; this is write way for beginner?\\n"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "very easy c++ solution\\n for(int i=digits.size()-1;i>=0;i--)\\n   {\\n       if(digits[i]<9)\\n       {\\n           digits[i]++;\\n           return digits;\\n       }\\n       else\\n       {\\n           digits[i]=0;\\n       }\\n                  \\n   }\\n   digits.push_back(0);\\n   digits[0]=1;\\n   return digits;"
                    }
                ]
            },
            {
                "id": 2045323,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2044544,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2040611,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2036252,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2035844,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2022155,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2009432,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2005275,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 2003887,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 1998898,
                "content": [
                    {
                        "username": "Anubhav_Choudhary",
                        "content": "this code beats 100% users in time complexity but is not so good in terms of space complexity.\\nAny suggestions?\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int n = digits.length;\\n\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(digits[i]<9){\\n               digits[i]++;\\n               return digits;\\n            }else{\\n            digits[i] = 0;\\n            }\\n        }\\n        int[] result = new int[n+1];\\n        result[0] = 1;\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "Sameer_Vohra",
                        "content": "         class Solution {\n         public:\n         vector<int> plusOne(vector<int>& digits) {\n        unsigned long long num = 0;\n\n        int n = digits.size();\n\n        for(int i=0; i<n; i++){\n            num = num*10 + digits[i];\n        }\n\n        num = num+1;\n\n        vector<int> ans;\n\n        while(num!=0){\n            int temp = num%10;\n            num/=10;\n            ans.push_back(temp);\n        }\n\n        reverse(ans.begin(), ans.end());\n\n        return ans;\n    }\n};\n\n[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\n\nWhy is this code not working for the test case given above?"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The reason your code is not working for the given test case is that the number generated by concatenating all the digits in the vector is too large to fit into an `unsigned long long` variable. For example, the number formed from the given vector `[7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]` is very large and is likely to cause an overflow.\\n\\nOne way to avoid this is to perform the \"plus one\" operation directly on the array/vector without converting it to a number. Here\\'s how:\\n\\n1. Start from the last digit and move toward the first digit, propagating any carry.\\n2. If the last digit is less than 9, just increment it and you are done.\\n3. If the last digit is 9, make it zero and propagate a carry to the previous digit.\\n4. If the first digit ends up being zero with a carry, you\\'ll need to insert a new \\'1\\' at the beginning.\\n\\nHere is some sample code to demonstrate:\\n\\n\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (digits[i] < 9) {\\n                ++digits[i];\\n                return digits;\\n            }\\n            digits[i] = 0;\\n        }\\n        // If all the digits were 9, then we\\'ll reach this point and we need to add a new \\'1\\' at the beginning.\\n        digits.insert(digits.begin(), 1);\\n        return digits;\\n    }\\n};\\n\\n\\nThis approach has a time complexity of \\\\( O(n) \\\\) and doesn\\'t use any additional space (except for the returned result), i.e., it has a space complexity of \\\\( O(1) \\\\)."
                    },
                    {
                        "username": "Aayush_Agarwal",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(digits[n-1]==9){\\n                digits[n-1]=0;\\n            }\\n            else{\\n                digits[i]+=1;\\n                return digits;\\n            }\\n        }\\n        digits.insert(digits.begin(),1);\\n        cout<<digits.size();\\n        return digits;\\n    }\\n};\\nwhy my code is giving wrong answer for [9,9].\\nit gives output as [10,0] instead of [1,0,0].\\nwhen i run it on vs code it provides correct output. please tell me what\\'s wrong in it. "
                    },
                    {
                        "username": "princewilly-cloud",
                        "content": "this question looked easy, but it definitely required some tough logic "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "No jst bro just addition with carry.\\ntake the size+1 of new array if and olny all values are 9. Thats it . "
                    },
                    {
                        "username": "Pr1yankar",
                        "content": "hehe done in first try. so satisfying !!!!  "
                    },
                    {
                        "username": "faizanhaidar",
                        "content": "They asked to increment the last number only but for [9,9] my solution is [9,1,0] and it expects [1,0,0]"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    for(int i=digits.size()-1;i>=0;i--)\\n    {\\n        if(digits.at(i)==9)\\n            digits.at(i)=0;\\n        else\\n        {\\n            digits.at(i)=digits.at(i)+1;\\n            return digits;\\n        }\\n    }\\n    digits.at(0)=1;\\n    digits.push_back(0);\\n    return digits;\\n    }\\n};"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "When I started to solve this question. I was thinking that this is very easy question but when submitting the code. Then understand it is not easy as expected."
                    },
                    {
                        "username": "RudrSharma",
                        "content": "use long long data type except int  data type \\n"
                    },
                    {
                        "username": "aryav_luna",
                        "content": "but return type of function is int array so how would it work?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know the best possible answer for this. But the most easy one would be string > int+1 > string > list(int(string)) (list_comprehension would be helpful)"
                    },
                    {
                        "username": "kraig1",
                        "content": "lass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n    vector<int> v;\\n    int b = digits.size();\\n    int c = 0;\\n    for (int i = 0; i < b; i++) {\\n        if (digits[i] == 9) c++;\\n    }\\n    if (c == b) {\\n        v.push_back(1);\\n        while (c--) {\\n            v.push_back(0);\\n            }\\n    } else {\\n        for (int i = b - 1; i >= 0; i--) {\\n            if (digits[i] == 9) {\\n                v.push_back(0);\\n                digits[i - 1] += 1;\\n            } else {\\n                digits[i] += 1;\\n                break;\\n            }\\n        }\\n        reverse(v.begin(), v.end());\\n    }\\n    return v;\\n    }\\n};            where is wrong in my code"
                    }
                ]
            },
            {
                "id": 1994941,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1986849,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1978507,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1972982,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1971507,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1966992,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1959180,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1956445,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1942942,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1941708,
                "content": [
                    {
                        "username": "MitchMountainCoding",
                        "content": "Although the problem constraints don\\'t require it, for a more real-world scenario, I would want to consider the fact that numbers can be incredibly large, possibly exceeding the maximum limit of a long in Java. In such cases, a conversion to BigInteger and then performing the increment operation would work."
                    },
                    {
                        "username": "Jiraiya1",
                        "content": "public static int[] plusOne(int[] digits) {\\n\\n        if(digits.length == 1 && digits[0] == 9) {\\n            return new int[]{1,0};\\n        }\\n\\n      for(int i = digits.length-1; i>=0; i--) {\\n          \\n          if(digits[i] != 9) {\\n              digits[i] = digits[i] +1;\\n             return digits;\\n          }\\n      }\\n      return new int[]{};\\n    }\\n\\nI have a issue with this test case \\n\\n\\ndigits =\\n[9,9]\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[1,0,0]"
                    },
                    {
                        "username": "devsoni5880",
                        "content": "Hello,\\nI am able to crack all the test cases but one tese case I am not able to achive is if digits = 9 the they want [1,0] in output so how do i do that?\\nthe length is 1 and if we add 1 , 0 then the length will incress and this will throw an error of index out of bound\\n\\nkindly help me."
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "Yous should use memory allocation"
                    },
                    {
                        "username": "Yeab13",
                        "content": "Incase you are using javascript , don\\'t forget to use BigInt as some of the tests cases hold big number"
                    },
                    {
                        "username": "Seethaphal",
                        "content": "This question is difficult to understand. what does this mean  \"where each digits[i] is the ith digit of the integer.\"  \\n\\nint[] x ={1,2,3} ith digit   x[0] is the zeroth digit of the integer? \\n\\nThe digits are ordered from most significant to least significant in left-to-right order.  right side digits are not required?\\n\\nThe large integer does not contain any leading 0\\'s. ?\\n"
                    },
                    {
                        "username": "Boobs_Inspector",
                        "content": "what returnSize pointer stands for?\\n"
                    },
                    {
                        "username": "mng48301",
                        "content": "Make sure to fully understand a problem before you start trying to solve it. I misunderstood what they were asking for and wasted an hour wondering what went wrong. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Can we get some basic English comprehension checks on these tests? \\nSince when does \\'significant\\' mean \\'largest\\' or \\'biggest\\'? - significant is just the entirely incorrect word to use here, very confusing. "
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I only got this cuz of the test cases, that array its just a number and u should return that number increased by +1 but in an array form. Use int(), str() this stuff and should be easy.... downvote tho for the complicated description "
                    },
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[9,9] and digits=[1,9,9]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "100 \\u0438 200\\n"
                    }
                ]
            },
            {
                "id": 1941687,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1934735,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1922431,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1918670,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1908466,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1907090,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1891365,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1884705,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1883693,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1858251,
                "content": [
                    {
                        "username": "Andersonwjeh",
                        "content": "What will be the out put of digits=[1,5,9,]"
                    },
                    {
                        "username": "Bespalow",
                        "content": "160"
                    },
                    {
                        "username": "Msey",
                        "content": "Get asked that question at Google equals win the lottery"
                    },
                    {
                        "username": "tanishq29",
                        "content": " can anyone help me to modify this code for 3rd test case where value is 9,\\nint [] arr = new int[digits.length];\\n        for(int i = 0 ; i<digits.length-1 ; i++){\\n            arr[i] = digits[i];\\n            int s = digits.length-1;\\n            arr[s] = digits[s] + 1;\\n        }\\n        \\n        return arr;"
                    },
                    {
                        "username": "b20ec013",
                        "content": "for (int i = digits.length - 1; i >= 0; i--) {\\n\\tif (digits[i] < 9) {\\n\\t\\tdigits[i]++;\\n\\t\\treturn digits;\\n\\t}\\n\\tdigits[i] = 0;\\n}\\n\\ndigits = new int[digits.length + 1];\\ndigits[0] = 1;\\nreturn digits;                   like this\\n"
                    },
                    {
                        "username": "b20ec013",
                        "content": "create if condition in loop and check if last digit is 9 increment the size of array and add zero at last"
                    },
                    {
                        "username": "mahendrareddykuncha",
                        "content": "Using while loop got output as [9] -> [1] expected is [1,0] why so,"
                    },
                    {
                        "username": "omarkh999",
                        "content": "why the hell can not I use more than one function and mingle them in PlusOne. He keeps telling me that the name of the function is not Identified  as though I did not write it."
                    },
                    {
                        "username": "eagle_s_",
                        "content": "can somebody help me why i'm getting run time error---------\n\n\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size()-1;\n        int num = digits[n] + 1;\n        int rem = -1;\n        bool rem1 = false;\n        if(num >= 10)\n        {\n            rem = 1;\n            rem1 = true;\n        }\n        else\n        {\n            digits[n] = num;\n        }\n        if(rem1 != false)\n        {\n            digits[n] = 0;\n            for(int i = digits.size()-2; i >= 0; i--)\n            {\n                digits[i] = digits[i] + rem;\n                if(digits[i] >= 10)\n                {\n                    digits[i] = 0;\n                    rem = 1;\n                }\n                else\n                {\n                    rem = -1;\n                    rem1 = false;\n                    break;\n                }\n            }\n        }\n        if(rem1 != false)\n        {\n            vector<int> ans;\n            ans[0] = 1;\n            for(int i = 0; i < digits.size(); i++)\n            {\n                ans[i+1] = digits[i];\n            }\n            return ans;\n        }\n        return digits;\n    }\n};"
                    },
                    {
                        "username": "shahareyar601",
                        "content": "can someone tell me why it is not working for {9}\\n\\nvector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n       for(int i=n-1;i>0;i--){\\n         if(digits[i]!=9){\\n         digits[i]=digits[i]+1;\\n         break;\\n         }\\n         else\\n         digits[i]=0;\\n         \\n       } \\n       if(digits[0]==0){\\n       digits.insert(digits.begin(),1);\\n       }\\n        return digits;\\n    }"
                    },
                    {
                        "username": "vighnesh_rasal",
                        "content": "I am trying to use BigInteger in java but compiler says \\'cannot find symbol BigInteger.\\' what seems to be the problem? "
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "you need to import Biginteger."
                    },
                    {
                        "username": "Hagar_",
                        "content": "Hello,\\n\\nI\\'m trying to join digits in a string using `s = digits.join(\"\");`. Yet, for case [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3] it neglects the last three digits and ouput 6145390195186705000\\n\\nI even used loops to check, but still returns the same answer\\n\\n```\\nfor (let i = 0; i < digits.length; i++) {\\n      text += digits[i];\\n      console.log(digits[i]);\\n    }\\n```\\n\\nAny idea why this happens?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        list = []\\n        digit = \\'\\'\\n        for i in digits:\\n            digit += str(i)\\n        num = 1\\n        num += int(digit)\\n        num1 = str(num)\\n        for i in num1:\\n            list.append(int(i))\\n        return list"
                    }
                ]
            },
            {
                "id": 1846145,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1841757,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1840067,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1839821,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1838736,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1835121,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1830114,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1827168,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1813842,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1808828,
                "content": [
                    {
                        "username": "mahajanagouda",
                        "content": "can anybody tell me why this code is not working it is returning same array even after adding 1 to the integer\\n\\n\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int temp1=0,into=1;\\n        int temp;\\n        int length = digits.length;\\n        for(int i =length-1;i>-1;i--){\\n            temp=digits[i]*into;\\n            temp1=temp1+temp;\\n            into=into*10;\\n            if((digits[i]==9)&&(length!=length+1))\\n            {\\n                length++;\\n            }\\n\\n        } \\n        System.out.println(temp1);\\n        int temp2=temp1+1;\\n        System.out.println(temp2);\\n        int div=10;\\n        for(int i=length-1;i<-1;i--){\\n    \\n            digits[i]=temp2%div;\\n            temp2=temp2-digits[i];\\n            div=div*10;\\n        }\\n        System.out.println(temp2%10);\\n        return digits;\\n    }"
                    },
                    {
                        "username": "Mirza-Fardeen",
                        "content": "java.lang.NumberFormatException: For input string: \"728509129536673284379577474947011174006\"\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 1163, java.base/java.lang.Long.valueOf\\n  at line 7, Solution.plusOne\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main \\n\\nwhat is this -__- , seriously"
                    },
                    {
                        "username": "ezratweaver",
                        "content": "took 3 lines of code too easy"
                    },
                    {
                        "username": "rohit_442",
                        "content": "case 3 failed\\n"
                    },
                    {
                        "username": "Ashu07",
                        "content": "class Solution\\n{\\n    public int[] plusOne(int[] arr) \\n    {\\n            \\tlong int ans= 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n        \\tans=ans*10+arr[i];\\n        }\\n        ans+=1;\\n        int size=0,rev=0;\\n        int n =ans;\\n        while(ans>0)\\n        {\\n        \\tint rem = ans%10;\\n        \\trev=rev*10+rem;\\n        \\tsize++;\\n        \\tans/=10;\\n        }\\n       int [] nums= new int[size];\\n       for(int i=0;i<size;i++)\\n       {\\n    \\t   nums[i]=rev%10;\\n    \\t   rev/=10;\\n       }\\n     return nums;\\n    }\\n}\\n\\nThis fails on \\n[9,8,7,6,5,4,3,2,1,0]\\nUse Testcase\\nOutput\\n[9,2,2,2,3,1,8,7,5,0]\\nExpected\\n[9,8,7,6,5,4,3,2,1,1]\\n\\nAnyone correct me?\\n"
                    },
                    {
                        "username": "MastaGlazy",
                        "content": "Can anybody explain to me why this outputs just a \"]\"? I really don\\'t get it and its frustrating me.\\n```c\\nint* plusOne(int* digits, int digitsSize, int* returnSize){\\n    int *newDigits = malloc(digitsSize*sizeof(int));\\n\\n    for(size_t i = 0; i < digitsSize; i++){\\n        newDigits[i] = digits[i];\\n        printf(\"%d\", newDigits[i]);\\n    }\\n    return newDigits;\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "You didn\\'t set returnSize. It should either be ``*returnSize = digitsSize`` or\\n``*returnSize = digitsSize + 1`` depending on whether the number overflowed after incrementing."
                    },
                    {
                        "username": "Cl0us",
                        "content": "guys help. Why do I have runtime error in this code?\\n ` vector <int> d=digits;\\n        int size=digits.size();\\n        if (size==1)\\n        {\\n            if (d[size-1]==9)\\n            {\\n                d[size-1]=1;\\n                d[size]=0;\\n            }\\n        }\\n        else if (size>1)\\n        {\\n            size--;\\n            d[size]++;\\n            while (size>=0 && d[size]==10)\\n            {\\n                d[size]=0;\\n                size--;\\n                d[size]++;\\n            }\\n        }\\n        return d;`"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var plusOne = function(digits) {\\n    let num = parseInt(digits.join(\\'\\'))+1\\n    return num.toString().split(\\'\\')\\n};\\n\\ni am so frastrated\\ncan someone tell me why i am wrong?????"
                    },
                    {
                        "username": "ubidy947",
                        "content": "how do I get past the test 61 which has 39 elements in the list. I am getting a number format exception as the number is to large to convert into Long as well."
                    },
                    {
                        "username": "TimZgeybi",
                        "content": "maybe try \"long long\" instead"
                    },
                    {
                        "username": "bhoomishah20",
                        "content": "Hi Is this proper way to write this code? \nFirst I am checking with for loop that is all digits are 9, if yes then create new array with 1+ length and make first as 1 and others as 0. else another loop to add plus one.\n\n\nboolean isAllnine=false;\n            for(int i=0;i<=length-1;i++) {\n                if(digits[i]!=9) {\n                    break;\n                } else {\n                    if(i==length-1) isAllnine =true;\n                }\n            }\n            if(isAllnine) {\n            int [] ndigits =new int[length+1];\n            ndigits[0]=1;\n            return ndigits;\n            } else {\n                int j=length-1;\n                while(j>=0) {\n                    int sum = digits[j]+1;\n                    \n                    if(sum>9) {\n                        digits[j] =0;  \n                         j--;\n                    } else {\n                        digits[j] =sum; \n                    \n                        return digits;\n                    }\n                   \n                    \n                }\n            }"
                    }
                ]
            },
            {
                "id": 1805046,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1800492,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1798573,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1796819,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1794579,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1789588,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1789139,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1785143,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1779515,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1774899,
                "content": [
                    {
                        "username": "Raj5504",
                        "content": "int n = digits.length;\\n        for(int i = n-1;i >= 0;i--){\\n            if(digits[i] < 9){\\n                digits[i]++;\\n                return digits;\\n            }else{      \\n                digits[i] = 0;\\n            } \\n        }\\n        int[] arr = new int[n+1];\\n        arr[0]=1;\\n        \\n        return arr;"
                    },
                    {
                        "username": "tkulkarni",
                        "content": "class Solution {\\n    public int[] plusOne(int[] digits) {\\n        int[] arr = new int[digits.length];\\n        for(int i=0; i<digits.length; i++){\\n            arr[i] = digits[i];\\n        }\\n        arr[digits.length-1] += 1;\\n\\n        return arr;\\n    }\\n}\\n\\nfirst two cases are successfull but the last case: \\ninput: [9]\\noutput[10]\\nexpected: [1,0]\\n????"
                    },
                    {
                        "username": "avneesh_2001",
                        "content": "to see theback of the digit less than 9 to increse \\nex 123\\n   124\\nso last digit increase, to take the for loop last to end.\\n for(int i=l-1; i>=0; i--)\\n\\n\\nbecause the last less than 9\\nto increse last digit just return\\n\\n\\n if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;         //to not the next digit just return\\n\\n     }\\n\\nelse the number is nine\\n  else\\n     {\\n         digits[i]=0;        //all nine is 0\\n     }\\nthe after nine any digit less than nine so back to this condition\\n  if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n\\nbut the 99 is two digit plus one 100 this is increse one index of digit\\nall nine is 0\\n00\\npush back one 0\\n000\\nand first number is one\\n\\n\\n digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n\\n\\nsolution\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n int l= digits.size();\\n for(int i=l-1; i>=0; i--)\\n {\\n     if(digits[i]<9)\\n     {\\n        digits[i]++;\\n        return digits;\\n\\n     }\\n     else\\n     {\\n         digits[i]=0;\\n     }\\n    \\n }\\n  digits.push_back(0);\\n     digits[0]=1;\\n     return digits;\\n    }\\n};"
                    },
                    {
                        "username": "Akshay0621",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        number = 0\\n        n = len(digits)\\n        ans = []\\n        if len(digits) >= 1 and len(digits) <= 100:\\n            for i in range(len(digits)):\\n                number += digits[i] * (10 ** (n - 1))\\n                n -= 1\\n            number += 1\\n            while number > 0:\\n                digit = number % 10\\n                number = number // 10\\n                ans.append(digit)\\n            ans.reverse()\\n            return ans"
                    },
                    {
                        "username": "_r0ng5_",
                        "content": "Can anyone explain to me what is the value of returnSize here? I use C language"
                    },
                    {
                        "username": "NasimHelal",
                        "content": "I feel very good after solving this problem .. thanks to leetcode "
                    },
                    {
                        "username": "sdi2100098",
                        "content": "C++ and hints\nFor anyone currently working on this problem, split the problem into two smaller ones. First what happens if at the end of the vector the digit<9. Easy : just increase the last digit by one and push back into a new array the elements of the  already existing one.(Hint for C++ : you can use digits.back() function for more elegant use instead of doing : digits[digits.size-1]) `if(digits.back()<9)`\nAnd now for the 'tricky part', the second part of the problem. So we know that the last element is equal to 9.But how can we check what happens to the second to the last element, the third to the last element and so on. Meaning what happens if they are also equal to 9. (Hint for C++ :  you can use .rbegin() and .rend() to traverse the vector from end to start) `for(auto i = digits.rbegin(); i!=digits.rend(); ++i)`.If they are equal to 9 we must make them equal to 0 and using a bool variable continue the process until we find an element which is not equal to 9 or the loop ends. At the end if for example we have a testcase like so :  digits=[9,9,9] the output should be [1,0,0,0] but we have changed the digits into -> digits=[0,0,0]. The solution is simple just push_back to the array that you will return first 1 and continue by pushing back each element of the modified digits(0,0,0).   `return_array.push_back(1);\n            for(auto &j:digits){\n                return_array.push_back(j);`"
                    },
                    {
                        "username": "jonathanwu907890",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        if digits[-1] == 9:\\n            digits[-1] = 1\\n            digits.append(0)\\n            return digits\\n        digits[-1] = digits[-1] + 1\\n        return digits\\n\\nit doesn\\'t work for nums = 9,9??\\nwhy does it expect 1,0,0\\nif i increment last digit of nums then it would be 9,1,0\\ni dont see how this could be 1,0,0"
                    },
                    {
                        "username": "I3imran3",
                        "content": "const plusOne =(digits)=>(BigInt(digits.join(\"\")) +BigInt (1)).toString().split(\"\")"
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "     public int[] plusOne(int[] digits) {\n        int remainder = 0;\n        int digitCount = digits.length - 1;\n        digits[digitCount] = digits[digitCount] + 1;\n\n        do {\n            if (digits[digitCount] + remainder > 9) {\n                digits[digitCount] = (digits[digitCount] + remainder) % 10;\n                remainder = 1;\n            } else {\n                digits[digitCount] = (digits[digitCount] + remainder);\n                remainder = 0;\n            }\n\n            digitCount--;\n        } while (remainder != 0 && digitCount >= 0);\n\n        if (remainder == 1) {\n            int[] newDigits = new int[digits.length + 1];\n            newDigits[0] = 1;\n\n            System.arraycopy(digits, 0, newDigits, 1, digits.length);\n\n            return newDigits;\n        }\n\n        return digits; \n    }"
                    }
                ]
            },
            {
                "id": 1772541,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1772367,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1767978,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1767655,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1762112,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1760265,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1759374,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1758655,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1754118,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1751716,
                "content": [
                    {
                        "username": "chirag123490",
                        "content": "why the hell is this showing after taking long long datatype\\nLine 7: Char 34: runtime error: signed integer overflow: 7285091295366732843 * 10 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:16:34"
                    },
                    {
                        "username": "neeluuu",
                        "content": " String res=\"\";\\n     \\n        for(int i=0;i<digits.length;i++)\\n        {\\n             String s1 = Integer.toString(digits[i]);\\n            res=res+s1;\\n        }\\n           \\n          \\n              BigInteger num=new BigInteger(res);\\n           BigInteger one=new BigInteger(\"1\");\\n              num=num.add(one);\\n           \\n             \\n                String str=num.toString();\\n               int[] arr=new int[str.length()];\\n               \\n        System.out.println(res);\\n\\n     \\n       \\n      for(int i=0;i<str.length();i++)\\n      {\\n            char ch=str.charAt(i);\\n         arr[i]=ch-\\'0\\'; \\n      }\\n\\n        return arr;\\n        \\n\\n"
                    },
                    {
                        "username": "palakjain_123",
                        "content": "Solution is correct till 60 test cases how should approach next\\nvector<int> plusOne(vector<int>& digits) {\\n        vector <int> temp;\\n       long long int n=1,g=0,r=0;\\n       long long int len=digits.size();\\n        while(len-1>0)\\n        {\\n          n=n*10;\\n          len--;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<digits.size();i++)\\n        {\\n           sum=sum+digits[i]*n;\\n           n=n/10;\\n        }\\n        sum=sum+1;\\n        int temp1=sum,leng=0;\\n        while(temp1!=0) {\\n          leng++;\\n          temp1=temp1/10;\\n        } \\n        int count=0;\\n        for(int i=0;i<leng;i++)\\n        {\\n          r=sum%10;\\n          temp.push_back(r);\\n          sum=sum/10;\\n          count++;\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "this is my code ,I couldn\\'t able to solve the error(index 1 out of bounds for length 1)@ 27th line..can anyone help me according this>!!\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int j=0;\\n        int sum=0,num=0;\\n        int k=digits.length-1;\\n        int len=digits.length;\\n        while(len!=0)\\n        {\\n            sum=(int)(sum+(digits[j]*Math.pow(10,k)));\\n            k--;\\n            j++;\\n            len--;\\n        }\\n        sum=sum+1;\\n        int rem;\\n        int temp=sum;\\n        while(sum!=0)\\n        {\\n            num++;\\n            sum=sum/10;\\n        }\\n        sum=temp;\\n        int ku=num;\\n       \\n       for(j=num-1;j>=0;j--)\\n       {   rem=sum%10;\\n           digits[j]=rem;\\n           sum=sum/10;\\n       }\\n       /* for(int i=ku-1;i>=0;i--)\\n        {\\n            digits[n]=digits[i];\\n            n++;\\n        }*/\\n        return digits;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Subh001",
                        "content": "WHY THIS SOLN IS NOT WORKING: OUTPUT {49,50,50}etc. like this.\\n        int n=digits.length;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=sum*10+ digits[i];\\n        }\\n        sum++;\\n        \\n        String ans=Integer.toString(sum);\\n        int arr[]=new int[ans.length()];\\n        for(int i=0;i<arr.length;i++){\\n arr[i]=ans.charAt(i);           \\n            \\n        }\\n        return arr;\\n   \\n\\n"
                    },
                    {
                        "username": "tarunhawdia",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int i=0;\\n        int x=0;\\n        while(i<digits.size()){\\n            x=x*10+digits[i];\\n            i++;\\n        }\\n        x=x+1;\\n        while(x>=0){\\n            int rev=0;\\n            rev=x%10;\\n            x=x/10;\\n            digits.insert(digits.begin(),rev);\\n        }\\n        return digits;\\n    }\\n};\\n//why TLE showing is this?"
                    },
                    {
                        "username": "alexarmstrongvi",
                        "content": "Why do C++ solutions have higher memory usage (8.7 - 8.8MB) when they update the digits vector in-place compared to solutions that store the answer in a new vector (8.4 - 8.6MB)?"
                    },
                    {
                        "username": "abdullahfazili3614",
                        "content": "digits = [8,9,9,9]\\nhow is the output 1,0,0,0,0\\nmy answer is 9,0,0,0"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jpwallace22",
                        "content": "I created a recursive function that works on everything I can throw at it.. however leetcode fails with a `process exited with signal SIGSEGV` whenever it tries to run it. Anyone else see this? "
                    }
                ]
            },
            {
                "id": 1750926,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1750884,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1749795,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1749204,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1741891,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1738350,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1733046,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1729248,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1724878,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1723443,
                "content": [
                    {
                        "username": "AyushV1",
                        "content": "[leetcode](https://leetcode.com) my code is not working for [9];\\n"
                    },
                    {
                        "username": "tomarvaibhav",
                        "content": "int count=0,l=1;\\n         \\n        for(int i=digits.length-1;i>=0;i--){\\n            count+=digits[i]*l;\\n            l*=10;\\n        }\\n        count+=1;\\nMy code is not working for input [9,8,7,6,5,4,3,2,1,0] , till digit 8 count value is right but for 9 it\\'s not correct.\\nPlz tell me what is the error\\n"
                    },
                    {
                        "username": "adityasailella",
                        "content": "Is this any good??\\n    let num = digits.join(\"\");\\n    num = BigInt(num);\\n    ans = num + BigInt(1);\\n    return(Array.from(String(ans),BigInt));\\n"
                    },
                    {
                        "username": "somalkarprajwal0",
                        "content": "Can Anyone tell me what\\'s wrong with my code \\nI am getting runtime error in this test case [9,8,7,6,5,4,3,2,1,0]\\n\\n`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int sum{};\\n        int k = 1;\\n        vector<int>ans{};\\n        int l = digits.size()-1;\\n        for(int i = l;i>=0;i--){\\n            sum = sum + digits[i]*k;\\n            k *=10;\\n        }\\n        sum ++;\\n        while(sum != 0){\\n            int ele = sum %10;\\n            ans.push_back(ele);\\n            sum /=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "premkumarsingh410",
                        "content": "when you do k*=10 the signed integer overflows. However if u use long long data type it should pass the given test case but will fail after 60th testcase."
                    },
                    {
                        "username": "_Mohamed_Atef",
                        "content": "amazing problem I love it thanks\\' LeetCode"
                    },
                    {
                        "username": "vik24k",
                        "content": "one-line answer:\n\n` def plusOne(self, digits: List[int]) -> List[int]: \n        return [int(num) for num in str(int(\"\".join([str(num) for num in digits]))+1)]`"
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int[] plusOne(int[] digits) {\\n        int i = digits.length;\\n        int n=0;\\n        int arr1[];\\n        int s=0;\\n        for(int j=0;j<i;j++){\\n            s=s*10 + digits[j];\\n        }\\n        int k=s+1;\\n        int t=k;\\n        while(k!=0){\\n             n++;\\n             k=k/10;\\n         }\\n        //  int arr1[];\\n        for(int h=0;h<n;h++){\\n            int q=t%10;\\n            arr1[h]=q;\\n            t=t/10;\\n        }\\n        return arr1;\\n    }\\n}\\n`your inline code...your inline code...`\\n\\nCan somebody explain the error in this solution"
                    },
                    {
                        "username": "abhisheksingh789",
                        "content": "int has some limitations"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Why does an O(n^2) solution where I use insert method for inserting at zeroth index beats 100% of cpp solutions? This question may have weak testcases."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Here\\'s the code for those interested, please let me know if I\\'m missing something.\\n```\\n    vector<int> plusOne(vector<int>& digits) {\\n        vector<int> res;\\n        int c = 1;\\n\\n        for(int i = digits.size()-1 ; i >= 0 ; i--){\\n            int s = digits[i]+c;\\n\\n            c = s/10;\\n\\n            res.insert(res.begin(),s%10);\\n        }\\n\\n        if(c!=0) res.insert(res.begin(),c);\\n\\n        return res;\\n    }\\n```"
                    },
                    {
                        "username": "dblum49",
                        "content": "This question is the perfect problem for introducing how to perform simple operations on numbers that are too large to store. I just learned about this and am surprised to see it so soon. "
                    },
                    {
                        "username": "aggarwalmukul96",
                        "content": "signed integer overflow how to solve this error:(\\ntest case [7,2,8,5,0,9,1,2,9,5,3,6,6,7,3,2,8,4,3,7,9,5,7,7,4,7,4,9,4,7,0,1,1,1,7,4,0,0,6]\\nused long,long long data type\\n"
                    }
                ]
            },
            {
                "id": 1722518,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1721161,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1720584,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1718041,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1716171,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1715296,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1707595,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1706793,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1704307,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1701915,
                "content": [
                    {
                        "username": "karandinakaran01",
                        "content": " `class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        if(digits[-1]!=9){\n            digits[-1]++;\n            \n        }\n        else{\n            for(int i=digits.size()-1; i>=0; i--){\n                if(digits[i]==9){digits[i]=0;}\n                else{digits[i]++;\n                break;}\n\n            }\n        \n        }\n        return digits;\n    }\n};`\n\n\nHow is this throwing a runtime error?"
                    },
                    {
                        "username": "GSS2025",
                        "content": " ```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int s = digits.size();\\n        for (int i = s-1; i >= 0; i--){\\n            if (digits[i] < 9){\\n                digits[i] += 1;\\n                return digits;\\n            }\\n            if (digits[i] == 9){\\n                digits[i] = 0;\\n                digits[i-1] += 1;\\n                if (digits[0] == 9){\\n                    digits.insert(digits.begin(), 1);\\n                    digits[1] = 0;\\n                }\\n                return digits;\\n            }\\n        }\\n            \\n        return digits;\\n    }\\n};\\n```\\nwhen my first for is:  for (int i = s-1; i > 0; i--)\\nthe code runs, but any digits coming in where it starts with 9 and it needs to be incremented does not work. ex [9] stays at 9.  i was thinking its not accessing that element since its index is 0, so i changed the for loop to  for (int i = s-1; i > 0; i--)\\nbut that gives me an offset error. whats the reason for this? and what can i do to fix it? thank you for the help!"
                    },
                    {
                        "username": "ameysati",
                        "content": "What is the problem with my code?\\n\\n#include <string>\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) \\n    {\\n        int l = digits.size()-1;\\n        if(digits[l-1]==9)\\n        {\\n            digits[l-1]=digits[l-1]/10;\\n            digits.push_back(0);\\n        }\\n        else\\n            digits[l-1]++;\\n\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "ameysati",
                        "content": "Or i may be understanding the question wrong?\\n"
                    },
                    {
                        "username": "Sandeep4769",
                        "content": "`   vector<int> plusOne(vector<int>& digits) {\n        int m = digits.size()-1;\n        int n=digits[m]+1;\n        vector<int> num;\n        int carry=0;\n        while(m!=0){\n          num.push_back(n%10);\n          carry=n/10;\n          n=digits[m-1]+carry;\n          m--;\n        }\n        num.push_back(n%10);\n        if(n>=10) num.push_back(n/10);\n        reverse(num.begin(), num.end());\n         return num;\n        }  `\n  "
                    },
                    {
                        "username": "poweracoon",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n     x = List\\n     new_list = []\\n     number = \"\"\\n    for item in x:\\n        number = str(item) +number\\n    real_number = int(number)\\n    new_number = real_number +1\\n    for digits in new_number:\\n        new_list.append(digits)\\n    return new_list\\n\\nTHIS IS MY CODE AND it IS NOT WORKING. I THINK THERE IS NO FAULT IN IT. WHY IS IT NOT WORKING?\\n"
                    },
                    {
                        "username": "omerkayaliel",
                        "content": "why am I getting a runtime error. Without \"digits[n-1]++;\" it doesn\\'t give any errors.\\n\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits)\\n    {\\n        int n = digits.size();\\n\\n        digits[n-1]++;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(digits[i]==10)\\n            {\\n                digits[i-1]++;\\n                digits[i]=0;\\n            }\\n            else\\n                break;\\n        }\\n        return digits;\\n    }\\n};"
                    },
                    {
                        "username": "krpto-affan",
                        "content": "class Solution(object):\\n    def plusOne(self, digits):\\n        new = []\\n        a = \"\"\\n        for i in digits:\\n            a += str(i)\\n        a = int(a)+1\\n        for i in str(a):\\n            new.append(i)\\n        print(new)\\n        return new\\n"
                    },
                    {
                        "username": "tongalexhe",
                        "content": "`class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n = digits.size()-1;\\n\\n        while(n>=0)\\n        {\\n            \\n            digits[n] = (digits[n] +1)%10;\\n            //cout<<digits[i]<<endl;\\n            if(digits[n] != 0)\\n                return digits;\\n            else\\n                n--;\\n\\n        }\\n        cout<<n<<endl;\\n        vector<int> v(digits.size()+1,0);\\n        v[0] = 1;\\n        return v;\\n    }\\n};`"
                    },
                    {
                        "username": "Anjoshannon",
                        "content": "Why is does this not work?\\n\\n `function plusOne(digits: number[]): number[] {\\n    let a = Array.from(String(Math.round(Number(digits.join().replace(/,/g, \\'\\')) + 1)), num => Number(num))\\n\\n    return a\\n};`\\n\\nat a point the numbers on the end just return as zeros and I dont know why.\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "for C++ solution CHECKOUT THIS LINK\\nLEAVE A STAR  if you find it helpful.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/66_plus_one.cpp\\n\\n"
                    }
                ]
            },
            {
                "id": 1701808,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1699010,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1697006,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1690646,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1685423,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1685414,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1684055,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1682619,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1681229,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            },
            {
                "id": 1676120,
                "content": [
                    {
                        "username": "Naved2019khan",
                        "content": " `  \\n\\nwhile(i>=0 && digits[i]==9)\\n       {\\n           digits[i]=0;\\n           i--;\\n       }\\n       int m=n;\\n       if(digits[i+1]==0 && i<0)\\n       {\\n           ans.push_back(1);\\n           m+=1;\\n       }\\n       else{\\n           digits[i]+=1;\\n       }\\n       for(int i=0;i<n;i++)\\n           {\\n               ans.push_back(digits[i]);\\n           }\\nreturn ans;\\n\\n ` \\n\\nwhy this is\\'nt working but it work on other ide like interview bit, show error address Sanitizer \\n "
                    },
                    {
                        "username": "saifie1",
                        "content": " `var plusOne = function(arr) {\n       let i=arr.length-1\n    while(arr[i]===9){\n        arr[i]=0\n        i--\n    }\n    if(i>=0){\n       arr[i]+=1\n    }\n    else{\n        arr.unshift(1)\n    }\n    return arr\n};`"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "\\nclass Solution:\\n\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum = int(\"\".join(map(str,digits))) + int(1)\\n        return [int(i) for i in str(sum)]"
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        sum=\"\"\\n        for i in range(len(digits)):\\n            sum+=str(digits[i])\\n        a=int(sum)+1\\n        b=[]\\n        for i in str(a):\\n            b.append(int(i))\\n        return b"
                    },
                    {
                        "username": "timblake17",
                        "content": "Was this just a test for me to google that parseInt doesn\\'t work on numbers with more that16 digits?"
                    },
                    {
                        "username": "anubhavnegi54",
                        "content": "you can work with BigInteger "
                    },
                    {
                        "username": "GreidO",
                        "content": " `class Solution:\\n\\tdef plusOne(self, digits: List[int]) -> list[int]:\\n\\t\\treturn [int(number) for number in str(int(\\'\\'.join([str(number) for number in digits])) + 1)]`"
                    },
                    {
                        "username": "rickx_x",
                        "content": "class Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        if(digits[digits.size()-1]==9){\\n            int count =0;\\n            int  i = digits.size()-1;\\n            while(digits[i]==9){\\n                digits.pop_back();\\n                count++;\\n                i--;\\n            }\\n            digits.emplace_back(1);\\n            while(count--){\\n                digits.emplace_back(0);\\n            }\\n        }\\n        else{\\n            digits[digits.size()-1]+=1;\\n        }\\n        return digits;\\n    }\\n};\\n\\nwhy isn\\'t this working ?"
                    },
                    {
                        "username": "aizardar",
                        "content": "Three steps to solve this problem:\\n1. get the number from the digits list\\n2. increment the number, and\\n3. Again get the digits of the number into a list. "
                    },
                    {
                        "username": "kasamravi03",
                        "content": "if(len(digits)!=1):\\n            if(digits[len(digits)-1]!=9):\\n                digits[len(digits)-1]+=1\\n            else:\\n                digits[len(digits)-1]=0\\n                digits[len(digits)-2]+=1\\n        else:\\n            if(digits[len(digits)-1]==9):\\n                digits.append(0)\\n                digits[len(digits)-2]=1\\n            else:\\n                digits[len(digits)-1]+=1\\n        return(digits)\\ncan anybody help me out"
                    },
                    {
                        "username": "omkar1029",
                        "content": "`public int[] PlusOne(int[] digits) {\\n        \\n        int[] array = new int[NewArrayLength(digits)];\\n        \\n        int i = digits.Length - 1;\\n        int j = array.Length - 1;\\n        \\n        while(digits[i] == 9){\\n            array[j] = 0;\\n            i--;\\n            j--;\\n        }\\n\\n        if(i >= 0){\\n            array[j] = digits[i] + 1;\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i >= 0){\\n            array[j] = digits[i];\\n            i--;\\n            j--;\\n        }\\n\\n        return array;\\n    }\\n\\n    int NewArrayLength(int[] digits){\\n        for(int i = 0; i < digits.Length; i++){\\n            if(digits[i] != 9) return digits.Length;\\n        }\\n        return digits.Length + 1;\\n    }`\\n\\nwhy is this giving `System.IndexOutOfRangeException`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Fraction to Recurring Decimal",
        "question_content": "<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 51106,
                "title": "my-clean-java-solution",
                "content": "The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.\\n\\nUse HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part.\\n\\nPlease comment if you see something wrong or can be improved. Cheers!\\n\\n    public class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }\\n            StringBuilder res = new StringBuilder();\\n            // \"+\" or \"-\"\\n            res.append(((numerator > 0) ^ (denominator > 0)) ? \"-\" : \"\");\\n            long num = Math.abs((long)numerator);\\n            long den = Math.abs((long)denominator);\\n            \\n            // integral part\\n            res.append(num / den);\\n            num %= den;\\n            if (num == 0) {\\n                return res.toString();\\n            }\\n            \\n            // fractional part\\n            res.append(\".\");\\n            HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n            map.put(num, res.length());\\n            while (num != 0) {\\n                num *= 10;\\n                res.append(num / den);\\n                num %= den;\\n                if (map.containsKey(num)) {\\n                    int index = map.get(num);\\n                    res.insert(index, \"(\");\\n                    res.append(\")\");\\n                    break;\\n                }\\n                else {\\n                    map.put(num, res.length());\\n                }\\n            }\\n            return res.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String fractionToDecimal(int numerator, int denominator) {\\n            if (numerator == 0) {\\n                return \"0\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51109,
                "title": "accepted-cpp-solution-with-explainations",
                "content": "    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    // upgraded parameter types\\n    string fractionToDecimal(int64_t n, int64_t d) {\\n        // zero numerator\\n        if (n == 0) return \"0\";\\n    \\n        string res;\\n        // determine the sign\\n        if (n < 0 ^ d < 0) res += '-';\\n    \\n        // remove sign of operands\\n        n = abs(n), d = abs(d);\\n    \\n        // append integral part\\n        res += to_string(n / d);\\n    \\n        // in case no fractional part\\n        if (n % d == 0) return res;\\n    \\n        res += '.';\\n    \\n        unordered_map<int, int> map;\\n    \\n        // simulate the division process\\n        for (int64_t r = n % d; r; r %= d) {\\n    \\n            // meet a known remainder\\n            // so we reach the end of the repeating part\\n            if (map.count(r) > 0) {\\n                res.insert(map[r], 1, '(');\\n                res += ')';\\n                break;\\n            }\\n    \\n            // the remainder is first seen\\n            // remember the current position for it\\n            map[r] = res.size();\\n    \\n            r *= 10;\\n    \\n            // append the quotient digit\\n            res += to_string(r / d);\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51160,
                "title": "c-unordered-map",
                "content": "For the decimal part to recur, **the remainder should recur**. So we maintain the remainders we have seen. Once we see an existing remainder, we have reached the end of the recurring part (enclose it with a `)`). Moreover, insert the `(` to the starting index of the recurring part by maintaining a mapping from each remainder to the index of the corresponding digit and using it to retrieve the starting index.\\n\\nFor those without fractional parts or with non-recursive fractional points, we may find them out by `%` or zero remainder. Some other problems that need to be considered include the sign and overflow (`-2147483648 / -1`).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) {\\n            return \"0\";\\n        }\\n        string ans;\\n        if (numerator > 0 ^ denominator > 0) {\\n            ans += \\'-\\';\\n        }\\n        long n = labs(numerator), d = labs(denominator), r = n % d;\\n        ans += to_string(n / d);\\n        if (!r) {\\n            return ans;\\n        }\\n        ans += \\'.\\';\\n        unordered_map<long, int> rs;\\n        while (r) {\\n            if (rs.find(r) != rs.end()) {\\n                ans.insert(rs[r], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            rs[r] = ans.size();\\n            r *= 10;\\n            ans += to_string(r / d);\\n            r %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) {\\n            return \"0\";\\n        }\\n        string ans;\\n        if (numerator > 0 ^ denominator > 0) {\\n            ans += \\'-\\';\\n        }\\n        long n = labs(numerator), d = labs(denominator), r = n % d;\\n        ans += to_string(n / d);\\n        if (!r) {\\n            return ans;\\n        }\\n        ans += \\'.\\';\\n        unordered_map<long, int> rs;\\n        while (r) {\\n            if (rs.find(r) != rs.end()) {\\n                ans.insert(rs[r], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            rs[r] = ans.size();\\n            r *= 10;\\n            ans += to_string(r / d);\\n            r %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51110,
                "title": "do-not-use-python-as-cpp-here-s-a-short-version-python-code",
                "content": "Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow",
                "solutionTags": [
                    "Python"
                ],
                "code": "Though python is slow, It is easy to write\\n\\n    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = '-' if numerator*denominator < 0 else ''\\n        result = [sign+str(n), '.']\\n        stack = []\\n        while remainder not in stack:\\n            stack.append(remainder)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            result.append(str(n))\\n\\n        idx = stack.index(remainder)\\n        result.insert(idx+2, '(')\\n        result.append(')')\\n        return ''.join(result).replace('(0)', '').rstrip('.')\\n\\nand there's no overflow",
                "codeTag": "Java"
            },
            {
                "id": 51187,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51140,
                "title": "short-java-solution",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }",
                "solutionTags": [],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        StringBuilder result = new StringBuilder();\\n        String sign = (numerator < 0 == denominator < 0 || numerator == 0) ? \"\" : \"-\";\\n        long num = Math.abs((long) numerator);\\n        long den = Math.abs((long) denominator);\\n        result.append(sign);\\n        result.append(num / den);\\n        long remainder = num % den;\\n        if (remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        HashMap<Long, Integer> hashMap = new HashMap<Long, Integer>();\\n        while (!hashMap.containsKey(remainder)) {\\n            hashMap.put(remainder, result.length());\\n            result.append(10 * remainder / den);\\n            remainder = 10 * remainder % den;\\n        }\\n        int index = hashMap.get(remainder);\\n        result.insert(index, \"(\");\\n        result.append(\")\");\\n        return result.toString().replace(\"(0)\", \"\");\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1669777,
                "title": "accepted-simple-solution-with-step-by-step-detailed-explaination",
                "content": "So we can divide this question in three parts :\\n1.\\tDivision with its own multiple for eg. 8 / 4 = 2\\n2.\\tDivision without repeating numbers after decimal for eg. 41 / 2 = 20.5\\n3.\\tDivision with repeating numbers after decimal for eg. 14 / 3 = 4.(6) or 47 / 18 = 2.6(1)\\nNote : Here the repeating part is in bracket.\\n\\nFor **1st Part** we can normally divide the numbers and add it to the ans string and return if the remainder is 0.\\n\\n```\\n//Code: \\nint q = num / den;\\nint r = num % den;\\nans += q;\\nif(r == 0) return ans;\\n```\\n\\nFor **2nd part** we need to add a \\u201C.\\u201D if remainder is not zero and then make the remainder 10 times everytime and append the quotient to the ans string.\\n```\\n//Code:\\nwhile(r != 0)\\n\\tr *= 10;\\n\\tq = r / den;\\n\\tr = r % den;\\n\\tans += q;\\n```\\n\\nFor the **3rd part** we need to use and unordered_map so that we can store the the position from where the repeating of number starts in front of the remainder. If the remainder is already in the map then we insert the \\u201C(\\u201D opening bracket at the position of that rem and lastly append a \\u201C)\\u201D closing bracket and break out of the loop and return the ans.\\n```\\n//Code :\\nunordered_map<int, int> mp;\\nwhile(r != 0)\\n\\tif(mp(r) is in map)\\n\\t\\tint pos = mp[r];\\n\\t\\tans.insert(pos, \"(\");\\n\\t\\tans += \\')\\';\\n\\t\\tbreak;\\n\\telse\\n\\t\\tmp[r] = ans.length();\\n\\t\\tr *= 10;\\n\\t\\tq = r / den;\\n\\t\\tr = r % den;\\n\\t\\tans += q;\\n```\\n\\nNow it will give runtime error for cases like -1 / -2147483648 so we need to change the int to long\\n```\\nlong num = labs(numerator), den = labs(denominator);\\nlong q = num / den;\\nlong r = num % den;\\n```\\nand \\n```\\nunordered_map<long, int> mp;\\n```\\nWe need to handle the case where there are negative numbers. So if numerator is negative and denominator is positive or numerator is positive and denominator is negative we need to add a \\u201C-\\u201C negative symbol in the ans.\\n```\\nif (numerator > 0 ^ denominator > 0) \\n\\tans += \\'-\\';\\n```\\n\\n**Final Code :**\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(!numerator) return \"0\";\\n        string ans = \"\";\\n        if (numerator > 0 ^ denominator > 0) ans += \\'-\\';\\n        long num = labs(numerator), den = labs(denominator);\\n        long q = num / den;\\n        long r = num % den;\\n        ans += to_string(q);\\n        \\n        if(r == 0) return ans;\\n        \\n        ans += \\'.\\';\\n        unordered_map<long, int> mp;\\n        while(r != 0){\\n            if(mp.find(r) != mp.end()){\\n                int pos = mp[r];\\n                ans.insert(pos, \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                mp[r] = ans.length();\\n                r *= 10;\\n                q = r / den;\\n                r = r % den;\\n                ans += to_string(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n//Code: \\nint q = num / den;\\nint r = num % den;\\nans += q;\\nif(r == 0) return ans;\\n```\n```\\n//Code:\\nwhile(r != 0)\\n\\tr *= 10;\\n\\tq = r / den;\\n\\tr = r % den;\\n\\tans += q;\\n```\n```\\n//Code :\\nunordered_map<int, int> mp;\\nwhile(r != 0)\\n\\tif(mp(r) is in map)\\n\\t\\tint pos = mp[r];\\n\\t\\tans.insert(pos, \"(\");\\n\\t\\tans += \\')\\';\\n\\t\\tbreak;\\n\\telse\\n\\t\\tmp[r] = ans.length();\\n\\t\\tr *= 10;\\n\\t\\tq = r / den;\\n\\t\\tr = r % den;\\n\\t\\tans += q;\\n```\n```\\nlong num = labs(numerator), den = labs(denominator);\\nlong q = num / den;\\nlong r = num % den;\\n```\n```\\nunordered_map<long, int> mp;\\n```\n```\\nif (numerator > 0 ^ denominator > 0) \\n\\tans += \\'-\\';\\n```\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(!numerator) return \"0\";\\n        string ans = \"\";\\n        if (numerator > 0 ^ denominator > 0) ans += \\'-\\';\\n        long num = labs(numerator), den = labs(denominator);\\n        long q = num / den;\\n        long r = num % den;\\n        ans += to_string(q);\\n        \\n        if(r == 0) return ans;\\n        \\n        ans += \\'.\\';\\n        unordered_map<long, int> mp;\\n        while(r != 0){\\n            if(mp.find(r) != mp.end()){\\n                int pos = mp[r];\\n                ans.insert(pos, \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                mp[r] = ans.length();\\n                r *= 10;\\n                q = r / den;\\n                r = r % den;\\n                ans += to_string(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51107,
                "title": "accepted-clean-java-solution",
                "content": "I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I don't understand why so many people tends to write \"short\" java solutions over \"clear\" java solution when performance stays the same.\\nIn order to be a good teammate, one should always write clean code instead of hacky code if performance stays the same.\\n\\n        \\n      public String fractionToDecimal(int numerator, int denominator) {\\n            boolean isNegative = (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) ? true : false;\\n            long numeratorL = Math.abs((long) numerator);\\n            long denominatorL = Math.abs((long) denominator);\\n            Map<Long, Integer> previousRemains = new HashMap<Long, Integer>();\\n            StringBuilder sb = new StringBuilder();\\n            long quotian = numeratorL / denominatorL;\\n            sb.append(quotian);\\n            \\n            numeratorL %= denominatorL;\\n        \\n            if (numeratorL != 0) {\\n                sb.append(\".\");\\n            }\\n            \\n            int quotianIndex = 0;\\n            while (numeratorL != 0) {\\n                numeratorL *= 10;\\n                quotian = Math.abs(numeratorL / denominatorL);\\n                if (!previousRemains.containsKey(numeratorL)) {\\n                    sb.append(quotian);\\n                    previousRemains.put(numeratorL, quotianIndex++);\\n                } else {\\n                    int firstIndex = 1 + previousRemains.get(numeratorL) + sb.indexOf(\".\");\\n                    sb.insert(firstIndex, '(');\\n                    sb.append(\")\");\\n                    break;\\n                }\\n                numeratorL %= denominatorL;\\n            }\\n            \\n            if (isNegative) {\\n                sb.insert(0, \"-\");\\n            }\\n            return sb.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 51114,
                "title": "python-solution",
                "content": "    class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}\\n        while numerator!=0:\\n            if numerator not in table.keys():\\n                table[numerator]=i\\n            else:\\n                i=table[numerator]\\n                res=res[:i]+\"(\"+res[i:]+\")\"\\n                return res\\n            numerator=numerator*10\\n            res+=str(numerator/denominator)\\n            numerator%=denominator\\n            i+=1\\n        return res\\n\\nIdea is to put every remainder into the hash table as a key, and the current length of the result string as the value. When the same remainder shows again, it's circulating from the index of the value in the table.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a string\\n    def fractionToDecimal(self, numerator, denominator):\\n        res=\"\"\\n        if numerator/denominator<0:\\n            res+=\"-\"\\n        if numerator%denominator==0:\\n            return str(numerator/denominator)\\n        numerator=abs(numerator)\\n        denominator=abs(denominator)\\n        res+=str(numerator/denominator)\\n        res+=\".\"\\n        numerator%=denominator\\n        i=len(res)\\n        table={}",
                "codeTag": "Java"
            },
            {
                "id": 180004,
                "title": "python-4-lines-32ms-beats-100-with-explanation",
                "content": "LOLOLOL:\\n```python\\ndef fractionToDecimal(self, n, d): # 32ms, beats 100%\\n    if n % d == 0: return str(n // d)\\n    p, q, r, s, m = abs(n), abs(d), abs(n) % abs(d), \\'\\', {}\\n    while r and r not in m: m[r], r, s = len(s), r * 10 % q, s + str(r * 10 // q)\\n    return (\\'\\' if (n > 0) == (d > 0) else \\'-\\') + str(p // q) + \\'.\\' + (s[:m[r]] + \\'(\\' + s[m[r]:] + \\')\\' if r else s)\\n```\\n---\\n\\n### Explanation\\nMy original solution:\\n```python\\ndef fractionToDecimal(self, numerator, denominator):\\n    if numerator % denominator == 0: return str(numerator // denominator)\\n    p, q = map(abs, (numerator, denominator))\\n    prefix = (\\'\\' if (numerator > 0) == (denominator > 0) else \\'-\\') + str(p // q) + \\'.\\' # everything before the decimal point\\n    suffix = \\'\\' # everything after the decimal point\\n    remainder = p % q\\n    index = {}\\n    while remainder not in index: # search for recurrence\\n        index[remainder] = len(suffix)\\n        suffix += str(remainder * 10 // q)\\n        remainder = remainder * 10 % q\\n        if remainder == 0: return prefix + suffix # no recurring decimal\\n    return prefix + suffix[:index[remainder]] + \\'(\\' + suffix[index[remainder]:] + \\')\\'\\n```\\nThis is easy to understand by following an example. Consider the fraction `611/4950 == 0.12(34)`. If you work out the division, you\\'ll see that the remainders are `611`, `1160`, `1700`, `2150`, `1700`, `2150`, etc.\\n```\\n      0.123434...\\n    +---------\\n4950|611\\n       0\\n     ---------\\n     6110      <- remainder is 611\\n     4950\\n     ---------\\n     11600     <- remainder is 1160\\n      9900\\n     ---------\\n      17000    <- remainder is 1700\\n      14850\\n     ---------\\n       21500   <- remainder is 2150\\n       19800\\n     ---------\\n        17000  <- remainder is 1700\\n        14850\\n     ---------\\n         21500 <- remainder is 2150\\n         19800\\n     ---------\\n          1700 <- remainder is 1700\\n           ...\\n```\\nSo we just have to keep track of the remainders. The moment we see a repeated one (`1700` in this example), we stop and ask \"when was the first time I saw this remainder?\" For this particular example, the answer is \"when I was trying to find the `3rd` decimal place\". Therefore, the recurrence starts from the `3rd` decimal place. That\\'s it.",
                "solutionTags": [],
                "code": "```python\\ndef fractionToDecimal(self, n, d): # 32ms, beats 100%\\n    if n % d == 0: return str(n // d)\\n    p, q, r, s, m = abs(n), abs(d), abs(n) % abs(d), \\'\\', {}\\n    while r and r not in m: m[r], r, s = len(s), r * 10 % q, s + str(r * 10 // q)\\n    return (\\'\\' if (n > 0) == (d > 0) else \\'-\\') + str(p // q) + \\'.\\' + (s[:m[r]] + \\'(\\' + s[m[r]:] + \\')\\' if r else s)\\n```\n```python\\ndef fractionToDecimal(self, numerator, denominator):\\n    if numerator % denominator == 0: return str(numerator // denominator)\\n    p, q = map(abs, (numerator, denominator))\\n    prefix = (\\'\\' if (numerator > 0) == (denominator > 0) else \\'-\\') + str(p // q) + \\'.\\' # everything before the decimal point\\n    suffix = \\'\\' # everything after the decimal point\\n    remainder = p % q\\n    index = {}\\n    while remainder not in index: # search for recurrence\\n        index[remainder] = len(suffix)\\n        suffix += str(remainder * 10 // q)\\n        remainder = remainder * 10 % q\\n        if remainder == 0: return prefix + suffix # no recurring decimal\\n    return prefix + suffix[:index[remainder]] + \\'(\\' + suffix[index[remainder]:] + \\')\\'\\n```\n```\\n      0.123434...\\n    +---------\\n4950|611\\n       0\\n     ---------\\n     6110      <- remainder is 611\\n     4950\\n     ---------\\n     11600     <- remainder is 1160\\n      9900\\n     ---------\\n      17000    <- remainder is 1700\\n      14850\\n     ---------\\n       21500   <- remainder is 2150\\n       19800\\n     ---------\\n        17000  <- remainder is 1700\\n        14850\\n     ---------\\n         21500 <- remainder is 2150\\n         19800\\n     ---------\\n          1700 <- remainder is 1700\\n           ...\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 51128,
                "title": "simple-and-short-solution-in-java",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        if (denominator == 0) return \"\";\\n        StringBuilder str = new StringBuilder();\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        if (numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) {\\n            str.append('-');\\n        }\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long n = num/den;\\n        long reminder = num % den;\\n        str.append(n);\\n        if (reminder == 0) return str.toString();\\n        else str.append('.');\\n        while(!map.containsKey(reminder)) {\\n            map.put(reminder,str.length());\\n            n = reminder*10/den;\\n            reminder = reminder*10%den;\\n            if (reminder != 0 || reminder == 0 && !map.containsKey(reminder)) {\\n                str.append(n);\\n            }\\n        }\\n        if (reminder != 0) {\\n            str.insert(map.get(reminder),\"(\");\\n            str.append(')');            \\n        }\\n        return str.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 457990,
                "title": "java-a-simple-solution-with-explanation",
                "content": "```\\npublic String fractionToDecimal(int num, int den) {\\n        \\n\\tif(num==0) return \"0\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// Negative sign is appended if either of num or den is negative\\n\\tres.append((num > 0) ^ (den > 0) ? \"-\" : \"\");\\n\\n\\t// Get rid of signs and convert to long to prevent overflow\\n\\tlong n = Math.abs((long) num);\\n\\tlong d = Math.abs((long) den);\\n\\n\\t// Append the integral part\\n\\tres.append(n/d);\\n\\n\\tn %= d;\\n\\tif(n==0) return res.toString();             // Cause there is no fraction\\n\\n\\t// Append the fraction\\n\\tres.append(\".\");\\n\\tHashMap<Long, Integer> hm = new HashMap();  // Map will store remainders and their positions\\n\\thm.put(n, res.length());\\n\\twhile(n!=0) {                               // We will break in case of recurring fraction\\n\\t\\tn *= 10;\\n\\t\\tres.append(n/d);\\n\\t\\tn %= d;\\n\\n\\t\\tInteger remainderIndex = hm.get(n);\\n\\t\\tif(remainderIndex!=null) {              // We have a recurrence\\n\\t\\t\\tres.insert(remainderIndex, \"(\");\\n\\t\\t\\tres.append(\")\");\\n\\t\\t\\treturn res.toString();\\n\\t\\t} else {\\n\\t\\t\\thm.put(n, res.length());            // Add for future checks\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String fractionToDecimal(int num, int den) {\\n        \\n\\tif(num==0) return \"0\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// Negative sign is appended if either of num or den is negative\\n\\tres.append((num > 0) ^ (den > 0) ? \"-\" : \"\");\\n\\n\\t// Get rid of signs and convert to long to prevent overflow\\n\\tlong n = Math.abs((long) num);\\n\\tlong d = Math.abs((long) den);\\n\\n\\t// Append the integral part\\n\\tres.append(n/d);\\n\\n\\tn %= d;\\n\\tif(n==0) return res.toString();             // Cause there is no fraction\\n\\n\\t// Append the fraction\\n\\tres.append(\".\");\\n\\tHashMap<Long, Integer> hm = new HashMap();  // Map will store remainders and their positions\\n\\thm.put(n, res.length());\\n\\twhile(n!=0) {                               // We will break in case of recurring fraction\\n\\t\\tn *= 10;\\n\\t\\tres.append(n/d);\\n\\t\\tn %= d;\\n\\n\\t\\tInteger remainderIndex = hm.get(n);\\n\\t\\tif(remainderIndex!=null) {              // We have a recurrence\\n\\t\\t\\tres.insert(remainderIndex, \"(\");\\n\\t\\t\\tres.append(\")\");\\n\\t\\t\\treturn res.toString();\\n\\t\\t} else {\\n\\t\\t\\thm.put(n, res.length());            // Add for future checks\\n\\t\\t}\\n\\t}\\n\\treturn res.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51186,
                "title": "fast-and-concise-python-solution-using-dictionary",
                "content": "    def fractionToDecimal(self, numerator, denominator):\\n        sign = '-' if numerator * denominator < 0 else ''\\n        head, remainder = divmod(abs(numerator), abs(denominator))\\n        tail, seen = '', {}\\n        while remainder != 0:\\n            if remainder in seen:\\n                tail = tail[: seen[remainder]] + '(' + tail[seen[remainder]:] + ')'\\n                break\\n            seen[remainder] = len(tail)\\n            digit, remainder = divmod( remainder*10, abs(denominator) )\\n            tail+=str(digit)\\n        return sign + str(head) + (tail and '.' + tail)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def fractionToDecimal(self, numerator, denominator):\\n        sign = '-' if numerator * denominator < 0 else ''\\n        head, remainder = divmod(abs(numerator), abs(denominator))\\n        tail, seen = '', {}\\n        while remainder != 0:\\n            if remainder in seen:\\n                tail = tail[: seen[remainder]] + '(' + tail[seen[remainder]:] + ')'\\n                break\\n            seen[remainder] = len(tail)\\n            digit, remainder = divmod( remainder*10, abs(denominator) )\\n            tail+=str(digit)\\n        return sign + str(head) + (tail and '.' + tail)",
                "codeTag": "Python3"
            },
            {
                "id": 157398,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0: \\n            return \\'0\\'\\n        neg = (numerator < 0) ^ (denominator < 0)\\n        w,r = divmod(abs(numerator),abs(denominator))\\n        s = str(w)\\n        if neg:\\n            s = \"-\" + s \\n        if r:\\n            s += \\'.\\'\\n        i = len(s)\\n        nums = { r: i }\\n        while r:\\n            q,r = divmod(r * 10, abs(denominator))\\n            s += str(q)\\n            if r in nums:\\n                s = s[:nums[r]] + \\'(\\' + s[nums[r]:] + \\')\\' \\n                return s\\n            i += 1\\n            nums[r] = i\\n        return s",
                "solutionTags": [],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator == 0: \\n            return \\'0\\'\\n        neg = (numerator < 0) ^ (denominator < 0)\\n        w,r = divmod(abs(numerator),abs(denominator))\\n        s = str(w)\\n        if neg:\\n            s = \"-\" + s \\n        if r:\\n            s += \\'.\\'\\n        i = len(s)\\n        nums = { r: i }",
                "codeTag": "Java"
            },
            {
                "id": 2549071,
                "title": "c-handling-edge-cases-easily-with-full-explanation-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n     \\n        string ans = \"\";\\n       \\n        \\n        // Handling Negative Case\\n        if((n<0 && d>0) || (n>0 && d<0 ))\\n            ans+= \\'-\\';\\n        \\n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\\n        // in Long long datatype ans remainder as well\\n        \\n        long long a = abs(n);\\n        long long b = abs(d);\\n        \\n        // Calculation Integral Part Of Answer\\n        long long num = abs(a/b);\\n        \\n        // Storing that to our ans string\\n        ans += to_string(num);\\n        \\n        // Calculate Remainder\\n        long long rem = abs(a%b);\\n        \\n        \\n        // IF remainder is zero , there wont be decimal part so return ans\\n        if(rem == 0)\\n            return ans;\\n        \\n        ans.push_back(\\'.\\');\\n        \\n        // Now We will calculate decimal part\\n        // we will store mapping of remainder with its appearing index \\n        // ex : 1/10 => rem = 1 its index will be 0\\n        \\n        string dec = \"\";\\n        unordered_map<int, int> mp;\\n       \\n        \\n        while(rem)\\n        {\\n            // iF We come across any remainder which is present in mapping \\n            // it means the recurring part start from that remainder and we will get its index \\n            // and process the result\\n            if(mp.find(rem) != mp.end())\\n            {\\n                int index  = mp[rem];\\n                string recurring = dec.substr(index);\\n                dec.erase(index);\\n                dec += \\'(\\' + recurring + \\')\\';\\n                break;\\n            }\\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\\n            else\\n            {\\n                mp[rem] = dec.size();\\n                dec += to_string(rem*10/b);\\n                rem = (rem*10)%b;\\n            }\\n        }\\n        \\n        ans += dec;\\n        return ans;\\n        \\n        \\n        // Pls Upvote If You Like It\\n    }\\n};\\n\\n// Some Good Test Cases\\n// 4\\n// 333\\n\\n// -1\\n// -2147483648\\n\\n// 1\\n// 17\\n\\n// 45\\n// 499\\n\\n// -2147483648\\n// -1\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n     \\n        string ans = \"\";\\n       \\n        \\n        // Handling Negative Case\\n        if((n<0 && d>0) || (n>0 && d<0 ))\\n            ans+= \\'-\\';\\n        \\n        // To avoid Edge Cases Mentioned Below store Numerator and Denominator\\n        // in Long long datatype ans remainder as well\\n        \\n        long long a = abs(n);\\n        long long b = abs(d);\\n        \\n        // Calculation Integral Part Of Answer\\n        long long num = abs(a/b);\\n        \\n        // Storing that to our ans string\\n        ans += to_string(num);\\n        \\n        // Calculate Remainder\\n        long long rem = abs(a%b);\\n        \\n        \\n        // IF remainder is zero , there wont be decimal part so return ans\\n        if(rem == 0)\\n            return ans;\\n        \\n        ans.push_back(\\'.\\');\\n        \\n        // Now We will calculate decimal part\\n        // we will store mapping of remainder with its appearing index \\n        // ex : 1/10 => rem = 1 its index will be 0\\n        \\n        string dec = \"\";\\n        unordered_map<int, int> mp;\\n       \\n        \\n        while(rem)\\n        {\\n            // iF We come across any remainder which is present in mapping \\n            // it means the recurring part start from that remainder and we will get its index \\n            // and process the result\\n            if(mp.find(rem) != mp.end())\\n            {\\n                int index  = mp[rem];\\n                string recurring = dec.substr(index);\\n                dec.erase(index);\\n                dec += \\'(\\' + recurring + \\')\\';\\n                break;\\n            }\\n            // If Remainder dont exist in map we will continue dividing and storing next remainder till it becomes zero\\n            else\\n            {\\n                mp[rem] = dec.size();\\n                dec += to_string(rem*10/b);\\n                rem = (rem*10)%b;\\n            }\\n        }\\n        \\n        ans += dec;\\n        return ans;\\n        \\n        \\n        // Pls Upvote If You Like It\\n    }\\n};\\n\\n// Some Good Test Cases\\n// 4\\n// 333\\n\\n// -1\\n// -2147483648\\n\\n// 1\\n// 17\\n\\n// 45\\n// 499\\n\\n// -2147483648\\n// -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208837,
                "title": "166-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also handles the edge cases of a zero numerator and a zero denominator, and also checks for the negative sign at the beginning. It then calculates the integer part of the result by doing an integer division of the numerator by the denominator, and checks if there is a fractional part by checking if the remainder of this division is zero. If there is a fractional part, it adds a decimal point to the result.\\n\\nThe main optimization in this solution is the use of a dictionary to store the position of each remainder in the result. This way, we can easily check if a remainder has already appeared in the result, and if it has, we know that we have found a repeating part. We can then insert the opening and closing parentheses at the appropriate positions in the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Handle edge cases\\n        if numerator == 0:\\n            return \"0\"\\n        if denominator == 0:\\n            return \"\"\\n\\n        # Initialize result and check for negative sign\\n        result = \"\"\\n        if (numerator < 0) ^ (denominator < 0):\\n            result += \"-\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n\\n        # Integer part of the result\\n        result += str(numerator // denominator)\\n\\n        # Check if there is a fractional part\\n        if numerator % denominator == 0:\\n            return result\\n\\n        result += \".\"\\n\\n        # Use a dictionary to store the position of each remainder\\n        remainder_dict = {}\\n        remainder = numerator % denominator\\n\\n        # Keep adding the remainder to the result until it repeats or the remainder becomes 0\\n        while remainder != 0 and remainder not in remainder_dict:\\n            remainder_dict[remainder] = len(result)\\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder %= denominator\\n\\n        # Check if there is a repeating part\\n        if remainder in remainder_dict:\\n            result = result[:remainder_dict[remainder]] + \"(\" + result[remainder_dict[remainder]:] + \")\"\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Handle edge cases\\n        if numerator == 0:\\n            return \"0\"\\n        if denominator == 0:\\n            return \"\"\\n\\n        # Initialize result and check for negative sign\\n        result = \"\"\\n        if (numerator < 0) ^ (denominator < 0):\\n            result += \"-\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n\\n        # Integer part of the result\\n        result += str(numerator // denominator)\\n\\n        # Check if there is a fractional part\\n        if numerator % denominator == 0:\\n            return result\\n\\n        result += \".\"\\n\\n        # Use a dictionary to store the position of each remainder\\n        remainder_dict = {}\\n        remainder = numerator % denominator\\n\\n        # Keep adding the remainder to the result until it repeats or the remainder becomes 0\\n        while remainder != 0 and remainder not in remainder_dict:\\n            remainder_dict[remainder] = len(result)\\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder %= denominator\\n\\n        # Check if there is a repeating part\\n        if remainder in remainder_dict:\\n            result = result[:remainder_dict[remainder]] + \"(\" + result[remainder_dict[remainder]:] + \")\"\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163728,
                "title": "swift-fraction-to-recurring-decimal",
                "content": "```swift\\nclass Solution {\\n    func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String {\\n        var num = numerator, den = denominator\\n        var result = [String]()\\n        \\n        guard num != 0 else { return \"0\" }\\n        \\n        if (num > 0 && den < 0) || (num < 0 && den > 0) {\\n            result.append(\"-\")\\n        }\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        result.append(String(num/den))\\n        num %= den\\n        \\n        guard num != 0 else { return result.joined() }\\n        \\n        result.append(\".\")\\n        var map = [Int:Int]()\\n        map[num] = result.count\\n        \\n        while num != 0 {\\n            num *= 10\\n            result.append(String(num / den))\\n            num %= den\\n            if let value = map[num] {\\n                let index = value\\n                result.insert(\"(\", at: index)\\n                result.append(\")\")\\n                break\\n            } else {\\n                map[num] = result.count\\n            }\\n        }\\n        return result.joined()\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.081 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssert(s.fractionToDecimal(1, 2) == \"0.5\") // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.fractionToDecimal(2, 1) == \"2\") // success\\n    }\\n    func testExample3() {\\n        XCTAssert(s.fractionToDecimal(2, 3) == \"0.(6)\") // success\\n    }\\n    func testExample4() {\\n        XCTAssert(s.fractionToDecimal(4, 333) == \"0.(012)\") // success\\n    }\\n    func testExample5() {\\n        XCTAssert(s.fractionToDecimal(1, 5) == \"0.2\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func fractionToDecimal(_ numerator: Int, _ denominator: Int) -> String {\\n        var num = numerator, den = denominator\\n        var result = [String]()\\n        \\n        guard num != 0 else { return \"0\" }\\n        \\n        if (num > 0 && den < 0) || (num < 0 && den > 0) {\\n            result.append(\"-\")\\n        }\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        result.append(String(num/den))\\n        num %= den\\n        \\n        guard num != 0 else { return result.joined() }\\n        \\n        result.append(\".\")\\n        var map = [Int:Int]()\\n        map[num] = result.count\\n        \\n        while num != 0 {\\n            num *= 10\\n            result.append(String(num / den))\\n            num %= den\\n            if let value = map[num] {\\n                let index = value\\n                result.insert(\"(\", at: index)\\n                result.append(\")\")\\n                break\\n            } else {\\n                map[num] = result.count\\n            }\\n        }\\n        return result.joined()\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.081 (0.083) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssert(s.fractionToDecimal(1, 2) == \"0.5\") // success\\n    }\\n    func testExample2() {\\n        XCTAssert(s.fractionToDecimal(2, 1) == \"2\") // success\\n    }\\n    func testExample3() {\\n        XCTAssert(s.fractionToDecimal(2, 3) == \"0.(6)\") // success\\n    }\\n    func testExample4() {\\n        XCTAssert(s.fractionToDecimal(4, 333) == \"0.(012)\") // success\\n    }\\n    func testExample5() {\\n        XCTAssert(s.fractionToDecimal(1, 5) == \"0.2\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262401,
                "title": "c-very-easy-to-understand-100-beat",
                "content": "The problem is quiet straight forward except few cases.\\n*Steps:*\\n1. First decide the **sign** of output as (num/den) can be positive or negative as well.\\n2. Divide is **numerator** by **denominator**, check whether **remainder** exist or not\\n3. If *remainder* does exists and equal to ``0``, then simply return, as we have divided num by den.\\n4. Else divide till *remainder* is ``0`` and **repeat** exists.\\n\\t a. Check whether *remainder* will repeat after some time of division.\\n\\t b. If *remainder* repeats, then it\\'s guaranteed that next number will again repeat, then simply put braces at the end ``)`` and since we need to see previous tracked *remainders*, we have to use **hash-table** for *constant time operation*, then we also the **first** occurance of *remainder*, then simply get the position and insert the ``(`` bracket.\\n\\t c. Else if **remainder** do not repeat, then it has to converge to ``0``. Once it\\'s ``0`` we are out of loop and simply return the output.\\n\\t \\n\\t *Below is implementation of above algorithm*\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int num, int den) {\\n        bool neg = (num<0)^(den<0) ? true: false;\\n        long long int n = num;\\n        long long int d = den;\\n        n = abs(n);\\n        d = abs(d);\\n        long long int tmp = n/d;\\n        string res = \"\";\\n        if(neg && n!=0)\\n         res += \"-\";\\n\\n        res += to_string(tmp);\\n        n %= d;\\n        if(n==0){\\n            return res;\\n        }\\n        res += \".\";\\n        // now before decimal, work is over now after decimal\\n        bool repeat = false;\\n        unordered_map<long long int, int> mp; // mapping from remainder to size of string\\n        while(n!=0 && !repeat){\\n            if(mp.find(n)==mp.end())\\n                mp[n] = res.size();\\n            else if(mp.find(n)!=mp.end()){\\n                // repeat found\\n                repeat = true; // no need of repeat variable as we are breaking explicitly\\n                res.push_back(\\')\\');\\n                res.insert(mp[n],\"(\");\\n                break;\\n            }\\n            n = n*10;\\n            res += to_string(n/d);\\n            n %= d;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNote: pardon my English\\nHappy Coding.",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int num, int den) {\\n        bool neg = (num<0)^(den<0) ? true: false;\\n        long long int n = num;\\n        long long int d = den;\\n        n = abs(n);\\n        d = abs(d);\\n        long long int tmp = n/d;\\n        string res = \"\";\\n        if(neg && n!=0)\\n         res += \"-\";\\n\\n        res += to_string(tmp);\\n        n %= d;\\n        if(n==0){\\n            return res;\\n        }\\n        res += \".\";\\n        // now before decimal, work is over now after decimal\\n        bool repeat = false;\\n        unordered_map<long long int, int> mp; // mapping from remainder to size of string\\n        while(n!=0 && !repeat){\\n            if(mp.find(n)==mp.end())\\n                mp[n] = res.size();\\n            else if(mp.find(n)!=mp.end()){\\n                // repeat found\\n                repeat = true; // no need of repeat variable as we are breaking explicitly\\n                res.push_back(\\')\\');\\n                res.insert(mp[n],\"(\");\\n                break;\\n            }\\n            n = n*10;\\n            res += to_string(n/d);\\n            n %= d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411727,
                "title": "c-solution-0ms-beats-100-concise-code",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Fraction to Recurring Decimal.\\nMemory Usage: 9 MB, less than 73.33% of C++ online submissions for Fraction to Recurring Decimal.\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int nu, int de) {\\n        \\n        if (nu == 0)  return \"0\";\\n        string res;\\n        unordered_map<long long int, int> mp;\\n        bool flag = ((nu < 0 && de >= 0) || (nu >= 0 && de < 0));\\n        long long numerator = nu;\\n        long long denominator = de;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        long long dividend = numerator/denominator;\\n        long long rem = numerator%denominator;\\n        res = std::to_string(dividend);\\n        \\n        if(rem == 0)\\n            return (flag ? \\'-\\' + res : res);\\n        \\n        res.push_back(\\'.\\');\\n        while(rem != 0)\\n        {\\n            numerator = rem*10;\\n            if(mp.find(numerator) != mp.end())\\n            {\\n                int p = mp[numerator];\\n                res = res.substr(0,p) + \\'(\\' + res.substr(p) + \\')\\';\\n                break;\\n            }\\n            \\n            mp[numerator] = res.size();\\n            dividend = numerator/denominator;\\n            res.push_back(dividend+\\'0\\');\\n            rem = numerator%denominator;\\n        }\\n        \\n        if(flag)\\n            res.insert(res.begin(), \\'-\\');\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string fractionToDecimal(int nu, int de) {\\n        \\n        if (nu == 0)  return \"0\";\\n        string res;\\n        unordered_map<long long int, int> mp;\\n        bool flag = ((nu < 0 && de >= 0) || (nu >= 0 && de < 0));\\n        long long numerator = nu;\\n        long long denominator = de;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        long long dividend = numerator/denominator;\\n        long long rem = numerator%denominator;\\n        res = std::to_string(dividend);\\n        \\n        if(rem == 0)\\n            return (flag ? \\'-\\' + res : res);\\n        \\n        res.push_back(\\'.\\');\\n        while(rem != 0)\\n        {\\n            numerator = rem*10;\\n            if(mp.find(numerator) != mp.end())\\n            {\\n                int p = mp[numerator];\\n                res = res.substr(0,p) + \\'(\\' + res.substr(p) + \\')\\';\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51165,
                "title": "easy-to-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if(denominator == 0) return \"\";\\n            if(numerator == 0) return \"0\"; \\n            unordered_map<long, int> appeared;\\n            string ans;\\n            \\n            long p_int = abs((long)numerator / (long)denominator);\\n            ans += string((numerator < 0) ^ (denominator < 0), '-'); \\n            ans += to_string(p_int);\\n            long rem = abs((long)numerator % (long)denominator);\\n            if(rem == 0) return ans;\\n            ans += \".\";\\n            \\n            while(rem){\\n                appeared[rem] = ans.size();\\n                rem *= 10;\\n                ans += to_string(rem / abs((long)denominator));\\n                rem %= abs((long)denominator);\\n                if(appeared.find(rem) != appeared.end()){\\n                    ans.insert(appeared[rem], \"(\");\\n                    ans += \")\";\\n                    break;\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string fractionToDecimal(int numerator, int denominator) {\\n            if(denominator == 0) return \"\";\\n            if(numerator == 0) return \"0\"; \\n            unordered_map<long, int> appeared;\\n            string ans;\\n            \\n            long p_int = abs((long)numerator / (long)denominator);\\n            ans += string((numerator < 0) ^ (denominator < 0), '-'); \\n            ans += to_string(p_int);\\n            long rem = abs((long)numerator % (long)denominator);\\n            if(rem == 0) return ans;\\n            ans += \".\";\\n            \\n            while(rem){\\n                appeared[rem] = ans.size();\\n                rem *= 10;\\n                ans += to_string(rem / abs((long)denominator));\\n                rem %= abs((long)denominator);\\n                if(appeared.find(rem) != appeared.end()){\\n                    ans.insert(appeared[rem], \"(\");\\n                    ans += \")\";\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 495542,
                "title": "python-long-divsion-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \\'0\\'\\n        \\n        result = []\\n        if numerator < 0 and denominator > 0 or numerator >= 0 and denominator < 0:\\n            result.append(\\'-\\')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        result.append(str(numerator // denominator))\\n        \\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(result)\\n        result.append(\\'.\\')\\n        \\n        d = {}\\n        while remainder != 0:\\n            if remainder in d:\\n                result.insert(d[remainder], \\'(\\')\\n                result.append(\\')\\')\\n                return \\'\\'.join(result)\\n            \\n            d[remainder] = len(result)\\n            \\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder = remainder % denominator\\n        \\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \\'0\\'\\n        \\n        result = []\\n        if numerator < 0 and denominator > 0 or numerator >= 0 and denominator < 0:\\n            result.append(\\'-\\')\\n        \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        result.append(str(numerator // denominator))\\n        \\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(result)\\n        result.append(\\'.\\')\\n        \\n        d = {}\\n        while remainder != 0:\\n            if remainder in d:\\n                result.insert(d[remainder], \\'(\\')\\n                result.append(\\')\\')\\n                return \\'\\'.join(result)\\n            \\n            d[remainder] = len(result)\\n            \\n            remainder *= 10\\n            result += str(remainder // denominator)\\n            remainder = remainder % denominator\\n        \\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51131,
                "title": "an-intuitive-solution-in-c-beating-100-submissions-well-explained",
                "content": "Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "Beating 100% submission, why? no one ever submitted the C version so far. Here is my solution:\\n\\n - determine the sign of the result;\\n - retrieve the integer part of the result - numerator/denominator;\\n - get all the decimals by the remainder -> numerator%denominator just as we do division in mathematics; but along with it we should record the remainder value and the corresponding string index collecting string (once we find the same remainder, we will know that we will run in a circle since the denominator is always the same, so then we have to <font color=\"#ff0000\">bracket the inner digits up</font>) and return;\\n\\n> B.T.W. there is a customised hash-map structure to store the remainder and the string index\\n\\nBang! End of story.\\n\\n----------\\n    \\n    #define LEN 10000\\n    struct MyListNode\\n    {\\n        long long key;\\n        int val;\\n        struct MyListNode *next;\\n    };\\n    \\n    void push(struct MyListNode* head, long long key, int val)\\n    {\\n        struct MyListNode *p = head;\\n        while(p->next)\\n            p = p->next;\\n        struct MyListNode *t = (struct MyListNode*)malloc(sizeof(struct MyListNode));\\n        t->key = key;\\n        t->val = val;\\n        p->next = t;\\n    }\\n    \\n    int pop(struct MyListNode* head, long long key)\\n    {\\n        struct MyListNode *p = head->next;\\n        while(p)\\n        {\\n            if(p->key == key)\\n                return p->val;\\n            p = p->next;\\n        }\\n        return 0;\\n    }\\n    \\n    char* fractionToDecimal(int n, int d)\\n    {\\n        if(n == 0) return \"0\";\\n        char *s = (char*)malloc(sizeof(char)*LEN);\\n        int index = 0;\\n        if((n<0 && d>0) || (n>0 && d<0)) s[index++] = '-'; //get the sign part;\\n        long long numerator = (n==INT_MIN)? -1*(long long)n : abs(n); //get the positive format of numerator;\\n        long long denominator = (d==INT_MIN)? -1*(long long)d : abs(d); //get the positive format of denominator;\\n        long long integer = numerator/denominator; //collecting the integer part;\\n        if(integer == 0)\\n            s[index++] = '0';\\n        else\\n        {\\n            char *t = (char*)malloc(sizeof(char)*LEN); //used to store the integer part in reverse order;\\n            int index0 = 0;\\n            while(integer)\\n            {\\n                t[index0++] = integer%10+'0';\\n                integer /= 10;\\n            }\\n            for(int i = index0-1; i > -1; i--) //reverse it again, then s will store the integer part in normal sequence;\\n                s[index++] = t[i];\\n        }\\n        long long remainder = numerator%denominator; //get the remainder by mod operator;\\n        if(remainder == 0) \\n        {\\n            s[index] = '\\\\0';\\n            return s;\\n        }\\n        s[index++] = '.'; //there are decimals;\\n        struct MyListNode *head = (struct MyListNode*)malloc(sizeof(struct MyListNode)); //used to store the remainder digit index in string for recurring;\\n        while(remainder)\\n        {\\n            int pre = pop(head, remainder);\\n            if(pre) //check if this digit has already occurred, if so, add brackets;\\n            {\\n                for(int i = index; i > pre; i--)\\n                    s[i] = s[i-1];\\n                index++;\\n                s[pre] = '(';\\n                s[index++] = ')';\\n                break;\\n            }\\n            push(head, remainder, index);\\n            remainder *= 10; //imitating division process here, retrieving the high decimal digit;\\n            s[index++] = remainder/denominator+'0';\\n            remainder %= denominator;\\n        }\\n        s[index] = '\\\\0';\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1029272,
                "title": "javascript-solution",
                "content": "```javascript\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(!numerator) return \\'0\\';\\n    \\n    let str = \\'\\';\\n    \\n    if(Math.sign(numerator) !== Math.sign(denominator)) str += \\'-\\';\\n    \\n    const numer = Math.abs(numerator)\\n    const denom = Math.abs(denominator)\\n    \\n    str += Math.floor(numer/denom);\\n    let rem = numer%denom;\\n    if(!rem) return str;\\n    str += \\'.\\'\\n    \\n    const map = new Map();\\n    \\n    while(rem !== 0) {\\n        map.set(rem, str.length);\\n        \\n        rem *= 10;\\n        str += Math.floor(rem/denom);\\n        rem %= denom\\n        \\n        if(map.has(rem)) {\\n            const idx = map.get(rem);\\n            return str.slice(0, idx) + `(${str.slice(idx)})`; \\n        }\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988279,
                "title": "python-optimal-and-easy-solution-faster-than-95",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```\\n\\n**Guys give it an upvote if you liked it, so it can help others :)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        if numerator % denominator == 0:\\n            return str(numerator//denominator)\\n        sign = \\'\\' if numerator * denominator >= 0 else \\'-\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = sign + str(numerator//denominator) + \\'.\\'\\n        numerator %= denominator\\n        i, part = 0, \\'\\'\\n        m = {numerator:i}\\n        while numerator % denominator:\\n            numerator *= 10\\n            i += 1\\n            rem = numerator % denominator\\n            part += str(numerator // denominator)\\n            if rem in m:\\n                part = part[:m[rem]]+\\'(\\'+part[m[rem]:]+\\')\\'\\n                return res + part\\n            m[rem] = i\\n            numerator = rem\\n        return res + part\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51205,
                "title": "a-clean-c-solution-with-3ms",
                "content": "    class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\tres += \"0\";\\n    \\t\\t}\\n    \\n    \\t\\tif(0 == rem) return res; // That the remainder is 0 means there isn't a fractional part of the result, \\n    \\t\\t//so we return the integral part.\\n    \\n    \\t\\t/*\\n    \\t\\tIn the following, we record the numerator to be divided by the denominator and the length of the temporary result.\\n    \\t\\tIf a numerator has been met before, circulation happens, so we stop the computation and insert a parathesis, and return \\n    \\t\\tthe result.\\n    \\t\\t*/\\n    \\t\\tnum = rem;\\n    \\n    \\t\\tunordered_map<long long, int> m;\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\tnum *= 10;\\n    \\t\\tres.append(\".\");\\n    \\t\\tm[num] = res.size();\\n    \\n    \\t\\twhile(num > 0)\\n    \\t\\t{\\n    \\t\\t\\tif(num < den)\\n    \\t\\t\\t{// If the numerator is less than the denominator, we multiply the numerator with 10, and append a 'o'\\n    \\t\\t\\t\\t// to the result. And we record the numerator and the temporary size of the result.\\n    \\t\\t\\t\\tnum *= 10;\\n    \\t\\t\\t\\tres.append(\"0\");\\n    \\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tif(num > den)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tchar ch = '0' + num/den; // Compute the quotient and push the quotient to the result.\\n    \\t\\t\\t\\tres.push_back(ch);\\n    \\t\\t\\t\\tnum %= den; // Compute the remainder; \\n    \\t\\t\\t\\tnum *= 10; // multiply the remainder with 10, and it will be the new numerator.\\n    \\t\\t\\t\\tif(m.end() == m.find(num)) // This numerator occurs for the first time, so we record it.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tm[num] = res.size();\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse // Circulation happens, so we return the result.\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tstring temp = res.substr(0, m[num]) + \"(\" + res.substr(m[num], string::npos) + \")\";\\n    \\t\\t\\t\\t\\tres = temp;\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator)\\n    \\t{\\n    \\t\\tif(0 == numerator) return \"0\";// If the numerator is 0, the final result must be 0.\\n    \\n    \\t\\tlong long num = numerator;// One of the test case is denominator = 0x80000000, thus we must save its opposite\\n    \\t\\tlong long den = denominator; // number in a long long variable.\\n    \\n    \\t\\tbool b1 = num < 0;\\n    \\t\\tbool b2 = den < 0;\\n    \\n    \\t\\tif(b1) num = - num;\\t// We convert both numerator and denominator into positive numbers.\\n    \\t\\tif(b2) den = -den;\\n    \\n    \\t\\tstring res = \"\";\\n    \\t\\tif(b1^b2) res += \"-\"; // Add a \"-\" if the numerator is positive and the denominator is negative or vice versa.\\n    \\n    \\t\\tlong long quo = num/den;\\n    \\t\\tlong long rem = num%den;\\n    \\n    \\t\\t//Calculate the integral part of the final result.\\n    \\t\\tif(quo > 0)\\n    \\t\\t{\\n    \\t\\t\\tostringstream oss;\\n    \\t\\t\\toss << quo;\\n    \\t\\t\\tres += oss.str();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51235,
                "title": "online-judge-pass-java-version",
                "content": "     public class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n                if (denominator == 0) {\\n                    throw new IllegalArgumentException(\" denominator can not be zero\");\\n                }\\n                \\n                // avoid overflow for minimum vlaue of interger\\n                long newNum = (long) numerator;\\n                long newDeNom = (long) denominator;\\n        \\t\\t\\n        \\t\\tStringBuilder sb = new StringBuilder();\\n                \\n                // detect sign\\n                if ((newNum > 0 && newDeNom < 0) || (newNum <0 && newDeNom > 0)) {\\n        \\t\\t    sb.append(\"-\");\\n        \\t\\t}\\n        \\t\\t// make sure it is postive value\\n        \\t\\tnewNum = Math.abs(newNum);\\n        \\t\\tnewDeNom = Math.abs(newDeNom);      \\n                       \\n                sb.append(newNum / newDeNom);\\n                \\n                long reminder = newNum % newDeNom;\\n                Map<Long, Integer> reminderMap = new HashMap<>();\\n                \\n                if (reminder != 0) {\\n                    sb.append(\".\");\\n                }\\n                \\n                while (reminder != 0 && !reminderMap.containsKey(reminder)) {\\n                    reminderMap.put(reminder, sb.length());\\n                    reminder *= 10;\\n                    sb.append(reminder / newDeNom);\\n                    reminder = reminder % newDeNom; \\n                }\\n                \\n                if (reminderMap.containsKey(reminder)) {\\n                    sb.insert(reminderMap.get(reminder), \"(\");\\n                    sb.append(\")\");\\n                }\\n                return sb.toString();\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n                if (denominator == 0) {\\n                    throw new IllegalArgumentException(\" denominator can not be zero\");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3041777,
                "title": "100-fast-simple-c-implementation",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    string tostring(long long n){\\n        if (n==0)return \"0\";\\n        string ans;\\n        while (n>0){\\n            string dem;\\n            dem+= ((n%10)+\\'0\\');\\n            ans= dem+ans;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    string fractionToDecimal(int num, int denom) {\\n        if (num==0)return \"0\";\\n        string ans;\\n        if ((num<0 && denom>0) || (num>0 && denom<0))ans.push_back(\\'-\\');\\n        num= abs(num); denom= abs(denom);\\n        long long quotient= num/denom;\\n        long long remainder= num%denom;\\n        ans= ans+tostring(quotient);\\n        if (remainder==0)return ans;\\n        ans+=\\'.\\';\\n        map<long long, int> mp;\\n        while (remainder != 0){\\n            if (mp.find(remainder)!= mp.end()){\\n                int pos= mp[remainder];\\n                ans.insert(pos,\"(\");\\n                ans+=\\')\\';\\n                break;\\n            }\\n            else {\\n                mp[remainder]= ans.length();\\n                remainder*= 10;\\n                quotient= remainder/denom;\\n                remainder= remainder%denom;\\n                ans+= tostring(quotient);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string tostring(long long n){\\n        if (n==0)return \"0\";\\n        string ans;\\n        while (n>0){\\n            string dem;\\n            dem+= ((n%10)+\\'0\\');\\n            ans= dem+ans;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    string fractionToDecimal(int num, int denom) {\\n        if (num==0)return \"0\";\\n        string ans;\\n        if ((num<0 && denom>0) || (num>0 && denom<0))ans.push_back(\\'-\\');\\n        num= abs(num); denom= abs(denom);\\n        long long quotient= num/denom;\\n        long long remainder= num%denom;\\n        ans= ans+tostring(quotient);\\n        if (remainder==0)return ans;\\n        ans+=\\'.\\';\\n        map<long long, int> mp;\\n        while (remainder != 0){\\n            if (mp.find(remainder)!= mp.end()){\\n                int pos= mp[remainder];\\n                ans.insert(pos,\"(\");\\n                ans+=\\')\\';\\n                break;\\n            }\\n            else {\\n                mp[remainder]= ans.length();\\n                remainder*= 10;\\n                quotient= remainder/denom;\\n                remainder= remainder%denom;\\n                ans+= tostring(quotient);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545296,
                "title": "c-faster-than-100-easy",
                "content": "![image](https://assets.leetcode.com/users/images/c81f470d-88e4-4e34-bea5-ff6256a539ee_1635417844.7527034.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n1, int d1) {\\n        string ans = \"\", temp = \"\";\\n        unordered_map<int, int> mp;\\n        \\n        if(!n1){\\n            return \"0\";\\n        }\\n        if(n1 > 0 and d1 < 0 or n1 < 0 and d1 > 0){\\n            temp += \\'-\\';\\n        }\\n        long n = abs(n1);\\n        long d = abs(d1);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        if(n){\\n            ans += \\'.\\';\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n *= 10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0, mp[n]) + \\'(\\' + ans.substr(mp[n]) + \\')\\';\\n            }\\n        }\\n        return temp + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n1, int d1) {\\n        string ans = \"\", temp = \"\";\\n        unordered_map<int, int> mp;\\n        \\n        if(!n1){\\n            return \"0\";\\n        }\\n        if(n1 > 0 and d1 < 0 or n1 < 0 and d1 > 0){\\n            temp += \\'-\\';\\n        }\\n        long n = abs(n1);\\n        long d = abs(d1);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        if(n){\\n            ans += \\'.\\';\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n *= 10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0, mp[n]) + \\'(\\' + ans.substr(mp[n]) + \\')\\';\\n            }\\n        }\\n        return temp + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496638,
                "title": "java-with-explanation-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public String fractionToDecimal(int num, int den) {\\n        //base case\\n        if(num==0)\\n            return \"0\";\\n        \\n        //converting all integers to num becuase we may multiply them with 10 also multiple time.\\n        long numerator=num;\\n        long denominator=den;\\n        \\n        //chekcing what sign our result should have \\n        boolean flag=false;\\n        \\n        if((numerator<0 && denominator>=0) || (numerator>=0 && denominator<0))\\n            flag=true;\\n        \\n        //and removing sign from den and num\\n        numerator=Math.abs(numerator);\\n        denominator=Math.abs(denominator);\\n        \\n        \\n        long divider=numerator/denominator;\\n        long rem=numerator%denominator;\\n        \\n        StringBuilder op;\\n        if(rem==0){//no need to move further ,just return the results..\\n            op=(new StringBuilder()).append(divider);\\n        }else{//we have to find fractional points\\n            //we always multiply rem by 10 once then move forwad in case of remainder\\n            op= (new StringBuilder()).append(divider).append(\".\").append(fraction(rem*10,denominator,new StringBuilder(),new HashMap<Long,Integer>()));\\n        }\\n        //System.out.println(op.toString());\\n        if(flag)\\n            op.insert(0,\\'-\\');\\n        return op.toString();\\n    }\\n                           \\n    //while finding fractionals numbers we keep track of waht we have found till now \\n    //so we can just stop if we have already found solution for current situation and append parenthises as asked in question.\\n    public StringBuilder fraction(long num,long den,StringBuilder sb,HashMap<Long,Integer> hm){\\n        \\n        //if we solved it before just append () at appropriate indices\\n        if(hm.containsKey(num)){\\n            int index=hm.get(num);\\n            sb.insert(index,\\'(\\');\\n            sb.append(\\')\\');\\n            return sb;\\n        }\\n        \\n        if(num<den){//we have to multiply num with 10.\\n            sb.append(0);//to do so we first have to append 0 in divider\\n            return fraction(num*10,den,sb,hm);\\n        }\\n        \\n        long divider=num/den;\\n        long rem=num%den;\\n        \\n        if(rem==0){\\n            return sb.append(divider);\\n        }else{\\n            hm.put(num,sb.length());\\n            sb.append(divider);\\n            return fraction(rem*10,den,sb,hm);\\n        }\\n    }\\n\\t//if you find this helpful then please up vote.\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String fractionToDecimal(int num, int den) {\\n        //base case\\n        if(num==0)\\n            return \"0\";\\n        \\n        //converting all integers to num becuase we may multiply them with 10 also multiple time.\\n        long numerator=num;\\n        long denominator=den;\\n        \\n        //chekcing what sign our result should have \\n        boolean flag=false;\\n        \\n        if((numerator<0 && denominator>=0) || (numerator>=0 && denominator<0))\\n            flag=true;\\n        \\n        //and removing sign from den and num\\n        numerator=Math.abs(numerator);\\n        denominator=Math.abs(denominator);\\n        \\n        \\n        long divider=numerator/denominator;\\n        long rem=numerator%denominator;\\n        \\n        StringBuilder op;\\n        if(rem==0){//no need to move further ,just return the results..\\n            op=(new StringBuilder()).append(divider);\\n        }else{//we have to find fractional points\\n            //we always multiply rem by 10 once then move forwad in case of remainder\\n            op= (new StringBuilder()).append(divider).append(\".\").append(fraction(rem*10,denominator,new StringBuilder(),new HashMap<Long,Integer>()));\\n        }\\n        //System.out.println(op.toString());\\n        if(flag)\\n            op.insert(0,\\'-\\');\\n        return op.toString();\\n    }\\n                           \\n    //while finding fractionals numbers we keep track of waht we have found till now \\n    //so we can just stop if we have already found solution for current situation and append parenthises as asked in question.\\n    public StringBuilder fraction(long num,long den,StringBuilder sb,HashMap<Long,Integer> hm){\\n        \\n        //if we solved it before just append () at appropriate indices\\n        if(hm.containsKey(num)){\\n            int index=hm.get(num);\\n            sb.insert(index,\\'(\\');\\n            sb.append(\\')\\');\\n            return sb;\\n        }\\n        \\n        if(num<den){//we have to multiply num with 10.\\n            sb.append(0);//to do so we first have to append 0 in divider\\n            return fraction(num*10,den,sb,hm);\\n        }\\n        \\n        long divider=num/den;\\n        long rem=num%den;\\n        \\n        if(rem==0){\\n            return sb.append(divider);\\n        }else{\\n            hm.put(num,sb.length());\\n            sb.append(divider);\\n            return fraction(rem*10,den,sb,hm);\\n        }\\n    }\\n\\t//if you find this helpful then please up vote.\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200334,
                "title": "c-100-faster-76-less-space-easy-to-understand",
                "content": "// Use a map to track repeating fraction.\\n// Need to handling int overflow, which caused me 90% of the time, and end up having to use\\n// long long, which I should have thought of much earlier.\\n\\n\\tstring fractionToDecimal(int numerator, int denominator)\\n\\t{\\n\\t\\tif (!numerator)\\n\\t\\t{\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\n\\t\\tstring result;\\n\\t\\tlong long remainder = numerator;\\n\\t\\tunordered_map<long long, int> pattern;\\n\\n\\t\\t// Determine sign so that we don\\'t have to care about it later.\\n\\t\\tif ((remainder < 0 && denominator > 0) ||\\n\\t\\t\\t(remainder > 0 && denominator < 0))\\n\\t\\t{\\n\\t\\t\\tresult += \"-\";\\n\\t\\t}\\n\\n\\t\\twhile (remainder)\\n\\t\\t{\\n\\t\\t\\tresult += to_string(llabs(remainder / denominator));\\n\\t\\t\\tremainder = remainder % denominator;\\n\\n\\t\\t\\t// Each time we got a new remainder, check if it matches a repeat pattern. \\n\\t\\t\\tif (pattern.find(remainder) != pattern.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.insert(pattern[remainder], \"(\");\\n\\t\\t\\t\\tresult.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we are not done by dividing once, we need a \".\".\\n\\t\\t\\tif (remainder && result.find(\\'.\\') == result.npos)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += \".\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save the remainder and its correspounding position in the result.\\n\\t\\t\\tpattern[remainder] = result.length();\\n\\n\\t\\t\\tremainder *= 10;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "// Use a map to track repeating fraction.\\n// Need to handling int overflow, which caused me 90% of the time, and end up having to use\\n// long long, which I should have thought of much earlier.\\n\\n\\tstring fractionToDecimal(int numerator, int denominator)\\n\\t{\\n\\t\\tif (!numerator)\\n\\t\\t{\\n\\t\\t\\treturn \"0\";\\n\\t\\t}\\n\\n\\t\\tstring result;\\n\\t\\tlong long remainder = numerator;\\n\\t\\tunordered_map<long long, int> pattern;\\n\\n\\t\\t// Determine sign so that we don\\'t have to care about it later.\\n\\t\\tif ((remainder < 0 && denominator > 0) ||\\n\\t\\t\\t(remainder > 0 && denominator < 0))\\n\\t\\t{\\n\\t\\t\\tresult += \"-\";\\n\\t\\t}\\n\\n\\t\\twhile (remainder)\\n\\t\\t{\\n\\t\\t\\tresult += to_string(llabs(remainder / denominator));\\n\\t\\t\\tremainder = remainder % denominator;\\n\\n\\t\\t\\t// Each time we got a new remainder, check if it matches a repeat pattern. \\n\\t\\t\\tif (pattern.find(remainder) != pattern.end())\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.insert(pattern[remainder], \"(\");\\n\\t\\t\\t\\tresult.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we are not done by dividing once, we need a \".\".\\n\\t\\t\\tif (remainder && result.find(\\'.\\') == result.npos)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult += \".\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save the remainder and its correspounding position in the result.\\n\\t\\t\\tpattern[remainder] = result.length();\\n\\n\\t\\t\\tremainder *= 10;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 673275,
                "title": "java-clean-code-easy-to-understand-1-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n\\t\\n\\t\\tif(numerator == 0) return \"0\";\\n\\t\\tif(denominator == 0) return \"\";\\n\\t\\n\\t\\tboolean sign = (numerator < 0) ^ (denominator < 0);\\n \\n\\t\\tStringBuilder ans = new StringBuilder();\\n \\n\\t\\tlong num = Math.abs(new Long(numerator));\\n\\t\\tlong den = Math.abs(new Long(denominator));\\n\\t\\t\\n\\t\\tif(sign) ans.append(\"-\");\\n \\n\\t\\tans.append(num / den);\\n\\t\\tlong remainder = (num % den) * 10;\\n\\t\\t\\n\\t\\tif(remainder != 0) ans.append(\".\");\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n        \\n\\t\\twhile(remainder != 0) {\\n\\t\\t\\tif(map.containsKey(remainder)) {\\n\\t\\t\\t\\tans.insert(map.get(remainder), \"(\");\\n\\t\\t\\t\\tans.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmap.put(remainder, ans.length());\\n\\t\\t\\tans.append(remainder / den);\\n\\t\\t\\tremainder = (remainder % den) * 10;\\n\\t\\t}\\n \\n\\t\\treturn ans.toString();\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n\\t\\n\\t\\tif(numerator == 0) return \"0\";\\n\\t\\tif(denominator == 0) return \"\";\\n\\t\\n\\t\\tboolean sign = (numerator < 0) ^ (denominator < 0);\\n \\n\\t\\tStringBuilder ans = new StringBuilder();\\n \\n\\t\\tlong num = Math.abs(new Long(numerator));\\n\\t\\tlong den = Math.abs(new Long(denominator));\\n\\t\\t\\n\\t\\tif(sign) ans.append(\"-\");\\n \\n\\t\\tans.append(num / den);\\n\\t\\tlong remainder = (num % den) * 10;\\n\\t\\t\\n\\t\\tif(remainder != 0) ans.append(\".\");\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n        \\n\\t\\twhile(remainder != 0) {\\n\\t\\t\\tif(map.containsKey(remainder)) {\\n\\t\\t\\t\\tans.insert(map.get(remainder), \"(\");\\n\\t\\t\\t\\tans.append(\")\");\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tmap.put(remainder, ans.length());\\n\\t\\t\\tans.append(remainder / den);\\n\\t\\t\\tremainder = (remainder % den) * 10;\\n\\t\\t}\\n \\n\\t\\treturn ans.toString();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413293,
                "title": "clean-java-solution-1ms",
                "content": "This uses a map to detect a cycle.\\n\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder builder = new StringBuilder();\\n        if ((numerator < 0) ^ (denominator < 0)) builder.append(\"-\");\\n\\t\\t\\n\\t\\t//converts to long to get rid of the pesky int overflow\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\n        builder.append((n/d));\\n        if ((n %= d) == 0) return builder.toString();\\n        builder.append(\".\");\\n        \\n\\t\\t//map stores the index in our  builder where we first encounter this numerator\\n        Map<Long, Integer> numerators = new HashMap<>();\\n        while(!numerators.containsKey(n)) {\\n            numerators.put(n, builder.length());\\n            n *= 10;\\n            builder.append(n/d);\\n            if ((n %= d) == 0) return builder.toString();\\n        }\\n\\t\\t//we use the index to insert our bracket\\n        return builder.insert(numerators.get(n),\"(\").append(\")\").toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder builder = new StringBuilder();\\n        if ((numerator < 0) ^ (denominator < 0)) builder.append(\"-\");\\n\\t\\t\\n\\t\\t//converts to long to get rid of the pesky int overflow\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\n        builder.append((n/d));\\n        if ((n %= d) == 0) return builder.toString();\\n        builder.append(\".\");\\n        \\n\\t\\t//map stores the index in our  builder where we first encounter this numerator\\n        Map<Long, Integer> numerators = new HashMap<>();\\n        while(!numerators.containsKey(n)) {\\n            numerators.put(n, builder.length());\\n            n *= 10;\\n            builder.append(n/d);\\n            if ((n %= d) == 0) return builder.toString();\\n        }\\n\\t\\t//we use the index to insert our bracket\\n        return builder.insert(numerators.get(n),\"(\").append(\")\").toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 228992,
                "title": "easy-to-read-javascript-solution-w-explanation-beats-100-68-ms",
                "content": "Idea: the core of this problem is identifying and handling repeating decimals correctly. Besides that, you just need to make sure that you\\'re handling edge cases appropriately. One way to think about identifying repeating decimals is to track the \"carry\" as if you\\'re doing long division by hand. If you\\'ve seen the \"carry\" before, then you\\'re in a loop that started at the index of the first time you saw that carry.\\n\\nFor example, with 2 / 3:\\n \\n![image](https://assets.leetcode.com/users/tadasant/image_1548851304.png)\\n\\n\\nEdge cases:\\n* Left side of decimal is >0, or >9 (i.e. multiple digits might throw off your idx counting)\\n* Numerator is zero\\n* Negative numbers (one or both numerator/denominator)\\n* Whole numbers (i.e. no need for decimal point)\\n* Non-repeating decimals\\n\\n```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    // Handle zero edge case\\n    if (numerator === 0) {\\n        return \"0\";\\n    }\\n    \\n    // Handle negatives edge cases, work with positive numbers moving forward\\n    const isNegative = numerator < 0 ? denominator > 0 : denominator < 0;\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    \\n    // Handle whole number edge case\\n    const leftSide = Math.floor(numerator / denominator);\\n    const hasDecimal = (numerator / denominator) % 1 !== 0;\\n    if (!hasDecimal) {\\n        return isNegative ? `-${leftSide.toString()}` : leftSide.toString();\\n    }\\n    \\n    // Invoke core algorithm\\n    const result = [leftSide.toString(), \\'.\\'];\\n    addDecimal(numerator, denominator, leftSide, result);\\n    \\n    // Finish handling negatives edge case\\n    if (isNegative) {\\n        result.unshift(\"-\");\\n    }\\n\\t\\n    return result.join(\\'\\');\\n};\\n\\nfunction addDecimal(numerator, denominator, leftSide, result) {\\n    // Account for whole number edge case; make numerator less than denominator\\n    numerator -= (leftSide * denominator);\\n    \\n    let idx = 0; // idx of the current digit\\n    const carries = {}; // carry values to index (within decimal digit chars) mapping\\n    \\n    // Loop dividing numerator by denominator and tracking carry at each step\\n    while (numerator !== 0 && !(numerator in carries)) {\\n        carries[numerator] = idx++;\\n        numerator *= 10;\\n        const nextDigit = Math.floor(numerator / denominator);\\n        result.push(nextDigit.toString());\\n        numerator %= denominator;\\n    }\\n    \\n    // If we detected a loop, add the repeating parentheses\\n    if (numerator in carries) {\\n        addParens(carries[numerator], result);\\n    }\\n}\\n\\nfunction addParens(decimalIdx, result) {\\n    result.splice(2 + decimalIdx, 0, \\'(\\'); // +2 because decimal point is at idx 1\\n    result.push(\\')\\');\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    // Handle zero edge case\\n    if (numerator === 0) {\\n        return \"0\";\\n    }\\n    \\n    // Handle negatives edge cases, work with positive numbers moving forward\\n    const isNegative = numerator < 0 ? denominator > 0 : denominator < 0;\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n    \\n    // Handle whole number edge case\\n    const leftSide = Math.floor(numerator / denominator);\\n    const hasDecimal = (numerator / denominator) % 1 !== 0;\\n    if (!hasDecimal) {\\n        return isNegative ? `-${leftSide.toString()}` : leftSide.toString();\\n    }\\n    \\n    // Invoke core algorithm\\n    const result = [leftSide.toString(), \\'.\\'];\\n    addDecimal(numerator, denominator, leftSide, result);\\n    \\n    // Finish handling negatives edge case\\n    if (isNegative) {\\n        result.unshift(\"-\");\\n    }\\n\\t\\n    return result.join(\\'\\');\\n};\\n\\nfunction addDecimal(numerator, denominator, leftSide, result) {\\n    // Account for whole number edge case; make numerator less than denominator\\n    numerator -= (leftSide * denominator);\\n    \\n    let idx = 0; // idx of the current digit\\n    const carries = {}; // carry values to index (within decimal digit chars) mapping\\n    \\n    // Loop dividing numerator by denominator and tracking carry at each step\\n    while (numerator !== 0 && !(numerator in carries)) {\\n        carries[numerator] = idx++;\\n        numerator *= 10;\\n        const nextDigit = Math.floor(numerator / denominator);\\n        result.push(nextDigit.toString());\\n        numerator %= denominator;\\n    }\\n    \\n    // If we detected a loop, add the repeating parentheses\\n    if (numerator in carries) {\\n        addParens(carries[numerator], result);\\n    }\\n}\\n\\nfunction addParens(decimalIdx, result) {\\n    result.splice(2 + decimalIdx, 0, \\'(\\'); // +2 because decimal point is at idx 1\\n    result.push(\\')\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 137886,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\'-\\' if numerator*denominator < 0 else \\'\\'\\n        fraction = [sign+str(n)]\\n        if remainder == 0:\\n            return \\'\\'.join(fraction)\\n\\n        fraction.append(\\'.\\')\\n        dic = {}\\n        while remainder != 0:\\n            if remainder in dic:\\n                fraction.insert(dic[remainder], \\'(\\')\\n                fraction.append(\\')\\')\\n                break\\n            dic[remainder] = len(fraction)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            fraction.append(str(n))\\n        return \\'\\'.join(fraction)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        n, remainder = divmod(abs(numerator), abs(denominator))\\n        sign = \\'-\\' if numerator*denominator < 0 else \\'\\'\\n        fraction = [sign+str(n)]\\n        if remainder == 0:\\n            return \\'\\'.join(fraction)\\n\\n        fraction.append(\\'.\\')\\n        dic = {}\\n        while remainder != 0:\\n            if remainder in dic:\\n                fraction.insert(dic[remainder], \\'(\\')\\n                fraction.append(\\')\\')\\n                break\\n            dic[remainder] = len(fraction)\\n            n, remainder = divmod(remainder*10, abs(denominator))\\n            fraction.append(str(n))\\n        return \\'\\'.join(fraction)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51113,
                "title": "fastest-java-solution-1-ms-and-o-1-space",
                "content": "My algorithm base on the Floyd's cycle-finding algorithm. Instead of using hashMap to store the result of each step, It uses two pointer, fast (iterate twice each time) and slow (iterate once each time) to detect cycle. Then It finds out the non-cycle part and cycle part. Therefore, it's O(1) space and is faster than those of using hash.\\n```\\npublic class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        // negative sign\\n        boolean negative = (numerator < 0) ^ (denominator < 0);\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n        long intPart = n / d;\\n        long rest = n - intPart * d;\\n        if (rest == 0) return negative ? String.valueOf(intPart * (-1)) : String.valueOf(intPart); // Integer result\\n        StringBuilder res = new StringBuilder();\\n        if (negative) res.append(\"-\");\\n        res.append(intPart);\\n        res.append(\".\");\\n        long slow;\\n        long fast;\\n        long[] temp = new long[2];\\n        slow = Decimal(rest*10, d)[1];\\n        fast = Decimal(Decimal(rest*10, d)[1], d)[1];\\n        while (slow != fast) {\\n            slow = Decimal(slow, d)[1];\\n            fast = Decimal(Decimal(fast, d)[1], d)[1];\\n        }\\n        slow = rest * 10;\\n        while (slow != fast && slow != 0) {\\n            temp = Decimal(slow, d);\\n            slow = temp[1];\\n            res.append(temp[0]);       // non-cycle part\\n            fast = Decimal(fast, d)[1];\\n        }\\n        if (slow == 0) return res.toString();  // return when result is finite decimal\\n        temp = Decimal(slow, d);\\n        fast = temp[1];\\n        res.append(\"(\");\\n        res.append(temp[0]);\\n        while (slow != fast) {\\n            temp = Decimal(fast, d);\\n            fast = temp[1];\\n            res.append(temp[0]);  // cycle part\\n        }\\n        res.append(\")\");\\n        return res.toString();\\n    }\\n    public long[] Decimal(long rest, long denominator) {\\n        // return the quotient and remainder (multiplied by 10)\\n        long r1;\\n        long r2;\\n        if (rest < denominator) {\\n            r1 = 0;\\n            r2 = rest * 10;\\n        }\\n        else {\\n            r1 = rest / denominator;\\n            r2 = (rest - denominator * r1) * 10;\\n        }\\n        return new long[]{r1, r2};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        // negative sign\\n        boolean negative = (numerator < 0) ^ (denominator < 0);\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n        long intPart = n / d;\\n        long rest = n - intPart * d;\\n        if (rest == 0) return negative ? String.valueOf(intPart * (-1)) : String.valueOf(intPart); // Integer result\\n        StringBuilder res = new StringBuilder();\\n        if (negative) res.append(\"-\");\\n        res.append(intPart);\\n        res.append(\".\");\\n        long slow;\\n        long fast;\\n        long[] temp = new long[2];\\n        slow = Decimal(rest*10, d)[1];\\n        fast = Decimal(Decimal(rest*10, d)[1], d)[1];\\n        while (slow != fast) {\\n            slow = Decimal(slow, d)[1];\\n            fast = Decimal(Decimal(fast, d)[1], d)[1];\\n        }\\n        slow = rest * 10;\\n        while (slow != fast && slow != 0) {\\n            temp = Decimal(slow, d);\\n            slow = temp[1];\\n            res.append(temp[0]);       // non-cycle part\\n            fast = Decimal(fast, d)[1];\\n        }\\n        if (slow == 0) return res.toString();  // return when result is finite decimal\\n        temp = Decimal(slow, d);\\n        fast = temp[1];\\n        res.append(\"(\");\\n        res.append(temp[0]);\\n        while (slow != fast) {\\n            temp = Decimal(fast, d);\\n            fast = temp[1];\\n            res.append(temp[0]);  // cycle part\\n        }\\n        res.append(\")\");\\n        return res.toString();\\n    }\\n    public long[] Decimal(long rest, long denominator) {\\n        // return the quotient and remainder (multiplied by 10)\\n        long r1;\\n        long r2;\\n        if (rest < denominator) {\\n            r1 = 0;\\n            r2 = rest * 10;\\n        }\\n        else {\\n            r1 = rest / denominator;\\n            r2 = (rest - denominator * r1) * 10;\\n        }\\n        return new long[]{r1, r2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881820,
                "title": "c-hashmap-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string ans;\\n        ans = (numerator > 0)^(denominator > 0) ? \"-\":\"\";       //adding sign if either num or deno is -ve\\n        \\n        long n = abs(numerator);        //making both num and deno +ve\\n        long d = abs(denominator);\\n        ans += to_string(n/d);          \\n        \\n        n = n%d;\\n        if(!n) return ans;              //if we got remainder n = 0 then return ans else add \".\" to the ans\\n        \\n        ans += \".\";\\n        \\n        //If you find remainder again means ans from that point will start repeating from there so we map\\n        //remainder with the length pf answer at that point so that if it occur again then we can insert bracket there\\n        unordered_map<long, int> mp;\\n        \\n        while(n)        //repeat untill remainder != 0\\n        {   \\n            if(mp[n])   //if you find that this remainder has occurred before then  \\n            {\\n                ans.insert(mp[n], \"(\");    //Inserting ( at position when we first found that remainder\\n                ans += \")\";                //Inserting closing bracket at the last\\n                break;          \\n            }\\n            else{\\n                mp[n] = ans.size();     //storing when remainder n come then what is the size of ans\\n                n *= 10;\\n                ans += to_string(n/d);  \\n                n = n%d;                //calculating remainder\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string ans;\\n        ans = (numerator > 0)^(denominator > 0) ? \"-\":\"\";       //adding sign if either num or deno is -ve\\n        \\n        long n = abs(numerator);        //making both num and deno +ve\\n        long d = abs(denominator);\\n        ans += to_string(n/d);          \\n        \\n        n = n%d;\\n        if(!n) return ans;              //if we got remainder n = 0 then return ans else add \".\" to the ans\\n        \\n        ans += \".\";\\n        \\n        //If you find remainder again means ans from that point will start repeating from there so we map\\n        //remainder with the length pf answer at that point so that if it occur again then we can insert bracket there\\n        unordered_map<long, int> mp;\\n        \\n        while(n)        //repeat untill remainder != 0\\n        {   \\n            if(mp[n])   //if you find that this remainder has occurred before then  \\n            {\\n                ans.insert(mp[n], \"(\");    //Inserting ( at position when we first found that remainder\\n                ans += \")\";                //Inserting closing bracket at the last\\n                break;          \\n            }\\n            else{\\n                mp[n] = ans.size();     //storing when remainder n come then what is the size of ans\\n                n *= 10;\\n                ans += to_string(n/d);  \\n                n = n%d;                //calculating remainder\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296174,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0){\\n            return  \"0\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0){\\n            sb.append(\"-\");\\n        }\\n        \\n        long divisor = Math.abs((long)numerator);\\n        long dividend = Math.abs((long)denominator);\\n        long remainder = divisor % dividend;\\n        sb.append(divisor / dividend);\\n        \\n        if(remainder == 0){\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        while(remainder!=0){\\n            if(map.containsKey(remainder)){\\n                sb.insert(map.get(remainder), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(remainder, sb.length());\\n            remainder*= 10;\\n            sb.append(remainder/dividend);\\n            remainder%= dividend;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0){\\n            return  \"0\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1017288,
                "title": "explained-python-3-time-complexity-o-len-frac-28-ms",
                "content": "The general idea is to keep a list of the decimal and all the remainders. If the remainder is 0, return the decimal, and if the remainder started repeating, add parenthesis to the part repeating and return it.\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        times = \\'\\'\\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\\n            times = \\'-\\'\\n            numerator = abs(numerator)\\n            denominator = abs(denominator)\\n        if numerator < 0 and denominator < 0:\\n            numerator = -numerator\\n            denominator = -denominator\\n        decimal = []\\n        remainders = []\\n        while True:\\n            decimal.append(str(numerator // denominator))\\n            numerator %= denominator\\n            remainders.append(numerator)\\n            numerator *= 10\\n            \\n            if numerator == 0:\\n                if len(decimal) == 1:\\n                    return times + \\'\\'.join(decimal)\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n            \\n            if remainders.count(remainders[-1]) > 1:\\n                decimal.insert(remainders.index(remainders[-1]) + 1, \\'(\\')\\n                decimal.append(\\')\\')\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n```\\n\\t\\nthe first part is to deal with negatives (If one is negative, make a times variable to add to the start and make all the variables positive. If both are negative, just make all positive)\\nThe start of the while loop is just doing long division and adding the remainders to the remainder list.\\nThe middle of the while loop is dealing with if the denominator (numerator in this case) is 0, which I will then return the decimal because the fraction isn\\'t repeating.\\n\\nThe end part of the while part is the tricky part, and I admit it took me 15 minutes of constant submitting and bug-fixing. the if statement is checking is the remainder had the same value twice, which means the decimal is repeating. So, the demical.insert() is inserting a parenthesis at the start of when the repeating part started. For example, if decimal is \\'0.6\\' (\\'06\\' in the actual code but that doesn\\'t matter) and remainders is [2, 2] I know that the six is repeating, and insert a parenthesis right before \\'6\\'. Then i append a parenthesis at the end of the decimal to get \\'0.(6)\\', and then return it.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        times = \\'\\'\\n        if numerator < 0 and denominator > 0 or numerator > 0 and denominator < 0:\\n            times = \\'-\\'\\n            numerator = abs(numerator)\\n            denominator = abs(denominator)\\n        if numerator < 0 and denominator < 0:\\n            numerator = -numerator\\n            denominator = -denominator\\n        decimal = []\\n        remainders = []\\n        while True:\\n            decimal.append(str(numerator // denominator))\\n            numerator %= denominator\\n            remainders.append(numerator)\\n            numerator *= 10\\n            \\n            if numerator == 0:\\n                if len(decimal) == 1:\\n                    return times + \\'\\'.join(decimal)\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n            \\n            if remainders.count(remainders[-1]) > 1:\\n                decimal.insert(remainders.index(remainders[-1]) + 1, \\'(\\')\\n                decimal.append(\\')\\')\\n                return times + decimal[0] + \\'.\\' + \\'\\'.join(decimal[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922829,
                "title": "easyway-explanation-every-step",
                "content": "# ![image](https://assets.leetcode.com/users/images/3990a5fc-e26c-4b29-8268-5dce917a531d_1604464154.2853613.png)\\n\\n\\n# Quotient=numerator / denominator\\n# remainder=numerator % denominator\\n```\\nans=\"\"\\n         x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n\\n```\\n\\n# at first make  negative number to positive for make to easy .at last when original result send than handle it.\\n\\n```\\nreturn ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n\\n\\n```\\n# there is two condition if remainder is zero then skip middle of the code and return this way\\n# here numerator(x) and denominator(y)\\n\\n# Main part of the code when not zero means fractional part is present\\n\\n```\\nif r!=0:\\n          ans+=\".\"\\n```\\n# so at first put into  \".\"  reason is  this is fractional part\\n```\\n          h={}\\n```\\n# we put remainder and what is the length of the output in hasmap . it helps what is the  position  when this remainder come\\n```\\n          while r!=0:\\n                if r in h:\\n              \\n                      l=h[r]\\n                      ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n                      break\\n  ```\\n  # if your remainder present in hasmsp then modify your answer according to leetcode wanted and break .if not put break then loop goes infinity\\n  \\n  \\n```\\n            h[r]=len(ans)\\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n\\n\\n```\\n# if not present then put remainder as a key and length of output as data \\n# this is fractional part so multiple with 10 with remainder\\n# continue same process utill remaind is not zero\\n```\\n\\n\\nYour input\\n4\\n333\\n\\n\\noriginal output = 0.012012012012012012.......\\n\\n store new remainder(key) in hasmap= 4 when length of output (data)= 2 ( 0. ) hasmap= {4: 2}\\n\\n store new remainder(key) in hasmap= 40 when length of output (data)= 3 ( 0.0 ) hasmap= {4: 2, 40: 3}\\n\\n store new remainder(key) in hasmap= 67 when length of output (data)= 4 ( 0.01 ) hasmap= {4: 2, 40: 3, 67: 4}\\n\\n repeated remainder= 4 repeated position= 2\\n{4: 2, 40: 3, 67: 4}\\n\\nOutput\\n\"0.(012)\"\\nExpected\\n\\n```\\n```\\n\\nYour input\\n622\\n495\\noriginal output = 1.256565656565656......\\n\\n store new remainder(key) in hasmap= 127 when length of output (data)= 2 ( 1. ) hasmap= {127: 2}\\n\\n store new remainder(key) in hasmap= 280 when length of output (data)= 3 ( 1.2 ) hasmap= {127: 2, 280: 3}\\n\\n store new remainder(key) in hasmap= 325 when length of output (data)= 4 ( 1.25 ) hasmap= {127: 2, 280: 3, 325: 4}\\n\\n repeated remainder= 280 repeated position= 3\\n{127: 2, 280: 3, 325: 4}\\n\\nOutput\\n\"1.2(56)\"\\nExpected\\n\"1.2(56)\"\\n\\nRun Code\\n\\n\\n\\n\\n```\\n\\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, n, d):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        \\n        x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n        \\n        if r!=0:\\n          ans+=\".\"\\n          h={}\\n          while r!=0:\\n            \\n            if r in h:\\n              \\n              l=h[r]\\n              ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n              break\\n              \\n            h[r]=len(ans)\\n            \\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n        \\n        return ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n            \\n          \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nans=\"\"\\n         x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n\\n```\n```\\nreturn ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n\\n\\n```\n```\\nif r!=0:\\n          ans+=\".\"\\n```\n```\\n          h={}\\n```\n```\\n          while r!=0:\\n                if r in h:\\n              \\n                      l=h[r]\\n                      ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n                      break\\n  ```\n```\\n            h[r]=len(ans)\\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n\\n\\n```\n```\\n\\n\\nYour input\\n4\\n333\\n\\n\\noriginal output = 0.012012012012012012.......\\n\\n store new remainder(key) in hasmap= 4 when length of output (data)= 2 ( 0. ) hasmap= {4: 2}\\n\\n store new remainder(key) in hasmap= 40 when length of output (data)= 3 ( 0.0 ) hasmap= {4: 2, 40: 3}\\n\\n store new remainder(key) in hasmap= 67 when length of output (data)= 4 ( 0.01 ) hasmap= {4: 2, 40: 3, 67: 4}\\n\\n repeated remainder= 4 repeated position= 2\\n{4: 2, 40: 3, 67: 4}\\n\\nOutput\\n\"0.(012)\"\\nExpected\\n\\n```\n```\\n\\nYour input\\n622\\n495\\noriginal output = 1.256565656565656......\\n\\n store new remainder(key) in hasmap= 127 when length of output (data)= 2 ( 1. ) hasmap= {127: 2}\\n\\n store new remainder(key) in hasmap= 280 when length of output (data)= 3 ( 1.2 ) hasmap= {127: 2, 280: 3}\\n\\n store new remainder(key) in hasmap= 325 when length of output (data)= 4 ( 1.25 ) hasmap= {127: 2, 280: 3, 325: 4}\\n\\n repeated remainder= 280 repeated position= 3\\n{127: 2, 280: 3, 325: 4}\\n\\nOutput\\n\"1.2(56)\"\\nExpected\\n\"1.2(56)\"\\n\\nRun Code\\n\\n\\n\\n\\n```\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, n, d):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        \\n        x,y=n,d\\n        n,d=abs(n),abs(d)\\n        q=n//d\\n        r=n%d\\n        ans+=str(q)\\n        \\n        if r!=0:\\n          ans+=\".\"\\n          h={}\\n          while r!=0:\\n            \\n            if r in h:\\n              \\n              l=h[r]\\n              ans=ans[0:l]+\"(\"+ans[l:]+\")\"\\n              break\\n              \\n            h[r]=len(ans)\\n            \\n            r*=10\\n            q=r//d\\n            r=r%d\\n            \\n            ans+=str(q)\\n        \\n        return ans if (x>0 and  y>0) or (x<0 and y<0) or x==0 else \"-\"+ ans\\n            \\n          \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 292716,
                "title": "c-dictionary-and-while",
                "content": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator) {\\n        return FractionToDecimalLong((long)numerator, (long)denominator);\\n    }\\n\\n    private string FractionToDecimalLong(long numerator, long denominator) {\\n        var isNegative = false;\\n        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {\\n            isNegative = true;\\n        }\\n\\n        numerator = Math.Abs(numerator);\\n        denominator = Math.Abs(denominator);\\n\\n        var integerPart = numerator / denominator;\\n\\n        var floatPart = \"\";\\n\\n        var remainderAndIndex = new Dictionary<long, int>();\\n        var remainder = numerator % denominator;\\n\\n        if (remainder == 0) return isNegative ? $\"-{integerPart}\" : $\"{integerPart}\";\\n\\n        var i = 0;\\n\\n        while (remainder != 0) {\\n            remainderAndIndex[remainder] = i;\\n            i++;\\n            remainder *= 10;\\n            floatPart = $\"{floatPart}{remainder / denominator}\";\\n            remainder = remainder % denominator;\\n            if (remainderAndIndex.ContainsKey(remainder)) {\\n                floatPart = floatPart.Insert(remainderAndIndex[remainder], \"(\");\\n                floatPart += \")\";\\n                break;\\n            }\\n        }\\n\\n        if (isNegative) {\\n            return $\"-{integerPart}.{floatPart}\";\\n        }\\n\\n        return $\"{integerPart}.{floatPart}\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator) {\\n        return FractionToDecimalLong((long)numerator, (long)denominator);\\n    }\\n\\n    private string FractionToDecimalLong(long numerator, long denominator) {\\n        var isNegative = false;\\n        if ((numerator > 0 && denominator < 0) || (numerator < 0 && denominator > 0)) {\\n            isNegative = true;\\n        }\\n\\n        numerator = Math.Abs(numerator);\\n        denominator = Math.Abs(denominator);\\n\\n        var integerPart = numerator / denominator;\\n\\n        var floatPart = \"\";\\n\\n        var remainderAndIndex = new Dictionary<long, int>();\\n        var remainder = numerator % denominator;\\n\\n        if (remainder == 0) return isNegative ? $\"-{integerPart}\" : $\"{integerPart}\";\\n\\n        var i = 0;\\n\\n        while (remainder != 0) {\\n            remainderAndIndex[remainder] = i;\\n            i++;\\n            remainder *= 10;\\n            floatPart = $\"{floatPart}{remainder / denominator}\";\\n            remainder = remainder % denominator;\\n            if (remainderAndIndex.ContainsKey(remainder)) {\\n                floatPart = floatPart.Insert(remainderAndIndex[remainder], \"(\");\\n                floatPart += \")\";\\n                break;\\n            }\\n        }\\n\\n        if (isNegative) {\\n            return $\"-{integerPart}.{floatPart}\";\\n        }\\n\\n        return $\"{integerPart}.{floatPart}\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51122,
                "title": "java-1ms-without-using-hash-table",
                "content": "  Actually there is no need to use a hash table.\\n\\n  I get this inspiration from the problem NO.142, Linked list Cycle II, imagine every remainder you take as a node when you perform the division. When you get the recurring decimals, the pattern will be the same as the pattern mentioned in Linked list Cydle II(Find the node which the cycle starts).\\n \\n  How to find that node we want? Suppose we have n nodes who are not in the cycle and m nodes who are in the cycle. We create two pointers. The first one moves one nodes per step, the second one moves two nodes per step. When the first one reaches the node that we want, the second one is n nodes ahead. For the second node, if it want to catch up the first node, it will have to move m-n steps ahead. So far the first node have moved for (m-n+n) = m steps and there are (m+n-m) = n steps left to reach the node which starts the cycle. The same thing is, it will take exactly n steps for the first node to reach that node. So we could use a pointer start from the beginning of the list and move all of them one nodes per step. When they reach the same node. That node is the node we want.\\n\\n  The actual code is as follows.\\n\\npublic class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator==Integer.MIN_VALUE&&denominator==-1)\\n            return \"2147483648\";\\n        int dummy = numerator/denominator, lef = numerator%denominator;\\n        String str = dummy+\"\";\\n        if(dummy==0){\\n            if((numerator>0&&denominator<0)||(numerator<0&&denominator>0))\\n            str = \"-\" + str; // 0 does not have a negative mark in front of it, so we have to add that.\\n        }\\n        if(lef==0) return str; // this indicates the result is an integer.\\n        \\n        StringBuilder sb = new StringBuilder();\\n        sb.append(str);\\n        sb.append(\".\");\\n        long left = lef<0? -lef : lef;\\n        long denomin = denominator<0? -denominator : denominator;\\n        if(denominator==Integer.MIN_VALUE){\\n            denomin = Integer.MAX_VALUE;\\n            denomin++; // without this, when the denominator is -214748648, it will cause a overflow.\\n        }\\n        long slow = mod(left,denomin), fast = mod(mod(left,denomin),denomin);\\n        if(slow==0){ // no need to start the loop.\\n            left = extend(left,denomin,sb);\\n            return sb.toString();\\n        }\\n        \\n        while(slow!=fast){\\n            if(fast==0){  // this indicates there are no cycles.\\n                while(left!=0)\\n                    left = extend(left,denomin,sb);\\n                return sb.toString();\\n            }\\n            slow = mod(slow,denomin);\\n            fast = mod(mod(fast,denomin),denomin);\\n        }\\n        \\n        slow = left;\\n        while(slow!=fast){\\n            slow = mod(slow,denomin);\\n            fast = mod(fast,denomin);\\n        }\\n        while(left!=slow)\\n            left = extend(left,denomin,sb);\\n        sb.append(\"(\"); // the start of the cycle.\\n        left = extend(left,denomin,sb);\\n        while(left!=slow)\\n            left = extend(left,denomin,sb);\\n        sb.append(\")\");\\n        return sb.toString();\\n    }\\n    \\n    private long mod(long left, long denominator){\\n        left = left * 10;      \\n        return left%denominator;    \\n    }\\n    \\n    private long extend(long left, long denominator, StringBuilder sb){\\n        left = left * 10;      \\n        sb.append(left/denominator);\\n        return left%denominator;\\n    }\\n\\n }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator==Integer.MIN_VALUE&&denominator==-1)\\n            return \"2147483648\";\\n        int dummy = numerator/denominator, lef = numerator%denominator;\\n        String str = dummy+\"\";\\n        if(dummy==0){\\n            if((numerator>0&&denominator<0)||(numerator<0&&denominator>0))\\n            str = \"-\" + str; // 0 does not have a negative mark in front of it, so we have to add that.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2405774,
                "title": "c-unordered-map-0ms-time",
                "content": "**C++ Implementation**\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        int cnt = 0;\\n        if(n == 0) return \"0\";\\n        if(n < 0) cnt++;\\n        if(d < 0) cnt++;\\n        n = abs(n);\\n        d = abs(d);        \\n        long long rem = n%d;\\n        long long q = n/d;\\n        string ans = \"\";\\n        ans += to_string(q);\\n        if(rem == 0) {\\n            if(cnt == 1) return \"-\"+ans;\\n            else return ans;\\n        }\\n        unordered_map<int,int>mp;\\n        ans += \".\";\\n        while(rem != 0){\\n            if(mp.find(rem) != mp.end()){\\n                int len = mp[rem];\\n                string s1 = ans.substr(0,len);\\n                string s2 = ans.substr(len);\\n                ans = s1+\"(\"+s2+\")\";\\n                break;\\n            }\\n            else{\\n                mp[rem] = ans.size();\\n                rem *= 10;\\n                q = rem/d;\\n                rem = rem%d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(cnt == 1) return \"-\"+ans;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please like my solution**\\n**HAPPY CODING**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        int cnt = 0;\\n        if(n == 0) return \"0\";\\n        if(n < 0) cnt++;\\n        if(d < 0) cnt++;\\n        n = abs(n);\\n        d = abs(d);        \\n        long long rem = n%d;\\n        long long q = n/d;\\n        string ans = \"\";\\n        ans += to_string(q);\\n        if(rem == 0) {\\n            if(cnt == 1) return \"-\"+ans;\\n            else return ans;\\n        }\\n        unordered_map<int,int>mp;\\n        ans += \".\";\\n        while(rem != 0){\\n            if(mp.find(rem) != mp.end()){\\n                int len = mp[rem];\\n                string s1 = ans.substr(0,len);\\n                string s2 = ans.substr(len);\\n                ans = s1+\"(\"+s2+\")\";\\n                break;\\n            }\\n            else{\\n                mp[rem] = ans.size();\\n                rem *= 10;\\n                q = rem/d;\\n                rem = rem%d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(cnt == 1) return \"-\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209251,
                "title": "cpp-string-map",
                "content": "```\\nstring fractionToDecimal(int num, int den) {\\n\\t//WV recommended\\n\\tbool isNegative = false;\\n\\tint newNum = num;\\n\\tint newDen = den;\\n\\tif (num < 0 or den < 0) {\\n\\t\\tisNegative = true;\\n\\t\\tnewNum = abs(num);\\n\\t\\tnewDen = abs(den);\\n\\t}\\n\\tif (num < 0 and den < 0) {\\n\\t\\t//coz, dono - hai to ek doosre ko cancel kr dege\\n\\t\\tisNegative = false;\\n\\t}\\n\\n\\tstring ans = \"\";\\n\\tlong long quotent = newNum / newDen;\\n\\tlong long rem = newNum % newDen;\\n\\tans += to_string(abs(quotent));\\n\\n\\tif (rem == 0) {\\n\\t\\tif (isNegative and ans != \"0\") {\\n\\t\\t\\tans.insert(0, \"-\");\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\telse { //rem != 0\\n\\t\\tans += \".\"; // decimal lga dia\\n\\t\\tmap<long long, long long> mp; //rem,position(index)\\n\\t\\t// cout << \"test \" << ans << endl;\\n\\t\\twhile (rem != 0) {\\n\\t\\t\\tif (mp.find(rem) != mp.end()) { //found\\n\\t\\t\\t\\t//means remainder repeat hua h, recurring decimal exist(WV). so add \"(\" at position(from map) and \")\" at the end\\n\\t\\t\\t\\tlong long len = mp[rem];\\n\\t\\t\\t\\tans.insert(len, \"(\");\\n\\t\\t\\t\\tans += \")\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse { //not found\\n\\t\\t\\t\\tmp[rem] = ans.size();\\n\\t\\t\\t\\trem *= 10; //decimal lga hai toh zero add krte h, jaese actual divide krte time krte h(WV)\\n\\t\\t\\t\\tquotent = rem / newDen;\\n\\t\\t\\t\\trem = rem % newDen;\\n\\t\\t\\t\\tans += to_string(abs(quotent));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (isNegative) {\\n\\t\\tcout << \"test \" << ans << endl;\\n\\t\\tans.insert(0, \"-\");\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nstring fractionToDecimal(int num, int den) {\\n\\t//WV recommended\\n\\tbool isNegative = false;\\n\\tint newNum = num;\\n\\tint newDen = den;\\n\\tif (num < 0 or den < 0) {\\n\\t\\tisNegative = true;\\n\\t\\tnewNum = abs(num);\\n\\t\\tnewDen = abs(den);\\n\\t}\\n\\tif (num < 0 and den < 0) {\\n\\t\\t//coz, dono - hai to ek doosre ko cancel kr dege\\n\\t\\tisNegative = false;\\n\\t}\\n\\n\\tstring ans = \"\";\\n\\tlong long quotent = newNum / newDen;\\n\\tlong long rem = newNum % newDen;\\n\\tans += to_string(abs(quotent));\\n\\n\\tif (rem == 0) {\\n\\t\\tif (isNegative and ans != \"0\") {\\n\\t\\t\\tans.insert(0, \"-\");\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\telse { //rem != 0\\n\\t\\tans += \".\"; // decimal lga dia\\n\\t\\tmap<long long, long long> mp; //rem,position(index)\\n\\t\\t// cout << \"test \" << ans << endl;\\n\\t\\twhile (rem != 0) {\\n\\t\\t\\tif (mp.find(rem) != mp.end()) { //found\\n\\t\\t\\t\\t//means remainder repeat hua h, recurring decimal exist(WV). so add \"(\" at position(from map) and \")\" at the end\\n\\t\\t\\t\\tlong long len = mp[rem];\\n\\t\\t\\t\\tans.insert(len, \"(\");\\n\\t\\t\\t\\tans += \")\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse { //not found\\n\\t\\t\\t\\tmp[rem] = ans.size();\\n\\t\\t\\t\\trem *= 10; //decimal lga hai toh zero add krte h, jaese actual divide krte time krte h(WV)\\n\\t\\t\\t\\tquotent = rem / newDen;\\n\\t\\t\\t\\trem = rem % newDen;\\n\\t\\t\\t\\tans += to_string(abs(quotent));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (isNegative) {\\n\\t\\tcout << \"test \" << ans << endl;\\n\\t\\tans.insert(0, \"-\");\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "C++"
            },
            {
                "id": 1387484,
                "title": "java-using-hashmap-faster-than-100",
                "content": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator==0) return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //negative case\\n        if (numerator>0 && denominator<0 || numerator<0 && denominator>0) {\\n            sb.append(\"-\");\\n        }\\n        \\n        long x = Math.abs(Long.valueOf(numerator));\\n        long y = Math.abs(Long.valueOf(denominator));\\n        \\n        sb.append(String.valueOf(x/y));\\n        \\n        long remainder = x%y;\\n        if (remainder==0) {\\n            return sb.toString();\\n        }\\n        \\n        //decimal case\\n        sb.append(\".\");\\n\\t\\t\\n\\t\\t//store the remainder in a Hashmap because in the case of recurring decimal, the remainder repeats as dividend.\\n        Map<Long,Integer> map = new HashMap<>();\\n        while (remainder != 0) {\\n            if (map.containsKey(remainder)){\\n                sb.insert(map.get(remainder), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n\\t\\t\\t//store the remainder and the index of it\\'s occurence in the String\\n            map.put(remainder, sb.length());\\n            remainder *= 10;\\n            sb.append(String.valueOf(remainder/y));\\n            remainder %= y;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator==0) return \"0\";\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //negative case\\n        if (numerator>0 && denominator<0 || numerator<0 && denominator>0) {\\n            sb.append(\"-\");\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1261844,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(long numerator, long denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        bool negative = numerator<0 ^ denominator<0;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        string integer = (negative?\"-\":\"\") + to_string(numerator/denominator);\\n        numerator %= denominator;\\n        \\n        unordered_map<int, int> seen;\\n        string decimal = \".\";\\n        while (numerator != 0) {\\n            numerator *= 10;\\n            decimal += to_string(numerator/denominator);\\n            numerator %= denominator;\\n            if (seen[numerator]) {\\n                decimal.insert(seen[numerator], \"(\");\\n                decimal += \")\";\\n                break;\\n            }\\n            seen[numerator] = decimal.size();\\n        }\\n        \\n        if (decimal.size() == 1) return integer;\\n        else return integer + decimal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(long numerator, long denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        bool negative = numerator<0 ^ denominator<0;\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        string integer = (negative?\"-\":\"\") + to_string(numerator/denominator);\\n        numerator %= denominator;\\n        \\n        unordered_map<int, int> seen;\\n        string decimal = \".\";\\n        while (numerator != 0) {\\n            numerator *= 10;\\n            decimal += to_string(numerator/denominator);\\n            numerator %= denominator;\\n            if (seen[numerator]) {\\n                decimal.insert(seen[numerator], \"(\");\\n                decimal += \")\";\\n                break;\\n            }\\n            seen[numerator] = decimal.size();\\n        }\\n        \\n        if (decimal.size() == 1) return integer;\\n        else return integer + decimal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833246,
                "title": "simple-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long num = numerator;\\n        long deno = denominator;\\n        boolean negtive = (double)num/deno < 0 ? true:false;\\n        num = Math.abs(num);\\n        deno = Math.abs(deno);\\n        String res = negtive? \"-\"+num/deno : num/deno+\"\";\\n        if(num % deno == 0) \\n            return res;\\n        String decimal = \"\";\\n        num = (num % deno) * 10;\\n        HashMap<Long, Integer> mods = new HashMap();\\n        int index = 0;\\n        while(!mods.containsKey(num) && num != 0){\\n            mods.put(num, index++);\\n            decimal += num/deno;\\n            num = (num % deno) * 10;\\n        }\\n        if(num == 0) return res+\".\"+decimal;\\n        int i = mods.get(num);\\n        res += \".\" + decimal.substring(0, i) + \"(\" + decimal.substring(i) + \")\";\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long num = numerator;\\n        long deno = denominator;\\n        boolean negtive = (double)num/deno < 0 ? true:false;\\n        num = Math.abs(num);\\n        deno = Math.abs(deno);\\n        String res = negtive? \"-\"+num/deno : num/deno+\"\";\\n        if(num % deno == 0) \\n            return res;\\n        String decimal = \"\";\\n        num = (num % deno) * 10;\\n        HashMap<Long, Integer> mods = new HashMap();\\n        int index = 0;\\n        while(!mods.containsKey(num) && num != 0){\\n            mods.put(num, index++);\\n            decimal += num/deno;\\n            num = (num % deno) * 10;\\n        }\\n        if(num == 0) return res+\".\"+decimal;\\n        int i = mods.get(num);\\n        res += \".\" + decimal.substring(0, i) + \"(\" + decimal.substring(i) + \")\";\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793983,
                "title": "c-beats-100-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0 || denominator == 0) {\\n            return \"0\";\\n        }\\n        \\n        long num = labs(numerator);\\n        long den = labs(denominator);\\n        \\n        string cur = \"\";\\n        \\n        if(numerator < 0 ^ denominator < 0) {\\n            cur += \"-\";\\n        }\\n        \\n        cur += to_string(num / den);\\n        \\n        if(num % den == 0) {\\n            return cur;\\n        }\\n        num %= den;\\n        \\n        cur += \".\";\\n        \\n        \\n        unordered_map<long, int> seen;\\n        \\n        while(num > 0) {\\n            if(seen.find(num) != seen.end()) {\\n                cur.insert(seen[num], 1, \\'(\\');\\n                cur += \")\";\\n                return cur;\\n            }\\n            \\n            seen[num] = cur.size();\\n            num *= 10;\\n            cur += to_string(num / den);\\n            num %= den;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0 || denominator == 0) {\\n            return \"0\";\\n        }\\n        \\n        long num = labs(numerator);\\n        long den = labs(denominator);\\n        \\n        string cur = \"\";\\n        \\n        if(numerator < 0 ^ denominator < 0) {\\n            cur += \"-\";\\n        }\\n        \\n        cur += to_string(num / den);\\n        \\n        if(num % den == 0) {\\n            return cur;\\n        }\\n        num %= den;\\n        \\n        cur += \".\";\\n        \\n        \\n        unordered_map<long, int> seen;\\n        \\n        while(num > 0) {\\n            if(seen.find(num) != seen.end()) {\\n                cur.insert(seen[num], 1, \\'(\\');\\n                cur += \")\";\\n                return cur;\\n            }\\n            \\n            seen[num] = cur.size();\\n            num *= 10;\\n            cur += to_string(num / den);\\n            num %= den;\\n        }\\n        \\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51200,
                "title": "my-python-code-without-using-extra-space",
                "content": "The idea is pretty simple, the question is essentially the same with \"Find the start point of a linked list cycle\". I used the fast pointer and slow pointer trick.\\nBelow is my code with some explanation:\\n\\n    def fractionToDecimal(self, numerator, denominator):\\n        n = numerator\\n        d = denominator\\n        if n % d == 0:\\n            return str(n//d)\\n        # Deal with negatives\\n        if (abs(n)/n) * (abs(d)/d) < 0:\\n            res = '-'\\n            n = abs(n)\\n            d = abs(d)\\n        else:\\n            res = ''\\n        # Integer part\\n        res = res + str(n//d) + '.'\\n        n = n % d\\n        # Start point of the \"list\"\\n        frem = n\\n        srem = n\\n        firstTime = True\\n        while frem != 0 and not (firstTime == False and frem == srem):\\n            firstTime = False\\n            srem = (srem * 10) % d\\n            frem = (frem * 10) % d\\n            if frem:\\n                frem = (frem * 10) % d\\n        # The fast pointer encounters a remainder of 0, so no cycle in the \"list\"\\n        if frem == 0:\\n            res += str((n * 10) // d)\\n            rem = (n * 10) % d\\n            while rem:\\n                res += str((rem * 10) // d)\\n                rem = (rem * 10) % d\\n            return res\\n        else:\\n            # Find the start point of the cycle, meanwhile, generate the non recurring part\\n            srem = n\\n            while frem != srem:\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n                frem = (frem * 10) % d\\n            res += '('\\n            # Generate the recurring part\\n            firstTime = True\\n            while not (firstTime == False and srem == frem):\\n                firstTime = False\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n            res += ')'\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is pretty simple, the question is essentially the same with \"Find the start point of a linked list cycle\". I used the fast pointer and slow pointer trick.\\nBelow is my code with some explanation:\\n\\n    def fractionToDecimal(self, numerator, denominator):\\n        n = numerator\\n        d = denominator\\n        if n % d == 0:\\n            return str(n//d)\\n        # Deal with negatives\\n        if (abs(n)/n) * (abs(d)/d) < 0:\\n            res = '-'\\n            n = abs(n)\\n            d = abs(d)\\n        else:\\n            res = ''\\n        # Integer part\\n        res = res + str(n//d) + '.'\\n        n = n % d\\n        # Start point of the \"list\"\\n        frem = n\\n        srem = n\\n        firstTime = True\\n        while frem != 0 and not (firstTime == False and frem == srem):\\n            firstTime = False\\n            srem = (srem * 10) % d\\n            frem = (frem * 10) % d\\n            if frem:\\n                frem = (frem * 10) % d\\n        # The fast pointer encounters a remainder of 0, so no cycle in the \"list\"\\n        if frem == 0:\\n            res += str((n * 10) // d)\\n            rem = (n * 10) % d\\n            while rem:\\n                res += str((rem * 10) // d)\\n                rem = (rem * 10) % d\\n            return res\\n        else:\\n            # Find the start point of the cycle, meanwhile, generate the non recurring part\\n            srem = n\\n            while frem != srem:\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n                frem = (frem * 10) % d\\n            res += '('\\n            # Generate the recurring part\\n            firstTime = True\\n            while not (firstTime == False and srem == frem):\\n                firstTime = False\\n                res += str((srem * 10) // d)\\n                srem = (srem * 10) % d\\n            res += ')'\\n            return res",
                "codeTag": "Python3"
            },
            {
                "id": 51228,
                "title": "my-java-solution",
                "content": "basic idea:\\n\\n1. for the input integer: positive and negative number matters? => yes, so check the sign first\\n\\n2. can get integer part directly by a/b, then deal with decimal part\\n\\n3. get remainder by a%b. the problem is: how to check the decimal part is repeated (or not)?\\n\\n4. for each loop, we can get the digit by remainder*10/b and update new remainder=remainder*10%b, if we get the same remainder again, previous result is repeated\\n\\n5. so, use a set to store the remainder(s) that already appeared and use queue to store int sequence that need to append to res\\n\\n6. check remainder for each loop, if 0, poll all elem in queue, if set contains the remainder (q...)\\n\\n7. but... the question comes again: example, if result is 0.123454545 or 1/7 = 0.123454545, need a parameter to store which digit the res starts to repeat.. extra info is needed when we store the remainder to \"locate\" its position\\n\\n8. back to step 5, define the map instead of set to store <remainder, position> position=i (each loop i++)\\n\\t\\n9. at last, check the remainder to know whether it's belong to \"recurring\" result or not\\n\\n\\n        public static String fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tString res = \"\";\\n    \\t\\tlong a = Math.abs((long) numerator);\\n    \\t\\tlong b = Math.abs((long) denominator);\\n    \\t\\tif ((denominator < 0 && numerator > 0) || (denominator > 0 && numerator < 0)) {\\n    \\t\\t\\tres += \"-\";\\n    \\t\\t}\\n    \\t\\tlong intPart= a / b;\\n    \\t\\tres += intPart;\\n    \\t\\tif (a % b == 0) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tres += \".\";\\n    \\t\\tlong remainder = a % b;\\n    \\t\\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n    \\t\\tint i = 1;\\n    \\t\\tmap.put(remainder, 1);\\n    \\t\\tQueue<Long> queue = new LinkedList<Long>();\\n    \\t\\tint begin = -1;\\n    \\t\\twhile (remainder != 0) {\\n    \\t\\t\\ti++;\\n    \\t\\t\\tlong tmp = remainder * 10 / b;\\n    \\t\\t\\tremainder = remainder * 10 % b;\\n    \\t\\t\\tif (map.containsKey(remainder)) {\\n    \\t\\t\\t\\tbegin = map.get(remainder);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tmap.put(remainder, i);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (remainder == 0) {\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tres += queue.poll();\\n    \\t\\t\\t}\\n    \\t\\t} else {\\n    \\t\\t\\tint j = 1;\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tlong cur = queue.poll();\\n    \\t\\t\\t\\tif (j != begin) {\\n    \\t\\t\\t\\t\\tres += cur;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tres = res + \"(\" + cur;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t\\tres += \")\";\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n\\na little optimization can be done: define stringbuilder as the result",
                "solutionTags": [
                    "Java"
                ],
                "code": "basic idea:\\n\\n1. for the input integer: positive and negative number matters? => yes, so check the sign first\\n\\n2. can get integer part directly by a/b, then deal with decimal part\\n\\n3. get remainder by a%b. the problem is: how to check the decimal part is repeated (or not)?\\n\\n4. for each loop, we can get the digit by remainder*10/b and update new remainder=remainder*10%b, if we get the same remainder again, previous result is repeated\\n\\n5. so, use a set to store the remainder(s) that already appeared and use queue to store int sequence that need to append to res\\n\\n6. check remainder for each loop, if 0, poll all elem in queue, if set contains the remainder (q...)\\n\\n7. but... the question comes again: example, if result is 0.123454545 or 1/7 = 0.123454545, need a parameter to store which digit the res starts to repeat.. extra info is needed when we store the remainder to \"locate\" its position\\n\\n8. back to step 5, define the map instead of set to store <remainder, position> position=i (each loop i++)\\n\\t\\n9. at last, check the remainder to know whether it's belong to \"recurring\" result or not\\n\\n\\n        public static String fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tString res = \"\";\\n    \\t\\tlong a = Math.abs((long) numerator);\\n    \\t\\tlong b = Math.abs((long) denominator);\\n    \\t\\tif ((denominator < 0 && numerator > 0) || (denominator > 0 && numerator < 0)) {\\n    \\t\\t\\tres += \"-\";\\n    \\t\\t}\\n    \\t\\tlong intPart= a / b;\\n    \\t\\tres += intPart;\\n    \\t\\tif (a % b == 0) {\\n    \\t\\t\\treturn res;\\n    \\t\\t}\\n    \\t\\tres += \".\";\\n    \\t\\tlong remainder = a % b;\\n    \\t\\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n    \\t\\tint i = 1;\\n    \\t\\tmap.put(remainder, 1);\\n    \\t\\tQueue<Long> queue = new LinkedList<Long>();\\n    \\t\\tint begin = -1;\\n    \\t\\twhile (remainder != 0) {\\n    \\t\\t\\ti++;\\n    \\t\\t\\tlong tmp = remainder * 10 / b;\\n    \\t\\t\\tremainder = remainder * 10 % b;\\n    \\t\\t\\tif (map.containsKey(remainder)) {\\n    \\t\\t\\t\\tbegin = map.get(remainder);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tmap.put(remainder, i);\\n    \\t\\t\\t\\tqueue.offer(tmp);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tif (remainder == 0) {\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tres += queue.poll();\\n    \\t\\t\\t}\\n    \\t\\t} else {\\n    \\t\\t\\tint j = 1;\\n    \\t\\t\\twhile (!queue.isEmpty()) {\\n    \\t\\t\\t\\tlong cur = queue.poll();\\n    \\t\\t\\t\\tif (j != begin) {\\n    \\t\\t\\t\\t\\tres += cur;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tres = res + \"(\" + cur;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tj++;\\n    \\t\\t\\t}\\n    \\t\\t\\tres += \")\";\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n\\na little optimization can be done: define stringbuilder as the result",
                "codeTag": "Unknown"
            },
            {
                "id": 3472668,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires converting a fraction to a decimal representation. If the decimal representation is finite, then the output is simply the quotient of the numerator and denominator. Otherwise, we need to represent the repeating decimal with a set of parentheses. We can detect the repeating part by using a hash table to keep track of the remainders and the corresponding position of the quotient where the remainder appears.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by checking if the numerator or denominator is negative. If both are negative, then we convert them to positive. We then calculate the quotient of the numerator and denominator using the integer division. If the remainder is 0, then the output is simply the quotient.\\n\\nIf the remainder is non-zero, we append a decimal point to the quotient and calculate the fractional part. We keep track of the remainders and corresponding positions of the quotient where the remainders appear. If we encounter a remainder that we have seen before, we know that the decimal expansion repeats. We can then insert the opening and closing parentheses around the repeating part of the quotient.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the algorithm is $$O(d)$$, where d is the number of digits in the repeating part of the decimal expansion. This is because we need to perform integer division and multiplication for each digit in the decimal expansion.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is $$O(d)$$, where d is the number of digits in the repeating part of the decimal expansion. This is because we need to store the remainders and corresponding positions of the quotient where the remainders appear in a hash table.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111158,
                "title": "o-n-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFractions are repeated due to recurring numerator and denominator\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave the numerator encounterd along with its posistion in the remainder string when it was encountered. When the remainder is found in hash map. Just break and add brances to the string in beetween\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    10^4  (O(n))      *             O(1)             +     O(N)\\n    MAX_STR_LENGTH    *   HASH SEARCH FOR REMAINDER  +  STRING COPY\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(N)          +    2 * O(N)       + c\\n    (HASH MAP)    +     STRINGS\\n\\nOne can optimize by using single string and soing string manipulations at the end\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        std::string ans;\\n        std::string final_ans; \\n        if((numerator<0&&denominator>0) ||(numerator>0&&denominator<0))\\n        {\\n        ans.append(\"-\");\\n        }\\n        long int d= abs(denominator);\\n        long int n=abs(numerator);\\n        \\n        ans = ans+std::to_string((long int)(n/d));\\n        std::unordered_map<long,int> m;\\n        long int remainder = n%d;\\n        if(remainder!=0)\\n        {\\n            ans.append(\".\");\\n            while(ans.size()<10001)\\n            {\\n                if(remainder ==0 ||m.find(remainder)!=m.end())\\n                {\\n                    break;\\n                }\\n                m[remainder] = ans.size();\\n                long int t= (remainder*10)/d;\\n                ans.append(std::to_string(t));\\n                remainder = (remainder*10)%d;\\n            }\\n            if(m.find(remainder)!=m.end())\\n            {\\n                final_ans = ans.substr(0,m[remainder]) \\n                + \"(\"+\\n                ans.substr(m[remainder])\\n                +\")\";\\n            }\\n            else{\\n                final_ans = ans;\\n            }\\n        }\\n        else\\n        final_ans = ans;\\n        return final_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        std::string ans;\\n        std::string final_ans; \\n        if((numerator<0&&denominator>0) ||(numerator>0&&denominator<0))\\n        {\\n        ans.append(\"-\");\\n        }\\n        long int d= abs(denominator);\\n        long int n=abs(numerator);\\n        \\n        ans = ans+std::to_string((long int)(n/d));\\n        std::unordered_map<long,int> m;\\n        long int remainder = n%d;\\n        if(remainder!=0)\\n        {\\n            ans.append(\".\");\\n            while(ans.size()<10001)\\n            {\\n                if(remainder ==0 ||m.find(remainder)!=m.end())\\n                {\\n                    break;\\n                }\\n                m[remainder] = ans.size();\\n                long int t= (remainder*10)/d;\\n                ans.append(std::to_string(t));\\n                remainder = (remainder*10)%d;\\n            }\\n            if(m.find(remainder)!=m.end())\\n            {\\n                final_ans = ans.substr(0,m[remainder]) \\n                + \"(\"+\\n                ans.substr(m[remainder])\\n                +\")\";\\n            }\\n            else{\\n                final_ans = ans;\\n            }\\n        }\\n        else\\n        final_ans = ans;\\n        return final_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746780,
                "title": "like-pen-paper-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, nu: int, de: int) -> str:\\n        cf=\"\"\\n        if(nu*de<0):\\n            cf=\"-\"\\n        nu=abs(nu)\\n        de=abs(de)\\n        st1=nu//de\\n        re=abs(nu%de)\\n        st1=str(st1)\\n        st2=\"\"\\n        i=0\\n        dc={}\\n        while(re>0):\\n            if(re<de):\\n                re*=10\\n            if((re,de) in dc):\\n                st2=st2[:dc[(re,de)]]+\"(\"+st2[dc[(re,de)]:]+\")\"\\n                break\\n            dc[(re,de)]=i\\n            i+=1\\n            st2+=str(re//de)\\n            re=re%de\\n        if(st2==\"\"):\\n            return cf+st1\\n        return(cf+st1+\".\"+st2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, nu: int, de: int) -> str:\\n        cf=\"\"\\n        if(nu*de<0):\\n            cf=\"-\"\\n        nu=abs(nu)\\n        de=abs(de)\\n        st1=nu//de\\n        re=abs(nu%de)\\n        st1=str(st1)\\n        st2=\"\"\\n        i=0\\n        dc={}\\n        while(re>0):\\n            if(re<de):\\n                re*=10\\n            if((re,de) in dc):\\n                st2=st2[:dc[(re,de)]]+\"(\"+st2[dc[(re,de)]:]+\")\"\\n                break\\n            dc[(re,de)]=i\\n            i+=1\\n            st2+=str(re//de)\\n            re=re%de\\n        if(st2==\"\"):\\n            return cf+st1\\n        return(cf+st1+\".\"+st2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419439,
                "title": "c-taking-care-of-minor-edge-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        if(n==0)    return \"0\";\\n        if(d==1)    return to_string(n);\\n        if(d==-1)    return to_string((long)fabs(n));\\n        string ans=\"\";\\n        if((n<0 && d>0) || (n>0 && d<0))    ans += \"-\";\\n        n = abs(n);\\n        d = abs(d);\\n        ans += to_string(n/d);\\n        long long rem = n%d;\\n        if(!rem)    return ans;\\n        else    ans += \".\";\\n        unordered_map<int,int>num;\\n        while(rem!=0)\\n        {\\n            if(num.find(rem)!=num.end())    \\n            {\\n                ans.insert(num[rem],\"(\");\\n                ans += \")\";\\n                return ans;\\n            }\\n            num[rem] = ans.length();\\n            rem *= 10;\\n            ans += to_string(rem/d);\\n            rem %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        if(n==0)    return \"0\";\\n        if(d==1)    return to_string(n);\\n        if(d==-1)    return to_string((long)fabs(n));\\n        string ans=\"\";\\n        if((n<0 && d>0) || (n>0 && d<0))    ans += \"-\";\\n        n = abs(n);\\n        d = abs(d);\\n        ans += to_string(n/d);\\n        long long rem = n%d;\\n        if(!rem)    return ans;\\n        else    ans += \".\";\\n        unordered_map<int,int>num;\\n        while(rem!=0)\\n        {\\n            if(num.find(rem)!=num.end())    \\n            {\\n                ans.insert(num[rem],\"(\");\\n                ans += \")\";\\n                return ans;\\n            }\\n            num[rem] = ans.length();\\n            rem *= 10;\\n            ans += to_string(rem/d);\\n            rem %= d;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894376,
                "title": "26ms-python-efficient-easy-to-understand-solution",
                "content": "Please Upvote if you like it....\\n```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ansmaker = \"\"\\n        if numerator == 0:\\n            return \"0\"\\n        if numerator<0 and denominator<0:\\n            numerator = -1*numerator\\n            denominator = -1*denominator\\n        elif numerator<0 and denominator>=0:\\n            numerator = -1*numerator\\n            ansmaker= \"-\"\\n        elif numerator>=0 and denominator<0:\\n            denominator = -1* denominator\\n            ansmaker = \"-\"\\n        dict1 = {}\\n        q = numerator//denominator\\n        r = numerator%denominator\\n        # print(q,r)\\n        if r == 0:\\n            return(ansmaker + str(q))\\n        else:\\n            ans = ansmaker+ str(q) + \".\"\\n        while True:\\n            if r == 0:\\n                return ans\\n            if r in dict1:\\n                sl = dict1[r]\\n                ans = ans[:sl] + \"(\" + ans[sl:] + \")\"\\n                return ans\\n            dict1[r] = len(ans)\\n            r = r*10\\n            q = r//denominator\\n            r = r%denominator\\n            ans = ans+str(q)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n        ansmaker = \"\"\\n        if numerator == 0:\\n            return \"0\"\\n        if numerator<0 and denominator<0:\\n            numerator = -1*numerator\\n            denominator = -1*denominator\\n        elif numerator<0 and denominator>=0:\\n            numerator = -1*numerator\\n            ansmaker= \"-\"\\n        elif numerator>=0 and denominator<0:\\n            denominator = -1* denominator\\n            ansmaker = \"-\"\\n        dict1 = {}\\n        q = numerator//denominator\\n        r = numerator%denominator\\n        # print(q,r)\\n        if r == 0:\\n            return(ansmaker + str(q))\\n        else:\\n            ans = ansmaker+ str(q) + \".\"\\n        while True:\\n            if r == 0:\\n                return ans\\n            if r in dict1:\\n                sl = dict1[r]\\n                ans = ans[:sl] + \"(\" + ans[sl:] + \")\"\\n                return ans\\n            dict1[r] = len(ans)\\n            r = r*10\\n            q = r//denominator\\n            r = r%denominator\\n            ans = ans+str(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856027,
                "title": "java-convert-to-long",
                "content": "Double is not precise enough to be used for this question, so we will have to resort to elementary school math division. \\n\\nTo handle annoying edge cases, just convert it to long before we do anything.\\n\\n```Java\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) {\\n        long x = Math.abs(n*1L), y = Math.abs(d*1L);\\n        StringBuilder sb = new StringBuilder();\\n        if (n < 0 && d > 0 || n > 0 && d < 0){\\n            sb.append(\\'-\\'); // append \\'-\\' if one of n or d is negative.\\n        }\\n\\n        Map<Long, Integer> map = new HashMap<>();\\n        sb.append(x / y);\\n        x %= y;\\n        if (x > 0){ // only append \\'.\\' when we have reminder.\\n            sb.append(\\'.\\');\\n        }\\n        while(!map.containsKey(x)){ // keep doing division until we find a cycle\\n            map.put(x, map.size());\\n            x *= 10;\\n            if (x > 0){\\n                sb.append(x / y);\\n            }\\n            x %= y;\\n        }\\n\\n        if (x > 0){ // only append \\'()\\' when there is a cycle.\\n            sb.insert(sb.length() - (map.size() - map.get(x)), \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) {\\n        long x = Math.abs(n*1L), y = Math.abs(d*1L);\\n        StringBuilder sb = new StringBuilder();\\n        if (n < 0 && d > 0 || n > 0 && d < 0){\\n            sb.append(\\'-\\'); // append \\'-\\' if one of n or d is negative.\\n        }\\n\\n        Map<Long, Integer> map = new HashMap<>();\\n        sb.append(x / y);\\n        x %= y;\\n        if (x > 0){ // only append \\'.\\' when we have reminder.\\n            sb.append(\\'.\\');\\n        }\\n        while(!map.containsKey(x)){ // keep doing division until we find a cycle\\n            map.put(x, map.size());\\n            x *= 10;\\n            if (x > 0){\\n                sb.append(x / y);\\n            }\\n            x %= y;\\n        }\\n\\n        if (x > 0){ // only append \\'()\\' when there is a cycle.\\n            sb.insert(sb.length() - (map.size() - map.get(x)), \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774976,
                "title": "fraction-to-recurring-decimal-solution-java",
                "content": "class Solution {\\n  public String fractionToDecimal(int numerator, int denominator) {\\n    if (numerator == 0)\\n      return \"0\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    if (numerator < 0 ^ denominator < 0)\\n      sb.append(\"-\");\\n\\n    long n = Math.abs((long) numerator);\\n    long d = Math.abs((long) denominator);\\n    sb.append(n / d);\\n\\n    if (n % d == 0)\\n      return sb.toString();\\n\\n    sb.append(\".\");\\n    Map<Long, Integer> seen = new HashMap<>();\\n\\n    for (long r = n % d; r > 0; r %= d) {\\n      if (seen.containsKey(r)) {\\n        sb.insert(seen.get(r), \"(\");\\n        sb.append(\")\");\\n        break;\\n      }\\n      seen.put(r, sb.length());\\n      r *= 10;\\n      sb.append(r / d);\\n    }\\n\\n    return sb.toString();\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public String fractionToDecimal(int numerator, int denominator) {\\n    if (numerator == 0)\\n      return \"0\";\\n\\n    StringBuilder sb = new StringBuilder();\\n\\n    if (numerator < 0 ^ denominator < 0)\\n      sb.append(\"-\");\\n\\n    long n = Math.abs((long) numerator);\\n    long d = Math.abs((long) denominator);\\n    sb.append(n / d);\\n\\n    if (n % d == 0)\\n      return sb.toString();\\n\\n    sb.append(\".\");\\n    Map<Long, Integer> seen = new HashMap<>();\\n\\n    for (long r = n % d; r > 0; r %= d) {\\n      if (seen.containsKey(r)) {\\n        sb.insert(seen.get(r), \"(\");\\n        sb.append(\")\");\\n        break;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1744021,
                "title": "python-beginner-with-explanation",
                "content": "1. We get if the sign of answer we will return. if sign is true final answer will be positive else negative\\n2. then we do integer division of the given numerator with the given denominator \\n3. if the remainder is zero we return the answer using the sign we calculated\\n4. if remainder is not zero we append \".\" to the ans array and then keep trach of the remainder we will get each time we divide the coming remainder in a hashmap with the value of the place where we will need to insert the \"(\". \\n5. if we find such remainder value repeat we insert \"(\" at the required index and append \")\" at the last of the array and then return thr answer according to the sign we calculated\\nUPVOTE IF HELPFUL\\n```\\ndef fractionToDecimal(self, num: int, den: int) -> str:\\n        ans = []\\n        \\n        if (num >= 0 and den >= 0) or (num <= 0 and den <= 0):\\n            sign = True\\n        else:\\n            sign = False\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        q = num // den\\n        r = num % den\\n        \\n        ans.append(q)\\n\\n        if r == 0:\\n            return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n        else:\\n            ans.append(\".\")\\n            map1 = {}\\n            while r != 0:\\n                if r in map1:\\n                    ans.insert(map1[r], \"(\")\\n                    ans.append(\")\")\\n                    break\\n                else:\\n                    map1[r] = len(ans)\\n                    r *= 10\\n                    q = r // den\\n                    r %= den\\n                    ans.append(q)\\n        \\n        \\n        return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef fractionToDecimal(self, num: int, den: int) -> str:\\n        ans = []\\n        \\n        if (num >= 0 and den >= 0) or (num <= 0 and den <= 0):\\n            sign = True\\n        else:\\n            sign = False\\n        \\n        num = abs(num)\\n        den = abs(den)\\n        \\n        q = num // den\\n        r = num % den\\n        \\n        ans.append(q)\\n\\n        if r == 0:\\n            return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n        else:\\n            ans.append(\".\")\\n            map1 = {}\\n            while r != 0:\\n                if r in map1:\\n                    ans.insert(map1[r], \"(\")\\n                    ans.append(\")\")\\n                    break\\n                else:\\n                    map1[r] = len(ans)\\n                    r *= 10\\n                    q = r // den\\n                    r %= den\\n                    ans.append(q)\\n        \\n        \\n        return \"\".join(map(str, ans)) if sign else \"-\" + \"\".join(map(str, ans))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1535423,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        sign = bool(numerator > 0) ^ bool(denominator > 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = (\"-\" if sign else \"\") + str(numerator//denominator)\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return res\\n\\n        res += \".\"\\n        pos = {}\\n        while remainder != 0:\\n            if remainder not in pos:\\n                pos[remainder] = len(res)\\n            else:\\n                res = res[:pos[remainder]] + \"(\" + res[pos[remainder]:] + \")\"\\n                return res\\n                \\n            res += str(remainder * 10 // denominator)\\n            remainder = (remainder * 10) % denominator\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        sign = bool(numerator > 0) ^ bool(denominator > 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        res = (\"-\" if sign else \"\") + str(numerator//denominator)\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return res\\n\\n        res += \".\"\\n        pos = {}\\n        while remainder != 0:\\n            if remainder not in pos:\\n                pos[remainder] = len(res)\\n            else:\\n                res = res[:pos[remainder]] + \"(\" + res[pos[remainder]:] + \")\"\\n                return res\\n                \\n            res += str(remainder * 10 // denominator)\\n            remainder = (remainder * 10) % denominator\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401382,
                "title": "js-using-hashmap-with-explanation-in-the-comments",
                "content": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(numerator === 0) {\\n        return \\'0\\';\\n    }\\n\\t// check if the result should be negative or not\\n    const isNeg = (numerator < 0 && denominator > 0) || (denominator < 0 && numerator > 0);\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n\\n\\t// this map will keep note of all the remainders occurences,\\n\\t// if a remainder appears again, that will repeat the same pattern\\n    const remaindersMap = new Map();\\n\\n\\t// add the negative sign to result if applicable\\n    let result = isNeg ? \\'-\\' : \\'\\';\\n    let quotient = numerator / denominator,\\n        remainder = numerator % denominator;\\n\\n\\t// add the quotient to the result -\\n\\t// if num > deno the it will be a positive integer, else it will be 0\\n    result += Math.floor(quotient);\\n\\t\\n\\t// if remainder is 0, that means the num is entirely divisible by deno, so we can return the result\\n    if(remainder === 0) {\\n        return result;\\n    } else {\\n\\t\\t// else there will be a floating value, so we add decimal to the resultant string\\n\\t\\t// set num to remainder\\n\\t\\t// add the remainder to map to check if it reappears\\n        result += \\'.\\';\\n        numerator = remainder;\\n        remaindersMap.set(remainder, 0);\\n    }\\n\\t// handling the floating point separately, `decimalStr` will store that string\\n\\t// `patternStartIdx` - to keep note of the index from where pattern will start\\n    let decimalStr = \\'\\',\\n        patternStartIdx = -1;\\n\\t\\t\\n\\t// 2 conditions for getting out of the loop\\n\\t// num > 0 - when num === 0 that means num is divisible by deno\\n\\t// patternStartIdx === -1 - it will change when a pattern  is found\\n    while(numerator > 0 && patternStartIdx === -1) {\\n        numerator *= 10;    // numerator < denominator\\n        \\n        quotient = numerator / denominator;\\n        remainder = numerator % denominator;\\n        \\n\\t\\t// add the quotient to the decimalStr\\n        decimalStr += Math.floor(quotient);\\n\\t\\t\\n\\t\\t// if remainder is reoccuring => pattern found\\n        if(remaindersMap.has(remainder)) {\\n\\t\\t\\t// get the start index from where the pattern begin - it will be the index the remainder had previous occured\\n\\t\\t\\t// we get the value and break from the loop\\n            patternStartIdx = remaindersMap.get(remainder);\\n            break;\\n        }\\n\\t\\t// else add the remainder to the map with index as `decimalStr.length`\\n\\t\\t// and set num as the remainder for next iteration\\n        remaindersMap.set(remainder, decimalStr.length);\\n        numerator = remainder;\\n    }\\n\\t// if pattern is found, add the decimal string along with brackets around the repeating pattern\\n\\t// else simply add the decimalStr\\n    if(patternStartIdx !== -1) {\\n        result += decimalStr.substring(0, patternStartIdx);\\n        result += \\'(\\' + decimalStr.substring(patternStartIdx) + \\')\\';    \\n    } else {\\n        result += decimalStr;\\n    }\\n    return result;\\n}\\n```\\nTime Complexity = O(denominator)\\nSpace Complexity = O(denominator)\\n\\nThe range of remainder can be from [0, denominator - 1]\\nWe loop till remainder reoccurs, max it can check for each remainder and we are storing remainder values in a map.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fractionToDecimal = function(numerator, denominator) {\\n    if(numerator === 0) {\\n        return \\'0\\';\\n    }\\n\\t// check if the result should be negative or not\\n    const isNeg = (numerator < 0 && denominator > 0) || (denominator < 0 && numerator > 0);\\n    numerator = Math.abs(numerator);\\n    denominator = Math.abs(denominator);\\n\\n\\t// this map will keep note of all the remainders occurences,\\n\\t// if a remainder appears again, that will repeat the same pattern\\n    const remaindersMap = new Map();\\n\\n\\t// add the negative sign to result if applicable\\n    let result = isNeg ? \\'-\\' : \\'\\';\\n    let quotient = numerator / denominator,\\n        remainder = numerator % denominator;\\n\\n\\t// add the quotient to the result -\\n\\t// if num > deno the it will be a positive integer, else it will be 0\\n    result += Math.floor(quotient);\\n\\t\\n\\t// if remainder is 0, that means the num is entirely divisible by deno, so we can return the result\\n    if(remainder === 0) {\\n        return result;\\n    } else {\\n\\t\\t// else there will be a floating value, so we add decimal to the resultant string\\n\\t\\t// set num to remainder\\n\\t\\t// add the remainder to map to check if it reappears\\n        result += \\'.\\';\\n        numerator = remainder;\\n        remaindersMap.set(remainder, 0);\\n    }\\n\\t// handling the floating point separately, `decimalStr` will store that string\\n\\t// `patternStartIdx` - to keep note of the index from where pattern will start\\n    let decimalStr = \\'\\',\\n        patternStartIdx = -1;\\n\\t\\t\\n\\t// 2 conditions for getting out of the loop\\n\\t// num > 0 - when num === 0 that means num is divisible by deno\\n\\t// patternStartIdx === -1 - it will change when a pattern  is found\\n    while(numerator > 0 && patternStartIdx === -1) {\\n        numerator *= 10;    // numerator < denominator\\n        \\n        quotient = numerator / denominator;\\n        remainder = numerator % denominator;\\n        \\n\\t\\t// add the quotient to the decimalStr\\n        decimalStr += Math.floor(quotient);\\n\\t\\t\\n\\t\\t// if remainder is reoccuring => pattern found\\n        if(remaindersMap.has(remainder)) {\\n\\t\\t\\t// get the start index from where the pattern begin - it will be the index the remainder had previous occured\\n\\t\\t\\t// we get the value and break from the loop\\n            patternStartIdx = remaindersMap.get(remainder);\\n            break;\\n        }\\n\\t\\t// else add the remainder to the map with index as `decimalStr.length`\\n\\t\\t// and set num as the remainder for next iteration\\n        remaindersMap.set(remainder, decimalStr.length);\\n        numerator = remainder;\\n    }\\n\\t// if pattern is found, add the decimal string along with brackets around the repeating pattern\\n\\t// else simply add the decimalStr\\n    if(patternStartIdx !== -1) {\\n        result += decimalStr.substring(0, patternStartIdx);\\n        result += \\'(\\' + decimalStr.substring(patternStartIdx) + \\')\\';    \\n    } else {\\n        result += decimalStr;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998707,
                "title": "python-solution-with-detail-explanation",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        if numerator % denominator == 0: \\n\\t\\t\\treturn str(numerator // denominator)\\n        \\n        prefix = \\'\\'\\n        if (numerator > 0) != (denominator > 0):\\n            prefix = \\'-\\'\\n        \\n        # Operation must be on positive values\\n        if numerator < 0:\\n            numerator = - numerator\\n        if denominator < 0:\\n            denominator = - denominator\\n\\n        digit, remainder = divmod(numerator, denominator)\\n            \\n        res = prefix + str(digit) + \\'.\\' # EVERYTHING BEFORE DECIMAL\\n        \\n        table = {}\\n        suffix = \\'\\'\\n        \\n        while remainder not in table.keys():\\n            \\n            # Store index of the reminder in the table\\n            table[remainder] = len(suffix)\\n            \\n            val, remainder = divmod(remainder*10, denominator)\\n            \\n            suffix += str(val)\\n            \\n            # No repeating\\n            if remainder == 0:\\n                return res + suffix\\n        \\n        indexOfRepeatingPart = table[remainder]\\n        \\n        decimalTillRepeatingPart = suffix[:indexOfRepeatingPart]\\n        \\n        repeatingPart = suffix[indexOfRepeatingPart:]\\n\\n        return res + decimalTillRepeatingPart + \\'(\\' + repeatingPart + \\')\\'\\n\\ns = Solution()\\n\\nprint(s.fractionToDecimal(2, 3))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        if numerator % denominator == 0: \\n\\t\\t\\treturn str(numerator // denominator)\\n        \\n        prefix = \\'\\'\\n        if (numerator > 0) != (denominator > 0):\\n            prefix = \\'-\\'\\n        \\n        # Operation must be on positive values\\n        if numerator < 0:\\n            numerator = - numerator\\n        if denominator < 0:\\n            denominator = - denominator\\n\\n        digit, remainder = divmod(numerator, denominator)\\n            \\n        res = prefix + str(digit) + \\'.\\' # EVERYTHING BEFORE DECIMAL\\n        \\n        table = {}",
                "codeTag": "Java"
            },
            {
                "id": 806380,
                "title": "scala",
                "content": "```\\nimport scala.math.Integral.Implicits._\\nimport scala.math._\\n\\nobject Solution {\\n  def fractionToDecimal(numerator: Int, denominator: Int): String = {\\n    val sign = if (signum(numerator) * signum(denominator) == -1) \"-\" else \"\"\\n    s\"${sign}${fractionToDecimal(abs(numerator.toLong), abs(denominator.toLong))}\"\\n  }\\n\\n  private def fractionToDecimal(numerator: Long, denominator: Long): String = {\\n    numerator /% denominator match {\\n      case (quot, 0)   => quot.toString\\n      case (quot, rem) => s\"${quot}.${generateFractional(rem, denominator)}\"\\n    }\\n  }\\n\\n  @scala.annotation.tailrec\\n  private def generateFractional(numerator: Long,\\n                                 denominator: Long,\\n                                 numeratorToIndex: Map[Long, Int] = Map(),\\n                                 fractional: String = \"\"): String = {\\n    numeratorToIndex.get(numerator) match {\\n      case Some(index) => s\"${fractional.substring(0, index)}(${fractional.substring(index)})\"\\n      case _           => 10 * numerator /% denominator match {\\n        case (quot, 0)   => fractional + quot\\n        case (quot, rem) => generateFractional(rem, denominator, numeratorToIndex + (numerator -> fractional.length),\\n                                               fractional + quot)\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\nimport scala.math.Integral.Implicits._\\nimport scala.math._\\n\\nobject Solution {\\n  def fractionToDecimal(numerator: Int, denominator: Int): String = {\\n    val sign = if (signum(numerator) * signum(denominator) == -1) \"-\" else \"\"\\n    s\"${sign}${fractionToDecimal(abs(numerator.toLong), abs(denominator.toLong))}\"\\n  }\\n\\n  private def fractionToDecimal(numerator: Long, denominator: Long): String = {\\n    numerator /% denominator match {\\n      case (quot, 0)   => quot.toString\\n      case (quot, rem) => s\"${quot}.${generateFractional(rem, denominator)}\"\\n    }\\n  }\\n\\n  @scala.annotation.tailrec\\n  private def generateFractional(numerator: Long,\\n                                 denominator: Long,\\n                                 numeratorToIndex: Map[Long, Int] = Map(),\\n                                 fractional: String = \"\"): String = {\\n    numeratorToIndex.get(numerator) match {\\n      case Some(index) => s\"${fractional.substring(0, index)}(${fractional.substring(index)})\"\\n      case _           => 10 * numerator /% denominator match {\\n        case (quot, 0)   => fractional + quot\\n        case (quot, rem) => generateFractional(rem, denominator, numeratorToIndex + (numerator -> fractional.length),\\n                                               fractional + quot)\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 696535,
                "title": "c-hashmaps-100-runtime",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        long long num = numerator;\\n        long long deno = denominator;\\n        if(num==0) return \"0\";\\n        bool isNeg = false;\\n        if(num<0 && deno<0){\\n            num=abs(num);\\n            deno=abs(deno);\\n        }\\n        else if(num<0) {\\n            isNeg = true;\\n            num = abs(num);\\n        }\\n        else if(deno<0) {\\n            isNeg = true;\\n            deno = abs(deno);\\n        }\\n        long long q = num/deno;\\n        string ans = to_string(q);\\n        long long rem = num%deno;\\n        if(rem==0) {\\n            if(isNeg) return \"-\"+ans;\\n            return ans;\\n        }\\n        unordered_map<int,int> m;\\n        m[rem]=0;\\n        int count = 1;\\n        string str = \"\";\\n        while(rem!=0) {\\n            rem = rem* 10;\\n            q = rem/deno;\\n            str+=to_string(q);\\n            rem=rem%deno;\\n            if(m.find(rem)!=m.end()){\\n                str = str.substr(0,m[rem]) + \"(\" + str.substr(m[rem]) + \")\";\\n                break;\\n            }\\n            m[rem]=count;\\n            count++;\\n        }\\n        if(isNeg) return \"-\"+ans+\".\"+str;\\n        return ans+\".\"+str;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        long long num = numerator;\\n        long long deno = denominator;\\n        if(num==0) return \"0\";\\n        bool isNeg = false;\\n        if(num<0 && deno<0){\\n            num=abs(num);\\n            deno=abs(deno);\\n        }\\n        else if(num<0) {\\n            isNeg = true;\\n            num = abs(num);\\n        }\\n        else if(deno<0) {\\n            isNeg = true;\\n            deno = abs(deno);\\n        }\\n        long long q = num/deno;\\n        string ans = to_string(q);\\n        long long rem = num%deno;\\n        if(rem==0) {\\n            if(isNeg) return \"-\"+ans;\\n            return ans;\\n        }\\n        unordered_map<int,int> m;\\n        m[rem]=0;\\n        int count = 1;\\n        string str = \"\";\\n        while(rem!=0) {\\n            rem = rem* 10;\\n            q = rem/deno;\\n            str+=to_string(q);\\n            rem=rem%deno;\\n            if(m.find(rem)!=m.end()){\\n                str = str.substr(0,m[rem]) + \"(\" + str.substr(m[rem]) + \")\";\\n                break;\\n            }\\n            m[rem]=count;\\n            count++;\\n        }\\n        if(isNeg) return \"-\"+ans+\".\"+str;\\n        return ans+\".\"+str;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 489423,
                "title": "python3-very-clean-recursive-explained-solution",
                "content": "Let\\'s talk about how long division with decimals works. There\\'s no secret for this problem, it really is just the standard long division you learn when you\\'re 6 years old or whatever, unless you\\'re like me and day dreamed in your early days and learned it in college ;)\\n\\nBy the way, the `quotient` is the answer you get after completing division.\\n\\nIn general, the algorithm goes like this:\\n\\n```\\n\\t1. Perform a standard integer division with the numerator and denominator. \\n\\t2. If there is a remainder, we are now entering the realm of decimal division. Else, we are done and you can return your quotient.\\n\\t3. Assuming a remainder, while there exists a remainder, multiply it by 10 and perform long division, then set the remainder to the new remainder after the division.\\n\\t   Keep appending your quotients to your final answer\\n```\\n\\nOk, simple right! Knowing how to do this by hand is just these steps. It gets more complicated when dealing with a computer, though. Sometimes with the decimal division algorithm, you get caught in a cycle. This is where the problem really gets interesting. Consider the following division, `4/300`.\\n\\n```\\nnumerator = 4, denominator = 333\\n\\n4/333 = 0, r 4, final answer = 0\\n\\nlet numerator = 4*10 = 40\\n\\nnumerator = 40, denominator = 333\\n\\n40/333 = 0, r 40, final answer = 0.0\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012\\n\\nlet numerator = 4*10 = 40 (*PAY ATTENTION NOW!!)\\n\\n40/333 = 0 r 40, final answer = 0.0120\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01201\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012012\\n\\nlet numerator = 4*10 = 40 \\n\\n40/300 = 0 r 40, final answer = 0.0120120\\n\\nlet numerator = 40*10 .........\\n\\nyou get the point\\n........\\n```\\n\\nBasically, we\\'re caught in a cycle. Decimal division is crude, and if you happen to get an irrational number from your division, you have a cycle in your division. So, the question wants you to observe this, and it wants you to wrap your cycle around with (`CYCLE HERE`). This is where the problem earns it\\'s worth. How do we, *find* and ***identify*** the cycle? Generally speaking, just knowing there\\'s a cycle is easy to detect, but being able to do something like pinpoint what/ where the cycle is, with these problems, is the difficult part (e.g., the critical connections problem).\\n\\nThe answer is what it always is, ***memoization***. Each time in your long division part, you see a new numerator, record it and where you first saw it. As demonstrated in the example above, if you run into the same numerator twice, you will start repeating the exact same sequence of numbers each time. If you happen to remember where that numerator took place in your current sequence, you could intervene and just wrap the start point and end point with a pair of parenthesis, and get your answer. In our example above, we would stop right where we saw the 40, and wrap the first occurance of it all the way to the end of our recorded sequence, and terminate the algorithm. So, we would\\'ve had the [\\'0\\',\\'1\\',\\'2\\'] sequence, then we see the 40 again, and intervene our sequence to be [\\'(0\\', \\'1\\', \\'2)\\'], and break out.\\n\\nThe reason I adore recursion for this problem, even though it\\'s not necesarry is because for one, it\\'s short, clear, and simple. Two, we are essentially treating this as a graph problem searching for a cycle. What do we do with most graph problems? DFS :D\\n\\n***NOTICE***:\\nBy the way, most examples you\\'ll see will have something like 5.13434134 == 5.(134), but it\\'s possible to have something like 4.232112316767676767 == 4.23211231(67). The cycle might not just happen when the decimal part starts. Also, negative numbers are a thing. The simple way to handle them like always is to just convert them into positives, and make the final answer negative if we have one of them is positive and the other negative.\\n\\nSo, here is our final algorithm:\\n\\n```\\n1. Convert the numbers to be positive, if they\\'re negative. Record if the division would\\'ve resulted in negative numbers or not.\\n2. Record the integer part of the division. If there is no remainder, jump to step 4, otherwise, begin the recording of a new sequence. Set the numerator equal to remainder * 10.\\n3. While the numerator is not zero and not seen before, perform long division. Mark this numerator as a numerator we\\'ve seen before in a hash table; memorizing the index we found it first. After each division, add the result to our new sequence, and perform long division again (i.e, repeat this step recursively) setting our new numerator to be the remainder of the division we just did multiplied by 10.\\nIf we end up seeing the same numerator, in our sequence, add a \\'(\\' on the index which corresponds to the numerator we\\'ve seen before, and the end of our sequence, also add a \\')\\' to that element\\n4. Join the integer part with the decimal part, if any.\\n5. Convert the result of 4. to a negative number by prepending a - in the front if we discovered at step 0 the result is supposed to be negative\\n```\\n\\n\\nAnd here\\'s my code. \\n\\n***Disclaimer***: I know recursion is not optimal for this problem. If the test cases were extreme, and made it so a lot of steps were needed to complete the algorithm, it wouldn\\'t be able to finish because Python would suffer stack overflow. But, this is an interview question and the important part is to get a nice working clean solution. If you were in an interview and decided to roll with a recursive solution, let the interviewer know you\\'re aware with the price you pay for using recursion. This isn\\'t just exclusive to this problem, it\\'s actually a general reason why general recursion should be avoided whenever possible. This is a problem where it\\'s easily avoidable, but just very clean to use it. As far as time complexity goes, I\\'m not sure. It\\'s not something I\\'d really expect the interviewers to ask you about unless you\\'re a math person. It\\'s not just a log number or something, there are some very complicated theorems that probably go into finding that out. This is something that is studied in a number theory course, so the scope is pretty high. Just make sure you do your job as a programmer to keep the complexity to the number of steps the long divison with decimals would take, i.e, not recreating lists or reconverting your sequences at each step.\\n\\nIf you have any questions or I said something wrong in here, please feel free to ask/ discuss in comments :D\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        def longDivision(numerator, denominator, seen, quotient):\\n            if numerator == 0:\\n                return\\n            elif numerator in seen:\\n                quotient[seen[numerator]] = \\'(\\' + quotient[seen[numerator]]\\n                quotient[-1] = quotient[-1] + \\')\\'\\n                return\\n            \\n            seen[numerator] = len(quotient)\\n            quotient.append(str(numerator//denominator))\\n            longDivision(numerator%denominator * 10, denominator, seen, quotient)\\n        \\n        #preprocess. Make negative positive.\\n        isNegative = (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        #extract the integer portion of the quotient\\n        integerPart = str(numerator//denominator)\\n        \\n        #prepare, and perform longdevision on remiander*10, if any\\n        seen = {}\\n        decimalPart = []\\n        longDivision(numerator%denominator * 10, denominator, seen, decimalPart)\\n        \\n        #merge the integer part with the decimal part, if decimal exists\\n        decimalPart = \\'.\\' + \\'\\'.join(decimalPart) if decimalPart else \\'\\'\\n        quotient = integerPart + decimalPart\\n        \\n        return quotient if not isNegative else \\'-\\' + quotient\\n```",
                "solutionTags": [],
                "code": "```\\n\\t1. Perform a standard integer division with the numerator and denominator. \\n\\t2. If there is a remainder, we are now entering the realm of decimal division. Else, we are done and you can return your quotient.\\n\\t3. Assuming a remainder, while there exists a remainder, multiply it by 10 and perform long division, then set the remainder to the new remainder after the division.\\n\\t   Keep appending your quotients to your final answer\\n```\n```\\nnumerator = 4, denominator = 333\\n\\n4/333 = 0, r 4, final answer = 0\\n\\nlet numerator = 4*10 = 40\\n\\nnumerator = 40, denominator = 333\\n\\n40/333 = 0, r 40, final answer = 0.0\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012\\n\\nlet numerator = 4*10 = 40 (*PAY ATTENTION NOW!!)\\n\\n40/333 = 0 r 40, final answer = 0.0120\\n\\nlet numerator = 40*10 = 400\\n\\n400/333 = 1, r 67, final answer = 0.01201\\n\\nlet numerator = 67*100 = 670\\n\\n670 / 333 = 2 r 4, final answer = 0.012012\\n\\nlet numerator = 4*10 = 40 \\n\\n40/300 = 0 r 40, final answer = 0.0120120\\n\\nlet numerator = 40*10 .........\\n\\nyou get the point\\n........\\n```\n```\\n1. Convert the numbers to be positive, if they\\'re negative. Record if the division would\\'ve resulted in negative numbers or not.\\n2. Record the integer part of the division. If there is no remainder, jump to step 4, otherwise, begin the recording of a new sequence. Set the numerator equal to remainder * 10.\\n3. While the numerator is not zero and not seen before, perform long division. Mark this numerator as a numerator we\\'ve seen before in a hash table; memorizing the index we found it first. After each division, add the result to our new sequence, and perform long division again (i.e, repeat this step recursively) setting our new numerator to be the remainder of the division we just did multiplied by 10.\\nIf we end up seeing the same numerator, in our sequence, add a \\'(\\' on the index which corresponds to the numerator we\\'ve seen before, and the end of our sequence, also add a \\')\\' to that element\\n4. Join the integer part with the decimal part, if any.\\n5. Convert the result of 4. to a negative number by prepending a - in the front if we discovered at step 0 the result is supposed to be negative\\n```\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        def longDivision(numerator, denominator, seen, quotient):\\n            if numerator == 0:\\n                return\\n            elif numerator in seen:\\n                quotient[seen[numerator]] = \\'(\\' + quotient[seen[numerator]]\\n                quotient[-1] = quotient[-1] + \\')\\'\\n                return\\n            \\n            seen[numerator] = len(quotient)\\n            quotient.append(str(numerator//denominator))\\n            longDivision(numerator%denominator * 10, denominator, seen, quotient)\\n        \\n        #preprocess. Make negative positive.\\n        isNegative = (numerator < 0 and denominator > 0) or (numerator > 0 and denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        #extract the integer portion of the quotient\\n        integerPart = str(numerator//denominator)\\n        \\n        #prepare, and perform longdevision on remiander*10, if any\\n        seen = {}\\n        decimalPart = []\\n        longDivision(numerator%denominator * 10, denominator, seen, decimalPart)\\n        \\n        #merge the integer part with the decimal part, if decimal exists\\n        decimalPart = \\'.\\' + \\'\\'.join(decimalPart) if decimalPart else \\'\\'\\n        quotient = integerPart + decimalPart\\n        \\n        return quotient if not isNegative else \\'-\\' + quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382877,
                "title": "straightforward-python-long-division-solution",
                "content": "```\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if denominator < 0:\\n            denominator *= -1\\n            numerator *= -1\\n        sign = 1\\n        if numerator < 0:\\n            sign = -1\\n            numerator *= -1\\n        inte = (\\'-\\' if sign == -1 else \\'\\') + str(numerator // denominator)\\n        rem = numerator % denominator\\n        frac, mp, i = [], dict(), 0\\n        while rem != 0 and rem not in mp:\\n            mp[rem] = i\\n            i += 1\\n            rem *= 10\\n            frac.append(str(rem // denominator))\\n            rem %= denominator\\n        if rem == 0:\\n            if frac == []:\\n                return inte\\n            else:\\n                return inte + \\'.\\' + \\'\\'.join(frac)\\n        else:\\n            j = mp[rem]\\n            return inte + \\'.\\' + \\'\\'.join(frac[:j]) + \\'(\\' + \\'\\'.join(frac[j:]) + \\')\\'\\n```",
                "solutionTags": [],
                "code": "```\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if denominator < 0:\\n            denominator *= -1\\n            numerator *= -1\\n        sign = 1\\n        if numerator < 0:\\n            sign = -1\\n            numerator *= -1\\n        inte = (\\'-\\' if sign == -1 else \\'\\') + str(numerator // denominator)\\n        rem = numerator % denominator\\n        frac, mp, i = [], dict(), 0\\n        while rem != 0 and rem not in mp:\\n            mp[rem] = i\\n            i += 1\\n            rem *= 10\\n            frac.append(str(rem // denominator))\\n            rem %= denominator\\n        if rem == 0:\\n            if frac == []:\\n                return inte\\n            else:\\n                return inte + \\'.\\' + \\'\\'.join(frac)\\n        else:\\n            j = mp[rem]\\n            return inte + \\'.\\' + \\'\\'.join(frac[:j]) + \\'(\\' + \\'\\'.join(frac[j:]) + \\')\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359183,
                "title": "javascript-solution-best-time-here-best-solution",
                "content": "**If you don\\'t have a rought idea or understand the code below, please check out tadasant\\'s post for explanation by searching tadasant in discuss section.**\\n\\nThis post is for people who love to use {} instead of new Map() when needing a map like me.\\n\\nRecently after reading this article: https://medium.com/front-end-weekly/es6-map-vs-object-what-and-when-b80621932373 , I decided to do a performance test myself on this problem.\\n \\nSince leetcode has smaller amount of test cases, the run time beat % does not always mean the solution is optimal, you still have to think about run time complexity of your solution + any builtin function you used and data structure optimization.\\n\\n**NOTE:**\\nI\\'m new to performance testing and only did it on http://jsben.ch/ on chrome, please comment if you got something to offer or correct about my post.\\n\\n## Tests\\n**On LeetCode:** my solution with map was slower than obj with 37 test cases.\\n**On JSBEN: *code block 1* being obj {}, *code block 2* being new Map(), tests are [[nominator,denominator]......]**\\n\\n**1 test case [2,1] run 2000 times:** obj is only faster sometimes than map and not by much\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565868374.png)\\n\\nWith more tests cases it becomes apparent.\\n\\n\\n**[[1,2],[2,1],[1,998001],[-2147483648,1]] run 2000 times**\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565868996.png)\\n\\nLastly, to add more random test cases and at the same time not make the tab stop responding. I used the snippet here to generate 1 random test case and push it in.\\n```\\n//This block gets run 2000 times, to not explode I add onl 1 random element at the end.\\nconst tests = [[1,2],[2,1],[1,998001],[-2147483648,1]];\\n\\n\\nconst INT_MAX = Math.pow(2,32) - 1;\\nconst INT_MIN = -Math.pow(2,32);\\nconst range = INT_MAX-INT_MIN;\\ntests.push(Math.floor(Math.random()*(range)+INT_MIN),\\n           Math.floor(Math.random()*(range)+INT_MIN));\\n```\\n**[[1,2],[2,1],[1,998001],[-2147483648,1],[?,?]] run 2000 times**\\n![image](https://assets.leetcode.com/users/allanhsu8/image_1565869329.png)\\nWe can see map just beats object always. **Therefore use new Map() when you are using maps!** \\n\\nFor details of my code on JSBEN: http://jsben.ch/YeH2E , there are also plenty of map vs object tests on JSBEN you can search up and see for yourself of the getters and setters. Map is an object, but object is not a map.\\n\\n## Solution\\n```\\nconst fractionToDecimal = (numerator, denominator) => {\\n    if(numerator === 0) return \"0\";\\n    if(denominator === 0) return numerator < 0 ? Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;\\n    \\n    let res = \"\";\\n    \\n    //Check result sign\\n    if(Math.sign(numerator) !== Math.sign(denominator)) res += \"-\";\\n    \\n    let n = Math.abs(numerator);\\n    const d = Math.abs(denominator);\\n    \\n    //don\\'t use n/d | 0 to floor since js bitwise operation is based on 32 bits\\n    //and large positive num could cause sign bit to flip into a neg num or overflow\\n    res += Math.floor(n/d); \\n    n = n%d;\\n    \\n    if(n === 0) return res;\\n    \\n    res += \".\";\\n    \\n    //key for remainder, value for pattern start index\\n    let map = new Map();   // USE MAP\\n    \\n    //we can use res.length as index since it keeps track of the growth\\n    //alwasy being the next index to insert so we don\\'t need another variable!\\n    while(n !== 0){\\n        //keep track of remainders\\n        map.set(n,res.length);\\n        \\n        n *= 10;\\n        res += Math.floor(n/d); //add quotient digit to the res.length index\\n        n %= d;\\n    \\n        if(map.has(n))\\n            return `${res.substring(0,map.get(n))}(${res.substr(map.get(n))})`;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//This block gets run 2000 times, to not explode I add onl 1 random element at the end.\\nconst tests = [[1,2],[2,1],[1,998001],[-2147483648,1]];\\n\\n\\nconst INT_MAX = Math.pow(2,32) - 1;\\nconst INT_MIN = -Math.pow(2,32);\\nconst range = INT_MAX-INT_MIN;\\ntests.push(Math.floor(Math.random()*(range)+INT_MIN),\\n           Math.floor(Math.random()*(range)+INT_MIN));\\n```\n```\\nconst fractionToDecimal = (numerator, denominator) => {\\n    if(numerator === 0) return \"0\";\\n    if(denominator === 0) return numerator < 0 ? Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;\\n    \\n    let res = \"\";\\n    \\n    //Check result sign\\n    if(Math.sign(numerator) !== Math.sign(denominator)) res += \"-\";\\n    \\n    let n = Math.abs(numerator);\\n    const d = Math.abs(denominator);\\n    \\n    //don\\'t use n/d | 0 to floor since js bitwise operation is based on 32 bits\\n    //and large positive num could cause sign bit to flip into a neg num or overflow\\n    res += Math.floor(n/d); \\n    n = n%d;\\n    \\n    if(n === 0) return res;\\n    \\n    res += \".\";\\n    \\n    //key for remainder, value for pattern start index\\n    let map = new Map();   // USE MAP\\n    \\n    //we can use res.length as index since it keeps track of the growth\\n    //alwasy being the next index to insert so we don\\'t need another variable!\\n    while(n !== 0){\\n        //keep track of remainders\\n        map.set(n,res.length);\\n        \\n        n *= 10;\\n        res += Math.floor(n/d); //add quotient digit to the res.length index\\n        n %= d;\\n    \\n        if(map.has(n))\\n            return `${res.substring(0,map.get(n))}(${res.substr(map.get(n))})`;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208050,
                "title": "java-solution-20-lines",
                "content": "```\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n        long a = numerator, b = denominator, m = a % b;  //a\\u5206\\u5B50,b\\u5206\\u6BCD,m\\u4F59\\u6570\\n        Map<Long, Integer> map = new HashMap<>();\\n        if (m == 0)\\n            return a / b + \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if (a * b < 0)\\n            sb.append(\\'-\\');\\n        a = Math.abs(a);\\n        b = Math.abs(b);\\n        sb.append(a / b).append(\\'.\\');\\n        m = a % b;\\n        map.put(m, sb.length());\\n        while (m != 0) {\\n            a = m * 10;\\n            sb.append(a / b);\\n            m = a % b;\\n            if (map.containsKey(m))\\n                return sb.insert((int) map.get(m), \\'(\\').append(\\')\\').toString();\\n            map.put(m, sb.length());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic String fractionToDecimal(int numerator, int denominator) {\\n        long a = numerator, b = denominator, m = a % b;  //a\\u5206\\u5B50,b\\u5206\\u6BCD,m\\u4F59\\u6570\\n        Map<Long, Integer> map = new HashMap<>();\\n        if (m == 0)\\n            return a / b + \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if (a * b < 0)\\n            sb.append(\\'-\\');\\n        a = Math.abs(a);\\n        b = Math.abs(b);\\n        sb.append(a / b).append(\\'.\\');\\n        m = a % b;\\n        map.put(m, sb.length());\\n        while (m != 0) {\\n            a = m * 10;\\n            sb.append(a / b);\\n            m = a % b;\\n            if (map.containsKey(m))\\n                return sb.insert((int) map.get(m), \\'(\\').append(\\')\\').toString();\\n            map.put(m, sb.length());\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205217,
                "title": "c-0-ms-with-example-explanation-complexity-discussion",
                "content": "Let\\'s divide the problem to two sections.\\n1. Calculating the decimal value \\n2. Calculating the fractional value.\\n \\n* Calculating the decimal value:\\nThis one is straight forward; we can get the decimal value by a single division operation and store it to a string variable.\\nIf the numerator is divisible to denumerator, then we are done and need to return the string value of the division result \\nFor example if we have   numerator =84 and denumerator =7 then we should return \"12\"\\n\\n* Calculating the fractional value:\\n This step could be tricky.\\n Here is an example to refresh your mind for division algorithm.\\n \\n 1 / 7 : 1/7 = 0 , 1%7 =1  => 1/7 = 0. **X**  \\n to find the value of **X** we need to multiply the remainder by 10 and then repeat the division like\\n 1\\\\*10 =10 then 10/ 7 : 10/7 =1 , 10%7 =3  => 1/7 = 0.1**X**\\n 3\\\\*10 =30 then 30/ 7 : 30/7 =4 , 30%7 =2  => 1/7 = 0.14**X**\\n 2\\\\*10 =20 then 20/ 7 : 20/7 =2 , 20%7 =6  => 1/7 = 0.142**X**\\n 6\\\\*10 =60 then 60/ 7 : 60/7 =8 , 60%7 =4  => 1/7 = 0.1428**X**\\n 4\\\\*10 =40 then 40/ 7 : 40/7 =5 , 40%7 =5  => 1/7 = 0.14285**X**\\n \\n 5*10 =50 then 50/ 7 ~ 50/7 =7 , 50%7 =1  => 1/7 = 0.142857   , at this stage you can see that we are reaching a same number we have already calculated. So we need to report like 1/ 7  ~ 0.(142857)\\n \\nThe idea to implement the elaborated example is here:\\nwe can keep track of each generated remainder in a hash as a key of hash. The value of the hash can be the location of them in generated string. For example in the given example we have the following values for the hash:\\n\\nkey   val\\n1        0\\n3        1\\n2        2\\n6        3\\n4        4\\n5        6\\n\\nSo, to finalize it we can insert the \"(\" at the position of previously visited h[val] and add the \")\" to the end of string\\n \\nOne more important point needs to be noticed is about the sign. To handle it we can decide about the sign at very beginning and add the \"-\" to the result if needed (when only one of the operators is negative) , then do the rest of algorithm by updating the input parameters with their absolutes values.\\n\\n \\n#  Complexity\\n*  The interesting or follow up question could be about the time complexity of this algorithm.\\n\\t*  Memory complexity:  for this approach is O(denominator), the reason is that we are hashing the remainder values, so the maximum required hash location is denominator-1.\\n\\t\\n\\t*  Time complexity:  Similarly the maximum division operation we need to do is equal to denominator, the readson is that the remainder can be any number from [0,denominator-1]. So we can say the time complexity of the algoritm is also O(denominator)\\n  \\n\\n```\\nstring fractionToDecimal(int num1, int num2) {\\n  string res =\"\";    \\n  if (num1==0) return \"0\";\\n  if (num2==0) return \"NaN\";  \\n  long int n1 = num1;\\n  long int n2 = num2;\\n  if (n1>0 ^ n2>0) res+=\\'-\\';\\n  n1 = abs(n1);\\n  n2 = abs (n2);\\n  res += to_string(n1/n2);  \\n  if (n1%n2==0)\\n      return res;\\n  res+=\\'.\\';   \\n  map <int, int> h;\\n  n1 = n1 %n2;\\n  n1*=10;\\n  int idx=0;\\n  string frac = \"\"; \\n  while (n1!= 0 )  {\\n      if (h.find(n1)!=h.end()) {\\n          frac.insert(h[n1], \"(\");\\n          frac.append(\")\");\\n          break;\\n      }\\n      frac+= to_string(n1/n2);     \\n      h[n1] = idx;  \\n      n1 = n1 %n2;\\n      n1*=10;\\n      idx++;\\n  }\\n  res+=frac;\\n  return res;    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstring fractionToDecimal(int num1, int num2) {\\n  string res =\"\";    \\n  if (num1==0) return \"0\";\\n  if (num2==0) return \"NaN\";  \\n  long int n1 = num1;\\n  long int n2 = num2;\\n  if (n1>0 ^ n2>0) res+=\\'-\\';\\n  n1 = abs(n1);\\n  n2 = abs (n2);\\n  res += to_string(n1/n2);  \\n  if (n1%n2==0)\\n      return res;\\n  res+=\\'.\\';   \\n  map <int, int> h;\\n  n1 = n1 %n2;\\n  n1*=10;\\n  int idx=0;\\n  string frac = \"\"; \\n  while (n1!= 0 )  {\\n      if (h.find(n1)!=h.end()) {\\n          frac.insert(h[n1], \"(\");\\n          frac.append(\")\");\\n          break;\\n      }\\n      frac+= to_string(n1/n2);     \\n      h[n1] = idx;  \\n      n1 = n1 %n2;\\n      n1*=10;\\n      idx++;\\n  }\\n  res+=frac;\\n  return res;    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51134,
                "title": "simple-java-solution-with-explanation-for-all-key-points",
                "content": "```\\npublic String fractionToDecimal(int numerator, int denominator) {\\n        //1. Handle 3 special cases and return directly.\\n        //1) Zero divisor\\n        if (denominator == 0) return \"Error: 0 cannot be a denominator!\";\\n        //2) Zero dividend\\n        if (numerator == 0) return \"0\";\\n        //3) Exact division\\n        if (numerator % denominator == 0) return String.valueOf((long)numerator / (long)denominator);\\n        //NOTE: Convert to long before dividing to avoid overflow.\\n\\n        //2. Handle indivisible case\\n        StringBuilder sb = new StringBuilder();\\n\\n        //1) Add \"-\" sign for negative numbers\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        //NOTE: MUST convert int to long before abs() since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE.\\n\\n        if ( (long)numerator * (long)denominator < 0) sb.append(\"-\");\\n        //NOTE:\\n        // -- This is mandatory when num < den.\\n        // -- Convert to long before * to avoid overflow.\\n\\n        //2) Add integral part and \".\"\\n        sb.append(num / den).append(\".\");\\n        //NOTE: Use ABS() value to avoid double \"-\" sign when abs(num)>abs(den).\\n\\n        //3) Handle fraction part\\n        long remainder = num % den;\\n        Map<Long/*current reminder*/, Integer/* current stringBuilder.length()*/> map =\\n                new HashMap<Long, Integer>();\\n        //Assumption: a repeat remainder indicate a recursion of fraction.\\n        while (!map.containsKey(remainder)) {\\n            map.put(remainder, sb.length());\\n            sb.append(remainder * 10 / den);    //current fraction digit\\n            remainder = remainder * 10 % den;   //next reminder\\n        }\\n\\n        sb.insert(map.get(remainder), \"(\"); //Insert \"(\" before the start of recursion.\\n        sb.append(\")\"); //Append \")\" at the end.\\n        return sb.toString().replace(\"(0)\", \"\");    //Remove \"(0)\" when no recursion.\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String fractionToDecimal(int numerator, int denominator) {\\n        //1. Handle 3 special cases and return directly.\\n        //1) Zero divisor\\n        if (denominator == 0) return \"Error: 0 cannot be a denominator!\";\\n        //2) Zero dividend\\n        if (numerator == 0) return \"0\";\\n        //3) Exact division\\n        if (numerator % denominator == 0) return String.valueOf((long)numerator / (long)denominator);\\n        //NOTE: Convert to long before dividing to avoid overflow.\\n\\n        //2. Handle indivisible case\\n        StringBuilder sb = new StringBuilder();\\n\\n        //1) Add \"-\" sign for negative numbers\\n        long num = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        //NOTE: MUST convert int to long before abs() since Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE.\\n\\n        if ( (long)numerator * (long)denominator < 0) sb.append(\"-\");\\n        //NOTE:\\n        // -- This is mandatory when num < den.\\n        // -- Convert to long before * to avoid overflow.\\n\\n        //2) Add integral part and \".\"\\n        sb.append(num / den).append(\".\");\\n        //NOTE: Use ABS() value to avoid double \"-\" sign when abs(num)>abs(den).\\n\\n        //3) Handle fraction part\\n        long remainder = num % den;\\n        Map<Long/*current reminder*/, Integer/* current stringBuilder.length()*/> map =\\n                new HashMap<Long, Integer>();\\n        //Assumption: a repeat remainder indicate a recursion of fraction.\\n        while (!map.containsKey(remainder)) {\\n            map.put(remainder, sb.length());\\n            sb.append(remainder * 10 / den);    //current fraction digit\\n            remainder = remainder * 10 % den;   //next reminder\\n        }\\n\\n        sb.insert(map.get(remainder), \"(\"); //Insert \"(\" before the start of recursion.\\n        sb.append(\")\"); //Append \")\" at the end.\\n        return sb.toString().replace(\"(0)\", \"\");    //Remove \"(0)\" when no recursion.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51180,
                "title": "simple-java-solution-using-hashmap-and-stringbuilder",
                "content": "    public String fractionToDecimal(int numerator, int denominator) {\\n        long n=numerator;\\n\\t\\tlong d=denominator;\\n\\t\\tif(n==0)return \"0\";\\n        int sign=1;\\n        if(numerator<0){sign=-sign;n=-n;}\\n        if(denominator<0){sign=-sign;d=-d;}   \\n        \\n        StringBuilder sb=new StringBuilder();\\n        if(sign==-1)sb.append(\"-\");\\n        sb.append(n/d);\\n        n%=d;\\n        if(n==0)return sb.toString();\\n        sb.append(\".\");\\n        \\n        HashMap<Long,Integer>map=new HashMap();\\n        List<Long>list=new ArrayList();\\n        int index=0;\\n        while(n!=0&&!map.containsKey(n)){\\n            map.put(n,index++);\\n            n*=10;\\n            list.add(n/d);\\n            n%=d;\\n        }\\n        //Divide process finished\\n        if(n==0){ //No repeat\\n            for(int i=0;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            return sb.toString();\\n        }else{ //Has repeat\\n            int startIndex=map.get(n);    \\n            for(int i=0;i<startIndex;i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\"(\");\\n            for(int i=startIndex;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\")\");\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public String fractionToDecimal(int numerator, int denominator) {\\n        long n=numerator;\\n\\t\\tlong d=denominator;\\n\\t\\tif(n==0)return \"0\";\\n        int sign=1;\\n        if(numerator<0){sign=-sign;n=-n;}\\n        if(denominator<0){sign=-sign;d=-d;}   \\n        \\n        StringBuilder sb=new StringBuilder();\\n        if(sign==-1)sb.append(\"-\");\\n        sb.append(n/d);\\n        n%=d;\\n        if(n==0)return sb.toString();\\n        sb.append(\".\");\\n        \\n        HashMap<Long,Integer>map=new HashMap();\\n        List<Long>list=new ArrayList();\\n        int index=0;\\n        while(n!=0&&!map.containsKey(n)){\\n            map.put(n,index++);\\n            n*=10;\\n            list.add(n/d);\\n            n%=d;\\n        }\\n        //Divide process finished\\n        if(n==0){ //No repeat\\n            for(int i=0;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            return sb.toString();\\n        }else{ //Has repeat\\n            int startIndex=map.get(n);    \\n            for(int i=0;i<startIndex;i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\"(\");\\n            for(int i=startIndex;i<list.size();i++){\\n                sb.append(list.get(i));\\n            }\\n            sb.append(\")\");\\n            return sb.toString();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51196,
                "title": "clean-ruby-solution-with-comments-72-ms",
                "content": "    def fraction_to_decimal(n, d)\\n    \\n    \\t# Get +/-\\n    \\tresult = n*d >= 0 ? '' : '-'\\n    \\n    \\t# Get whole number\\n    \\tn = n.abs\\n    \\td = d.abs\\n    \\tresult << (n/d).to_s\\n    \\tn %= d\\n    \\n    \\t# Check whole number\\n    \\treturn result if n == 0\\n    \\n    \\t# Get decimal\\n    \\tresult << '.'\\n    \\tcheck = Hash.new\\n    \\n    \\t# Division\\n    \\twhile not n.zero? and check[n].nil?\\n    \\t\\tcheck[n] = result.length\\n    \\t\\tn *= 10\\n    \\t\\tresult << (n/d).to_s\\n    \\t\\tn %= d\\n    \\tend\\n    \\n    \\t# Check repeating\\n    \\tresult.insert(check[n], '(') << ')' if check[n]\\n    \\n    \\treturn result\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def fraction_to_decimal(n, d)\\n    \\n    \\t# Get +/-\\n    \\tresult = n*d >= 0 ? '' : '-'\\n    \\n    \\t# Get whole number\\n    \\tn = n.abs\\n    \\td = d.abs\\n    \\tresult << (n/d).to_s\\n    \\tn %= d\\n    \\n    \\t# Check whole number\\n    \\treturn result if n == 0\\n    \\n    \\t# Get decimal\\n    \\tresult << '.'\\n    \\tcheck = Hash.new\\n    \\n    \\t# Division\\n    \\twhile not n.zero? and check[n].nil?\\n    \\t\\tcheck[n] = result.length\\n    \\t\\tn *= 10\\n    \\t\\tresult << (n/d).to_s\\n    \\t\\tn %= d\\n    \\tend\\n    \\n    \\t# Check repeating\\n    \\tresult.insert(check[n], '(') << ')' if check[n]\\n    \\n    \\treturn result\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 51236,
                "title": "my-java-solution-with-explanation-second-version",
                "content": "my trick:\\n1. use long to avoid overflow<br>\\n2. use StringBuffer to build String<br>\\n3.use class pair to keep track of numerator and denominator,if I find the same pair in the map,it means the fractional part is repeating.<br>\\n4.  using `res=numeratorl/denominatorl;numeratorl=(numeratorl%denominatorl)*10;` to simulate division,`res` is the value to append to buffer.\\n\\n   \\n     public class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n\\t    \\t//to avoid overflow\\n\\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n\\t        StringBuffer buffer=new StringBuffer();\\n\\t        //handle negatives \\n\\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n\\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n\\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n\\t        //map,key:pair to hold numerator and denominator;value:position of numerator/denominator \\n\\t        HashMap<pair, Integer>map=new HashMap<>();\\n\\t        //handle integer part\\n\\t        long res=numeratorl/denominatorl;\\n\\t        numeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t\\tbuffer.append(res);\\n\\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n\\t\\t\\t//handle float part\\n\\t\\t\\twhile(numeratorl != 0){\\n\\t\\t\\t\\tres=numeratorl/denominatorl;\\n\\t\\t\\t\\tpair p=new pair(denominatorl,numeratorl);\\n\\t\\t\\t\\tif(map.get(p)!=null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//handle repaeting part\\n\\t\\t\\t\\t\\tbuffer.insert(map.get(p).intValue(), '(');\\n\\t\\t\\t\\t\\tbuffer.append(')');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.put(p, buffer.length());\\n\\t\\t\\t\\tnumeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t        buffer.append(res);\\n\\t\\t\\t}\\n\\t        return buffer.toString();\\n\\t    }\\n\\t    //this class is used to hold numerator and denominator,override hashcode\\\\equals\\n\\t    private static class pair{\\n\\t    \\tpublic long d;\\n\\t    \\tpublic long n;\\n\\t    \\tpublic pair(long d,long n) {\\n\\t    \\t\\tthis.d=d;this.n=n;\\n\\t\\t\\t}\\n\\t    \\t@Override\\n\\t    \\tpublic int hashCode() {\\n\\t    \\t\\treturn Arrays.hashCode(new long[]{d,n});\\n\\t    \\t}\\n\\t    \\t@Override\\n\\t    \\tpublic boolean equals(Object obj) {\\n\\t    \\t\\tpair p = (pair) obj;\\n\\t    \\t\\treturn p.d==d&&p.n==n;\\n\\t    \\t}\\n\\t     }\\n        }\\n\\nI make this problem complicated,because if numerator repeating,the fractional part is repeating.so class `pair` is not needed.I give my second version\\n \\n\\n    public class Solution {\\n    \\t    public String fractionToDecimal(int numerator, int denominator) {\\n    \\t    \\t//to avoid overflow\\n    \\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n    \\t        StringBuffer buffer=new StringBuffer();\\n    \\t        //handle negetives \\n    \\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n    \\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n    \\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n    \\t        //map,key:  numerator ,because denominator never changes;value:position of numerator/denominator \\n    \\t        HashMap<Long, Integer>map=new HashMap<>();\\n    \\t        //handle integer part\\n    \\t        long res=numeratorl/denominatorl;\\n    \\t        numeratorl=(numeratorl%denominatorl)*10;\\n    \\t\\t\\tbuffer.append(res);\\n    \\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n    \\t\\t\\t//handle flaot part\\n    \\t\\t\\twhile(numeratorl != 0){\\n    \\t\\t\\t\\tres=numeratorl/denominatorl;\\n    \\t\\t\\t\\tif(map.get(numeratorl)!=null)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t//handle repaeting part\\n    \\t\\t\\t\\t\\tbuffer.insert(map.get(numeratorl).intValue(), '(');\\n    \\t\\t\\t\\t\\tbuffer.append(')');\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tmap.put(numeratorl, buffer.length());\\n    \\t\\t\\t\\tnumeratorl=(numeratorl%denominatorl)*10;\\n    \\t\\t        buffer.append(res);\\n    \\t\\t\\t}\\n    \\t        return buffer.toString();\\n    \\t    }\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public String fractionToDecimal(int numerator, int denominator) {\\n\\t    \\t//to avoid overflow\\n\\t    \\tlong numeratorl=numerator, denominatorl=denominator;\\n\\t        StringBuffer buffer=new StringBuffer();\\n\\t        //handle negatives \\n\\t        if(numeratorl<0&&denominatorl>0)buffer.append('-');\\n\\t        else if(numeratorl>0&&denominatorl<0)buffer.append('-');\\n\\t        numeratorl=Math.abs(numeratorl);denominatorl=Math.abs(denominatorl);\\n\\t        //map,key:pair to hold numerator and denominator;value:position of numerator/denominator \\n\\t        HashMap<pair, Integer>map=new HashMap<>();\\n\\t        //handle integer part\\n\\t        long res=numeratorl/denominatorl;\\n\\t        numeratorl=(numeratorl%denominatorl)*10;\\n\\t\\t\\tbuffer.append(res);\\n\\t\\t\\tif(numeratorl!=0)buffer.append('.');\\n\\t\\t\\t//handle float part\\n\\t\\t\\twhile(numeratorl != 0){\\n\\t\\t\\t\\tres=numeratorl/denominatorl;\\n\\t\\t\\t\\tpair p=new pair(denominatorl,numeratorl);\\n\\t\\t\\t\\tif(map.get(p)!=null)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t//handle repaeting part\\n\\t\\t\\t\\t\\tbuffer.insert(map.get(p).intValue(), '(');\\n\\t\\t\\t\\t\\tbuffer.append(')');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3791144,
                "title": "easy-to-understand-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        long long a = labs(n), b = labs(d);\\n        string ans = \"\";\\n        if( (n < 0 && d > 0) || (n > 0 && d < 0) ) ans += \"-\";\\n        long long res = a/b; ans += to_string(res);\\n        long long r = a%b;\\n        if(r == 0) return ans;\\n        ans += \".\";\\n        unordered_map<int,int>mp;\\n        mp[r] = ans.length();\\n\\n        while(r != 0){\\n            r *= 10;\\n            res = r/b; ans+= to_string(res);\\n            r = r%b;\\n            if(mp.find(r) != mp.end()){\\n                ans.insert(ans.begin()+mp[r],\\'(\\');\\n                ans += \")\";\\n                return ans;\\n            }\\n            mp[r] = ans.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d) {\\n        long long a = labs(n), b = labs(d);\\n        string ans = \"\";\\n        if( (n < 0 && d > 0) || (n > 0 && d < 0) ) ans += \"-\";\\n        long long res = a/b; ans += to_string(res);\\n        long long r = a%b;\\n        if(r == 0) return ans;\\n        ans += \".\";\\n        unordered_map<int,int>mp;\\n        mp[r] = ans.length();\\n\\n        while(r != 0){\\n            r *= 10;\\n            res = r/b; ans+= to_string(res);\\n            r = r%b;\\n            if(mp.find(r) != mp.end()){\\n                ans.insert(ans.begin()+mp[r],\\'(\\');\\n                ans += \")\";\\n                return ans;\\n            }\\n            mp[r] = ans.length();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051470,
                "title": "100-fast-fully-commented-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d)\\n    {\\n        string ans;\\n        if((n<0 && d>0) || (n>0 && d<0))\\n            ans+=\\'-\\';\\n        n=abs(n);\\n        d=abs(d);\\n        long long q=n/d;//initial quotient\\n        long long rem=n%d;//initial remainder\\n        ans+=to_string(q);\\n        if(rem==0) return ans;//there is no decimal part\\n        ans+=\\'.\\';\\n        int fl=0;//flag variable to determine if theb decimal is recurring\\n        int ind_start=-1;//starting index of the recurring part of the decimal\\n        int index=0;//to store the index of all the numbers after point\\n        unordered_map<int,unordered_map<int,int>>mp;//quotient-->remainder-->index of number\\n        string after_pt;//string to store all the numbers after point\\n        while(rem!=0)\\n        {\\n            rem*=10;\\n            long long q2=rem/d;\\n            rem=rem%d;\\n            if(mp[q2][rem])//means the quotient-->remainder already exists thus the decimal part is recurring\\n            {\\n                fl=1;\\n                ind_start=mp[q2][rem];//the index of the start of the recuuring part of the decimal\\n                break;\\n            }\\n            else\\n            {\\n                after_pt+=to_string(q2);\\n                mp[q2][rem]=index++;\\n            }\\n        }\\n        if(fl==0)//contains no recurring number just concatenate the strings\\n            ans+=after_pt;\\n        else\\n        {\\n            //contains a recurring part\\n            for(int i=0;i<after_pt.length();i++)\\n            {\\n                if(i==ind_start)//this is the start of the recurring part of the decimal nos\\n                    ans+=\\'(\\';\\n                ans+=after_pt[i];\\n            }\\n            ans+=\\')\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int n, int d)\\n    {\\n        string ans;\\n        if((n<0 && d>0) || (n>0 && d<0))\\n            ans+=\\'-\\';\\n        n=abs(n);\\n        d=abs(d);\\n        long long q=n/d;//initial quotient\\n        long long rem=n%d;//initial remainder\\n        ans+=to_string(q);\\n        if(rem==0) return ans;//there is no decimal part\\n        ans+=\\'.\\';\\n        int fl=0;//flag variable to determine if theb decimal is recurring\\n        int ind_start=-1;//starting index of the recurring part of the decimal\\n        int index=0;//to store the index of all the numbers after point\\n        unordered_map<int,unordered_map<int,int>>mp;//quotient-->remainder-->index of number\\n        string after_pt;//string to store all the numbers after point\\n        while(rem!=0)\\n        {\\n            rem*=10;\\n            long long q2=rem/d;\\n            rem=rem%d;\\n            if(mp[q2][rem])//means the quotient-->remainder already exists thus the decimal part is recurring\\n            {\\n                fl=1;\\n                ind_start=mp[q2][rem];//the index of the start of the recuuring part of the decimal\\n                break;\\n            }\\n            else\\n            {\\n                after_pt+=to_string(q2);\\n                mp[q2][rem]=index++;\\n            }\\n        }\\n        if(fl==0)//contains no recurring number just concatenate the strings\\n            ans+=after_pt;\\n        else\\n        {\\n            //contains a recurring part\\n            for(int i=0;i<after_pt.length();i++)\\n            {\\n                if(i==ind_start)//this is the start of the recurring part of the decimal nos\\n                    ans+=\\'(\\';\\n                ans+=after_pt[i];\\n            }\\n            ans+=\\')\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001970,
                "title": "java-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }   \\n        sb = new StringBuilder();\\n        \\n        addSign(numerator,denominator);\\n        divideNumbers(numerator,denominator);\\n\\n        return sb.toString();\\n    }\\n    private void addSign(int a , int b){\\n        \\n        if((a > 0 && b > 0) || (a < 0 && b < 0)){\\n            return;\\n        }    \\n        sb.append(\"-\");\\n    }\\n    private void divideNumbers(int a,int b){\\n        \\n        long num = Math.abs((long)a);\\n        long den = Math.abs((long)b);\\n\\n        sb.append(num/den);\\n        num %= den;\\n        if(num == 0){\\n            return;\\n        } \\n        appendDecimalPart(num,den);\\n    }\\n    private void appendDecimalPart(long num, long den){\\n\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        sb.append(\".\");\\n        while(num !=0){\\n\\n            num *= 10;\\n            sb.append(num/den);\\n            num %= den;\\n\\n            if(map.containsKey(num)){\\n                sb.insert(map.get(num),\"(\");\\n                sb.append(\")\");\\n                return;\\n            }\\n            else{\\n                map.put(num,sb.length());\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String fractionToDecimal(int numerator, int denominator) {\\n\\n        if(numerator == 0){\\n            return \"0\";\\n        }   \\n        sb = new StringBuilder();\\n        \\n        addSign(numerator,denominator);\\n        divideNumbers(numerator,denominator);\\n\\n        return sb.toString();\\n    }\\n    private void addSign(int a , int b){\\n        \\n        if((a > 0 && b > 0) || (a < 0 && b < 0)){\\n            return;\\n        }    \\n        sb.append(\"-\");\\n    }\\n    private void divideNumbers(int a,int b){\\n        \\n        long num = Math.abs((long)a);\\n        long den = Math.abs((long)b);\\n\\n        sb.append(num/den);\\n        num %= den;\\n        if(num == 0){\\n            return;\\n        } \\n        appendDecimalPart(num,den);\\n    }\\n    private void appendDecimalPart(long num, long den){\\n\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        sb.append(\".\");\\n        while(num !=0){\\n\\n            num *= 10;\\n            sb.append(num/den);\\n            num %= den;\\n\\n            if(map.containsKey(num)){\\n                sb.insert(map.get(num),\"(\");\\n                sb.append(\")\");\\n                return;\\n            }\\n            else{\\n                map.put(num,sb.length());\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816835,
                "title": "simple-java-solution-beats-99",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) \\n    {\\n        long a = Math.abs((long)n);\\n        long b = Math.abs((long)d);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if( (n<0 && d>0) || (n>0 && d<0))\\n            sb.append(\\'-\\');\\n        \\n        sb.append(a/b);\\n        a = a%b;\\n        \\n        if(a > 0)\\n            sb.append(\\'.\\');\\n        \\n        HashMap<Long,Integer> map = new HashMap<>();\\n        \\n        while(!map.containsKey(a))\\n        {\\n            map.put(a , map.size());\\n            a = a*10;\\n            \\n            if(a > 0)\\n                sb.append(a/b);\\n            \\n            a = a%b;\\n        }\\n        \\n        if(a > 0)\\n        {\\n            sb.insert(sb.length()-(map.size()-map.get(a)) , \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int n, int d) \\n    {\\n        long a = Math.abs((long)n);\\n        long b = Math.abs((long)d);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if( (n<0 && d>0) || (n>0 && d<0))\\n            sb.append(\\'-\\');\\n        \\n        sb.append(a/b);\\n        a = a%b;\\n        \\n        if(a > 0)\\n            sb.append(\\'.\\');\\n        \\n        HashMap<Long,Integer> map = new HashMap<>();\\n        \\n        while(!map.containsKey(a))\\n        {\\n            map.put(a , map.size());\\n            a = a*10;\\n            \\n            if(a > 0)\\n                sb.append(a/b);\\n            \\n            a = a%b;\\n        }\\n        \\n        if(a > 0)\\n        {\\n            sb.insert(sb.length()-(map.size()-map.get(a)) , \\'(\\');\\n            sb.append(\\')\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174526,
                "title": "simple-to-understand",
                "content": "\\n    string fractionToDecimal(int a, int d) \\n    {\\n        long long n=a;\\n        if(n%d==0)\\n            return to_string(n/d);\\n        \\n        string ans;\\n        if(n<0^d<0)\\n            ans+=\\'-\\';\\n        \\n        n=abs(n),d=abs(d);\\n        \\n        ans+=to_string((n/d));\\n        ans+=\\'.\\';\\n        n%=d;\\n        n*=10;\\n        \\n        unordered_map<long long,int>mp;\\n        \\n        \\n        while(n)\\n        {\\n            if(mp.count(n))\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n            }\\n            mp[n]=ans.size();\\n            ans+=(n/d)+\\'0\\';  \\n            n%=d;\\n            n*=10;\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**upvode only when you understand this.**",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    string fractionToDecimal(int a, int d) \\n    {\\n        long long n=a;\\n        if(n%d==0)\\n            return to_string(n/d);\\n        \\n        string ans;\\n        if(n<0^d<0)\\n            ans+=\\'-\\';\\n        \\n        n=abs(n),d=abs(d);\\n        \\n        ans+=to_string((n/d));\\n        ans+=\\'.\\';\\n        n%=d;\\n        n*=10;\\n        \\n        unordered_map<long long,int>mp;\\n        \\n        \\n        while(n)\\n        {\\n            if(mp.count(n))\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n            }\\n            mp[n]=ans.size();\\n            ans+=(n/d)+\\'0\\';  \\n            n%=d;\\n            n*=10;\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**upvode only when you understand this.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1828185,
                "title": "java-1ms-100",
                "content": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator == 0)\\n            return \"0\";\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        if(numerator < 0 ^ denominator < 0)\\n            res.append(\"-\");\\n        \\n        long n = Math.abs((long) numerator);\\n        long d = Math.abs((long) denominator);\\n        \\n        long q = n / d;\\n        long r = n % d;\\n        res.append(q);\\n        \\n        if(r == 0)\\n            return res.toString();\\n        else{\\n            res.append(\".\");\\n            \\n            HashMap<Long, Integer> map = new HashMap<>();\\n            \\n            while(r != 0) {\\n                if(map.containsKey(r)){\\n                    int len = map.get(r);\\n                    res.insert(len,\"(\");\\n                    res.append(\")\");\\n                    break;\\n                }else{\\n                    map.put(r,res.length());\\n                    r = r * 10;\\n                    q = r / d;\\n                    r = r % d;\\n                    res.append(q);\\n                }\\n            }\\n        }\\n            \\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(numerator == 0)\\n            return \"0\";\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        if(numerator < 0 ^ denominator < 0)\\n            res.append(\"-\");\\n        \\n        long n = Math.abs((long) numerator);\\n        long d = Math.abs((long) denominator);\\n        \\n        long q = n / d;\\n        long r = n % d;\\n        res.append(q);\\n        \\n        if(r == 0)\\n            return res.toString();\\n        else{\\n            res.append(\".\");\\n            \\n            HashMap<Long, Integer> map = new HashMap<>();\\n            \\n            while(r != 0) {\\n                if(map.containsKey(r)){\\n                    int len = map.get(r);\\n                    res.insert(len,\"(\");\\n                    res.append(\")\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1764668,
                "title": "c-solution-in-0-ms-unordered-map-clean-commented-code",
                "content": "\\tstring fractionToDecimal(long a, long b) {\\n\\t\\t//base case\\n        if(a==0) return \"0\";\\n        string res;\\n\\t\\t//checking if either of the numerator or denominator is negitive\\n        if(a<0 ^ b<0) res=\\'-\\'+res;\\n        a=abs(a);\\n        b=abs(b);\\n\\t\\t//append the result of a/b to string\\n        res+=to_string(a/b);\\n\\t\\t//If there is remainder for a/b then decimal point exists\\n        if(a%b==0) return res;\\n        res+=\".\";\\n        long rem=a%b;\\n\\t\\t//map to store the index of occurance particular remainder\\n\\t\\t//If the same remainder is seen again we will use the first occuarance of that remainder and put in paranthesis indicating that sequence is repeating\\n        unordered_map<long,long> m;\\n        while(rem){\\n            if(m.find(rem)!=m.end()){\\n                res.insert(res.begin()+m[rem],\\'(\\');\\n                res.push_back(\\')\\');\\n                break;\\n            }\\n            m[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/b);\\n            rem=rem%b;\\n        }\\n        return res;\\n    }\\n\\nPlease upvote : )",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tstring fractionToDecimal(long a, long b) {\\n\\t\\t//base case\\n        if(a==0) return \"0\";\\n        string res;\\n\\t\\t//checking if either of the numerator or denominator is negitive\\n        if(a<0 ^ b<0) res=\\'-\\'+res;\\n        a=abs(a);\\n        b=abs(b);\\n\\t\\t//append the result of a/b to string\\n        res+=to_string(a/b);\\n\\t\\t//If there is remainder for a/b then decimal point exists\\n        if(a%b==0) return res;\\n        res+=\".\";\\n        long rem=a%b;\\n\\t\\t//map to store the index of occurance particular remainder\\n\\t\\t//If the same remainder is seen again we will use the first occuarance of that remainder and put in paranthesis indicating that sequence is repeating\\n        unordered_map<long,long> m;\\n        while(rem){\\n            if(m.find(rem)!=m.end()){\\n                res.insert(res.begin()+m[rem],\\'(\\');\\n                res.push_back(\\')\\');\\n                break;\\n            }\\n            m[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/b);\\n            rem=rem%b;\\n        }\\n        return res;\\n    }\\n\\nPlease upvote : )",
                "codeTag": "Unknown"
            },
            {
                "id": 1668331,
                "title": "python3-with-explanation-runtime-around-40ms-65ms",
                "content": "Although this is not the most perfect solution, I would like to share this with you and please feel free to comment below!\\n### Logic\\n* I handle this problem with memorization. As shown in the code, there are 2 arrays, the remainders and the quotients records the values of each round of division respectively.\\n* During the while loop, we check the current numerator value.\\n\\t* If the numerator is 0, which means the original numerator does not have recurring decimal, we can break the loop.\\n\\t* Otherwise, we will power the current numerator by 10 and start the next division.\\n\\t\\t* If the new numerator is already stored in the remainders, which means the following division operations will lead to recurring decimal, we can break the loop and return the answer.\\n\\t\\t* Otherwise, record the remainder and quotient, and update the numerator to its remainder.\\n* Finally, we will add the negative sign if necessary.\\n\\n### Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        neg = True if numerator/denominator < 0 else False\\n        numerator = -numerator if numerator < 0 else numerator\\n        denominator = -denominator if denominator < 0 else denominator\\n        out = str(numerator//denominator)\\n        if numerator % denominator:\\n            out += \".\"\\n        remainders = []\\n        quotients = []\\n        numerator %= denominator\\n        while numerator:\\n            numerator *= 10\\n            if str(numerator) in remainders:\\n                duplicateStart = remainders.index(str(numerator))\\n                out += \"\".join(quotients[:duplicateStart])\\n                out += \"(\"+\"\".join(quotients[duplicateStart:])+\")\"\\n                return \"-\"+out if neg else out\\n            else:\\n                remainders.append(str(numerator))\\n                quotients.append(str(numerator // denominator))\\n                numerator %= denominator\\n        out += \"\".join(quotients)\\n        return \"-\"+out if neg else out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        neg = True if numerator/denominator < 0 else False\\n        numerator = -numerator if numerator < 0 else numerator\\n        denominator = -denominator if denominator < 0 else denominator\\n        out = str(numerator//denominator)\\n        if numerator % denominator:\\n            out += \".\"\\n        remainders = []\\n        quotients = []\\n        numerator %= denominator\\n        while numerator:\\n            numerator *= 10\\n            if str(numerator) in remainders:\\n                duplicateStart = remainders.index(str(numerator))\\n                out += \"\".join(quotients[:duplicateStart])\\n                out += \"(\"+\"\".join(quotients[duplicateStart:])+\")\"\\n                return \"-\"+out if neg else out\\n            else:\\n                remainders.append(str(numerator))\\n                quotients.append(str(numerator // denominator))\\n                numerator %= denominator\\n        out += \"\".join(quotients)\\n        return \"-\"+out if neg else out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651060,
                "title": "python-solution-with-a-bit-of-explanation",
                "content": "The time complexity of this method is O(1) because the resulting array cannot be longer than 10000, which means the loop doesn\\'t go beyond 10000 iterations. The space complexity is also O(1) for the same reason, which might not depend on either numerator or the denominator.\\n\\nLet us list the possible test cases that this problem might need to deal with later.\\n\\tA) 1/90                 => 0.0(1)\\n\\tB) -1/90               =>-0.0(1)\\n\\tC) 0/-10               =>0\\n\\tD)4/2                    =>2\\n\\tE)2565/100000  =>0.02565\\n\\t\\nNow, let us go through the solution below.\\n1) First, we will return if the numerator is 0 because the answer will always be 0.\\n2) Second, we will check the sign of the resulting number. If both are positive or negative, then the resulting number will be positive; otherwise, it will be negative.\\n3) Third, we will divide the numerator by the denominator, add that value to the result, and keep track of the reminder.\\n4) Forth, if the remainder is 0, the denominator perfectly divides the numerator, which means we can return the result.\\n5) Fifth, if there is a remainder, we will add \".\" to the result because we will further divide the remainder to get results after the decimal place.\\n6) Sixth, this is the central part because most of the portion before this is relatively straightforward. We will keep track of the remainder and the length of the resulting array in a hash map. If we have previously seen that remainder, the result will have recurring numbers in decimal. And by keeping track of the length of the resulting array, we will know where to place the start bracket in the result. So, if we have already seen the reminder earlier, we will return here by placing the start bracket and end bracket in the result. We will need to multiply the remainder by 10 in each step. If we want to do the following division 1/90, then the remainder will be 1 before the for loop begins. Then we will need to multiply it by 10, and the new remainder will be 10, and then we will multiply it by 10 again, and the new val will be 1 and the remainder will be 10 again.\\n7) Seventh, when the remainder becomes 0, like in the case 1/1000000000000000 where it might take a while, we will break the while loop and return the result.\\n(Sorry for the bad English)\\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        negative_sign = (numerator < 0) ^ (denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        result = [\"-\"] if negative_sign else []\\n        result.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        seen_numerator = {}\\n        if remainder == 0:\\n            return \"\".join(result)\\n        \\n        result.append(\".\")\\n        while remainder != 0:\\n            if remainder in seen_numerator:\\n                result.append(\")\")\\n                small_pos = seen_numerator[remainder]\\n                return \"\".join(result[:small_pos]) + \"(\"+\"\".join(result[small_pos:])\\n            seen_numerator[remainder] = len(result)\\n            remainder *= 10\\n            val = remainder // denominator\\n            remainder %= denominator\\n            result.append(str(val))\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        negative_sign = (numerator < 0) ^ (denominator < 0)\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        result = [\"-\"] if negative_sign else []\\n        result.append(str(numerator // denominator))\\n        remainder = numerator % denominator\\n        \\n        seen_numerator = {}\\n        if remainder == 0:\\n            return \"\".join(result)\\n        \\n        result.append(\".\")\\n        while remainder != 0:\\n            if remainder in seen_numerator:\\n                result.append(\")\")\\n                small_pos = seen_numerator[remainder]\\n                return \"\".join(result[:small_pos]) + \"(\"+\"\".join(result[small_pos:])\\n            seen_numerator[remainder] = len(result)\\n            remainder *= 10\\n            val = remainder // denominator\\n            remainder %= denominator\\n            result.append(str(val))\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639085,
                "title": "clean-java-with-comment",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        // if negative, append -\\n        if(numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) builder.append(\"-\");\\n        \\n        // avoid integer overflow by converting to long\\n        long divisor = Math.abs((long) numerator);\\n        long dividend = Math.abs((long) denominator);\\n        \\n        long remainder = divisor % dividend;\\n        builder.append(divisor / dividend);\\n        \\n        // no decimal \\n        if(remainder == 0) return builder.toString();\\n        \\n        builder.append(\".\");\\n        \\n        // key is the remainder, value is the position in the result string\\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        while(remainder != 0) {\\n            // check if remainder is repeating\\n            if(map.containsKey(remainder)) {\\n                //insert ( before the repeating num\\n                builder.insert(map.get(remainder), \"(\");\\n                //insert ) after the repeatingn num\\n                builder.append(\")\");\\n                break;\\n            }\\n            \\n            // first time seeing the remainder\\n            // position is the end of the string\\n            map.put(remainder, builder.length());\\n            // continue to divide the dividend so we should *= 10 as per normal long division\\n            remainder *= 10;\\n            builder.append(remainder / dividend);\\n            remainder %= dividend;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        \\n        StringBuilder builder = new StringBuilder();\\n        \\n        // if negative, append -\\n        if(numerator < 0 && denominator > 0 || numerator > 0 && denominator < 0) builder.append(\"-\");\\n        \\n        // avoid integer overflow by converting to long\\n        long divisor = Math.abs((long) numerator);\\n        long dividend = Math.abs((long) denominator);\\n        \\n        long remainder = divisor % dividend;\\n        builder.append(divisor / dividend);\\n        \\n        // no decimal \\n        if(remainder == 0) return builder.toString();\\n        \\n        builder.append(\".\");\\n        \\n        // key is the remainder, value is the position in the result string\\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        while(remainder != 0) {\\n            // check if remainder is repeating\\n            if(map.containsKey(remainder)) {\\n                //insert ( before the repeating num\\n                builder.insert(map.get(remainder), \"(\");\\n                //insert ) after the repeatingn num\\n                builder.append(\")\");\\n                break;\\n            }\\n            \\n            // first time seeing the remainder\\n            // position is the end of the string\\n            map.put(remainder, builder.length());\\n            // continue to divide the dividend so we should *= 10 as per normal long division\\n            remainder *= 10;\\n            builder.append(remainder / dividend);\\n            remainder %= dividend;\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618999,
                "title": "a-fast-simple-and-easy-to-follow-python-solution",
                "content": "A lot of solutions out there are way too much for me. The following is a simplied python solution with explanation in plain language. I hope that helps. \\n\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        # base case\\n        if numerator == 0:\\n            return \\'0\\'\\n        \\n        # result\\n        res = \\'\\'\\n        \\n        # positive and negative\\n        if (numerator > 0 and denominator < 0) or \\\\\\n            (numerator < 0 and denominator > 0):\\n            res += \\'-\\'\\n        \\n        # absolute value\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # remainder as zero\\n        res += str(numerator//denominator)\\n        numerator %= denominator\\n        if numerator == 0:\\n            return res\\n        \\n        # add a dot .\\n        res += \\'.\\'\\n        \\n        # hashmap to write down the starting index of a repeated remainder\\n        hashmap = {}\\n        hashmap[numerator] = len(res)\\n        while numerator != 0:\\n            \\n            # continue to mutiply by 10\\n            numerator *= 10\\n            res += str(numerator//denominator)\\n            numerator %= denominator\\n            \\n            # check if it finds a repeated pattern\\n            if numerator in hashmap:\\n                index = hashmap[numerator]\\n                res = res[:index] + \\'(\\' + res[index:]\\n                res += \\')\\'\\n                break\\n            else:\\n                hashmap[numerator] = len(res)\\n                 \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        \\n        # base case\\n        if numerator == 0:\\n            return \\'0\\'\\n        \\n        # result\\n        res = \\'\\'\\n        \\n        # positive and negative\\n        if (numerator > 0 and denominator < 0) or \\\\\\n            (numerator < 0 and denominator > 0):\\n            res += \\'-\\'\\n        \\n        # absolute value\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # remainder as zero\\n        res += str(numerator//denominator)\\n        numerator %= denominator\\n        if numerator == 0:\\n            return res\\n        \\n        # add a dot .\\n        res += \\'.\\'\\n        \\n        # hashmap to write down the starting index of a repeated remainder\\n        hashmap = {}\\n        hashmap[numerator] = len(res)\\n        while numerator != 0:\\n            \\n            # continue to mutiply by 10\\n            numerator *= 10\\n            res += str(numerator//denominator)\\n            numerator %= denominator\\n            \\n            # check if it finds a repeated pattern\\n            if numerator in hashmap:\\n                index = hashmap[numerator]\\n                res = res[:index] + \\'(\\' + res[index:]\\n                res += \\')\\'\\n                break\\n            else:\\n                hashmap[numerator] = len(res)\\n                 \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501693,
                "title": "accepted-java-solution-through-long-division-using-a-string-builder-and-a-hash-map",
                "content": "```\\nclass Solution {\\n    private static final String MINUS = \"-\";\\n    private static final String DECIMAL_POINT = \".\";\\n    private static final String OPENING_BRACKET = \"(\";\\n    private static final String CLOSING_BRACKET = \")\";\\n    \\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(0==numerator){\\n            return \"0\";\\n        }\\n        \\n        StringBuilder formattedFraction = new StringBuilder();\\n        \\n        if(numerator<0 ^ denominator<0){\\n            formattedFraction.append(MINUS);\\n        }\\n        \\n        long dividend = Math.abs(Long.valueOf(numerator));\\n        long divisor = Math.abs(Long.valueOf(denominator));\\n        \\n        formattedFraction.append(String.valueOf(dividend/divisor));\\n        long remainder = dividend%divisor;\\n        \\n        if(0==remainder){\\n            return formattedFraction.toString();\\n        }\\n        \\n        formattedFraction.append(DECIMAL_POINT);\\n        \\n        //Structure to Hash and Store all the Remainder Sequences we have encountered so far\\n        Map<Long,Integer> seqeuences = new HashMap<Long,Integer>();\\n        \\n        while(0!=remainder){\\n            if(seqeuences.containsKey(remainder)){\\n                formattedFraction.insert(seqeuences.get(remainder),OPENING_BRACKET);\\n                formattedFraction.append(CLOSING_BRACKET);\\n                break;\\n            }\\n            \\n            seqeuences.put(remainder,formattedFraction.length());\\n            remainder*=10;\\n            formattedFraction.append(String.valueOf(remainder/divisor));\\n            remainder %= divisor; \\n        }\\n        \\n        return formattedFraction.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private static final String MINUS = \"-\";\\n    private static final String DECIMAL_POINT = \".\";\\n    private static final String OPENING_BRACKET = \"(\";\\n    private static final String CLOSING_BRACKET = \")\";\\n    \\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(0==numerator){\\n            return \"0\";\\n        }\\n        \\n        StringBuilder formattedFraction = new StringBuilder();\\n        \\n        if(numerator<0 ^ denominator<0){\\n            formattedFraction.append(MINUS);\\n        }\\n        \\n        long dividend = Math.abs(Long.valueOf(numerator));\\n        long divisor = Math.abs(Long.valueOf(denominator));\\n        \\n        formattedFraction.append(String.valueOf(dividend/divisor));\\n        long remainder = dividend%divisor;\\n        \\n        if(0==remainder){\\n            return formattedFraction.toString();\\n        }\\n        \\n        formattedFraction.append(DECIMAL_POINT);\\n        \\n        //Structure to Hash and Store all the Remainder Sequences we have encountered so far\\n        Map<Long,Integer> seqeuences = new HashMap<Long,Integer>();\\n        \\n        while(0!=remainder){\\n            if(seqeuences.containsKey(remainder)){\\n                formattedFraction.insert(seqeuences.get(remainder),OPENING_BRACKET);\\n                formattedFraction.append(CLOSING_BRACKET);\\n                break;\\n            }\\n            \\n            seqeuences.put(remainder,formattedFraction.length());\\n            remainder*=10;\\n            formattedFraction.append(String.valueOf(remainder/divisor));\\n            remainder %= divisor; \\n        }\\n        \\n        return formattedFraction.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427700,
                "title": "python-3-solution-using-hashmap",
                "content": "```\\ndef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\tneg = (numerator<0 and denominator>0) or (numerator>0 and denominator<0)\\n\\tnumerator = abs(numerator) \\n\\tdenominator = abs(denominator)\\n\\n\\tres = [str(numerator//denominator)]\\n\\tindex = 1\\n\\tnumerator%=denominator\\n\\tif numerator!=0:\\n\\t\\tres.append(\".\")\\n\\t\\tindex+=1\\n\\tdic = {}\\n\\n\\twhile numerator!=0:\\n\\t\\tif numerator in dic:\\n\\t\\t\\tres = res[:dic[numerator]] + [\"(\"] + res[dic[numerator]:] + [\")\"]\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tdic[numerator] = index\\n\\t\\tnumerator*=10\\n\\t\\tres.append(str(numerator//denominator))\\n\\t\\tindex+=1\\n\\t\\tnumerator%=denominator\\n\\treturn \"\".join(res) if not neg else \"-\"+\"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\tneg = (numerator<0 and denominator>0) or (numerator>0 and denominator<0)\\n\\tnumerator = abs(numerator) \\n\\tdenominator = abs(denominator)\\n\\n\\tres = [str(numerator//denominator)]\\n\\tindex = 1\\n\\tnumerator%=denominator\\n\\tif numerator!=0:\\n\\t\\tres.append(\".\")\\n\\t\\tindex+=1\\n\\tdic = {}\\n\\n\\twhile numerator!=0:\\n\\t\\tif numerator in dic:\\n\\t\\t\\tres = res[:dic[numerator]] + [\"(\"] + res[dic[numerator]:] + [\")\"]\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tdic[numerator] = index\\n\\t\\tnumerator*=10\\n\\t\\tres.append(str(numerator//denominator))\\n\\t\\tindex+=1\\n\\t\\tnumerator%=denominator\\n\\treturn \"\".join(res) if not neg else \"-\"+\"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1402927,
                "title": "c-4ms-explained-easy-to-understand",
                "content": "1. Calculate the decimal part and add to ans.\\n2. Run loop till remainder is 0 or remainder is seen already in the calculation.\\n3. Add the decimal part of remainder/denominator to the ans.\\n**Note:**\\n1. Using index because we need to insert \"(\" at the start of the remainder that is repeating.\\nFor ex: consider 2/30 = 0.0666..., so answer should be 0.0(6) not 0.(06).\\nFor the same reason, map is used instead of set.\\n2. Using long and labs for INT_MIN.\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n    if(numerator==0) return \"0\";\\n    string ans;\\n    unordered_map<long int,int> mp;\\n    if((numerator<0 && denominator>0) || (numerator>0 && denominator<0)) ans=ans+\"-\";\\n    long int num=labs(numerator),den=labs(denominator);    \\n    long int remainder,decimal=num/den;\\n    int curdigit,index;\\n    remainder=num%den,\\n    ans=ans+to_string(decimal);\\n    if(remainder!=0) ans=ans+\".\";\\n    index=ans.size();\\n    while(remainder!=0)\\n    {\\n        if(mp.find(remainder)!=mp.end())\\n        {\\n            ans.insert(mp[remainder],\"(\");\\n            ans=ans+\")\";\\n            break;\\n        }\\n        mp[remainder]=index;\\n        remainder=remainder*10 ;\\n        curdigit=remainder/den;\\n        ans=ans+to_string(curdigit);\\n        remainder=remainder%den;\\n        index++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n    if(numerator==0) return \"0\";\\n    string ans;\\n    unordered_map<long int,int> mp;\\n    if((numerator<0 && denominator>0) || (numerator>0 && denominator<0)) ans=ans+\"-\";\\n    long int num=labs(numerator),den=labs(denominator);    \\n    long int remainder,decimal=num/den;\\n    int curdigit,index;\\n    remainder=num%den,\\n    ans=ans+to_string(decimal);\\n    if(remainder!=0) ans=ans+\".\";\\n    index=ans.size();\\n    while(remainder!=0)\\n    {\\n        if(mp.find(remainder)!=mp.end())\\n        {\\n            ans.insert(mp[remainder],\"(\");\\n            ans=ans+\")\";\\n            break;\\n        }\\n        mp[remainder]=index;\\n        remainder=remainder*10 ;\\n        curdigit=remainder/den;\\n        ans=ans+to_string(curdigit);\\n        remainder=remainder%den;\\n        index++;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087090,
                "title": "easy-python-solution",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, N: int, D: int) -> str:\\n        neg = True\\n        if (N < 0 and D < 0) or (N >= 0 and D >= 0): neg = False\\n        N = abs(N)\\n        D = abs(D)\\n        rem = N % D\\n        q = N // D\\n        res = [(\"-\" if neg else \"\") + str(q)]                \\n        maps = {}        \\n        if rem == 0:\\n            return str((-1 if neg else 1) * q)\\n        else:\\n            res.append(\\'.\\')\\n            while rem != 0:        \\n                if rem in maps:\\n                    res.append(\\')\\')\\n                    res.insert(maps[rem] , \\'(\\')\\n                    break;\\n                else:\\n                    maps[rem] = len(res)\\n                    rem *= 10\\n                    res.append(str(rem // D))\\n                    rem %= D\\n        return \"\".join(res)\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fractionToDecimal(self, N: int, D: int) -> str:\\n        neg = True\\n        if (N < 0 and D < 0) or (N >= 0 and D >= 0): neg = False\\n        N = abs(N)\\n        D = abs(D)\\n        rem = N % D\\n        q = N // D\\n        res = [(\"-\" if neg else \"\") + str(q)]                \\n        maps = {}        \\n        if rem == 0:\\n            return str((-1 if neg else 1) * q)\\n        else:\\n            res.append(\\'.\\')\\n            while rem != 0:        \\n                if rem in maps:\\n                    res.append(\\')\\')\\n                    res.insert(maps[rem] , \\'(\\')\\n                    break;\\n                else:\\n                    maps[rem] = len(res)\\n                    rem *= 10\\n                    res.append(str(rem // D))\\n                    rem %= D\\n        return \"\".join(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083481,
                "title": "very-clear-solution-with-python-with-detailed-comment",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # the key idea of solving this problem is how to detect repeating\\n        # and locate where to add parentheses\\n        # the answer is generate the decimal part with mod operation and recalculate\\n        # the remainer time by time. When meeting same remainer, there have repeating\\n        # and the begining of the repeating is the index where you first meet\\n        # the same remainer\\n        res = \"\"\\n        # determinate symbol with xor, remeber 0 have not negative one\\n        if numerator ^ denominator < 0 and numerator != 0:\\n            res += \"-\"\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        # calculate the integral part\\n        res += str(int(numerator / denominator))\\n        remainder_index = {}\\n        remainder = numerator % denominator\\n        # calculate the decimal part\\n        if remainder != 0:\\n            res += \".\"\\n        while remainder:\\n            # detect same remainer, so we can locate the repeating part\\n            if remainder in remainder_index:\\n                res = res[0:remainder_index[remainder]] + \\'(\\' + res[remainder_index[remainder]:] + \\')\\'\\n                # please notice that the rest calculate is repeating, so break now\\n                break\\n            \\n            remainder_index[remainder] = len(res)\\n            remainder *= 10\\n            res += str(int(remainder / denominator))\\n            remainder %= denominator\\n            \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # the key idea of solving this problem is how to detect repeating\\n        # and locate where to add parentheses\\n        # the answer is generate the decimal part with mod operation and recalculate\\n        # the remainer time by time. When meeting same remainer, there have repeating\\n        # and the begining of the repeating is the index where you first meet\\n        # the same remainer\\n        res = \"\"\\n        # determinate symbol with xor, remeber 0 have not negative one\\n        if numerator ^ denominator < 0 and numerator != 0:\\n            res += \"-\"\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        # calculate the integral part\\n        res += str(int(numerator / denominator))\\n        remainder_index = {}",
                "codeTag": "Java"
            },
            {
                "id": 907216,
                "title": "java-1-ms-faster-than-99-91-36-4-mb-less-than-20-75",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (numerator < 0 ^ denominator < 0) {\\n            sb.append(\"-\");\\n        }\\n        long up = Math.abs((long) numerator);\\n        long down = Math.abs((long) denominator);\\n        sb.append(up / down);\\n        long rem = up % down;\\n        if (rem == 0) {\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        Map<Long, Integer> idxs = new HashMap<>();\\n        while (rem != 0) {\\n            if (idxs.containsKey(rem)) {\\n                sb.insert(idxs.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            idxs.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / down);\\n            rem %= down;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (numerator < 0 ^ denominator < 0) {\\n            sb.append(\"-\");\\n        }\\n        long up = Math.abs((long) numerator);\\n        long down = Math.abs((long) denominator);\\n        sb.append(up / down);\\n        long rem = up % down;\\n        if (rem == 0) {\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        Map<Long, Integer> idxs = new HashMap<>();\\n        while (rem != 0) {\\n            if (idxs.containsKey(rem)) {\\n                sb.insert(idxs.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            idxs.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / down);\\n            rem %= down;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837008,
                "title": "python-solution-with-intuition",
                "content": "Intuition: First we handle the special case where numerator is zero. We build our final output in an array, and at the end we return this array. We take into account the signs initially so that we can do our division dealing with only positive numbers. XOR operation enables us to quickly determine if exactly one of numerator or denominator is negative. We separate our solution into two parts, the integral part and the decimal part.\\n\\nFor the integral part, we need to use integer division to see how many times denominator goes into numerator. This will be zero if denominator > numerator. This makes sense because if a denominator is bigger than a numerator, then the integral portion of our decimal will be zero. Once we handle the integral portion, we then move onto the decimal part. \\n\\nFor the decimal part, we are looking for the point at which remainders begin to repeat, in our long division. At the point in which we see a repeat remainder, we know that we have a cycle and that there will be repeats from here onward. If remainder gets to zero, that means the decimal part does not have a cycle, and we exit the while loop accordingly. \\n\\nWithin the while loop we handle the long division for the decimal part. At the same time, we maintain a dictionary of remainders we\\'ve seen so far, as well as the index we saw this remainder. The while loop has two ways of exiting:\\n- Case 1: We see a remainder we saw in the past, which indicates a cycle. So we insert parentheses where needed and we exit.\\n- Case 2: remainder makes it down to zero, which indicates that the decimal portion has no cycle. So we return.\\n\\n**Time complexity**: Similar to the space complexity analysis done below, this problem does not have a traditionally well defined large input, since if we consider an input like numerator = 9000, denominator = 1, Time complexity is constant, even though numerator is large. Time complexity really only depends on the size of the cycle. But size of cycle does not depend on the \"size\" of either numerator or denominator. So time complexity is not well defined here either. \\n**Space complexity**: This will depend on how much space our output array uses. Our output array uses as much space as the longest cycle. This does not directly depend on numerator, denominator, at least in the traditional way we do space complexity analyses. Because large inputs are not well defined in this case. Because a large input could be numerator = 9000, denominator = 1, but that has a constant time for output. So space complexity is not well defined, since we don\\'t have a traditonally well defined large input, with which our space complexity grows alongside. \\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        output = []\\n        \\n        if (numerator < 0) ^ (denominator < 0): \\n            output.append(\\'-\\')\\n            \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # integral part\\n        quotient = numerator // denominator\\n        output.append(str(quotient)) # do i need str here?\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(output)\\n        \\n        # decimal part\\n        output.append(\\'.\\')\\n        remainderToIndexSeen={}\\n        \\n        while remainder != 0:\\n            if remainder in remainderToIndexSeen:\\n                output.insert(remainderToIndexSeen[remainder], \"(\")\\n                output.append(\")\")\\n                break\\n            remainderToIndexSeen[remainder] = len(output)\\n            \\n            # Next 3 lines of code simulate 3 steps of long division:\\n            \\n            # 1) bring down the zero\\n            remainder *= 10 \\n            \\n            # 2) find the next part of quotient\\n            output.append(str(remainder // denominator)) \\n            \\n            # 3) subtract to find the new remainder\\n            remainder %= denominator \\n        \\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0: return \"0\"\\n        output = []\\n        \\n        if (numerator < 0) ^ (denominator < 0): \\n            output.append(\\'-\\')\\n            \\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # integral part\\n        quotient = numerator // denominator\\n        output.append(str(quotient)) # do i need str here?\\n        remainder = numerator % denominator\\n        \\n        if remainder == 0: return \\'\\'.join(output)\\n        \\n        # decimal part\\n        output.append(\\'.\\')\\n        remainderToIndexSeen={}\\n        \\n        while remainder != 0:\\n            if remainder in remainderToIndexSeen:\\n                output.insert(remainderToIndexSeen[remainder], \"(\")\\n                output.append(\")\")\\n                break\\n            remainderToIndexSeen[remainder] = len(output)\\n            \\n            # Next 3 lines of code simulate 3 steps of long division:\\n            \\n            # 1) bring down the zero\\n            remainder *= 10 \\n            \\n            # 2) find the next part of quotient\\n            output.append(str(remainder // denominator)) \\n            \\n            # 3) subtract to find the new remainder\\n            remainder %= denominator \\n        \\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827938,
                "title": "solution-without-storing-all-remainders-o-1-space-python",
                "content": "Explanations added in the code as comments\\n```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        \\n        # Find sign of result\\n        sign = 1\\n        if numerator < 0:\\n            numerator = -numerator\\n            sign *= -1\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign *= -1\\n        \\n        # Calculate integer part before the decimal\\n        intPart = int(numerator / denominator)\\n        numerator %= denominator\\n        numerator = numerator = numerator\\n        \\n        # Ensure that the numerator and denominator do not have 2 or 5\\n        # as a common factor\\n        while numerator % 2 == 0 and denominator % 2 == 0:\\n            numerator /= 2\\n            denominator /= 2\\n        while numerator % 5 == 5 and denominator % 5 == 0:\\n            numerator /= 5\\n            denominator /= 5\\n            \\n        # At this point the number of non recurring digits after the decimal\\n        # point will be:\\n        # Max(m,n)\\n        # where m is the highest number for which 2^m divides denominator\\n        # and n is the highest number for which 5^n divides denominator\\n        num = denominator\\n        num2Factors = 0\\n        while num % (2 ** (num2Factors + 1)) == 0:\\n            num2Factors += 1\\n        num5Factors = 0\\n        while num % (5 ** (num5Factors + 1)) == 0:\\n            num5Factors += 1\\n        nonRecc = max(num2Factors, num5Factors)\\n        \\n        # Calculate the non recurring decimal part of the result\\n        decPart = \\'\\'\\n        while nonRecc and numerator:\\n            numerator *= 10\\n            decPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            nonRecc -= 1\\n            \\n        # firstNum is the numerator which will be repeated in the recurring part\\n        # of the result.\\n        # Calculate the recurring decimal part of the result by dividing until\\n        # we get firstNum again.\\n        firstNum = numerator\\n        reccPart = \\'\\'\\n        while numerator:\\n            numerator *= 10\\n            reccPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            if numerator == firstNum:\\n                break\\n        \\n        # Construct the result from the individual parts\\n        res = \\'\\' if sign == 1 else \\'-\\'\\n        res += str(intPart)\\n        if decPart or reccPart:\\n            res += \\'.\\'\\n        res += decPart\\n        if reccPart:\\n            res += \\'(\\' + reccPart + \\')\\'\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator == 0:\\n            return \"0\"\\n        \\n        # Find sign of result\\n        sign = 1\\n        if numerator < 0:\\n            numerator = -numerator\\n            sign *= -1\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign *= -1\\n        \\n        # Calculate integer part before the decimal\\n        intPart = int(numerator / denominator)\\n        numerator %= denominator\\n        numerator = numerator = numerator\\n        \\n        # Ensure that the numerator and denominator do not have 2 or 5\\n        # as a common factor\\n        while numerator % 2 == 0 and denominator % 2 == 0:\\n            numerator /= 2\\n            denominator /= 2\\n        while numerator % 5 == 5 and denominator % 5 == 0:\\n            numerator /= 5\\n            denominator /= 5\\n            \\n        # At this point the number of non recurring digits after the decimal\\n        # point will be:\\n        # Max(m,n)\\n        # where m is the highest number for which 2^m divides denominator\\n        # and n is the highest number for which 5^n divides denominator\\n        num = denominator\\n        num2Factors = 0\\n        while num % (2 ** (num2Factors + 1)) == 0:\\n            num2Factors += 1\\n        num5Factors = 0\\n        while num % (5 ** (num5Factors + 1)) == 0:\\n            num5Factors += 1\\n        nonRecc = max(num2Factors, num5Factors)\\n        \\n        # Calculate the non recurring decimal part of the result\\n        decPart = \\'\\'\\n        while nonRecc and numerator:\\n            numerator *= 10\\n            decPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            nonRecc -= 1\\n            \\n        # firstNum is the numerator which will be repeated in the recurring part\\n        # of the result.\\n        # Calculate the recurring decimal part of the result by dividing until\\n        # we get firstNum again.\\n        firstNum = numerator\\n        reccPart = \\'\\'\\n        while numerator:\\n            numerator *= 10\\n            reccPart += str(int(numerator / denominator))\\n            numerator %= denominator\\n            if numerator == firstNum:\\n                break\\n        \\n        # Construct the result from the individual parts\\n        res = \\'\\' if sign == 1 else \\'-\\'\\n        res += str(intPart)\\n        if decPart or reccPart:\\n            res += \\'.\\'\\n        res += decPart\\n        if reccPart:\\n            res += \\'(\\' + reccPart + \\')\\'\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777285,
                "title": "accepted-c-stringstream-with-unordered-set-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    // Updated the signature to int64_t to handle specific cases like abs(INT_MIN)\\n    string fractionToDecimal(int64_t numerator, int64_t denominator) {\\n        // special case\\n        if (numerator == 0) return \"0\";\\n        // we will use string stream to store the result\\n        stringstream res;        \\n        // if negative, we will add \"-\"\\n        if (numerator > 0 ^ denominator > 0) \\n            res << \"-\";\\n        \\n\\t\\t// working now with absolute values\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        // add the int result.\\n        res << (numerator/denominator);\\n        \\n        // working with the remainder \\n        numerator = numerator % denominator;\\n        \\n        // if we have a fraction, we need to add a \".\"\\n        if (numerator > 0) \\n            res << \".\";\\n        \\n        unordered_set<int> dups;        \\n        bool re = false;\\n        stringstream reStream;\\n        while (numerator != 0) {\\n            if (dups.count(numerator) > 0) {\\n\\t\\t\\t\\t// we have a repeat, let\\'s identify the repeated fraction or break if have already found it.\\n                if (!re) {\\n\\t\\t\\t\\t\\t// let\\'s find out the repeated fraction\\n\\t\\t\\t\\t\\tre = true;\\n\\t\\t\\t\\t\\t// clear the map for the next repeated segment.\\n                    dups.clear();\\n                } else { \\n                    break; \\n                }\\n            }\\n\\t\\t\\t// keep track of numerator values to detect the next duplicated fraction if it exists\\n            dups.insert(numerator);\\n            \\n            numerator *= 10;\\n            if (!re) {\\n                // non repeated fraction stream\\n                res << (numerator / denominator);\\n            } else {\\n                // repeated fraction stream.\\n                reStream << (numerator / denominator);\\n            }\\n            // working with the remainder of numerator\\n            numerator = numerator % denominator;\\n        }\\n        \\n        // in case we have a repeated fraction\\n        string repeatedFraction = reStream.str();\\n        if (!repeatedFraction.empty()) {\\n            string ans = res.str();\\n            // find the start position of the repeat\\n            auto repeat = ans.find(repeatedFraction);\\n            // reset the stream\\n            res.str(std::string());\\n            res << ans.substr(0, repeat) << \"(\" << ans.substr(repeat) << \")\";\\n        }\\n        return res.str();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Updated the signature to int64_t to handle specific cases like abs(INT_MIN)\\n    string fractionToDecimal(int64_t numerator, int64_t denominator) {\\n        // special case\\n        if (numerator == 0) return \"0\";\\n        // we will use string stream to store the result\\n        stringstream res;        \\n        // if negative, we will add \"-\"\\n        if (numerator > 0 ^ denominator > 0) \\n            res << \"-\";\\n        \\n\\t\\t// working now with absolute values\\n        numerator = abs(numerator);\\n        denominator = abs(denominator);\\n        \\n        // add the int result.\\n        res << (numerator/denominator);\\n        \\n        // working with the remainder \\n        numerator = numerator % denominator;\\n        \\n        // if we have a fraction, we need to add a \".\"\\n        if (numerator > 0) \\n            res << \".\";\\n        \\n        unordered_set<int> dups;        \\n        bool re = false;\\n        stringstream reStream;\\n        while (numerator != 0) {\\n            if (dups.count(numerator) > 0) {\\n\\t\\t\\t\\t// we have a repeat, let\\'s identify the repeated fraction or break if have already found it.\\n                if (!re) {\\n\\t\\t\\t\\t\\t// let\\'s find out the repeated fraction\\n\\t\\t\\t\\t\\tre = true;\\n\\t\\t\\t\\t\\t// clear the map for the next repeated segment.\\n                    dups.clear();\\n                } else { \\n                    break; \\n                }\\n            }\\n\\t\\t\\t// keep track of numerator values to detect the next duplicated fraction if it exists\\n            dups.insert(numerator);\\n            \\n            numerator *= 10;\\n            if (!re) {\\n                // non repeated fraction stream\\n                res << (numerator / denominator);\\n            } else {\\n                // repeated fraction stream.\\n                reStream << (numerator / denominator);\\n            }\\n            // working with the remainder of numerator\\n            numerator = numerator % denominator;\\n        }\\n        \\n        // in case we have a repeated fraction\\n        string repeatedFraction = reStream.str();\\n        if (!repeatedFraction.empty()) {\\n            string ans = res.str();\\n            // find the start position of the repeat\\n            auto repeat = ans.find(repeatedFraction);\\n            // reset the stream\\n            res.str(std::string());\\n            res << ans.substr(0, repeat) << \"(\" << ans.substr(repeat) << \")\";\\n        }\\n        return res.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703787,
                "title": "python3-32ms-intuitive",
                "content": "\\tclass Solution:\\n\\t\\tdef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\t\\t\\tif denominator  == 0 : return \\'\\'\\n\\t\\t\\tif numerator == 0: return \\'0\\'\\n\\n\\t\\t\\t# sign part\\n\\t\\t\\tsign = \\'\\' if numerator*denominator >= 0 else \\'-\\'\\n\\n\\t\\t\\t# to non-negative vals\\n\\t\\t\\tnumerator = abs(numerator)\\n\\t\\t\\tdenominator = abs(denominator)\\n\\n\\t\\t\\t# int part\\n\\t\\t\\tint_part = str(numerator//denominator)\\n\\t\\t\\tif numerator%denominator == 0:\\n\\t\\t\\t\\treturn sign + int_part\\n\\n\\t\\t\\t# fractional part\\n\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\tfrac = []\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tvisited = dict()\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif numerator in visited: break # save numerator\\n\\t\\t\\t\\tvisited[numerator] = cnt\\n\\t\\t\\t\\tnumerator *= 10\\n\\t\\t\\t\\tif numerator < denominator:\\n\\t\\t\\t\\t\\tfrac.append(\\'0\\')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrac.append(str(numerator//denominator))\\n\\t\\t\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t# repeat part\\n\\t\\t\\ttail = \\'\\'.join(frac[visited[numerator]:cnt])\\n\\t\\t\\ttail = \\'(\\' + tail + \\')\\' if tail and tail != \\'0\\' else \\'\\'  \\n\\t\\t\\t# sign + int + dot + frac + repeat\\n\\t\\t\\treturn sign + int_part + \\'.\\' + \\'\\'.join(frac[:visited[numerator]]) + tail\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\t\\t\\tif denominator  == 0 : return \\'\\'\\n\\t\\t\\tif numerator == 0: return \\'0\\'\\n\\n\\t\\t\\t# sign part\\n\\t\\t\\tsign = \\'\\' if numerator*denominator >= 0 else \\'-\\'\\n\\n\\t\\t\\t# to non-negative vals\\n\\t\\t\\tnumerator = abs(numerator)\\n\\t\\t\\tdenominator = abs(denominator)\\n\\n\\t\\t\\t# int part\\n\\t\\t\\tint_part = str(numerator//denominator)\\n\\t\\t\\tif numerator%denominator == 0:\\n\\t\\t\\t\\treturn sign + int_part\\n\\n\\t\\t\\t# fractional part\\n\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\tfrac = []\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tvisited = dict()\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif numerator in visited: break # save numerator\\n\\t\\t\\t\\tvisited[numerator] = cnt\\n\\t\\t\\t\\tnumerator *= 10\\n\\t\\t\\t\\tif numerator < denominator:\\n\\t\\t\\t\\t\\tfrac.append(\\'0\\')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrac.append(str(numerator//denominator))\\n\\t\\t\\t\\t\\tnumerator= numerator % denominator\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t# repeat part\\n\\t\\t\\ttail = \\'\\'.join(frac[visited[numerator]:cnt])\\n\\t\\t\\ttail = \\'(\\' + tail + \\')\\' if tail and tail != \\'0\\' else \\'\\'  \\n\\t\\t\\t# sign + int + dot + frac + repeat\\n\\t\\t\\treturn sign + int_part + \\'.\\' + \\'\\'.join(frac[:visited[numerator]]) + tail\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 691856,
                "title": "c-easy-to-understand-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        long long  n = numerator;\\n        long long  d = denominator;\\n        \\n        if(!n)return \"0\";\\n        \\n        string sign = ((n/abs(n)) != (d/abs(d)))?\"-\":\"\";\\n        \\n        n = abs(n);\\n        d = abs(d);\\n        \\n        \\n        string ans = to_string(n/d);\\n        \\n        if(!(n%d))return sign + ans;\\n\\n        ans+=\\'.\\';\\n        \\n        n = n%d;\\n        \\n        unordered_map<int,int>mp;\\n        mp[n]=ans.size();\\n     \\n        \\n        while(n){\\n            n*=10;\\n            while(n<d){\\n                n*=10;\\n                ans+=\\'0\\';\\n            }\\n            \\n            ans += to_string(n/d);\\n            n = n%d;\\n            if(mp[n]){\\n                string s1 = ans.substr(0,mp[n]);\\n                string s2 =\"(\" + ans.substr(mp[n]) + \")\";\\n                return sign + s1 + s2;\\n            }\\n            \\n            mp[n] = ans.size();\\n        }\\n        \\n        return sign + ans;\\n        \\n        \\n     \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        long long  n = numerator;\\n        long long  d = denominator;\\n        \\n        if(!n)return \"0\";\\n        \\n        string sign = ((n/abs(n)) != (d/abs(d)))?\"-\":\"\";\\n        \\n        n = abs(n);\\n        d = abs(d);\\n        \\n        \\n        string ans = to_string(n/d);\\n        \\n        if(!(n%d))return sign + ans;\\n\\n        ans+=\\'.\\';\\n        \\n        n = n%d;\\n        \\n        unordered_map<int,int>mp;\\n        mp[n]=ans.size();\\n     \\n        \\n        while(n){\\n            n*=10;\\n            while(n<d){\\n                n*=10;\\n                ans+=\\'0\\';\\n            }\\n            \\n            ans += to_string(n/d);\\n            n = n%d;\\n            if(mp[n]){\\n                string s1 = ans.substr(0,mp[n]);\\n                string s2 =\"(\" + ans.substr(mp[n]) + \")\";\\n                return sign + s1 + s2;\\n            }\\n            \\n            mp[n] = ans.size();\\n        }\\n        \\n        return sign + ans;\\n        \\n        \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626411,
                "title": "c-solution",
                "content": "```\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool minus =false;\\n        long den = denominator;\\n        long num= numerator;\\n        if(den<0)\\n        {\\n            den = abs((long long)den);\\n            minus= !minus;\\n        }\\n        if(num<0)\\n        {\\n            num= abs((long long)num);\\n            minus= !minus;\\n        }\\n        \\n        long int rem = num%den;\\n        long int r = num/den;\\n        string result = to_string(r);\\n        if(minus && (r>0 || rem>0))\\n        {\\n            result =\"-\"+result;\\n        }\\n        if(rem==0)\\n        {\\n            return result;\\n        }\\n        int start=0;\\n        \\n        map<long,int> rem_res;\\n        string repeat=\"\";\\n        while(rem!=0 && rem_res.find(rem)==rem_res.end())\\n        {\\n            rem_res[rem]=start++;\\n            rem=rem*10;\\n            long temp = rem/den;\\n            \\n            repeat+=to_string(temp);\\n            \\n            rem = rem%den;\\n        }\\n        \\n        if(rem!=0)\\n        {\\n            int pos=rem_res[rem];\\n            if(pos > 0)\\n            {\\n                result+= \".\"+repeat.substr(0,pos)+\"(\"+ repeat.substr(pos)+\")\";\\n            }\\n            else \\n            {\\n                result+= \".(\"+ repeat.substr(pos)+\")\";\\n            }\\n            \\n        }\\n        else\\n        {\\n            result += \".\"+repeat;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool minus =false;\\n        long den = denominator;\\n        long num= numerator;\\n        if(den<0)\\n        {\\n            den = abs((long long)den);\\n            minus= !minus;\\n        }\\n        if(num<0)\\n        {\\n            num= abs((long long)num);\\n            minus= !minus;\\n        }\\n        \\n        long int rem = num%den;\\n        long int r = num/den;\\n        string result = to_string(r);\\n        if(minus && (r>0 || rem>0))\\n        {\\n            result =\"-\"+result;\\n        }\\n        if(rem==0)\\n        {\\n            return result;\\n        }\\n        int start=0;\\n        \\n        map<long,int> rem_res;\\n        string repeat=\"\";\\n        while(rem!=0 && rem_res.find(rem)==rem_res.end())\\n        {\\n            rem_res[rem]=start++;\\n            rem=rem*10;\\n            long temp = rem/den;\\n            \\n            repeat+=to_string(temp);\\n            \\n            rem = rem%den;\\n        }\\n        \\n        if(rem!=0)\\n        {\\n            int pos=rem_res[rem];\\n            if(pos > 0)\\n            {\\n                result+= \".\"+repeat.substr(0,pos)+\"(\"+ repeat.substr(pos)+\")\";\\n            }\\n            else \\n            {\\n                result+= \".(\"+ repeat.substr(pos)+\")\";\\n            }\\n            \\n        }\\n        else\\n        {\\n            result += \".\"+repeat;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617207,
                "title": "java-using-hash-map",
                "content": "Using long to avoid corner case;\\nconvert to long before get abs value to avoid overflow.\\n\\nusing map to remember last remainder, for period.\\n\\n```\\n    public String fractionToDecimal(int nm, int dm) {\\n        if (dm == 0 || nm == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append((dm > 0) ^ (nm > 0) ? \"-\" : \"\");\\n        long d = Math.abs((long)dm), n = Math.abs((long)nm);  // must use (long)dm for -1, -2147483648\\n        sb.append(n / d);\\n        long rem = n % d;\\n        if (rem == 0) return sb.toString();\\n        sb.append(\".\");\\n        Map<Long, Integer> map = new HashMap<>();\\n        while(rem != 0) {\\n            if (map.containsKey(rem)){\\n                sb.insert(map.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / d);\\n            rem = rem % d;\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String fractionToDecimal(int nm, int dm) {\\n        if (dm == 0 || nm == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append((dm > 0) ^ (nm > 0) ? \"-\" : \"\");\\n        long d = Math.abs((long)dm), n = Math.abs((long)nm);  // must use (long)dm for -1, -2147483648\\n        sb.append(n / d);\\n        long rem = n % d;\\n        if (rem == 0) return sb.toString();\\n        sb.append(\".\");\\n        Map<Long, Integer> map = new HashMap<>();\\n        while(rem != 0) {\\n            if (map.containsKey(rem)){\\n                sb.insert(map.get(rem), \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            map.put(rem, sb.length());\\n            rem *= 10;\\n            sb.append(rem / d);\\n            rem = rem % d;\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 611572,
                "title": "concise-java-solution-intuition-explained-important-to-understand-the-edge-cases",
                "content": "Intution is that if repeation occurs in the remainder than something needs to done and something can be done only with help of memory as how will we know if same case has occurred. Intutition is same as that of happy number with a lot of edge cases. It is fun learning this problem #happycoding\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        /* we need to take care of \\n        a) sign\\n        b) overflow case of -ve case of Integer.MAX_VALUE;\\n        c) memory overflow\\n        */\\n        if(numerator==0)\\n            return new String(\"0\");\\n        StringBuilder result = new StringBuilder();\\n        /* handle the sign */\\n        if(numerator <0 ^ denominator <0)\\n            result.append(\"-\");\\n        \\n        /* converting to long other wise -ve case of Integer.MAX_VALUE will\\n        overflow */\\n        long num = Math.abs(Long.valueOf(numerator));\\n        long denom = Math.abs(Long.valueOf(denominator));\\n        result.append(num/denom);\\n        long remainder = num % denom;\\n        if(remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        Map<Long,Integer> store = new HashMap<>(); \\n        while(remainder!=0){\\n            \\n            /* if the same remainder comes then we know that everything will\\n            repeat */\\n            if(store.containsKey(remainder)){\\n                result.insert(store.get(remainder),\"(\");\\n                result.append(\")\");\\n                break;\\n            }\\n            \\n            store.put(remainder,result.length());\\n            remainder*=10;\\n            result.append(String.valueOf(remainder/denom));\\n            remainder = remainder % denominator;\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        /* we need to take care of \\n        a) sign\\n        b) overflow case of -ve case of Integer.MAX_VALUE;\\n        c) memory overflow\\n        */\\n        if(numerator==0)\\n            return new String(\"0\");\\n        StringBuilder result = new StringBuilder();\\n        /* handle the sign */\\n        if(numerator <0 ^ denominator <0)\\n            result.append(\"-\");\\n        \\n        /* converting to long other wise -ve case of Integer.MAX_VALUE will\\n        overflow */\\n        long num = Math.abs(Long.valueOf(numerator));\\n        long denom = Math.abs(Long.valueOf(denominator));\\n        result.append(num/denom);\\n        long remainder = num % denom;\\n        if(remainder == 0)\\n            return result.toString();\\n        result.append(\".\");\\n        Map<Long,Integer> store = new HashMap<>(); \\n        while(remainder!=0){\\n            \\n            /* if the same remainder comes then we know that everything will\\n            repeat */\\n            if(store.containsKey(remainder)){\\n                result.insert(store.get(remainder),\"(\");\\n                result.append(\")\");\\n                break;\\n            }\\n            \\n            store.put(remainder,result.length());\\n            remainder*=10;\\n            result.append(String.valueOf(remainder/denom));\\n            remainder = remainder % denominator;\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515772,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        if (denominator == 0)\\n        {\\n            //throw new IllegalArgumentException(\" denominator can not be zero\");\\n            throw new ArgumentException(\" denominator can not be zero\");\\n        }\\n\\n        // avoid overflow for minimum value of integer\\n        long newNum = (long)numerator;\\n        long newDeNom = (long)denominator;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        // detect sign\\n        if ((newNum > 0 && newDeNom < 0) || (newNum < 0 && newDeNom > 0))\\n            sb.Append(\"-\");\\n        \\n        // make sure it is postive value\\n        newNum = Math.Abs(newNum);\\n        newDeNom = Math.Abs(newDeNom);      \\n\\n        sb.Append(newNum / newDeNom);\\n\\n        long remainder = newNum % newDeNom;\\n        Dictionary<long, int> remainderMap = new Dictionary<long, int>();\\n\\n        if (remainder != 0)\\n            sb.Append(\".\");\\n\\n        while (remainder != 0 && !remainderMap.ContainsKey(remainder))\\n        {\\n            remainderMap.Add(remainder, sb.Length);\\n            remainder *= 10;\\n            sb.Append(remainder / newDeNom);\\n            remainder = remainder % newDeNom; \\n        }\\n\\n        if (remainderMap.ContainsKey(remainder))\\n        {\\n            sb.Insert(remainderMap[remainder], \"(\");\\n            sb.Append(\")\");\\n        }\\n        return sb.ToString();\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        if (denominator == 0)\\n        {\\n            //throw new IllegalArgumentException(\" denominator can not be zero\");\\n            throw new ArgumentException(\" denominator can not be zero\");\\n        }\\n\\n        // avoid overflow for minimum value of integer\\n        long newNum = (long)numerator;\\n        long newDeNom = (long)denominator;\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        // detect sign\\n        if ((newNum > 0 && newDeNom < 0) || (newNum < 0 && newDeNom > 0))\\n            sb.Append(\"-\");\\n        \\n        // make sure it is postive value\\n        newNum = Math.Abs(newNum);\\n        newDeNom = Math.Abs(newDeNom);      \\n\\n        sb.Append(newNum / newDeNom);\\n\\n        long remainder = newNum % newDeNom;\\n        Dictionary<long, int> remainderMap = new Dictionary<long, int>();\\n\\n        if (remainder != 0)\\n            sb.Append(\".\");\\n\\n        while (remainder != 0 && !remainderMap.ContainsKey(remainder))\\n        {\\n            remainderMap.Add(remainder, sb.Length);\\n            remainder *= 10;\\n            sb.Append(remainder / newDeNom);\\n            remainder = remainder % newDeNom; \\n        }\\n\\n        if (remainderMap.ContainsKey(remainder))\\n        {\\n            sb.Insert(remainderMap[remainder], \"(\");\\n            sb.Append(\")\");\\n        }\\n        return sb.ToString();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425909,
                "title": "python3-two-100-clear-workflow",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        res = \\'\\'\\n        # sign\\n        if numerator*denominator<0:\\n            res+=\\'-\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        \\n        # before point\\n        res+= str(numerator//denominator)\\n        carrier = numerator%denominator\\n        \\n        # after point\\n        if carrier>0:\\n            res+=\\'.\\'\\n        memo = {}\\n        while carrier>0:\\n            if carrier in memo:\\n                index = memo[carrier]\\n                res = res[:index]+\\'(\\'+res[index:] +\\')\\'\\n                return res\\n            else:\\n                memo[carrier]=len(res)\\n                res+=str((carrier*10)//denominator)\\n                carrier = ((carrier*10)%denominator)\\n                \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        res = \\'\\'\\n        # sign\\n        if numerator*denominator<0:\\n            res+=\\'-\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        \\n        # before point\\n        res+= str(numerator//denominator)\\n        carrier = numerator%denominator\\n        \\n        # after point\\n        if carrier>0:\\n            res+=\\'.\\'\\n        memo = {}\\n        while carrier>0:\\n            if carrier in memo:\\n                index = memo[carrier]\\n                res = res[:index]+\\'(\\'+res[index:] +\\')\\'\\n                return res\\n            else:\\n                memo[carrier]=len(res)\\n                res+=str((carrier*10)//denominator)\\n                carrier = ((carrier*10)%denominator)\\n                \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 405994,
                "title": "python-easy-understanding",
                "content": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # if this can be divided completely\\n        if numerator % denominator == 0: return str(numerator // denominator)\\n        \\n        # extract the symbol of negative or positive number of the result\\n        sign = \\'-\\' if numerator * denominator < 0 else \\'\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        ans = \\'\\'\\n        rem_pos = {} # store recurring number\\n        i = numerator // denominator # integer part\\n        rem = numerator % denominator\\n        \\n        while rem != 0 and rem not in rem_pos:\\n            rem_pos[rem] = len(rem_pos) # {remainder : position}\\n            numerator = rem * 10\\n            \\n            dec_part = numerator // denominator\\n            ans += str(dec_part)\\n            \\n            rem = numerator % denominator\\n        \\n        if rem == 0: return sign + str(i) + \\'.\\' + ans # no recurring\\n        return sign + str(i) + \\'.\\' + ans[:rem_pos[rem]] + \\'(\\' + ans[rem_pos[rem]:] + \\')\\' # recurring\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # if this can be divided completely\\n        if numerator % denominator == 0: return str(numerator // denominator)\\n        \\n        # extract the symbol of negative or positive number of the result\\n        sign = \\'-\\' if numerator * denominator < 0 else \\'\\'\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        ans = \\'\\'\\n        rem_pos = {} # store recurring number\\n        i = numerator // denominator # integer part\\n        rem = numerator % denominator\\n        \\n        while rem != 0 and rem not in rem_pos:\\n            rem_pos[rem] = len(rem_pos) # {remainder : position}\\n            numerator = rem * 10\\n            \\n            dec_part = numerator // denominator\\n            ans += str(dec_part)\\n            \\n            rem = numerator % denominator\\n        \\n        if rem == 0: return sign + str(i) + \\'.\\' + ans # no recurring\\n        return sign + str(i) + \\'.\\' + ans[:rem_pos[rem]] + \\'(\\' + ans[rem_pos[rem]:] + \\')\\' # recurring\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330668,
                "title": "c-100-beat-o-1-run-time-koderz-kamp-l33t-solution-kool",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool aNegative = (numerator < 0) != (denominator < 0);\\n        long long aNum = numerator, aDen = denominator;\\n        \\n        aNum = abs(aNum);\\n        aDen = abs(aDen);\\n        \\n        long long aDigit = aNum / aDen;\\n        string aResult = to_string(aDigit);\\n        \\n        long long aRemainder = (aNum % aDen) * 10;\\n        \\n        if (aNegative && (aDigit != 0 || aRemainder != 0)) {\\n            aResult = string(\"-\") + aResult;\\n        }\\n        \\n        if (aRemainder != 0) { \\n            \\n            aResult.append(\".\");\\n            unordered_map<int, int> aRepeatMap(64);\\n            \\n            while (aRemainder != 0) {\\n                if (aRepeatMap[aRemainder] != 0) {\\n                    aResult.insert(aRepeatMap[aRemainder], \"(\");\\n                    aResult.append(\")\");\\n                    break;\\n                } else {\\n                    aRepeatMap[aRemainder] = aResult.size();\\n                    aResult.append(to_string(aRemainder / aDen));\\n                    aRemainder = (aRemainder % aDen) * 10;\\n                }   \\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nFor some reason, I kept thinking the numerator had to be in the loop? I was doing it by hand, translating into code makes me rip out hairs. Ahh!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        bool aNegative = (numerator < 0) != (denominator < 0);\\n        long long aNum = numerator, aDen = denominator;\\n        \\n        aNum = abs(aNum);\\n        aDen = abs(aDen);\\n        \\n        long long aDigit = aNum / aDen;\\n        string aResult = to_string(aDigit);\\n        \\n        long long aRemainder = (aNum % aDen) * 10;\\n        \\n        if (aNegative && (aDigit != 0 || aRemainder != 0)) {\\n            aResult = string(\"-\") + aResult;\\n        }\\n        \\n        if (aRemainder != 0) { \\n            \\n            aResult.append(\".\");\\n            unordered_map<int, int> aRepeatMap(64);\\n            \\n            while (aRemainder != 0) {\\n                if (aRepeatMap[aRemainder] != 0) {\\n                    aResult.insert(aRepeatMap[aRemainder], \"(\");\\n                    aResult.append(\")\");\\n                    break;\\n                } else {\\n                    aRepeatMap[aRemainder] = aResult.size();\\n                    aResult.append(to_string(aRemainder / aDen));\\n                    aRemainder = (aRemainder % aDen) * 10;\\n                }   \\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314537,
                "title": "use-python-to-resolve-o-n",
                "content": "class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n\\n\\n        tag = -1 if numerator * denominator < 0 else 1 #\\u5224\\u65AD\\u662F\\u5426\\u6709\\u6B63\\u8D1F\\u53F7\\uFF0C\\u4EE3\\u7801\\u4E2D\\u7528\\u6B63\\u6570\\u8FDB\\u884C\\u76F8\\u9664\\uFF0C\\u82E5\\u6709\\u8D1F\\u53F7\\u6700\\u540E\\u52A0\\u4E0A\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        re_num = \\'\\'\\n        dictionary = {}\\n        while 1:\\n            if not re_num:#\\u9996\\u6B21\\u8FDB\\u884C\\u8BA1\\u7B97\\n                value = numerator // denominator\\n                numerator = numerator % denominator\\n                # print(value,numerator)\\n                if numerator == 0:#\\u65E0\\u5FAA\\u73AF\\n                    re_num += str(value)\\n                    return re_num if tag == 1 else \\'-\\' + re_num\\n                else:\\n                    re_num = str(value) + \\'.\\'\\n            else: #\\u540E\\u7EED\\u8BA1\\u7B97\\uFF0C\\u5373\\u5BFB\\u627E\\u5FAA\\u73AF\\u9879\\uFF0C\\u82E5\\u6CA1\\u6709\\uFF0C\\u76F4\\u63A5return\\n                numerator *= 10\\n                value = numerator // denominator\\n                numerator = numerator % denominator\\n\\n                if numerator == 0:#\\u65E0\\u5FAA\\u73AF\\n                    re_num += str(value)\\n                    return re_num if tag == 1 else \\'-\\' + re_num\\n                else:#\\u6709\\u5FAA\\u73AF\\u65F6\\u8FD4\\u56DE\\n                    if str(value) + \\' \\' + str(numerator) in dictionary:\\n                        re_num = re_num[:dictionary[str(value) + \\' \\' + str(numerator)]] + \\'(\\' + re_num[dictionary[str(\\n                            value) + \\' \\' + str(numerator)]:] + \\')\\'\\n                        return re_num if tag == 1 else \\'-\\' + re_num\\n                    else:\\n                        dictionary[str(value) + \\' \\' + str(numerator)] = len(re_num)\\n                        re_num += str(value)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def fractionToDecimal(self, numerator, denominator):\\n        \"\"\"\\n        :type numerator: int\\n        :type denominator: int\\n        :rtype: str\\n        \"\"\"\\n\\n\\n        tag = -1 if numerator * denominator < 0 else 1 #\\u5224\\u65AD\\u662F\\u5426\\u6709\\u6B63\\u8D1F\\u53F7\\uFF0C\\u4EE3\\u7801\\u4E2D\\u7528\\u6B63\\u6570\\u8FDB\\u884C\\u76F8\\u9664\\uFF0C\\u82E5\\u6709\\u8D1F\\u53F7\\u6700\\u540E\\u52A0\\u4E0A\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        re_num = \\'\\'\\n        dictionary = {}",
                "codeTag": "Java"
            },
            {
                "id": 239616,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n- After the decimal point, we need to record all the remainders and the corresponding position to insert `(`. \\n - When we get a new remainder which is not present in `HashMap`, then add it to the `HashMap` along with its position. This position will be helpful later in order to insert `(` in case when the remainder gets repeated.\\n - When the remainder is already in the `HashMap`, then it means the fractional part is repeating, so insert `(` to the corresponding position, then append `)` and break the loop.\\n\\nTime complexity : `O(k)` - where `k` is the number of times we get the distinct non-zero `remainder` during the fractional part division.\\nSpace complexity : `O(k)` - space required for `HashMap` to store distinct non-zero `remainders`.\\n\\n```\\nclass Solution\\n{\\n    public String fractionToDecimal(int numerator, int denominator)\\n\\t{\\n        Map<Long, Integer> map = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\t\\tlong r = n % d;\\n\\t\\t\\n        if(numerator != 0 && numerator > 0 ^ denominator > 0) \\n            sb.append(\"-\");\\n\\t\\t\\n        sb.append(n / d);                       // Integral part\\n\\n        if(r > 0)\\n\\t\\t\\tsb.append(\".\");\\t\\t\\t\\t\\t\\t// Fractional part\\n\\t\\t\\n        while(r > 0)\\n\\t\\t{\\n            if(map.containsKey(r))\\n\\t\\t\\t{\\n                int index = map.get(r);\\n                sb.insert(index, \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            else\\n\\t\\t\\t{\\n                map.put(r, sb.length());\\n                r = r * 10;\\n                sb.append(r / d);\\n                r = r % d;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String fractionToDecimal(int numerator, int denominator)\\n\\t{\\n        Map<Long, Integer> map = new HashMap<>();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n        long n = Math.abs((long)numerator);\\n        long d = Math.abs((long)denominator);\\n\\t\\tlong r = n % d;\\n\\t\\t\\n        if(numerator != 0 && numerator > 0 ^ denominator > 0) \\n            sb.append(\"-\");\\n\\t\\t\\n        sb.append(n / d);                       // Integral part\\n\\n        if(r > 0)\\n\\t\\t\\tsb.append(\".\");\\t\\t\\t\\t\\t\\t// Fractional part\\n\\t\\t\\n        while(r > 0)\\n\\t\\t{\\n            if(map.containsKey(r))\\n\\t\\t\\t{\\n                int index = map.get(r);\\n                sb.insert(index, \"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n            else\\n\\t\\t\\t{\\n                map.put(r, sb.length());\\n                r = r * 10;\\n                sb.append(r / d);\\n                r = r % d;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183567,
                "title": "concise-python-solution",
                "content": "```\\ndef fractionToDecimal(self, a, b):\\n        sg = \\'-\\'*int(a*b < 0)\\n        a, b = abs(a), abs(b)\\n        d, a = str(a//b), a % b        \\n        \\n        vis, s = [], []\\n        a *= 10\\n        while a not in vis and a != 0:                        \\n            vis.append(a)            \\n            s.append(str(a//b))\\n            a = 10*(a % b)\\n                      \\n        i = 0 if a == 0 else vis.index(a)        \\n        return \\'\\'.join([sg, d, \\'.\\'* (len(s)>0)] + s[:i] + [\\'(\\'*(a>0)] + s[i:] + [\\')\\'*(a>0)]) ",
                "solutionTags": [],
                "code": "```\\ndef fractionToDecimal(self, a, b):\\n        sg = \\'-\\'*int(a*b < 0)\\n        a, b = abs(a), abs(b)\\n        d, a = str(a//b), a % b        \\n        \\n        vis, s = [], []\\n        a *= 10\\n        while a not in vis and a != 0:                        \\n            vis.append(a)            \\n            s.append(str(a//b))\\n            a = 10*(a % b)\\n                      \\n        i = 0 if a == 0 else vis.index(a)        \\n        return \\'\\'.join([sg, d, \\'.\\'* (len(s)>0)] + s[:i] + [\\'(\\'*(a>0)] + s[i:] + [\\')\\'*(a>0)]) ",
                "codeTag": "Python3"
            },
            {
                "id": 170235,
                "title": "c-neat",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) \\n            return \"0\"; // For example 0/m\\n        \\n        string ans;\\n        if (numerator < 0 ^ denominator < 0) \\n            ans += \\'-\\'; // -n/m, or n/-m\\n        \\n        long n, d, r; // numerator, denominator, and remainder\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        \\n        ans += to_string(n/d);\\n        r = n % d;\\n        if (!r)\\n            return ans;    // n/m where n is multiple of m\\n        \\n        // Here we know that, we should calculate the fraction part.\\n        unordered_map<long, int> m; // map for remainder to quotient index\\n        long                     q; // quotient;\\n        ans += \\'.\\';\\n        r *= 10;\\n        while(r) {\\n            q = r / d;\\n            if (m.count(r)) {\\n                // Here we know that remainder is repeating, \\n                // hence fraction part will repeat, but what is the starting position\\n                // of repeating fraction part? its the index of the quotient when\\n                // we last saw this remainder. That is m[r]!\\n                ans.insert(m[r], 1, \\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += to_string(q);\\n            r = (r % d) * 10;       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (!numerator) \\n            return \"0\"; // For example 0/m\\n        \\n        string ans;\\n        if (numerator < 0 ^ denominator < 0) \\n            ans += \\'-\\'; // -n/m, or n/-m\\n        \\n        long n, d, r; // numerator, denominator, and remainder\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        \\n        ans += to_string(n/d);\\n        r = n % d;\\n        if (!r)\\n            return ans;    // n/m where n is multiple of m\\n        \\n        // Here we know that, we should calculate the fraction part.\\n        unordered_map<long, int> m; // map for remainder to quotient index\\n        long                     q; // quotient;\\n        ans += \\'.\\';\\n        r *= 10;\\n        while(r) {\\n            q = r / d;\\n            if (m.count(r)) {\\n                // Here we know that remainder is repeating, \\n                // hence fraction part will repeat, but what is the starting position\\n                // of repeating fraction part? its the index of the quotient when\\n                // we last saw this remainder. That is m[r]!\\n                ans.insert(m[r], 1, \\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += to_string(q);\\n            r = (r % d) * 10;       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51119,
                "title": "golang-solution-using-math",
                "content": "Basic analysis can be borrowed from here:\\nhttp://yucoding.blogspot.com/2015/03/leetcode-question-fraction-to-recurring.html\\nBut the code can be simplified a bit.\\n\\n```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tflag := \"\"\\n\\tswitch {\\n\\tcase numerator < 0 && denominator < 0:\\n\\t\\tnumerator, denominator = -numerator, -denominator\\n\\tcase numerator > 0 && denominator < 0:\\n\\t\\tdenominator, flag = -denominator, \"-\"\\n\\tcase numerator < 0 && denominator > 0:\\n\\t\\tnumerator, flag = -numerator, \"-\"\\n\\t}\\n\\n\\tqua, rem := numerator/denominator, numerator%denominator\\n\\tres := []byte(strconv.FormatInt(int64(qua), 10))\\n\\tif rem == 0 {\\n\\t\\treturn flag + string(res)\\n\\t}\\n\\n\\tres = append(res, '.')\\n\\tm, curIndex := make(map[int]int), len(res)-1\\n\\tfor rem != 0 {\\n\\t\\tnumerator = rem * 10\\n\\t\\tqua, rem = numerator/denominator, numerator%denominator\\n\\n\\t\\tif index, ok := m[numerator]; ok {\\n\\t\\t\\tres = append(res, ')', ' ')\\n\\t\\t\\tcopy(res[index+1:], res[index:])\\n\\t\\t\\tres[index] = '('\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres = append(res, digitToByte(qua))\\n\\t\\tcurIndex++\\n\\t\\tm[numerator] = curIndex\\n\\t}\\n\\treturn flag + string(res)\\n}\\n\\nfunc digitToByte(digit int) byte {\\n\\treturn byte('0' + digit)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tflag := \"\"\\n\\tswitch {\\n\\tcase numerator < 0 && denominator < 0:\\n\\t\\tnumerator, denominator = -numerator, -denominator\\n\\tcase numerator > 0 && denominator < 0:\\n\\t\\tdenominator, flag = -denominator, \"-\"\\n\\tcase numerator < 0 && denominator > 0:\\n\\t\\tnumerator, flag = -numerator, \"-\"\\n\\t}\\n\\n\\tqua, rem := numerator/denominator, numerator%denominator\\n\\tres := []byte(strconv.FormatInt(int64(qua), 10))\\n\\tif rem == 0 {\\n\\t\\treturn flag + string(res)\\n\\t}\\n\\n\\tres = append(res, '.')\\n\\tm, curIndex := make(map[int]int), len(res)-1\\n\\tfor rem != 0 {\\n\\t\\tnumerator = rem * 10\\n\\t\\tqua, rem = numerator/denominator, numerator%denominator\\n\\n\\t\\tif index, ok := m[numerator]; ok {\\n\\t\\t\\tres = append(res, ')', ' ')\\n\\t\\t\\tcopy(res[index+1:], res[index:])\\n\\t\\t\\tres[index] = '('\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tres = append(res, digitToByte(qua))\\n\\t\\tcurIndex++\\n\\t\\tm[numerator] = curIndex\\n\\t}\\n\\treturn flag + string(res)\\n}\\n\\nfunc digitToByte(digit int) byte {\\n\\treturn byte('0' + digit)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51154,
                "title": "easy-understanding",
                "content": "public class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator == 0) return \"0\";\\n        if (denominator == 0) return \"\";\\n\\n        \\n        StringBuffer sb = new StringBuffer();\\n        boolean flag = (numerator < 0) ^ (denominator < 0);\\n        \\n        long num = Math.abs(numerator);\\n        long den = Math.abs(denominator);\\n        num = Math.abs(num);\\n        den = Math.abs(den);\\n\\n        long n = num / den;\\n        long remainder = (num % den) * 10;\\n        \\n        sb.append(flag ? \"-\" : \"\");\\n        sb.append(n);\\n        sb.append(remainder!=0?\".\":\"\");\\n\\n        HashMap<Long, Integer> hashMap = new HashMap<>();\\n        \\n        while (remainder != 0) {\\n\\n            if (hashMap.containsKey(remainder)) {\\n                int len = hashMap.get(remainder);\\n                sb.insert(len,'(');\\n                sb.append(')');\\n                break;\\n            } \\n\\n            hashMap.put(remainder, sb.length());\\n            n = remainder / den;\\n            sb.append(n);\\n            remainder = (remainder % den) * 10;\\n        }\\n\\n\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        \\n        if (numerator == 0) return \"0\";\\n        if (denominator == 0) return \"\";\\n\\n        \\n        StringBuffer sb = new StringBuffer();\\n        boolean flag = (numerator < 0) ^ (denominator < 0);\\n        \\n        long num = Math.abs(numerator);\\n        long den = Math.abs(denominator);\\n        num = Math.abs(num);\\n        den = Math.abs(den);\\n\\n        long n = num / den;\\n        long remainder = (num % den) * 10;\\n        \\n        sb.append(flag ? \"-\" : \"\");\\n        sb.append(n);\\n        sb.append(remainder!=0?\".\":\"\");\\n\\n        HashMap<Long, Integer> hashMap = new HashMap<>();\\n        \\n        while (remainder != 0) {\\n\\n            if (hashMap.containsKey(remainder)) {\\n                int len = hashMap.get(remainder);\\n                sb.insert(len,'(');\\n                sb.append(')');\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51188,
                "title": "python-solution-with-map",
                "content": "    class Solution:\\n    # @param {integer} numerator\\n    # @param {integer} denominator\\n    # @return {string}\\n    def fractionToDecimal(self, numerator, denominator):\\n        neg = False\\n        if numerator<0 and denominator>0 or numerator>0 and denominator<0:\\n            neg = True\\n            \\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        ans = str(numerator/denominator)\\n        if neg:\\n            ans = '-' + ans\\n            \\n        if numerator%denominator == 0:\\n            return ans\\n            \\n        dic = {}\\n        ans += '.'\\n        count = len(ans)\\n        \\n        \\n        tmp = numerator%denominator\\n        while True:\\n            if tmp not in dic:\\n                dic[tmp] = len(ans)\\n            else:\\n                ans = ans[:dic[tmp]] + '(' + ans[dic[tmp]:] + ')'\\n                break\\n            \\n            tmp *= 10\\n            if tmp < denominator:\\n                ans += '0'\\n                continue\\n            if tmp%denominator == 0:\\n                ans += str(tmp/denominator)\\n                break\\n            else:\\n                tmpans = tmp/denominator\\n                tmp = tmp%denominator\\n                ans += str(tmpans)\\n            \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 51210,
                "title": "2ms-c-solution-share-a-poor-coding-style",
                "content": "    class Solution {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tostringstream os;\\n                //dealing with denominator == 0\\n    \\t\\tif (denominator == 0){\\n    \\t\\t\\tos << INT_MAX;\\n    \\t\\t\\treturn os.str();\\n    \\t\\t}\\n                //dealing with numerator == 0\\n    \\t\\tif(numerator==0)\\n    \\t\\t    return \"0\";\\n                //others\\n    \\t\\tif ((numerator<0) ^ (denominator < 0))\\n    \\t\\t\\tos << '-';\\n    \\t\\tlong long x = abs((long long)numerator), y = abs((long long)denominator);\\n    \\t\\tos << x / y;\\n    \\t\\tif ((x %= y) == 0)\\n    \\t\\t\\treturn os.str();\\n    \\t\\tos << '.';\\n\\n    \\t    long long ax = x, ay = y;\\n    \\t\\tint i = 0, j = 0;\\n               //find the count of non_repeating part,it depends on how many 2 or 5 factor \\n               // are there in denominator\\n    \\t\\twhile (y % 2 == 0){\\n    \\t\\t\\ty /= 2;\\n    \\t\\t\\t++i;\\n    \\t\\t}\\n    \\t\\twhile (y % 5 == 0){\\n    \\t\\t\\ty /= 5;\\n    \\t\\t\\t++j;\\n    \\t\\t}\\n    \\t\\tint k = max(i, j);\\n                //non_repeating part\\n    \\t\\twhile (k != 0 && ax != 0){\\n    \\t\\t\\tax = ax * 10;\\n    \\t\\t\\tos << ax / ay;\\n    \\t\\t\\tax %= ay;\\n    \\t\\t\\t--k;\\n    \\t\\t}\\n    \\t\\tif (ax == 0)\\n    \\t\\t\\treturn os.str();\\n    \\t\\tlong long m = ax;\\n    \\t\\tos << '(';\\n                //repeating part\\n                //to find the repeating part ,we need to find when the denominator(here it is ax) repeats,\\n                //then we stop;\\n    \\t\\twhile (true){\\n    \\t\\t\\tax = ax * 10;\\n    \\t\\t\\tos << ax / ay;\\n    \\t\\t\\tif ((ax %= ay) == m)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tos << ')';\\n    \\t\\treturn os.str();\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tstring fractionToDecimal(int numerator, int denominator) {\\n    \\t\\tostringstream os;\\n                //dealing with denominator == 0\\n    \\t\\tif (denominator == 0){\\n    \\t\\t\\tos << INT_MAX;\\n    \\t\\t\\treturn os.str();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51214,
                "title": "4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string fractionToDecimal(int num, int den) {\\n            if (den == 0 || num == 0) {\\n                return \"0\";\\n            }\\n            string res = ((num < 0) ^ (den < 0)) == 1 ? \"-\" : \"\";\\n            // store as long since INT_MAX might come\\n            // also no overflow needed since string for INT_MIN/-1\\n            long a = abs((long)num);\\n            long b = abs((long)den);\\n            ostringstream os;\\n            os << a/b;\\n            res += os.str();\\n            if (a%b == 0) {\\n                return res;\\n            }\\n            \\n            res += \".\";\\n            unordered_map<int, int> pos_map;\\n            long x = a%b;\\n            string frac = \"\";\\n            while(x) {\\n                long d = (x*10)/b;\\n                ostringstream os;\\n                os << d;\\n                frac += os.str();\\n                pos_map[x] = frac.size()-1;\\n                x = (x*10)%b;\\n                if (pos_map.find(x) != pos_map.end()) {\\n                    int i = pos_map[x];\\n                    res += string(frac, 0, i) + \"(\" + string(frac, i, frac.size()-i) + \")\";\\n                    return res;\\n                }\\n            }\\n            \\n            return (res +  frac);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string fractionToDecimal(int num, int den) {\\n            if (den == 0 || num == 0) {\\n                return \"0\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3604036,
                "title": "most-efficient-js-solution-with-easy-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function takes two parameters: numerator and denominator, representing the fraction to be converted.\\n\\n2. The code first checks if the numerator is zero. If it is, it returns \"0\" as the decimal representation of the fraction.\\n\\n3. A variable named result is initialized as an empty string. This variable will store the decimal representation of the fraction.\\n\\n4. The code handles the sign of the resulting decimal by checking if the signs of the numerator and denominator are the same. If they are not, a \"-\" sign is added to the result.\\n\\n5. The numerator and denominator are converted to their absolute values using the Math.abs() function. This ensures that the calculations are performed correctly regardless of the sign.\\n\\n6. The integer part of the fraction is determined by dividing the absolute numerator by the absolute denominator and using Math.floor() to round down the division result. The integer part is added to the result.\\n\\n7. The code calculates the remainder of the division using the modulus operator (%). If the remainder is zero, it means there is no fractional part, so the result is returned.\\n\\n8. If there is a fractional part, a decimal point is added to the result.\\n\\n9. The code uses a Map called map to track the remainders and their positions. This is done to detect repeating patterns in the decimal representation of the fraction.\\n\\n10. The code enters a loop that continues until the remainder becomes zero. In each iteration, it checks if the remainder is already in the map. If it is, it means a repeating pattern is detected. The code retrieves the position of the previous occurrence of the remainder and adds parentheses around the repeating pattern in the result.\\n\\n11. If the remainder is not in the map, it is added to the map with its current position.\\n\\n12. The remainder is then multiplied by 10 and divided by the denominator. The floor value of this division is added to the result.\\n\\n13. The remainder is updated by taking the modulus of the division result with the denominator.\\n\\n14. Once the loop ends, the final result is returned.\\n\\n# Complexity\\n- Time complexity:\\nO(denominator)\\nwhere the denominator represents the size of the input denominator. This is because the loop iterates until the remainder becomes zero, and in the worst case, the remainder can take values from 1 to the denominator.\\n\\n- Space complexity:\\n O(denominator)\\nas the map can store up to denominator number of entries in the worst case scenario where there is a repeating pattern of length denominator.\\n\\n# Code\\n```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; // Special case for numerator equal to zero\\n  }\\n\\n  let result = \"\";\\n\\n  // Handle sign\\n  if (Math.sign(numerator) !== Math.sign(denominator)) {\\n    result += \"-\";\\n  }\\n\\n  // Convert to positive values\\n  const numer = Math.abs(numerator);\\n  const denom = Math.abs(denominator);\\n\\n  // Integer part\\n  result += Math.floor(numer / denom);\\n\\n  let remainder = numer % denom;\\n  if (remainder === 0) {\\n    return result; // No fractional part, return result\\n  }\\n\\n  result += \".\";\\n\\n  const map = new Map(); // To track remainders and their positions\\n\\n  while (remainder !== 0) {\\n    if (map.has(remainder)) {\\n      // Repeating pattern detected\\n      const index = map.get(remainder);\\n      result = result.slice(0, index) + \"(\" + result.slice(index) + \")\";\\n      break;\\n    }\\n\\n    map.set(remainder, result.length); // Store remainder and position\\n\\n    remainder *= 10;\\n    result += Math.floor(remainder / denom);\\n    remainder %= denom;\\n  }\\n\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(numerator, denominator) {\\n  if (numerator === 0) {\\n    return \"0\"; // Special case for numerator equal to zero\\n  }\\n\\n  let result = \"\";\\n\\n  // Handle sign\\n  if (Math.sign(numerator) !== Math.sign(denominator)) {\\n    result += \"-\";\\n  }\\n\\n  // Convert to positive values\\n  const numer = Math.abs(numerator);\\n  const denom = Math.abs(denominator);\\n\\n  // Integer part\\n  result += Math.floor(numer / denom);\\n\\n  let remainder = numer % denom;\\n  if (remainder === 0) {\\n    return result; // No fractional part, return result\\n  }\\n\\n  result += \".\";\\n\\n  const map = new Map(); // To track remainders and their positions\\n\\n  while (remainder !== 0) {\\n    if (map.has(remainder)) {\\n      // Repeating pattern detected\\n      const index = map.get(remainder);\\n      result = result.slice(0, index) + \"(\" + result.slice(index) + \")\";\\n      break;\\n    }\\n\\n    map.set(remainder, result.length); // Store remainder and position\\n\\n    remainder *= 10;\\n    result += Math.floor(remainder / denom);\\n    remainder %= denom;\\n  }\\n\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591102,
                "title": "python-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def fractionToDecimal(self, n: int, d: int) -> str:\\n        sol = \"\"\\n        if n == 0:\\n            return \"0\"\\n        negative = (n < 0) ^ (d < 0)\\n        n = abs(n)\\n        d = abs(d)\\n        sol+=str(n // d)\\n\\n        dec = \"\"\\n        if n % d:\\n            nums = {}\\n            sol += \".\"\\n            n = n % d\\n            while n:\\n                if n in nums:\\n                    dec += \")\"\\n                    pos = nums[n]\\n                    dec = dec[:pos] + \"(\" + dec[pos:]\\n                    break\\n\\n                nums[n] = len(dec)\\n                n *= 10\\n                dec += str(n // d)\\n                n = n % d\\n                \\n        sign = \"-\" if negative else \"\"\\n        return sign + sol + dec\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, n: int, d: int) -> str:\\n        sol = \"\"\\n        if n == 0:\\n            return \"0\"\\n        negative = (n < 0) ^ (d < 0)\\n        n = abs(n)\\n        d = abs(d)\\n        sol+=str(n // d)\\n\\n        dec = \"\"\\n        if n % d:\\n            nums = {}\\n            sol += \".\"\\n            n = n % d\\n            while n:\\n                if n in nums:\\n                    dec += \")\"\\n                    pos = nums[n]\\n                    dec = dec[:pos] + \"(\" + dec[pos:]\\n                    break\\n\\n                nums[n] = len(dec)\\n                n *= 10\\n                dec += str(n // d)\\n                n = n % d\\n                \\n        sign = \"-\" if negative else \"\"\\n        return sign + sol + dec\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549719,
                "title": "166-fraction-to-recurring-decimal",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) \\n    {\\n        unordered_map<long long,int>q;    \\n        long long ne = numerator,de = denominator;\\n        if(numerator <0 && denominator < 0)\\n        {\\n            ne = abs(numerator),de = abs(denominator);\\n        }\\n       \\n        string ans = to_string(ne/de);\\n        int pi = ans.size();\\n        ans += \\'.\\';\\n        if(ne%de == 0)\\n        {\\n            ans.pop_back();\\n            return ans;\\n        }\\n\\n        q[ne%de] = 1;\\n        long long temp = ne%de;\\n        int n = 0;\\n        while(q.size())\\n        {\\n            q[temp] = ++n;\\n            temp *= 10;\\n           ans += to_string(abs(temp/de));\\n           temp = temp % de;\\n\\n           if(temp == 0)\\n           {\\n               return ans;\\n           }\\n           else if(q.find(temp) != q.end())\\n           {\\n               ans.push_back(\\')\\');\\n               int ac = q[temp];\\n               ans =  ans.substr(0,pi+ac) + \\'(\\' + ans.substr(pi+ac);\\n               if(de < 0 || ne < 0)\\n               {\\n                   ans = \\'-\\'+ans;\\n               }\\n               return ans;\\n           }\\n        } \\n\\n        return \"\";                  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173413,
                "title": "java-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String fractionToDecimal(int num,int deno) {\\n        boolean isNegative = false;\\n        StringBuilder ans = new StringBuilder();\\n\\n        if(num<0 && deno>0 || num>0 && deno<0){\\n            ans.append(\\'-\\');\\n        } \\n        \\n        long quo = num/deno,rem =num%deno;\\n       \\n        ans.append(Math.abs(quo));\\n        if(rem==0){\\n            return ans.toString();\\n        }else{\\n            ans.append(\".\");\\n\\n            HashMap<Long,Integer> map = new HashMap<>();\\n            while(rem!=0){\\n                if(map.containsKey(rem)){\\n                    int pos = map.get(rem);\\n                    ans.insert(pos,\\'(\\');\\n                    ans.append(\\')\\');\\n                    break;\\n                }else{\\n                    map.put(rem,ans.length());\\n                    rem*=10;\\n                    quo=rem/deno;\\n                    rem=rem%deno;\\n                    ans.append(Math.abs(quo)); \\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int num,int deno) {\\n        boolean isNegative = false;\\n        StringBuilder ans = new StringBuilder();\\n\\n        if(num<0 && deno>0 || num>0 && deno<0){\\n            ans.append(\\'-\\');\\n        } \\n        \\n        long quo = num/deno,rem =num%deno;\\n       \\n        ans.append(Math.abs(quo));\\n        if(rem==0){\\n            return ans.toString();\\n        }else{\\n            ans.append(\".\");\\n\\n            HashMap<Long,Integer> map = new HashMap<>();\\n            while(rem!=0){\\n                if(map.containsKey(rem)){\\n                    int pos = map.get(rem);\\n                    ans.insert(pos,\\'(\\');\\n                    ans.append(\\')\\');\\n                    break;\\n                }else{\\n                    map.put(rem,ans.length());\\n                    rem*=10;\\n                    quo=rem/deno;\\n                    rem=rem%deno;\\n                    ans.append(Math.abs(quo)); \\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153685,
                "title": "c-straight-ward-solution-64ms-97",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        var sb = new StringBuilder();\\n\\n        if (numerator < 0 ^ denominator < 0 && numerator != 0) \\n            sb.Append(\\'-\\');\\n\\n        long n = Math.Abs((long)numerator);\\n        long d = Math.Abs((long)denominator);            \\n\\n        sb.Append(n / d);\\n\\n        n = n % d;\\n\\n        if (n != 0)\\n        {\\n            sb.Append(\\'.\\');\\n\\n            var f2Pos = new Dictionary<long, int>();\\n\\n            while (n != 0 && !f2Pos.ContainsKey(n))\\n            {\\n                f2Pos.Add(n,  sb.Length);\\n\\n                n = n * 10;\\n\\n                sb.Append(n / d);\\n\\n                n = n % d;\\n            }\\n\\n            if (f2Pos.ContainsKey(n))\\n            {\\n                sb.Insert(f2Pos[n], \\'(\\').Append(\\')\\');\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string FractionToDecimal(int numerator, int denominator)\\n    {\\n        var sb = new StringBuilder();\\n\\n        if (numerator < 0 ^ denominator < 0 && numerator != 0) \\n            sb.Append(\\'-\\');\\n\\n        long n = Math.Abs((long)numerator);\\n        long d = Math.Abs((long)denominator);            \\n\\n        sb.Append(n / d);\\n\\n        n = n % d;\\n\\n        if (n != 0)\\n        {\\n            sb.Append(\\'.\\');\\n\\n            var f2Pos = new Dictionary<long, int>();\\n\\n            while (n != 0 && !f2Pos.ContainsKey(n))\\n            {\\n                f2Pos.Add(n,  sb.Length);\\n\\n                n = n * 10;\\n\\n                sb.Append(n / d);\\n\\n                n = n % d;\\n            }\\n\\n            if (f2Pos.ContainsKey(n))\\n            {\\n                sb.Insert(f2Pos[n], \\'(\\').Append(\\')\\');\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033967,
                "title": "easy-c-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        // If numerator is zero then return 0;\\n        if (numerator == 0) \\n            return \"0\";\\n\\n        string res = \"\";\\n\\n        // Maybe numerator & denominator can be negative\\n        if ((numerator < 0) ^ (denominator < 0)) \\n            res += \\'-\\';\\n        \\n        /*\\n        // Also you can check for negative like\\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\\n            res += \\'-\\';\\n        */   \\n\\n        // Remove the negative sign from the numerator | denominator\\n        long dividend = abs((long) numerator);\\n        long divisor = abs((long) denominator);\\n\\n        // Find the remainder\\n        long rem = dividend % divisor;\\n\\n        // Add the numeric result\\n        res += to_string(dividend / divisor);\\n\\n        // in case no fractional part\\n        if (rem == 0)\\n            return res;\\n\\n        // If remainder is not 0 then they having fractional part so add the point for fraction\\n        res += \\'.\\';\\n\\n        unordered_map<long, int> map;\\n\\n        // Calculate division\\n        while(rem != 0) {\\n\\n            // Check for repeating part, If exist then insert in ();\\n            if (map.count(rem) > 0) {\\n                res.insert(map[rem], 1, \\'(\\');\\n                res += \\')\\';\\n                break;\\n            }\\n\\n            map[rem] = res.size();\\n\\n            rem *= 10;\\n\\n            // Add the quotient in result\\n            res += to_string(rem / divisor);\\n            rem %= divisor;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n# Upvote if it is useful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        // If numerator is zero then return 0;\\n        if (numerator == 0) \\n            return \"0\";\\n\\n        string res = \"\";\\n\\n        // Maybe numerator & denominator can be negative\\n        if ((numerator < 0) ^ (denominator < 0)) \\n            res += \\'-\\';\\n        \\n        /*\\n        // Also you can check for negative like\\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0))\\n            res += \\'-\\';\\n        */   \\n\\n        // Remove the negative sign from the numerator | denominator\\n        long dividend = abs((long) numerator);\\n        long divisor = abs((long) denominator);\\n\\n        // Find the remainder\\n        long rem = dividend % divisor;\\n\\n        // Add the numeric result\\n        res += to_string(dividend / divisor);\\n\\n        // in case no fractional part\\n        if (rem == 0)\\n            return res;\\n\\n        // If remainder is not 0 then they having fractional part so add the point for fraction\\n        res += \\'.\\';\\n\\n        unordered_map<long, int> map;\\n\\n        // Calculate division\\n        while(rem != 0) {\\n\\n            // Check for repeating part, If exist then insert in ();\\n            if (map.count(rem) > 0) {\\n                res.insert(map[rem], 1, \\'(\\');\\n                res += \\')\\';\\n                break;\\n            }\\n\\n            map[rem] = res.size();\\n\\n            rem *= 10;\\n\\n            // Add the quotient in result\\n            res += to_string(rem / divisor);\\n            rem %= divisor;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830411,
                "title": "0-ms-faster-than-100",
                "content": "\\n```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tvar res bytes.Buffer\\n\\tif ((numerator < 0) && (denominator > 0)) || ((numerator > 0) && (denominator < 0)) {\\n\\t\\tres.WriteString(\"-\")\\n\\t}\\n\\tnum := int(math.Abs(float64(numerator)))\\n\\tden := int(math.Abs(float64(denominator)))\\n\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\tnum %= den\\n\\tif num == 0 {\\n\\t\\treturn res.String()\\n\\t}\\n\\tres.WriteString(\".\")\\n\\tremainder := make(map[int]int)\\n\\tremainder[num] = res.Len()\\n\\tfor num != 0 {\\n\\t\\tnum *= 10\\n\\t\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\t\\tnum %= den\\n\\t\\tif index, ok := remainder[num]; ok {\\n\\t\\t\\tresult := res.String()\\n\\t\\t\\treturn result[:index] + \"(\" + result[index:] + \")\"\\n\\t\\t}\\n\\t\\tremainder[num] = res.Len()\\n\\t}\\n\\treturn res.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tvar res bytes.Buffer\\n\\tif ((numerator < 0) && (denominator > 0)) || ((numerator > 0) && (denominator < 0)) {\\n\\t\\tres.WriteString(\"-\")\\n\\t}\\n\\tnum := int(math.Abs(float64(numerator)))\\n\\tden := int(math.Abs(float64(denominator)))\\n\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\tnum %= den\\n\\tif num == 0 {\\n\\t\\treturn res.String()\\n\\t}\\n\\tres.WriteString(\".\")\\n\\tremainder := make(map[int]int)\\n\\tremainder[num] = res.Len()\\n\\tfor num != 0 {\\n\\t\\tnum *= 10\\n\\t\\tres.WriteString(fmt.Sprintf(\"%d\", num/den))\\n\\t\\tnum %= den\\n\\t\\tif index, ok := remainder[num]; ok {\\n\\t\\t\\tresult := res.String()\\n\\t\\t\\treturn result[:index] + \"(\" + result[index:] + \")\"\\n\\t\\t}\\n\\t\\tremainder[num] = res.Len()\\n\\t}\\n\\treturn res.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549434,
                "title": "best-explanation-clean-crisp-hashmap",
                "content": "Lets simulate the process of converting fraction to decimal. Lets look at the part where we have already figured out the integer part which is floor(numerator / denominator).\\nNow you are left with ( remainder = numerator%denominator ) / denominator.\\nIf you remember the process of converting to decimal, at each step you do the following :\\n\\n1) multiply the remainder by 10,\\n2) append remainder / denominator to your decimals\\n3) remainder = remainder % denominator.\\n\\nAt any moment, if your remainder becomes 0, you are done.\\n\\nHowever, there is a problem with recurring decimals. For example if you look at 1/3, the remainder never becomes 0.\\n\\nNotice one more important thing.\\nIf you start with remainder = R at any point with denominator d, you will always get the same sequence of digits.\\nSo, if your remainder repeats at any point of time, you know that the digits between the last occurrence of R will keep repeating.\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n        return \"0\";\\n        }\\n        if (denominator == 0) {\\n            return \"\";\\n        }\\n        string result = \"\";\\n        //std::cout << numerator << \" \" << denominator << endl;\\n        if ((numerator < 0) ^ (denominator < 0)) {\\n            //std::cout << \"True\" << endl;\\n            result += \"-\";\\n        }\\n        //numerator = abs(numerator);\\n        //denominator = abs(denominator);\\n        long num = numerator, den = denominator;\\n        num = abs(num);\\n        den = abs(den);\\n        long res = num/den;\\n        result += to_string(res);\\n    \\n        long rem = (num%den)*10;\\n        if (rem == 0) {\\n            return result;\\n        }\\n    \\n        std::map<long, int> mp;\\n        result += \".\";\\n        while (rem != 0) {\\n            if (mp.find(rem) != mp.end()) {\\n                int beg = mp[rem];\\n                string part1 = result.substr(0,beg);\\n                string part2 = result.substr(beg, result.length()-beg);\\n                result = part1 + \"(\"+part2+\")\";\\n                return result;\\n            }\\n            mp[rem] = result.length();\\n            res = rem/den;\\n            result += to_string(res);\\n            rem = (rem%den) *10;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) {\\n        return \"0\";\\n        }\\n        if (denominator == 0) {\\n            return \"\";\\n        }\\n        string result = \"\";\\n        //std::cout << numerator << \" \" << denominator << endl;\\n        if ((numerator < 0) ^ (denominator < 0)) {\\n            //std::cout << \"True\" << endl;\\n            result += \"-\";\\n        }\\n        //numerator = abs(numerator);\\n        //denominator = abs(denominator);\\n        long num = numerator, den = denominator;\\n        num = abs(num);\\n        den = abs(den);\\n        long res = num/den;\\n        result += to_string(res);\\n    \\n        long rem = (num%den)*10;\\n        if (rem == 0) {\\n            return result;\\n        }\\n    \\n        std::map<long, int> mp;\\n        result += \".\";\\n        while (rem != 0) {\\n            if (mp.find(rem) != mp.end()) {\\n                int beg = mp[rem];\\n                string part1 = result.substr(0,beg);\\n                string part2 = result.substr(beg, result.length()-beg);\\n                result = part1 + \"(\"+part2+\")\";\\n                return result;\\n            }\\n            mp[rem] = result.length();\\n            res = rem/den;\\n            result += to_string(res);\\n            rem = (rem%den) *10;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2511125,
                "title": "java-solution",
                "content": "Calculation of the Integral part is simple. Its basic division. \\nAfter that we need to multply the remainder by 10 and make it the new numerator and keep calculating the decimal part.\\nWe will save the states of the numerator and if the states get repeated again, this would mean that we have recurring part. Then we can just insert are brackets around the recurring part.\\n\\nIts basically the division algorithm with just a hashmap to check if there exists a recurrence in the fractional part of the number.\\n\\n```\\nclass Solution {\\n    HashMap<Long, Integer> visited = new HashMap<>(); \\n    // Stores states(numerators) and indices where the \\'(\\' would come if this is the state that starts the recurrence.\\n\\t\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long n = numerator;\\n        long d = denominator;\\n        boolean negative = false;\\n\\t\\t\\n\\t\\t// We calculate the answer as positive numbers and then add the signs at the end.\\n        if(n < 0){\\n            n*=-1;\\n            negative = true;\\n        }\\n        if(d < 0){\\n            d*=-1;\\n            negative = !negative;\\n        }\\n        \\n        String sign = \"\";\\n\\t\\t\\n        if(negative && n != 0){\\n            sign =\"-\";\\n        }\\n\\t\\t\\n\\t\\t//Preprocessing. We get the part before the decimal first. Then check if there exists a remainder.\\n\\t\\t// Only then do we preoceed ahead with the fractional part.\\n\\t\\t\\n        long q = n/d;\\n        long r = n%d;\\n        StringBuilder str = new StringBuilder(sign);\\n        str.append(q);\\n        if(r == 0){\\n            return str.toString();\\n        }\\n        str.append(\\'.\\');\\n        n = 10 * r;\\n        while(n > 0){\\n            if(visited.containsKey(n)){\\n                str.append(\\')\\');\\n                break;\\n            }\\n            visited.put(n, str.length());\\n            q = n/d;\\n            r = n %d;\\n            str.append(q);\\n            n = 10 * r;\\n        }\\n        if(visited.containsKey(n)){\\n            str.insert(visited.get(n), \"(\");\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Long, Integer> visited = new HashMap<>(); \\n    // Stores states(numerators) and indices where the \\'(\\' would come if this is the state that starts the recurrence.\\n\\t\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        long n = numerator;\\n        long d = denominator;\\n        boolean negative = false;\\n\\t\\t\\n\\t\\t// We calculate the answer as positive numbers and then add the signs at the end.\\n        if(n < 0){\\n            n*=-1;\\n            negative = true;\\n        }\\n        if(d < 0){\\n            d*=-1;\\n            negative = !negative;\\n        }\\n        \\n        String sign = \"\";\\n\\t\\t\\n        if(negative && n != 0){\\n            sign =\"-\";\\n        }\\n\\t\\t\\n\\t\\t//Preprocessing. We get the part before the decimal first. Then check if there exists a remainder.\\n\\t\\t// Only then do we preoceed ahead with the fractional part.\\n\\t\\t\\n        long q = n/d;\\n        long r = n%d;\\n        StringBuilder str = new StringBuilder(sign);\\n        str.append(q);\\n        if(r == 0){\\n            return str.toString();\\n        }\\n        str.append(\\'.\\');\\n        n = 10 * r;\\n        while(n > 0){\\n            if(visited.containsKey(n)){\\n                str.append(\\')\\');\\n                break;\\n            }\\n            visited.put(n, str.length());\\n            q = n/d;\\n            r = n %d;\\n            str.append(q);\\n            n = 10 * r;\\n        }\\n        if(visited.containsKey(n)){\\n            str.insert(visited.get(n), \"(\");\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357200,
                "title": "37ms-python-solution-with-comments-using-dictionary",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Get sign\\n        negative = numerator * denominator < 0\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # First division\\n        quotient, remainder = divmod(numerator, denominator)\\n        remainders = {}\\n        res = [str(quotient)]\\n        \\n        # If not divided exactly, repeat until remainder is zero or loop\\n        i = 0\\n        while remainder != 0 and remainder not in remainders:\\n            remainders[remainder] = i\\n            quotient, remainder = divmod(remainder * 10, denominator)\\n            res.append(str(quotient))\\n            i += 1\\n        \\n        # Add sign\\n        if negative:\\n            res[0] = \\'-\\' + res[0]\\n        \\n        # Return result\\n        if remainder == 0:\\n            if len(res) == 1:\\n                return res[0]\\n            else:\\n                return res[0] + \\'.\\' + \\'\\'.join(res[1:])\\n\\n        return res[0] + \\'.\\' + \\'\\'.join(res[1:remainders[remainder] + 1]) + \\'(\\' + \\'\\'.join(res[remainders[remainder] + 1:]) + \\')\\'\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        # Get sign\\n        negative = numerator * denominator < 0\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        \\n        # First division\\n        quotient, remainder = divmod(numerator, denominator)\\n        remainders = {}\\n        res = [str(quotient)]\\n        \\n        # If not divided exactly, repeat until remainder is zero or loop\\n        i = 0\\n        while remainder != 0 and remainder not in remainders:\\n            remainders[remainder] = i\\n            quotient, remainder = divmod(remainder * 10, denominator)\\n            res.append(str(quotient))\\n            i += 1\\n        \\n        # Add sign\\n        if negative:\\n            res[0] = \\'-\\' + res[0]\\n        \\n        # Return result\\n        if remainder == 0:\\n            if len(res) == 1:\\n                return res[0]\\n            else:\\n                return res[0] + \\'.\\' + \\'\\'.join(res[1:])\\n\\n        return res[0] + \\'.\\' + \\'\\'.join(res[1:remainders[remainder] + 1]) + \\'(\\' + \\'\\'.join(res[remainders[remainder] + 1:]) + \\')\\'\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2303120,
                "title": "easy-c-with-comments-code",
                "content": "\\tstring fractionToDecimal(int num, int den) {\\n\\t\\t\\tbool neg = (num<0)^(den<0) ? true: false;\\n\\t\\t\\tlong long int n = num;\\n\\t\\t\\tlong long int d = den;\\n\\t\\t\\tn = abs(n);\\n\\t\\t\\td = abs(d);\\n\\t\\t\\tlong long int tmp = n/d;\\n\\t\\t\\tstring res = \"\";\\n\\t\\t\\tif(neg && n!=0)\\n\\t\\t\\t res += \"-\";\\n\\n\\t\\t\\tres += to_string(tmp);\\n\\t\\t\\tn %= d;\\n\\t\\t\\tif(n==0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tres += \".\";\\n\\t\\t\\t// now before decimal, work is over now after decimal\\n\\t\\t\\tbool repeat = false;\\n\\t\\t\\tunordered_map<long long int, int> mp; // mapping from remainder to size of string\\n\\t\\t\\twhile(n!=0 && !repeat){\\n\\t\\t\\t\\tif(mp.find(n)==mp.end())\\n\\t\\t\\t\\t\\tmp[n] = res.size();\\n\\t\\t\\t\\telse if(mp.find(n)!=mp.end()){\\n\\t\\t\\t\\t\\t// repeat found\\n\\t\\t\\t\\t\\trepeat = true; // no need of repeat variable as we are breaking explicitly\\n\\t\\t\\t\\t\\tres.push_back(\\')\\');\\n\\t\\t\\t\\t\\tres.insert(mp[n],\"(\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn = n*10;\\n\\t\\t\\t\\tres += to_string(n/d);\\n\\t\\t\\t\\tn %= d;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tstring fractionToDecimal(int num, int den) {\\n\\t\\t\\tbool neg = (num<0)^(den<0) ? true: false;\\n\\t\\t\\tlong long int n = num;\\n\\t\\t\\tlong long int d = den;\\n\\t\\t\\tn = abs(n);\\n\\t\\t\\td = abs(d);\\n\\t\\t\\tlong long int tmp = n/d;\\n\\t\\t\\tstring res = \"\";\\n\\t\\t\\tif(neg && n!=0)\\n\\t\\t\\t res += \"-\";\\n\\n\\t\\t\\tres += to_string(tmp);\\n\\t\\t\\tn %= d;\\n\\t\\t\\tif(n==0){\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tres += \".\";\\n\\t\\t\\t// now before decimal, work is over now after decimal\\n\\t\\t\\tbool repeat = false;\\n\\t\\t\\tunordered_map<long long int, int> mp; // mapping from remainder to size of string\\n\\t\\t\\twhile(n!=0 && !repeat){\\n\\t\\t\\t\\tif(mp.find(n)==mp.end())\\n\\t\\t\\t\\t\\tmp[n] = res.size();\\n\\t\\t\\t\\telse if(mp.find(n)!=mp.end()){\\n\\t\\t\\t\\t\\t// repeat found\\n\\t\\t\\t\\t\\trepeat = true; // no need of repeat variable as we are breaking explicitly\\n\\t\\t\\t\\t\\tres.push_back(\\')\\');\\n\\t\\t\\t\\t\\tres.insert(mp[n],\"(\");\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn = n*10;\\n\\t\\t\\t\\tres += to_string(n/d);\\n\\t\\t\\t\\tn %= d;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2296524,
                "title": "easy-java-solution-with-explanations-run-time-2ms",
                "content": "\\n* Check for base conditions\\n*  If numerator ==0 return \"0\"\\n* if denominator==0 return \"\"\\n* check for the sign => if true then append a negative sign to the string builder\\n* append num/den to the string builder\\n* check for the remainder if remainder == 0 return the stringbuilder formed so far\\n* append \".\" to the final answer\\n* create a  Map<Long,Integer>map  to store remainder\\n* lopp till remainder!=0\\n* if map already contains remainder insert \"(\" and the position of map.get(rem)\\n* append \")\"  then break\\n* if not => map.put(rem ,currentlength of stringbuilder)\\n* multiply rem *10 append  rem/den to string Builder \\n* remainder = reminder%den\\n\\n```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0)return \"0\";\\n        if(denominator==0)return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0)\\n            sb.append(\"-\");\\n        long nume = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long rem = nume%den;\\n        sb.append(nume/den);\\n        if(rem==0)return sb.toString();\\n        sb.append(\".\");\\n        Map<Long,Integer>map = new HashMap<>();\\n        while(rem!=0){\\n            if(map.containsKey(rem)){\\n                sb.insert(map.get(rem),\"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n           map.put(rem,sb.length());\\n           rem*=10;\\n           sb.append(rem/den);\\n           rem %= den; \\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n***IF YOU LIKED THE APPROACH PLEASE UPVOTE !!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0)return \"0\";\\n        if(denominator==0)return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        if(numerator<0 && denominator>0 || numerator>0 && denominator<0)\\n            sb.append(\"-\");\\n        long nume = Math.abs((long)numerator);\\n        long den = Math.abs((long)denominator);\\n        long rem = nume%den;\\n        sb.append(nume/den);\\n        if(rem==0)return sb.toString();\\n        sb.append(\".\");\\n        Map<Long,Integer>map = new HashMap<>();\\n        while(rem!=0){\\n            if(map.containsKey(rem)){\\n                sb.insert(map.get(rem),\"(\");\\n                sb.append(\")\");\\n                break;\\n            }\\n           map.put(rem,sb.length());\\n           rem*=10;\\n           sb.append(rem/den);\\n           rem %= den; \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098202,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        pre = \"-\" if numerator * denominator < 0 else \"\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        q, r = divmod(numerator, denominator)\\n        q = str(q)\\n        if r == 0:\\n            return pre + q\\n        res = pre + q + \".\"\\n        dic = {}\\n        idx = len(res)\\n        r *= 10\\n        while r > 0:\\n            if r in dic:\\n                return res[:dic[r]] + f\"({res[dic[r]:]})\"\\n            dic[r] = idx\\n            q, r = divmod(r, denominator)\\n            res += (q := str(q))\\n            if r == 0:\\n                return res\\n            idx += len(q)\\n            r *= 10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        pre = \"-\" if numerator * denominator < 0 else \"\"\\n        numerator, denominator = abs(numerator), abs(denominator)\\n        q, r = divmod(numerator, denominator)\\n        q = str(q)\\n        if r == 0:\\n            return pre + q\\n        res = pre + q + \".\"\\n        dic = {}\\n        idx = len(res)\\n        r *= 10\\n        while r > 0:\\n            if r in dic:\\n                return res[:dic[r]] + f\"({res[dic[r]:]})\"\\n            dic[r] = idx\\n            q, r = divmod(r, denominator)\\n            res += (q := str(q))\\n            if r == 0:\\n                return res\\n            idx += len(q)\\n            r *= 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085538,
                "title": "c-easy-approach-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        string ans = \"\";\\n        \\n        int sign = 0;\\n        \\n        if(numerator < 0 and denominator < 0)\\n            sign = 0;\\n        else if(numerator < 0 and denominator > 0 || numerator > 0 and denominator < 0 )\\n            sign = 1;\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        long q = (n / d);\\n        long r = (n % d);\\n        ans += to_string(q);\\n        \\n        if(r == 0){\\n            if(sign == 1)\\n                ans.insert(ans.begin(),\\'-\\');\\n            return ans;\\n        }\\n        else{\\n            ans += \\'.\\';\\n            unordered_map<long, int> mp; \\n            while(r != 0){\\n                if(mp.find(r) != mp.end()){\\n                    int len = mp[r];\\n                    ans.insert(ans.begin()+len, \\'(\\');\\n                    ans.push_back(\\')\\');\\n                    break;\\n                }\\n                else{\\n                    mp.insert({r,ans.length()});\\n                }\\n                r = r * 10;\\n                q = (r/d);\\n                r = r % d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(sign == 1)\\n            ans.insert(ans.begin(),\\'-\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        string ans = \"\";\\n        \\n        int sign = 0;\\n        \\n        if(numerator < 0 and denominator < 0)\\n            sign = 0;\\n        else if(numerator < 0 and denominator > 0 || numerator > 0 and denominator < 0 )\\n            sign = 1;\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        long q = (n / d);\\n        long r = (n % d);\\n        ans += to_string(q);\\n        \\n        if(r == 0){\\n            if(sign == 1)\\n                ans.insert(ans.begin(),\\'-\\');\\n            return ans;\\n        }\\n        else{\\n            ans += \\'.\\';\\n            unordered_map<long, int> mp; \\n            while(r != 0){\\n                if(mp.find(r) != mp.end()){\\n                    int len = mp[r];\\n                    ans.insert(ans.begin()+len, \\'(\\');\\n                    ans.push_back(\\')\\');\\n                    break;\\n                }\\n                else{\\n                    mp.insert({r,ans.length()});\\n                }\\n                r = r * 10;\\n                q = (r/d);\\n                r = r % d;\\n                ans += to_string(q);\\n            }\\n        }\\n        if(sign == 1)\\n            ans.insert(ans.begin(),\\'-\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072354,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n  def fractionToDecimal(self, n, d):\\n    if n%d==0: return str(n // d)\\n    \\n    rdict, ds= {0:-1}, []\\n    \\n    sign, n, d = \\'-\\' if bool(n<0) ^ bool(d<0) else \\'\\', abs(n), abs(d)\\n    I, r = sign + str(n // d), n % d\\n    \\n    while r not in rdict:\\n      rdict[r] = len(ds)\\n      ds.append(str(r * 10 // d))\\n      r = r * 10 % d\\n    \\n    if r:\\n      i = rdict[r]\\n      return \\'{}.{}({})\\'.format(I, \\'\\'.join(ds[:i]),\\'\\'.join(ds[i:]))\\n    else:\\n      return \\'{}.{}\\'.format(I, \\'\\'.join(ds))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def fractionToDecimal(self, n, d):\\n    if n%d==0: return str(n // d)\\n    \\n    rdict, ds= {0:-1}, []\\n    \\n    sign, n, d = \\'-\\' if bool(n<0) ^ bool(d<0) else \\'\\', abs(n), abs(d)\\n    I, r = sign + str(n // d), n % d\\n    \\n    while r not in rdict:\\n      rdict[r] = len(ds)\\n      ds.append(str(r * 10 // d))\\n      r = r * 10 % d\\n    \\n    if r:\\n      i = rdict[r]\\n      return \\'{}.{}({})\\'.format(I, \\'\\'.join(ds[:i]),\\'\\'.join(ds[i:]))\\n    else:\\n      return \\'{}.{}\\'.format(I, \\'\\'.join(ds))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985646,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(n, d) {\\n    if (n === 0) {\\n        return \"0\";\\n    }\\n    const sign = n > 0 && d > 0 || n < 0 && d < 0 ? \"\" : \"-\";\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    let r = String(Math.trunc(n / d));\\n    let rem = n % d;\\n    if (rem === 0) {\\n        return sign + r;\\n    }\\n    \\n    r += \".\";\\n    const map = new Map();\\n    map.set(rem, r.length);\\n    while (rem > 0) {\\n        rem *= 10;\\n        r += String(Math.trunc(rem/d));\\n        rem = rem % d;\\n        const ex = map.get(rem);\\n        if (ex !== undefined) {\\n            return sign + r.substring(0, ex) + \"(\" + r.substring(ex) + \")\";\\n        }\\n        map.set(rem, r.length);\\n    }\\n    \\n    return sign + r;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numerator\\n * @param {number} denominator\\n * @return {string}\\n */\\nvar fractionToDecimal = function(n, d) {\\n    if (n === 0) {\\n        return \"0\";\\n    }\\n    const sign = n > 0 && d > 0 || n < 0 && d < 0 ? \"\" : \"-\";\\n    n = Math.abs(n);\\n    d = Math.abs(d);\\n    let r = String(Math.trunc(n / d));\\n    let rem = n % d;\\n    if (rem === 0) {\\n        return sign + r;\\n    }\\n    \\n    r += \".\";\\n    const map = new Map();\\n    map.set(rem, r.length);\\n    while (rem > 0) {\\n        rem *= 10;\\n        r += String(Math.trunc(rem/d));\\n        rem = rem % d;\\n        const ex = map.get(rem);\\n        if (ex !== undefined) {\\n            return sign + r.substring(0, ex) + \"(\" + r.substring(ex) + \")\";\\n        }\\n        map.set(rem, r.length);\\n    }\\n    \\n    return sign + r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898401,
                "title": "my-cpp-solution",
                "content": "Implementation\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(!numerator) return \"0\";\\n        \\n        string ans;\\n        \\n        if((numerator > 0) ^ (denominator > 0)){\\n            ans += \"-\";\\n        }\\n        \\n\\t\\t// basically converting into the long abs value\\n        long num = labs(numerator), den = labs(denominator);\\n        \\n        long quotient = num / den;\\n        long remainder = num % den;\\n        if(!remainder){\\n            ans += to_string(quotient);\\n            return ans;\\n        }\\n        ans += to_string(quotient) + \\'.\\';\\n        unordered_map<long, int> freq;\\n        \\n        while(remainder){\\n            if(freq.find(remainder) != freq.end()){\\n                ans.insert(freq[remainder], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                freq[remainder] = ans.size();\\n                remainder *= 10;\\n                quotient = remainder / den;\\n                remainder = remainder % den;\\n                ans += to_string(quotient);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        \\n        if(!numerator) return \"0\";\\n        \\n        string ans;\\n        \\n        if((numerator > 0) ^ (denominator > 0)){\\n            ans += \"-\";\\n        }\\n        \\n\\t\\t// basically converting into the long abs value\\n        long num = labs(numerator), den = labs(denominator);\\n        \\n        long quotient = num / den;\\n        long remainder = num % den;\\n        if(!remainder){\\n            ans += to_string(quotient);\\n            return ans;\\n        }\\n        ans += to_string(quotient) + \\'.\\';\\n        unordered_map<long, int> freq;\\n        \\n        while(remainder){\\n            if(freq.find(remainder) != freq.end()){\\n                ans.insert(freq[remainder], \"(\");\\n                ans += \\')\\';\\n                break;\\n            }\\n            else{\\n                freq[remainder] = ans.size();\\n                remainder *= 10;\\n                quotient = remainder / den;\\n                remainder = remainder % den;\\n                ans += to_string(quotient);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850961,
                "title": "plain-c-no-additional-memory-floyd-s-cycle-detection-algorithm",
                "content": "```\\n\\ntypedef long long i64;\\n\\nvoid next(i64* r, i64* n, i64 b) {\\n    *n = (*r*10) / b;\\n    *r = (*r*10) % b;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }\\n\\n    int start = 0;\\n    int len = 1;\\n\\n    r1 = a%b;\\n    \\n    // cycle start\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        next(&r2, &n2, b);\\n        start ++;\\n    }\\n\\n    // cycle len\\n    next(&r1, &n1, b);\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        len ++;\\n    }\\n\\n    if ((i64)numerator*(i64)denominator < 0) {\\n        sprintf(ret, \"-%lld\", a/b);\\n    } else {\\n        sprintf(ret, \"%lld\", a/b);\\n    }\\n    p += strlen(ret);\\n    \\n    r1 = a%b;\\n    next(&r1, &n1, b);\\n    for (i = 0; i < start; i++) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++ = n1 + \\'0\\';\\n        next(&r1, &n1, b);\\n    }\\n    if (len > 1 || n1 != 0) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++= \\'(\\';\\n        for (i = 0; i < len; i++) {\\n            *p++ = n1 + \\'0\\';\\n            next(&r1, &n1, b);\\n        }\\n        *p++= \\')\\';\\n    }\\n    *p++= 0;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\ntypedef long long i64;\\n\\nvoid next(i64* r, i64* n, i64 b) {\\n    *n = (*r*10) / b;\\n    *r = (*r*10) % b;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){\\n    char* ret = malloc(20000);\\n    char* p = ret;\\n    i64 a = numerator;\\n    i64 b = denominator;\\n    i64 r1, r2;\\n    i64 n1, n2;\\n    int i;\\n    int point = 0;\\n       \\n    a = labs(a);\\n    b = labs(b);\\n    \\n    r1 = r2 = a%b;\\n\\n    next(&r1, &n1, b);\\n\\n    next(&r2, &n2, b);\\n    next(&r2, &n2, b);\\n\\n    // has cycle\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n\\n        next(&r2, &n2, b);\\n        next(&r2, &n2, b);\\n    }\\n\\n    int start = 0;\\n    int len = 1;\\n\\n    r1 = a%b;\\n    \\n    // cycle start\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        next(&r2, &n2, b);\\n        start ++;\\n    }\\n\\n    // cycle len\\n    next(&r1, &n1, b);\\n    while (r1 != r2) {\\n        next(&r1, &n1, b);\\n        len ++;\\n    }\\n\\n    if ((i64)numerator*(i64)denominator < 0) {\\n        sprintf(ret, \"-%lld\", a/b);\\n    } else {\\n        sprintf(ret, \"%lld\", a/b);\\n    }\\n    p += strlen(ret);\\n    \\n    r1 = a%b;\\n    next(&r1, &n1, b);\\n    for (i = 0; i < start; i++) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++ = n1 + \\'0\\';\\n        next(&r1, &n1, b);\\n    }\\n    if (len > 1 || n1 != 0) {\\n        if (!point) {\\n            *p++ = \\'.\\'; point = 1;\\n        }\\n\\n        *p++= \\'(\\';\\n        for (i = 0; i < len; i++) {\\n            *p++ = n1 + \\'0\\';\\n            next(&r1, &n1, b);\\n        }\\n        *p++= \\')\\';\\n    }\\n    *p++= 0;\\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1782737,
                "title": "c-100-2ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator  == 0) return \"0\";\\n        string ans ;\\n        ans+=((numerator>0)^(denominator>0))?\"-\":\"\";\\n        long n=abs(numerator),d=abs(denominator);\\n        ans+=to_string(n/d);\\n        n=n%d;\\n        if(!n) return ans;\\n        ans+=\".\";\\n        unordered_map<long ,int> mp;\\n        mp[n]=ans.size();\\n        while(n)\\n        {\\n            n*=10;\\n            ans+=to_string(n/d);\\n            n=n%d;\\n            if(mp[n])\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n           }\\n            mp[n]=ans.size();\\n        }\\n        return ans ;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator  == 0) return \"0\";\\n        string ans ;\\n        ans+=((numerator>0)^(denominator>0))?\"-\":\"\";\\n        long n=abs(numerator),d=abs(denominator);\\n        ans+=to_string(n/d);\\n        n=n%d;\\n        if(!n) return ans;\\n        ans+=\".\";\\n        unordered_map<long ,int> mp;\\n        mp[n]=ans.size();\\n        while(n)\\n        {\\n            n*=10;\\n            ans+=to_string(n/d);\\n            n=n%d;\\n            if(mp[n])\\n            {\\n                ans.insert(mp[n],\"(\");\\n                ans+=\")\";\\n                break;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1732890,
                "title": "easy-to-understand-c",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n\\n    unordered_map<int,int>mp;\\n    string fractionToDecimal(long num, long d) {\\n        long e1=num; long e2=d;\\n         num=abs(num); d=abs(d);// Here I am converting to positive numbers bcz I will face with modulo operator later\\n        mp={};\\n        int n=1e4; string ans;\\n          if((e1<0&&e2>0)||(e1>0&&e2<0))  ans=\\'-\\'+ans;\\n            long p=num/d; num=num%d;              \\n         ans+=to_string(p);\\n        if(num==0) return ans;\\n       ans+=\\'.\\';\\n        int r=0;         \\n        int u=ans.size();\\n        while(n--&&num){\\n            int z=0;\\n            num=num*10;\\n            int t=num/d;          \\n\\n            if(mp[num]==0)mp[num]=u;\\n            else {r=mp[num];break;}\\n                 u++;\\n            ans+=(t+\\'0\\');    num=num%d;        \\n        }\\n        if(r){\\n            ans.insert(ans.begin()+r,\\'(\\');\\n            ans.push_back(\\')\\');\\n        }           \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    unordered_map<int,int>mp;\\n    string fractionToDecimal(long num, long d) {\\n        long e1=num; long e2=d;\\n         num=abs(num); d=abs(d);// Here I am converting to positive numbers bcz I will face with modulo operator later\\n        mp={}",
                "codeTag": "Java"
            },
            {
                "id": 1722894,
                "title": "c-unordered-map-easy",
                "content": "```\\nstring fractionToDecimal(int numerator, int denominator) \\n    {\\n        string res=\"\";\\n        if(numerator==0)\\n            return \"0\";\\n        if(numerator>0^denominator>0)\\n            res+=\\'-\\';\\n        long num=abs(numerator);\\n        long den=abs(denominator);\\n        unordered_map<long, int> mp;\\n        \\n        res+=to_string(num/den);\\n        if(num%den==0)\\n            return res;\\n        res+=\\'.\\';\\n        \\n        long rem=num%den;\\n        \\n        while(rem)\\n        {\\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res.insert(mp[rem], \"(\");\\n                res+=\\')\\';\\n                break;\\n            }\\n            \\n            mp[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/den);\\n            rem%=den;\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring fractionToDecimal(int numerator, int denominator) \\n    {\\n        string res=\"\";\\n        if(numerator==0)\\n            return \"0\";\\n        if(numerator>0^denominator>0)\\n            res+=\\'-\\';\\n        long num=abs(numerator);\\n        long den=abs(denominator);\\n        unordered_map<long, int> mp;\\n        \\n        res+=to_string(num/den);\\n        if(num%den==0)\\n            return res;\\n        res+=\\'.\\';\\n        \\n        long rem=num%den;\\n        \\n        while(rem)\\n        {\\n            if(mp.find(rem)!=mp.end())\\n            {\\n                res.insert(mp[rem], \"(\");\\n                res+=\\')\\';\\n                break;\\n            }\\n            \\n            mp[rem]=res.size();\\n            rem*=10;\\n            res+=to_string(rem/den);\\n            rem%=den;\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1694135,
                "title": "unordered-map-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        unordered_map<long, int> mp;\\n        \\n        if(numerator == 0) return \"0\";\\n        string ans = (numerator < 0) ^ (denominator < 0)? \"-\": \"\";\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        \\n        if(n){\\n            ans += \".\";\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n = n*10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0,mp[n]) + \"(\" + ans.substr(mp[n]) + \")\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        unordered_map<long, int> mp;\\n        \\n        if(numerator == 0) return \"0\";\\n        string ans = (numerator < 0) ^ (denominator < 0)? \"-\": \"\";\\n        \\n        long n = abs(numerator);\\n        long d = abs(denominator);\\n        \\n        ans += to_string(n/d);\\n        n %= d;\\n        \\n        if(n){\\n            ans += \".\";\\n            while(n and mp.find(n) == mp.end()){\\n                mp[n] = ans.size();\\n                n = n*10;\\n                ans += to_string(n/d);\\n                n %= d;\\n            }\\n            if(n){\\n                ans = ans.substr(0,mp[n]) + \"(\" + ans.substr(mp[n]) + \")\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690553,
                "title": "two-python-solutions-using-either-dictionary-get-or-list-index-in-try-except",
                "content": "Both of these solutions run in about the same amount of time, but with multiple submissions it appears the dictionary method is faster (fastest run was 28 ms), while the list method consistently uses less memory (14.2 MB vs 14.6 for the dict method). This makes sense since the dict has to store twice as much data (keys and values).\\nThe try/except block for the list will be a little slower, although I think that dict.get uses a try/except internally to return None when the key isn\\'t found.\\n\\nBoth solutions are using the same algorithm for long division.  A modulo operation is run to get the remainder, while int division (//) is used to get the next digit of the quotient.  Multiply the remainder by 10 for the next pass. We track all of the remainders we have seen in a dictionary or list. \\n  If the remainder ever equals 0, then the decimal is non repeating and we have finished division.\\n  If the remainder is one we have seen before, than the decimal is starting to repeat, and we can stop division after constructing the repeating portion, and also extracting any non-repeating leading portion.\\n  \\nSome key test cases to run in your testing:\\nnumerator = 0, denominator < 0  (I failed this edge case once, with output \\'-0\\')\\nnumerator = 1 denominator = 6 (or 12).  Repeating decimals, but the first few digits don\\'t repeat.\\nnumerator = 1, denominator = 9967.  Repeating decimal with 9966 digits in the repeating portion.\\n### Solution using List.index with Try/Except:\\n```python\\n  class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a list to track remainders we have seen\\n        seen_remainders = [remainder]\\n        decimal = \\'\\'   # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            \\n            # Check if we have seen this remainder before\\n            try:\\n                pattern_start = seen_remainders.index(remainder)\\n            except ValueError:\\n                # If not, add it to remainders we have seen\\n                seen_remainders.append(remainder)\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\\n\\n### Solution using a dictionary to track remainders seen\\n```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a dict to track remainders we have seen, where\\n        # key = remainder, value = index in the string decimal where remainder was seen.\\n        seen_remainders = {}\\n        idx = 0\\n        seen_remainders[remainder] = idx\\n        decimal = \\'\\' # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            idx += 1  # Increment the tracking index for the dictionary\\n            \\n            # Use dict.get to check our our remainder has already been seen\\n            pattern_start = seen_remainders.get(remainder)\\n            \\n            if pattern_start is None:\\n                # If not, add it to remainders we have seen\\n                seen_remainders[remainder] = idx\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n  class Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a list to track remainders we have seen\\n        seen_remainders = [remainder]\\n        decimal = \\'\\'   # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            \\n            # Check if we have seen this remainder before\\n            try:\\n                pattern_start = seen_remainders.index(remainder)\\n            except ValueError:\\n                # If not, add it to remainders we have seen\\n                seen_remainders.append(remainder)\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```\n```python\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        sign = True  # True == output is POSITIVE\\n        \\n        # Handle edge case of 0, and check for final negative sign.\\n        if numerator == 0:\\n            return \"0\"\\n        elif numerator < 0:\\n            numerator = -numerator\\n            sign = not sign\\n        if denominator < 0:\\n            denominator = -denominator\\n            sign = not sign\\n        \\n        # Get the whole number part of the quotient, and the initial remainder\\n        remainder = numerator % denominator\\n        quot = numerator // denominator\\n        \\n        # Initialize the output string\\n        ans = \\'\\' if sign else \\'-\\'\\n        ans += str(quot) + (\\'.\\' if remainder else \\'\\')\\n        \\n        # Use a dict to track remainders we have seen, where\\n        # key = remainder, value = index in the string decimal where remainder was seen.\\n        seen_remainders = {}\\n        idx = 0\\n        seen_remainders[remainder] = idx\\n        decimal = \\'\\' # Constructed string of the decimal portion\\n        \\n        while remainder > 0:\\n            remainder *= 10   # Carry down a 0\\n            quot = remainder // denominator   \\n            decimal += str(quot)\\n            remainder %= denominator  # Get the new remainder\\n            idx += 1  # Increment the tracking index for the dictionary\\n            \\n            # Use dict.get to check our our remainder has already been seen\\n            pattern_start = seen_remainders.get(remainder)\\n            \\n            if pattern_start is None:\\n                # If not, add it to remainders we have seen\\n                seen_remainders[remainder] = idx\\n            else:\\n                # If we have seen the remainder before, we can construct the answer string\\n                # decimal[:pattern_start] is the non-repeating part of the decimal\\n                # decimal[pattern_start:] is the repeating portion\\n                ans += decimal[:pattern_start] + \\'(\\' + decimal[pattern_start:]+ \\')\\'\\n                break\\n            \\n            # If the remainder is 0, division is complete, and there was no repeating decimal.\\n            if remainder == 0:\\n                ans += decimal\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630639,
                "title": "easy-fast-c-solution",
                "content": "\\t\\tstring ans;\\n        long n, d, r;\\n        unorderedmap<long, int> m;\\n        long q;\\n        \\n        if(numerator ==0) return \"0\"; // for n/m = 0/m\\n        if(numerator<0 ^ denominator<0) ans +=\\'-\\'; // for -n/m or n/-m\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        ans += tostring(n/d);\\n        r = n % d;\\n        if(r == 0) return ans; // absolute value with no remainder\\n        ans += \".\";\\n        r = 10;\\n        while(r){\\n            q = r / d;\\n            if(m.count(r)){\\n                ans.insert(m[r],1,\\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += tostring(q);\\n            r = (r%d) 10;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t\\tstring ans;\\n        long n, d, r;\\n        unorderedmap<long, int> m;\\n        long q;\\n        \\n        if(numerator ==0) return \"0\"; // for n/m = 0/m\\n        if(numerator<0 ^ denominator<0) ans +=\\'-\\'; // for -n/m or n/-m\\n        n = labs((long)numerator);\\n        d = labs((long)denominator);\\n        ans += tostring(n/d);\\n        r = n % d;\\n        if(r == 0) return ans; // absolute value with no remainder\\n        ans += \".\";\\n        r = 10;\\n        while(r){\\n            q = r / d;\\n            if(m.count(r)){\\n                ans.insert(m[r],1,\\'(\\');\\n                ans += \\')\\';\\n                return ans;\\n            }\\n            m[r] = ans.size();\\n            ans += tostring(q);\\n            r = (r%d) 10;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605510,
                "title": "go-solution-faster-than-100",
                "content": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n res := \"\"\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tif numerator < 0 && denominator < 0 {\\n\\t\\tnumerator = -numerator\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tif numerator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tnumerator = -numerator\\n\\t}\\n\\tif denominator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tres += strconv.Itoa(numerator / denominator)\\n\\tnumerator = numerator % denominator\\n\\tif numerator == 0 {\\n\\t\\treturn res\\n\\t}\\n\\tres += \".\"\\n\\tm := map[int]int{}\\n\\tfor numerator != 0 {\\n\\t\\tif i, ok := m[numerator]; ok {\\n\\t\\t\\tres = res[:i] + \"(\" + res[i:] + \")\"\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tm[numerator] = len(res)\\n\\t\\tnumerator *= 10\\n\\t\\tres += strconv.Itoa(numerator / denominator)\\n\\t\\tnumerator = numerator % denominator\\n\\t}\\n\\treturn res\\n}\\n",
                "solutionTags": [],
                "code": "```\\nfunc fractionToDecimal(numerator int, denominator int) string {\\n res := \"\"\\n\\tif numerator == 0 {\\n\\t\\treturn \"0\"\\n\\t}\\n\\tif numerator < 0 && denominator < 0 {\\n\\t\\tnumerator = -numerator\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tif numerator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tnumerator = -numerator\\n\\t}\\n\\tif denominator < 0 {\\n\\t\\tres += \"-\"\\n\\t\\tdenominator = -denominator\\n\\t}\\n\\tres += strconv.Itoa(numerator / denominator)\\n\\tnumerator = numerator % denominator\\n\\tif numerator == 0 {\\n\\t\\treturn res\\n\\t}\\n\\tres += \".\"\\n\\tm := map[int]int{}\\n\\tfor numerator != 0 {\\n\\t\\tif i, ok := m[numerator]; ok {\\n\\t\\t\\tres = res[:i] + \"(\" + res[i:] + \")\"\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\tm[numerator] = len(res)\\n\\t\\tnumerator *= 10\\n\\t\\tres += strconv.Itoa(numerator / denominator)\\n\\t\\tnumerator = numerator % denominator\\n\\t}\\n\\treturn res\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1584325,
                "title": "straightforward-java-solution-w-explanation",
                "content": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        String sign = (numerator < 0 && denominator < 0 || numerator >= 0 && denominator >= 0) ? \"\" : \"-\";\\n        long n = Math.abs(Long.valueOf(numerator));\\n        long d = Math.abs(Long.valueOf(denominator));\\n        sb.append(sign);\\n        // integral part\\n        sb.append(n / d);\\n        if (n % d == 0) return sb.toString();\\n        sb.append(\".\");\\n        // fractional part\\n        // keeps track of seen numerators and the length of sb\\n        Map<Long, Integer> m = new HashMap<>();\\n        while (n % d != 0) {\\n            n %= d;\\n            if (m.containsKey(n)) {\\n                // found a cycle\\n                sb.insert(m.get(n), \"(\");\\n                sb.append(\")\");\\n                return sb.toString();\\n            }\\n            m.put(n, sb.length());\\n            n *= 10;\\n            sb.append(n / d);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String fractionToDecimal(int numerator, int denominator) {\\n        if (numerator == 0) return \"0\";\\n        StringBuilder sb = new StringBuilder();\\n        String sign = (numerator < 0 && denominator < 0 || numerator >= 0 && denominator >= 0) ? \"\" : \"-\";\\n        long n = Math.abs(Long.valueOf(numerator));\\n        long d = Math.abs(Long.valueOf(denominator));\\n        sb.append(sign);\\n        // integral part\\n        sb.append(n / d);\\n        if (n % d == 0) return sb.toString();\\n        sb.append(\".\");\\n        // fractional part\\n        // keeps track of seen numerators and the length of sb\\n        Map<Long, Integer> m = new HashMap<>();\\n        while (n % d != 0) {\\n            n %= d;\\n            if (m.containsKey(n)) {\\n                // found a cycle\\n                sb.insert(m.get(n), \"(\");\\n                sb.append(\")\");\\n                return sb.toString();\\n            }\\n            m.put(n, sb.length());\\n            n *= 10;\\n            sb.append(n / d);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584088,
                "title": "java-solution-explanation",
                "content": "**Idea:**\\n1. In order to have a recurring decimal, 2 conditions MUST satisfy\\n\\t1. remainders MUST match\\n\\t2. the quotient digit where remainders are same MUST also match\\n2. We store the indexes of remainders in a `Map` \\n3. Wenever we find a repeating remainder, \\nwe check whether the quotients are also matching or not. \\nTo find the quotient digit, `ans[map[remainder]]`, where ans is our fraction part\\n4. Also, we need to deal with -ve numbers, so we do\\n\\t1. Widening Conversion (int -> long)\\n\\t2. explicitly check whether if exactly one input is -ve or not. \\n\\tIf yes, then `ans` will also be -ve\\n\\nBelow is the implementation of above approach\\n\\n\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String fractionToDecimal(int num, int den) {\\n\\n        String ans = \"\";\\n        \\n        // widening conversion to handle INT_MIN/INT_MAX\\n        long numerator = num; \\n        long denominator = den;\\n\\n        // ans will be -ve; if exactly one is -ve\\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {\\n            ans += \"-\";\\n        }\\n\\n        numerator = Math.abs(numerator);\\n        denominator = Math.abs(denominator);\\n        \\n        // does not have fraction part\\n        if (numerator % denominator == 0) {\\n            return ans + (numerator / denominator);\\n        }\\n\\n        long quotient = numerator / denominator;\\n        long remainder = numerator % denominator;\\n\\n        // real part\\n        ans += quotient + \".\";\\n\\n        ans += findFractionPart(remainder * 10, denominator);\\n\\n        return ans;\\n    }\\n\\n    String findFractionPart(long numerator, long denominator) {\\n\\n        StringBuilder ans = new StringBuilder();\\n        Map<Long, Integer> remIdx = new HashMap<>(); // holds indexes of remainders\\n        int idx = 0;\\n\\n        while (true) {\\n\\n            long quotient = numerator / denominator;\\n            long remainder = numerator % denominator;\\n\\n            if (remainder == 0) { // no recurring part present\\n                ans.append(quotient);\\n                break;\\n            }\\n\\n            \\n            /*\\n                in order to have a recurring decimal, 2 conditions must satisfy\\n                1. remainder is repeating\\n                2. the quotients of repeating remainder positions MUST also match  \\n            */\\n            \\n            if (remIdx.containsKey(remainder) && \\n                ans.charAt(remIdx.get(remainder)) == (quotient + \\'0\\')) { // same quotient\\n                \\n                // found recurring\\n                ans.insert(remIdx.get(remainder), \"(\");\\n                ans.append(\")\");\\n                break;\\n            } else {\\n\\t\\t\\t\\t// no recurring\\n                ans.append(quotient);\\n                remIdx.put(remainder, idx);\\n            }\\n\\n            // continue checking for next iteration\\n            idx++;\\n            numerator = remainder * 10;\\n\\n        }\\n\\n        return ans.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public String fractionToDecimal(int num, int den) {\\n\\n        String ans = \"\";\\n        \\n        // widening conversion to handle INT_MIN/INT_MAX\\n        long numerator = num; \\n        long denominator = den;\\n\\n        // ans will be -ve; if exactly one is -ve\\n        if ((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)) {\\n            ans += \"-\";\\n        }\\n\\n        numerator = Math.abs(numerator);\\n        denominator = Math.abs(denominator);\\n        \\n        // does not have fraction part\\n        if (numerator % denominator == 0) {\\n            return ans + (numerator / denominator);\\n        }\\n\\n        long quotient = numerator / denominator;\\n        long remainder = numerator % denominator;\\n\\n        // real part\\n        ans += quotient + \".\";\\n\\n        ans += findFractionPart(remainder * 10, denominator);\\n\\n        return ans;\\n    }\\n\\n    String findFractionPart(long numerator, long denominator) {\\n\\n        StringBuilder ans = new StringBuilder();\\n        Map<Long, Integer> remIdx = new HashMap<>(); // holds indexes of remainders\\n        int idx = 0;\\n\\n        while (true) {\\n\\n            long quotient = numerator / denominator;\\n            long remainder = numerator % denominator;\\n\\n            if (remainder == 0) { // no recurring part present\\n                ans.append(quotient);\\n                break;\\n            }\\n\\n            \\n            /*\\n                in order to have a recurring decimal, 2 conditions must satisfy\\n                1. remainder is repeating\\n                2. the quotients of repeating remainder positions MUST also match  \\n            */\\n            \\n            if (remIdx.containsKey(remainder) && \\n                ans.charAt(remIdx.get(remainder)) == (quotient + \\'0\\')) { // same quotient\\n                \\n                // found recurring\\n                ans.insert(remIdx.get(remainder), \"(\");\\n                ans.append(\")\");\\n                break;\\n            } else {\\n\\t\\t\\t\\t// no recurring\\n                ans.append(quotient);\\n                remIdx.put(remainder, idx);\\n            }\\n\\n            // continue checking for next iteration\\n            idx++;\\n            numerator = remainder * 10;\\n\\n        }\\n\\n        return ans.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562827,
                "title": "short-python-with-line-by-line-explanation-faster-than-100",
                "content": "The idea is to just follow what you would do by hand.\\n\\n* Keep dividing and take the remainder * 10 to be the new dividend.\\n* If remainder is 0, the decimal terminates, i.e., no repeating pattern.\\n* If remainder has already been encountered before, the decimal repeats from there.\\n\\n\\n```python\\n# One corner case.\\nif numerator == 0:\\n\\treturn \\'0\\'\\n\\n# Sign character is either \\'\\' (positive) or \\'-\\' (negative)\\nsign = \\'\\' if numerator * denominator > 0 else \\'-\\'\\n\\n# Sign is now taken care of, no need to worry about signs anymore.\\nn, d = abs(numerator), abs(denominator)\\n\\n# Prepare result string (to be returned).\\ninteger, remainder = divmod(n, d)  # n // d, n % d\\nresult = sign + str(integer) + (\\'.\\' if remainder else \\'\\')\\n\\n# Save remainder and its corresponding position to this dict:\\nr2p = {}  # remainder -> position in result string.\\n\\n# Stop when either remainder == 0 or remainder existed in r2p\\nwhile remainder and remainder not in r2p:\\n\\tr2p[remainder] = len(result)  # remainder position is just current length\\n\\tdigit, remainder = divmod(remainder * 10, d)\\n\\tresult += str(digit)  # add the digit to result string.\\n\\nif remainder == 0:  # i.e. no repeating decimals.\\n\\treturn result\\n\\np = r2p[remainder]  # the point at which decimal starts repeating.\\nreturn result[:p] + \\'(\\' + result[p:] + \\')\\'  # add parenthesis around it.\\n```",
                "solutionTags": [],
                "code": "```python\\n# One corner case.\\nif numerator == 0:\\n\\treturn \\'0\\'\\n\\n# Sign character is either \\'\\' (positive) or \\'-\\' (negative)\\nsign = \\'\\' if numerator * denominator > 0 else \\'-\\'\\n\\n# Sign is now taken care of, no need to worry about signs anymore.\\nn, d = abs(numerator), abs(denominator)\\n\\n# Prepare result string (to be returned).\\ninteger, remainder = divmod(n, d)  # n // d, n % d\\nresult = sign + str(integer) + (\\'.\\' if remainder else \\'\\')\\n\\n# Save remainder and its corresponding position to this dict:\\nr2p = {}  # remainder -> position in result string.\\n\\n# Stop when either remainder == 0 or remainder existed in r2p\\nwhile remainder and remainder not in r2p:\\n\\tr2p[remainder] = len(result)  # remainder position is just current length\\n\\tdigit, remainder = divmod(remainder * 10, d)\\n\\tresult += str(digit)  # add the digit to result string.\\n\\nif remainder == 0:  # i.e. no repeating decimals.\\n\\treturn result\\n\\np = r2p[remainder]  # the point at which decimal starts repeating.\\nreturn result[:p] + \\'(\\' + result[p:] + \\')\\'  # add parenthesis around it.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525698,
                "title": "using-hashmap-easy-to-understand-commented-solution-100-faster-c",
                "content": "```\\nclass Solution {\\n    \\n    void ComputeAfterDecimal(long num , long den , string &res){\\n        unordered_map<long , long>history;\\n        long q , r;\\n        \\n        while(num){\\n            q = num/den;\\n            r = num%den;\\n            \\n            //i have seen q for first time\\n            if(history.find(num) == history.end()){\\n                history[num] = res.size();\\n                res+=to_string(q);\\n                num =r*10;\\n            }\\n            //found a recurring event\\n            else{\\n                //insert brackets\\n                res = res.substr(0 , history[num]) + \"(\" + res.substr(history[num] ,res.size() -history[num] ) + \")\";\\n                break;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string res = \"\";\\n        //for negative numbers division\\n        if(( numerator >0 && denominator < 0) || (numerator <0 && denominator > 0) )\\n            res +=\"-\";\\n        \\n        //absolute divison\\n        long num = (long)abs(numerator);\\n        long den = (long)abs(denominator);\\n        \\n        //part before decimal point\\n        long q = num/den;\\n        long rem = num % den;\\n        \\n        res+=to_string(q);\\n        \\n        if(rem == 0)\\n            return res;\\n        \\n        //non-zero remainder which means i need a decimal point\\n        res+=\".\";\\n        \\n        ComputeAfterDecimal(rem*10 , den , res);\\n        \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void ComputeAfterDecimal(long num , long den , string &res){\\n        unordered_map<long , long>history;\\n        long q , r;\\n        \\n        while(num){\\n            q = num/den;\\n            r = num%den;\\n            \\n            //i have seen q for first time\\n            if(history.find(num) == history.end()){\\n                history[num] = res.size();\\n                res+=to_string(q);\\n                num =r*10;\\n            }\\n            //found a recurring event\\n            else{\\n                //insert brackets\\n                res = res.substr(0 , history[num]) + \"(\" + res.substr(history[num] ,res.size() -history[num] ) + \")\";\\n                break;\\n            }\\n        }\\n    }\\n    \\n    \\n    \\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator == 0) return \"0\";\\n        \\n        string res = \"\";\\n        //for negative numbers division\\n        if(( numerator >0 && denominator < 0) || (numerator <0 && denominator > 0) )\\n            res +=\"-\";\\n        \\n        //absolute divison\\n        long num = (long)abs(numerator);\\n        long den = (long)abs(denominator);\\n        \\n        //part before decimal point\\n        long q = num/den;\\n        long rem = num % den;\\n        \\n        res+=to_string(q);\\n        \\n        if(rem == 0)\\n            return res;\\n        \\n        //non-zero remainder which means i need a decimal point\\n        res+=\".\";\\n        \\n        ComputeAfterDecimal(rem*10 , den , res);\\n        \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523395,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator2, int denominator2) {\\n        if(!numerator2)\\n            return \"0\";\\n        string ans = (numerator2 < 0) ^ (denominator2 < 0)? \"-\": \"\", tmp = \"\";\\n        long long numerator = labs(numerator2);\\n        long long denominator = labs(denominator2);\\n        ans += to_string(numerator / denominator);\\n        numerator %= denominator;\\n        if(numerator){\\n            ans += \\'.\\';\\n            unordered_map<int, int> mp;\\n            while(numerator && mp.find(numerator) == mp.end()){\\n                mp[numerator] = tmp.size();\\n                numerator *= 10;\\n                tmp += to_string(numerator / denominator);\\n                numerator %= denominator;\\n            }\\n            //has loop, handle speically\\n            if(numerator)\\n                tmp = tmp.substr(0, mp[numerator]) + \"(\" + tmp.substr(mp[numerator]) + \")\";\\n        }\\n        return ans + tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator2, int denominator2) {\\n        if(!numerator2)\\n            return \"0\";\\n        string ans = (numerator2 < 0) ^ (denominator2 < 0)? \"-\": \"\", tmp = \"\";\\n        long long numerator = labs(numerator2);\\n        long long denominator = labs(denominator2);\\n        ans += to_string(numerator / denominator);\\n        numerator %= denominator;\\n        if(numerator){\\n            ans += \\'.\\';\\n            unordered_map<int, int> mp;\\n            while(numerator && mp.find(numerator) == mp.end()){\\n                mp[numerator] = tmp.size();\\n                numerator *= 10;\\n                tmp += to_string(numerator / denominator);\\n                numerator %= denominator;\\n            }\\n            //has loop, handle speically\\n            if(numerator)\\n                tmp = tmp.substr(0, mp[numerator]) + \"(\" + tmp.substr(mp[numerator]) + \")\";\\n        }\\n        return ans + tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498058,
                "title": "c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0) return \"0\";\\n        bool numNegative=0, denNegative=0;\\n        long long int num=long(numerator), den=long(denominator);\\n        string ans=\"\";\\n        if(numerator<0) {\\n            numNegative=1;\\n            num=-num;\\n        }\\n        if(denominator<0){\\n            denNegative=1;\\n            den=-den;\\n        }\\n        long long int q=num/den;\\n        long long int r=num%den;\\n        ans+=to_string(q);\\n        if(r==0) ans=ans;\\n        else{\\n            ans+=\".\";\\n            unordered_map<long long int, long long int> mp;\\n            while(r){\\n                if(mp.find(r)!=mp.end()){\\n                    long long int len=mp[r];\\n                    ans.insert(len, \"(\");\\n                    ans+=\")\";\\n                    break;\\n                }\\n                else{\\n                    mp[r]=ans.size();\\n                    r*=10;\\n                    q=r/den;\\n                    r=r%den;\\n                    ans+=to_string(q);\\n                }\\n            }\\n        }\\n        if(numNegative && denNegative) ans=ans;\\n        else if(numNegative || denNegative) ans.insert(0,\"-\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(numerator==0) return \"0\";\\n        bool numNegative=0, denNegative=0;\\n        long long int num=long(numerator), den=long(denominator);\\n        string ans=\"\";\\n        if(numerator<0) {\\n            numNegative=1;\\n            num=-num;\\n        }\\n        if(denominator<0){\\n            denNegative=1;\\n            den=-den;\\n        }\\n        long long int q=num/den;\\n        long long int r=num%den;\\n        ans+=to_string(q);\\n        if(r==0) ans=ans;\\n        else{\\n            ans+=\".\";\\n            unordered_map<long long int, long long int> mp;\\n            while(r){\\n                if(mp.find(r)!=mp.end()){\\n                    long long int len=mp[r];\\n                    ans.insert(len, \"(\");\\n                    ans+=\")\";\\n                    break;\\n                }\\n                else{\\n                    mp[r]=ans.size();\\n                    r*=10;\\n                    q=r/den;\\n                    r=r%den;\\n                    ans+=to_string(q);\\n                }\\n            }\\n        }\\n        if(numNegative && denNegative) ans=ans;\\n        else if(numNegative || denNegative) ans.insert(0,\"-\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479774,
                "title": "c-solution",
                "content": "```\\nlong abs1(long a){\\n    return a < 0 ? -a : a;\\n}\\n\\nlong repIndex(long* arr, long len, long num){\\n    for(int i = 0; i < len; i++){\\n        if(arr[i] == num)\\n            return i;\\n    }\\n    return -1;\\n}\\n\\nint length(int num){\\n    int len = num == 0 ? 1 : 0;\\n    while(num != 0){\\n        num /= 10;\\n        len ++;\\n    }\\n    return len;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }\\n    \\n//=========================================================================================\\n    bool repeat = 0;\\n    int fLen = 0, index = -1;                               //fLen: Fraction length, index: repeat at index (0.16666 -> index = 1)\\n    if(num % den){                                          //mod is not 0\\n        fLen ++;                                            //if mod is not 0, it has dot.\\n        int maxUnrepeated = length(den) + 1 /*2*/, realUnrepeated = 0;\\n        long *mods = malloc(maxUnrepeated * sizeof(long));  //Store unrepeated mods * 10. In the case of 1/6, it would be 1 * 10 and 4 * 10.\\n        long n = num % den * 10;                            //0.16666 -> n = 10\\n        do{\\n            if(realUnrepeated < maxUnrepeated){\\n                mods[realUnrepeated] = n;\\n                realUnrepeated ++;\\n            }\\n            fLen ++;\\n            n = n % den * 10;\\n            index = repIndex(mods, realUnrepeated, n);      //0.16666 -> index = 1\\n            if(index != -1){                                //if index != -1, n is found in mods[] \\n                repeat = 1;\\n                fLen += 2;                                  //()\\n                break;\\n            }\\n        }while(n);\\n    }\\n//=========================================================================================\\n    int len = sign + iLen + fLen;                           //0.1(6) -> 0 + 1 + 5\\n    char* r = malloc((len + 1) * sizeof(char)), *p = r;\\n\\n    //copy sign\\n    if(sign) *p++ = \\'-\\';\\n    \\n    //copy integer\\n    for(int i = iLen - 1; i >= 0; i--){\\n        p[i] = (integer % 10) + \\'0\\';\\n        integer /= 10;\\n    }\\n    \\n    if(fLen){\\n        p += iLen;                                         //move the pointer to the fractional part\\n        *p++ = \\'.\\';\\n    }\\n\\n    if(repeat){\\n        p[index] = \\'(\\';\\n        r[len - 1] = \\')\\';\\n        fLen -= 3;\\n    }\\n    \\n    //copy fraction\\n    long n = num, mod;\\n    for(int i = 0; i < fLen; i++){\\n        mod = n % den; //4\\n        n = mod * 10;\\n        if(p[i]==\\'(\\')p++;\\n        p[i] = n / den + \\'0\\';\\n    }\\n    \\n    r[len] = \\'\\\\0\\';\\n    return r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong abs1(long a){\\n    return a < 0 ? -a : a;\\n}\\n\\nlong repIndex(long* arr, long len, long num){\\n    for(int i = 0; i < len; i++){\\n        if(arr[i] == num)\\n            return i;\\n    }\\n    return -1;\\n}\\n\\nint length(int num){\\n    int len = num == 0 ? 1 : 0;\\n    while(num != 0){\\n        num /= 10;\\n        len ++;\\n    }\\n    return len;\\n}\\n\\nchar * fractionToDecimal(int numerator, int denominator){   //Assume: 1  6  Result: 0.1(6)\\n    long num = numerator, den = denominator;                //cast to long                    \\n    long integer = num / den;  //0\\n    \\n    int sign = 0;\\n    int iLen = length(integer);                             //1\\n    \\n    // Set positive for all\\n    if((long)num * den < 0){\\n        sign = 1;\\n        integer = -integer;\\n        num = abs1(num);\\n        den = abs1(den);\\n    }\\n    \\n//=========================================================================================\\n    bool repeat = 0;\\n    int fLen = 0, index = -1;                               //fLen: Fraction length, index: repeat at index (0.16666 -> index = 1)\\n    if(num % den){                                          //mod is not 0\\n        fLen ++;                                            //if mod is not 0, it has dot.\\n        int maxUnrepeated = length(den) + 1 /*2*/, realUnrepeated = 0;\\n        long *mods = malloc(maxUnrepeated * sizeof(long));  //Store unrepeated mods * 10. In the case of 1/6, it would be 1 * 10 and 4 * 10.\\n        long n = num % den * 10;                            //0.16666 -> n = 10\\n        do{\\n            if(realUnrepeated < maxUnrepeated){\\n                mods[realUnrepeated] = n;\\n                realUnrepeated ++;\\n            }\\n            fLen ++;\\n            n = n % den * 10;\\n            index = repIndex(mods, realUnrepeated, n);      //0.16666 -> index = 1\\n            if(index != -1){                                //if index != -1, n is found in mods[] \\n                repeat = 1;\\n                fLen += 2;                                  //()\\n                break;\\n            }\\n        }while(n);\\n    }\\n//=========================================================================================\\n    int len = sign + iLen + fLen;                           //0.1(6) -> 0 + 1 + 5\\n    char* r = malloc((len + 1) * sizeof(char)), *p = r;\\n\\n    //copy sign\\n    if(sign) *p++ = \\'-\\';\\n    \\n    //copy integer\\n    for(int i = iLen - 1; i >= 0; i--){\\n        p[i] = (integer % 10) + \\'0\\';\\n        integer /= 10;\\n    }\\n    \\n    if(fLen){\\n        p += iLen;                                         //move the pointer to the fractional part\\n        *p++ = \\'.\\';\\n    }\\n\\n    if(repeat){\\n        p[index] = \\'(\\';\\n        r[len - 1] = \\')\\';\\n        fLen -= 3;\\n    }\\n    \\n    //copy fraction\\n    long n = num, mod;\\n    for(int i = 0; i < fLen; i++){\\n        mod = n % den; //4\\n        n = mod * 10;\\n        if(p[i]==\\'(\\')p++;\\n        p[i] = n / den + \\'0\\';\\n    }\\n    \\n    r[len] = \\'\\\\0\\';\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463059,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    string fractionToDecimal(int num, int den) {\\n        string res=\"\";\\n        bool isNeg=false;\\n        if((num>0&&den<0)||(num<0&&den>0)){\\n            isNeg=true;\\n        }\\n        ll n=(ll)abs(num);\\n        ll d=(ll)abs(den);\\n        if(n%d==0){\\n            res=to_string(n/d);\\n        }\\n        else{\\n            ll rem=n%d;\\n            res=to_string(n/d);\\n            res+=\".\";\\n            string temp=\"\";\\n            unordered_map<ll,string> mp;\\n            mp[rem]=\"\";\\n            while(rem!=0){\\n                rem=rem*10;\\n                if(rem<d){\\n                    temp+=\"0\";\\n                }\\n                else{\\n                    temp+=to_string(rem/d);\\n                    rem=rem%d;\\n                    if(mp.find(rem)!=mp.end()){\\n                        temp=mp[rem]+\"(\"+ temp.substr(mp[rem].size()) +\")\";\\n                        break;\\n                    }\\n                    else{\\n                        mp[rem]=temp;\\n                    }\\n                }\\n            }\\n            \\n            res=res+temp;\\n            \\n        }\\n        \\n        \\n        if(isNeg) return \"-\"+res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    string fractionToDecimal(int num, int den) {\\n        string res=\"\";\\n        bool isNeg=false;\\n        if((num>0&&den<0)||(num<0&&den>0)){\\n            isNeg=true;\\n        }\\n        ll n=(ll)abs(num);\\n        ll d=(ll)abs(den);\\n        if(n%d==0){\\n            res=to_string(n/d);\\n        }\\n        else{\\n            ll rem=n%d;\\n            res=to_string(n/d);\\n            res+=\".\";\\n            string temp=\"\";\\n            unordered_map<ll,string> mp;\\n            mp[rem]=\"\";\\n            while(rem!=0){\\n                rem=rem*10;\\n                if(rem<d){\\n                    temp+=\"0\";\\n                }\\n                else{\\n                    temp+=to_string(rem/d);\\n                    rem=rem%d;\\n                    if(mp.find(rem)!=mp.end()){\\n                        temp=mp[rem]+\"(\"+ temp.substr(mp[rem].size()) +\")\";\\n                        break;\\n                    }\\n                    else{\\n                        mp[rem]=temp;\\n                    }\\n                }\\n            }\\n            \\n            res=res+temp;\\n            \\n        }\\n        \\n        \\n        if(isNeg) return \"-\"+res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413300,
                "title": "c-easy-to-understand-0ms-faster-than-100",
                "content": "```\\nstring fractionToDecimal(int numerator, int denominator) {\\n    long long int num = numerator;\\n    long long int den = denominator;\\n    if(num == 0)\\n        return \"0\";\\n    string res;\\n    int sign = 1;\\n    sign *= num > 0?1:-1;\\n    sign *= den >= 0 ? 1: -1;\\n    num = abs(num);\\n    den = abs(den);\\n    long long int quotient = num / den;\\n    num = num % den;\\n    if(num == 0)\\n        res += to_string(quotient);\\n    else\\n        res += to_string(quotient) + \".\";\\n    int every;\\n    vector<int> m_v;\\n    int x = res.size();\\n    int st = 0;\\n    while(num!=0){\\n        m_v.push_back(num);\\n        num *= 10;\\n        every = num / den;\\n        res += to_string(every);\\n        num %= den;\\n        auto it = std::find(m_v.begin(), m_v.end(), num);\\n        if(it != m_v.end()){\\n            st = it - m_v.begin() + x;\\n            res = res.substr(0, st) + \"(\" + res.substr(st) + \")\";\\n            break;\\n        }\\n    }\\n    if(sign == -1)\\n        res = \"-\" + res;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring fractionToDecimal(int numerator, int denominator) {\\n    long long int num = numerator;\\n    long long int den = denominator;\\n    if(num == 0)\\n        return \"0\";\\n    string res;\\n    int sign = 1;\\n    sign *= num > 0?1:-1;\\n    sign *= den >= 0 ? 1: -1;\\n    num = abs(num);\\n    den = abs(den);\\n    long long int quotient = num / den;\\n    num = num % den;\\n    if(num == 0)\\n        res += to_string(quotient);\\n    else\\n        res += to_string(quotient) + \".\";\\n    int every;\\n    vector<int> m_v;\\n    int x = res.size();\\n    int st = 0;\\n    while(num!=0){\\n        m_v.push_back(num);\\n        num *= 10;\\n        every = num / den;\\n        res += to_string(every);\\n        num %= den;\\n        auto it = std::find(m_v.begin(), m_v.end(), num);\\n        if(it != m_v.end()){\\n            st = it - m_v.begin() + x;\\n            res = res.substr(0, st) + \"(\" + res.substr(st) + \")\";\\n            break;\\n        }\\n    }\\n    if(sign == -1)\\n        res = \"-\" + res;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400356,
                "title": "intuitive-python-solution",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator < 0 and denominator > 0:\\n            return \\'-\\'+self.fractionToDecimal(-numerator, denominator)\\n        elif numerator < 0 and denominator < 0:\\n            return self.fractionToDecimal(-numerator, -denominator)\\n        elif numerator > 0 and denominator < 0:\\n            return \\'-\\'+self.fractionToDecimal(numerator, -denominator)\\n        first, residual = numerator // denominator, numerator % denominator\\n        if not residual:\\n            return str(first)\\n        cur = list(str(first))+[\\'.\\']\\n        digit_map = {}\\n        ind = len(cur)\\n        while residual:\\n            new_numerator = residual * 10\\n            if new_numerator  in digit_map:\\n                cur.insert(digit_map[new_numerator ],\\'(\\')\\n                cur.append(\\')\\')\\n                break\\n            \\n            new_digit, residual = new_numerator//denominator, new_numerator%denominator\\n            cur.append(str(new_digit))\\n            digit_map[new_numerator] = ind \\n            ind += 1\\n            \\n        return \\'\\'.join(cur)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n        if numerator < 0 and denominator > 0:\\n            return \\'-\\'+self.fractionToDecimal(-numerator, denominator)\\n        elif numerator < 0 and denominator < 0:\\n            return self.fractionToDecimal(-numerator, -denominator)\\n        elif numerator > 0 and denominator < 0:\\n            return \\'-\\'+self.fractionToDecimal(numerator, -denominator)\\n        first, residual = numerator // denominator, numerator % denominator\\n        if not residual:\\n            return str(first)\\n        cur = list(str(first))+[\\'.\\']\\n        digit_map = {}\\n        ind = len(cur)\\n        while residual:\\n            new_numerator = residual * 10\\n            if new_numerator  in digit_map:\\n                cur.insert(digit_map[new_numerator ],\\'(\\')\\n                cur.append(\\')\\')\\n                break\\n            \\n            new_digit, residual = new_numerator//denominator, new_numerator%denominator\\n            cur.append(str(new_digit))\\n            digit_map[new_numerator] = ind \\n            ind += 1\\n            \\n        return \\'\\'.join(cur)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397685,
                "title": "c-solution-with-explanation-faster-than-100",
                "content": "The basic idea is when you divide the numerator by the denominator, if there are recurring digits, then it is the result of **recurring remainders** when you repeat the process of adding 0 to the end of remainders and keep dividing. \\n\\nIn order to save those remainder for checking later, a `map<int, int>` is used here: the keys are previous remainders and the values are the position. You need to keep the position for duplicate checkings; the first duplicated position is also **the start of recurring part** (for example: 1/6 = 0.1(6) in which the recurring part start at 6, not 1)\\n\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        bool sign = (numerator <= 0 && denominator < 0) || (numerator >= 0 && denominator > 0);\\n        long long num = numerator; \\n        long long den = denominator;\\n        num = abs(num); \\n        den = abs(den); \\n        string real = to_string(num/den);\\n        if (!sign) \\n            real = \\'-\\' + real;\\n        string decimal = \".\";\\n        map<int, int> mp;\\n        mp.clear();\\n        long long rem = num % den;\\n        if (rem == 0) \\n            return real;\\n        while (rem != 0 && (mp.find(rem) == mp.end())) {\\n            mp[rem] = decimal.length();\\n            rem = rem * 10;\\n            decimal += (char)(\\'0\\' + rem/den);\\n            rem = rem % den;\\n        }\\n        if (rem == 0)\\n            return real + decimal;\\n        return real + decimal.substr(0, mp[rem]) + \\'(\\' + decimal.substr(mp[rem]) + \\')\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        bool sign = (numerator <= 0 && denominator < 0) || (numerator >= 0 && denominator > 0);\\n        long long num = numerator; \\n        long long den = denominator;\\n        num = abs(num); \\n        den = abs(den); \\n        string real = to_string(num/den);\\n        if (!sign) \\n            real = \\'-\\' + real;\\n        string decimal = \".\";\\n        map<int, int> mp;\\n        mp.clear();\\n        long long rem = num % den;\\n        if (rem == 0) \\n            return real;\\n        while (rem != 0 && (mp.find(rem) == mp.end())) {\\n            mp[rem] = decimal.length();\\n            rem = rem * 10;\\n            decimal += (char)(\\'0\\' + rem/den);\\n            rem = rem % den;\\n        }\\n        if (rem == 0)\\n            return real + decimal;\\n        return real + decimal.substr(0, mp[rem]) + \\'(\\' + decimal.substr(mp[rem]) + \\')\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383933,
                "title": "clean-and-understandable-typescript-solution",
                "content": "```\\nfunction fractionToDecimal(numerator: number, denominator: number): string {\\n  if (numerator === 0) {\\n    return \"0\";\\n  }\\n\\n  /*\\n    If either the numerator or denominator is negative but not both, \\n    the fraction will be negative as well.\\n  */\\n  const sign = numerator > 0 === denominator > 0 ? \"\" : \"-\";\\n\\n  numerator = Math.abs(numerator);\\n  denominator = Math.abs(denominator);\\n\\n  const wholeNumber = Math.floor(numerator / denominator);\\n\\n  return sign + wholeNumber + fraction(numerator % denominator, denominator);\\n}\\n\\nconst fraction = (remainder: number, denominator: number): string => {\\n  /*\\n    remainder will be 0 when there is no fractional part\\n  */\\n  if (remainder === 0) {\\n    return \"\";\\n  }\\n\\n  let fraction = \".\";\\n  const map = new Map<number, number>();\\n\\n  while (remainder !== 0) {\\n    /*\\n      We use remainder as the key for the index as it is unique for\\n      non-repeating fractions. It also handles the case where we have\\n      a final string of \"0.02301\" where the 0 repeats twice. However,\\n      the 0s have different remainders at calculation and as such\\n      don\\'t trigger the repeating sequence logic we have below.\\n\\n      For repeating fractions like \"0.012012\", the remainders for the \\n      0s are the same at calculation. From a logical standpoint, it has\\n      to be the same in order for the 2nd \"012\" sequence to be calculated\\n      the same.\\n    */\\n    map.set(remainder, fraction.length);\\n\\n    /*\\n      Step the remainder once to the right so we can keep filling out\\n      the fraction.\\n      \"0.0_\" -> \"0.01_\"\\n\\n      Fill the blank spot with the integer result of how many times\\n      denominator goes into remainder.\\n\\n      Remainder is then reset to the remainder of that division operation.\\n    */\\n    remainder *= 10;\\n    fraction += Math.floor(remainder / denominator);\\n    remainder %= denominator;\\n\\n    const remainderIndex = map.get(remainder);\\n    if (remainderIndex !== undefined) {\\n      return (\\n        fraction.slice(0, remainderIndex) +\\n        \"(\" +\\n        fraction.slice(remainderIndex) +\\n        \")\"\\n      );\\n    }\\n  }\\n\\n  return fraction;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction fractionToDecimal(numerator: number, denominator: number): string {\\n  if (numerator === 0) {\\n    return \"0\";\\n  }\\n\\n  /*\\n    If either the numerator or denominator is negative but not both, \\n    the fraction will be negative as well.\\n  */\\n  const sign = numerator > 0 === denominator > 0 ? \"\" : \"-\";\\n\\n  numerator = Math.abs(numerator);\\n  denominator = Math.abs(denominator);\\n\\n  const wholeNumber = Math.floor(numerator / denominator);\\n\\n  return sign + wholeNumber + fraction(numerator % denominator, denominator);\\n}\\n\\nconst fraction = (remainder: number, denominator: number): string => {\\n  /*\\n    remainder will be 0 when there is no fractional part\\n  */\\n  if (remainder === 0) {\\n    return \"\";\\n  }\\n\\n  let fraction = \".\";\\n  const map = new Map<number, number>();\\n\\n  while (remainder !== 0) {\\n    /*\\n      We use remainder as the key for the index as it is unique for\\n      non-repeating fractions. It also handles the case where we have\\n      a final string of \"0.02301\" where the 0 repeats twice. However,\\n      the 0s have different remainders at calculation and as such\\n      don\\'t trigger the repeating sequence logic we have below.\\n\\n      For repeating fractions like \"0.012012\", the remainders for the \\n      0s are the same at calculation. From a logical standpoint, it has\\n      to be the same in order for the 2nd \"012\" sequence to be calculated\\n      the same.\\n    */\\n    map.set(remainder, fraction.length);\\n\\n    /*\\n      Step the remainder once to the right so we can keep filling out\\n      the fraction.\\n      \"0.0_\" -> \"0.01_\"\\n\\n      Fill the blank spot with the integer result of how many times\\n      denominator goes into remainder.\\n\\n      Remainder is then reset to the remainder of that division operation.\\n    */\\n    remainder *= 10;\\n    fraction += Math.floor(remainder / denominator);\\n    remainder %= denominator;\\n\\n    const remainderIndex = map.get(remainder);\\n    if (remainderIndex !== undefined) {\\n      return (\\n        fraction.slice(0, remainderIndex) +\\n        \"(\" +\\n        fraction.slice(remainderIndex) +\\n        \")\"\\n      );\\n    }\\n  }\\n\\n  return fraction;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352484,
                "title": "c-faster-solution-with-comments",
                "content": "```cpp\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n     \\n        // Output string to store the answer\\n        string result = \"\";\\n \\n        // Ensure numerator is non-zero,\\n        // if numerator is zero , then return \"0\"\\n        if (numerator == 0){\\n            return \"0\";\\n        }\\n        \\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){\\n            result.append(\"-\");\\n        }\\n            \\n        // getting the absolute value of the numerator and denominator\\n        long long int n = abs(numerator);\\n        long long int d = abs(denominator);\\n        \\n        // Calculate the absolute part\\n        // (before decimal point), which is quotitent\\n        long long int quotitent = n / d;\\n            \\n        // Append the quotitent\\n        result += to_string(abs(quotitent));\\n        \\n        // If completely divisible, return answer.\\n        if (n % d == 0){\\n            return result;\\n        }\\n        \\n        // append the decimal \".\" dot\\n        result += \".\";\\n        \\n        // Initialize Remainder\\n        long remainder = n % d;\\n        \\n        // create the map to store the remainder\\n        map<int, int> remMap;\\n     \\n        // Position at which fraction starts repeating, if it exists\\n        int index;\\n        \\n        \\n        // run the loop till remainder becomes \"0\" and repeathing becomes \"true\"\\n        while (remainder > 0) {\\n            \\n            // If the remainder is already seen,\\n            // then there exists a repeating fraction.\\n            // break the loop and print the result, after appending the remainder\\n            if (remMap.find(remainder) != remMap.end()) {\\n     \\n                result.insert( remMap[remainder], \"(\");\\n                \\n                result.append(\")\");\\n                \\n                break;\\n            }\\n            // if no remainder found\\n            // add the remainder to the map \\n            // with key as remainder and value as size of the result\\n            else{\\n                remMap[remainder] = result.size();\\n            }\\n            \\n            remainder = remainder * 10;\\n \\n            // Calculate quotient, append it to result and\\n            // calculate next remainder\\n            long long int temp = remainder / d;\\n            \\n            remainder = remainder % denominatr;\\n            \\n            result += to_string(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n     \\n        // Output string to store the answer\\n        string result = \"\";\\n \\n        // Ensure numerator is non-zero,\\n        // if numerator is zero , then return \"0\"\\n        if (numerator == 0){\\n            return \"0\";\\n        }\\n        \\n        if((numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0)){\\n            result.append(\"-\");\\n        }\\n            \\n        // getting the absolute value of the numerator and denominator\\n        long long int n = abs(numerator);\\n        long long int d = abs(denominator);\\n        \\n        // Calculate the absolute part\\n        // (before decimal point), which is quotitent\\n        long long int quotitent = n / d;\\n            \\n        // Append the quotitent\\n        result += to_string(abs(quotitent));\\n        \\n        // If completely divisible, return answer.\\n        if (n % d == 0){\\n            return result;\\n        }\\n        \\n        // append the decimal \".\" dot\\n        result += \".\";\\n        \\n        // Initialize Remainder\\n        long remainder = n % d;\\n        \\n        // create the map to store the remainder\\n        map<int, int> remMap;\\n     \\n        // Position at which fraction starts repeating, if it exists\\n        int index;\\n        \\n        \\n        // run the loop till remainder becomes \"0\" and repeathing becomes \"true\"\\n        while (remainder > 0) {\\n            \\n            // If the remainder is already seen,\\n            // then there exists a repeating fraction.\\n            // break the loop and print the result, after appending the remainder\\n            if (remMap.find(remainder) != remMap.end()) {\\n     \\n                result.insert( remMap[remainder], \"(\");\\n                \\n                result.append(\")\");\\n                \\n                break;\\n            }\\n            // if no remainder found\\n            // add the remainder to the map \\n            // with key as remainder and value as size of the result\\n            else{\\n                remMap[remainder] = result.size();\\n            }\\n            \\n            remainder = remainder * 10;\\n \\n            // Calculate quotient, append it to result and\\n            // calculate next remainder\\n            long long int temp = remainder / d;\\n            \\n            remainder = remainder % denominatr;\\n            \\n            result += to_string(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310874,
                "title": "100-faster-and-easier-c-solution",
                "content": "What you need to crack this is a hashmap and your childhood memories that you have with you of dividing numbers\\uD83E\\uDD17!\\nNote : Do check for sign as well.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(denominator == 0)\\n            return \"\";\\n        \\n        if(numerator == 0) \\n            return \"0\"; \\n        \\n        unordered_map<long, int> ump;\\n        string res;\\n        \\n        long quo = abs((long)numerator / (long)denominator);\\n        int sgn = 1;\\n\\n        if(numerator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(denominator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(sgn == -1)\\n        res+=\\'-\\';\\n\\n        res += to_string(quo);\\n\\n        long rem = abs((long)numerator % (long)denominator);\\n\\n        if(rem == 0) \\n        return res;\\n        res += \".\";\\n        \\n        while(rem)\\n        {\\n            ump[rem] = res.size();\\n            rem *= 10;\\n            res += to_string(rem / abs((long)denominator));\\n            rem %= abs((long)denominator);\\n            if(ump.find(rem) != ump.end())\\n            {\\n                res.insert(ump[rem], \"(\");\\n                res += \")\";\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string fractionToDecimal(int numerator, int denominator) {\\n        if(denominator == 0)\\n            return \"\";\\n        \\n        if(numerator == 0) \\n            return \"0\"; \\n        \\n        unordered_map<long, int> ump;\\n        string res;\\n        \\n        long quo = abs((long)numerator / (long)denominator);\\n        int sgn = 1;\\n\\n        if(numerator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(denominator < 0 )\\n        sgn = -1*sgn;\\n\\n        if(sgn == -1)\\n        res+=\\'-\\';\\n\\n        res += to_string(quo);\\n\\n        long rem = abs((long)numerator % (long)denominator);\\n\\n        if(rem == 0) \\n        return res;\\n        res += \".\";\\n        \\n        while(rem)\\n        {\\n            ump[rem] = res.size();\\n            rem *= 10;\\n            res += to_string(rem / abs((long)denominator));\\n            rem %= abs((long)denominator);\\n            if(ump.find(rem) != ump.end())\\n            {\\n                res.insert(ump[rem], \"(\");\\n                res += \")\";\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263033,
                "title": "one-imp-thing-to-learn-regarding-the-integers",
                "content": "Must notice that for nume=-2147483648. \\nnume=abs(nume) will be same as nume and not the positive equivalent of it.\\nSo whenenver the input constraint is INT_MIN<=nume<=INT_MAX then always always, recieve the numbers in the funciton signature only in long long format or cast the number into higher data type and then perform the operations on it. \\nEg: \\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=n1;\\n    n*=-1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> 2147483648\\n```\\n\\nand notice this : \\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=-1*n1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> -2147483648\\n```\\n\\nHere is the solution : \\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    string fractionToDecimal(ll nume, ll deno) {\\n        if(nume==0) return \"0\";\\n        string ans=\"\";\\n        if((nume<0 or deno<0)and not(nume<0 and deno<0))\\n            ans+=\"-\";\\n        nume=abs(nume);\\n        deno=abs(deno);\\n        \\n        ans+=to_string(nume/deno);\\n        ll rem=nume%deno;\\n        if(rem==0){\\n            return ans;\\n        }\\n        //dealing with after float value\\n        ans+=\".\";\\n        map<ll,ll> mm;\\n        while(rem){\\n            if(mm.find(rem)!=mm.end()){\\n                auto it=mm.find(rem);\\n                int pos=it->second;\\n                string str1=ans.substr(0,pos);\\n                string str2=ans.substr(pos);\\n                ans=str1+\"(\"+str2+\")\";\\n                break;\\n            }\\n            else{\\n                mm.insert(make_pair(rem,ans.length()));\\n                rem*=10;\\n                int q=rem/deno;\\n                ans+=to_string(q);\\n                rem%=deno;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=n1;\\n    n*=-1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> 2147483648\\n```\n```\\n#include <iostream>\\nusing namespace std;\\nint main() {\\n    int n1=-2147483648;\\n    long long n=-1*n1;\\n    cout<<n<<endl;\\n}\\n\\nO/P=> -2147483648\\n```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    string fractionToDecimal(ll nume, ll deno) {\\n        if(nume==0) return \"0\";\\n        string ans=\"\";\\n        if((nume<0 or deno<0)and not(nume<0 and deno<0))\\n            ans+=\"-\";\\n        nume=abs(nume);\\n        deno=abs(deno);\\n        \\n        ans+=to_string(nume/deno);\\n        ll rem=nume%deno;\\n        if(rem==0){\\n            return ans;\\n        }\\n        //dealing with after float value\\n        ans+=\".\";\\n        map<ll,ll> mm;\\n        while(rem){\\n            if(mm.find(rem)!=mm.end()){\\n                auto it=mm.find(rem);\\n                int pos=it->second;\\n                string str1=ans.substr(0,pos);\\n                string str2=ans.substr(pos);\\n                ans=str1+\"(\"+str2+\")\";\\n                break;\\n            }\\n            else{\\n                mm.insert(make_pair(rem,ans.length()));\\n                rem*=10;\\n                int q=rem/deno;\\n                ans+=to_string(q);\\n                rem%=deno;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1257265,
                "title": "python-solution-annoying-to-get-every-little-piece-right",
                "content": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        ans = \\'-\\' if numerator // denominator < 0 else \\'\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        prefrac = numerator // denominator\\n        ans += str(prefrac) \\n        \\n        rem = numerator % denominator\\n        if not rem:\\n            return ans\\n        ans += \\'.\\'\\n        remainder = \\'\\'\\n        seen = {}\\n        \\n        while rem not in seen:\\n            if rem == 0:\\n                return ans + remainder\\n            \\n            seen[rem] = len(remainder)\\n            rem *= 10\\n            remainder += str(rem//denominator)\\n            rem %= denominator\\n            \\n        return ans + remainder[:seen[rem]] + \\'(\\' + remainder[seen[rem]:] + \\')\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\\n\\n        ans = \\'-\\' if numerator // denominator < 0 else \\'\\'\\n        numerator = abs(numerator)\\n        denominator = abs(denominator)\\n        prefrac = numerator // denominator\\n        ans += str(prefrac) \\n        \\n        rem = numerator % denominator\\n        if not rem:\\n            return ans\\n        ans += \\'.\\'\\n        remainder = \\'\\'\\n        seen = {}\\n        \\n        while rem not in seen:\\n            if rem == 0:\\n                return ans + remainder\\n            \\n            seen[rem] = len(remainder)\\n            rem *= 10\\n            remainder += str(rem//denominator)\\n            rem %= denominator\\n            \\n        return ans + remainder[:seen[rem]] + \\'(\\' + remainder[seen[rem]:] + \\')\\'\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566944,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566482,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573920,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567896,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567897,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1570001,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573343,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1680418,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573302,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573002,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566944,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1566482,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573920,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567896,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1567897,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1570001,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573343,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1680418,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573302,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1573002,
                "content": [
                    {
                        "username": "ALittleLight",
                        "content": "There are a lot of ambiguities in this question that make it impossible to solve without guessing what is meant.  Perhaps this is a good interview question, because you can see if the candidate will talk through the ambiguities, but it is not a good leetcode question because short of submitting solutions with my interpretations, and checking to see if they pass or fail, I have no way of knowing what is actually intended by the question.\\n\\nFor example, how many digits of precision should I return?  Should I truncate or round to get this precision?  The question asks that I enclose a \"repeating part\" of the decimal in parantheses.  Does that mean I put parantheses around any repetition - e.g. 0.661 should be 0.(6)1 because 6 repeated twice?  Or just repetition that goes to the end of the length of my output string?  Do I mark repeatign digits or repeating sequences?\\n\\nI know people have solved this, so it is obviously possible to solve, but I think getting the solution is partly just guessing what the question means, which is not satisfying from a question like this."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "If you know about division and rational numbers you should know what repetition means.\\nIn any case, you can always write a testcase and see what the expected output is."
                    },
                    {
                        "username": "adamlhh",
                        "content": "As the title says. Is there any good way to deal with the extreme edge case without converting int to long?"
                    },
                    {
                        "username": "mmaddury",
                        "content": "Very poorly described. The medium difficulty is probably only due to all the unlisted contraints. Like peeling an onion. I wish there was a way for me to block such submitters. I do not want to waste time on this author\\'s additional problems.\\n\\n"
                    },
                    {
                        "username": "jiaoyipeng1704",
                        "content": "I am wondering whether it is meaningful to test such cases as [-2147483648, 1], [-1, -2147483648]: does the author just want to reminder people to use long int type? If so,  why not try [-1, -2147483647], [-1, -2147483646] etc. Actually, those cases are nothing except to be used to make fun of people."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "how did you pass those cases?"
                    },
                    {
                        "username": "hearkener",
                        "content": "The repeating pattern could not determined by first repeating number.\\n\\nfor example, 1/6 = 0.1(6) maybe correct cause the first repeating number is 6.\\n\\nbut 10/23 = 0.(43478260869565521739130) which you can see that 0,1,2,3,4,5,6,7,8,9 appears multiple times."
                    },
                    {
                        "username": "parin2",
                        "content": "Did anyone notice? 1/2147483647 gives TLE?\\nCan someone tell me why?"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "The repetition is too long."
                    },
                    {
                        "username": "kitadoom",
                        "content": "In case someone who is wodering how to deal with **infinite non-repeating decimals**.\\nAll the cases in this problem will never lead to an infinite non-repeating decimal, since they are all fractions of two integers.\\nHope nobody is as dumb as me..\\n"
                    },
                    {
                        "username": "user3893LK",
                        "content": "You will never get infinite non-repeating decimal when numerator and denominator are integer, maximum period is denominator-1"
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "This must be a hard one."
                    },
                    {
                        "username": "dparry",
                        "content": "Hello!\\n\\nI solved this problem today and found that in order to find the period of the repeating decimal, one needed to solve the solution\\n$$\\n10^D = 1 mod n\\n$$\\nwhich allows you to say 1/n = (D length string repeated).  I don\\'t see many solutions using this.  Why?"
                    },
                    {
                        "username": "samwisegamgee",
                        "content": "Is 1/2147483647 a test case? Does it work for this input?"
                    }
                ]
            },
            {
                "id": 1571365,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1568993,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1572225,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1571364,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2048998,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2031528,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1967412,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1852823,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1796595,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1769745,
                "content": [
                    {
                        "username": "data_nerd",
                        "content": "What if the division gives an irrational number such as pi. What should we return?"
                    },
                    {
                        "username": "mockRE",
                        "content": "Irrational numbers can not be represented as the division of two integers"
                    },
                    {
                        "username": "Samuri",
                        "content": "1/333 = 0.(003) or 0.00(300)?\\n\\nWhich is correct?"
                    },
                    {
                        "username": "lekacode",
                        "content": "Description doesn\\'t say that input is only rational numbers, right?"
                    },
                    {
                        "username": "gqq",
                        "content": "Notice that [WolframAlpha][1] says it is 2.0(370). Which one is correct or preferred?\\n\\n\\n  [1]: http://www.wolframalpha.com/input/?i=165/81"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "If you can divide any two numbers on paper (regardless of how long it would take), you can solve this problem.\\nIf you\\'re unsure when a repetition occurs, look at the remainders. `hint`\\nOther than that, I strongly advise you to leave the discussion section as it is full of brain farts. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The problem is interseting, but it definitely must be marked as hard."
                    },
                    {
                        "username": "codez93",
                        "content": "making observations are key to this problem."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "I was really concerned hitting the Submit button after all of these comments complaining of ambiguities and unexplained edge cases, but I never found them.  If it helps, these are the only three custom test cases I made, and they even took nearly twice as long as the actual OJ tests.\\n\\n-8 35\\n-543210 -12345\\n1 -9967"
                    },
                    {
                        "username": "ShivT828",
                        "content": "To find out repeating decimals, think in term of remainders instead of repeating decimals."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Permutation",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1725956,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try to think about the frequency of each letter. What if all characters appear with even times? What if some characters appear with odd times? :)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\nEvery letter in the word must be matched, except for possibly the middle one"
                    },
                    {
                        "username": "LethalQ",
                        "content": "appreciate it man, this one helped a lot, I mean it."
                    }
                ]
            },
            {
                "id": 1797677,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try to think about the frequency of each letter. What if all characters appear with even times? What if some characters appear with odd times? :)"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n\\nEvery letter in the word must be matched, except for possibly the middle one"
                    },
                    {
                        "username": "LethalQ",
                        "content": "appreciate it man, this one helped a lot, I mean it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Leaves of Binary Tree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570684,
                "content": [
                    {
                        "username": "kaaustubh",
                        "content": "I was asked the same question in the interview at Google, I think I came up with a good solution to return the leaves on the same level. But somehow the inteviewer was very keen not only to get the sequence but also to remove the leaves from the tree. I struggled a bit with that. And he really wanted the leaves to be remove from the root. But when I checked Leetcode later, I found none of the solutions are actually removing leaves."
                    },
                    {
                        "username": "laichbr",
                        "content": "Also removed nodes in my implementation. Did iterative DFS with a passed list and gathered the leaves each run. Check here -> https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/3178081/iterative-dfs-trimming-simple-python-implementation/?envType=study-plan&id=data-structure-iii"
                    },
                    {
                        "username": "mchim",
                        "content": "Here, removing nodes: https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/83811/simple-java-recursive-1ms-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I know how to remove children - set the parent's `left` or `right` to `null`. But how can I remove the root?"
                    },
                    {
                        "username": "bhagwataditya226",
                        "content": "While using recursion for DFS use another extra parameter as parent and pass it along, if the node\\'s left and right are empty: check if the parent\\'s left == node or parent.right == node: then set the child(node) to null. This way you eliminate all the node. now when the recursion arrives at root: it won\\'t have a parent, so check if parent is null:-> then just add the root.val to result and set it to null."
                    },
                    {
                        "username": "Yuhua-Wang",
                        "content": "[@mdesmond](/mdesmond) In that sense we don't even need to delete left and right for Java implementation. We can just return the dummy root at the end."
                    },
                    {
                        "username": "mdesmond",
                        "content": "Use a dummy root, and keep deleting leaves until the tree contains only the dummy root"
                    },
                    {
                        "username": "laichbr",
                        "content": "If you think of it as repeated DFS for the leaves and the trimming at the occurrence of a leaf node per repeated attempt with the node value added to the current iterations list values, you will get the list for this dfs removal. If you add the resulting list to the final list each time and go until you\\'ve nulled the root, you get it! "
                    }
                ]
            },
            {
                "id": 1567965,
                "content": [
                    {
                        "username": "kaaustubh",
                        "content": "I was asked the same question in the interview at Google, I think I came up with a good solution to return the leaves on the same level. But somehow the inteviewer was very keen not only to get the sequence but also to remove the leaves from the tree. I struggled a bit with that. And he really wanted the leaves to be remove from the root. But when I checked Leetcode later, I found none of the solutions are actually removing leaves."
                    },
                    {
                        "username": "laichbr",
                        "content": "Also removed nodes in my implementation. Did iterative DFS with a passed list and gathered the leaves each run. Check here -> https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/3178081/iterative-dfs-trimming-simple-python-implementation/?envType=study-plan&id=data-structure-iii"
                    },
                    {
                        "username": "mchim",
                        "content": "Here, removing nodes: https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/83811/simple-java-recursive-1ms-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I know how to remove children - set the parent's `left` or `right` to `null`. But how can I remove the root?"
                    },
                    {
                        "username": "bhagwataditya226",
                        "content": "While using recursion for DFS use another extra parameter as parent and pass it along, if the node\\'s left and right are empty: check if the parent\\'s left == node or parent.right == node: then set the child(node) to null. This way you eliminate all the node. now when the recursion arrives at root: it won\\'t have a parent, so check if parent is null:-> then just add the root.val to result and set it to null."
                    },
                    {
                        "username": "Yuhua-Wang",
                        "content": "[@mdesmond](/mdesmond) In that sense we don't even need to delete left and right for Java implementation. We can just return the dummy root at the end."
                    },
                    {
                        "username": "mdesmond",
                        "content": "Use a dummy root, and keep deleting leaves until the tree contains only the dummy root"
                    },
                    {
                        "username": "laichbr",
                        "content": "If you think of it as repeated DFS for the leaves and the trimming at the occurrence of a leaf node per repeated attempt with the node value added to the current iterations list values, you will get the list for this dfs removal. If you add the resulting list to the final list each time and go until you\\'ve nulled the root, you get it! "
                    }
                ]
            },
            {
                "id": 1798850,
                "content": [
                    {
                        "username": "kaaustubh",
                        "content": "I was asked the same question in the interview at Google, I think I came up with a good solution to return the leaves on the same level. But somehow the inteviewer was very keen not only to get the sequence but also to remove the leaves from the tree. I struggled a bit with that. And he really wanted the leaves to be remove from the root. But when I checked Leetcode later, I found none of the solutions are actually removing leaves."
                    },
                    {
                        "username": "laichbr",
                        "content": "Also removed nodes in my implementation. Did iterative DFS with a passed list and gathered the leaves each run. Check here -> https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/3178081/iterative-dfs-trimming-simple-python-implementation/?envType=study-plan&id=data-structure-iii"
                    },
                    {
                        "username": "mchim",
                        "content": "Here, removing nodes: https://leetcode.com/problems/find-leaves-of-binary-tree/solutions/83811/simple-java-recursive-1ms-solution/?orderBy=most_votes"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I know how to remove children - set the parent's `left` or `right` to `null`. But how can I remove the root?"
                    },
                    {
                        "username": "bhagwataditya226",
                        "content": "While using recursion for DFS use another extra parameter as parent and pass it along, if the node\\'s left and right are empty: check if the parent\\'s left == node or parent.right == node: then set the child(node) to null. This way you eliminate all the node. now when the recursion arrives at root: it won\\'t have a parent, so check if parent is null:-> then just add the root.val to result and set it to null."
                    },
                    {
                        "username": "Yuhua-Wang",
                        "content": "[@mdesmond](/mdesmond) In that sense we don't even need to delete left and right for Java implementation. We can just return the dummy root at the end."
                    },
                    {
                        "username": "mdesmond",
                        "content": "Use a dummy root, and keep deleting leaves until the tree contains only the dummy root"
                    },
                    {
                        "username": "laichbr",
                        "content": "If you think of it as repeated DFS for the leaves and the trimming at the occurrence of a leaf node per repeated attempt with the node value added to the current iterations list values, you will get the list for this dfs removal. If you add the resulting list to the final list each time and go until you\\'ve nulled the root, you get it! "
                    }
                ]
            }
        ]
    },
    {
        "title": "Count The Repetitions",
        "question_content": "<p>We define <code>str = [s, n]</code> as the string <code>str</code> which consists of the string <code>s</code> concatenated <code>n</code> times.</p>\n\n<ul>\n\t<li>For example, <code>str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;</code>.</li>\n</ul>\n\n<p>We define that string <code>s1</code> can be obtained from string <code>s2</code> if we can remove some characters from <code>s2</code> such that it becomes <code>s1</code>.</p>\n\n<ul>\n\t<li>For example, <code>s1 = &quot;abc&quot;</code> can be obtained from <code>s2 = &quot;ab<strong><u>dbe</u></strong>c&quot;</code> based on our definition by removing the bolded underlined characters.</li>\n</ul>\n\n<p>You are given two strings <code>s1</code> and <code>s2</code> and two integers <code>n1</code> and <code>n2</code>. You have the two strings <code>str1 = [s1, n1]</code> and <code>str2 = [s2, n2]</code>.</p>\n\n<p>Return <em>the maximum integer </em><code>m</code><em> such that </em><code>str = [str2, m]</code><em> can be obtained from </em><code>str1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= n1, n2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2997580,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```\\n\\n```Java []\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         int l1 = s1.length(), l2 = s2.length();\\n        int[] next = new int[l2 + 1];\\n        int[] count = new int[l2 + 1];\\n        int cnt = 0, p = 0;\\n        for (int i = 0; i < n1; i++) {\\n            for (int j = 0; j < l1; j++) {\\n                if (s1.charAt(j) == s2.charAt(p)) {\\n                    p++;\\n                }\\n                if (p == l2) {\\n                    cnt++;\\n                    p = 0;\\n                }\\n            }\\n            count[i] = cnt;\\n            next[i] = p;\\n            for (int j = 0; j < i; j++) {\\n                if (next[j] == p) {\\n                    int prev_count = count[j];\\n                    int pattern_count = (count[i] - count[j]) * ((n1 - j - 1) / (i - j));\\n                    int remain_count = count[j + (n1 - j - 1) % (i - j)] - count[j];\\n                    return (prev_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        return count[n1 - 1] / n2;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\n```Python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```\n```Java []\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         int l1 = s1.length(), l2 = s2.length();\\n        int[] next = new int[l2 + 1];\\n        int[] count = new int[l2 + 1];\\n        int cnt = 0, p = 0;\\n        for (int i = 0; i < n1; i++) {\\n            for (int j = 0; j < l1; j++) {\\n                if (s1.charAt(j) == s2.charAt(p)) {\\n                    p++;\\n                }\\n                if (p == l2) {\\n                    cnt++;\\n                    p = 0;\\n                }\\n            }\\n            count[i] = cnt;\\n            next[i] = p;\\n            for (int j = 0; j < i; j++) {\\n                if (next[j] == p) {\\n                    int prev_count = count[j];\\n                    int pattern_count = (count[i] - count[j]) * ((n1 - j - 1) / (i - j));\\n                    int remain_count = count[j + (n1 - j - 1) % (i - j)] - count[j];\\n                    return (prev_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        return count[n1 - 1] / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95401,
                "title": "ugly-java-brute-force-solution-but-accepted-1088ms",
                "content": "I didn't come up with any good solution so I tried brute force. Key points:\\n1. How do we know \"string s2 can be obtained from string s1\"? Easy, use two pointers iterate through s2 and s1. If chars are equal, move both. Otherwise only move pointer1.\\n2. We repeat step 1 and go through s1 for n1 times and count how many times can we go through s2.\\n3. Answer to this problem is times go through s2 divide by n2.\\n\\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int count1 = 0, count2 = 0, i = 0, j = 0;\\n        \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n            }\\n        }\\n        \\n        return count2 / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int count1 = 0, count2 = 0, i = 0, j = 0;\\n        \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n            }\\n        }\\n        \\n        return count2 / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95398,
                "title": "c-solution-inspired-by-70664914-with-organized-explanation",
                "content": "*You can find more of my code/explanations in my github repo [lzl124631x/LeetCode](https://github.com/lzl124631x/LeetCode)*\\n\\nIt\\'s easy to come up with a brute force solution and to find that there will be a **repetitive pattern** when matching `S2` through `S1`. The only problem is how to use the repetitive pattern to save computation.\\n\\n**Fact:**\\nIf `s2` repeats in `S1` `R` times, then `S2` must repeats in `S1` `R / n2` times.\\n**Conclusion:**\\nWe can simply count the repetition of `s2` and then divide the count by `n2`.\\n\\n**How to denote repetition:**\\nWe need to scan `s1` `n1` times. Denote each scanning of `s1` as an `s1` segment.\\nAfter each scanning of `i`-th `s1` segment, we will have\\n1. The accumulative count of `s2` repeated in this `s1` segment.  \\n2. A `nextIndex` that `s2[nextIndex]` is the first letter you\\'ll be looking for in the next `s1` segment.\\n> Suppose `s1=\"abc\"`, `s2=\"bac\"`, `nextIndex` will be `1`; `s1=\"abca\"`, `s2=\"bac\"`, `nextIndex` will be `2`\\n\\nIt is the `nextIndex` that is the denotation of the repetitive pattern.\\n\\n**Example:**\\n```\\nInput:\\ns1=\"abacb\", n1=6\\ns2=\"bcaa\", n2=1\\n\\nReturn:\\n3\\n```\\n```\\n                    0 1    2 3 0      1    2 3 0      1    2 3 0  \\nS1 --------------> abacb | abacb | abacb | abacb | abacb | abacb \\n\\nrepeatCount ----->    0  |   1   |   1   |   2   |   2   |   3\\n\\nIncrement of \\nrepeatCount     ->    0  |   1   |   0   |   1   |   0   |   1\\n\\nnextIndex ------->    2  |   1   |   2   |   1   |   2   |   1\\n                                     ^\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t repetitive pattern found here (we\\'ve met 2 before)!\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t The pattern repeated 3 times\\n```\\n\\nThe `nextIndex` has `s2.size()` possible values, ranging from `0` to `s2.size() - 1`. Due to PigeonHole principle, you must find two same `nextIndex` after scanning `s2.size() + 1` `s1` segments.\\n\\nOnce you meet a `nextIndex` you\\'ve met before, you\\'ll know that the following `nextIndex`s and increments of `repeatCount` will repeat a pattern.\\n\\nSo let\\'s separate the `s1` segments into 3 parts:\\n1. the prefix part before repetitive pattern\\n2. the repetitive part\\n3. the suffix part after repetitive pattern (incomplete repetitive pattern remnant)\\n\\nAll you have to do is add up the repeat counts of the 3 parts.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> repeatCount(n1 + 1, 0);\\n        vector<int> nextIndex(n1 + 1, 0);\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            repeatCount[k] = cnt;\\n            nextIndex[k] = j;\\n            for (int start = 0; start < k; ++start) {\\n                if (nextIndex[start] == j) { // see if you have met this nextIndex before\\n                    // if found, you can calculate the 3 parts\\n                    int prefixCount = repeatCount[start]; // prefixCount is the start-th repeatCount\\n                    // (repeatCount[k] - prefixCount) is the repeatCount of one occurrance of the pattern\\n                    // There are (n1 - start) / (k - start) occurrances of the pattern\\n                    // So (n1 - start) / (k - start) * (repeatCount[k] - prefixCount) is the repeatCount of the repetitive part\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - prefixCount);\\n                    // The suffix contains the incomplete repetitive remnant (if any)\\n                    // Its length is (n1 - start) % (k - start)\\n                    // So the suffix repeatCount should be repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return repeatCount[n1] / n2;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate 12/31/2018\\n* `int patternCount = (repeatCount[k] - repeatCount[start]) * (n1 - start) / (k - start);` to \\n`int patternCount = (repeatCount[k] - repeatCount[start]) * ((n1 - start) / (k - start));` since `a * b / c` doesn\\'t necessarily equal `a * (b / c)`. (the old test cases didn\\'t cover this case)\\n* The size of `repeatCount` and `nextIndex` should be `n1 + 1`.\\nThanks for comments from @wxd_sjtu, @rjtsdl, @Rongch\\n\\nAnother version using `unordered_map` to save computation. Reduce runtime from ~80ms to ~4ms.\\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, int> kToRepeatCount;\\n        unordered_map<int, int> nextIndexToK;\\n        kToRepeatCount[0] = 0;\\n        nextIndexToK[0] = 0;\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            if (nextIndexToK.find(j) != nextIndexToK.end()) {\\n                int start = nextIndexToK[j];\\n                int prefixCount = kToRepeatCount[start];\\n                int patternCount = (n1 - start) / (k - start) * (cnt - prefixCount);\\n                int suffixCount = kToRepeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                return (prefixCount + patternCount + suffixCount) / n2;\\n            }\\n            kToRepeatCount[k] = cnt;\\n            nextIndexToK[j] = k;\\n        }\\n        return kToRepeatCount[n1] / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInput:\\ns1=\"abacb\", n1=6\\ns2=\"bcaa\", n2=1\\n\\nReturn:\\n3\\n```\n```\\n                    0 1    2 3 0      1    2 3 0      1    2 3 0  \\nS1 --------------> abacb | abacb | abacb | abacb | abacb | abacb \\n\\nrepeatCount ----->    0  |   1   |   1   |   2   |   2   |   3\\n\\nIncrement of \\nrepeatCount     ->    0  |   1   |   0   |   1   |   0   |   1\\n\\nnextIndex ------->    2  |   1   |   2   |   1   |   2   |   1\\n                                     ^\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t repetitive pattern found here (we\\'ve met 2 before)!\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t The pattern repeated 3 times\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> repeatCount(n1 + 1, 0);\\n        vector<int> nextIndex(n1 + 1, 0);\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            repeatCount[k] = cnt;\\n            nextIndex[k] = j;\\n            for (int start = 0; start < k; ++start) {\\n                if (nextIndex[start] == j) { // see if you have met this nextIndex before\\n                    // if found, you can calculate the 3 parts\\n                    int prefixCount = repeatCount[start]; // prefixCount is the start-th repeatCount\\n                    // (repeatCount[k] - prefixCount) is the repeatCount of one occurrance of the pattern\\n                    // There are (n1 - start) / (k - start) occurrances of the pattern\\n                    // So (n1 - start) / (k - start) * (repeatCount[k] - prefixCount) is the repeatCount of the repetitive part\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - prefixCount);\\n                    // The suffix contains the incomplete repetitive remnant (if any)\\n                    // Its length is (n1 - start) % (k - start)\\n                    // So the suffix repeatCount should be repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return repeatCount[n1] / n2;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-the-repetitions/\\n// Author: github.com/lzl124631x\\n// Time: O(|s1| * n1) where |s1| is the length of s1\\n// Space: O(n1)\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, int> kToRepeatCount;\\n        unordered_map<int, int> nextIndexToK;\\n        kToRepeatCount[0] = 0;\\n        nextIndexToK[0] = 0;\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; ++k) {\\n            for (int i = 0; i < s1.size(); ++i) {\\n                if (s1[i] == s2[j]) {\\n                    ++j;\\n                    if (j == s2.size()) {\\n                        j = 0;\\n                        ++cnt;\\n                    }\\n                }\\n            }\\n            if (nextIndexToK.find(j) != nextIndexToK.end()) {\\n                int start = nextIndexToK[j];\\n                int prefixCount = kToRepeatCount[start];\\n                int patternCount = (n1 - start) / (k - start) * (cnt - prefixCount);\\n                int suffixCount = kToRepeatCount[start + (n1 - start) % (k - start)] - prefixCount;\\n                return (prefixCount + patternCount + suffixCount) / n2;\\n            }\\n            kToRepeatCount[k] = cnt;\\n            nextIndexToK[j] = k;\\n        }\\n        return kToRepeatCount[n1] / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372230,
                "title": "python-don-t-look-at-words-look-at-chars-in-two-virtual-repeating-strings-detailed-explanation",
                "content": "Words repetition like [s1, n1] are distracting. What actually matters is the chars. \\nImagine both s1 and s2 as \"virtual\" string that repeats forever. Let i1 and i2 be the index of the two virtual strings, not the index of the original short strings. That means i1 and i2 can be infinitely big. Use mod only when getting char value at i1 and i2, but don\\'t change i1 and i2 by \"mod\" operation.\\nMatch the two virtual s1 with s2, until the s1 index reach it\\'s limit length, which by definition is n1\\\\*len(s1). Then the i2 position at this point will be the final result in terms of char length.\\nThe rest is just converting i2 to the number of words, where word length is len(s2)\\\\*n2.\\n\\nTo improve performance, we use dictionary to store previously matched indexes in original s1 and s2, if the same matched index comes again, that means we are in a repeating pattern, in which case we increase i1 and i2 by the length of their repeating circle until there is not enough chars left in virtual s1.\\n\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        d={}\\n        l1,l2=len(s1),len(s2)\\n        total1=l1*n1\\n        i1=i2=0\\n        while i1<total1:\\n            if s1[i1%l1]==s2[i2%l2]:\\n                if (i1%l1,i2%l2) in d:\\n                    prevI1,prevI2=d[(i1%l1,i2%l2)]\\n                    circle1=i1-prevI1\\n                    circle2=i2-prevI2\\n                    circle1Cnt=(total1-i1)//circle1\\n                    i1+=circle1Cnt*circle1\\n                    i2+=circle1Cnt*circle2\\n                    if i1>=total1:\\n                        break\\n                else:\\n                    d[(i1%l1,i2%l2)]=[i1,i2]\\n                i2+=1\\n            i1+=1\\n        return i2//l2//n2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        d={}\\n        l1,l2=len(s1),len(s2)\\n        total1=l1*n1\\n        i1=i2=0\\n        while i1<total1:\\n            if s1[i1%l1]==s2[i2%l2]:\\n                if (i1%l1,i2%l2) in d:\\n                    prevI1,prevI2=d[(i1%l1,i2%l2)]\\n                    circle1=i1-prevI1\\n                    circle2=i2-prevI2\\n                    circle1Cnt=(total1-i1)//circle1\\n                    i1+=circle1Cnt*circle1\\n                    i2+=circle1Cnt*circle2\\n                    if i1>=total1:\\n                        break\\n                else:\\n                    d[(i1%l1,i2%l2)]=[i1,i2]\\n                i2+=1\\n            i1+=1\\n        return i2//l2//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95408,
                "title": "easy-understanding-java-solution-with-detailed-explanation-21ms",
                "content": "The key is, we just need to calculate ***what will remain after s1 obtains s2***.\\n\\nThat is, `(s1, s2) -> (sRemain, matchCnt)`; for example,\\n`(abcd, ab) -> (cd, 1)`\\n`(ababa, ab) -> (a, 2)`\\n`(a, aaaa) -> (a, 0)`\\n`(aabaabaab, aba) -> (ab, 2)` as `aabaaba` exactly matches `aba` twice.\\n\\n\\nAnd, each time we append `s1` to the `remain string`, to make a sequence: (Using `[]` to mark the `remain string`)\\n`(abcd, ab): abcd -> [cd]abcd -> [cd]abcd -> [cd]abcd -> ...`\\n`(ababa, ab): ababa -> [a]ababa -> [a]ababa -> [a]ababa -> ...`\\n`(a, aaaa): a -> [a]a -> [aa]a -> [aaa]a -> a -> [a]a -> [aa]a -> ...`\\n`(aabaabaab, aba): aabaabaab -> [ab]aabaabaab -> [ab]aabaabaab -> ...`\\n\\nObviously, there will be a loop in the sequence, assume the length of loop is `loop`, and the length before the loop is `k`.\\n`(abcd, ab): loop=1, k=1`\\n`(a, aaaa): loop=4, k=0`\\n`(aabaabaab, aba): loop=1, k=1`\\n\\nSo, we just need to calculate `the count of each loop`, and `the count before entering the loop`, and calculate the total.\\n\\nHere is the code with detailed comment, 21ms.\\n\\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!ableToObtain(s1, s2)) return 0; // check if [s1. \\u221e] obtains s2\\n        int cnt=0, k=-1;\\n        String s=s1;\\n        StringBuilder remainBuilder; // record `remain string`\\n        ArrayList<String> stringList=new ArrayList<>(); // record all the `remain string`\\n        ArrayList<Integer> countList=new ArrayList<>(); // record matching count from start to the current remain string \\n        stringList.add(\"\"); // record empty string\\n        countList.add(0);\\n        for (int i=0;i<=n1;i++) {\\n            remainBuilder=new StringBuilder();\\n            cnt+=getRemain(s, s2, remainBuilder); // get the next remain string, returns the count of matching\\n            String remain=remainBuilder.toString();\\n            if ((k=stringList.indexOf(remain))!=-1) break; // if there is a loop, break\\n            stringList.add(remain); // record the remain string into arraylist \\n            countList.add(cnt);\\n            s=remain+s1; // append s1 to make a new string\\n        }\\n        // here, k is the beginning of the loop\\n        if (k==-1) return cnt/n2; // if there is no loop\\n        int countOfLoop=cnt-countList.get(k), loopLength=stringList.size()-k; // get matching count in the loop, and loop length\\n        cnt=countList.get(k);\\n        n1-=k;\\n        cnt+=countOfLoop*(n1/loopLength);\\n        n1%=loopLength; \\n        cnt+=countList.get(k+n1)-countList.get(k);\\n        return cnt/n2;\\n    }\\n\\n    // check if [s1. \\u221e] obtains s2\\n    private boolean ableToObtain(String s1, String s2) {\\n        boolean[] cnt=new boolean[26];\\n        for (char c: s1.toCharArray()) cnt[c-'a']=true;\\n        for (char c: s2.toCharArray()) {\\n            if (!cnt[c-'a']) return false;\\n        }\\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemain(String s1, String s2, StringBuilder remain) {\\n        int cnt=0, lastMatch=-1, p2=0;\\n        for (int p1=0;p1<s1.length();p1++) {\\n            if (s1.charAt(p1)==s2.charAt(p2)) {\\n                if (++p2==s2.length()) {\\n                    p2=0;\\n                    cnt++;\\n                    lastMatch=p1;\\n                }\\n            }\\n        }\\n        remain.append(s1.substring(lastMatch+1));\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!ableToObtain(s1, s2)) return 0; // check if [s1. \\u221e] obtains s2\\n        int cnt=0, k=-1;\\n        String s=s1;\\n        StringBuilder remainBuilder; // record `remain string`\\n        ArrayList<String> stringList=new ArrayList<>(); // record all the `remain string`\\n        ArrayList<Integer> countList=new ArrayList<>(); // record matching count from start to the current remain string \\n        stringList.add(\"\"); // record empty string\\n        countList.add(0);\\n        for (int i=0;i<=n1;i++) {\\n            remainBuilder=new StringBuilder();\\n            cnt+=getRemain(s, s2, remainBuilder); // get the next remain string, returns the count of matching\\n            String remain=remainBuilder.toString();\\n            if ((k=stringList.indexOf(remain))!=-1) break; // if there is a loop, break\\n            stringList.add(remain); // record the remain string into arraylist \\n            countList.add(cnt);\\n            s=remain+s1; // append s1 to make a new string\\n        }\\n        // here, k is the beginning of the loop\\n        if (k==-1) return cnt/n2; // if there is no loop\\n        int countOfLoop=cnt-countList.get(k), loopLength=stringList.size()-k; // get matching count in the loop, and loop length\\n        cnt=countList.get(k);\\n        n1-=k;\\n        cnt+=countOfLoop*(n1/loopLength);\\n        n1%=loopLength; \\n        cnt+=countList.get(k+n1)-countList.get(k);\\n        return cnt/n2;\\n    }\\n\\n    // check if [s1. \\u221e] obtains s2\\n    private boolean ableToObtain(String s1, String s2) {\\n        boolean[] cnt=new boolean[26];\\n        for (char c: s1.toCharArray()) cnt[c-'a']=true;\\n        for (char c: s2.toCharArray()) {\\n            if (!cnt[c-'a']) return false;\\n        }\\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemain(String s1, String s2, StringBuilder remain) {\\n        int cnt=0, lastMatch=-1, p2=0;\\n        for (int p1=0;p1<s1.length();p1++) {\\n            if (s1.charAt(p1)==s2.charAt(p2)) {\\n                if (++p2==s2.length()) {\\n                    p2=0;\\n                    cnt++;\\n                    lastMatch=p1;\\n                }\\n            }\\n        }\\n        remain.append(s1.substring(lastMatch+1));\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95397,
                "title": "c-0ms-o-str1-length-str2-length",
                "content": "IDEA: \\n\\n**Given a str2, for each str, we can give a value v to this str such that, after greedily looking through str, our imaginary next step is to find str2[v].**\\nIn our problem, str is always (str1,n), with a given str1, so, we can take one more step and say that for each n, there is a unique v associated to n(i.e t0 (str,n)).\\n\\ndefine a division and a modulo between two strings as follow: \\n\\nstr/str2=argmax{i, (str2,i) can be obtained by str}\\nstr%str2=the v mentioned above associated with str.\\n\\nAll possible values of v is less than str2.size(), \\nso (str1,n)%str2 will begin to **repeat a pattern** after a certain n less than str2.size(). \\n(the pattern is the same because in the cases with the same v, our situations are exactly the same), \\nso is (str1,n)/str2-(str1,n+1)/str2 for the same reason. \\nWe can therefore precompute a table for all these values with O(str1.length*str2.length).\\n\\n(str1,n) can be divided in three parts:\\n\\nsth before pattern(A)    +    pattern parts(B)    +    sth after pattern(C)\\n\\nThe pattern does not necessarily begin in the first str1, we shall see if n is great enough so that there can be a pattern.\\n\\nThe last pattern(C) is not necessarily complete, we need to calculate it separately.\\n\\nWe can finish in just looking to the precomputed table and doing some simple maths. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95407,
                "title": "simple-c-code-16-lines-but-slow-179ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len=s2.size();\\n        vector<int> dp(len);\\n        for(int i=0;i<len;i++){\\n            int start=i;\\n            for(char ch : s1)if(ch==s2[start%len])start++;\\n            if(start==i)return 0;\\n            dp[i]=start-i;\\n        }\\n        int idx=0;\\n        for(int i=0;i<n1;i++)idx+=dp[idx%len];\\n        return idx/len/n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len=s2.size();\\n        vector<int> dp(len);\\n        for(int i=0;i<len;i++){\\n            int start=i;\\n            for(char ch : s1)if(ch==s2[start%len])start++;\\n            if(start==i)return 0;\\n            dp[i]=start-i;\\n        }\\n        int idx=0;\\n        for(int i=0;i<n1;i++)idx+=dp[idx%len];\\n        return idx/len/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95429,
                "title": "python-69ms-solution",
                "content": "The main idea is to find a circle. A `circle` means m rounds of s1 has a subarray of n rounds of s2, and at the meantime starting from the same point of s1. \\n```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {} # s2_idx : s1_round, s2_round\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round) / circle_s1_round * circle_s2_round\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key, val in start.iteritems():\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res / n2\\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round / n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {} # s2_idx : s1_round, s2_round\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round) / circle_s1_round * circle_s2_round\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key, val in start.iteritems():\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res / n2\\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round / n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95426,
                "title": "accepted-8ms-java-solution-with-explanation",
                "content": "**IDEA:** \\nImagine s1 and s2 repeat inifinite times as below (for example s1 = \"abcd\" and \\ns2 = \"ab\") \\nabcdabcdabcd... \\nababab... \\nsay <i, j> are pairs of pointers to s1 and s2 in greedy matched characters, \\nin above example will be \\n<0, 0>, <1, 1>, <4, 2>, <5, 3>, <8, 4>, <9, 5>... \\nIn a brute force solution we can keep increasing i and j until i exceeds s1 x n1.\\n\\nSay the lengths of s1 and s2 are m1 and m2. It's easy to prove that: \\nIf there are two pairs <i1, j1>, <i2, j2> satisfying: \\n(i2 - i1) % m1 == 0 && (j2 - j1) % m2 == 0, \\nlet d1 = i2 - i1 and d2 = j2 - j1, \\nthen for all positive integer k, <i1 + d1 * k, j1 + d2 * k> will be pairs too.\\n\\nSo without brute force matching, my trick is to use above conclusion to push <i,\\nj> quickly to near the end of the expanded string s1 x n1, after the first <i1,\\nj1> and <i2, j2> pair is found. Here's the solution:\\n\\n```\\npublic class Solution {\\n\\tpublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint m1 = s1.length();\\n\\t\\tint m2 = s2.length();\\n\\t\\tif (m1 == 0 || m2 == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint i, j;\\n\\t\\t// extra code to remove unnecessary characters in s1\\n\\t\\tStringBuffer sb = new StringBuffer();\\n\\t\\tboolean[] used = new boolean[26];\\n\\t\\tint[] counts = new int[26]; // count of each character in s1\\n\\t\\tfor (i = 0; i < m2; i++) {\\n\\t\\t\\tj = s2.charAt(i) - 'a';\\n\\t\\t\\tused[j] = true;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tif (used[j])\\n\\t\\t\\t\\tsb.append(s1.charAt(i));\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tif (used[i] && counts[i] == 0) // character in s2 not in s1\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\ts1 = sb.toString();\\n\\t\\tm1 = s1.length();\\n\\n\\t\\t// extra code to reduce s1 and s2 if it contains repeating pattern\\n\\t\\tfor (i = 1; i <= m1 / 2; i++) {\\n\\t\\t\\tif (m1 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s1, i)) {\\n\\t\\t\\t\\ts1 = s1.substring(0, i);\\n\\t\\t\\t\\tn1 *= m1 / i;\\n\\t\\t\\t\\tm1 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 1; i <= m2 / 2; i++) {\\n\\t\\t\\tif (m2 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s2, i)) {\\n\\t\\t\\t\\ts2 = s2.substring(0, i);\\n\\t\\t\\t\\tn2 *= m2 / i;\\n\\t\\t\\t\\tm2 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[][] ocs = new int[26][m1]; // occurrences of each character in s1\\n\\t\\tArrays.fill(counts, 0);\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tocs[j][counts[j]] = i;\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// simple case\\n\\t\\tif (m2 == 1) {\\n\\t\\t\\tj = s2.charAt(0) - 'a';\\n\\t\\t\\treturn counts[j]*n1/n2;\\n\\t\\t}\\n\\n\\t\\treturn getMaxRepetitionsProcessed(counts, ocs, n1, s2.toCharArray(), n2);\\n\\t}\\n\\n\\tpublic int getMaxRepetitionsProcessed(int[] counts, int[][] ocs, int n1, char[] ca2, int n2) {\\n\\t\\tint m1 = ocs[0].length;\\n\\t\\tint m2 = ca2.length;\\n\\t\\t// <i, j> pairs in slot mod m1/m2\\n\\t\\tint[][][] r = new int[m1][m2][2];\\n\\t\\t// pos[c][0] is the current index of character c in i, \\n\\t\\t// pos[c][1] is which occurrence in s1\\n\\t\\tint[][] pos = new int[26][2]; \\n\\t\\tint i, j, k, r1 = 0, r2 = 0;\\n\\t\\tboolean found = false;\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tpos[i][0] = ocs[i][0];\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tfor (j = 0; j < m2; j++) {\\n\\t\\t\\t\\tr[i][j][0] = -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 0, j = 0; i < m1 * n1; i++, j++) {\\n\\t\\t\\tk = ca2[j % m2] - 'a';\\n\\t\\t\\t// move pos[k] to a position equal or after i by iterating k's occurrences\\n\\t\\t\\twhile (pos[k][0] < i) {\\n\\t\\t\\t\\tpos[k][1]++;\\n\\t\\t\\t\\tif (pos[k][1] < counts[k]) {\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][pos[k][1]] - ocs[k][pos[k][1] - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpos[k][1] = 0;\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][0] + m1 - ocs[k][counts[k] - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti = pos[k][0];\\n\\t\\t\\tif (i >= m1 * n1) {\\n\\t\\t\\t\\treturn j / m2 / n2;\\n\\t\\t\\t}\\n\\t\\t\\tr1 = i % m1;\\n\\t\\t\\tr2 = j % m2;\\n\\t\\t\\tif (!found && r[r1][r2][0] < 0) {\\n\\t\\t\\t\\tr[r1][r2][0] = i;\\n\\t\\t\\t\\tr[r1][r2][1] = j;\\n\\t\\t\\t} else if (!found) { // push by mod trick here\\n\\t\\t\\t\\tint d1 = i - r[r1][r2][0];\\n\\t\\t\\t\\tint d2 = j - r[r1][r2][1];\\n\\t\\t\\t\\tk = (m1 * n1 - i) / d1;\\n\\t\\t\\t\\ti += k * d1;\\n\\t\\t\\t\\tj += k * d2;\\n\\t\\t\\t\\tfor (r1 = 0; r1 < 26; r1++) { // update all pos[c] the same way as i\\n\\t\\t\\t\\t\\tpos[r1][0] += k * d1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn j / m2 / n2;\\n\\t}\\n\\n\\tpublic boolean repeatAtK(String s, int k) { // check if s is repeated every k characters\\n\\t\\tint m = s.length();\\n\\t\\tint x = m / k;\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tfor (int j = 0; j < x; j++) {\\n\\t\\t\\t\\tif (s.charAt(i) != s.charAt(j * k + i))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```\\n\\nRegarding the time complexity, the for loop should be less than 2 * m1 * m2\\ntimes according to pigeonhole theorem, and the while loop inside should be less\\nthant m1 (actually can be amortized to d1/d2), so the overall time complexity\\nshould be less than O(m1 * m1 * m2). I believe in reality it should be much less. \\n\\nUgly coding because I'm not good at it, just want to share this idea to see if \\nit makes sense. Any improvement is most welcome.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint m1 = s1.length();\\n\\t\\tint m2 = s2.length();\\n\\t\\tif (m1 == 0 || m2 == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint i, j;\\n\\t\\t// extra code to remove unnecessary characters in s1\\n\\t\\tStringBuffer sb = new StringBuffer();\\n\\t\\tboolean[] used = new boolean[26];\\n\\t\\tint[] counts = new int[26]; // count of each character in s1\\n\\t\\tfor (i = 0; i < m2; i++) {\\n\\t\\t\\tj = s2.charAt(i) - 'a';\\n\\t\\t\\tused[j] = true;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tif (used[j])\\n\\t\\t\\t\\tsb.append(s1.charAt(i));\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tif (used[i] && counts[i] == 0) // character in s2 not in s1\\n\\t\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\ts1 = sb.toString();\\n\\t\\tm1 = s1.length();\\n\\n\\t\\t// extra code to reduce s1 and s2 if it contains repeating pattern\\n\\t\\tfor (i = 1; i <= m1 / 2; i++) {\\n\\t\\t\\tif (m1 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s1, i)) {\\n\\t\\t\\t\\ts1 = s1.substring(0, i);\\n\\t\\t\\t\\tn1 *= m1 / i;\\n\\t\\t\\t\\tm1 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 1; i <= m2 / 2; i++) {\\n\\t\\t\\tif (m2 % i != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (repeatAtK(s2, i)) {\\n\\t\\t\\t\\ts2 = s2.substring(0, i);\\n\\t\\t\\t\\tn2 *= m2 / i;\\n\\t\\t\\t\\tm2 = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[][] ocs = new int[26][m1]; // occurrences of each character in s1\\n\\t\\tArrays.fill(counts, 0);\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tj = s1.charAt(i) - 'a';\\n\\t\\t\\tocs[j][counts[j]] = i;\\n\\t\\t\\tcounts[j]++;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// simple case\\n\\t\\tif (m2 == 1) {\\n\\t\\t\\tj = s2.charAt(0) - 'a';\\n\\t\\t\\treturn counts[j]*n1/n2;\\n\\t\\t}\\n\\n\\t\\treturn getMaxRepetitionsProcessed(counts, ocs, n1, s2.toCharArray(), n2);\\n\\t}\\n\\n\\tpublic int getMaxRepetitionsProcessed(int[] counts, int[][] ocs, int n1, char[] ca2, int n2) {\\n\\t\\tint m1 = ocs[0].length;\\n\\t\\tint m2 = ca2.length;\\n\\t\\t// <i, j> pairs in slot mod m1/m2\\n\\t\\tint[][][] r = new int[m1][m2][2];\\n\\t\\t// pos[c][0] is the current index of character c in i, \\n\\t\\t// pos[c][1] is which occurrence in s1\\n\\t\\tint[][] pos = new int[26][2]; \\n\\t\\tint i, j, k, r1 = 0, r2 = 0;\\n\\t\\tboolean found = false;\\n\\t\\tfor (i = 0; i < 26; i++) {\\n\\t\\t\\tpos[i][0] = ocs[i][0];\\n\\t\\t}\\n\\t\\tfor (i = 0; i < m1; i++) {\\n\\t\\t\\tfor (j = 0; j < m2; j++) {\\n\\t\\t\\t\\tr[i][j][0] = -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (i = 0, j = 0; i < m1 * n1; i++, j++) {\\n\\t\\t\\tk = ca2[j % m2] - 'a';\\n\\t\\t\\t// move pos[k] to a position equal or after i by iterating k's occurrences\\n\\t\\t\\twhile (pos[k][0] < i) {\\n\\t\\t\\t\\tpos[k][1]++;\\n\\t\\t\\t\\tif (pos[k][1] < counts[k]) {\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][pos[k][1]] - ocs[k][pos[k][1] - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpos[k][1] = 0;\\n\\t\\t\\t\\t\\tpos[k][0] += ocs[k][0] + m1 - ocs[k][counts[k] - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti = pos[k][0];\\n\\t\\t\\tif (i >= m1 * n1) {\\n\\t\\t\\t\\treturn j / m2 / n2;\\n\\t\\t\\t}\\n\\t\\t\\tr1 = i % m1;\\n\\t\\t\\tr2 = j % m2;\\n\\t\\t\\tif (!found && r[r1][r2][0] < 0) {\\n\\t\\t\\t\\tr[r1][r2][0] = i;\\n\\t\\t\\t\\tr[r1][r2][1] = j;\\n\\t\\t\\t} else if (!found) { // push by mod trick here\\n\\t\\t\\t\\tint d1 = i - r[r1][r2][0];\\n\\t\\t\\t\\tint d2 = j - r[r1][r2][1];\\n\\t\\t\\t\\tk = (m1 * n1 - i) / d1;\\n\\t\\t\\t\\ti += k * d1;\\n\\t\\t\\t\\tj += k * d2;\\n\\t\\t\\t\\tfor (r1 = 0; r1 < 26; r1++) { // update all pos[c] the same way as i\\n\\t\\t\\t\\t\\tpos[r1][0] += k * d1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn j / m2 / n2;\\n\\t}\\n\\n\\tpublic boolean repeatAtK(String s, int k) { // check if s is repeated every k characters\\n\\t\\tint m = s.length();\\n\\t\\tint x = m / k;\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tfor (int j = 0; j < x; j++) {\\n\\t\\t\\t\\tif (s.charAt(i) != s.charAt(j * k + i))\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95402,
                "title": "very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea",
                "content": "Based on idea here: https://discuss.leetcode.com/topic/70667/c-0ms-o-str1-length-str2-length\\nThanks to @70664914 \\nAdded some early stop\\n```Java\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] reps = new int[102];\\n        int[] rests = new int[102];\\n        int posRest=0, repTime=0;\\n        int i=0, k=0;\\n        if(n1 <= 0) return 0;\\n        while(k==i) {\\n            i++;\\n            for(int j=0; j<s1.length(); j++) {\\n                if(s2.charAt(posRest) == s1.charAt(j)) {\\n                    posRest++;\\n                    if(posRest == s2.length()) {\\n                        repTime++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            if(i >= n1)\\n                return repTime / n2;\\n            for(k=0; k<i; k++){\\n                if(posRest == rests[k])\\n                    break;\\n            }\\n            reps[i] = repTime;\\n            rests[i] = posRest;\\n        }\\n        int interval = i-k;\\n        int repeatCount = (n1-k) / interval;\\n        int repeatTimes = repeatCount * (reps[i]-reps[k]);\\n        int remainTimes = reps[(n1-k) % interval + k];\\n        return (repeatTimes + remainTimes) / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] reps = new int[102];\\n        int[] rests = new int[102];\\n        int posRest=0, repTime=0;\\n        int i=0, k=0;\\n        if(n1 <= 0) return 0;\\n        while(k==i) {\\n            i++;\\n            for(int j=0; j<s1.length(); j++) {\\n                if(s2.charAt(posRest) == s1.charAt(j)) {\\n                    posRest++;\\n                    if(posRest == s2.length()) {\\n                        repTime++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            if(i >= n1)\\n                return repTime / n2;\\n            for(k=0; k<i; k++){\\n                if(posRest == rests[k])\\n                    break;\\n            }\\n            reps[i] = repTime;\\n            rests[i] = posRest;\\n        }\\n        int interval = i-k;\\n        int repeatCount = (n1-k) / interval;\\n        int repeatTimes = repeatCount * (reps[i]-reps[k]);\\n        int remainTimes = reps[(n1-k) % interval + k];\\n        return (repeatTimes + remainTimes) / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119679,
                "title": "brutal-force-optimization-easy-understanding-c",
                "content": "brutal force is simple. What we need to do is to find the repeating cycle and move the pointers forward. When the s2 ends and the s1 pointer is on the previous positions, then you get the repeating things.\\n\\nLet\\'s say s1 = \"abab\", s2= \"aabb\".\\n\\n```\\nabab abab abab abab abab\\na ab  ba  ab b a ab  b\\n      |      |       |\\np1:   1      3       1\\n```\\nIn the above chart, when string 2 ends, p1 positions are 1, 3, 1. Here we can find the repeating cycle, which consists of 3 s1 and 2 s2. Then we can calculate how many round are there to go and then easily move the points to the very end part.\\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            // optimization part below\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    // s1 reaches the same position, which means the repeating cycle found. \\n                    //Then we can leap forward.\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nabab abab abab abab abab\\na ab  ba  ab b a ab  b\\n      |      |       |\\np1:   1      3       1\\n```\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            // optimization part below\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    // s1 reaches the same position, which means the repeating cycle found. \\n                    //Then we can leap forward.\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 95420,
                "title": "c-3ms-find-reoccurence-and-skip",
                "content": "Every time we find a complete s2 in n1\\\\*s1, we record three things using a map:\\n* key: current position in s1\\n* value: current position in n\\\\*s1 and how many s2 have been found.\\n\\nLater, we check if current position in s1 has been recorded before, and if so, we can skip reoccurrence of all s1[i0:i](see what i0 and i mean in code below) in n1\\\\*s1.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, pair<int, int>> r;\\n        \\n        int k = 0;\\n        for(int i = 0; i < s1.length()*n1;) {\\n            \\n            int rr = i % s1.length();\\n            if(r.find(rr) == r.end()) {\\n                r[rr] = make_pair(i, k);\\n                // cout << \"setup: \" << rr << ',' << i << ',' << k << endl;\\n            }\\n            else {\\n                // cout << rr << ',' << i << ',' << k << endl;\\n                auto i0 = r[rr].first;\\n                auto k0 = r[rr].second; // now, i - i0 == (k - k0) * s2.length()\\n                \\n                int n = (s1.length()*n1 - i0) / (i - i0); // we have n*(k - k0) complete s2 left\\n                \\n                // skip repeated patterns\\n                i = i0 + n*(i - i0);\\n                k = k0 + n*(k - k0);\\n            }\\n            \\n            for(int j = 0; i < s1.length()*n1 && j < s2.length(); ++ i, ++ j) {\\n                while(i < s1.length()*n1 && s1[i%s1.length()] != s2[j]) ++ i;\\n            }\\n            \\n            if(i >= s1.length()*n1) {\\n                break;\\n            }\\n            \\n            ++ k;\\n        }\\n        \\n        // cout << k << endl;\\n        return k / n2;\\n    }\\n    \\n    inline string repeat(string &s, int n) {\\n        string S;\\n        S.reserve(s.size()*n);\\n        while(n -- > 0) {\\n            S += s;\\n        }\\n        return S;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        unordered_map<int, pair<int, int>> r;\\n        \\n        int k = 0;\\n        for(int i = 0; i < s1.length()*n1;) {\\n            \\n            int rr = i % s1.length();\\n            if(r.find(rr) == r.end()) {\\n                r[rr] = make_pair(i, k);\\n                // cout << \"setup: \" << rr << ',' << i << ',' << k << endl;\\n            }\\n            else {\\n                // cout << rr << ',' << i << ',' << k << endl;\\n                auto i0 = r[rr].first;\\n                auto k0 = r[rr].second; // now, i - i0 == (k - k0) * s2.length()\\n                \\n                int n = (s1.length()*n1 - i0) / (i - i0); // we have n*(k - k0) complete s2 left\\n                \\n                // skip repeated patterns\\n                i = i0 + n*(i - i0);\\n                k = k0 + n*(k - k0);\\n            }\\n            \\n            for(int j = 0; i < s1.length()*n1 && j < s2.length(); ++ i, ++ j) {\\n                while(i < s1.length()*n1 && s1[i%s1.length()] != s2[j]) ++ i;\\n            }\\n            \\n            if(i >= s1.length()*n1) {\\n                break;\\n            }\\n            \\n            ++ k;\\n        }\\n        \\n        // cout << k << endl;\\n        return k / n2;\\n    }\\n    \\n    inline string repeat(string &s, int n) {\\n        string S;\\n        S.reserve(s.size()*n);\\n        while(n -- > 0) {\\n            S += s;\\n        }\\n        return S;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 496150,
                "title": "java-dp-like-solution",
                "content": "* iterate through S1 again and again, track the pointer position of S2 at the end of each S1 iteration\\n* continue until the S2 pointer comes back to previous position, which means we\\'ve found a cycle\\n\\t* break up into 3 parts: pre-cycle, in-cycle, post-cycle\\n\\t\\t* calculate loop count for the in-cycle part\\n\\t\\t* snitch pre-cycle and post-cycle together, and calculate the loop count for this combined parts\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int nn1 = s1.length();\\n        int nn2 = s2.length();\\n        \\n        int[][] records = new int[2][n1+1];\\n        Arrays.fill(records[0], -1);\\n        int index2 = 0, count = 0;\\n        int cycleStart = -1, cycleEnd = -1, cycleCount = -1;\\n        for (int i = 1; i <= n1; i++) {\\n            for (int j = 0; j < nn1; j++) {\\n                if (s1.charAt(j) == s2.charAt(index2)) {\\n                    index2++;\\n                }\\n                if (index2 == nn2) {\\n                    index2 = 0;\\n                    count++;\\n                }\\n            }\\n            for (int k = 1; k < i; k++) {\\n                if (records[0][k] == index2) { \\n                    // we find the cycle, record start/end/count and then quit the loop\\n                    cycleStart = k;\\n                    cycleEnd = i;\\n                    cycleCount = count - records[1][k];\\n                }\\n            }\\n            if (cycleStart != -1) {\\n                break;\\n            }\\n            records[0][i] = index2;\\n            records[1][i] = count;\\n        }\\n        \\n        if (cycleStart == -1) {\\n            return count / n2;\\n        }\\n        \\n        int res = 0;\\n        // calculate cycle\\n        int cycleN = (n1 - cycleStart) / (cycleEnd - cycleStart);\\n        res = cycleN * cycleCount;\\n        // snitich pre-cycle and post-cycle parts\\n        res += records[1][n1 - cycleN * (cycleEnd - cycleStart)];\\n        \\n        return res / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int nn1 = s1.length();\\n        int nn2 = s2.length();\\n        \\n        int[][] records = new int[2][n1+1];\\n        Arrays.fill(records[0], -1);\\n        int index2 = 0, count = 0;\\n        int cycleStart = -1, cycleEnd = -1, cycleCount = -1;\\n        for (int i = 1; i <= n1; i++) {\\n            for (int j = 0; j < nn1; j++) {\\n                if (s1.charAt(j) == s2.charAt(index2)) {\\n                    index2++;\\n                }\\n                if (index2 == nn2) {\\n                    index2 = 0;\\n                    count++;\\n                }\\n            }\\n            for (int k = 1; k < i; k++) {\\n                if (records[0][k] == index2) { \\n                    // we find the cycle, record start/end/count and then quit the loop\\n                    cycleStart = k;\\n                    cycleEnd = i;\\n                    cycleCount = count - records[1][k];\\n                }\\n            }\\n            if (cycleStart != -1) {\\n                break;\\n            }\\n            records[0][i] = index2;\\n            records[1][i] = count;\\n        }\\n        \\n        if (cycleStart == -1) {\\n            return count / n2;\\n        }\\n        \\n        int res = 0;\\n        // calculate cycle\\n        int cycleN = (n1 - cycleStart) / (cycleEnd - cycleStart);\\n        res = cycleN * cycleCount;\\n        // snitich pre-cycle and post-cycle parts\\n        res += records[1][n1 - cycleN * (cycleEnd - cycleStart)];\\n        \\n        return res / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947084,
                "title": "python-3-count-the-repetitions-t-m-34-ms-13-9-mb-100-96",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720776,
                "title": "python-3-solution-with-clear-comments",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        # hashtable to store the patterns\\n        patterns = {}\\n\\n        # pointers on s1 and s2\\n        p1, p2 = 0, 0\\n\\n        # number of occurance of s1 and s2 so far\\n        c1, c2 = 1, 0\\n\\n        # execute the loop when number of occurance of s1 has not been used up\\n        while c1 <= n1:\\n\\n            # if a character match is found, move p2 forward\\n            if s1[p1] == s2[p2]:\\n                p2 += 1\\n\\n                # p2 reaches the end of s2, meaning 1 occurance of s2\\n            if p2 == len(s2):\\n                c2 += 1\\n                p2 = 0\\n\\n                # store the pattern if not exists\\n                if p1 not in patterns:\\n                    patterns[p1] = (c1, c2)\\n\\n                # a repeat has been found, handle the repeat\\n                else:\\n                    # previous occurance of s1 and s2\\n                    prev_c1, prev_c2 = patterns[p1]\\n\\n                    # number of occurance of s1 and s2 in a single repeat\\n                    n_s1_repeat, n_s2_repeat = c1 - prev_c1, c2 - prev_c2\\n\\n                    # number of repeats\\n                    n_repeats = (n1 - prev_c1) // n_s1_repeat\\n\\n                    # number of s2 occurances in the repeats\\n                    c2_repeats = n_repeats * n_s2_repeat\\n\\n                    # the remain available occurances of s1\\n                    remain_c1 = (n1 - prev_c1) % n_s1_repeat\\n\\n                    # update c1 and c2\\n                    c1 = n1 - remain_c1\\n                    c2 = c2_repeats + prev_c2\\n\\n            # move forward p1 every iteration\\n            p1 += 1\\n\\n            # p1 reaches the end of s1, move it back to 0 and mark 1 occurance of s1\\n            if p1 == len(s1):\\n                c1 += 1\\n                p1 = 0\\n\\n        # divide c2 by n2 to get the result\\n        return c2 // n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        # hashtable to store the patterns\\n        patterns = {}\\n\\n        # pointers on s1 and s2\\n        p1, p2 = 0, 0\\n\\n        # number of occurance of s1 and s2 so far\\n        c1, c2 = 1, 0\\n\\n        # execute the loop when number of occurance of s1 has not been used up\\n        while c1 <= n1:\\n\\n            # if a character match is found, move p2 forward\\n            if s1[p1] == s2[p2]:\\n                p2 += 1\\n\\n                # p2 reaches the end of s2, meaning 1 occurance of s2\\n            if p2 == len(s2):\\n                c2 += 1\\n                p2 = 0\\n\\n                # store the pattern if not exists\\n                if p1 not in patterns:\\n                    patterns[p1] = (c1, c2)\\n\\n                # a repeat has been found, handle the repeat\\n                else:\\n                    # previous occurance of s1 and s2\\n                    prev_c1, prev_c2 = patterns[p1]\\n\\n                    # number of occurance of s1 and s2 in a single repeat\\n                    n_s1_repeat, n_s2_repeat = c1 - prev_c1, c2 - prev_c2\\n\\n                    # number of repeats\\n                    n_repeats = (n1 - prev_c1) // n_s1_repeat\\n\\n                    # number of s2 occurances in the repeats\\n                    c2_repeats = n_repeats * n_s2_repeat\\n\\n                    # the remain available occurances of s1\\n                    remain_c1 = (n1 - prev_c1) % n_s1_repeat\\n\\n                    # update c1 and c2\\n                    c1 = n1 - remain_c1\\n                    c2 = c2_repeats + prev_c2\\n\\n            # move forward p1 every iteration\\n            p1 += 1\\n\\n            # p1 reaches the end of s1, move it back to 0 and mark 1 occurance of s1\\n            if p1 == len(s1):\\n                c1 += 1\\n                p1 = 0\\n\\n        # divide c2 by n2 to get the result\\n        return c2 // n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95405,
                "title": "find-the-cycle-python-fast-with-explanation",
                "content": "This is a difficult problem (for me anyway). I kept thinking that there had to be a trick\\n\\nFirstly, if there is any character in `s2` that is not in `s1` then we can never obtain `[S2, M]` from `S1`.\\n\\nThen I step through `s1`, incrementing an index pointer in `s2` whenever characters match :\\n* When I reach the end of `s2`, go back to the start and increment the counter `s2_reps` that tells me how many complete copies of `s2` I have used.\\n* Similarly when I reach the end of `s1`, go back to the start and increment `s1_reps`.\\n* At then end of `s1` record in a dictionary a mapping from the next index to be matched in `s2` as key and the pair of `(s1_reps, s2_reps)` as value.\\n* If the key has been seen before then we are in a loop, every time we go through `s1` we are at the same position in `s2`. So we can break from stepping through the strings and work out how many loops we can go through for all of `[s1, n1]`.\\n\\n(Potentially we never find a loop and have reached `n1` repetitions of `s1` already so can just return `s2_reps // n2`)\\n\\nHaving found how many repetitions of `s1` and `s2` there are in a loop, we use as many loops as possible to go through `n1` copies of `s1`. Bear in mind that there may be some repetitions before the loop is entered.\\nThen all that remains is if we have not seen `n1` copies of `s1` after the final loop, step through the strings again until we reach `n1`.\\n\\nI suspect the code below could be made a little more efficient. Comments welcome! \\n```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n\\n        if any(c for c in set(s2) if c not in set(s1)):   # early return if impossible\\n            return 0\\n\\n        s2_index_to_reps = {0 : (0, 0)}   # mapping from index in s2 to numbers of repetitions of s1 and s2\\n        i, j = 0, 0\\n        s1_reps, s2_reps = 0, 0\\n\\n        while s1_reps < n1:\\n\\n            if s1[i] == s2[j]:\\n                j += 1     # move s2 pointer if chars match\\n            i += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n                if j in s2_index_to_reps:   # loop found, same index in s2 as seen before\\n                    break\\n                s2_index_to_reps[j] = (s1_reps, s2_reps)\\n\\n        if s1_reps == n1:    # already used n1 copies of s1\\n            return s2_reps // n2\\n\\n        initial_s1_reps, initial_s2_reps = s2_index_to_reps[j]    # repetitions before loop starts\\n        loop_s1_reps = s1_reps - initial_s1_reps\\n        loop_s2_reps = s2_reps - initial_s2_reps\\n        loops = (n1 - initial_s1_reps) // loop_s1_reps\\n\\n        s2_reps = initial_s2_reps + loops * loop_s2_reps\\n        s1_reps = initial_s1_reps + loops * loop_s1_reps\\n\\n        while s1_reps < n1:   # if loop does not end with n1 copies of s1, keep going\\n\\n            if s1[i] == s2[j]:\\n                j += 1\\n            i += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n        return s2_reps // n2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n\\n        if any(c for c in set(s2) if c not in set(s1)):   # early return if impossible\\n            return 0\\n\\n        s2_index_to_reps = {0 : (0, 0)}   # mapping from index in s2 to numbers of repetitions of s1 and s2\\n        i, j = 0, 0\\n        s1_reps, s2_reps = 0, 0\\n\\n        while s1_reps < n1:\\n\\n            if s1[i] == s2[j]:\\n                j += 1     # move s2 pointer if chars match\\n            i += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n                if j in s2_index_to_reps:   # loop found, same index in s2 as seen before\\n                    break\\n                s2_index_to_reps[j] = (s1_reps, s2_reps)\\n\\n        if s1_reps == n1:    # already used n1 copies of s1\\n            return s2_reps // n2\\n\\n        initial_s1_reps, initial_s2_reps = s2_index_to_reps[j]    # repetitions before loop starts\\n        loop_s1_reps = s1_reps - initial_s1_reps\\n        loop_s2_reps = s2_reps - initial_s2_reps\\n        loops = (n1 - initial_s1_reps) // loop_s1_reps\\n\\n        s2_reps = initial_s2_reps + loops * loop_s2_reps\\n        s1_reps = initial_s1_reps + loops * loop_s1_reps\\n\\n        while s1_reps < n1:   # if loop does not end with n1 copies of s1, keep going\\n\\n            if s1[i] == s2[j]:\\n                j += 1\\n            i += 1\\n\\n            if i == len(s1):\\n                i = 0\\n                s1_reps += 1\\n\\n            if j == len(s2):\\n                j = 0\\n                s2_reps += 1\\n\\n        return s2_reps // n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95422,
                "title": "java-solution-with-explanation",
                "content": "Took reference from https://discuss.leetcode.com/topic/71256/easy-understanding-java-solution-with-detailed-explanation-21ms but tried to give more detailed explanation about the pattern math.\\n\\n```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!verifyInput(s1, s2)) {\\n            return 0;\\n        }\\n\\n        int totalOccurrence = 0;\\n        String remaining = \"\", str = s1;\\n        boolean loopFound = false;\\n        Map<String, Integer> cycleIndex = new HashMap<String, Integer>();\\n        ArrayList<Integer> occurenceCountAtEachCycle = new ArrayList<Integer>(); \\n        \\n        for (int i = 0; i <= n1; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            totalOccurrence += getRemaining(str, s2, sb);\\n            remaining = sb.toString();\\n\\n            if (cycleIndex.containsKey(remaining)) {\\n                loopFound = true;\\n                break;\\n            }\\n\\n            cycleIndex.put(remaining, i);\\n            \\n            occurenceCountAtEachCycle.add(totalOccurrence);\\n            \\n            str = remaining + s1; // append s1 to make a new string\\n        }\\n\\n        if (!loopFound) {\\n            return totalOccurrence / n2; // if there is no loop\\n        }\\n\\n        int indexBeforeLoop = cycleIndex.get(remaining);\\n        \\n        int occurrenceCountInLoopCycle = totalOccurrence - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n       \\n       // represents the number of cycles required to complete a loop\\n        int loopCycleLength = occurenceCountAtEachCycle.size() - indexBeforeLoop;\\n        \\n        // resetting the total occurrence to cycle before loop happened\\n        totalOccurrence = occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        \\n        // removing cycles from n1 before loop started. Adding 1 as n1 is 1 based and other index are 0 based\\n        n1 -= (indexBeforeLoop + 1);\\n        \\n        // total occurrence is number of occurrence before loop + number of occurrence in loops for the rest of n1\\n        totalOccurrence += occurrenceCountInLoopCycle * (n1 / loopCycleLength);\\n        \\n        // if loop cycle terminated prematurely then the remaining cycles should be accounted\\n        n1 %= loopCycleLength;\\n\\n        if(n1 != 0){\\n            // occurenceCountAtEachCycle.get(indexBeforeLoop) is required because we just want to add the left over cycles of incomplete loop.\\n            totalOccurrence += occurenceCountAtEachCycle.get(indexBeforeLoop + n1) - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        }\\n\\n        return totalOccurrence / n2;\\n    }\\n\\n    // check if s1 contains all s2 characters\\n    private boolean verifyInput(String s1, String s2) {\\n        boolean[] arr = new boolean[26];\\n\\n        for (char ch : s1.toCharArray()) {\\n            arr[ch - 'a'] = true;\\n        }\\n\\n        for (char ch : s2.toCharArray()) {\\n            if (!arr[ch - 'a']){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemaining(String s1, String s2, StringBuilder remaining) {\\n        int count = 0, lastMatchIdx = -1, s2Idx = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(s2Idx)) {\\n                if (++s2Idx == s2.length()) {\\n                    s2Idx = 0;\\n                    count++;\\n                    lastMatchIdx = i;\\n                }\\n            }\\n        }\\n        remaining.append(s1.substring(lastMatchIdx + 1));\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (!verifyInput(s1, s2)) {\\n            return 0;\\n        }\\n\\n        int totalOccurrence = 0;\\n        String remaining = \"\", str = s1;\\n        boolean loopFound = false;\\n        Map<String, Integer> cycleIndex = new HashMap<String, Integer>();\\n        ArrayList<Integer> occurenceCountAtEachCycle = new ArrayList<Integer>(); \\n        \\n        for (int i = 0; i <= n1; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            totalOccurrence += getRemaining(str, s2, sb);\\n            remaining = sb.toString();\\n\\n            if (cycleIndex.containsKey(remaining)) {\\n                loopFound = true;\\n                break;\\n            }\\n\\n            cycleIndex.put(remaining, i);\\n            \\n            occurenceCountAtEachCycle.add(totalOccurrence);\\n            \\n            str = remaining + s1; // append s1 to make a new string\\n        }\\n\\n        if (!loopFound) {\\n            return totalOccurrence / n2; // if there is no loop\\n        }\\n\\n        int indexBeforeLoop = cycleIndex.get(remaining);\\n        \\n        int occurrenceCountInLoopCycle = totalOccurrence - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n       \\n       // represents the number of cycles required to complete a loop\\n        int loopCycleLength = occurenceCountAtEachCycle.size() - indexBeforeLoop;\\n        \\n        // resetting the total occurrence to cycle before loop happened\\n        totalOccurrence = occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        \\n        // removing cycles from n1 before loop started. Adding 1 as n1 is 1 based and other index are 0 based\\n        n1 -= (indexBeforeLoop + 1);\\n        \\n        // total occurrence is number of occurrence before loop + number of occurrence in loops for the rest of n1\\n        totalOccurrence += occurrenceCountInLoopCycle * (n1 / loopCycleLength);\\n        \\n        // if loop cycle terminated prematurely then the remaining cycles should be accounted\\n        n1 %= loopCycleLength;\\n\\n        if(n1 != 0){\\n            // occurenceCountAtEachCycle.get(indexBeforeLoop) is required because we just want to add the left over cycles of incomplete loop.\\n            totalOccurrence += occurenceCountAtEachCycle.get(indexBeforeLoop + n1) - occurenceCountAtEachCycle.get(indexBeforeLoop);\\n        }\\n\\n        return totalOccurrence / n2;\\n    }\\n\\n    // check if s1 contains all s2 characters\\n    private boolean verifyInput(String s1, String s2) {\\n        boolean[] arr = new boolean[26];\\n\\n        for (char ch : s1.toCharArray()) {\\n            arr[ch - 'a'] = true;\\n        }\\n\\n        for (char ch : s2.toCharArray()) {\\n            if (!arr[ch - 'a']){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n    // get remain string after s1 obtains s2, return the matching count\\n    private int getRemaining(String s1, String s2, StringBuilder remaining) {\\n        int count = 0, lastMatchIdx = -1, s2Idx = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(s2Idx)) {\\n                if (++s2Idx == s2.length()) {\\n                    s2Idx = 0;\\n                    count++;\\n                    lastMatchIdx = i;\\n                }\\n            }\\n        }\\n        remaining.append(s1.substring(lastMatchIdx + 1));\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777287,
                "title": "java-solution-4ms-runtime-with-brief-explanation",
                "content": "## Code \\u2615\\uFE0F\\n\\n```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```\\n\\n## Explanation ..\\n\\n. For each repetition of s1, count the number of times we see s2\\n. Store the seen count for each repetition of s1\\n. Store the index of s2 where we stopped after each repetition of s1\\n. For each repetition of s1, check if we\\'ve seen this index of s2 before\\n. If we have, then we\\'ve found a repeating pattern\\n. The number of times we see s2 in the pattern is (count[k] - count[start])\\n. The number of times we see s2 outside the pattern is (count[start + (n1 - start) % (k - start)] - count[start])\\n. The number of times we see s2 in total is (prefixCount + patternCount + suffixCount)\\n. The number of times we see s2 in total divided by n2 is the answer\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589114,
                "title": "python-3-short-simple-solution",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        dp = []\\n        for i in range(len(s2)):\\n            start = i\\n            cnt = 0\\n            for j in range(len(s1)):\\n                if s1[j] == s2[start]:\\n                    start += 1\\n                    if start == len(s2):\\n                        start = 0\\n                        cnt += 1\\n            dp.append((start,cnt))\\n        res = 0\\n        next = 0\\n        for _ in range(n1):\\n            res += dp[next][1]\\n            next = dp[next][0]\\n        return res // n2\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        dp = []\\n        for i in range(len(s2)):\\n            start = i\\n            cnt = 0\\n            for j in range(len(s1)):\\n                if s1[j] == s2[start]:\\n                    start += 1\\n                    if start == len(s2):\\n                        start = 0\\n                        cnt += 1\\n            dp.append((start,cnt))\\n        res = 0\\n        next = 0\\n        for _ in range(n1):\\n            res += dp[next][1]\\n            next = dp[next][0]\\n        return res // n2\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95424,
                "title": "java-solution-with-o-s1-length-2-s2-length",
                "content": "To determine if a string `str2` is contained in another string `str1`, there is a naive `O(n)` solution with `n = str1.length`: from start to end, simply match each character in `str2` greedily with those in `str1`. If there is a such match for all characters in `str2`, we conclude `str2` is contained in `str1`, otherwise it is not.\\n\\nTo find the number of `str2` contained in `str1`, we can proceed similarly except now we need to keep track of the number of matches found for `str2`. Still this can be done in `O(n)` time.\\n\\nSo for our problem, \"**to find the maximum number of `S2=[s2,n2]` contained in `S1=[s1,n1]`**\", we have the following naive solution:\\n\\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    int M = 0, p = 0, q = 0;\\n    \\t\\n    for (int i = 0; i < n1; i++) {\\n    \\tfor (int j = 0; j < s1.length(); j++) {\\n    \\t    if (s1.charAt(j) == s2.charAt(q)) {\\n    \\t\\tq++;\\n    \\t\\t\\t\\t\\n    \\t\\tif (q == s2.length()) {\\n    \\t\\t    p++;\\n    \\t\\t    q = 0;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t\\tif (p == n2) {\\n    \\t\\t    M++;\\n    \\t\\t    p = 0;\\n    \\t\\t}\\n    \\t    }\\n    \\t}\\n    }\\n    \\t\\n    return M;\\n}\\n```\\nAnd as you would expect, this failed the extreme case when `s1.length = 100` and `n1 = 10^6` (i.e., `S1.length = 10^8`). So let's see how we can do better.\\n\\nThe key idea here is to take advantage of the fact that `S1` consists of repeating strings (i.e. `s1`). The naive solution ignored this information and did a blind scan for the whole string, which led to the poor time performance.\\n\\nFirst we will assume `s1` contains at least once of each distinct character in `s2`, otherwise no `S2` can be contained in `S1`. Second, instead of finding the number of `S2` contained in `S1`, we will find the number of `s2` contained in `S1`. The former can be obtained by dividing the latter by `n2`.\\n\\nTo implement the above idea, here are some observations:\\n1. Each character with index `i` (`0 <= i < N1`) in string `S1` will correspond to some index `j` in string `s1`, with `j = i % s1.length` and `N1 = S1.length`.\\n\\n2. Each match of the whole string `s2` in `S1` will end at some index in `S1`. Starting from the first match, let's label the end index for each match in `S1` as `i1, i2, i3 ...`, and the corresponding indices in `s1` as `j1, j2, j3 ...`.\\n\\n3. Let `ip` and `iq` be the end indices in `S1` of the first two matches whose corresponding indices in `s1`, `jp` and `jq`, are equal. Let `S1(ip, iq]` denote the substring between them, `l = iq - ip` as its length and `m` as the total number of `s2` contained in it. Then the substring `S1(ip, N1)` can be constructed by concatenating `t` times the substring `S1(ip, iq]` plus possibly some residual part `S1(r, N1)`, where `t = (N1 - ip - 1) / l`  (integer part) and `r = ip + t * l  + 1`. And the total number of `s2` contained in the substring `S1(ip, r)` will simply be the product `m * l`. Also the total length of the residual substring is less than `l`.\\n(**Note**: for the substring notations, `(` or `)` means exclusive, `[` or `]` inclusive)\\n\\n4. It can be shown that if the two indices `ip` and `iq` in part 3 exist, they can be found in `O(s1.length^2 * s2.length)` time. The reasoning is as follows: first since `s1` contains at least once of each distinct character in `s2`, starting from any index in `S1`, it will take at most `s1.length * (s2.length + 1)` characters to find a match of `s2` in `S1` (consider the worst case scenario in which it takes a whole `s1` string to match each single character in `s2`). Second there are at most `s1.length` matches of `s2` in `S1` whose corresponding indices in `s1` are all different, as each match must take one index in `s1` and we have only up to `s1.length` different positions available. Therefore the index in `s1` of the `(s1.length + 1)`-th match must coincide with some previous match. In total `ip` and `iq` will be found within `s1.length^2 * (s2.length + 1)` characters. This also sets the upper limit on `l` where `l = iq - ip`, which in turn bounds the total length of the residual substring in part 3.\\n\\n5. The total number of `s2` contained in `S1` can be obtained from three parts: the number contained in substring `S1[0, ip]`, the number contained in substring `S1(ip, r)` and lastly the number contained in the residual substring `S1[r, N1)`. The number in the second part can be obtained in constant time (simple mathematical computation) while those in the first and third parts can both be obtained in `O(s1.length^2 * s2.length)` time. Therefore our total time complexity will be at most `O(s1.length^2 * s2.length)`.\\n\\nHere is the java program for the improved solution with brief explanation as follows:\\n1. First make sure `s1` contains at least once of each distinct character in `s2`.\\n\\n2. For each match of `s2` in `S1`, we will record two piece of information: its end index in `S1` and the total number of matches up to this end index. Since we will have at most `s1.length` \"distinct\" matches, we will use an array of the same length as `s1` to hold matches found so far. The element in the array will be another array of length 2, whose first element denotes the end index and second element the total matches.\\n\\n3. We will proceed in the way described in the naive solution to identify possible matches. If we do not make it all the way to the end of `S1`, then a repeating match is found. We can obtain `l`, `m` and `t` to compute the number of `s2` contained in the second part as well as scanning the residual substring to get that in the third part. The final answer will be the total number in all three parts divided by `n2`.\\n\\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    Set<Character> set = new HashSet<>(s1.length());\\n\\n    for (char ch : s1.toCharArray()) set.add(ch);\\n\\n    for (char ch : s2.toCharArray()) {\\n    \\tif (!set.contains(ch)) return 0;\\n    }\\n    \\t\\n    int[][] arr = new int[s1.length()][2];\\n\\n    for (int i = 0; i < s1.length(); i++) {\\n        arr[i][0] = -1;\\n    }\\n    \\t\\n    int i = 0, j = 0, k = 0, c = 0, N1 = n1 * s1.length();\\n    \\t\\n    for (; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n    \\tif (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t    c++;\\n\\t    if (arr[j][0] >= 0) break;\\n\\t    arr[j][0] = i;\\n\\t    arr[j][1] = c;\\n\\t}\\n    }\\n    \\t\\n    if (i < N1) {\\n        int l = i - arr[j][0];\\n        int m = c - arr[j][1];\\n        int t = (N1 - arr[j][0] - 1) / l;\\n        c = arr[j][1] + m * t;\\n        i = arr[j][0] + l * t + 1;\\n        \\t\\n        for (j = i % s1.length(), k = 0; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n            if (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t\\tc++;\\n    \\t    }\\n        }\\n    }\\n    \\t\\n    return c / n2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    int M = 0, p = 0, q = 0;\\n    \\t\\n    for (int i = 0; i < n1; i++) {\\n    \\tfor (int j = 0; j < s1.length(); j++) {\\n    \\t    if (s1.charAt(j) == s2.charAt(q)) {\\n    \\t\\tq++;\\n    \\t\\t\\t\\t\\n    \\t\\tif (q == s2.length()) {\\n    \\t\\t    p++;\\n    \\t\\t    q = 0;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t\\tif (p == n2) {\\n    \\t\\t    M++;\\n    \\t\\t    p = 0;\\n    \\t\\t}\\n    \\t    }\\n    \\t}\\n    }\\n    \\t\\n    return M;\\n}\\n```\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    Set<Character> set = new HashSet<>(s1.length());\\n\\n    for (char ch : s1.toCharArray()) set.add(ch);\\n\\n    for (char ch : s2.toCharArray()) {\\n    \\tif (!set.contains(ch)) return 0;\\n    }\\n    \\t\\n    int[][] arr = new int[s1.length()][2];\\n\\n    for (int i = 0; i < s1.length(); i++) {\\n        arr[i][0] = -1;\\n    }\\n    \\t\\n    int i = 0, j = 0, k = 0, c = 0, N1 = n1 * s1.length();\\n    \\t\\n    for (; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n    \\tif (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t    c++;\\n\\t    if (arr[j][0] >= 0) break;\\n\\t    arr[j][0] = i;\\n\\t    arr[j][1] = c;\\n\\t}\\n    }\\n    \\t\\n    if (i < N1) {\\n        int l = i - arr[j][0];\\n        int m = c - arr[j][1];\\n        int t = (N1 - arr[j][0] - 1) / l;\\n        c = arr[j][1] + m * t;\\n        i = arr[j][0] + l * t + 1;\\n        \\t\\n        for (j = i % s1.length(), k = 0; i < N1; i++, j = i % s1.length(), k %= s2.length()) {\\n            if (s1.charAt(j) == s2.charAt(k) && ++k == s2.length()) {\\n    \\t\\tc++;\\n    \\t    }\\n        }\\n    }\\n    \\t\\n    return c / n2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95403,
                "title": "a-15ms-java-solution-with-explanation-brute-force-memorization",
                "content": "I was enlightened by the @shawngao's brute force solution, the post can be found [here](https://discuss.leetcode.com/topic/70707/ugly-java-brute-force-solution-but-accepted-1088ms).\\n\\nThe basic idea is to repeat s1 in n1 times, and count how many s2 we can find. The answer number of s2  we can find divide by n2. \\n\\nTo accelerate the process, a map is used to find \"loop\".\\n\\nThe following is the code\\n\\nPoint[][] map is used for find loop.\\nint[] p1 and int[] p2 are the counters.\\n\\n```\\npublic class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        Point[][] map = new Point[len1][len2];\\n        int[] p1 = new int[2];\\n        int[] p2 = new int[2];\\n        while (p1[1] < n1) {\\n            char c = s2.charAt(p2[0]);\\n            while (p1[1] < n1 && s1.charAt(p1[0]) != c) {\\n                inc(p1, len1);\\n            }\\n            if (map[p1[0]][p2[0]] == null) {\\n                map[p1[0]][p2[0]] = new Point(p1[1], p2[1]);\\n            } else {\\n                int deltaP1 = p1[1] - map[p1[0]][p2[0]].x;\\n                int deltaP2 = p2[1] - map[p1[0]][p2[0]].y;\\n                int k = (n1 - deltaP1 - 1) / deltaP1;\\n                p1[1] += k * deltaP1;\\n                p2[1] += k * deltaP2;\\n            }\\n            inc(p1, len1);\\n            inc(p2, len2);\\n        }\\n        return p2[1] / n2;\\n    }\\n\\n    public void inc(int[] p, int len) {\\n        if (++ p[0] == len) {\\n            p[0] = 0;\\n            p[1] += 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        Point[][] map = new Point[len1][len2];\\n        int[] p1 = new int[2];\\n        int[] p2 = new int[2];\\n        while (p1[1] < n1) {\\n            char c = s2.charAt(p2[0]);\\n            while (p1[1] < n1 && s1.charAt(p1[0]) != c) {\\n                inc(p1, len1);\\n            }\\n            if (map[p1[0]][p2[0]] == null) {\\n                map[p1[0]][p2[0]] = new Point(p1[1], p2[1]);\\n            } else {\\n                int deltaP1 = p1[1] - map[p1[0]][p2[0]].x;\\n                int deltaP2 = p2[1] - map[p1[0]][p2[0]].y;\\n                int k = (n1 - deltaP1 - 1) / deltaP1;\\n                p1[1] += k * deltaP1;\\n                p2[1] += k * deltaP2;\\n            }\\n            inc(p1, len1);\\n            inc(p2, len2);\\n        }\\n        return p2[1] / n2;\\n    }\\n\\n    public void inc(int[] p, int len) {\\n        if (++ p[0] == len) {\\n            p[0] = 0;\\n            p[1] += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754336,
                "title": "precomputation-brute-force-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    count how many element from a given index of s2 match whole \\n    string of s1 that is for a single n1 , so we have to count \\n    all n1 and just increse index of s2 . and add max match len.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    count how many element from a given index of s2 match whole \\n    string of s1 that is for a single n1 , so we have to count \\n    all n1 and just increse index of s2 . and add max match len.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1=s1.size(),len2=s2.size();\\n        vector<int>inc(len2,0);\\n        for(int i=0;i<len2;i++){\\n            int ptr1=0,ptr2=i;\\n            while(ptr1<len1){\\n                if(s1[ptr1]==s2[ptr2%len2]){\\n                    ptr1++;\\n                    ptr2++;\\n                }\\n                else ptr1++;\\n            }\\n            inc[i]=ptr2-i;\\n        }\\n        int ptr=0,mx_match_len=0;\\n        for(int i=1;i<=n1;i++){\\n            mx_match_len+=inc[ptr];\\n            ptr+=inc[ptr];\\n            ptr%=len2;\\n        }\\n        return mx_match_len/(n2*len2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1=s1.size(),len2=s2.size();\\n        vector<int>inc(len2,0);\\n        for(int i=0;i<len2;i++){\\n            int ptr1=0,ptr2=i;\\n            while(ptr1<len1){\\n                if(s1[ptr1]==s2[ptr2%len2]){\\n                    ptr1++;\\n                    ptr2++;\\n                }\\n                else ptr1++;\\n            }\\n            inc[i]=ptr2-i;\\n        }\\n        int ptr=0,mx_match_len=0;\\n        for(int i=1;i<=n1;i++){\\n            mx_match_len+=inc[ptr];\\n            ptr+=inc[ptr];\\n            ptr%=len2;\\n        }\\n        return mx_match_len/(n2*len2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594109,
                "title": "bestest-solution-ever-in-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674639,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128061,
                "title": "c-solution-slow-but-easy-to-understand-find-lcm-of-both-the-strings-shorter-code",
                "content": "```\\nlong a=0,b=0;\\n    void lcm(string s1, long n1, string s2, long n2)\\n    {\\n        int i=0,j=0;\\n        bool pos=false;\\n        while(1)\\n        {\\n            while(i<s1.length() && j<s2.length() && a<n1)\\n            {\\n                if(i==0 && j==0 && pos)\\n                    return;\\n                pos=true;\\n                if(s1[i]==s2[j])\\n                    j++;\\n                if(j==s2.length())\\n                {\\n                    b++;\\n                    j=0;\\n                }\\n                i++;\\n                if(i==s1.length())\\n                {\\n                    a++;\\n                    i=0;\\n                }\\n            }\\n            if(a==n1)\\n                return;\\n        }\\n    }\\n    int getMaxRepetitions(string s1, long n1, string s2, long n2) {\\n        if(n1==0 || n2==0)\\n            return 0;\\n        lcm(s1,n1,s2,n2);\\n        return (long)(n1*b)/(long)(a*n2);\\n    }",
                "solutionTags": [],
                "code": "```\\nlong a=0,b=0;\\n    void lcm(string s1, long n1, string s2, long n2)\\n    {\\n        int i=0,j=0;\\n        bool pos=false;\\n        while(1)\\n        {\\n            while(i<s1.length() && j<s2.length() && a<n1)\\n            {\\n                if(i==0 && j==0 && pos)\\n                    return;\\n                pos=true;\\n                if(s1[i]==s2[j])\\n                    j++;\\n                if(j==s2.length())\\n                {\\n                    b++;\\n                    j=0;\\n                }\\n                i++;\\n                if(i==s1.length())\\n                {\\n                    a++;\\n                    i=0;\\n                }\\n            }\\n            if(a==n1)\\n                return;\\n        }\\n    }\\n    int getMaxRepetitions(string s1, long n1, string s2, long n2) {\\n        if(n1==0 || n2==0)\\n            return 0;\\n        lcm(s1,n1,s2,n2);\\n        return (long)(n1*b)/(long)(a*n2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 791499,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        if n1 == 0 {\\n            return 0;\\n        };\\n        let mut indices = vec![0; n1 as usize + 1];\\n        let mut counts = vec![0; n1 as usize + 1];\\n        let mut index = 0;\\n        let mut count = 0;\\n        for i in 1..=n1 as usize {\\n            for j in 0..s1.len() {\\n                if s1.as_bytes()[j] == s2.as_bytes()[index] {\\n                    index += 1;\\n                }\\n                if index == s2.len() {\\n                    index = 0;\\n                    count += 1;\\n                }\\n            }\\n            counts[i] = count;\\n            indices[i] = index;\\n            for k in 0..i {\\n                if indices[k] == index {\\n                    let pre_count = counts[k];\\n                    let pattern_count = (n1 - k as i32) / (i - k) as i32 * (counts[i] - pre_count);\\n                    let remain_count = counts[k + (n1 as usize - k) % (i - k)] - pre_count;\\n                    return (pre_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        counts[n1 as usize] / n2\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_get_max_repetitions() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"acb\".to_string(), 4, \"ab\".to_string(), 2),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_02() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"aaa\".to_string(), 20, \"aaaaa\".to_string(), 1),\\n            12\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_03() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"bacaba\".to_string(), 3, \"abacab\".to_string(), 1),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_04() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"ecbafedcba\".to_string(), 3, \"abcdef\".to_string(), 1),\\n            1\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        if n1 == 0 {\\n            return 0;\\n        };\\n        let mut indices = vec![0; n1 as usize + 1];\\n        let mut counts = vec![0; n1 as usize + 1];\\n        let mut index = 0;\\n        let mut count = 0;\\n        for i in 1..=n1 as usize {\\n            for j in 0..s1.len() {\\n                if s1.as_bytes()[j] == s2.as_bytes()[index] {\\n                    index += 1;\\n                }\\n                if index == s2.len() {\\n                    index = 0;\\n                    count += 1;\\n                }\\n            }\\n            counts[i] = count;\\n            indices[i] = index;\\n            for k in 0..i {\\n                if indices[k] == index {\\n                    let pre_count = counts[k];\\n                    let pattern_count = (n1 - k as i32) / (i - k) as i32 * (counts[i] - pre_count);\\n                    let remain_count = counts[k + (n1 as usize - k) % (i - k)] - pre_count;\\n                    return (pre_count + pattern_count + remain_count) / n2;\\n                }\\n            }\\n        }\\n        counts[n1 as usize] / n2\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_get_max_repetitions() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"acb\".to_string(), 4, \"ab\".to_string(), 2),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_02() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"aaa\".to_string(), 20, \"aaaaa\".to_string(), 1),\\n            12\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_03() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"bacaba\".to_string(), 3, \"abacab\".to_string(), 1),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_get_max_repetitions_04() {\\n        assert_eq!(\\n            Solution::get_max_repetitions(\"ecbafedcba\".to_string(), 3, \"abcdef\".to_string(), 1),\\n            1\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777733,
                "title": "java-1ms-100-time-55-4-space-only-array-used-in-detail-explaination-o-l-m",
                "content": "Key word: Regular, Cycle, Math;\\n\\nIdea: \\n\\nStep 1: As we should not brute force answer, we need to seperate it to a small problem, I did it wrong here in my first thought. I divided it to how many characters it need from s1 to form s2. This is trivial as after first round of choosing the character, the start of next round may not be start at the same character with same idx in s1.\\n\\nStep 2: Ok, we extend problem to how many s2 we can form when we endAt same character with same idx in s1, here is the cycle we want to find.\\neg. AAA and AA,\\n\\n1st Round: AA, we stop at idx 1 of s1 to collect s2(ie AA)\\n\\n2nd Round: AAA | A, we stop at idx 0 of second s1 to collect s2(A|A)\\n\\n3rd Round: AAA | AAA, we stop at idx 2 of second s1 to collect s2(AA)\\n\\n4th Round: AAA | AAA | AA, we stop at idx1 of third s1 to collect s2(AA)\\n\\n5th Round: There is not 5th round as we have already find a Cycle(1st and 4th round both stop at idx1) which means that \\n**every    3  +   3  +  2 = 8  characters we can collect 4 s2;**\\n\\t\\t    (AAA | AAA | AA)  \\n\\nso this is ideal scenario as we can start at first one. Generally, our first match might start at characters in s1 other than first one\\neg NBA and AB, it starts from second character. How about we refine our cycle length by deleting the header, so it will be\\n\\n1st Round: NB**A | NB**A, we stop at idx 1 of second s1 (A|NB) to collect BA \\n\\n2nd Round: NBA | NB**A | NB**A we stop at idx 1 of third s1 to collect s2(B|A), here is cycle, \\n\\nThe cycle length is 3 + 3 + 2 - 2 = 6;\\n(NBA | NBA | NBA | - NB)\\n\\nCool, we got length of cycle now, and we also know the total length of S1 is s1.length * n1, we can know how many cycles in S1, with the regular we got above, we can know in the cycles, how many s2 we can collect by #of Cycle * s2 per cycle\\n\\nWhat about remainning characters? They are capable to form s2 as well. Recall to how we find cycle, we defined in every round that how many s2 we can collect when we endAt specific idx. so we can get number of extra s2 that we collect from remaining characters;\\n\\nHere we go, we got total number of s2 we can collect from s1 by s2 in cycle + s2 in remaining characters.\\n\\nGiven repeating number n2 of s2, we can know how many s2 + s2 + ... + s2 we can get by total number of s2 / n2;\\n\\nConclusively, it will be **(# of s2 in cycle + # of s2 in remaining charaters) / n2**, by doing so, you can beat 100%, if not, ask Xfinity or Verizon for it. \\n\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n\\t\\t// for detecting cycle\\n        boolean[] endAt = new boolean[len1];\\n        char[] chs1 = s1.toCharArray(), chs2 = s2.toCharArray();\\n\\t\\t// how many s1 we use and how many s2 we collect when we endAt specific\\n        int[] nums1 = new int[len1], nums2 = new int[len1];\\n        \\n        int tltS1Len = len1 * n1;\\n        \\n        int startIdx = s1.indexOf(chs2[0]);\\n        if(startIdx == -1){\\n            return 0;\\n        }\\n        \\n        int s2n = 0, s1n = 0, curIdx = 0, prevIdx = -1;\\n        while(s1n * len1 + curIdx < tltS1Len){\\n            for(char c : chs2){\\n                curIdx = s1.indexOf(c, prevIdx + 1);\\n                \\n                if(curIdx == -1 && prevIdx == -1){\\n                    return 0;\\n                }\\n                prevIdx = curIdx;\\n                if(curIdx == -1){\\n                    ++s1n;\\n                    curIdx = s1.indexOf(c, prevIdx + 1);\\n                }\\n                prevIdx = curIdx;\\n            }\\n            // cycle found\\n            if(endAt[curIdx]){\\n                break;\\n            }\\n            \\n            prevIdx = curIdx;\\n            ++s2n;\\n            endAt[curIdx] = true;\\n            nums1[curIdx] = s1n;\\n            nums2[curIdx] = s2n; \\n        }\\n\\t\\t\\n        int cycleLen = (s1n - nums1[curIdx]) * len1;\\n        if(cycleLen == 0){\\n            return 0;\\n        }\\n        int nS2 = (tltS1Len - startIdx - 1) / cycleLen * s2n;\\n        int remain = (tltS1Len - startIdx - 1) % cycleLen;\\n        \\n        int extraNum = 0;\\n        for(int i = 0; i < len1; ++i){\\n            if(!endAt[i]){\\n                continue;\\n            }\\n            \\n            if(remain >= i + nums1[i] * len1){\\n                extraNum = Math.max(nums2[i], extraNum);\\n            }\\n        }\\n        \\n        return (nS2 + extraNum) / n2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n\\t\\t// for detecting cycle\\n        boolean[] endAt = new boolean[len1];\\n        char[] chs1 = s1.toCharArray(), chs2 = s2.toCharArray();\\n\\t\\t// how many s1 we use and how many s2 we collect when we endAt specific\\n        int[] nums1 = new int[len1], nums2 = new int[len1];\\n        \\n        int tltS1Len = len1 * n1;\\n        \\n        int startIdx = s1.indexOf(chs2[0]);\\n        if(startIdx == -1){\\n            return 0;\\n        }\\n        \\n        int s2n = 0, s1n = 0, curIdx = 0, prevIdx = -1;\\n        while(s1n * len1 + curIdx < tltS1Len){\\n            for(char c : chs2){\\n                curIdx = s1.indexOf(c, prevIdx + 1);\\n                \\n                if(curIdx == -1 && prevIdx == -1){\\n                    return 0;\\n                }\\n                prevIdx = curIdx;\\n                if(curIdx == -1){\\n                    ++s1n;\\n                    curIdx = s1.indexOf(c, prevIdx + 1);\\n                }\\n                prevIdx = curIdx;\\n            }\\n            // cycle found\\n            if(endAt[curIdx]){\\n                break;\\n            }\\n            \\n            prevIdx = curIdx;\\n            ++s2n;\\n            endAt[curIdx] = true;\\n            nums1[curIdx] = s1n;\\n            nums2[curIdx] = s2n; \\n        }\\n\\t\\t\\n        int cycleLen = (s1n - nums1[curIdx]) * len1;\\n        if(cycleLen == 0){\\n            return 0;\\n        }\\n        int nS2 = (tltS1Len - startIdx - 1) / cycleLen * s2n;\\n        int remain = (tltS1Len - startIdx - 1) % cycleLen;\\n        \\n        int extraNum = 0;\\n        for(int i = 0; i < len1; ++i){\\n            if(!endAt[i]){\\n                continue;\\n            }\\n            \\n            if(remain >= i + nums1[i] * len1){\\n                extraNum = Math.max(nums2[i], extraNum);\\n            }\\n        }\\n        \\n        return (nS2 + extraNum) / n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757668,
                "title": "java-while-loop-o-len-s1",
                "content": "Ref: https://leetcode.com/problems/count-the-repetitions/discuss/95401/Ugly-Java-brute-force-solution-but-accepted.-1088ms.\\n```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] a1 = s1.toCharArray(), a2 = s2.toCharArray();\\n        int l1 = a1.length, l2 = a2.length, c1 = 0, c2 = 0, i = 0, j = 0;\\n        while (c1 < n1) {\\n            if (a1[i] == a2[j]) {\\n                if (++j == l2) {\\n                    j = 0;\\n                    c2++;\\n                }\\n            }\\n            if (++i == l1) {\\n                i = 0;\\n                c1++;\\n            }\\n        }\\n        return c2 / n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] a1 = s1.toCharArray(), a2 = s2.toCharArray();\\n        int l1 = a1.length, l2 = a2.length, c1 = 0, c2 = 0, i = 0, j = 0;\\n        while (c1 < n1) {\\n            if (a1[i] == a2[j]) {\\n                if (++j == l2) {\\n                    j = 0;\\n                    c2++;\\n                }\\n            }\\n            if (++i == l1) {\\n                i = 0;\\n                c1++;\\n            }\\n        }\\n        return c2 / n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632449,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(s1==null || s2==null || s2.length()*n2 > s1.length()*n1) return 0;\\n        if(s2==\"\") return 0;\\n        \\n        int str2Index = 0;\\n        int count = 0;\\n        int k=0;\\n        while(k<n1)\\n        {\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(str2Index))\\n                    str2Index++;\\n                if(str2Index==(s2.length())){\\n                    str2Index=0;\\n                    count++;\\n                }\\n            }\\n            k++;\\n            if(str2Index==0)\\n            {\\n                if(n1%2==0 || n1 < 2)\\n                    count*=n1/k;\\n                else\\n                    count=(count*(n1-1)/k)+1;\\n                break;\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(s1==null || s2==null || s2.length()*n2 > s1.length()*n1) return 0;\\n        if(s2==\"\") return 0;\\n        \\n        int str2Index = 0;\\n        int count = 0;\\n        int k=0;\\n        while(k<n1)\\n        {\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(str2Index))\\n                    str2Index++;\\n                if(str2Index==(s2.length())){\\n                    str2Index=0;\\n                    count++;\\n                }\\n            }\\n            k++;\\n            if(str2Index==0)\\n            {\\n                if(n1%2==0 || n1 < 2)\\n                    count*=n1/k;\\n                else\\n                    count=(count*(n1-1)/k)+1;\\n                break;\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553058,
                "title": "python-binary-search-for-m-inverse-1-m",
                "content": "Most posts are using pattern-finding method, which is excellent and fast (~40 ms)\\nHere I provide a Binary Search solution, which is a bit slow(~380 ms) but pretty straightforward to understand.\\n\\nBasically, we are required to find biggest M, satisfying s2x(n2xM) is subsequence of s1xn1.\\nsuppose we find M=10, then we know that for M=9,8,7,6...the subsequence condition should also hold. Therefore, we could use Binary Search to find M.\\n\\nHowever, for most tranditional binary search pattern (lo=mid+1 & hi=mid), they are not directly useable for upper-bound-finding case like this problem. ```we need to convert upper-bound-finding problem to be a lower-bound-finding problem```. Thus, the solution is: \\nwe use Binary Search algorithm to find the ```lower-bound of 1/M```, which ``corresponds to upper-bound of M``.\\n\\nThe following is the explanation for function issubseq(s2, n2, s1, n1).\\ninitially, we count the number of s1 for ```matching single s2```, we call it ```s1_used```, usually there would be a half-used s1 for matching s2\\'s tail, which is between ```best case``` and ```worst case```.\\n\\nso the ```best case``` would be ```s1_used s1``` cover ```single s2```, and  ```n2*s1_used s1``` cover ```n2 s2```\\nthe ```worst case``` would be ```(s1_used+1) s1``` cover ```single s2```, and ```n2*(s1_used+1) s1``` cover ```n2 s2```.\\n\\nthus, if ```n1 <  n2*s1_used``` for best case, return ```False```.\\nif ```n1 >=  n2*(s1_used+1)``` for worst case, return ```True```.\\nfinally, the hard part is what if n1 is between best case and worst case?\\n\\nIn this situation, we will try to match another single s2 again from the end index of previous matching, until we meet the above two extreme conditions or ```there is no half-used s1 when a full s2-matching is done```.\\n\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        \\n        def divide_gcd(n1, n2):\\n            m, n = n1, n2\\n            while m % n:\\n                m, n = n, m % n\\n            return n1 // n, n2 // n\\n        \\n        def issubseq(s2, n2, s1, n1):  # return True/False s2*n2 is the subsequence of s1*n1\\n            s2_used = 0\\n            s1_used, s1_sidx = 0, 0\\n            while True:\\n                for ch in s2:\\n                    j = s1.find(ch, s1_sidx)\\n                    if j == -1:\\n                        s1_used += 1\\n                        j = s1.find(ch, 0)\\n                    s1_sidx = j + 1\\n                s2_used += 1\\n                if s1.find(s2[0], s1_sidx) == -1:\\n                    s1_used += 1\\n                    return s1_used * n2 <= s2_used * n1  # rewrite the original condition: s1_used / s2_used >= n2 / n1\\n                if s1_used * n2 >= s2_used * n1:\\n                    return False\\n                if s1_used * n2 + n2 <= s2_used * n1:\\n                    return True\\n        \\n        if not set(s2).issubset(set(s1)):\\n            return 0\\n        if len(s1) * n1 < len(s2) * n2:\\n            return 0\\n        \\n        n1, n2 = divide_gcd(n1, n2)\\n        lo, hi = (len(s2) * n2) / (len(s1) * n1), 10**5\\n        while lo + 1e-11 < hi:\\n            mid = (lo + hi) / 2\\n            if issubseq(s2, n2*(int(1/mid)+1), s1, n1):\\n                hi = mid\\n            else:\\n                lo = mid\\n        return int(1/lo)\\n```",
                "solutionTags": [],
                "code": "```we need to convert upper-bound-finding problem to be a lower-bound-finding problem```\n```lower-bound of 1/M```\n```matching single s2```\n```s1_used```\n```best case```\n```worst case```\n```best case```\n```s1_used s1```\n```single s2```\n```n2*s1_used s1```\n```n2 s2```\n```worst case```\n```(s1_used+1) s1```\n```single s2```\n```n2*(s1_used+1) s1```\n```n2 s2```\n```n1 <  n2*s1_used```\n```False```\n```n1 >=  n2*(s1_used+1)```\n```True```\n```there is no half-used s1 when a full s2-matching is done```\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        \\n        def divide_gcd(n1, n2):\\n            m, n = n1, n2\\n            while m % n:\\n                m, n = n, m % n\\n            return n1 // n, n2 // n\\n        \\n        def issubseq(s2, n2, s1, n1):  # return True/False s2*n2 is the subsequence of s1*n1\\n            s2_used = 0\\n            s1_used, s1_sidx = 0, 0\\n            while True:\\n                for ch in s2:\\n                    j = s1.find(ch, s1_sidx)\\n                    if j == -1:\\n                        s1_used += 1\\n                        j = s1.find(ch, 0)\\n                    s1_sidx = j + 1\\n                s2_used += 1\\n                if s1.find(s2[0], s1_sidx) == -1:\\n                    s1_used += 1\\n                    return s1_used * n2 <= s2_used * n1  # rewrite the original condition: s1_used / s2_used >= n2 / n1\\n                if s1_used * n2 >= s2_used * n1:\\n                    return False\\n                if s1_used * n2 + n2 <= s2_used * n1:\\n                    return True\\n        \\n        if not set(s2).issubset(set(s1)):\\n            return 0\\n        if len(s1) * n1 < len(s2) * n2:\\n            return 0\\n        \\n        n1, n2 = divide_gcd(n1, n2)\\n        lo, hi = (len(s2) * n2) / (len(s1) * n1), 10**5\\n        while lo + 1e-11 < hi:\\n            mid = (lo + hi) / 2\\n            if issubseq(s2, n2*(int(1/mid)+1), s1, n1):\\n                hi = mid\\n            else:\\n                lo = mid\\n        return int(1/lo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543506,
                "title": "python-solution-with-finding-a-cycle",
                "content": "The idea is to find the number of occurences of s2 in S1 and to find a cycle in s1.\\nHere is the code:\\n```\\ndef solve(s1, n1, s2, n2):\\n    s1l, s2l, S1L = len(s1), len(s2), len(s1) * n1\\n    # Maps from idx in s1 to \\n    #   (num characters from begin, num occurences of s2)\\n    numChars = { 0: (0, 0) } \\n    i, j = 0, 0\\n    s2Cnt = 0\\n    cntr = 10002\\n    while cntr and i < S1L:\\n        cntr -= 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if s2[idxj] == s1[idxi]:\\n            j += 1\\n            if j % s2l == 0: s2Cnt += 1\\n        i += 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if j and idxj == 0:\\n            if idxi not in numChars:\\n                # save the current idx of occurence of s2\\n                numChars[idxi] = (i, s2Cnt)\\n            else:\\n                # found a cycle\\n                charsInCycle, occurencesBefore = i - numChars[idxi][0], numChars[idxi][1]\\n                numberOfCycles = (S1L - i) // charsInCycle\\n                s2Cnt += (s2Cnt - occurencesBefore) * numberOfCycles\\n                i += numberOfCycles * charsInCycle\\n                # go till end normally\\n                while i < S1L:\\n                    if s1[i % s1l]==s2[j % s2l]:\\n                        j += 1\\n                        if j % s2l == 0:\\n                            s2Cnt += 1\\n                    i += 1\\n                return s2Cnt // n2\\n    return s2Cnt // n2\\n\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        return solve(s1,n1,s2,n2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef solve(s1, n1, s2, n2):\\n    s1l, s2l, S1L = len(s1), len(s2), len(s1) * n1\\n    # Maps from idx in s1 to \\n    #   (num characters from begin, num occurences of s2)\\n    numChars = { 0: (0, 0) } \\n    i, j = 0, 0\\n    s2Cnt = 0\\n    cntr = 10002\\n    while cntr and i < S1L:\\n        cntr -= 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if s2[idxj] == s1[idxi]:\\n            j += 1\\n            if j % s2l == 0: s2Cnt += 1\\n        i += 1\\n        idxi, idxj = i % s1l, j % s2l\\n        if j and idxj == 0:\\n            if idxi not in numChars:\\n                # save the current idx of occurence of s2\\n                numChars[idxi] = (i, s2Cnt)\\n            else:\\n                # found a cycle\\n                charsInCycle, occurencesBefore = i - numChars[idxi][0], numChars[idxi][1]\\n                numberOfCycles = (S1L - i) // charsInCycle\\n                s2Cnt += (s2Cnt - occurencesBefore) * numberOfCycles\\n                i += numberOfCycles * charsInCycle\\n                # go till end normally\\n                while i < S1L:\\n                    if s1[i % s1l]==s2[j % s2l]:\\n                        j += 1\\n                        if j % s2l == 0:\\n                            s2Cnt += 1\\n                    i += 1\\n                return s2Cnt // n2\\n    return s2Cnt // n2\\n\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        return solve(s1,n1,s2,n2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241512,
                "title": "o-m-n-python3-solution",
                "content": "\\nIn my code, the first function defined what \"contain\" is and the second function is to find maximum m.\\n\\nWe know that, in the best case:\\n    S1 = s1*n1\\n    S2 = s2*n2\\nWe compute the quotient of lengths of S1 and S2, which is M in the code and M is the best repetition we can get.\\nAnd count down from M, return the repetition as long as S1 contains S2.\\n\\nFor example:\\nif the length of S1 is 12, and S2\\'s length is 3, the largest (best) m could be 4, or less, \\nif 4*S2 can\\'t meet the condition, then let m be 3, and check again.\\nThis way, we only check 4 times at worst.\\n\\n```\\ndef Contain(L1,L2):\\n    for i in range(len(L2)):\\n        if L2[i] in L1:\\n            L1 = L1[L1.index(L2[i]):]\\n        else:\\n            return False\\n    return True\\n\\ndef getMaxRepetitions(s1,n1,s2,n2):\\n    S1 = s1*n1\\n    S2 = s2*n2\\n    M = int(len(S1)//len(S2))\\n    for m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n\\n\\n```\\n\\n ===================================================== 4/22/2019 Update =====================================================\\n\\nThanks to @luzi82 for pointing out my problem.\\nIn this part, if the range is from M to 1, it\\'ll exclude m=1\\n```\\nfor m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```\\nI changed it into:\\n```\\nfor m in range(M,0,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```\\nAnd it worked for the cases of 1 repetition.\\n\\nAnd as for the case:\\ns1=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\nn1=1000000\\nRunning time is up to 48s \\nThe main part slowing things down is the calculation: S1 = s1n1\\nWhen n1 is really large, this algorithm could be really slow.\\n\\nWhat\\'s sarcastic is that I used the title \\'fast solution\\' when I first posted this answer.\\nI\\'ll keep updated on this section with better solution. \\nAnd you\\'re very welcome to give me some feedback and to let me know how to improve the algorithm. \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef Contain(L1,L2):\\n    for i in range(len(L2)):\\n        if L2[i] in L1:\\n            L1 = L1[L1.index(L2[i]):]\\n        else:\\n            return False\\n    return True\\n\\ndef getMaxRepetitions(s1,n1,s2,n2):\\n    S1 = s1*n1\\n    S2 = s2*n2\\n    M = int(len(S1)//len(S2))\\n    for m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n\\n\\n```\n```\\nfor m in range(M,1,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```\n```\\nfor m in range(M,0,-1):\\n        if Contain(S1,S2*m):\\n            return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 178774,
                "title": "use-next-array-java-solution",
                "content": "```\\nclass Solution{\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        boolean c[] = new boolean[26];\\n        for (int k = 0; k < len1; k++) {\\n            c[s1.charAt(k) - \\'a\\'] = true;\\n        }\\n\\n        for (int k = 0; k < len2; k++) {\\n            if (!c[s2.charAt(k) - \\'a\\']) {\\n                return 0;\\n            }\\n        }\\n\\n\\n        int[] dp = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            dp[i] = findNextIndex(s1, s2, i);\\n        }\\n\\n        int []fast = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            int t = i;\\n            int step = 0;\\n            for (int j = 0; j < 1000; j++) {\\n                step += dp[t];\\n                t = t + dp[t];\\n                t %= len1;\\n            }\\n    \\n            fast[i] = step;\\n        }\\n\\n        int i = 0;\\n        int limit = len1 * n1;\\n        int sum = 0;\\n        while(i < limit) {\\n            if (dp[i%len1] < 0) break;\\n            int fastNext = i + fast[i%len1];\\n            if (fastNext <= limit) {\\n                i = fastNext;\\n                sum+=1000;\\n                continue;\\n            }\\n\\n            i = i + dp[i%len1];\\n            if (i <= limit)\\n            sum++;\\n           \\n        }\\n\\n        return sum/n2;\\n    }\\n\\n    private int findNextIndex(String s1, String s2, int i) {\\n        int j = 0;\\n        int step = 0;\\n        while(j < s2.length()) {\\n            if (s1.charAt(i) == s2.charAt(j)) {\\n                j++;\\n            }\\n\\n            i++;\\n            step++;\\n            i %= s1.length();\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        boolean c[] = new boolean[26];\\n        for (int k = 0; k < len1; k++) {\\n            c[s1.charAt(k) - \\'a\\'] = true;\\n        }\\n\\n        for (int k = 0; k < len2; k++) {\\n            if (!c[s2.charAt(k) - \\'a\\']) {\\n                return 0;\\n            }\\n        }\\n\\n\\n        int[] dp = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            dp[i] = findNextIndex(s1, s2, i);\\n        }\\n\\n        int []fast = new int[len1];\\n        for (int i = 0; i < len1; i++) {\\n            int t = i;\\n            int step = 0;\\n            for (int j = 0; j < 1000; j++) {\\n                step += dp[t];\\n                t = t + dp[t];\\n                t %= len1;\\n            }\\n    \\n            fast[i] = step;\\n        }\\n\\n        int i = 0;\\n        int limit = len1 * n1;\\n        int sum = 0;\\n        while(i < limit) {\\n            if (dp[i%len1] < 0) break;\\n            int fastNext = i + fast[i%len1];\\n            if (fastNext <= limit) {\\n                i = fastNext;\\n                sum+=1000;\\n                continue;\\n            }\\n\\n            i = i + dp[i%len1];\\n            if (i <= limit)\\n            sum++;\\n           \\n        }\\n\\n        return sum/n2;\\n    }\\n\\n    private int findNextIndex(String s1, String s2, int i) {\\n        int j = 0;\\n        int step = 0;\\n        while(j < s2.length()) {\\n            if (s1.charAt(i) == s2.charAt(j)) {\\n                j++;\\n            }\\n\\n            i++;\\n            step++;\\n            i %= s1.length();\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95395,
                "title": "nice-fast-ish-115ms-simple-bruteforce-java-complete-with-unit-test-that-s-right",
                "content": "Code should be self-explanatory\\n\\n```\\nimport org.junit.jupiter.api.Test;\\n\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class Solution {\\n\\n    private int countS2inS1(final char[] s1, final char[] s2) {\\n        int count = 0;\\n        int s2Pointer = 0;\\n\\n        for (final char c1 : s1) {\\n            if (c1 == s2[s2Pointer]) {\\n                s2Pointer++;\\n\\n                if (s2Pointer == s2.length) {\\n                    s2Pointer = 0;\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int getMaxRepetitions(final String s1, final int n1, final String s2, final int n2) {\\n        final Set<Character> s1Chars = new HashSet<>();\\n\\n        for (final char c1 : s1.toCharArray()) {\\n            s1Chars.add(c1);\\n        }\\n\\n        final Set<Character> s2Chars = new HashSet<>();\\n\\n        for (final char c2 : s2.toCharArray()) {\\n            s2Chars.add(c2);\\n        }\\n\\n        if (s1Chars.size() == 1 && s2Chars.size() == 1 && s1Chars.iterator().next() == s2Chars.iterator().next()) {\\n            return (s1.length() * n1) / (s2.length() * n2);\\n        }\\n\\n        final StringBuilder sb1 = new StringBuilder();\\n\\n        for (int i = 0; i < (n1 / n2); i++) {\\n            sb1.append(s1);\\n        }\\n\\n        if (sb1.length() == 0) {\\n            sb1.append(s1);\\n            return Math.max(0, countS2inS1(sb1.toString().toCharArray(), s2.toCharArray()) - 1);\\n        }\\n\\n        return countS2inS1(sb1.toString().toCharArray(), s2.toCharArray());\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(2, new Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2));\\n        assertEquals(4, new Solution().getMaxRepetitions(\"aaa\", 3, \"aa\", 1));\\n        assertEquals(7, new Solution().getMaxRepetitions(\"baba\", 11, \"baab\", 1));\\n        assertEquals(1, new Solution().getMaxRepetitions(\"adasfdgdftadwfwfereredsfssas\", 500, \"fw\", 555));\\n        assertEquals(100000000, new Solution().getMaxRepetitions(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1000000, \"a\", 1));\\n        assertEquals(200000, new Solution().getMaxRepetitions(\"aahumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenazkycxf\", 1000000, \"aac\", 10));\\n        assertEquals(0, new Solution().getMaxRepetitions(\"musicforever\", 10, \"lovelive\", 100000));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport org.junit.jupiter.api.Test;\\n\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nimport static org.junit.jupiter.api.Assertions.assertEquals;\\n\\npublic class Solution {\\n\\n    private int countS2inS1(final char[] s1, final char[] s2) {\\n        int count = 0;\\n        int s2Pointer = 0;\\n\\n        for (final char c1 : s1) {\\n            if (c1 == s2[s2Pointer]) {\\n                s2Pointer++;\\n\\n                if (s2Pointer == s2.length) {\\n                    s2Pointer = 0;\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public int getMaxRepetitions(final String s1, final int n1, final String s2, final int n2) {\\n        final Set<Character> s1Chars = new HashSet<>();\\n\\n        for (final char c1 : s1.toCharArray()) {\\n            s1Chars.add(c1);\\n        }\\n\\n        final Set<Character> s2Chars = new HashSet<>();\\n\\n        for (final char c2 : s2.toCharArray()) {\\n            s2Chars.add(c2);\\n        }\\n\\n        if (s1Chars.size() == 1 && s2Chars.size() == 1 && s1Chars.iterator().next() == s2Chars.iterator().next()) {\\n            return (s1.length() * n1) / (s2.length() * n2);\\n        }\\n\\n        final StringBuilder sb1 = new StringBuilder();\\n\\n        for (int i = 0; i < (n1 / n2); i++) {\\n            sb1.append(s1);\\n        }\\n\\n        if (sb1.length() == 0) {\\n            sb1.append(s1);\\n            return Math.max(0, countS2inS1(sb1.toString().toCharArray(), s2.toCharArray()) - 1);\\n        }\\n\\n        return countS2inS1(sb1.toString().toCharArray(), s2.toCharArray());\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(2, new Solution().getMaxRepetitions(\"acb\", 4, \"ab\", 2));\\n        assertEquals(4, new Solution().getMaxRepetitions(\"aaa\", 3, \"aa\", 1));\\n        assertEquals(7, new Solution().getMaxRepetitions(\"baba\", 11, \"baab\", 1));\\n        assertEquals(1, new Solution().getMaxRepetitions(\"adasfdgdftadwfwfereredsfssas\", 500, \"fw\", 555));\\n        assertEquals(100000000, new Solution().getMaxRepetitions(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1000000, \"a\", 1));\\n        assertEquals(200000, new Solution().getMaxRepetitions(\"aahumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikeffmznimkkasvwsrenazkycxf\", 1000000, \"aac\", 10));\\n        assertEquals(0, new Solution().getMaxRepetitions(\"musicforever\", 10, \"lovelive\", 100000));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95418,
                "title": "java-5ms-solution-with-examination-easy-to-understand",
                "content": "Based on aaaeeeo 's solution.\\nhttps://discuss.leetcode.com/topic/70887/very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea\\n```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s2 == null || n1 <= 0 || n2 <= 0) {\\n            return 0;\\n        }\\n        HashMap<Integer, Integer> posMap = new HashMap<Integer, Integer>(); // key: the rest position of s2  value:the number of s1\\n        int[] repTimes = new int[102]; // repTimes[i]: nummer of used s1 is i, repetitions times is repTimes[i]\\n        char[] chars1 = s1.toCharArray();\\n        char[] chars2 = s2.toCharArray();\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        int s1Num = 1;\\n        int posInS2 = 0;\\n        int times = 0;\\n        while (s1Num <= n1) {\\n            for (int j = 0; j < len1; j++) {\\n                if (chars1[j] == chars2[posInS2]) {\\n                    posInS2++;\\n                    if (posInS2 == len2) {\\n                        times++;\\n                        posInS2 = 0;\\n                    }\\n                }\\n            }\\n            repTimes[s1Num] = times;\\n            if (posMap.containsKey(posInS2)) {\\n                break;\\n            }\\n            posMap.put(posInS2, s1Num);\\n            s1Num++;\\n        }\\n        if (s1Num >= n1) {\\n            return times / n2;\\n        }\\n        int k = posMap.get(posInS2);\\n        int s1NumInLoop = s1Num - k; // s1 num in each loop\\n        int s2NumInLoop = repTimes[s1Num] - repTimes[k]; // s2 num in each loop\\n        int repeatCount = (n1 - k) / s1NumInLoop;\\n        int n = repeatCount * s2NumInLoop;\\n        n += repTimes[k + (n1 - k) % s1NumInLoop];\\n        return n / n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s2 == null || n1 <= 0 || n2 <= 0) {\\n            return 0;\\n        }\\n        HashMap<Integer, Integer> posMap = new HashMap<Integer, Integer>(); // key: the rest position of s2  value:the number of s1\\n        int[] repTimes = new int[102]; // repTimes[i]: nummer of used s1 is i, repetitions times is repTimes[i]\\n        char[] chars1 = s1.toCharArray();\\n        char[] chars2 = s2.toCharArray();\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        int s1Num = 1;\\n        int posInS2 = 0;\\n        int times = 0;\\n        while (s1Num <= n1) {\\n            for (int j = 0; j < len1; j++) {\\n                if (chars1[j] == chars2[posInS2]) {\\n                    posInS2++;\\n                    if (posInS2 == len2) {\\n                        times++;\\n                        posInS2 = 0;\\n                    }\\n                }\\n            }\\n            repTimes[s1Num] = times;\\n            if (posMap.containsKey(posInS2)) {\\n                break;\\n            }\\n            posMap.put(posInS2, s1Num);\\n            s1Num++;\\n        }\\n        if (s1Num >= n1) {\\n            return times / n2;\\n        }\\n        int k = posMap.get(posInS2);\\n        int s1NumInLoop = s1Num - k; // s1 num in each loop\\n        int s2NumInLoop = repTimes[s1Num] - repTimes[k]; // s2 num in each loop\\n        int repeatCount = (n1 - k) / s1NumInLoop;\\n        int n = repeatCount * s2NumInLoop;\\n        n += repTimes[k + (n1 - k) % s1NumInLoop];\\n        return n / n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95421,
                "title": "java-5-ms-solution-similar-idea-from-418-sentence-screen-fitting",
                "content": "The idea is similar with #418 sentence screen fitting, e.g. store the next index \\n1. At Prepare funciton, calculate for each idx in s1, the next idx for fitting exactly one s2, and how many s1 is needed\\n2. Find the Looping starting index of s1, which means:\\n         m s1 can fit n s2, always from idx to idx at s1, \\n         also need to know how many times we used s1 before reaching loop index,\\n         and how many times we get s2 before reaching loop index\\n3. Using those parameters we can calculate overall how many times we can get s2 from n1 s1\\n```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\tif (s1.length()*n1 < s2.length()*n2) return 0;\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        for (char c: ss2) {\\n        \\tif (!s1.contains(c+\"\")) return 0;\\n        }\\n        int[] s1NextIdx = new int[ss1.length];\\n        int[] s1Costs = new int[ss1.length];\\n        prepare(ss1, ss2, s1NextIdx, s1Costs);\\n        int s1used = 0;\\n        int s1Idx = 0;\\n        int s2Count = 0;\\n        boolean[] used = new boolean[ss1.length];\\n        while (!used[s1Idx] && (s1used+s1Costs[s1Idx] <= n1)) {\\n            used[s1Idx] = true;\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        if (s1used+s1Costs[s1Idx] > n1) return s2Count/n2;\\n        if (s1Idx == 0 && n1%s1used == 0) {\\n        \\treturn s2Count*n1/s1used/n2;\\n        }\\n        int startIdx = 0;\\n        int preS2Count = 0;\\n        int preS1Used = 0;\\n        \\n        while (startIdx != s1Idx) {\\n            s1used -= s1Costs[startIdx];\\n            preS1Used += s1Costs[startIdx];\\n            startIdx = s1NextIdx[startIdx];\\n            s2Count--;\\n            preS2Count++;\\n        }\\n        if (preS2Count > 0) preS1Used++;\\n        int times = (n1-preS1Used)/s1used;\\n        s2Count = s2Count*times + preS2Count;\\n        s1used = preS1Used + times*s1used;\\n        //calcualting the tail part\\n        while (s1used+s1Costs[s1Idx] <= n1) {\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        return s2Count/n2;\\n    }\\n    private void prepare(char[] s1, char[] s2, int[] s1NextIdx, int[] s1Cost) {\\n        boolean[] used = new boolean[s1.length];\\n        int idx = 0;\\n        while (!used[idx]) {\\n            used[idx] = true;\\n            int curr = idx;\\n            int count = 0;\\n            int s2idx = 0;\\n            while (s2idx < s2.length) {\\n                if (s1[curr++] == s2[s2idx]) {\\n                    s2idx++;\\n                }\\n                if (curr >= s1.length) {\\n                    curr = 0;\\n                    count++;\\n                }\\n            }\\n            s1Cost[idx] = count;\\n            s1NextIdx[idx] = curr;\\n            idx = curr;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\tif (s1.length()*n1 < s2.length()*n2) return 0;\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        for (char c: ss2) {\\n        \\tif (!s1.contains(c+\"\")) return 0;\\n        }\\n        int[] s1NextIdx = new int[ss1.length];\\n        int[] s1Costs = new int[ss1.length];\\n        prepare(ss1, ss2, s1NextIdx, s1Costs);\\n        int s1used = 0;\\n        int s1Idx = 0;\\n        int s2Count = 0;\\n        boolean[] used = new boolean[ss1.length];\\n        while (!used[s1Idx] && (s1used+s1Costs[s1Idx] <= n1)) {\\n            used[s1Idx] = true;\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        if (s1used+s1Costs[s1Idx] > n1) return s2Count/n2;\\n        if (s1Idx == 0 && n1%s1used == 0) {\\n        \\treturn s2Count*n1/s1used/n2;\\n        }\\n        int startIdx = 0;\\n        int preS2Count = 0;\\n        int preS1Used = 0;\\n        \\n        while (startIdx != s1Idx) {\\n            s1used -= s1Costs[startIdx];\\n            preS1Used += s1Costs[startIdx];\\n            startIdx = s1NextIdx[startIdx];\\n            s2Count--;\\n            preS2Count++;\\n        }\\n        if (preS2Count > 0) preS1Used++;\\n        int times = (n1-preS1Used)/s1used;\\n        s2Count = s2Count*times + preS2Count;\\n        s1used = preS1Used + times*s1used;\\n        //calcualting the tail part\\n        while (s1used+s1Costs[s1Idx] <= n1) {\\n            s1used += s1Costs[s1Idx];\\n            s1Idx = s1NextIdx[s1Idx];\\n            s2Count++;\\n        }\\n        return s2Count/n2;\\n    }\\n    private void prepare(char[] s1, char[] s2, int[] s1NextIdx, int[] s1Cost) {\\n        boolean[] used = new boolean[s1.length];\\n        int idx = 0;\\n        while (!used[idx]) {\\n            used[idx] = true;\\n            int curr = idx;\\n            int count = 0;\\n            int s2idx = 0;\\n            while (s2idx < s2.length) {\\n                if (s1[curr++] == s2[s2idx]) {\\n                    s2idx++;\\n                }\\n                if (curr >= s1.length) {\\n                    curr = 0;\\n                    count++;\\n                }\\n            }\\n            s1Cost[idx] = count;\\n            s1NextIdx[idx] = curr;\\n            idx = curr;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95432,
                "title": "share-my-python-solution-detailed-thought-while-not-elegant",
                "content": "```python\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        # First, try to find s2 inside s1\\n        \\n        L1 = len(s1)\\n        L2 = len(s2)\\n        i = 0\\n        j = 0\\n        count = 0\\n        while i < L1:\\n            \\n            if s1[i] == s2[j]:\\n                j += 1\\n                if j == L2:\\n                    count += 1\\n                    j = 0\\n            \\n            i += 1\\n            \\n        # cannot find any single character of s2\\n        if count == 0 and j == 0:\\n            return 0\\n            \\n        # s1 contains at least one s2\\n        # concat two s1, we may find one more s2\\n        if count > 0:\\n            tmp = count\\n            i = 0\\n            while i < L1:\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == L2:\\n                        count += 1\\n                        j = 0\\n            \\n                i += 1\\n        \\n\\t    # no more s2 after concat\\n            if tmp * 2 == count:\\n                return tmp * n1 / n2\\n            # we do have one more s2 after concat\\n            else:\\n                return (tmp * n1 + n1 - 1) / n2 if n1 > 0 else 0\\n                \\n        # Here count == 0, j != 0, means only part of s2 is found inside s1, in other words, we got a \"dirty tail\"\\n        # concat more s1 until we find a complete s2, and keep finding new s2, until the \"dirty tail\" is gone or remains the same, which means we finally find the pattern\\n        \\n        tmp = -1\\n        accArr = []\\n        acc = 1\\n        while j != 0 and j != tmp:\\n            tmp = j\\n \\n            s1Num = 0\\n            findS2 = False\\n            while not findS2:\\n                s1Num += 1\\n                i = 0\\n                hit = False\\n                while i < L1:\\n                    if s1[i] == s2[j]:\\n                        hit = True\\n                        j += 1\\n                        if j == L2:\\n                            findS2 = True\\n                            count += 1\\n                            j = 0\\n                \\n                    i += 1\\n                    \\n                if not hit: # cannot find necessary characters\\n                    return 0\\n                    \\n            accArr.append(acc + s1Num) # accArr[i] = how many s1 are checked when we find i th complete s2\\n            acc += s1Num\\n            if acc > n1:\\n                return (count - 1) / n2\\n            \\n        # pattern found!\\n    \\n        if j == 0:\\n            # (acc) number of s1 = (count) number of s2\\n            S = n1 / acc * count\\n            r = n1 % acc\\n\\n            for num in accArr:\\n                if num <= r:\\n                    S += 1\\n                else:\\n                    break\\n\\n            return S / n2\\n            \\n        if j == tmp:\\n            # (acc) number of s1 = (count) number of s2\\uff0cnow every new (s1Num) number of s1, gives us a new s2\\n            return ( (n1 - acc) / s1Num + count) / n2\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        # First, try to find s2 inside s1\\n        \\n        L1 = len(s1)\\n        L2 = len(s2)\\n        i = 0\\n        j = 0\\n        count = 0\\n        while i < L1:\\n            \\n            if s1[i] == s2[j]:\\n                j += 1\\n                if j == L2:\\n                    count += 1\\n                    j = 0\\n            \\n            i += 1\\n            \\n        # cannot find any single character of s2\\n        if count == 0 and j == 0:\\n            return 0\\n            \\n        # s1 contains at least one s2\\n        # concat two s1, we may find one more s2\\n        if count > 0:\\n            tmp = count\\n            i = 0\\n            while i < L1:\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == L2:\\n                        count += 1\\n                        j = 0\\n            \\n                i += 1\\n        \\n\\t    # no more s2 after concat\\n            if tmp * 2 == count:\\n                return tmp * n1 / n2\\n            # we do have one more s2 after concat\\n            else:\\n                return (tmp * n1 + n1 - 1) / n2 if n1 > 0 else 0\\n                \\n        # Here count == 0, j != 0, means only part of s2 is found inside s1, in other words, we got a \"dirty tail\"\\n        # concat more s1 until we find a complete s2, and keep finding new s2, until the \"dirty tail\" is gone or remains the same, which means we finally find the pattern\\n        \\n        tmp = -1\\n        accArr = []\\n        acc = 1\\n        while j != 0 and j != tmp:\\n            tmp = j\\n \\n            s1Num = 0\\n            findS2 = False\\n            while not findS2:\\n                s1Num += 1\\n                i = 0\\n                hit = False\\n                while i < L1:\\n                    if s1[i] == s2[j]:\\n                        hit = True\\n                        j += 1\\n                        if j == L2:\\n                            findS2 = True\\n                            count += 1\\n                            j = 0\\n                \\n                    i += 1\\n                    \\n                if not hit: # cannot find necessary characters\\n                    return 0\\n                    \\n            accArr.append(acc + s1Num) # accArr[i] = how many s1 are checked when we find i th complete s2\\n            acc += s1Num\\n            if acc > n1:\\n                return (count - 1) / n2\\n            \\n        # pattern found!\\n    \\n        if j == 0:\\n            # (acc) number of s1 = (count) number of s2\\n            S = n1 / acc * count\\n            r = n1 % acc\\n\\n            for num in accArr:\\n                if num <= r:\\n                    S += 1\\n                else:\\n                    break\\n\\n            return S / n2\\n            \\n        if j == tmp:\\n            # (acc) number of s1 = (count) number of s2\\uff0cnow every new (s1Num) number of s1, gives us a new s2\\n            return ( (n1 - acc) / s1Num + count) / n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95436,
                "title": "java-solution",
                "content": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint count = 0;\\n\\t\\tString primary = \"\";\\n\\t\\tString secondary = \"\" ;\\n\\t\\tif(s1.length()*n1 < s2.length()*n2) {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1.contains(s2)){\\n\\t\\t\\tchar[] primArr = s1.toCharArray();\\n\\t\\t\\tchar[] secArr = s2.toCharArray();\\n\\t\\t\\tint j =0;\\n\\t\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount = n1* count/n2;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1 == s2) {\\n\\t\\t\\tcount = (n1/n2);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tfor(int i=1;i <= n1; i++) {\\n\\t\\t\\tprimary += s1;\\n\\t\\t}\\n\\t\\tfor(int i=1; i<=n2; i++) {\\n\\t\\t\\tsecondary += s2;\\n\\t\\t}\\n\\t\\tchar[] primArr = primary.toCharArray();\\n\\t\\tchar[] secArr = secondary.toCharArray();\\n\\t\\tint j = 0;\\n\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n\\t\\tint count = 0;\\n\\t\\tString primary = \"\";\\n\\t\\tString secondary = \"\" ;\\n\\t\\tif(s1.length()*n1 < s2.length()*n2) {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1.contains(s2)){\\n\\t\\t\\tchar[] primArr = s1.toCharArray();\\n\\t\\t\\tchar[] secArr = s2.toCharArray();\\n\\t\\t\\tint j =0;\\n\\t\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcount = n1* count/n2;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tif(s1 == s2) {\\n\\t\\t\\tcount = (n1/n2);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tfor(int i=1;i <= n1; i++) {\\n\\t\\t\\tprimary += s1;\\n\\t\\t}\\n\\t\\tfor(int i=1; i<=n2; i++) {\\n\\t\\t\\tsecondary += s2;\\n\\t\\t}\\n\\t\\tchar[] primArr = primary.toCharArray();\\n\\t\\tchar[] secArr = secondary.toCharArray();\\n\\t\\tint j = 0;\\n\\t\\tfor(int i=0; i< primArr.length && j<secArr.length; i++) {\\n\\t\\t\\tif(primArr[i] == secArr[j]) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif(j == secArr.length) {\\n\\t\\t\\t\\tcount +=1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016217,
                "title": "count-the-repetitions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    const len1 = s1.length;\\n    const len2 = s2.length; \\n    let count1 = 0; // Number of times s2 can be formed from s1\\n    let count2 = 0; // Number of times str2 = [s2, count2] can be formed from str1 = [s1, count1]\\n    let i = 0; // Pointer for s1\\n    let j = 0; // Pointer for s2\\n    while (count1 < n1) {\\n        if (s1[i] === s2[j]) {\\n            j++;\\n            if (j === len2) {\\n                j = 0;\\n                count2++;\\n            }\\n        }\\n        i++;\\n        if (i === len1) {\\n            i = 0;\\n            count1++;\\n        }\\n    }\\n    return Math.floor(count2 / n2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    const len1 = s1.length;\\n    const len2 = s2.length; \\n    let count1 = 0; // Number of times s2 can be formed from s1\\n    let count2 = 0; // Number of times str2 = [s2, count2] can be formed from str1 = [s1, count1]\\n    let i = 0; // Pointer for s1\\n    let j = 0; // Pointer for s2\\n    while (count1 < n1) {\\n        if (s1[i] === s2[j]) {\\n            j++;\\n            if (j === len2) {\\n                j = 0;\\n                count2++;\\n            }\\n        }\\n        i++;\\n        if (i === len1) {\\n            i = 0;\\n            count1++;\\n        }\\n    }\\n    return Math.floor(count2 / n2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846895,
                "title": "c-brute-force-approach-with-slight-time-optimization-slow-but-it-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe cannot actually store (s1 * n1) and (s2 * n2) due to memory constraints. Therefore we need to make n1 loops over s1, and for every n2 matches of s2 that we can find we increment count by 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n1 * s1.Length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int count = 0, ind = 0, loops = 0;\\n        for (int i = 0; i < n1; i++){\\n            for (int k = 0; k < s1.Length; k++){\\n                if (s1[k] == s2[ind]) ind++;\\n                if (ind == s2.Length){\\n                    ind = 0;\\n                    loops++;\\n                }\\n                if (loops == n2){\\n                    loops = 0;\\n                    count++;\\n                }\\n            }\\n            if (ind == 0 && loops == 0){\\n                int add = count;\\n                int times = i + 1;\\n                while (i + times < n1){\\n                    i += times;\\n                    count += add;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int count = 0, ind = 0, loops = 0;\\n        for (int i = 0; i < n1; i++){\\n            for (int k = 0; k < s1.Length; k++){\\n                if (s1[k] == s2[ind]) ind++;\\n                if (ind == s2.Length){\\n                    ind = 0;\\n                    loops++;\\n                }\\n                if (loops == n2){\\n                    loops = 0;\\n                    count++;\\n                }\\n            }\\n            if (ind == 0 && loops == 0){\\n                int add = count;\\n                int times = i + 1;\\n                while (i + times < n1){\\n                    i += times;\\n                    count += add;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827802,
                "title": "java-solution-4ms-runtime-with-brief-explanation",
                "content": "# Explanation\\n\\n. For each repetition of s1, count the number of times we see s2\\n. Store the seen count for each repetition of s1\\n. Store the index of s2 where we stopped after each repetition of s1\\n. For each repetition of s1, check if we\\'ve seen this index of s2 before\\n. If we have, then we\\'ve found a repeating pattern\\n. The number of times we see s2 in the pattern is (count[k] - count[start])\\n. The number of times we see s2 outside the pattern is (count[start + (n1 - start) % (k - start)] - count[start])\\n. The number of times we see s2 in total is (prefixCount + patternCount + suffixCount)\\n. The number of times we see s2 in total divided by n2 is the answer\\n\\n# Code\\n```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```\\n```C++[]\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\\n```python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int[] next = new int[s2.length() + 1];\\n        int[] count = new int[s2.length() + 1];\\n        int j = 0, cnt = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < s1.length(); i++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    j++;\\n                    if (j == s2.length()) {\\n                        j = 0;\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            count[k] = cnt;\\n            next[k] = j;\\n            for (int start = 0; start < k; start++) {\\n                if (next[start] == j) {\\n                    int prefixCount = count[start];\\n                    int patternCount = (count[k] - count[start]) * ((n1 - start) / (k - start));\\n                    int suffixCount = count[start + (n1 - start) % (k - start)] - count[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n        return count[n1] / n2;\\n    }\\n}\\n```\n```C++[]\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```\n```python3 []\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        start = {}\\n        s1_round, s2_round, s2_idx = 0, 0, 0\\n        while s1_round < n1:\\n            s1_round += 1\\n            for ch in s1:\\n                if ch == s2[s2_idx]:\\n                    s2_idx += 1\\n                    if s2_idx == len(s2):\\n                        s2_round += 1\\n                        s2_idx = 0\\n            if s2_idx in start:\\n                prev_s1_round, prev_s2_round = start[s2_idx]\\n                circle_s1_round, circle_s2_round = s1_round - prev_s1_round, s2_round - prev_s2_round\\n                res = (n1 - prev_s1_round)\\n                left_s1_round = (n1 - prev_s1_round) % circle_s1_round + prev_s1_round\\n                for key in start:\\n                    val = start[key]\\n                    if val[0] == left_s1_round:\\n                        res += val[1]\\n                        break\\n                return res \\n            else:\\n                start[s2_idx] = (s1_round, s2_round)\\n        return s2_round\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749178,
                "title": "100-using-2-vectors-easy-implementation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n        vector<int> repeatCount(len2 + 1, 0);\\n        vector<int> nextIndex(len2 + 1, 0);\\n\\n        int count1 = 0, count2 = 0, j = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < len1; i++) {\\n                if (s1[i] == s2[j]) {\\n                    j++;\\n                    if (j == len2) {\\n                        j = 0;\\n                        count2++;\\n                    }\\n                }\\n            }\\n            count1++;\\n\\n            // Check for repetition pattern\\n            repeatCount[k] = count2;\\n            nextIndex[k] = j;\\n\\n            for (int start = 0; start < k; start++) {\\n                if (nextIndex[start] == j) {\\n                    int prefixCount = repeatCount[start];\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - repeatCount[start]);\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - repeatCount[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n\\n        return count2 / n2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.length(), len2 = s2.length();\\n        vector<int> repeatCount(len2 + 1, 0);\\n        vector<int> nextIndex(len2 + 1, 0);\\n\\n        int count1 = 0, count2 = 0, j = 0;\\n        for (int k = 1; k <= n1; k++) {\\n            for (int i = 0; i < len1; i++) {\\n                if (s1[i] == s2[j]) {\\n                    j++;\\n                    if (j == len2) {\\n                        j = 0;\\n                        count2++;\\n                    }\\n                }\\n            }\\n            count1++;\\n\\n            // Check for repetition pattern\\n            repeatCount[k] = count2;\\n            nextIndex[k] = j;\\n\\n            for (int start = 0; start < k; start++) {\\n                if (nextIndex[start] == j) {\\n                    int prefixCount = repeatCount[start];\\n                    int patternCount = (n1 - start) / (k - start) * (repeatCount[k] - repeatCount[start]);\\n                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - repeatCount[start];\\n                    return (prefixCount + patternCount + suffixCount) / n2;\\n                }\\n            }\\n        }\\n\\n        return count2 / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748231,
                "title": "easy-o-n1-ns2-ns2-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEntire Thought process in the comments.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n1 + ns2*ns2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(ns2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // dp[i] = no of new blocks of s1 required to construct 1 block of str2 starting from s1[i]\\n        // next[i] = index of s1 obtained after constructing 1 block of str2 using dp[i] blocks\\n        // int blocks = 0, ind = 0, m = 0;\\n        // while (blocks + dp[ind] <= n) {\\n            // blocks += dp[ind];\\n            // ind = next[ind];\\n            // m++;\\n        // }\\n        //  return m;\\n        // TLE (10^ 6 * 100)\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if str2 started at str2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2 * n2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // but dp will have a size of ns2 (10 ^ 6 * 100)\\n        // TLE , MLE\\n        // can we reduce this size by leveraging periodicity of str2\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if s2 started at s2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // brute force dp (100 * 100);\\n        // for (int ind = 0; ind < ns2; ind++) {\\n        //     int l1 = 0, l2 = ind, cnt = 0;\\n        //     while (l1 < ns1) {\\n        //         if (s1[l1] == s2[l2]) {\\n        //             l2++;\\n        //             l2 %= ns2;\\n        //             cnt++;\\n        //         }\\n        //         l1++;\\n        //     }\\n        //     dp[ind] = cnt;\\n        // }\\n        int ns1 = s1.size(), ns2 = s2.size();\\n        vector<int> dp(ns2, 0);\\n        for (int ind = 0; ind < ns2; ind++) {\\n            int l1 = 0, l2 = ind, cnt = 0;\\n            while (l1 < ns1) {\\n                if (s1[l1] == s2[l2]) {\\n                    l2++;\\n                    l2 %= ns2;\\n                    cnt++;\\n                }\\n                l1++;\\n            }\\n            dp[ind] = cnt;\\n        }\\n        int cnt = 0;\\n        for (int i = 0, ind = 0; i < n1; i++) {\\n            cnt += dp[ind];\\n            ind = (ind + dp[ind]) % ns2;\\n        }\\n        return cnt / ns2 / n2 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // dp[i] = no of new blocks of s1 required to construct 1 block of str2 starting from s1[i]\\n        // next[i] = index of s1 obtained after constructing 1 block of str2 using dp[i] blocks\\n        // int blocks = 0, ind = 0, m = 0;\\n        // while (blocks + dp[ind] <= n) {\\n            // blocks += dp[ind];\\n            // ind = next[ind];\\n            // m++;\\n        // }\\n        //  return m;\\n        // TLE (10^ 6 * 100)\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if str2 started at str2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2 * n2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // but dp will have a size of ns2 (10 ^ 6 * 100)\\n        // TLE , MLE\\n        // can we reduce this size by leveraging periodicity of str2\\n        // revision\\n        // dp[i] = no of characters of str2 satisfied for 1 block of s1 if s2 started at s2[i]\\n        // int ns2 = s2.size();\\n        // for (int i = 0, ind = 0, cnt = 0; i < n; i++) {\\n        //     cnt += dp[ind];\\n        //     ind = (ind + dp[ind]) % ns2;\\n        // }\\n        // return cnt / ns2 / n2 ;\\n        // brute force dp (100 * 100);\\n        // for (int ind = 0; ind < ns2; ind++) {\\n        //     int l1 = 0, l2 = ind, cnt = 0;\\n        //     while (l1 < ns1) {\\n        //         if (s1[l1] == s2[l2]) {\\n        //             l2++;\\n        //             l2 %= ns2;\\n        //             cnt++;\\n        //         }\\n        //         l1++;\\n        //     }\\n        //     dp[ind] = cnt;\\n        // }\\n        int ns1 = s1.size(), ns2 = s2.size();\\n        vector<int> dp(ns2, 0);\\n        for (int ind = 0; ind < ns2; ind++) {\\n            int l1 = 0, l2 = ind, cnt = 0;\\n            while (l1 < ns1) {\\n                if (s1[l1] == s2[l2]) {\\n                    l2++;\\n                    l2 %= ns2;\\n                    cnt++;\\n                }\\n                l1++;\\n            }\\n            dp[ind] = cnt;\\n        }\\n        int cnt = 0;\\n        for (int i = 0, ind = 0; i < n1; i++) {\\n            cnt += dp[ind];\\n            ind = (ind + dp[ind]) % ns2;\\n        }\\n        return cnt / ns2 / n2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727400,
                "title": "100-beat-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667172,
                "title": "39-13-faster",
                "content": "\\n\\n# Code\\n```\\nclass Record{\\n    int count;\\n    int nextIndex;\\n\\n    public Record(int count, int nextIndex){\\n        this.count = count;\\n        this.nextIndex = nextIndex;\\n    }\\n}\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        \\n        List<Record> records = new ArrayList();\\n\\n        this.load(s1, s2, records);\\n\\n        int index = 0, match = 0;\\n\\n        while(n1>0){\\n            match+=records.get(index).count;\\n            index = records.get(index).nextIndex;\\n            n1--;\\n        }\\n\\n        return match/n2;\\n\\n    }\\n\\n    void load(String s1, String s2, List<Record> records){\\n\\n        for(int i=0; i<s2.length(); i++){\\n            int nextIndex = i;\\n            int count = 0;\\n\\n            for(int j=0; j<s1.length(); j++){\\n\\n                if(s2.charAt(nextIndex)==s1.charAt(j)) nextIndex++;\\n\\n                if(nextIndex==s2.length()){\\n                    count++;\\n                    nextIndex = 0;\\n                }\\n\\n            }\\n            records.add(new Record(count, nextIndex));\\n        }\\n\\n\\n\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Record{\\n    int count;\\n    int nextIndex;\\n\\n    public Record(int count, int nextIndex){\\n        this.count = count;\\n        this.nextIndex = nextIndex;\\n    }\\n}\\n\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        \\n        List<Record> records = new ArrayList();\\n\\n        this.load(s1, s2, records);\\n\\n        int index = 0, match = 0;\\n\\n        while(n1>0){\\n            match+=records.get(index).count;\\n            index = records.get(index).nextIndex;\\n            n1--;\\n        }\\n\\n        return match/n2;\\n\\n    }\\n\\n    void load(String s1, String s2, List<Record> records){\\n\\n        for(int i=0; i<s2.length(); i++){\\n            int nextIndex = i;\\n            int count = 0;\\n\\n            for(int j=0; j<s1.length(); j++){\\n\\n                if(s2.charAt(nextIndex)==s1.charAt(j)) nextIndex++;\\n\\n                if(nextIndex==s2.length()){\\n                    count++;\\n                    nextIndex = 0;\\n                }\\n\\n            }\\n            records.add(new Record(count, nextIndex));\\n        }\\n\\n\\n\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591093,
                "title": "geez-mad-coz-bad",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if n1 == 0:\\n            return 0\\n\\n        # Count the number of occurrences of s2 in each repetition of s1\\n        repeat_count = {}  # Map of count2: (count1, next_index)\\n        count1, count2 = 0, 0\\n        next_index = 0\\n\\n        while count1 < n1:\\n            for i in range(len(s1)):\\n                if s1[i] == s2[next_index]:\\n                    next_index += 1\\n                    if next_index == len(s2):\\n                        next_index = 0\\n                        count2 += 1\\n\\n            count1 += 1\\n\\n            if next_index in repeat_count:\\n                # Found a repeating pattern\\n                prev_count1, prev_count2 = repeat_count[next_index]\\n                pattern_count1 = count1 - prev_count1\\n                pattern_count2 = count2 - prev_count2\\n                pattern_repetitions = (n1 - prev_count1) // pattern_count1\\n                remaining_count1 = (n1 - prev_count1) % pattern_count1\\n\\n                count2 = prev_count2 + pattern_count2 * pattern_repetitions\\n                count1 = prev_count1 + pattern_count1 * pattern_repetitions\\n\\n                # Calculate remaining occurrences within the partial pattern\\n                for _ in range(remaining_count1):\\n                    for char in s1:\\n                        if char == s2[next_index]:\\n                            next_index += 1\\n                            if next_index == len(s2):\\n                                next_index = 0\\n                                count2 += 1\\n\\n                break\\n            else:\\n                repeat_count[next_index] = (count1, count2)\\n\\n        return count2 // n2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if n1 == 0:\\n            return 0\\n\\n        # Count the number of occurrences of s2 in each repetition of s1\\n        repeat_count = {}  # Map of count2: (count1, next_index)\\n        count1, count2 = 0, 0\\n        next_index = 0\\n\\n        while count1 < n1:\\n            for i in range(len(s1)):\\n                if s1[i] == s2[next_index]:\\n                    next_index += 1\\n                    if next_index == len(s2):\\n                        next_index = 0\\n                        count2 += 1\\n\\n            count1 += 1\\n\\n            if next_index in repeat_count:\\n                # Found a repeating pattern\\n                prev_count1, prev_count2 = repeat_count[next_index]\\n                pattern_count1 = count1 - prev_count1\\n                pattern_count2 = count2 - prev_count2\\n                pattern_repetitions = (n1 - prev_count1) // pattern_count1\\n                remaining_count1 = (n1 - prev_count1) % pattern_count1\\n\\n                count2 = prev_count2 + pattern_count2 * pattern_repetitions\\n                count1 = prev_count1 + pattern_count1 * pattern_repetitions\\n\\n                # Calculate remaining occurrences within the partial pattern\\n                for _ in range(remaining_count1):\\n                    for char in s1:\\n                        if char == s2[next_index]:\\n                            next_index += 1\\n                            if next_index == len(s2):\\n                                next_index = 0\\n                                count2 += 1\\n\\n                break\\n            else:\\n                repeat_count[next_index] = (count1, count2)\\n\\n        return count2 // n2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205458,
                "title": "better-loop-detection",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHaving made a previous attempt that took 600ms I realised that detecting loops against the initial s2 start point wasn\\'t enough, so maybe an array storing s1&s2 cycle numbers at s2 loop would enable detection of any loop?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTook some thinking about but in the end storing s2 cycle number at the end of each s1 cycle and storing s1 cycle number at the first detected letter of each s2 cycle gives the right information, as long as one completes the s1 cycle one is in when one detects the s2 alignment loop. Math is explained in the code. Now takes 0ms (?). Could do with some tidying up since `e[]` is no longer required.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\xB2)$$ longest loop might take `s1.length` cycles of `s1.length` iterations to find\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ constant space defined by max string length\\n\\n# Code\\n```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, f = -1;\\n    int e[102], g[102], h[102]; for(int n = 0; n < 102; e[n++] = -1);\\n    char s1r, s2r = s2[0];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { h[c++] = d; a = 0;  if(!(f < 0)) goto earlycalc; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(b == 0) { if(e[a] == -1) { e[a] = d; g[a] = c; } else f = a; } \\n            if(!(s2r = s2[++b])) { s2r = s2[(b = 0)]; d++; }\\n        }\\n    }\\n    return (d / n2);\\nearlycalc: ;\\n//  counting continues after loop is found to end of current s1 cycle. \\n//  s2 count is taken at the end of each s1 cycle\\n\\n    int s1cr = n1 - c;                       // s1 cycles remaining\\n    int ls1c = c - g[f] - 1;                 // loop s1 cycles\\n    int ls2c = h[c - 1] - h[g[f]];           // loop s2 cycles\\n    int lr = s1cr / ls1c;                    // loops remaining\\n    int s1cafl = s1cr % ls1c;                // s1 cycles after final loop\\n    int s2cafl = h[g[f] + s1cafl] - h[g[f]]; // s2 cycles after final loop\\n    int s2t = d + (lr * ls2c) + s2cafl;      // s2 total\\n\\n    //printf(\"%i, %i, %i, %i, %i, %i, %i, %i, %i, %i\", a, b, c, d, e[0], e[1], e[2], e[a], f, g[a]);\\n\\n    return s2t / n2;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, f = -1;\\n    int e[102], g[102], h[102]; for(int n = 0; n < 102; e[n++] = -1);\\n    char s1r, s2r = s2[0];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { h[c++] = d; a = 0;  if(!(f < 0)) goto earlycalc; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(b == 0) { if(e[a] == -1) { e[a] = d; g[a] = c; } else f = a; } \\n            if(!(s2r = s2[++b])) { s2r = s2[(b = 0)]; d++; }\\n        }\\n    }\\n    return (d / n2);\\nearlycalc: ;\\n//  counting continues after loop is found to end of current s1 cycle. \\n//  s2 count is taken at the end of each s1 cycle\\n\\n    int s1cr = n1 - c;                       // s1 cycles remaining\\n    int ls1c = c - g[f] - 1;                 // loop s1 cycles\\n    int ls2c = h[c - 1] - h[g[f]];           // loop s2 cycles\\n    int lr = s1cr / ls1c;                    // loops remaining\\n    int s1cafl = s1cr % ls1c;                // s1 cycles after final loop\\n    int s2cafl = h[g[f] + s1cafl] - h[g[f]]; // s2 cycles after final loop\\n    int s2t = d + (lr * ls2c) + s2cafl;      // s2 total\\n\\n    //printf(\"%i, %i, %i, %i, %i, %i, %i, %i, %i, %i\", a, b, c, d, e[0], e[1], e[2], e[a], f, g[a]);\\n\\n    return s2t / n2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203214,
                "title": "calculate-early-if-cycling-is-detected",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDetect looping alignment of substring finding and use that to calculate what the total would be without having to count it out completely.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop through s1 finding in-order occurrances of the characters from s2, counting cycles of s1 and s2 until the first cahracter of s2 is found again in the same position of s1 as it was the first time. also record s1 count at each s2 loop for later.\\n\\nIf n1 cycles of s1 have been reached before s2 alignment cycles, do simple calculation ([s2 cycles] / n2).\\n\\nIf s2 alignment is reached, total number of s2 cycles is ((n1 * [s2 cycles done]) / [s1 cycles done]) - ([s1 cycle s2 last completed on] == [final s1 cycle]). To get max cycles of n2 cycles of s2, integer divide by n2.\\n\\nIt might be needed to also detect s2 alignment looping that hapens on the 2nd or 3rd alignment position but never returns to the first, since 600ms seems a bit long for 50 testcases. Could be implemented as an array of max string length, each time s2 first char is found check for an entry at current s1 read point, and if there isn\\'t one enter [s2 cycle number] on that array point. found entry = break, subtract entry from s2 cycle number, calculate cycles, then add back on before divide by n2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\xB7s)$$ - depends on length of the strings and how they loop. Worst case they never loop and the entire n1*s1 sequence has to be searched.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n\\n# Code\\n```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, e = -1, f = 0;\\n    char s1r, s2r = s2[b];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { c++; a = 0; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(e == -1) e = a; else if((e == a) && (b == 0)) goto earlycalc; \\n            s2r = s2[++b];\\n        }\\n        if(!s2r) { s2r = s2[(b = 0)]; d++; f = c; }\\n    }\\n    return (d / n2);\\nearlycalc:\\n    // s2 is matching s1 in same place as first letter match - cycle is complete\\n    // after c cycles of s1 and d cycles of s2\\n    // so we can say (n1 * d) / c cycles of s2 are possible in n1 cycles of s1\\n    // and that / n2 cycles of n2 cycles of s2\\n    // if the last cycle of s2 crossed s1 loop boundry, calc will be 1 too high so we -(f==c) to remove the overcaclculation\\n   \\n    return ((((n1 * d) / c) - (f == c)) / n2); \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\\n    int a = 0, b = 0, c = 0, d = 0, e = -1, f = 0;\\n    char s1r, s2r = s2[b];\\n    while(c < n1)\\n    {   if(!(s1r = s1[a++])) { c++; a = 0; continue; } // loop reading of s1\\n        if(s2r == s1r) \\n        {   if(e == -1) e = a; else if((e == a) && (b == 0)) goto earlycalc; \\n            s2r = s2[++b];\\n        }\\n        if(!s2r) { s2r = s2[(b = 0)]; d++; f = c; }\\n    }\\n    return (d / n2);\\nearlycalc:\\n    // s2 is matching s1 in same place as first letter match - cycle is complete\\n    // after c cycles of s1 and d cycles of s2\\n    // so we can say (n1 * d) / c cycles of s2 are possible in n1 cycles of s1\\n    // and that / n2 cycles of n2 cycles of s2\\n    // if the last cycle of s2 crossed s1 loop boundry, calc will be 1 too high so we -(f==c) to remove the overcaclculation\\n   \\n    return ((((n1 * d) / c) - (f == c)) / n2); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3136218,
                "title": "c-solution-100-00-faster",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic int GetMaxRepetitions(string s1, int n1, string s2, int n2) \\n\\t\\t{\\n\\t\\t\\tint len1 = s1.Length, len2 = s2.Length;\\n\\t\\t\\tif (len1 == 0 || len2 == 0 || len1 * n1 < len2 * n2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] repeatCnt = new int[len2 + 1];\\n\\t\\t\\tint[] nextIdx = new int[len2 + 1];\\n\\t\\t\\tint cnt = 0, idx = 0;\\n\\t\\t\\tfor (int i = 0; i < n1; i++) \\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (char c in s1) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (c == s2[idx]) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t\\tif (idx == len2) \\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trepeatCnt[i] = cnt;\\n\\t\\t\\t\\tnextIdx[i] = idx;\\n\\t\\t\\t\\tfor (int j = 0; j < i; j++) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (nextIdx[j] == idx) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint prefixCount = repeatCnt[j];\\n\\t\\t\\t\\t\\t\\tint patternCount = (repeatCnt[i] - repeatCnt[j]) * ((n1 - j - 1) / (i - j));\\n\\t\\t\\t\\t\\t\\tint suffixCount = repeatCnt[j + (n1 - j - 1) % (i - j)] - repeatCnt[j];\\n\\t\\t\\t\\t\\t\\treturn (prefixCount + patternCount + suffixCount) / n2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn repeatCnt[n1 - 1] / n2;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int GetMaxRepetitions(string s1, int n1, string s2, int n2) \\n\\t\\t{\\n\\t\\t\\tint len1 = s1.Length, len2 = s2.Length;\\n\\t\\t\\tif (len1 == 0 || len2 == 0 || len1 * n1 < len2 * n2)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint[] repeatCnt = new int[len2 + 1];\\n\\t\\t\\tint[] nextIdx = new int[len2 + 1];\\n\\t\\t\\tint cnt = 0, idx = 0;\\n\\t\\t\\tfor (int i = 0; i < n1; i++) \\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (char c in s1) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (c == s2[idx]) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t\\tif (idx == len2) \\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3076718,
                "title": "simple-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1, l2 = len(s1), len(s2)\\n        visited = {}\\n        index = repeat_count = i = 0\\n        while i < n1:\\n            print(i)\\n            for j in range(l1):\\n                if s1[j] == s2[index]:\\n                    index += 1\\n                if index == l2:\\n                    index = 0\\n                    repeat_count += 1\\n            if index in visited:\\n                prev_i, prev_repeat_count = visited[index]\\n                r = (n1-1-i) // (i-prev_i)\\n                i += (i-prev_i)*r\\n                repeat_count += (repeat_count-prev_repeat_count )*r\\n                visited = {}\\n            else:\\n                visited[index] = [i, repeat_count]\\n            i += 1\\n        return repeat_count // n2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1, l2 = len(s1), len(s2)\\n        visited = {}\\n        index = repeat_count = i = 0\\n        while i < n1:\\n            print(i)\\n            for j in range(l1):\\n                if s1[j] == s2[index]:\\n                    index += 1\\n                if index == l2:\\n                    index = 0\\n                    repeat_count += 1\\n            if index in visited:\\n                prev_i, prev_repeat_count = visited[index]\\n                r = (n1-1-i) // (i-prev_i)\\n                i += (i-prev_i)*r\\n                repeat_count += (repeat_count-prev_repeat_count )*r\\n                visited = {}\\n            else:\\n                visited[index] = [i, repeat_count]\\n            i += 1\\n        return repeat_count // n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883422,
                "title": "100",
                "content": "![image.png](https://assets.leetcode.com/users/images/5a09beb5-18a4-47c3-b40b-7c30f69df7dd_1670323817.7765276.png)\\n\\n# Explain:\\n\\nthe goal is to find a block of x concatinations of s1 that contains all chars of s2 without leftovers from s2. once we have this block we can calculate how many times s2 * n2 fits in s1 * n1. \\n\\n#### for example:\\n#### input:\\n\"baba\" 11\\n\"baab\" 1\\n\\nwe will start by comparing \"baba\" to \"baab\":\\ns1 - b, s2 b ---> local counter = 1 ----> main counter = 0\\ns1 - a, s2 a ---> local counter = 2 ----> main counter = 0\\ns1 - b, s2 a ---> local counter = 2 ----> main counter = 0\\ns1 - a, s2 a ---> local counter = 3 ----> main counter = 0\\n\\nloop #1 ends with 3 out of 4 characters found. \\n\\ns1 - b, s2 b ---> local counter = 4 ----> main counter = 1\\ns1 - a, s2 b ---> local counter = 0 ----> main counter = 1\\ns1 - b, s2 b ---> local counter = 1 ----> main counter = 1\\ns1 - a, s2 a ---> local counter = 2 ----> main counter = 1\\n\\nloop #2 ends and we found that s2 appear 1 time in s1 (*1) and we have 2 characters left.\\n\\ns1 - b, s2 a ---> local counter = 2 ----> main counter = 1\\ns1 - a, s2 a ---> local counter = 3 ----> main counter = 1\\ns1 - b, s2 b ---> local counter = 4 ----> main counter = 2\\ns1 - a, s2 b ---> local counter = 0 ----> main counter = 2\\n\\nloop #3 ends and we found that s2 appear 2 time in s1 (*2) and we have no characters left.\\n\\nwe know now that a block of s1 * 3 have exactly 2 matches of s2.\\n\\nthe doulications of s2 is 1 and the douplications of s1 is 11\\ntherefor the answer should be (1/2) * (11 / 3) rounded to the bottom. \\n\\n# Complexity\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    \\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {number} n1\\n * @param {string} s2\\n * @param {number} n2\\n * @return {number}\\n */\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let idx2 = 0;\\n    \\n    let doWhile = true;\\n    let strCounter = 0;\\n    let sumChars = 0;\\n    let iterations = 0;\\n    while (doWhile && iterations < n1) {\\n        for (let idx1 = 0; idx1 < s1.length; idx1++) {\\n            const char1 = s1[idx1];\\n            const char2 = s2[idx2];\\n            if (char1 === char2) {\\n                sumChars++;\\n                idx2++;\\n                if (sumChars === s2.length) {\\n                    strCounter ++;\\n                    sumChars = 0;\\n                    idx2 = 0;\\n                }\\n            }\\n        }\\n        if (sumChars === 0) {\\n            doWhile = false;\\n        }\\n        iterations++;\\n    }\\n    \\n    return Math.floor((strCounter / n2) * (n1 / iterations));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858977,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        let m = s1.len();\\n        let n = s2.len();\\n        let mut x = vec![vec![0; n]; m];\\n        let mut y = vec![vec![0; n]; m];\\n        let (mut i, mut j) = (0, 1);\\n        loop {\\n            i += 1;\\n            let ii = (i % m as i32) as usize;\\n            let jj = (j % n as i32) as usize;\\n            let xx = x[ii][jj];\\n            let yy = y[ii][jj];\\n            x[ii][jj] = i;\\n            y[ii][jj] = j;\\n            if xx > 0 {\\n                let k = (n1 * m as i32 - i) / (i - xx);\\n                i += k * (i - xx);\\n                j += k * (j - yy);\\n            }\\n            if i == n1 * m as i32 {\\n                return j / (n * n2 as usize) as i32;\\n            }\\n            if s1.chars().nth(ii) == s2.chars().nth(jj) {\\n                j += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\\n        let m = s1.len();\\n        let n = s2.len();\\n        let mut x = vec![vec![0; n]; m];\\n        let mut y = vec![vec![0; n]; m];\\n        let (mut i, mut j) = (0, 1);\\n        loop {\\n            i += 1;\\n            let ii = (i % m as i32) as usize;\\n            let jj = (j % n as i32) as usize;\\n            let xx = x[ii][jj];\\n            let yy = y[ii][jj];\\n            x[ii][jj] = i;\\n            y[ii][jj] = j;\\n            if xx > 0 {\\n                let k = (n1 * m as i32 - i) / (i - xx);\\n                i += k * (i - xx);\\n                j += k * (j - yy);\\n            }\\n            if i == n1 * m as i32 {\\n                return j / (n * n2 as usize) as i32;\\n            }\\n            if s1.chars().nth(ii) == s2.chars().nth(jj) {\\n                j += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799895,
                "title": "easy-understandable-solution",
                "content": "```\\nclass Solution {\\n    bool alls2Ins1(string s2,string s1){\\n       map<char,bool>mp;\\n        for(auto e:s1)\\n            mp[e]=true;\\n        for(auto e:s2){\\n            if(!mp[e])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int n=s1.size();\\n        int m=s2.size();\\n        \\n        // find how many times can s2 be made a subsequence of [s1,n1]\\n        \\n        if(!alls2Ins1(s2,s1))\\n            return 0;\\n        \\n            int maxMatch[m];\\n        memset(maxMatch,0,sizeof(maxMatch));\\n        \\n        for(int i=0;i<m;i++){\\n            int ptr=i;\\n            \\n            for(int j=0;j<n;j++){\\n                if(s1[j]==s2[ptr]){\\n                  maxMatch[i]++;\\n                    ptr++;\\n                    ptr%=m;\\n                }\\n            }\\n            \\n        }\\n        \\n        int tot=0;\\n        \\n        int cur=0;\\n        \\n        for(int i=0;i<n1;i++){\\n           int matched= maxMatch[cur];\\n            tot+=matched;\\n            cur+=matched;\\n            cur%=m;\\n        }\\n        \\n        return (tot/m)/n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool alls2Ins1(string s2,string s1){\\n       map<char,bool>mp;\\n        for(auto e:s1)\\n            mp[e]=true;\\n        for(auto e:s2){\\n            if(!mp[e])\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int n=s1.size();\\n        int m=s2.size();\\n        \\n        // find how many times can s2 be made a subsequence of [s1,n1]\\n        \\n        if(!alls2Ins1(s2,s1))\\n            return 0;\\n        \\n            int maxMatch[m];\\n        memset(maxMatch,0,sizeof(maxMatch));\\n        \\n        for(int i=0;i<m;i++){\\n            int ptr=i;\\n            \\n            for(int j=0;j<n;j++){\\n                if(s1[j]==s2[ptr]){\\n                  maxMatch[i]++;\\n                    ptr++;\\n                    ptr%=m;\\n                }\\n            }\\n            \\n        }\\n        \\n        int tot=0;\\n        \\n        int cur=0;\\n        \\n        for(int i=0;i<n1;i++){\\n           int matched= maxMatch[cur];\\n            tot+=matched;\\n            cur+=matched;\\n            cur%=m;\\n        }\\n        \\n        return (tot/m)/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787702,
                "title": "count-the-repetitions-hard",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWipo\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // ptr2--> s2+s2+s2......  str2\\n        // ptr1--> s1+s1+..s1 --> str1\\n        \\n        int len1=s1.length();\\n        int len2=s2.length();\\n        \\n        unordered_map<int,int> increase;\\n        \\n        for(int i=0;i<len2;i++) {\\n            int ptr1=0;\\n            int ptr2=i;\\n            while(ptr1!=len1) {\\n                if(s1[ptr1]==s2[ptr2%len2]) {\\n                    ptr1++;\\n                    ptr2++;\\n                } else {\\n                    ptr1++;\\n                }\\n            }\\n            increase[i]=ptr2-i;\\n        }\\n        \\n        // O(len2*len1)\\n        \\n        int ptr=0;\\n        int totalMatchedLength=0;\\n        \\n        for(int i=0;i<n1;i++) {\\n            totalMatchedLength+=increase[ptr];\\n            ptr+=increase[ptr];\\n            ptr%=len2;\\n        }\\n        \\n        // O(n1+len2*len1)\\n        \\n        \\n        return totalMatchedLength/(len2*n2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        // ptr2--> s2+s2+s2......  str2\\n        // ptr1--> s1+s1+..s1 --> str1\\n        \\n        int len1=s1.length();\\n        int len2=s2.length();\\n        \\n        unordered_map<int,int> increase;\\n        \\n        for(int i=0;i<len2;i++) {\\n            int ptr1=0;\\n            int ptr2=i;\\n            while(ptr1!=len1) {\\n                if(s1[ptr1]==s2[ptr2%len2]) {\\n                    ptr1++;\\n                    ptr2++;\\n                } else {\\n                    ptr1++;\\n                }\\n            }\\n            increase[i]=ptr2-i;\\n        }\\n        \\n        // O(len2*len1)\\n        \\n        int ptr=0;\\n        int totalMatchedLength=0;\\n        \\n        for(int i=0;i<n1;i++) {\\n            totalMatchedLength+=increase[ptr];\\n            ptr+=increase[ptr];\\n            ptr%=len2;\\n        }\\n        \\n        // O(n1+len2*len1)\\n        \\n        \\n        return totalMatchedLength/(len2*n2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777270,
                "title": "swift-solution-tle",
                "content": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    func getMaxRepetitions(_ s1: String, _ n1: Int, _ s2: String, _ n2: Int) -> Int {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n        var count1 = 0\\n        var count2 = 0\\n        var i = 0\\n        var j = 0\\n        while count1 < n1 {\\n            if s1[i] == s2[j] {\\n                j += 1\\n                if j == s2.count {\\n                    j = 0\\n                    count2 += 1\\n                }\\n            }\\n            i += 1\\n            if i == s1.count {\\n                i = 0\\n                count1 += 1\\n            }\\n        }\\n        return count2 / n2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// Count the repetitions\\n// LeetCode: https://leetcode.com/problems/count-the-repetitions/\\n\\nclass Solution {\\n    func getMaxRepetitions(_ s1: String, _ n1: Int, _ s2: String, _ n2: Int) -> Int {\\n        let s1 = Array(s1)\\n        let s2 = Array(s2)\\n        var count1 = 0\\n        var count2 = 0\\n        var i = 0\\n        var j = 0\\n        while count1 < n1 {\\n            if s1[i] == s2[j] {\\n                j += 1\\n                if j == s2.count {\\n                    j = 0\\n                    count2 += 1\\n                }\\n            }\\n            i += 1\\n            if i == s1.count {\\n                i = 0\\n                count1 += 1\\n            }\\n        }\\n        return count2 / n2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684735,
                "title": "c-solution-using-two-approaches-preprocessing-using-dynamic-programming-and-pattern-finding",
                "content": "## **Approach 1:** Preprocessing using Dynamic Programming\\n1. str1=[s1,n1] and str2=[s2,n2], we need to find how many times the string str2  occurs as distinct subsequences in the string str1.\\n2. Let cnt1 and cnt2 be the number of times we have visited the string s1 and the string s2.\\n3. We also maintain pointers i, and j to iterate over s1 and s2. \\n4. In the brute force approach, we scan s1 and s2 and increments all these variables accordingly. The required result is obtained by cnt2/n2. But the time complexity is O(s1.size()*n1).\\n5. As the string str1 is the repetition of string s1, we can improve the brute force with some preprocessing. \\n6. Let us the define the state **dp[i][j]=maxMatch**, such that maxMatch is the maximum length of s2[j:]+[s2,x], x>0, which occurs as subsequence in the string s1[i:].\\n7. Now, we can use this pre-processing to fast-forward our brute force approach. We can process the entire string s1, in O(1) time. The overall time complexity of this approach will be O(n1).\\n8. We no longer require the pointer i for string s1 as the entire string will be processed in O(1)  time. We just need to carefully increment the pointer j and cnt2.\\n9. While calculating the result, we will only require dp[0][j] states but not other states so therefore we can bring down the space complexity from O(s1.size()*s2.size()) to O(s2.size())\\n10. Therefore the space complexity is **O(s2.size())** and the time complexity is **O(n1+s1.size()*s2.size())**.\\n11. Calculating the actual result from this preprocessing is quite simple, we just iterate over the string s1 for n1 times and increment the pointer j and cnt2 pointers accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>dp(s2.size());\\n        for(int i=s1.size()-1 ; i>=0 ; i--)\\n        { vector<int>tmp(s2.size());\\n          for(int j=s2.size()-1 ; j>=0 ; j--)\\n          { if(s1[i]==s2[j])\\n            { tmp[j]++;\\n              if((i+1)<s1.size())\\n              { int p=j+1; if(p==s2.size()) p=0;\\n                tmp[j]+=dp[p];\\n              }\\n            }\\n            else if((i+1)<s1.size())\\n              tmp[j]=dp[j];\\n          }  \\n          dp=tmp;\\n        }\\n        \\n        int res=0,cnt1=0,cnt2=0,j=0;\\n        while(cnt1<n1)\\n        { int maxMatch=dp[j];\\n          cnt1++;\\n         \\n          int diff=s2.size()-j;\\n          if(diff>=maxMatch)\\n          { j+=maxMatch;\\n            if(j==s2.size()) { j=0; cnt2++; }\\n          }\\n          else \\n          { cnt2++;\\n            maxMatch-=diff; j=maxMatch%s2.size();\\n            cnt2+=(maxMatch/(s2.size()));\\n          }\\n        }\\n        return cnt2/n2;\\n    }\\n};\\n\\n```\\n\\n## **Approach 2: Finding the Pattern**\\n\\n1. In the brute force approach, we iterate over s1 for n1 times. Whenever we are at index 0 of s1, the maximum **number of different possible indexes pointing to s2 is s2.size()**. Therefore, by pigeonhole principle, if we visit the string s1 at (s1.size()+1)^{th} time (in the worst case), we will be visiting a particular index at the second time.\\n2. Note: In the previous approach as well, we were maintaining the j^{th} index, pointing to s2, for each iteration of s1.\\n2. Therefore, the pattern had occurred for the first time. Using this pattern, we can now calculate our required result in O(1) time.\\n3. Suppose, the index ind pointing to s2 occurs at i^{th}  and k^{th} iteration of s2, where k<i. Then the next occurrence of index ind occurs at [i+(i-k)]^{th} iteration and so on. We must have, i+t*(i-k)<n1 [using 0 based indexed while iterating through the string s1] \\u21D2 i+t*(i-k) <= (n1-1) \\u21D2 **t <= (n1-1-i)/(i-k)** and therefore the pattern occurs for t+1, times.\\n4. Then the maximum iteration number we can achieve for the occurrence of pattern is: maxind=i+t*(i-k).\\n5. Our result can be obtained in three parts:\\nFirst part: **res+=cnt[k]** (Before occurrence of pattern).\\nSecond part: **res+=(cnt[i]-cnt[k])\\\\*(t+1)** [The pattern itself]\\nThird part: **res+=cnt[k+n1-1-maxind]-cnt[k]**   [The remaining part]\\n6. The Time Complexity is O(s1.size()*s2.size()) and Space Complexity is O(s2.size()).\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>nxtind(s2.size()+1),cnt(s2.size()+1);\\n        int ind=0,tcnt=0;\\n        \\n        for(int i=0; i<n1 ; i++)\\n        { for(int j=0 ; j<s1.size(); j++)\\n          { if(s1[j]==s2[ind]) ind++;\\n            if(ind==s2.size()) {ind=0; tcnt++;}   \\n          }\\n          cnt[i]=tcnt;\\n          nxtind[i]=ind;\\n          for(int k=0 ; k<i ; k++)\\n          { if(nxtind[k]==ind)\\n            { int res=cnt[k];\\n              int t=(n1-1-i)/(i-k);\\n              res+=(cnt[i]-cnt[k])*(t+1); \\n              int maxind=i+(i-k)*t;\\n              if(maxind<(n1-1)) res+=cnt[k+n1-1-maxind]-cnt[k];\\n              return res/n2;\\n            }  \\n          }\\n        }\\n        return cnt[n1-1]/n2;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>dp(s2.size());\\n        for(int i=s1.size()-1 ; i>=0 ; i--)\\n        { vector<int>tmp(s2.size());\\n          for(int j=s2.size()-1 ; j>=0 ; j--)\\n          { if(s1[i]==s2[j])\\n            { tmp[j]++;\\n              if((i+1)<s1.size())\\n              { int p=j+1; if(p==s2.size()) p=0;\\n                tmp[j]+=dp[p];\\n              }\\n            }\\n            else if((i+1)<s1.size())\\n              tmp[j]=dp[j];\\n          }  \\n          dp=tmp;\\n        }\\n        \\n        int res=0,cnt1=0,cnt2=0,j=0;\\n        while(cnt1<n1)\\n        { int maxMatch=dp[j];\\n          cnt1++;\\n         \\n          int diff=s2.size()-j;\\n          if(diff>=maxMatch)\\n          { j+=maxMatch;\\n            if(j==s2.size()) { j=0; cnt2++; }\\n          }\\n          else \\n          { cnt2++;\\n            maxMatch-=diff; j=maxMatch%s2.size();\\n            cnt2+=(maxMatch/(s2.size()));\\n          }\\n        }\\n        return cnt2/n2;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int>nxtind(s2.size()+1),cnt(s2.size()+1);\\n        int ind=0,tcnt=0;\\n        \\n        for(int i=0; i<n1 ; i++)\\n        { for(int j=0 ; j<s1.size(); j++)\\n          { if(s1[j]==s2[ind]) ind++;\\n            if(ind==s2.size()) {ind=0; tcnt++;}   \\n          }\\n          cnt[i]=tcnt;\\n          nxtind[i]=ind;\\n          for(int k=0 ; k<i ; k++)\\n          { if(nxtind[k]==ind)\\n            { int res=cnt[k];\\n              int t=(n1-1-i)/(i-k);\\n              res+=(cnt[i]-cnt[k])*(t+1); \\n              int maxind=i+(i-k)*t;\\n              if(maxind<(n1-1)) res+=cnt[k+n1-1-maxind]-cnt[k];\\n              return res/n2;\\n            }  \\n          }\\n        }\\n        return cnt[n1-1]/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677329,
                "title": "calculate-wraparound-position-smart-cycle-repetition-counting",
                "content": "# Intuition\\nLet\\'s reword the question to **\"how many occurences of `[str2, n2]` appears in `[str1, n1]` as a subsequence\"**, and then the intent of the question should be much easier to understand. Which is why **the question explaisn the \"removing\" characters part**, because then we can delete all the characters outside of the subsequences and have the result as a string.\\n\\n#### Step 1: Naive Brute Force (TLE)\\nLet\\'s have **two pointers** moving in both strings, we move the `str1` pointer until we encounter `str2[i]`, and then we keep track of how many \"whole\" `str2` have we seen.\\n\\nThe problem then becomes that `n1*str1.size()` and `n2*str2.size()` can become too big (10^6*100=10^8 characters), but the idea of the two pointers remain as the general idea to improve the naive brute force.\\n\\n#### Step 2: Better Brute Force (TLE)\\nWhat if we can somehow avoid doing two pointers **naively** to search for characters of `str2`? Notice that we start with `str2[0]` and then go to `str2[str2.size() - 1]`, and **they\\'re same position in `str1` over and over again.** Remember that we\\'re working with **copies of `str1`**, so we can treat this process as **going through cycles of `str1`!** For every index in `str1` such that `str1[i] == str2[0]`, we can calculate the number of cycles we\\'d need and the position we\\'d end up with.\\n\\nE.g. `str1 = \"baba\"` and `str2 = \"baab\"`, we\\'d have `cycles = [1,0,1,0]` and `dest = [0,0,2,0]` (remember we only care about `str1[i] == str2[0]`)\\n- Starting at `i = 0`, we\\'d need `1` cycle to find `baab` because we need `babababa` to get one `baab`, we\\'d also end up at `i = 4`, which is really `i = 0` for the second copy of `str1`\\n- Starting at `i = 2`, we\\'d again need `1` cycle to find `baab` because we need `babababa` to get one `baab`, we\\'d also end up at `i = 6`, which is really `i = 2` for the second copy of `str1`\\n\\nNow, we have the information to traverse `str2` at any position in `O(1)`. But hold on, it still handle cases like this one `str1 = \"a\"*100 (100 a\\'s), n1 = 1000000` and `str2 = \"a\", n2 = 1000000`. Notice that **we have multiple \"whole\" `str2` in one `str1`.** So we\\'re finding 100 `str2` and doing that `1000000` times, which still ends up being too many operations.\\n\\n#### Step 3: Smarter Brute Force (Accepted)\\nTo account for multiple `str2` problem mentioned above, we create new information `fit_copies` and `fit_dest`, which tells us how many whole `str2` we have in `str1` starting at `i`, and where we\\'d end up fitting all the `str2` we find starting at `i`. Together with this information combined with the position wrapping information from above, we can figure out how many `str2`\\'s we\\'d have in one `str1` in `O(1)`, and travel to the next cycle of `str1` in `O(1)`. This means **we\\'d have maximum `O(1000000)` to perform as each cycle is `O(1)`.**\\n\\n# Approach\\n1. Check if it\\'s possible to have `str2` by checking `str1` have all the charaters needed for `str2`\\n2. Precompute information for cycles and wraparound position to go through entirety of `str2` for every `cycles[i]` and `dest[i]` such that `str1[i] == str2[0]`\\n3. Precompute information for maximum number of `str2` and the position we\\'d end up at in `fit_copies[i]` and `fit_dest` starting at `str1[i]` such that `str1[i] == str2[0]`\\n4. Go through each cycle and update our answer\\n\\n# Complexity\\n- Time complexity: $$O(n1 * log(len(str1)))$$\\n    - Since we\\'re calculating how many `str2` we can have for `str1`, but we have to do that `n1` times. We\\'re also performing binary search to find the appropriate position to start counting the cycles\\n\\n- Space complexity: $$O(len(str1))$$\\n    - The biggest storage comes from storing the positions of each letter in `str1`\\n\\n# Code\\n```\\n#define all(x) x.begin(), x.end()\\n#define vec vector\\n\\nusing vi = vec<int>;\\nusing vvi = vec<vec<int>>;\\n\\nclass Solution {\\npublic:\\n  int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int m1 = s1.size(), m2 = s2.size();\\n\\n    // Check if `str2` is possible\\n    vi exists1(26), exists2(26);\\n    for (int i = 0; i < m1; i++) {\\n      exists1[s1[i] - \\'a\\'] = true;\\n    }\\n    for (int i = 0; i < m2; i++) {\\n      exists2[s2[i] - \\'a\\'] = true;\\n    }\\n    for (int i = 0; i < 26; i++) {\\n      if (exists2[i] && !exists1[i]) {\\n        return 0;\\n      }\\n    }\\n\\n    vvi pos(26);\\n    for (int i = 0; i < m1; i++) {\\n      pos[s1[i] - \\'a\\'].push_back(i);\\n    }\\n\\n    vi cycles(m1), dest(m1);\\n    for (int start = 0; start < m1; start++) {\\n      if (s1[start] != s2[0]) {\\n        continue;\\n      }\\n\\n      int cycle = 0, end = start - 1;\\n      for (int i = 0; i < m2; i++) {\\n        auto &poses = pos[s2[i] - \\'a\\'];\\n        assert(!poses.empty());\\n\\n        auto it = upper_bound(all(poses), end);\\n        if (it == poses.end()) {\\n          // We need another cycle to go through rest of `str2`\\n          cycle++;\\n          end = poses[0];\\n        } else {\\n          end = *it;\\n        }\\n      }\\n      dest[start] = end;\\n      cycles[start] = cycle;\\n    }\\n\\n    vi fit_copies(m1), fit_dest(m1);\\n    for (int start = 0; start < m1; start++) {\\n      if (s1[start] != s2[0]) {\\n        continue;\\n      }\\n\\n      int fits = 0, end = start - 1;\\n      while (true) {\\n        auto &poses = pos[s2[0] - \\'a\\'];\\n        assert(!poses.empty());\\n\\n        auto it = upper_bound(all(poses), end);\\n        // Another `str2` would need another cycle\\n        if (it == poses.end() || cycles[*it] > 0) {\\n          break;\\n        } else {\\n          fits++;\\n          end = dest[*it];\\n        }\\n      }\\n      fit_copies[start] = fits;\\n      fit_dest[start] = end;\\n    }\\n\\n    int cycle = 1, prev = -1, cnt = 0;\\n    while (cycle <= n1) {\\n      auto &poses = pos[s2[0] - \\'a\\'];\\n      assert(!poses.empty());\\n\\n      auto it = upper_bound(all(poses), prev);\\n      if (it == poses.end()) {\\n        // We end up perfectly at the end, go to next cycle\\n        cycle += 1 + cycles[poses[0]];\\n        prev = dest[poses[0]];\\n        cnt++;\\n      } else if (cycles[*it] > 0) {\\n        // Have part of `str2` until next cycle\\n        cycle += cycles[*it];\\n        prev = dest[*it];\\n        cnt++;\\n      } else {\\n        // Have multiple `str2` for the current cycle\\n        prev = fit_dest[*it];\\n        cnt += fit_copies[*it];\\n      }\\n    }\\n\\n    // When we stop, we have one extra count, so get rid of that\\n    // Remember we need to account for `n2`, a division can do\\n    return (cnt - 1) / n2;\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Binary Search",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n  int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int m1 = s1.size(), m2 = s2.size();\\n\\n    // Check if `str2` is possible\\n    vi exists1(26), exists2(26);\\n    for (int i = 0; i < m1; i++) {\\n      exists1[s1[i] - \\'a\\'] = true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2521184,
                "title": "python3-repeating-patterns",
                "content": "\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        cnt = idx = 0 \\n        count = []\\n        index = []\\n        for i in range(n1): \\n            for ch in s1: \\n                if ch == s2[idx]: \\n                    idx += 1\\n                    if idx == len(s2): \\n                        cnt += 1\\n                        idx = 0 \\n            count.append(cnt)\\n            index.append(idx)\\n            for ii in range(i): \\n                if index[ii] == idx: \\n                    prev = count[ii]\\n                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))\\n                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]\\n                    return (prev + repeat + post) // n2\\n        return count[-1]//n2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        cnt = idx = 0 \\n        count = []\\n        index = []\\n        for i in range(n1): \\n            for ch in s1: \\n                if ch == s2[idx]: \\n                    idx += 1\\n                    if idx == len(s2): \\n                        cnt += 1\\n                        idx = 0 \\n            count.append(cnt)\\n            index.append(idx)\\n            for ii in range(i): \\n                if index[ii] == idx: \\n                    prev = count[ii]\\n                    repeat = (cnt - prev) * ((n1-1-ii) // (i - ii))\\n                    post = count[ii + (n1-1-ii) % (i-ii)] - count[ii]\\n                    return (prev + repeat + post) // n2\\n        return count[-1]//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398242,
                "title": "c-using-hash-to-ditect-repetition-and-reduce-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int i = 0;\\n        int j = 0;\\n        int sn2 = n2;\\n        int sn1 = n1;\\n        unordered_map<long long,long long> m;\\n        bool found = false;\\n        long long  ii = 0;\\n        long long  jj = 0;\\n        while(n1>0)\\n        {\\n            if (s1[i]==s2[j]) \\n            {\\n                if (m.count(i*1000000+j))\\n                {\\n                    int ii1 = m[i*1000000+j]/1000000;\\n                    int jj1 = m[i*1000000+j]%1000000;\\n                    int ii_diff = ii-ii1;\\n                    int jj_diff = jj-jj1;\\n                    int  x = (s1.size()*sn1-ii)/ii_diff;\\n                    ii += x*ii_diff;\\n                    jj += x*jj_diff;\\n                    i = ii%s1.size();\\n                    j = jj%s2.size();\\n                    n1 = sn1 -ii/s1.size();\\n                    n2 = sn2 -jj/s2.size();\\n                    if (n1 == 0)\\n                        break;\\n                }\\n                else\\n                m[i*1000000+j]=ii*1000000+jj;\\n                jj++;\\n                if (++j >= s2.size())\\n                {\\n                    j = 0;\\n                    if(--n2 == 0)\\n                    {\\n                        ans++;\\n                        n2=sn2;\\n                    }\\n                }\\n            }\\n            ii++;\\n            if (++i == s1.size())\\n            {\\n                i=0;\\n                n1--;\\n            }\\n\\n        }\\n        return jj/(s2.size()*sn2);\\n    }\\n};\\n\\n/*\\n\"niconiconi\"\\n99981\\n\"nico\"\\n81\\n\\n\"acb\"\\n1\\n\"ab\"\\n1\\n\\n\"aaa\"\\n3\\n\"aa\"\\n1\\n\\n\"acb\"\\n4\\n\"ab\"\\n2\\n\\n\"bacaba\"\\n3\\n\"abacab\"\\n1\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikef\"\\n1000000\\n\"fmznimkkasvwsrenzkycxfxtlsgypsfad\"\\n333\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjpre\"\\n1000000\\n\"pggxr\"\\n100\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int i = 0;\\n        int j = 0;\\n        int sn2 = n2;\\n        int sn1 = n1;\\n        unordered_map<long long,long long> m;\\n        bool found = false;\\n        long long  ii = 0;\\n        long long  jj = 0;\\n        while(n1>0)\\n        {\\n            if (s1[i]==s2[j]) \\n            {\\n                if (m.count(i*1000000+j))\\n                {\\n                    int ii1 = m[i*1000000+j]/1000000;\\n                    int jj1 = m[i*1000000+j]%1000000;\\n                    int ii_diff = ii-ii1;\\n                    int jj_diff = jj-jj1;\\n                    int  x = (s1.size()*sn1-ii)/ii_diff;\\n                    ii += x*ii_diff;\\n                    jj += x*jj_diff;\\n                    i = ii%s1.size();\\n                    j = jj%s2.size();\\n                    n1 = sn1 -ii/s1.size();\\n                    n2 = sn2 -jj/s2.size();\\n                    if (n1 == 0)\\n                        break;\\n                }\\n                else\\n                m[i*1000000+j]=ii*1000000+jj;\\n                jj++;\\n                if (++j >= s2.size())\\n                {\\n                    j = 0;\\n                    if(--n2 == 0)\\n                    {\\n                        ans++;\\n                        n2=sn2;\\n                    }\\n                }\\n            }\\n            ii++;\\n            if (++i == s1.size())\\n            {\\n                i=0;\\n                n1--;\\n            }\\n\\n        }\\n        return jj/(s2.size()*sn2);\\n    }\\n};\\n\\n/*\\n\"niconiconi\"\\n99981\\n\"nico\"\\n81\\n\\n\"acb\"\\n1\\n\"ab\"\\n1\\n\\n\"aaa\"\\n3\\n\"aa\"\\n1\\n\\n\"acb\"\\n4\\n\"ab\"\\n2\\n\\n\"bacaba\"\\n3\\n\"abacab\"\\n1\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjprepggxrpnrvystmwcysyycqpevikef\"\\n1000000\\n\"fmznimkkasvwsrenzkycxfxtlsgypsfad\"\\n333\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000000\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n\"phqghumeaylnlfdxfircvscxggbwkfnqduxwfnfozvsrtkjpre\"\\n1000000\\n\"pggxr\"\\n100\\n\\n\"a\"\\n1000000\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n1000\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307017,
                "title": "java-6ms-find-cycle-o-mn",
                "content": "Not much to say, find the cycle. It is quite weird it is tagged under DP question. More like cycle detection question.\\n\\nThis runs in `O(MN)` because we are bound to encounter a cycle in all `M*N` possibilities, and whenever we do, we skip to near the end.\\n#### Java\\n```Java\\nclass Solution {\\n    public int getMaxRepetitions(String A, int a, String B, int b) {\\n        int m = A.length(), n = B.length();\\n        int[][] x = new int[m][n];\\n        int[][] y = new int[m][n];\\n        for (int i = 1, j = 1; true; i++){\\n            int ii = i%m, jj = j%n, xx = x[ii][jj], yy = y[ii][jj];\\n            x[ii][jj]=i;\\n            y[ii][jj]=j;\\n            if (xx > 0){ // ultra jump to the end!\\n                int k = (a*m-i)/(i-xx);\\n                i += k*(i-xx);\\n                j += k*(j-yy);\\n            }\\n            if (i == a*m){ // reached the end\\n                return j/(n*b);\\n            }\\n            if (A.charAt(ii)==B.charAt(jj)){ // subsequence check\\n                j++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int getMaxRepetitions(String A, int a, String B, int b) {\\n        int m = A.length(), n = B.length();\\n        int[][] x = new int[m][n];\\n        int[][] y = new int[m][n];\\n        for (int i = 1, j = 1; true; i++){\\n            int ii = i%m, jj = j%n, xx = x[ii][jj], yy = y[ii][jj];\\n            x[ii][jj]=i;\\n            y[ii][jj]=j;\\n            if (xx > 0){ // ultra jump to the end!\\n                int k = (a*m-i)/(i-xx);\\n                i += k*(i-xx);\\n                j += k*(j-yy);\\n            }\\n            if (i == a*m){ // reached the end\\n                return j/(n*b);\\n            }\\n            if (A.charAt(ii)==B.charAt(jj)){ // subsequence check\\n                j++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303632,
                "title": "time-o-s1-len-s2-len-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> countr(s2.size(),-1), indexr(s2.size(),-1);\\n        int count = 0;\\n        vector<int> seqIndex;\\n        for (int i=0, j2=0; i<n1; i++) {\\n            if (indexr[j2] > -1) {\\n                int repC = count-countr[j2];\\n                int repN = i - indexr[j2];\\n                int remainingN = n1 - i;\\n\\t\\t\\t\\t//the times that the pattern repeated\\n                count += remainingN/repN * repC;\\n\\t\\t\\t\\t//the residue at the end of str1, but still might form valid s2\\n                int j2_ = seqIndex[indexr[j2]+remainingN%repN];\\n                count += countr[j2_] - countr[j2];\\n                break;\\n            } else {\\n                countr[j2] = count;\\n                indexr[j2] = i;\\n                seqIndex.push_back(j2);\\n            }\\n            \\n            for (int j1=0; j1<s1.size(); j1++) {\\n                if (s1[j1] == s2[j2]) {\\n                    j2++;\\n                    if (j2 == s2.size()) {\\n                        j2 = 0;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count/n2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> countr(s2.size(),-1), indexr(s2.size(),-1);\\n        int count = 0;\\n        vector<int> seqIndex;\\n        for (int i=0, j2=0; i<n1; i++) {\\n            if (indexr[j2] > -1) {\\n                int repC = count-countr[j2];\\n                int repN = i - indexr[j2];\\n                int remainingN = n1 - i;\\n\\t\\t\\t\\t//the times that the pattern repeated\\n                count += remainingN/repN * repC;\\n\\t\\t\\t\\t//the residue at the end of str1, but still might form valid s2\\n                int j2_ = seqIndex[indexr[j2]+remainingN%repN];\\n                count += countr[j2_] - countr[j2];\\n                break;\\n            } else {\\n                countr[j2] = count;\\n                indexr[j2] = i;\\n                seqIndex.push_back(j2);\\n            }\\n            \\n            for (int j1=0; j1<s1.size(); j1++) {\\n                if (s1[j1] == s2[j2]) {\\n                    j2++;\\n                    if (j2 == s2.size()) {\\n                        j2 = 0;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010094,
                "title": "javascript-solution-just-code-optimization",
                "content": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let c = t = i = j = 0;\\n    while (c < n1) {\\n        if (s1[i] === s2[j] && ++j === s2.length) {\\n            j = 0;\\n            t++;\\n        }\\n        if (++i === s1.length) {\\n            i = 0;\\n            c++;\\n        }\\n    }\\n    return t / n2 >> 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let c = t = i = j = 0;\\n    while (c < n1) {\\n        if (s1[i] === s2[j] && ++j === s2.length) {\\n            j = 0;\\n            t++;\\n        }\\n        if (++i === s1.length) {\\n            i = 0;\\n            c++;\\n        }\\n    }\\n    return t / n2 >> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932676,
                "title": "count-the-repetitions-solutions-java",
                "content": "class Record {\\n  public int count;\\n  public int nextIndex;\\n  public Record(int count, int nextIndex) {\\n    this.count = count;\\n    this.nextIndex = nextIndex;\\n  }\\n};\\n\\nclass Solution {\\n  public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    List<Record> records = new ArrayList<>(); // [count(s1 matches s2[i:]), next index of s2[i:]]\\n\\n    for (int i = 0; i < s2.length(); ++i) {\\n      int count = 0;\\n      int nextIndex = i;\\n      for (int j = 0; j < s1.length(); ++j)\\n        if (s2.charAt(nextIndex) == s1.charAt(j))\\n          if (++nextIndex == s2.length()) { // have a match\\n            ++count;\\n            nextIndex = 0;\\n          }\\n      records.add(new Record(count, nextIndex));\\n    }\\n\\n    int matches = 0; // S1 matches s2\\n    int index = 0;\\n\\n    while (n1-- > 0) {\\n      matches += records.get(index).count;\\n      index = records.get(index).nextIndex;\\n    }\\n\\n    return matches / n2; // S1 matches S2\\n  }\\n}\\n",
                "solutionTags": [
                    "String",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n  public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    List<Record> records = new ArrayList<>(); // [count(s1 matches s2[i:]), next index of s2[i:]]\\n\\n    for (int i = 0; i < s2.length(); ++i) {\\n      int count = 0;\\n      int nextIndex = i;\\n      for (int j = 0; j < s1.length(); ++j)\\n        if (s2.charAt(nextIndex) == s1.charAt(j))\\n          if (++nextIndex == s2.length()) { // have a match\\n            ++count;\\n            nextIndex = 0;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1871739,
                "title": "c-o-s1-s2-read-if-you-find-cycles-too-hard-to-understand-implement",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        \\n        const int m1 = s1.length();\\n        const int m2 = s2.length();\\n        \\n        int pos1 = 0 , pos2 = 0;\\n        int k1 = 0, k2 = 0; \\n        \\n        vector<pair<int, int>> history(m2, {-1,-1});  // <pos2, <k1,k2>>\\n        \\n        history[0] = {0,0};\\n            \\n        while(k1 < n1)\\n        {\\n            if(s1[pos1++] == s2[pos2])\\n            {\\n                if(++pos2 == m2)\\n                {\\n                    ++k2, pos2 = 0;\\n                }\\n            }\\n            \\n            if(pos1 == m1) \\n            {\\n                ++k1, pos1 = 0;\\n               \\n                if(history[pos2].first == -1)\\n                {\\n                    history[pos2] = {k1, k2};\\n                }\\n                else\\n                {\\n                    auto [prev_k1, prev_k2] = history[pos2];\\n                    \\n                    if(prev_k2 == k2)   return 0;   // cannot obtain s2 from [s1,n1]\\n                    \\n                    // fast forward k1 and k2 based on the found cycle\\n                    if(k1 < n1)\\n                    {\\n                        // calc the largest q, s.t. k1 + q * (k1 - prev_k1) <= n1\\n                        int q = (n1 - k1) / (k1 - prev_k1);\\n                        k1 += q * (k1 - prev_k1);\\n                        k2 += q * (k2 - prev_k2);\\n                    }\\n                }\\n            }\\n        }\\n                   \\n        return k2 / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        \\n        const int m1 = s1.length();\\n        const int m2 = s2.length();\\n        \\n        int pos1 = 0 , pos2 = 0;\\n        int k1 = 0, k2 = 0; \\n        \\n        vector<pair<int, int>> history(m2, {-1,-1});  // <pos2, <k1,k2>>\\n        \\n        history[0] = {0,0};\\n            \\n        while(k1 < n1)\\n        {\\n            if(s1[pos1++] == s2[pos2])\\n            {\\n                if(++pos2 == m2)\\n                {\\n                    ++k2, pos2 = 0;\\n                }\\n            }\\n            \\n            if(pos1 == m1) \\n            {\\n                ++k1, pos1 = 0;\\n               \\n                if(history[pos2].first == -1)\\n                {\\n                    history[pos2] = {k1, k2};\\n                }\\n                else\\n                {\\n                    auto [prev_k1, prev_k2] = history[pos2];\\n                    \\n                    if(prev_k2 == k2)   return 0;   // cannot obtain s2 from [s1,n1]\\n                    \\n                    // fast forward k1 and k2 based on the found cycle\\n                    if(k1 < n1)\\n                    {\\n                        // calc the largest q, s.t. k1 + q * (k1 - prev_k1) <= n1\\n                        int q = (n1 - k1) / (k1 - prev_k1);\\n                        k1 += q * (k1 - prev_k1);\\n                        k2 += q * (k2 - prev_k2);\\n                    }\\n                }\\n            }\\n        }\\n                   \\n        return k2 / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733987,
                "title": "c-passes-all-test-cases",
                "content": "I know it is not the best or fastest but here is how I solved this one:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int s1size = s1.size(); int s2size = s2.size();\\n    vector<int> dpm (s1size, INT_MAX/2);\\n\\n    // store in dpm[i] how many elements from s1 does it take starting from ith element to make just one s2\\n    for(int i = 0; i < s1.size(); i++ )\\n    {\\n        int p1 = i, p2{0};\\n        bool found = false;\\n        while(p1 < s1.size() * n1 && !found)\\n        {\\n            if(s2[p2] == s1[p1 % s1size])\\n                {\\n                p2++;\\n                if(p2 == s2size)\\n                    found = true;\\n                }\\n            p1++;\\n        }\\n    if(found) dpm[i] = p1 - i;\\n    }\\n       \\n    //using dpm[i] calculate and store in number how many n2xs2 can be made before a loop is made to go back to 0th element of s1\\n    //break when a loop (back to 0th element is achieved)\\n    int p1{0}, s2count{0}, number{0};\\n    bool found = false;\\n    while(p1 <= s1size * n1)\\n        {\\n            if(s2count == n2)\\n            {\\n                s2count = 0;\\n                number++;\\n            }\\n            p1 = p1 + dpm[p1 % s1size];\\n            s2count ++;\\n\\n            if(p1 % s1size == 0)\\n           {\\n                found = true;\\n                break;\\n            }\\n        }\\n    \\n    //if no loop was found it is straightforward, just return the value of number\\n    if(!found) return number;\\n    \\n    int remaining = n1 * s1size % p1;\\n    int rem{0}, pp{0}, s2countrem{0};\\n    \\n    //if there is loop it is straightforward to calculate the total number occuring in the number of loops\\n    //but we also need to find out how many n2xs2 can be made outside of one incomplete loop\\n    while(pp <= remaining)\\n        {\\n            if(s2countrem == n2)\\n            {\\n                s2countrem = 0;\\n                rem++;\\n            }\\n            pp = pp + dpm[pp % s1size];\\n            s2countrem ++;\\n\\n        }\\n    \\n    long int temp = p1;\\n    temp = temp * n2 / s2count;\\n    \\n    int value =  n1 * s1size / p1 * number + n1 * s1size  / temp + rem;\\n    return value;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n    int s1size = s1.size(); int s2size = s2.size();\\n    vector<int> dpm (s1size, INT_MAX/2);\\n\\n    // store in dpm[i] how many elements from s1 does it take starting from ith element to make just one s2\\n    for(int i = 0; i < s1.size(); i++ )\\n    {\\n        int p1 = i, p2{0};\\n        bool found = false;\\n        while(p1 < s1.size() * n1 && !found)\\n        {\\n            if(s2[p2] == s1[p1 % s1size])\\n                {\\n                p2++;\\n                if(p2 == s2size)\\n                    found = true;\\n                }\\n            p1++;\\n        }\\n    if(found) dpm[i] = p1 - i;\\n    }\\n       \\n    //using dpm[i] calculate and store in number how many n2xs2 can be made before a loop is made to go back to 0th element of s1\\n    //break when a loop (back to 0th element is achieved)\\n    int p1{0}, s2count{0}, number{0};\\n    bool found = false;\\n    while(p1 <= s1size * n1)\\n        {\\n            if(s2count == n2)\\n            {\\n                s2count = 0;\\n                number++;\\n            }\\n            p1 = p1 + dpm[p1 % s1size];\\n            s2count ++;\\n\\n            if(p1 % s1size == 0)\\n           {\\n                found = true;\\n                break;\\n            }\\n        }\\n    \\n    //if no loop was found it is straightforward, just return the value of number\\n    if(!found) return number;\\n    \\n    int remaining = n1 * s1size % p1;\\n    int rem{0}, pp{0}, s2countrem{0};\\n    \\n    //if there is loop it is straightforward to calculate the total number occuring in the number of loops\\n    //but we also need to find out how many n2xs2 can be made outside of one incomplete loop\\n    while(pp <= remaining)\\n        {\\n            if(s2countrem == n2)\\n            {\\n                s2countrem = 0;\\n                rem++;\\n            }\\n            pp = pp + dpm[pp % s1size];\\n            s2countrem ++;\\n\\n        }\\n    \\n    long int temp = p1;\\n    temp = temp * n2 / s2count;\\n    \\n    int value =  n1 * s1size / p1 * number + n1 * s1size  / temp + rem;\\n    return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576273,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-count-the-repetitions",
                "content": "class Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};`class Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }\\n                }\\n            }\\n            for(int k=0;k<i;k++){\\n                if(posRest==rest[k]){b=k;last=i;break;}\\n            }\\n            rapport[i]=rap;rest[i]=posRest;\\n            if(b>=0)break;\\n        }\\n        int interval=last-b;\\n        if(b>=n1)return rapport[n1]/n2;\\n        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;\\n//corrected thanks to @zhiqing_xiao and @iaming \\n    }\\n};`",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        vector<int> rapport(102,-1);\\n        vector<int> rest(102,-1);\\n        int b=-1;int posRest=0;int rap=0;\\n        int last=-1;\\n        rapport[0]=rest[0]=0;//case when n=0\\n        for(int i=1;i<=s2.size()+1;i++){\\n            int j;\\n            for(j=0;j<s1.size();j++){\\n                if(s2[posRest]==s1[j]){\\n                    posRest++;\\n                    if(posRest==s2.size()){\\n                        rap++;\\n                        posRest=0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1526914,
                "title": "javascript-brute-force-4228ms",
                "content": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let cnt1 = cnt2 = i = j = 0;\\n    while (cnt1 < n1) {\\n        if (s1[i] == s2[j]) {\\n            j++;\\n            if (j == s2.length) {\\n                j = 0;\\n                cnt2++;\\n            }\\n        }\\n        i++;\\n        if (i == s1.length) {\\n            i = 0;\\n            cnt1++;\\n        }\\n    }\\n    return cnt2 / n2 >> 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getMaxRepetitions = (s1, n1, s2, n2) => {\\n    let cnt1 = cnt2 = i = j = 0;\\n    while (cnt1 < n1) {\\n        if (s1[i] == s2[j]) {\\n            j++;\\n            if (j == s2.length) {\\n                j = 0;\\n                cnt2++;\\n            }\\n        }\\n        i++;\\n        if (i == s1.length) {\\n            i = 0;\\n            cnt1++;\\n        }\\n    }\\n    return cnt2 / n2 >> 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504112,
                "title": "2ms-c-c-solution-by-finding-period",
                "content": "```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int cnt=0;\\n        int mark_s1=-1, mark_n1=-1, mark_cnt=-1, bLastPeriod=false;\\n        int i, j, k=0;\\n        for(i=0; i<n1; i++)\\n        {\\n            for(j=0; j<s1.length(); j++)\\n            {\\n                if(s1[j]!=s2[k]) continue;\\n                if(++k>=s2.length())\\n                {\\n                    k=0;\\n                    cnt++;\\n                    if(mark_s1==-1)\\n                    {\\n                        mark_s1=j;\\n                        mark_n1=i;\\n                        mark_cnt=cnt;\\n                    }\\n                    else\\n                    {\\n                        if(!bLastPeriod&& mark_s1==j) // found period\\n                        {\\n                            //i-mark_n1 is period\\n                            int more_periods=(n1-1-i)/(i-mark_n1);\\n                            i+=(more_periods*(i-mark_n1));\\n                            cnt+=(more_periods*(cnt-mark_cnt));\\n                            bLastPeriod=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt/n2; // cnt is repetitions of s2. needs to divide by n2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int cnt=0;\\n        int mark_s1=-1, mark_n1=-1, mark_cnt=-1, bLastPeriod=false;\\n        int i, j, k=0;\\n        for(i=0; i<n1; i++)\\n        {\\n            for(j=0; j<s1.length(); j++)\\n            {\\n                if(s1[j]!=s2[k]) continue;\\n                if(++k>=s2.length())\\n                {\\n                    k=0;\\n                    cnt++;\\n                    if(mark_s1==-1)\\n                    {\\n                        mark_s1=j;\\n                        mark_n1=i;\\n                        mark_cnt=cnt;\\n                    }\\n                    else\\n                    {\\n                        if(!bLastPeriod&& mark_s1==j) // found period\\n                        {\\n                            //i-mark_n1 is period\\n                            int more_periods=(n1-1-i)/(i-mark_n1);\\n                            i+=(more_periods*(i-mark_n1));\\n                            cnt+=(more_periods*(cnt-mark_cnt));\\n                            bLastPeriod=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return cnt/n2; // cnt is repetitions of s2. needs to divide by n2\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1449131,
                "title": "c-dynamic-programming-o-s1-size-s2-size-32-time",
                "content": "Let\\'s tackle the following problem:\\nSize of longest subsequence of \\n`s1*n = s1 s1 ... s1` (`n` times) which is a equal to a prefix of\\n`s2[j:] s2 ......` (infinite times) where `s2[j:]` is in python notation\\n\\nNow let `dp[i][j]` be the solution for `n=2^i` and `j`\\n\\nFinding `dp[0][j]` can be done by brute force.\\n```\\nfor(int i=0;i<s2.size();i++){\\n\\tdp[0][i] = 0;\\n\\tfor(int j=0;j<s1.size();j++){\\n\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t}\\n}\\n```\\n\\nAnd we have recurrence relation: `dp[i+1][j] = m + dp[i][(j+m)%N]` where `m = dp[i][j]` and `N = size of s2`.\\n\\nReason: \\n\\nLet `n = 2^i` then for `dp[i+1][j]` we need to find size of subsequence for  `s1*n + s1*n` matching with `s2[j:] s2 s2 ... `. \\n\\nThen `s1*n` has `m` matches which introduces an additional offset of `m%N` , hence the relation `dp[i+1][j] = m + dp[i][(j+m)%N]`\\n\\nSo we can find the dp in `O(32)` time. And the result can be calculated in the following way\\n```\\nfor(int i=0;i<32;i++){\\n\\tif(n1%2 == 1) {\\n\\t\\tint m = dp[i][offset];\\n\\t\\tk += m;\\n\\t\\toffset = (offset+m)%s2.size();\\n\\t}\\n\\tn1 /= 2;\\n}\\n```\\n\\nFull code:\\n```\\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n\\t#define int long long\\n\\tconst int N = 32;\\n\\tvector<vector<int>> dp(N, vector<int>(s2.size()));\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tdp[0][i] = 0;\\n\\t\\tfor(int j=0;j<s1.size();j++){\\n\\t\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tcout << dp[0][i] << \" \";\\n\\t}\\n\\n\\tfor(int i=1;i<N;i++){\\n\\t\\tfor(int j=0;j<s2.size();j++){\\n\\t\\t\\tdp[i][j] = dp[i-1][j] + dp[i-1][(j+dp[i-1][j])%s2.size()];\\n\\t\\t}\\n\\t}\\n\\n\\tint k = 0;\\n\\tint offset = 0;\\n\\tfor(int i=0;i<N;i++){\\n\\t\\tif(n1%2 == 1) {\\n\\t\\t\\tint m = dp[i][offset];\\n\\t\\t\\tk += m;\\n\\t\\t\\toffset = (offset+m)%s2.size();\\n\\t\\t}\\n\\t\\tn1 /= 2;\\n\\t}\\n\\t#undef int\\n\\treturn k/(n2*s2.size());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i=0;i<s2.size();i++){\\n\\tdp[0][i] = 0;\\n\\tfor(int j=0;j<s1.size();j++){\\n\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t}\\n}\\n```\n```\\nfor(int i=0;i<32;i++){\\n\\tif(n1%2 == 1) {\\n\\t\\tint m = dp[i][offset];\\n\\t\\tk += m;\\n\\t\\toffset = (offset+m)%s2.size();\\n\\t}\\n\\tn1 /= 2;\\n}\\n```\n```\\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n\\t#define int long long\\n\\tconst int N = 32;\\n\\tvector<vector<int>> dp(N, vector<int>(s2.size()));\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tdp[0][i] = 0;\\n\\t\\tfor(int j=0;j<s1.size();j++){\\n\\t\\t\\tif(s1[j]==s2[(i+dp[0][i])%s2.size()]) dp[0][i]++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i=0;i<s2.size();i++){\\n\\t\\tcout << dp[0][i] << \" \";\\n\\t}\\n\\n\\tfor(int i=1;i<N;i++){\\n\\t\\tfor(int j=0;j<s2.size();j++){\\n\\t\\t\\tdp[i][j] = dp[i-1][j] + dp[i-1][(j+dp[i-1][j])%s2.size()];\\n\\t\\t}\\n\\t}\\n\\n\\tint k = 0;\\n\\tint offset = 0;\\n\\tfor(int i=0;i<N;i++){\\n\\t\\tif(n1%2 == 1) {\\n\\t\\t\\tint m = dp[i][offset];\\n\\t\\t\\tk += m;\\n\\t\\t\\toffset = (offset+m)%s2.size();\\n\\t\\t}\\n\\t\\tn1 /= 2;\\n\\t}\\n\\t#undef int\\n\\treturn k/(n2*s2.size());\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1437481,
                "title": "efficient-linear-extrapolation-solution-in-c-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    static int getMaxRepetitions(string const& s1, int n1, string const& s2, int n2) {\\n        int const s1_len = s1.size();\\n        int const s2_len = s2.size();\\n        int s2_reps = 0;\\n        int s2_idx = 0;\\n        // \"match\" will store (s1_idx, (s1_reps, s2_reps)) whenever s1[s1_idx] matches s2[s2_len - 1]\\n        unordered_map<int, pair<int, int>> match;\\n        match.reserve(s1_len);\\n        for (int s1_reps = 0; s1_reps < n1; ++s1_reps) {\\n            bool has_match = false;\\n\\t\\t\\t// iterate over a fresh copy of s1\\n            for (int s1_idx = 0; s1_idx < s1_len; ++s1_idx) {\\n                if (s1[s1_idx] == s2[s2_idx]) {\\n                    has_match = true;\\n                    if (++s2_idx == s2_len) {\\n                        ++s2_reps;\\n                        s2_idx = 0;\\n                        auto iter = match.find(s1_idx);\\n                        if (iter != match.end()) {\\n                            auto const prev_s1_reps = iter->second.first;\\n                            auto const prev_s2_reps = iter->second.second;\\n                            // preform a linear extrapolation using the current (s1_reps, s2_reps)\\n                            // and the previous (s1_reps, s2_reps) to skip over a large number of\\n\\t\\t\\t\\t\\t\\t\\t// intermediate iterations\\n                            auto const n_iters = (n1 - 1 - s1_reps) / (s1_reps - prev_s1_reps);\\n                            s1_reps += n_iters * (s1_reps - prev_s1_reps);\\n                            s2_reps += n_iters * (s2_reps - prev_s2_reps);\\n                        } else {\\n                            match[s1_idx] = make_pair(s1_reps, s2_reps);\\n                        }\\n                    }\\n                }\\n            }\\n            if (!has_match)\\n                // If we did not make progress at all with the current copy of s1, then\\n\\t\\t\\t\\t// the char at s2[s2_idx] must be missing in s1. Therefore a full match is\\n\\t\\t\\t\\t// impossible.\\n                return 0;\\n        }\\n        return s2_reps / n2;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int getMaxRepetitions(string const& s1, int n1, string const& s2, int n2) {\\n        int const s1_len = s1.size();\\n        int const s2_len = s2.size();\\n        int s2_reps = 0;\\n        int s2_idx = 0;\\n        // \"match\" will store (s1_idx, (s1_reps, s2_reps)) whenever s1[s1_idx] matches s2[s2_len - 1]\\n        unordered_map<int, pair<int, int>> match;\\n        match.reserve(s1_len);\\n        for (int s1_reps = 0; s1_reps < n1; ++s1_reps) {\\n            bool has_match = false;\\n\\t\\t\\t// iterate over a fresh copy of s1\\n            for (int s1_idx = 0; s1_idx < s1_len; ++s1_idx) {\\n                if (s1[s1_idx] == s2[s2_idx]) {\\n                    has_match = true;\\n                    if (++s2_idx == s2_len) {\\n                        ++s2_reps;\\n                        s2_idx = 0;\\n                        auto iter = match.find(s1_idx);\\n                        if (iter != match.end()) {\\n                            auto const prev_s1_reps = iter->second.first;\\n                            auto const prev_s2_reps = iter->second.second;\\n                            // preform a linear extrapolation using the current (s1_reps, s2_reps)\\n                            // and the previous (s1_reps, s2_reps) to skip over a large number of\\n\\t\\t\\t\\t\\t\\t\\t// intermediate iterations\\n                            auto const n_iters = (n1 - 1 - s1_reps) / (s1_reps - prev_s1_reps);\\n                            s1_reps += n_iters * (s1_reps - prev_s1_reps);\\n                            s2_reps += n_iters * (s2_reps - prev_s2_reps);\\n                        } else {\\n                            match[s1_idx] = make_pair(s1_reps, s2_reps);\\n                        }\\n                    }\\n                }\\n            }\\n            if (!has_match)\\n                // If we did not make progress at all with the current copy of s1, then\\n\\t\\t\\t\\t// the char at s2[s2_idx] must be missing in s1. Therefore a full match is\\n\\t\\t\\t\\t// impossible.\\n                return 0;\\n        }\\n        return s2_reps / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236296,
                "title": "python3-solution-that-doesn-t-search-for-loops-bisection-comments-inside",
                "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1 = len(s1)\\n        l2 = len(s2)\\n        chars = set(s1)\\n        for c in s2:\\n            if c not in chars:\\n                return 0\\n        # if s2 contains some character not from s1, it\\'s impossible for any positive m\\n        \\n        Jumps = []\\n        def getchar(ofs):\\n            return s1[ofs%l1]\\n        for i in range(l1):\\n            cur = i\\n            for c in s2:\\n                while getchar(cur)!=c:\\n                    cur += 1\\n                cur += 1\\n            Jumps.append(cur-i)\\n        # Now, Jumps[i] contains how many chars do we have to move forward to find s2,\\n        # if we start from offset i.\\n        # We just have to know, how many times can we repeat this until we pass the limit l1*n1.\\n        # Bruteforce approach will time out, we must be more clever. We\\'ll use bisection, because\\n        # I don\\'t want to find loops.\\n        \\n        # jumplen functions calculates, how many chars do we have to move forward to find m copies of s2.\\n        # Now if we know maximum such m, that we don\\'t go pass the limit, we just return m//n2.\\n        # But first, we implement a special case, where m is a power of 2, using memoization.\\n        DP = dict()\\n        def jumplen_pow2(rem, pow2):\\n            assert(rem>=0 and rem<l1)\\n            key = (rem, pow2)\\n            if key in DP:\\n                return DP[key]\\n            if pow2==1:\\n                r = Jumps[rem]\\n            else:\\n                pow2 >>= 1\\n                r = jumplen(rem, pow2)\\n                r += jumplen((rem+r)%l1, pow2)\\n            DP[key] = r\\n            return r\\n        # Now to the general case. We just split m into sum of powers of 2, using binary representation.\\n        def jumplen(rem, m):\\n            if m==0:\\n                return 0\\n            pow2 = 1\\n            jl = 0\\n            while pow2<=m:\\n                if pow2&m:\\n                    l = jumplen_pow2(rem, pow2)\\n                    jl += l\\n                    rem = (rem+l)%l1\\n                pow2 <<= 1\\n            return jl\\n        # And we are ready to do the binary search for answer. First we find the borders.\\n        limit = l1*n1\\n        m = 1\\n        prev = 0\\n        while jumplen_pow2(0,m)<=limit:\\n            prev = m\\n            m <<= 1\\n        l,r = prev,m # the borders\\n        while r-l>1:\\n            m = l+(r-l)//2\\n            if jumplen(0,m)<=limit:\\n                l = m\\n            else:\\n                r = m\\n        return l//n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        l1 = len(s1)\\n        l2 = len(s2)\\n        chars = set(s1)\\n        for c in s2:\\n            if c not in chars:\\n                return 0\\n        # if s2 contains some character not from s1, it\\'s impossible for any positive m\\n        \\n        Jumps = []\\n        def getchar(ofs):\\n            return s1[ofs%l1]\\n        for i in range(l1):\\n            cur = i\\n            for c in s2:\\n                while getchar(cur)!=c:\\n                    cur += 1\\n                cur += 1\\n            Jumps.append(cur-i)\\n        # Now, Jumps[i] contains how many chars do we have to move forward to find s2,\\n        # if we start from offset i.\\n        # We just have to know, how many times can we repeat this until we pass the limit l1*n1.\\n        # Bruteforce approach will time out, we must be more clever. We\\'ll use bisection, because\\n        # I don\\'t want to find loops.\\n        \\n        # jumplen functions calculates, how many chars do we have to move forward to find m copies of s2.\\n        # Now if we know maximum such m, that we don\\'t go pass the limit, we just return m//n2.\\n        # But first, we implement a special case, where m is a power of 2, using memoization.\\n        DP = dict()\\n        def jumplen_pow2(rem, pow2):\\n            assert(rem>=0 and rem<l1)\\n            key = (rem, pow2)\\n            if key in DP:\\n                return DP[key]\\n            if pow2==1:\\n                r = Jumps[rem]\\n            else:\\n                pow2 >>= 1\\n                r = jumplen(rem, pow2)\\n                r += jumplen((rem+r)%l1, pow2)\\n            DP[key] = r\\n            return r\\n        # Now to the general case. We just split m into sum of powers of 2, using binary representation.\\n        def jumplen(rem, m):\\n            if m==0:\\n                return 0\\n            pow2 = 1\\n            jl = 0\\n            while pow2<=m:\\n                if pow2&m:\\n                    l = jumplen_pow2(rem, pow2)\\n                    jl += l\\n                    rem = (rem+l)%l1\\n                pow2 <<= 1\\n            return jl\\n        # And we are ready to do the binary search for answer. First we find the borders.\\n        limit = l1*n1\\n        m = 1\\n        prev = 0\\n        while jumplen_pow2(0,m)<=limit:\\n            prev = m\\n            m <<= 1\\n        l,r = prev,m # the borders\\n        while r-l>1:\\n            m = l+(r-l)//2\\n            if jumplen(0,m)<=limit:\\n                l = m\\n            else:\\n                r = m\\n        return l//n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233331,
                "title": "brute-force-solution",
                "content": "java code is:\\n# \\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int  count = 0, i = 0, j = 0;\\n        while (n1>0) {\\n            if(array1[i++]==array2[j])j++;\\n            if(j==array2.length){\\n                j=0;\\n                count++;\\n            }\\n            if(i==array1.length){\\n                i=0;\\n                n1--;\\n            }\\n        }\\n        return count / n2;\\n    }\\n}\\n\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        int  count = 0, i = 0, j = 0;\\n        while (n1>0) {\\n            if(array1[i++]==array2[j])j++;\\n            if(j==array2.length){\\n                j=0;\\n                count++;\\n            }\\n            if(i==array1.length){\\n                i=0;\\n                n1--;\\n            }\\n        }\\n        return count / n2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002643,
                "title": "c-code-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int l1 = s1.size();\\n        int l2 = s2.size();\\n        int p1 = 0; // pointer for s1, in range [0, n1*l1]\\n        int p2 = 0; // pointer for s2 in range [0, n2*l2*M]\\n        \\n        int o2p1[101][101]; // p1 value when offset on s1 & s2 is given\\n        int o2p2[101][101]; // p2 value when offset on s1 & s2 is given\\n        \\n        for (int i = 0; i <= 100; i++)\\n            for (int j = 0; j <= 100; j++){\\n                o2p1[i][j] = -1;\\n                o2p2[i][j] = -1;\\n            }\\n        \\n        while (p1 < l1 * n1){\\n            if (s1[p1 % l1] == s2[p2 % l2]){\\n                int off1 = p1 % l1; // p1\\'s offset across s1\\n                int off2 = p2 % l2; // p2\\'s offset across s2\\n                int prev1 = p1; // store p1 value before update\\n                int prev2 = p2; // store p2 value before update\\n                if (o2p1[off1][off2] != -1 && o2p2[off1][off2] != -1){ // repetition found\\n                    int times = (l1 * n1 - p1) / (p1 - o2p1[off1][off2]); // possible remaining repititions\\n                    p1 += times * (p1 - o2p1[off1][off2]); // update p1 by repititions\\n                    p2 += times * (p2 - o2p2[off1][off2]); // update p2 by repititions\\n                }\\n                else { // no repetition found\\n                    o2p1[off1][off2] = p1; // log down p1\\n                    o2p2[off1][off2] = p2; // log down p2\\n                }\\n                if (prev1 == p1 && prev2 == p2){ // no pointer update\\n                    p1 ++;\\n                    p2 ++;\\n                }\\n            }\\n            else\\n                p1 ++;\\n        }\\n        return (p2 / l2) / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int l1 = s1.size();\\n        int l2 = s2.size();\\n        int p1 = 0; // pointer for s1, in range [0, n1*l1]\\n        int p2 = 0; // pointer for s2 in range [0, n2*l2*M]\\n        \\n        int o2p1[101][101]; // p1 value when offset on s1 & s2 is given\\n        int o2p2[101][101]; // p2 value when offset on s1 & s2 is given\\n        \\n        for (int i = 0; i <= 100; i++)\\n            for (int j = 0; j <= 100; j++){\\n                o2p1[i][j] = -1;\\n                o2p2[i][j] = -1;\\n            }\\n        \\n        while (p1 < l1 * n1){\\n            if (s1[p1 % l1] == s2[p2 % l2]){\\n                int off1 = p1 % l1; // p1\\'s offset across s1\\n                int off2 = p2 % l2; // p2\\'s offset across s2\\n                int prev1 = p1; // store p1 value before update\\n                int prev2 = p2; // store p2 value before update\\n                if (o2p1[off1][off2] != -1 && o2p2[off1][off2] != -1){ // repetition found\\n                    int times = (l1 * n1 - p1) / (p1 - o2p1[off1][off2]); // possible remaining repititions\\n                    p1 += times * (p1 - o2p1[off1][off2]); // update p1 by repititions\\n                    p2 += times * (p2 - o2p2[off1][off2]); // update p2 by repititions\\n                }\\n                else { // no repetition found\\n                    o2p1[off1][off2] = p1; // log down p1\\n                    o2p2[off1][off2] = p2; // log down p2\\n                }\\n                if (prev1 == p1 && prev2 == p2){ // no pointer update\\n                    p1 ++;\\n                    p2 ++;\\n                }\\n            }\\n            else\\n                p1 ++;\\n        }\\n        return (p2 / l2) / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930408,
                "title": "c-0ms-100-dp-loop-detection",
                "content": "1 Using DP array to store {offset of s2, length matched by s2} for each s2 start offset\\n2 Once we detect loop, accelaate only once, but figuring out loop length and advance by times of loop length as far as possible. \\n3 After accelarate, just rely on dp array to advance.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int m1, string s2, int m2) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        vector<pair<int, int>> dp(n2, {-1,-1});\\n        int base = 0;\\n        int cnt = 0;\\n        int step = 1;\\n        bool acc = false;\\n        for (int c = 0; c < m1; c += step)\\n        {\\n            if (dp[base].first != -1)\\n            {\\n                // detect loop length\\n                if (!acc)\\n                {\\n                    acc = true;\\n                    int curcnt = dp[base].second;\\n                    int curbase = dp[base].first;\\n                    int l = 1;\\n                    \\n                    while (curbase != base)\\n                    {\\n                        l++;\\n                        curcnt += dp[curbase].second;\\n                        curbase = dp[curbase].first;\\n                    }\\n\\n                    // accelerate here\\n                    if (m1 >= c)\\n                    {\\n                        int r = (m1 - c) / l;\\n                        cnt += r * curcnt;\\n                        c += r * l;  \\n                        if (c >= m1)\\n                        {\\n                            break;\\n                        }\\n                    }\\n                }            \\n                \\n                cnt += dp[base].second;\\n                base = dp[base].first;\\n                continue;\\n            }\\n            int j = base;\\n            int cur = 0;\\n            for (int i = 0; i < n1; i++)\\n            {\\n                if (s1[i] == s2[j])\\n                {\\n                    j = (j + 1) % n2;\\n                    if (j == 0)\\n                    {\\n                        cur++;\\n                    }\\n                }\\n            }\\n            dp[base].first = j;\\n            dp[base].second = cur;\\n            base = j;\\n            cnt += cur;\\n        }\\n        return cnt / m2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int m1, string s2, int m2) {\\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        vector<pair<int, int>> dp(n2, {-1,-1});\\n        int base = 0;\\n        int cnt = 0;\\n        int step = 1;\\n        bool acc = false;\\n        for (int c = 0; c < m1; c += step)\\n        {\\n            if (dp[base].first != -1)\\n            {\\n                // detect loop length\\n                if (!acc)\\n                {\\n                    acc = true;\\n                    int curcnt = dp[base].second;\\n                    int curbase = dp[base].first;\\n                    int l = 1;\\n                    \\n                    while (curbase != base)\\n                    {\\n                        l++;\\n                        curcnt += dp[curbase].second;\\n                        curbase = dp[curbase].first;\\n                    }\\n\\n                    // accelerate here\\n                    if (m1 >= c)\\n                    {\\n                        int r = (m1 - c) / l;\\n                        cnt += r * curcnt;\\n                        c += r * l;  \\n                        if (c >= m1)\\n                        {\\n                            break;\\n                        }\\n                    }\\n                }            \\n                \\n                cnt += dp[base].second;\\n                base = dp[base].first;\\n                continue;\\n            }\\n            int j = base;\\n            int cur = 0;\\n            for (int i = 0; i < n1; i++)\\n            {\\n                if (s1[i] == s2[j])\\n                {\\n                    j = (j + 1) % n2;\\n                    if (j == 0)\\n                    {\\n                        cur++;\\n                    }\\n                }\\n            }\\n            dp[base].first = j;\\n            dp[base].second = cur;\\n            base = j;\\n            cnt += cur;\\n        }\\n        return cnt / m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842882,
                "title": "go-brute",
                "content": "```\\nfunc getMaxRepetitions(s1 string, n1 int, s2 string, n2 int) int {\\n    i1, i2 := 0, 0\\n    p1, p2 := 0, 0\\n    for i1 < n1 {\\n        if s1[p1] == s2[p2]  {\\n            p1++\\n            p2++\\n        } else {\\n            p1++\\n        }\\n        if p1 >= len(s1) {\\n            i1++\\n            p1 = 0\\n        }\\n        if p2 >= len(s2) {\\n            i2++\\n            p2 = 0\\n        }\\n    }\\n    return i2 / n2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getMaxRepetitions(s1 string, n1 int, s2 string, n2 int) int {\\n    i1, i2 := 0, 0\\n    p1, p2 := 0, 0\\n    for i1 < n1 {\\n        if s1[p1] == s2[p2]  {\\n            p1++\\n            p2++\\n        } else {\\n            p1++\\n        }\\n        if p1 >= len(s1) {\\n            i1++\\n            p1 = 0\\n        }\\n        if p2 >= len(s2) {\\n            i2++\\n            p2 = 0\\n        }\\n    }\\n    return i2 / n2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817198,
                "title": "java-o-n-3-with-memorization",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    String s1;String s2;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        dp=new int[s1.length()][2];\\n        int res=0;\\n        this.s1=s1;this.s2=s2;\\n        for(int i=0;i<s1.length();i++){\\n           record(i);\\n        }\\n        \\n        long total=s1.length()*n1;\\n        int cnt=0;\\n        while(cnt<total){\\n            int start=cnt%s1.length();\\n            int add=(dp[start][0]-1)*s1.length()+dp[start][1]+(s1.length()-start);\\n            if(cnt+add>total)break;\\n            res++;\\n            cnt+=add;\\n        }\\n        \\n        return res/n2;\\n    }\\n    \\n    public void record(int start){\\n        int i=0;int j=start;\\n        int cnt=0;boolean flag=true;\\n        while(i<s2.length()){\\n            if(cnt>s2.length()){\\n                flag=false;\\n                break;\\n            }\\n            if(s1.charAt(j)==s2.charAt(i))i++;\\n            j++;\\n            if(j==s1.length()){\\n                j=0;\\n                cnt++;\\n            }\\n        }\\n        if(flag){\\n            dp[start][0]=cnt;\\n        }else{\\n            dp[start][0]=1000000;\\n        }\\n        dp[start][1]=j;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    String s1;String s2;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        dp=new int[s1.length()][2];\\n        int res=0;\\n        this.s1=s1;this.s2=s2;\\n        for(int i=0;i<s1.length();i++){\\n           record(i);\\n        }\\n        \\n        long total=s1.length()*n1;\\n        int cnt=0;\\n        while(cnt<total){\\n            int start=cnt%s1.length();\\n            int add=(dp[start][0]-1)*s1.length()+dp[start][1]+(s1.length()-start);\\n            if(cnt+add>total)break;\\n            res++;\\n            cnt+=add;\\n        }\\n        \\n        return res/n2;\\n    }\\n    \\n    public void record(int start){\\n        int i=0;int j=start;\\n        int cnt=0;boolean flag=true;\\n        while(i<s2.length()){\\n            if(cnt>s2.length()){\\n                flag=false;\\n                break;\\n            }\\n            if(s1.charAt(j)==s2.charAt(i))i++;\\n            j++;\\n            if(j==s1.length()){\\n                j=0;\\n                cnt++;\\n            }\\n        }\\n        if(flag){\\n            dp[start][0]=cnt;\\n        }else{\\n            dp[start][0]=1000000;\\n        }\\n        dp[start][1]=j;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765447,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(s1.empty()) return 0;\\n\\n        std::vector<int> ws(s1.size(), 0);\\n\\n        int count = 0;\\n        int its = 0;\\n        int i = 0;\\n        int j = 0;\\n        int f = 0;\\n\\n        int curpos = 0;\\n        int lcount = 0;\\n\\n        while(its < n1){\\n            if(i == s1.size()){\\n                i = 0;\\n                ++its;\\n                continue;\\n            }\\n\\n            ++lcount;\\n\\n            if(s1[i] == s2[j]){\\n                \\n                if(j == 0){\\n                    curpos = i;\\n                   \\n                    if(ws[curpos]!=0){\\n                        int p = curpos;\\n                        std::stack<int> hops;\\n\\n                        int pos = curpos + its*s1.size();\\n                        int nxt = pos;\\n\\n                        do{\\n                            nxt = ws[p] + nxt;\\n                            hops.push(nxt - pos);\\n                            p = (p + ws[p])%s1.size();\\n                            while(ws[p]==0){\\n                                ++p;\\n                                ++nxt;\\n                                if(p == s1.size()){\\n                                    p = 0;\\n                                }\\n                            }\\n                        }while(p!=curpos);\\n\\n                        hops.push(nxt-pos);\\n\\n\\n                        if(!hops.empty()){\\n                            int lits = (n1*s1.size() - pos)/hops.top();\\n                            if(lits > 0){\\n                                count = count + (hops.size()-1)*lits;\\n                                pos = pos + hops.top()*lits;\\n                            }\\n                        }\\n                     \\n                        while((!hops.empty())&& (pos < n1*s1.size())){\\n                            if(pos + hops.top() < n1*s1.size()){\\n                                count += hops.size();\\n                                pos = pos + hops.top();\\n                            }\\n                            else{\\n                                hops.pop();\\n                            }\\n                        }\\n\\n                        return count/n2;\\n                    }             \\n\\n                }\\n                \\n                ++i;\\n                ++j;\\n\\n                if(j == s2.size()){\\n                    ++count;\\n                    j = 0;\\n                    ws[curpos] = lcount;\\n                    lcount = 0;\\n                }\\n                f = 0;\\n            }\\n            else{\\n                ++i;\\n                ++f;\\n\\n                if(j == 0){\\n                    lcount = 0;\\n                }\\n\\n                if(f == s1.size()){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(s1.empty()) return 0;\\n\\n        std::vector<int> ws(s1.size(), 0);\\n\\n        int count = 0;\\n        int its = 0;\\n        int i = 0;\\n        int j = 0;\\n        int f = 0;\\n\\n        int curpos = 0;\\n        int lcount = 0;\\n\\n        while(its < n1){\\n            if(i == s1.size()){\\n                i = 0;\\n                ++its;\\n                continue;\\n            }\\n\\n            ++lcount;\\n\\n            if(s1[i] == s2[j]){\\n                \\n                if(j == 0){\\n                    curpos = i;\\n                   \\n                    if(ws[curpos]!=0){\\n                        int p = curpos;\\n                        std::stack<int> hops;\\n\\n                        int pos = curpos + its*s1.size();\\n                        int nxt = pos;\\n\\n                        do{\\n                            nxt = ws[p] + nxt;\\n                            hops.push(nxt - pos);\\n                            p = (p + ws[p])%s1.size();\\n                            while(ws[p]==0){\\n                                ++p;\\n                                ++nxt;\\n                                if(p == s1.size()){\\n                                    p = 0;\\n                                }\\n                            }\\n                        }while(p!=curpos);\\n\\n                        hops.push(nxt-pos);\\n\\n\\n                        if(!hops.empty()){\\n                            int lits = (n1*s1.size() - pos)/hops.top();\\n                            if(lits > 0){\\n                                count = count + (hops.size()-1)*lits;\\n                                pos = pos + hops.top()*lits;\\n                            }\\n                        }\\n                     \\n                        while((!hops.empty())&& (pos < n1*s1.size())){\\n                            if(pos + hops.top() < n1*s1.size()){\\n                                count += hops.size();\\n                                pos = pos + hops.top();\\n                            }\\n                            else{\\n                                hops.pop();\\n                            }\\n                        }\\n\\n                        return count/n2;\\n                    }             \\n\\n                }\\n                \\n                ++i;\\n                ++j;\\n\\n                if(j == s2.size()){\\n                    ++count;\\n                    j = 0;\\n                    ws[curpos] = lcount;\\n                    lcount = 0;\\n                }\\n                f = 0;\\n            }\\n            else{\\n                ++i;\\n                ++f;\\n\\n                if(j == 0){\\n                    lcount = 0;\\n                }\\n\\n                if(f == s1.size()){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count/n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720023,
                "title": "java-3-ms-solution-o-l-2",
                "content": "Firstly we calculate the **counts** array which is number of s1 required to contain 1,2,3,4,... s2s.  For each character in s2, we greedily identify the next matching character in s1 in circular fashion. We keep track of the offset of s2[0] in s1 and remember the firs time an offset is used the second time and stop when an offset is used the third time. This way we obtain sufficient data to know that the initial [s1,b] contains [s2,idx], then every [s1,q] contains [s2, p]. The complexity is O(L^2) where L is the length of s1 and s2. The result counts array is O(L) length.\\n\\nThe we use binary search in **getNumberOfS2n2** to identify number of [s2,n2] that fit in [s1,n1]. The function **getNumS1ForS2k** calculates number of s1 required to hold [s2,k].\\n\\n```\\n  public static int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    if (n1 == 0 || n2 == 0) {\\n      return 0;\\n    }\\n    // If s2 contain any character not appear in s1, return 0.\\n    for (char c : s2.toCharArray()) {\\n      if (s1.indexOf(c) < 0) {\\n        return 0;\\n      }\\n    }\\n\\n    List<Integer> counts = calculateCounts(s1, s2);\\n    return getNumberOfS2n2(n1, n2, counts);\\n  }\\n\\n  // Calculate counts array in which counts[i] is the number of s1 required to contain [s2,i].\\n  // The special counts[0] hold the index when first observation of repeat offset.\\n  // We stop when observe the start offset the third time. For examples:\\n  //   1. cba abc => 1,3,5\\n  //   2. acb ab => 1,1,2\\n  //   3. aaa aa => 3,1,2,2,3,4,4\\n  //   4. baba baab => 2,2,3,5,6\\n  //   5. bacaba abacab => 2,2,3,4\\n  //   6. niconiconi nico => 3,1,1,2,2,3\\n  static List<Integer> calculateCounts(String s1, String s2) {\\n    int m = s1.length();\\n    int n = s2.length();\\n    List<Integer> counts = new ArrayList<>();\\n    counts.add(0);\\n\\n    int nums1 = 0;\\n    // Map from index in s1 of the first character of s2 to number of times such index is seen.\\n    Map<Integer, Integer> seen = new HashMap<>();\\n    int j = m-1;\\n    while (true) {\\n      for (int i = 0; i < n; i++) {\\n        if (j == m-1) {\\n          nums1++;\\n          j = 0;\\n        } else {\\n          j++;\\n        }\\n        int k = indexOf(s1, s2.charAt(i), j);\\n        if (k < j) {\\n          nums1++;\\n        }\\n        if (i == 0) {\\n          seen.put(k, seen.getOrDefault(k, 0) + 1);\\n          if (seen.get(k) == 2 && counts.get(0) == 0) {\\n            counts.set(0, counts.size() - 1);\\n          } else if (seen.get(k) == 3) {\\n            // System.out.format(\"%s %s %s\\\\n\", s1, s2, Utils.join(counts));\\n            return counts;\\n          }\\n        }\\n        j = k;\\n      }\\n      counts.add(nums1);\\n    }\\n  }\\n\\n  // Gets number of [s2,n2] fit in [s1,n1].\\n  // Note that counts[p] = q means [s1,q] contain [s2,p],\\n  static int getNumberOfS2n2(int n1, int n2, List<Integer> counts) {\\n    long l = 0;\\n    long h = Integer.MAX_VALUE;\\n    while (l < h) {\\n      long m = (l + 1 == h) ? h : (l+h)/2;\\n      // number of s1 required to hold [s2, m*n2]\\n      long nums1 = getNumS1ForS2k(m * n2, counts);\\n      if (nums1 > n1) {\\n        h = m - 1;\\n      } else {\\n        l = m;\\n      }\\n    }\\n    return (int) l;\\n  }\\n\\n  // Calculate number of s1 to hold [s2,k]\\n  static long getNumS1ForS2k(long k, List<Integer> counts) {\\n    if (k < counts.size()) {\\n      return counts.get((int) k);\\n    } else {\\n      int idx = counts.get(0);\\n      int len = counts.size();\\n      int b = counts.get(idx);\\n      // The initial [s1,b] contains [s2,idx], then every [s1,q] contains [s2, p]\\n      long q = counts.get(len-1) - counts.get(idx);\\n      int p = len - 1 - idx;\\n\\n      long ans = b;\\n      k -= idx;\\n      ans += q * (k / p);\\n      k %= p;\\n      if (k > 0) {\\n        ans += counts.get((int) k);\\n      }\\n      return ans;\\n    }\\n  }\\n\\n  // Gets the circular next index of character c in s on or after index i\\n  static int indexOf(String s, char c, int i) {\\n    int k = s.indexOf(c, i);\\n    return k >= 0 ? k : s.indexOf(c, 0);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n    if (n1 == 0 || n2 == 0) {\\n      return 0;\\n    }\\n    // If s2 contain any character not appear in s1, return 0.\\n    for (char c : s2.toCharArray()) {\\n      if (s1.indexOf(c) < 0) {\\n        return 0;\\n      }\\n    }\\n\\n    List<Integer> counts = calculateCounts(s1, s2);\\n    return getNumberOfS2n2(n1, n2, counts);\\n  }\\n\\n  // Calculate counts array in which counts[i] is the number of s1 required to contain [s2,i].\\n  // The special counts[0] hold the index when first observation of repeat offset.\\n  // We stop when observe the start offset the third time. For examples:\\n  //   1. cba abc => 1,3,5\\n  //   2. acb ab => 1,1,2\\n  //   3. aaa aa => 3,1,2,2,3,4,4\\n  //   4. baba baab => 2,2,3,5,6\\n  //   5. bacaba abacab => 2,2,3,4\\n  //   6. niconiconi nico => 3,1,1,2,2,3\\n  static List<Integer> calculateCounts(String s1, String s2) {\\n    int m = s1.length();\\n    int n = s2.length();\\n    List<Integer> counts = new ArrayList<>();\\n    counts.add(0);\\n\\n    int nums1 = 0;\\n    // Map from index in s1 of the first character of s2 to number of times such index is seen.\\n    Map<Integer, Integer> seen = new HashMap<>();\\n    int j = m-1;\\n    while (true) {\\n      for (int i = 0; i < n; i++) {\\n        if (j == m-1) {\\n          nums1++;\\n          j = 0;\\n        } else {\\n          j++;\\n        }\\n        int k = indexOf(s1, s2.charAt(i), j);\\n        if (k < j) {\\n          nums1++;\\n        }\\n        if (i == 0) {\\n          seen.put(k, seen.getOrDefault(k, 0) + 1);\\n          if (seen.get(k) == 2 && counts.get(0) == 0) {\\n            counts.set(0, counts.size() - 1);\\n          } else if (seen.get(k) == 3) {\\n            // System.out.format(\"%s %s %s\\\\n\", s1, s2, Utils.join(counts));\\n            return counts;\\n          }\\n        }\\n        j = k;\\n      }\\n      counts.add(nums1);\\n    }\\n  }\\n\\n  // Gets number of [s2,n2] fit in [s1,n1].\\n  // Note that counts[p] = q means [s1,q] contain [s2,p],\\n  static int getNumberOfS2n2(int n1, int n2, List<Integer> counts) {\\n    long l = 0;\\n    long h = Integer.MAX_VALUE;\\n    while (l < h) {\\n      long m = (l + 1 == h) ? h : (l+h)/2;\\n      // number of s1 required to hold [s2, m*n2]\\n      long nums1 = getNumS1ForS2k(m * n2, counts);\\n      if (nums1 > n1) {\\n        h = m - 1;\\n      } else {\\n        l = m;\\n      }\\n    }\\n    return (int) l;\\n  }\\n\\n  // Calculate number of s1 to hold [s2,k]\\n  static long getNumS1ForS2k(long k, List<Integer> counts) {\\n    if (k < counts.size()) {\\n      return counts.get((int) k);\\n    } else {\\n      int idx = counts.get(0);\\n      int len = counts.size();\\n      int b = counts.get(idx);\\n      // The initial [s1,b] contains [s2,idx], then every [s1,q] contains [s2, p]\\n      long q = counts.get(len-1) - counts.get(idx);\\n      int p = len - 1 - idx;\\n\\n      long ans = b;\\n      k -= idx;\\n      ans += q * (k / p);\\n      k %= p;\\n      if (k > 0) {\\n        ans += counts.get((int) k);\\n      }\\n      return ans;\\n    }\\n  }\\n\\n  // Gets the circular next index of character c in s on or after index i\\n  static int indexOf(String s, char c, int i) {\\n    int k = s.indexOf(c, i);\\n    return k >= 0 ? k : s.indexOf(c, 0);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699246,
                "title": "explained-with-loop-cycles-amortized-o-1",
                "content": "While we\\'re looping up to N1 calculated cycles with remainders, note that at worst case, only one character is pushed to the remainder, and character string size limit is 100, so effectively this makes all calculations bounded at 100 iterations, and hence can be considered amortized constant.\\n\\n```\\n#include <algorithm>\\n\\nstruct cycle\\n{\\n    int result;\\n    std::string remainder;\\n};\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n       \\n        //Given s1 = \"baba\" and s2 = \"ab\", we could say that for\\n        //howManyS1Consumed = 1, howManyS2Consumed  = 1 ( baba -> aba -> ab ), \\n        //but for howManyS1Consumed = 2 , we could generate howManyS3Consumed = 3\\n        //( \"babababa\" -> \"abababa\", \"ababab\")\\n        \\n        //This could be broken into following steps:\\n        //a) Remainder = \"\", \"baba\" => \"aba\" => \"ab\", result = 1, a is pushed to remainder\\n        //b) Remainder = \"a\", \"baba\" => \"(a)b\" + \"aba\", result = 2, a is pushed to remainder again and cycle is closed -> if we found a cycle loop it means we can stop as we\\'ll reuse this.\\n        \\n        std::unordered_map<std::string, int> calculatedCyclesMap; \\n        std::vector<struct cycle> calculatedCycles;\\n        int cycleLoopStart = INT_MAX;\\n        std::string remainder;        \\n        int s2Length = s2.length();\\n        \\n        int calculatedCyclesNumber = 0;\\n        while(calculatedCyclesNumber != n1)\\n        {\\n            auto cycleLoopIterator = calculatedCyclesMap.find(remainder);\\n            if(cycleLoopIterator != calculatedCyclesMap.end())\\n            {\\n                cycleLoopStart = cycleLoopIterator->second;\\n                //We\\'re at the beginning of an already calculated cycle loop\\n                break;\\n            }\\n            \\n            struct cycle calculatedCycle;\\n            calculatedCycle.remainder = remainder;\\n            int howManyS2Consumed = 0;\\n            int s2Index = remainder.size();\\n            for(int i = 0; i < s1.size(); ++i)\\n            {\\n                if(s1[i] == s2[s2Index])\\n                {\\n                    s2Index++;\\n                    if(s2Index == s2Length)\\n                    {\\n                        howManyS2Consumed++;\\n                        s2Index = 0;\\n                    }\\n                }\\n            }\\n            \\n            calculatedCycle.result = howManyS2Consumed; \\n            calculatedCycles.push_back(calculatedCycle);\\n            //Points to increasing indexes\\n            calculatedCyclesMap.insert(make_pair(remainder,calculatedCyclesNumber));\\n            remainder = s2.substr(0, s2Index);\\n            calculatedCyclesNumber++;\\n        }\\n        \\n        //Now we have 1-min(N1,100) cycles in calculatedCycles\\n        //min(N1,100), because in worst case, we will be pushing one character\\n        //into the remainder with every cycle ( remainder is built as a substring\\n        //from 0 to s2Index, where s2Index is from 0 to s2Length, and s2Length max\\n        //is 100 )\\n        //Also, optionally, we have a cycleLoopStart such as there\\'s a part\\n        //from 0 to cycleLoopStart which does not \\n        //wrap around, and then from cycleLoopStart to calculatedCycles.size()\\n        //which will loop around ( that is, upon applying this loop over and \\n        //over again, we arrive to the same result )\\n        \\n        //The final result\\n        int result = 0;\\n        \\n        for(int i = 0; i < std::min((int)cycleLoopStart, (int)calculatedCycles.size()); ++i)\\n        {\\n            result += calculatedCycles[i].result;\\n        }\\n        \\n        if(cycleLoopStart != INT_MAX)\\n        {\\n            int cycleLoopSize = calculatedCycles.size() - cycleLoopStart;\\n            int cyclesRemaining = n1 - cycleLoopStart; //cycleLoopStart = how many\\n            //cycles were already used in pre cycle loop stage.\\n            \\n            int fullCycleLoops = cyclesRemaining / cycleLoopSize;\\n            int partialCycleLoopSteps = cyclesRemaining % cycleLoopSize;\\n            int fullCycleResult = 0;\\n            int partialCycleResult = 0;\\n            bool partialCycleFinalized = (partialCycleLoopSteps == 0);            \\n            for(int i = 0; i < cycleLoopSize; ++i)\\n            {\\n                struct cycle &currentLoopCycle = calculatedCycles[cycleLoopStart + i];\\n                fullCycleResult += currentLoopCycle.result;\\n                if(!partialCycleFinalized)\\n                {\\n                    partialCycleResult += currentLoopCycle.result;\\n                    if((i + 1) == partialCycleLoopSteps)\\n                    {\\n                        partialCycleFinalized = true;\\n                    }                    \\n                }\\n            }\\n            \\n            result += (fullCycleResult * fullCycleLoops);\\n            result += partialCycleResult;\\n            \\n        }\\n\\t\\t\\n        //Finally, split the number of found s2\\'s by the n2 so that we get the actual amount of found S2\\'s\\n        return result / n2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <algorithm>\\n\\nstruct cycle\\n{\\n    int result;\\n    std::string remainder;\\n};\\n\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n       \\n        //Given s1 = \"baba\" and s2 = \"ab\", we could say that for\\n        //howManyS1Consumed = 1, howManyS2Consumed  = 1 ( baba -> aba -> ab ), \\n        //but for howManyS1Consumed = 2 , we could generate howManyS3Consumed = 3\\n        //( \"babababa\" -> \"abababa\", \"ababab\")\\n        \\n        //This could be broken into following steps:\\n        //a) Remainder = \"\", \"baba\" => \"aba\" => \"ab\", result = 1, a is pushed to remainder\\n        //b) Remainder = \"a\", \"baba\" => \"(a)b\" + \"aba\", result = 2, a is pushed to remainder again and cycle is closed -> if we found a cycle loop it means we can stop as we\\'ll reuse this.\\n        \\n        std::unordered_map<std::string, int> calculatedCyclesMap; \\n        std::vector<struct cycle> calculatedCycles;\\n        int cycleLoopStart = INT_MAX;\\n        std::string remainder;        \\n        int s2Length = s2.length();\\n        \\n        int calculatedCyclesNumber = 0;\\n        while(calculatedCyclesNumber != n1)\\n        {\\n            auto cycleLoopIterator = calculatedCyclesMap.find(remainder);\\n            if(cycleLoopIterator != calculatedCyclesMap.end())\\n            {\\n                cycleLoopStart = cycleLoopIterator->second;\\n                //We\\'re at the beginning of an already calculated cycle loop\\n                break;\\n            }\\n            \\n            struct cycle calculatedCycle;\\n            calculatedCycle.remainder = remainder;\\n            int howManyS2Consumed = 0;\\n            int s2Index = remainder.size();\\n            for(int i = 0; i < s1.size(); ++i)\\n            {\\n                if(s1[i] == s2[s2Index])\\n                {\\n                    s2Index++;\\n                    if(s2Index == s2Length)\\n                    {\\n                        howManyS2Consumed++;\\n                        s2Index = 0;\\n                    }\\n                }\\n            }\\n            \\n            calculatedCycle.result = howManyS2Consumed; \\n            calculatedCycles.push_back(calculatedCycle);\\n            //Points to increasing indexes\\n            calculatedCyclesMap.insert(make_pair(remainder,calculatedCyclesNumber));\\n            remainder = s2.substr(0, s2Index);\\n            calculatedCyclesNumber++;\\n        }\\n        \\n        //Now we have 1-min(N1,100) cycles in calculatedCycles\\n        //min(N1,100), because in worst case, we will be pushing one character\\n        //into the remainder with every cycle ( remainder is built as a substring\\n        //from 0 to s2Index, where s2Index is from 0 to s2Length, and s2Length max\\n        //is 100 )\\n        //Also, optionally, we have a cycleLoopStart such as there\\'s a part\\n        //from 0 to cycleLoopStart which does not \\n        //wrap around, and then from cycleLoopStart to calculatedCycles.size()\\n        //which will loop around ( that is, upon applying this loop over and \\n        //over again, we arrive to the same result )\\n        \\n        //The final result\\n        int result = 0;\\n        \\n        for(int i = 0; i < std::min((int)cycleLoopStart, (int)calculatedCycles.size()); ++i)\\n        {\\n            result += calculatedCycles[i].result;\\n        }\\n        \\n        if(cycleLoopStart != INT_MAX)\\n        {\\n            int cycleLoopSize = calculatedCycles.size() - cycleLoopStart;\\n            int cyclesRemaining = n1 - cycleLoopStart; //cycleLoopStart = how many\\n            //cycles were already used in pre cycle loop stage.\\n            \\n            int fullCycleLoops = cyclesRemaining / cycleLoopSize;\\n            int partialCycleLoopSteps = cyclesRemaining % cycleLoopSize;\\n            int fullCycleResult = 0;\\n            int partialCycleResult = 0;\\n            bool partialCycleFinalized = (partialCycleLoopSteps == 0);            \\n            for(int i = 0; i < cycleLoopSize; ++i)\\n            {\\n                struct cycle &currentLoopCycle = calculatedCycles[cycleLoopStart + i];\\n                fullCycleResult += currentLoopCycle.result;\\n                if(!partialCycleFinalized)\\n                {\\n                    partialCycleResult += currentLoopCycle.result;\\n                    if((i + 1) == partialCycleLoopSteps)\\n                    {\\n                        partialCycleFinalized = true;\\n                    }                    \\n                }\\n            }\\n            \\n            result += (fullCycleResult * fullCycleLoops);\\n            result += partialCycleResult;\\n            \\n        }\\n\\t\\t\\n        //Finally, split the number of found s2\\'s by the n2 so that we get the actual amount of found S2\\'s\\n        return result / n2;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 616597,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        for(auto c : s2) {\\n            // preventive checkings, it could be O(n), but who cares.\\n            if (s1.find(c) == string::npos) return 0;\\n        }\\n        int p1 = 0, p2 = 0, mark = 0;\\n        while(p1 < s1.length() * n1) {\\n            char c = s2[p2 % s2.length()];\\n            while(s1[p1 % s1.length()] != c && p1 < s1.length() * n1) p1 ++;\\n            p2++;\\n            p1++;\\n            if (p2 % s2.length() == 0) {\\n                if (p2 == s2.length()) {\\n                    mark = p1; // mark the position in s1, when the first s2 ends\\n                } else if (p1 % s1.length() == mark % s1.length()) {\\n                    int round = (s1.length() * n1 - p1) / (p1 - mark);\\n                    p1 += round * (p1 - mark);\\n                    p2 += round * (p2 - s2.length());\\n                }\\n            }\\n        }\\n        return p2 / s2.length() / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605918,
                "title": "extremely-concise-and-fast-solution",
                "content": "time complexity: O(n1 * len(s1)), theoretically faster than the best solution so far\\n```python\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if not set(s1) >= set(s2):\\n            return 0\\n        s1 = \\'\\'.join(ch for ch in s1 if ch in set(s2))\\n        i2 = 0\\n        start = [0] * len(s2)\\n        start[0] = (0, 0)\\n        count_round = [0] * (n1 + 1)\\n        for round in range(1, n1 + 1):\\n            for ch in s1:\\n                if s2[i2 % len(s2)] == ch:\\n                    i2 += 1\\n            c, i = divmod(i2, len(s2))\\n            if not start[i]:\\n                start[i] = (round, c)\\n                count_round[round] = c\\n            else:\\n                pre_round, pre_c = start[i]\\n                q, r = divmod(n1 - pre_round, round - pre_round)\\n                return ((c - pre_c) * q + count_round[pre_round + r]) // n2\\n        return i2 // (len(s2) * n2)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        if not set(s1) >= set(s2):\\n            return 0\\n        s1 = \\'\\'.join(ch for ch in s1 if ch in set(s2))\\n        i2 = 0\\n        start = [0] * len(s2)\\n        start[0] = (0, 0)\\n        count_round = [0] * (n1 + 1)\\n        for round in range(1, n1 + 1):\\n            for ch in s1:\\n                if s2[i2 % len(s2)] == ch:\\n                    i2 += 1\\n            c, i = divmod(i2, len(s2))\\n            if not start[i]:\\n                start[i] = (round, c)\\n                count_round[round] = c\\n            else:\\n                pre_round, pre_c = start[i]\\n                q, r = divmod(n1 - pre_round, round - pre_round)\\n                return ((c - pre_c) * q + count_round[pre_round + r]) // n2\\n        return i2 // (len(s2) * n2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532452,
                "title": "accepted-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            int fullS1Length = n1 * s1.Length;\\n            IDictionary<(int i, int j), (int i, int j)> repeatingMap = new Dictionary<(int i, int j), (int i, int j)>();\\n            while (i < fullS1Length)\\n            {\\n                var modI = i % s1.Length;\\n                var modJ = j % s2.Length;\\n\\n                if (s1[modI] == s2[modJ])\\n                {\\n\\n                    if (repeatingMap.ContainsKey((modI, modJ)))\\n                    {\\n                        (int i, int j) prevMatch = repeatingMap[(modI, modJ)];\\n                        var l1 = i - prevMatch.i;\\n                        var l2 = j - prevMatch.j;\\n                        var remains = (fullS1Length - i) / l1;\\n                        i += l1 * remains;\\n                        j += l2 * remains;\\n\\n                        if (i >= fullS1Length)\\n                        {\\n                             return j / s2.Length / n2;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        repeatingMap[(modI, modJ)] = (i,j);\\n                    }\\n\\n                    j++;\\n                }\\n\\n                i++;\\n            }\\n\\n            return j / s2.Length / n2;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            int fullS1Length = n1 * s1.Length;\\n            IDictionary<(int i, int j), (int i, int j)> repeatingMap = new Dictionary<(int i, int j), (int i, int j)>();\\n            while (i < fullS1Length)\\n            {\\n                var modI = i % s1.Length;\\n                var modJ = j % s2.Length;\\n\\n                if (s1[modI] == s2[modJ])\\n                {\\n\\n                    if (repeatingMap.ContainsKey((modI, modJ)))\\n                    {\\n                        (int i, int j) prevMatch = repeatingMap[(modI, modJ)];\\n                        var l1 = i - prevMatch.i;\\n                        var l2 = j - prevMatch.j;\\n                        var remains = (fullS1Length - i) / l1;\\n                        i += l1 * remains;\\n                        j += l2 * remains;\\n\\n                        if (i >= fullS1Length)\\n                        {\\n                             return j / s2.Length / n2;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        repeatingMap[(modI, modJ)] = (i,j);\\n                    }\\n\\n                    j++;\\n                }\\n\\n                i++;\\n            }\\n\\n            return j / s2.Length / n2;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471770,
                "title": "simple-clean-python-solution",
                "content": "```\\nclass Solution2:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        repeatCount = [0] * (n1 + 1)\\n        nextIndex = [0] * (n1 + 1)\\n        j, count = 0, 0\\n\\n        for k in range(1, n1 + 1):\\n            for i in range(len(s1)):\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == len(s2):\\n                        j = 0\\n                        count += 1\\n            repeatCount[k] = count\\n            nextIndex[k] = j\\n\\n            for start in range(k):\\n                if nextIndex[start] == j:\\n                    prefixCount = repeatCount[start]\\n                    patternCount = (n1 - start) // (k - start) * (repeatCount[k] - prefixCount)\\n                    suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    return (prefixCount + patternCount + suffixCount) // n2\\n\\n        return repeatCount[n1] // n2\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution2:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        repeatCount = [0] * (n1 + 1)\\n        nextIndex = [0] * (n1 + 1)\\n        j, count = 0, 0\\n\\n        for k in range(1, n1 + 1):\\n            for i in range(len(s1)):\\n                if s1[i] == s2[j]:\\n                    j += 1\\n                    if j == len(s2):\\n                        j = 0\\n                        count += 1\\n            repeatCount[k] = count\\n            nextIndex[k] = j\\n\\n            for start in range(k):\\n                if nextIndex[start] == j:\\n                    prefixCount = repeatCount[start]\\n                    patternCount = (n1 - start) // (k - start) * (repeatCount[k] - prefixCount)\\n                    suffixCount = repeatCount[start + (n1 - start) % (k - start)] - prefixCount\\n                    return (prefixCount + patternCount + suffixCount) // n2\\n\\n        return repeatCount[n1] // n2\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395920,
                "title": "python-beat-100-inspired-by-70664914",
                "content": "class Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        idx2 = 0\\n        nextIdx = [0]\\n        rounds2 = [0]\\n        repeats2 = 0\\n        \\n        for rounds in range(min(len(s2)+1, n1)):\\n            count = 0\\n            for idx1 in range(len(s1)):\\n                if s1[idx1] == s2[idx2]:\\n                    idx2 += 1\\n                    count += 1\\n                    if idx2 == len(s2):\\n                        repeats2 += 1\\n                        idx2 = 0\\n            for i in range(len(nextIdx)):\\n                if nextIdx[i] == idx2:\\n                    return (rounds2[i] + ((n1-i) / (rounds + 1 - i))*(repeats2 - rounds2[i]) + rounds2[(n1-i) % (rounds + 1 - i)]) / n2\\n            nextIdx.append(idx2)\\n            rounds2.append(repeats2)\\n            if count == 0:\\n                return(0)\\n        return(rounds2[n1]/n2)\\n                    \\n                    \\n                    \\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        idx2 = 0\\n        nextIdx = [0]\\n        rounds2 = [0]\\n        repeats2 = 0\\n        \\n        for rounds in range(min(len(s2)+1, n1)):\\n            count = 0\\n            for idx1 in range(len(s1)):\\n                if s1[idx1] == s2[idx2]:\\n                    idx2 += 1\\n                    count += 1\\n                    if idx2 == len(s2):\\n                        repeats2 += 1\\n                        idx2 = 0\\n            for i in range(len(nextIdx)):\\n                if nextIdx[i] == idx2:\\n                    return (rounds2[i] + ((n1-i) / (rounds + 1 - i))*(repeats2 - rounds2[i]) + rounds2[(n1-i) % (rounds + 1 - i)]) / n2\\n            nextIdx.append(idx2)\\n            rounds2.append(repeats2)\\n            if count == 0:\\n                return(0)\\n        return(rounds2[n1]/n2)\\n                    \\n                    \\n                    \\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 369466,
                "title": "from-brute-force-to-optimal-solution-1ms",
                "content": "1. Let\\'s start with the most straightforard solution. Check [s1,n1] against s2 directly to find the max number of match , noted as jCount. Since jCount = M*n2, then jCount/n2 is the result;\\n```\\n    //brute force - tle\\n    private int sln1(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\\n\\n2. There are a lot duplicated matches during brute force search. For example, s1 = abab, s2=aaa\\ns1s1=abababab\\ns2s2=aaaaaa\\ns1s1s1=abababababab\\n...\\nThen we know 3 s1 can match exactly 2 s2, there is not need to check [s1, 6], [s1, 9], they will mach 4 s2 and 6 s2 according to the ratio 3:2.\\nHow do we find the ratio? Every time we are comparing a character in s1 and a character in s2, we check their indexes i, j. If they reach the end of their length at the same point, that is a exact match. Since I reset j everytime it reaches the end of s2, we can check if j ==0 to find the exact match. At this piont, we would have [s2, jCount] is obtained from [s1, k+1], then we know the ratio is k+1: jCount. Since we have n1: Mn2 = k+1: jCount. we can get M = n1*jCount/(k+1)/n2;\\n```\\n    //brute force improved - 303ms\\n    //O(l^2*mo)\\n    private int sln2(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\\n\\n3. If we can find an exact match at the end of s2, can we find that at some point j, j< len(s2)? The answer is YES. We can use a hashmap to store the current nubmer of s1 visited and current number of s2 matched and use current index j in s2 as the key. If at one future point, we finish kth s1 search and end up at a point j which exists in our map, we know there is an exact match found in \"s2.substring(j)+s2s2....s2+s2.substring(0,j)\". \\nWe can get the number of s1 vistied from the diff between current number of s1, k and previous number of s1, prev(k), noted as kDiff;\\nWe can get the number of s2 matched from the diff between current jCount and previous jCount, prev(jCount), noted as jCountDiff;\\nWe can now get the ratio: kDiff/jCountDiff;\\nStarting from previous j, noted as prev(j), all matches found in the rest of string (s1s1s1...) will match this ratio. But the strings before prev(j) may not be the case. \\nThe number of s1 before prev(j) equals prev(k)+1, then the number of s1 after prev(j) equals n1-prev(k)-1, noted as n1Left. We can use this to find number of s2 matched from n1Left.\\nSince n1Left:n2Left = kDiff:jCountDiff. We can have n2Left = n1Left*jCountDiff/kDiff.\\nSince we have prev(jCount) of s2 matched before prev(j), we will have total M*n2 = n2Left+prev(jCount), and finally M= (n1Left*jCountDiff/kDiff+prev(jCount))/n2\\n\\n```\\n    //brute force improved improved - 1ms\\n    private int sln3(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n            if(map.containsKey(j)){\\n                int[] last = map.get(j);\\n                int kDiff = k-last[0];\\n                int jCountDiff = jCount- last[1];\\n                int n1Left = n1-last[0]-1;\\n                return (n1Left*jCountDiff/kDiff+last[1])/n2;\\n            }\\n            map.put(j, new int[]{k, jCount});\\n        }\\n        return jCount/n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    //brute force - tle\\n    private int sln1(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\n```\\n    //brute force improved - 303ms\\n    //O(l^2*mo)\\n    private int sln2(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n        }\\n        return jCount/n2;\\n    }\\n```\n```\\n    //brute force improved improved - 1ms\\n    private int sln3(String s1, int n1, String s2, int n2){\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int jCount=0;\\n        int l2 = ss2.length;\\n        Map<Integer, int[]> map = new HashMap<>();\\n        for(int k=0, j=0;k <n1; k++){\\n            for(int i =0;i < ss1.length; i++){\\n                if(ss1[i] == ss2[j]){\\n                    j ++;\\n                    jCount+= j/l2;\\n                    j = j%l2;\\n                }\\n            }\\n            if(j == 0){\\n                return n1*jCount/(k+1)/n2;\\n            }\\n            if(map.containsKey(j)){\\n                int[] last = map.get(j);\\n                int kDiff = k-last[0];\\n                int jCountDiff = jCount- last[1];\\n                int n1Left = n1-last[0]-1;\\n                return (n1Left*jCountDiff/kDiff+last[1])/n2;\\n            }\\n            map.put(j, new int[]{k, jCount});\\n        }\\n        return jCount/n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363840,
                "title": "improvement-of-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int idx=0;\\n        int len1=s1.length();\\n        int len2=s2.length();\\n        vector<vector<int> > dps1(len1, vector<int>(len2, -1)), dps2(len1, vector<int>(len2, -1));\\n        for(int i=0;i<n1*len1;++i){\\n            if(s2[idx%len2]==s1[i%len1]){\\n                if(dps1[i%len1][idx%len2]!=-1 && i+i-dps2[i%len1][idx%len2]<n1*len1){\\n                    idx+=idx-dps1[i%len1][idx%len2];\\n                    i+=i-dps2[i%len1][idx%len2]-1;\\n                }\\n                else{\\n                    dps1[i%len1][idx%len2]=idx;\\n                    dps2[i%len1][idx%len2]=i;\\n                    ++idx;                    \\n                }\\n            }\\n        }\\n        return idx/len2/n2;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int idx=0;\\n        int len1=s1.length();\\n        int len2=s2.length();\\n        vector<vector<int> > dps1(len1, vector<int>(len2, -1)), dps2(len1, vector<int>(len2, -1));\\n        for(int i=0;i<n1*len1;++i){\\n            if(s2[idx%len2]==s1[i%len1]){\\n                if(dps1[i%len1][idx%len2]!=-1 && i+i-dps2[i%len1][idx%len2]<n1*len1){\\n                    idx+=idx-dps1[i%len1][idx%len2];\\n                    i+=i-dps2[i%len1][idx%len2]-1;\\n                }\\n                else{\\n                    dps1[i%len1][idx%len2]=idx;\\n                    dps2[i%len1][idx%len2]=i;\\n                    ++idx;                    \\n                }\\n            }\\n        }\\n        return idx/len2/n2;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326820,
                "title": "share-my-concise-1ms-java-code",
                "content": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int n = s2.length();\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int[][] memo = new int[n][];\\n        int[] s2CountMap = new int[n + 1];\\n        int s1Count = 0, s2Count = 0;\\n        int s2Idx = 0;\\n        while (memo[s2Idx] == null) {\\n            memo[s2Idx] = new int[]{s1Count, s2Count};\\n            for (char c1 : ss1) {\\n                if (c1 == ss2[s2Idx]) {\\n                    s2Idx++;\\n                    if (s2Idx == n) {\\n                        s2Count++;\\n                        s2Idx = 0;\\n                    }\\n                }\\n            }\\n            s1Count++;\\n            s2CountMap[s1Count] = s2Count;\\n        }\\n\\n        int n1Left = n1 - memo[s2Idx][0];\\n        int matchedPatternCount = n1Left / (s1Count - memo[s2Idx][0]) * (s2Count - memo[s2Idx][1]);\\n        n1Left = n1Left % (s1Count - memo[s2Idx][0]);\\n        int leftS2Count = s2CountMap[memo[s2Idx][0] + n1Left] - memo[s2Idx][1];\\n        int totalCount = leftS2Count + matchedPatternCount + memo[s2Idx][1];\\n        return totalCount / n2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int n = s2.length();\\n        char[] ss1 = s1.toCharArray();\\n        char[] ss2 = s2.toCharArray();\\n        int[][] memo = new int[n][];\\n        int[] s2CountMap = new int[n + 1];\\n        int s1Count = 0, s2Count = 0;\\n        int s2Idx = 0;\\n        while (memo[s2Idx] == null) {\\n            memo[s2Idx] = new int[]{s1Count, s2Count};\\n            for (char c1 : ss1) {\\n                if (c1 == ss2[s2Idx]) {\\n                    s2Idx++;\\n                    if (s2Idx == n) {\\n                        s2Count++;\\n                        s2Idx = 0;\\n                    }\\n                }\\n            }\\n            s1Count++;\\n            s2CountMap[s1Count] = s2Count;\\n        }\\n\\n        int n1Left = n1 - memo[s2Idx][0];\\n        int matchedPatternCount = n1Left / (s1Count - memo[s2Idx][0]) * (s2Count - memo[s2Idx][1]);\\n        n1Left = n1Left % (s1Count - memo[s2Idx][0]);\\n        int leftS2Count = s2CountMap[memo[s2Idx][0] + n1Left] - memo[s2Idx][1];\\n        int totalCount = leftS2Count + matchedPatternCount + memo[s2Idx][1];\\n        return totalCount / n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307601,
                "title": "python3-o-s1-s2-solution-with-detailed-explanation-beats-100",
                "content": "![image](https://assets.leetcode.com/users/dengl11/image_1559973927.png)\\n\\n\\nThis is a quite tricky solution. It took me a day to understand the [discussion here](httphttps://leetcode.com/problems/count-the-repetitions/discuss/95397/C%2B%2B-0ms-O(str1.length*str2.length)://):\\n\\nThe basic idea is to detect the repeating pattern of S2 in multiple concated S1. After we find, say, `x1->x2` passes of S2 can be made from `y1->y2` passes of S1, then it means that n1 passes of S1 can make X passes of S2. And X is made from 2 parts:\\n\\n1. repeating part: `(n1 - y1)//(y2 - y1) * (x2-x1)`\\n2. remaining part: `(n1 - y1)%(y2 - y1) + y1 *`\\n\\nNow the question is how to find out `x1, x2`, `y1, y2`:\\n```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        pass2s = [-1]*(len(s2) + 1) # pass2s[i]: i pass1 can make pass2s[i] passes of pass2\\n        index2s = [-1]*(len(s2) + 1) # index2s[i]: i pass1 match up to (not including) the pass2s[i] character of S2; all values in index2s should be different, otherwise we will catch the same value and return, as seen in the code below\\n\\t\\t# initially without any pass S1:\\n        pass2s[0] = index2s[0] = 0\\n        index2 = 0\\n        pass2 = 0\\n        for pass1 in range(1, n1+1): # this outer loop will break within min(n1, n2) iterations\\n            for index1 in range(len(s1)): # use current pass of S1 to match as many characters in S2 as we can\\n                if s1[index1] == s2[index2]:\\n                    index2 += 1\\n                    if index2 == len(s2):\\n                        index2 = 0\\n                        pass2 += 1\\n\\t\\t\\t# now we know at pass1, how many pass2 we can make, and what the final stopping character\\n            index2s[pass1] = index2\\n            pass2s[pass1] = pass2\\n\\t\\t\\t\\n            # detect repeating pattern\\n            for i in range(pass1): # try fo find one prevous pass1 that can stop at the same character\\n                if index2s[i] == index2:\\n\\t\\t\\t\\t\\t# now we\\'d like to match index^th character of S2, and we find that one previous pass1, i.e. the i^th pass, can already match that, then the repeating pattern is detected\\n                    repeating_counts, remain = divmod(n1 - i, pass1 - i)\\n                    ans = repeating_counts * (pass2s[pass1]-pass2s[i])\\n                    ans += pass2s[i + remain]\\n\\t\\t\\t\\t\\t# ans here means that we can make ans passes of S2\\n                    return ans // n2\\n\\t\\t# if repeating pattern found, then just use all passes of S1, i.e. n1 to make S2\\n        return pass2s[n1] // n2\\n                    \\n```\\n\\nTotal compleity: \\n- Outer Loop: O(min(n1, S2))\\n- Innter Loop: O(S1)\\n\\nSo total complexity is O(|S1| * |S2|)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n        pass2s = [-1]*(len(s2) + 1) # pass2s[i]: i pass1 can make pass2s[i] passes of pass2\\n        index2s = [-1]*(len(s2) + 1) # index2s[i]: i pass1 match up to (not including) the pass2s[i] character of S2; all values in index2s should be different, otherwise we will catch the same value and return, as seen in the code below\\n\\t\\t# initially without any pass S1:\\n        pass2s[0] = index2s[0] = 0\\n        index2 = 0\\n        pass2 = 0\\n        for pass1 in range(1, n1+1): # this outer loop will break within min(n1, n2) iterations\\n            for index1 in range(len(s1)): # use current pass of S1 to match as many characters in S2 as we can\\n                if s1[index1] == s2[index2]:\\n                    index2 += 1\\n                    if index2 == len(s2):\\n                        index2 = 0\\n                        pass2 += 1\\n\\t\\t\\t# now we know at pass1, how many pass2 we can make, and what the final stopping character\\n            index2s[pass1] = index2\\n            pass2s[pass1] = pass2\\n\\t\\t\\t\\n            # detect repeating pattern\\n            for i in range(pass1): # try fo find one prevous pass1 that can stop at the same character\\n                if index2s[i] == index2:\\n\\t\\t\\t\\t\\t# now we\\'d like to match index^th character of S2, and we find that one previous pass1, i.e. the i^th pass, can already match that, then the repeating pattern is detected\\n                    repeating_counts, remain = divmod(n1 - i, pass1 - i)\\n                    ans = repeating_counts * (pass2s[pass1]-pass2s[i])\\n                    ans += pass2s[i + remain]\\n\\t\\t\\t\\t\\t# ans here means that we can make ans passes of S2\\n                    return ans // n2\\n\\t\\t# if repeating pattern found, then just use all passes of S1, i.e. n1 to make S2\\n        return pass2s[n1] // n2\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201674,
                "title": "javascript-56ms-o-s1-length-s2-length-time-and-o-1-space",
                "content": "Like other solutions, we also detect the cycle occurence, but repeat twice is enough. It passes the OJ in 56ms with O(1) space, let me know if there\\'s something wrong.\\n\\n```javascript\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let j = 0, i, count = 0, perCycle = 0, firstEnd = -1, lastEnd = -1, nonMatch = 0;\\n    for(i = 0; i < s1.length * n1; i++) {\\n        if (s2[j] === s1[i % s1.length]) {\\n            j++;\\n            nonMatch = 0;\\n        }\\n        else if (++nonMatch >= s1.length) break;\\n        if (j === s2.length) {\\n            count++;\\n            perCycle++;\\n            j = 0;\\n            if (lastEnd !== -1) continue;\\n            else if (firstEnd === -1) {\\n                firstEnd = i;\\n                perCycle = 0;\\n            }\\n            else if ((i - firstEnd) % s1.length === 0) {\\n                let cycleLen = i - firstEnd;\\n                let remainLen = s1.length * n1 - i - 1;\\n                let cycles = Math.floor(remainLen / cycleLen);\\n                count += cycles * perCycle;\\n                i += cycles * cycleLen;\\n            }\\n        }\\n    }\\n    return Math.floor(count / n2);\\n};\\n```\\n\\nRemoving the `nonMatch` check does not effect the time. Maybe there should be a test case like:\\n\\n```\\naaaaaa 1000000\\nb 1\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\\n    let j = 0, i, count = 0, perCycle = 0, firstEnd = -1, lastEnd = -1, nonMatch = 0;\\n    for(i = 0; i < s1.length * n1; i++) {\\n        if (s2[j] === s1[i % s1.length]) {\\n            j++;\\n            nonMatch = 0;\\n        }\\n        else if (++nonMatch >= s1.length) break;\\n        if (j === s2.length) {\\n            count++;\\n            perCycle++;\\n            j = 0;\\n            if (lastEnd !== -1) continue;\\n            else if (firstEnd === -1) {\\n                firstEnd = i;\\n                perCycle = 0;\\n            }\\n            else if ((i - firstEnd) % s1.length === 0) {\\n                let cycleLen = i - firstEnd;\\n                let remainLen = s1.length * n1 - i - 1;\\n                let cycles = Math.floor(remainLen / cycleLen);\\n                count += cycles * perCycle;\\n                i += cycles * cycleLen;\\n            }\\n        }\\n    }\\n    return Math.floor(count / n2);\\n};\\n```\n```\\naaaaaa 1000000\\nb 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155898,
                "title": "c-and-java-solution",
                "content": "The complexity lies in the fact that when we find the repetitive part s2 in s1, there could be trailing string in s1 left behind. How do we account for it in the next pattern matching ? For e.g. if we have S1 = [aba, 4] and S2 = [aab, 2] , then we have something like this:\\n\\nS1 = [ aba aba aba aba ]\\nS2 = [ aab aab ]\\nPattern matching starts at index 0 in s1.\\n\\nIn order to get one instance of s2 = [ aab ] begining from **index 0** in s1 = [aba] , We need two instances of s1, that is, [**a**b**a** a**b**a]. The pattern matching ends at index 1 in the second instance of s1 at **b**, trailing character in s2 **\"a\"** remains. So we know for any s2 that starts pattern matching at index 0 in s1 requires 2 instances of s1 and it\\'s total length is 5. The next pattern matching of s2 can begin here with **\"a\"** which is **indexed 2** in s1 originally. Suppose we have found lengths for all indices 0 <= i < s1.Length, we can simply use this pre-processed information to jump to next string s1 and find out where it ends and so on . For every jump we are matcing one s2. For every n2 * s2 we increment our result.\\n\\nFor special cases like s1 = \"aaaaaaaaaaaaa...100\"  and s2 = \"a\" we can simply return M by dividing the number of s2 we would need without processing.\\n```\\n public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            var h1 = new HashSet<char>();\\n            var h2 = new HashSet<char>();\\n\\n            for (int i = 0; i < s1.Length; i++)\\n                h1.Add(s1[i]);\\n\\n            for (int i = 0; i < s2.Length; i++)\\n                h2.Add(s2[i]);\\n\\n            var it = h2.GetEnumerator();\\n            while (it.MoveNext())\\n            {\\n                // if s2 contains something that s1 does not.\\n                if (!h1.Contains(it.Current)) return 0; \\n            }\\n            \\n            if (h1.Count() == 1 && h2.Count() == 1)\\n            {\\n                //For cases like \"aaaaaaaaaaaa....\" and \"aa..\"\\n                return ((n1 * s1.Length) / (n2 * s2.Length));\\n            }\\n\\n            //Lens stores the length of a string that contains one \"s2\" and begins at index i.\\n            var lens = new int[s1.Length];\\n\\n            for (int i = 0; i < s1.Length; i++)\\n            {\\n                int j = 0;\\n                int c = 0;\\n\\n                while (j < s2.Length)\\n                {\\n                    if (s2[j] == s1[((i + c) % s1.Length)])\\n                        j++;\\n                    c++;\\n                }\\n\\n                lens[i] = c - 1;\\n            }\\n\\n            int count = 0;\\n            int total_length = s1.Length * n1;\\n\\n            int temp = 0;\\n            int k = 0;\\n            int cur_index = 0;\\n\\n            while (true)\\n            {\\n                k += lens[cur_index] + 1;\\n                if (k > total_length) break;\\n\\n                temp++;\\n                if (temp == n2)\\n                {\\n                    count++;\\n                    temp = 0;\\n                }\\n                cur_index = (cur_index + lens[cur_index] + 1) % s1.Length;\\n            }\\n\\n            return count;\\n        }\\n```\\n\\nIn Java:\\n\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         HashSet<Character> h1 = new HashSet<>();\\n        HashSet<Character> h2 = new HashSet<>();\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            h1.add(s1.charAt(i));\\n        }\\n\\n        for (int i = 0; i < s2.length(); i++) {\\n            h2.add(s2.charAt(i));\\n        }\\n        \\n        int[] lens = new int[s1.length()];\\n\\n        Iterator<Character> it = h2.iterator();\\n        while (it.hasNext()) {\\n            if (!h1.contains(it.next())) return 0;\\n        }\\n        \\n        if (h1.size() == 1 && h2.size() == 1) {\\n            return ((n1 * s1.length()) / (n2 * s2.length()));\\n        }\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            int j = 0;\\n            int c = 0;\\n\\n            while (j < s2.length()) {\\n                if (s2.charAt(j) == s1.charAt(((i + c) % s1.length())))\\n                    j++;\\n                c++;\\n            }\\n\\n            lens[i] = c - 1;\\n        }\\n\\n        int rep = 0;\\n        int total_length = s1.length() * n1;\\n\\n        int temp = 0;\\n        int k = 0;\\n        int cur = 0;\\n\\n        while (true) {\\n            k += lens[cur] + 1;\\n            if (k > total_length) break;\\n\\n            temp++;\\n            if (temp == n2) {\\n                rep++;\\n                temp = 0;\\n            }\\n            cur = (cur + lens[cur] + 1) % s1.length();\\n        }\\n\\n        return rep;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int GetMaxRepetitions(string s1, int n1, string s2, int n2)\\n        {\\n            var h1 = new HashSet<char>();\\n            var h2 = new HashSet<char>();\\n\\n            for (int i = 0; i < s1.Length; i++)\\n                h1.Add(s1[i]);\\n\\n            for (int i = 0; i < s2.Length; i++)\\n                h2.Add(s2[i]);\\n\\n            var it = h2.GetEnumerator();\\n            while (it.MoveNext())\\n            {\\n                // if s2 contains something that s1 does not.\\n                if (!h1.Contains(it.Current)) return 0; \\n            }\\n            \\n            if (h1.Count() == 1 && h2.Count() == 1)\\n            {\\n                //For cases like \"aaaaaaaaaaaa....\" and \"aa..\"\\n                return ((n1 * s1.Length) / (n2 * s2.Length));\\n            }\\n\\n            //Lens stores the length of a string that contains one \"s2\" and begins at index i.\\n            var lens = new int[s1.Length];\\n\\n            for (int i = 0; i < s1.Length; i++)\\n            {\\n                int j = 0;\\n                int c = 0;\\n\\n                while (j < s2.Length)\\n                {\\n                    if (s2[j] == s1[((i + c) % s1.Length)])\\n                        j++;\\n                    c++;\\n                }\\n\\n                lens[i] = c - 1;\\n            }\\n\\n            int count = 0;\\n            int total_length = s1.Length * n1;\\n\\n            int temp = 0;\\n            int k = 0;\\n            int cur_index = 0;\\n\\n            while (true)\\n            {\\n                k += lens[cur_index] + 1;\\n                if (k > total_length) break;\\n\\n                temp++;\\n                if (temp == n2)\\n                {\\n                    count++;\\n                    temp = 0;\\n                }\\n                cur_index = (cur_index + lens[cur_index] + 1) % s1.Length;\\n            }\\n\\n            return count;\\n        }\\n```\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n         HashSet<Character> h1 = new HashSet<>();\\n        HashSet<Character> h2 = new HashSet<>();\\n\\n        for (int i = 0; i < s1.length(); i++) {\\n            h1.add(s1.charAt(i));\\n        }\\n\\n        for (int i = 0; i < s2.length(); i++) {\\n            h2.add(s2.charAt(i));\\n        }\\n        \\n        int[] lens = new int[s1.length()];\\n\\n        Iterator<Character> it = h2.iterator();\\n        while (it.hasNext()) {\\n            if (!h1.contains(it.next())) return 0;\\n        }\\n        \\n        if (h1.size() == 1 && h2.size() == 1) {\\n            return ((n1 * s1.length()) / (n2 * s2.length()));\\n        }\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            int j = 0;\\n            int c = 0;\\n\\n            while (j < s2.length()) {\\n                if (s2.charAt(j) == s1.charAt(((i + c) % s1.length())))\\n                    j++;\\n                c++;\\n            }\\n\\n            lens[i] = c - 1;\\n        }\\n\\n        int rep = 0;\\n        int total_length = s1.length() * n1;\\n\\n        int temp = 0;\\n        int k = 0;\\n        int cur = 0;\\n\\n        while (true) {\\n            k += lens[cur] + 1;\\n            if (k > total_length) break;\\n\\n            temp++;\\n            if (temp == n2) {\\n                rep++;\\n                temp = 0;\\n            }\\n            cur = (cur + lens[cur] + 1) % s1.length();\\n        }\\n\\n        return rep;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140674,
                "title": "python-44ms-by-finding-loop-with-same-position",
                "content": "\\t\\n\\tclass Solution:\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        i1, i2 = 0, 0\\n        dic_ind = {}\\n        dic_ln = {}\\n        dic_ind[0] = 0\\n        dic_ln[0] = 0\\n        k = 0\\n        cnt = 0\\n        while k < n1:\\n            if i2 == len(s2):\\n                cnt += 1\\n                i2 = 0\\n            elif i1 == len(s1):\\n                k += 1\\n                i1 = 0\\n                dic_ln[k] = cnt\\n                if i2 not in dic_ind:\\n                    dic_ind[i2] = k\\n                else:\\n                    break\\n            else:\\n                if s1[i1] == s2[i2]:\\n                    i2 += 1\\n                i1 += 1\\n        \\n        if k == n1:\\n            return cnt // n2\\n        loop_cnt = dic_ln[k] - dic_ln[dic_ind[i2]] # get the count of s2 in the loop\\n        loop_range = k - dic_ind[i2] # get the range of the loop with same i2 position\\n        num_loop = (n1 - dic_ind[i2]) // loop_range # get the number of the loops starting the first i2 line\\n        ln_rest = (n1 - dic_ind[i2]) % loop_range # get the rest of the lines\\n        res_p = dic_ln[dic_ind[i2] + ln_rest] # combine the starting point with rest of the lines\\n        return (res_p + num_loop * loop_cnt) // n2\\n\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        \"\"\"\\n        :type s1: str\\n        :type n1: int\\n        :type s2: str\\n        :type n2: int\\n        :rtype: int\\n        \"\"\"\\n        i1, i2 = 0, 0\\n        dic_ind = {}",
                "codeTag": "Java"
            },
            {
                "id": 95400,
                "title": "9ms-java-hashmap-solution",
                "content": "The code uses a HashMap to record the remaining string after matching (the remaining string of previous match and addition of needed number of s1) for 1*s2, and the number of s1 needed. When a remaining string loop is found, the help function stops, and the HashMap records all the remaining string records. Afterwards, the solution devides the remaining string into 2 parts, one outside the loop, and the other part inside the loop. Calculate the total number of s1 needed for pre-loop and loop separately. Based on these info, calculate how many s2 can be obtained depending on s1's value.\\n```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //make sure [s1,n1] is longer than [s2,n2]\\n        if(s1.length()*n1<s2.length()*n2) return 0;\\n        //make sure s1 repetition can make s2\\n        int i_2=0;\\n        int rep=0;\\n        while(i_2<s2.length()&&rep<1){\\n            int pre_2=i_2;\\n            int pre_rep=rep;\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(i_2)) {\\n                    i_2++;\\n                    if(i_2==s2.length()){\\n                        i_2=0;\\n                        rep++;\\n                    }\\n                }\\n                \\n            }\\n            if(pre_rep==rep&&pre_2==i_2) return 0;//the pre_2 element can't be matched by s1\\n        }\\n        List<String> order=new ArrayList<>();\\n        Map<String,Integer> rem=new HashMap<>();\\n        int[] loop=new int[2];\\n        //int rank=0;\\n        int index=0;\\n        help(s1,\"\",s2,rem,order,index,loop);\\n        \\n        int pre_sum=0;\\n        int loop_sum=0;\\n        for(int i=0;i<loop[0];i++){\\n            String temp=order.get(i);\\n            pre_sum+=rem.get(temp);\\n        }\\n        for(int i=loop[0];i<=loop[1];i++){\\n            String temp=order.get(i);\\n            loop_sum+=rem.get(temp);\\n        }\\n        int n_s2=0;\\n        \\n        if(n1<=pre_sum+loop_sum){\\n            //no loop at all\\n            for(int i=0;i<order.size();i++){\\n                n1-=rem.get(order.get(i));\\n                if(n1<0) break;\\n                n_s2++;\\n            }\\n        }\\n        else{\\n            n1-=pre_sum;\\n            n_s2+=loop[0];\\n            int loop_num=n1/loop_sum;\\n            n_s2+=loop_num*(loop[1]-loop[0]+1);\\n            n1-=loop_num*loop_sum;\\n            int i=loop[0];\\n            while(n1-rem.get(order.get(i))>=0){\\n                n1-=rem.get(order.get(i));\\n                i++;\\n                n_s2++;\\n            }\\n        }\\n        \\n        return n_s2/n2;\\n    }\\n    public void help(String s1,String pre_rem,String s2, Map<String,Integer> rem,List<String> order,int index,int[] loop){\\n        int i=0,j=0;\\n        int rep_s1=0;\\n        order.add(pre_rem);\\n        String curr=pre_rem;\\n        if(curr==null||curr.length()==0){\\n            curr=s1;\\n            rep_s1++;\\n        }\\n        while(j<s2.length()){\\n            if(curr.charAt(i)==s2.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n            if(j<s2.length()&&i>=curr.length()){\\n                i=0;\\n                curr=s1;\\n                rep_s1++;\\n            }\\n            \\n        }\\n        String curr_rem=curr.substring(i,curr.length());\\n        rem.put(pre_rem,rep_s1);\\n        \\n        if(!rem.containsKey(curr_rem)){\\n            help(s1,curr_rem,s2,rem,order,index+1,loop);\\n        }\\n        else{\\n            for(int k=0;k<order.size();k++){\\n                if(order.get(k).equals(curr_rem)) loop[0]=k;\\n                if(order.get(k).equals(pre_rem)){\\n                    loop[1]=k;        \\n                    break;\\n                } \\n\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //make sure [s1,n1] is longer than [s2,n2]\\n        if(s1.length()*n1<s2.length()*n2) return 0;\\n        //make sure s1 repetition can make s2\\n        int i_2=0;\\n        int rep=0;\\n        while(i_2<s2.length()&&rep<1){\\n            int pre_2=i_2;\\n            int pre_rep=rep;\\n            for(int i=0;i<s1.length();i++){\\n                if(s1.charAt(i)==s2.charAt(i_2)) {\\n                    i_2++;\\n                    if(i_2==s2.length()){\\n                        i_2=0;\\n                        rep++;\\n                    }\\n                }\\n                \\n            }\\n            if(pre_rep==rep&&pre_2==i_2) return 0;//the pre_2 element can't be matched by s1\\n        }\\n        List<String> order=new ArrayList<>();\\n        Map<String,Integer> rem=new HashMap<>();\\n        int[] loop=new int[2];\\n        //int rank=0;\\n        int index=0;\\n        help(s1,\"\",s2,rem,order,index,loop);\\n        \\n        int pre_sum=0;\\n        int loop_sum=0;\\n        for(int i=0;i<loop[0];i++){\\n            String temp=order.get(i);\\n            pre_sum+=rem.get(temp);\\n        }\\n        for(int i=loop[0];i<=loop[1];i++){\\n            String temp=order.get(i);\\n            loop_sum+=rem.get(temp);\\n        }\\n        int n_s2=0;\\n        \\n        if(n1<=pre_sum+loop_sum){\\n            //no loop at all\\n            for(int i=0;i<order.size();i++){\\n                n1-=rem.get(order.get(i));\\n                if(n1<0) break;\\n                n_s2++;\\n            }\\n        }\\n        else{\\n            n1-=pre_sum;\\n            n_s2+=loop[0];\\n            int loop_num=n1/loop_sum;\\n            n_s2+=loop_num*(loop[1]-loop[0]+1);\\n            n1-=loop_num*loop_sum;\\n            int i=loop[0];\\n            while(n1-rem.get(order.get(i))>=0){\\n                n1-=rem.get(order.get(i));\\n                i++;\\n                n_s2++;\\n            }\\n        }\\n        \\n        return n_s2/n2;\\n    }\\n    public void help(String s1,String pre_rem,String s2, Map<String,Integer> rem,List<String> order,int index,int[] loop){\\n        int i=0,j=0;\\n        int rep_s1=0;\\n        order.add(pre_rem);\\n        String curr=pre_rem;\\n        if(curr==null||curr.length()==0){\\n            curr=s1;\\n            rep_s1++;\\n        }\\n        while(j<s2.length()){\\n            if(curr.charAt(i)==s2.charAt(j)){\\n                j++;\\n            }\\n            i++;\\n            if(j<s2.length()&&i>=curr.length()){\\n                i=0;\\n                curr=s1;\\n                rep_s1++;\\n            }\\n            \\n        }\\n        String curr_rem=curr.substring(i,curr.length());\\n        rem.put(pre_rem,rep_s1);\\n        \\n        if(!rem.containsKey(curr_rem)){\\n            help(s1,curr_rem,s2,rem,order,index+1,loop);\\n        }\\n        else{\\n            for(int k=0;k<order.size();k++){\\n                if(order.get(k).equals(curr_rem)) loop[0]=k;\\n                if(order.get(k).equals(pre_rem)){\\n                    loop[1]=k;        \\n                    break;\\n                } \\n\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95404,
                "title": "share-my-time-limited-java-solution-but-have-no-idea-how-to-improve-it",
                "content": "```\\npublic class Solution {\\n    class MatchIndexLoop{\\n        int countLoop;\\n        int extraStep;\\n        MatchIndexLoop(int count_loop,int extra_step){\\n            countLoop=count_loop;\\n            extraStep=extra_step;\\n        }\\n    }\\n    private int count=0;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(originalCheck(s1,s2)==false){\\n            return 0;\\n        }\\n        \\n        int i=0;\\n        Map<Integer,MatchIndexLoop> map = new HashMap<>();\\n        \\n        while(i<n1*s1.length()){\\n             int index=i%s1.length();\\n             if(map.containsKey(index)){\\n                 count++;\\n                 MatchIndexLoop t=map.get(index);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n             }else{\\n                 MatchIndexLoop t = findNextPos(map,s1,index,s2);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n                 count++;\\n             }\\n            \\n            if(i>=n1*s1.length()){\\n                count--;\\n                break;\\n            }\\n            i++;\\n            \\n        }\\n        \\n        return count/n2; \\n    }\\n    \\n    public MatchIndexLoop findNextPos(Map<Integer,MatchIndexLoop> map,String str,int start_index,String target){\\n           int loop=0;\\n           String str2=str.substring(start_index)+str.substring(0,start_index);\\n        \\n           char[] strarray=str2.toCharArray();\\n           char[] target_array=target.toCharArray();\\n           \\n           int p=0;\\n           int i=0;\\n           for(;i<strarray.length;i++){\\n               if(target_array[p]==strarray[i]){\\n                   p++;\\n               }\\n               if(p==target_array.length){\\n                   break;\\n               }\\n               if(i+1==strarray.length){\\n                   loop++;\\n                   i=-1;\\n               }\\n           }\\n           MatchIndexLoop res = new MatchIndexLoop(loop,i);\\n           map.put(start_index,res);\\n           \\n           return  res;\\n    }\\n    \\n    public boolean originalCheck(String s1,String s2){\\n        char[] array1=s1.toCharArray();\\n        char[] array2=s2.toCharArray();\\n        \\n        boolean[] hash = new boolean[256];\\n        for(int i=0;i<array1.length;i++){\\n            hash[array1[i]]=true;\\n        }\\n        \\n        for(int i=0;i<array2.length;i++){\\n            if(hash[array2[i]]==false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class MatchIndexLoop{\\n        int countLoop;\\n        int extraStep;\\n        MatchIndexLoop(int count_loop,int extra_step){\\n            countLoop=count_loop;\\n            extraStep=extra_step;\\n        }\\n    }\\n    private int count=0;\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(originalCheck(s1,s2)==false){\\n            return 0;\\n        }\\n        \\n        int i=0;\\n        Map<Integer,MatchIndexLoop> map = new HashMap<>();\\n        \\n        while(i<n1*s1.length()){\\n             int index=i%s1.length();\\n             if(map.containsKey(index)){\\n                 count++;\\n                 MatchIndexLoop t=map.get(index);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n             }else{\\n                 MatchIndexLoop t = findNextPos(map,s1,index,s2);\\n                 i+=t.countLoop*s1.length()+t.extraStep;\\n                 count++;\\n             }\\n            \\n            if(i>=n1*s1.length()){\\n                count--;\\n                break;\\n            }\\n            i++;\\n            \\n        }\\n        \\n        return count/n2; \\n    }\\n    \\n    public MatchIndexLoop findNextPos(Map<Integer,MatchIndexLoop> map,String str,int start_index,String target){\\n           int loop=0;\\n           String str2=str.substring(start_index)+str.substring(0,start_index);\\n        \\n           char[] strarray=str2.toCharArray();\\n           char[] target_array=target.toCharArray();\\n           \\n           int p=0;\\n           int i=0;\\n           for(;i<strarray.length;i++){\\n               if(target_array[p]==strarray[i]){\\n                   p++;\\n               }\\n               if(p==target_array.length){\\n                   break;\\n               }\\n               if(i+1==strarray.length){\\n                   loop++;\\n                   i=-1;\\n               }\\n           }\\n           MatchIndexLoop res = new MatchIndexLoop(loop,i);\\n           map.put(start_index,res);\\n           \\n           return  res;\\n    }\\n    \\n    public boolean originalCheck(String s1,String s2){\\n        char[] array1=s1.toCharArray();\\n        char[] array2=s2.toCharArray();\\n        \\n        boolean[] hash = new boolean[256];\\n        for(int i=0;i<array1.length;i++){\\n            hash[array1[i]]=true;\\n        }\\n        \\n        for(int i=0;i<array2.length;i++){\\n            if(hash[array2[i]]==false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95406,
                "title": "java-30-lines-and-faster-optimize-first-ranking-answer-by-add-a-little-but-make-it-from-1088ms-to-12ms",
                "content": "When i check some fast answer, they are so many codes.\\n\\nthe brute force code is little and easy to understand, i found some clues to avoid duplicate calculate.\\n\\nyou will check the if(count2!=precount2){} clauses is the code i add, the thought is when s1 is at the ending and j==prej means \"**after that,all the for-loop is the duplicate calculations.**\" \\n\\nso i use a direct while loop without char checking.\\n\\n```\\npublic class Solution {\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(n1==0) return 0;\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        long count1 = 0, count2 = 0,precount2=0,precount1=0;\\n        int i = 0, j = 0,prej=0;\\n       \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n                if(count2!=precount2){\\n                    if(precount2==0){\\n                        prej = j;\\n                        precount2 = count2;\\n                        precount1 = count1;\\n                    }\\n                    else if(j==prej){\\n                        long diff2 = count2-precount2,diff1 = count1-precount1;\\n                        while(count1<n1){\\n                            count1+=diff1;\\n                            count2+=diff2;\\n                        }\\n                        break;\\n                    } \\n                }\\n            }\\n        }\\n        return (int) (count2*n1/count1/ n2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if(n1==0) return 0;\\n        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();\\n        long count1 = 0, count2 = 0,precount2=0,precount1=0;\\n        int i = 0, j = 0,prej=0;\\n       \\n        while (count1 < n1) {\\n            if (array1[i] == array2[j]) {\\n                j++;\\n                if (j == array2.length) {\\n                    j = 0;\\n                    count2++;\\n                }\\n            }\\n            i++;\\n            if (i == array1.length) {\\n                i = 0;\\n                count1++;\\n                if(count2!=precount2){\\n                    if(precount2==0){\\n                        prej = j;\\n                        precount2 = count2;\\n                        precount1 = count1;\\n                    }\\n                    else if(j==prej){\\n                        long diff2 = count2-precount2,diff1 = count1-precount1;\\n                        while(count1<n1){\\n                            count1+=diff1;\\n                            count2+=diff2;\\n                        }\\n                        break;\\n                    } \\n                }\\n            }\\n        }\\n        return (int) (count2*n1/count1/ n2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95409,
                "title": "java-brute-force-one-optimization-from-loop",
                "content": "Learned from https://discuss.leetcode.com/topic/71256/easy-understanding-java-solution-with-detailed-explanation-21ms. Basically we add a new ```s1```, we try to match once, and we get some remaining string. Then we add another new ```s1```, then we try to match again, then we get another remaining string. The key point is that the remaining string might repeat itself, hence a loop is formed. The loop is the key to speed up the brute force \"adding a ```s1```, match\" process.\\n\\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s1.length() == 0 || n1 == 0 || s2 == null || s2.length() == 0 || n2 == 0\\n                || impossibleMatch(s1, s2)) {\\n            return 0;\\n        }\\n        int matched = 0;\\n        int currentPos = 0;\\n        String lastRemain = \"\";\\n        Map<String, MatchReport> reports = new HashMap<>();\\n        while ((currentPos + lastRemain.length()) / s1.length() < n1) {\\n            if (reports.containsKey(lastRemain)) {\\n                LoopReport loop = analyzeLoop(reports, lastRemain);\\n                int loops = (s1.length() * n1 - currentPos) / loop.passedChars;\\n                matched += loops * loop.matched;\\n                currentPos += loops * loop.passedChars;\\n                reports.clear();\\n            } else {\\n                MatchReport report = match(lastRemain + s1, s2);\\n                reports.put(lastRemain, report);\\n                matched += report.matched;\\n                currentPos += report.passedChars;\\n                lastRemain = report.remain;\\n            }\\n        }\\n        return matched / n2;\\n    }\\n\\n    private LoopReport analyzeLoop(Map<String, MatchReport> reports, String entrykey) {\\n        int looplen = 0;\\n        int matched = 0;\\n        String key = entrykey;\\n        do {\\n            MatchReport report = reports.get(key);\\n            looplen += report.passedChars;\\n            matched += report.matched;\\n            key = report.remain;\\n        } while (!key.equals(entrykey));\\n        return new LoopReport(matched, looplen);\\n    }\\n\\n    private MatchReport match(String str1, String str2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int matched = 0;\\n        int end = 0;\\n        while (p1 < str1.length()) {\\n            char ch1 = str1.charAt(p1);\\n            char ch2 = str2.charAt(p2);\\n            if (ch1 == ch2) {\\n                if (++p2 == str2.length()) {\\n                    p2 = 0;\\n                    matched++;\\n                    end = p1 + 1;\\n                }\\n            }\\n            p1++;\\n        }\\n        return new MatchReport(matched, str1.substring(end), end);\\n    }\\n\\n    private boolean impossibleMatch(String str1, String str2) {\\n        Set<Character> chars = new HashSet<>();\\n        for (int i = 0; i < str2.length(); i++) {\\n            chars.add(str2.charAt(i));\\n        }\\n        for (int i = 0; i < str1.length(); i++) {\\n            chars.remove(str1.charAt(i));\\n        }\\n        return chars.size() > 0;\\n    }\\n\\n    class MatchReport {\\n        int matched;\\n        String remain;\\n        int passedChars;\\n        MatchReport(int matched, String remain, int passedChars) {\\n            this.matched = matched;\\n            this.remain = remain;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n\\n    class LoopReport {\\n        int matched;\\n        int passedChars;\\n        LoopReport(int matched, int passedChars) {\\n            this.matched = matched;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```s1```\n```s1```\n```s1```\n```\\npublic class Solution {\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1 == null || s1.length() == 0 || n1 == 0 || s2 == null || s2.length() == 0 || n2 == 0\\n                || impossibleMatch(s1, s2)) {\\n            return 0;\\n        }\\n        int matched = 0;\\n        int currentPos = 0;\\n        String lastRemain = \"\";\\n        Map<String, MatchReport> reports = new HashMap<>();\\n        while ((currentPos + lastRemain.length()) / s1.length() < n1) {\\n            if (reports.containsKey(lastRemain)) {\\n                LoopReport loop = analyzeLoop(reports, lastRemain);\\n                int loops = (s1.length() * n1 - currentPos) / loop.passedChars;\\n                matched += loops * loop.matched;\\n                currentPos += loops * loop.passedChars;\\n                reports.clear();\\n            } else {\\n                MatchReport report = match(lastRemain + s1, s2);\\n                reports.put(lastRemain, report);\\n                matched += report.matched;\\n                currentPos += report.passedChars;\\n                lastRemain = report.remain;\\n            }\\n        }\\n        return matched / n2;\\n    }\\n\\n    private LoopReport analyzeLoop(Map<String, MatchReport> reports, String entrykey) {\\n        int looplen = 0;\\n        int matched = 0;\\n        String key = entrykey;\\n        do {\\n            MatchReport report = reports.get(key);\\n            looplen += report.passedChars;\\n            matched += report.matched;\\n            key = report.remain;\\n        } while (!key.equals(entrykey));\\n        return new LoopReport(matched, looplen);\\n    }\\n\\n    private MatchReport match(String str1, String str2) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int matched = 0;\\n        int end = 0;\\n        while (p1 < str1.length()) {\\n            char ch1 = str1.charAt(p1);\\n            char ch2 = str2.charAt(p2);\\n            if (ch1 == ch2) {\\n                if (++p2 == str2.length()) {\\n                    p2 = 0;\\n                    matched++;\\n                    end = p1 + 1;\\n                }\\n            }\\n            p1++;\\n        }\\n        return new MatchReport(matched, str1.substring(end), end);\\n    }\\n\\n    private boolean impossibleMatch(String str1, String str2) {\\n        Set<Character> chars = new HashSet<>();\\n        for (int i = 0; i < str2.length(); i++) {\\n            chars.add(str2.charAt(i));\\n        }\\n        for (int i = 0; i < str1.length(); i++) {\\n            chars.remove(str1.charAt(i));\\n        }\\n        return chars.size() > 0;\\n    }\\n\\n    class MatchReport {\\n        int matched;\\n        String remain;\\n        int passedChars;\\n        MatchReport(int matched, String remain, int passedChars) {\\n            this.matched = matched;\\n            this.remain = remain;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n\\n    class LoopReport {\\n        int matched;\\n        int passedChars;\\n        LoopReport(int matched, int passedChars) {\\n            this.matched = matched;\\n            this.passedChars = passedChars;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95410,
                "title": "a-genarally-faster-than-o-str1-length-str2-length-solution",
                "content": "My code's run time is O(kL2logL1), where K is the rounds for s1 and s2' matching pattern to reoccur. For example:\\nS1:ababab\\nS2:bab\\nK = 3: because ababab|ababab contains 3 bab, after 3 repetitions of bab, the matching pattern reoccur.\\n\\nSo in average case, the code's run time is faster than O(l1*l2) But in a worst case, it can be as worse as O(L1 * L2 * lgL1).\\nOne example of the worst case is\\uff1a\\nS1:a....a (100 a's)\\nS2:a....a(99 a's)\\nK = 100: because S2 needs to repeat 100 times before the matching pattern reoccurs.\\n```\\nclass Solution {\\n    vector<int> charmap [256];\\n    void buildmap(const string & s1)\\n    {\\n        for (int i = 0; i < s1.size(); ++i)\\n            charmap[s1[i]].push_back(i);\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        buildmap(s1);\\n        int rep = 0,  last_pos = -1, mult = 0, start_pos = -1, first_start_pos = -2, last_last_pos = -2, last_rep = 0;\\n        vector<int> reps = {0};\\n        while (true)\\n        {\\n            for (int i = 0; i < s2.size();)\\n            {\\n                auto & v = charmap[s2[i]];\\n                if (v.empty())\\n                    return 0;\\n                auto iter = upper_bound(v.begin(), v.end(), last_pos);\\n                if (iter == v.end())\\n                {\\n                    rep ++;\\n                    reps.push_back(mult);\\n                    last_pos = -1;\\n                    continue;   \\n                }\\n                last_pos = *iter;\\n                ++ i;\\n            }\\n            start_pos = last_pos + 1;\\n            for (int i = s2.size() - 1; i >= 0;)\\n            {\\n                auto & v = charmap[s2[i]];\\n                auto iter = upper_bound(v.rbegin(), v.rend(), start_pos, std::greater<int>());\\n                if (iter == v.rend())\\n                {\\n                    start_pos = s1.size();\\n                    continue;   \\n                }\\n                start_pos = *iter;\\n                -- i;\\n            }\\n            mult ++;\\n            if (start_pos == first_start_pos)\\n            {\\n                mult --;\\n                break;\\n            }\\n            if (first_start_pos == -2)\\n                first_start_pos = start_pos;\\n            last_last_pos = last_pos;\\n            last_rep = rep;\\n        }\\n        last_rep ++;\\n        if (first_start_pos <= last_last_pos)\\n            return ((n1 / last_rep) * mult + reps[n1 % last_rep])/n2;\\n        return ((n1 - 1) / (last_rep - 1) * mult + reps[(n1 - 1) % (last_rep - 1) + 1])/n2;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> charmap [256];\\n    void buildmap(const string & s1)\\n    {\\n        for (int i = 0; i < s1.size(); ++i)\\n            charmap[s1[i]].push_back(i);\\n    }\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        buildmap(s1);\\n        int rep = 0,  last_pos = -1, mult = 0, start_pos = -1, first_start_pos = -2, last_last_pos = -2, last_rep = 0;\\n        vector<int> reps = {0};\\n        while (true)\\n        {\\n            for (int i = 0; i < s2.size();)\\n            {\\n                auto & v = charmap[s2[i]];\\n                if (v.empty())\\n                    return 0;\\n                auto iter = upper_bound(v.begin(), v.end(), last_pos);\\n                if (iter == v.end())\\n                {\\n                    rep ++;\\n                    reps.push_back(mult);\\n                    last_pos = -1;\\n                    continue;   \\n                }\\n                last_pos = *iter;\\n                ++ i;\\n            }\\n            start_pos = last_pos + 1;\\n            for (int i = s2.size() - 1; i >= 0;)\\n            {\\n                auto & v = charmap[s2[i]];\\n                auto iter = upper_bound(v.rbegin(), v.rend(), start_pos, std::greater<int>());\\n                if (iter == v.rend())\\n                {\\n                    start_pos = s1.size();\\n                    continue;   \\n                }\\n                start_pos = *iter;\\n                -- i;\\n            }\\n            mult ++;\\n            if (start_pos == first_start_pos)\\n            {\\n                mult --;\\n                break;\\n            }\\n            if (first_start_pos == -2)\\n                first_start_pos = start_pos;\\n            last_last_pos = last_pos;\\n            last_rep = rep;\\n        }\\n        last_rep ++;\\n        if (first_start_pos <= last_last_pos)\\n            return ((n1 / last_rep) * mult + reps[n1 % last_rep])/n2;\\n        return ((n1 - 1) / (last_rep - 1) * mult + reps[(n1 - 1) % (last_rep - 1) + 1])/n2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95412,
                "title": "c-easy-understand-solution",
                "content": "\\nIdea is  find index (both in s1 and s2) which start repeating before index in s1 going to the end..\\n\\nsuch as, assume n1 ,n2 is very large, for s1 = \"abca\" , s2 = \"ac\"\\ni = [0, 2, 3,     2(6), 3(7),  2(10)]  --> 6 is the real index, 2 is 6 % 4 == 2;\\nj = [0, 1, 0(2),  1(3), 0(4),  1(5) ] --> 2 is the real index, 0 is 2%2 == 0;\\n\\nso for index i , 2->6->10 is repeat, for index j, 1->3->5 is repeat follow i.\\n\\nso from i=6, every 2 step increase is repeat. so it can ease calculate instead of increase one by one\\n\\n```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.Length;\\n        int len2 = s2.Length;\\n        var dp = new string[len1,len2];\\n        int i = 0;\\n        int j = 0;\\n        bool find = false; \\n        while(i/len1 < n1){\\n            if(s1[i%len1] == s2[j%len2]){\\n                if(!find){\\n                    if(dp[i%len1,j%len2] == null){\\n                        dp[i%len1,j%len2] = i+\",\"+j;\\n                    }else{\\n                        find = true;\\n                        var arr = dp[i%len1,j%len2].Split(new char[]{','});\\n                        \\n                        int ii = int.Parse(arr[0]);\\n                        int jj = int.Parse(arr[1]);\\n                        //Console.WriteLine(ii+\",\"+jj+\",\"+i+\",\"+j);\\n                        int max = len1*n1;\\n                        int k = (max-i)/(i-ii);\\n                        //Console.WriteLine(k);\\n                        j = k*(j-jj)+j;\\n                        i = k*(i-ii)+i;\\n                    }\\n                }\\n                //Console.WriteLine(i+\",\"+j);\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return j/(len2*n2) -(len2*n2 == 1 ? 1 : 0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int GetMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int len1 = s1.Length;\\n        int len2 = s2.Length;\\n        var dp = new string[len1,len2];\\n        int i = 0;\\n        int j = 0;\\n        bool find = false; \\n        while(i/len1 < n1){\\n            if(s1[i%len1] == s2[j%len2]){\\n                if(!find){\\n                    if(dp[i%len1,j%len2] == null){\\n                        dp[i%len1,j%len2] = i+\",\"+j;\\n                    }else{\\n                        find = true;\\n                        var arr = dp[i%len1,j%len2].Split(new char[]{','});\\n                        \\n                        int ii = int.Parse(arr[0]);\\n                        int jj = int.Parse(arr[1]);\\n                        //Console.WriteLine(ii+\",\"+jj+\",\"+i+\",\"+j);\\n                        int max = len1*n1;\\n                        int k = (max-i)/(i-ii);\\n                        //Console.WriteLine(k);\\n                        j = k*(j-jj)+j;\\n                        i = k*(i-ii)+i;\\n                    }\\n                }\\n                //Console.WriteLine(i+\",\"+j);\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return j/(len2*n2) -(len2*n2 == 1 ? 1 : 0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95413,
                "title": "24ms-java-clean-solution",
                "content": "    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //get count of s2 in s1*n1\\n        int count = getCount(s1, s2, n1);\\n        return count/n2;\\n    }\\n    \\n    private int getCount(String s1, String s2, int n) {\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        //store cumulative count of s2\\n        List<Integer> sums = new ArrayList<Integer>();\\n        String s = s1;\\n        int sum = 0;\\n        sums.add(sum);\\n        int i = 0;\\n        while (i < n) {\\n            //cycle caught, break\\n            if (map.containsKey(s))\\n                break;\\n            //count s2 in s, add sum and return suffix index\\n            int suffixIndex = countAndUpdateSums(sums, sum, s, s2);\\n            sum = sums.get(sums.size()-1);\\n            map.put(s, sums.size()-1);\\n            s = s.substring(suffixIndex) + s1;\\n            i++;\\n        }\\n        int result = sum;\\n        if (i < n) {\\n            int cycleCount = sum-sums.get(map.get(s)-1);\\n            int cycleLen = map.size()-map.get(s)+1;\\n            int cycleNum = (n-i)/cycleLen;\\n            int postCycleLen = (n-i)%cycleLen;\\n            int postCycleCount = sums.get(map.get(s)+postCycleLen-1)-sums.get(map.get(s)-1);\\n            result += cycleCount*cycleNum+postCycleCount;\\n        }\\n        return result;\\n    }\\n    \\n    private int countAndUpdateSums(List<Integer> sums, int sum, String s1, String s2) {\\n        int i = 0;\\n        int j = 0;\\n        int last = 0;\\n        int count = 0;\\n        while (i < s1.length()) {\\n            if (s1.charAt(i) == s2.charAt(j))\\n                j++;\\n            i++;\\n            if (j == s2.length()) {\\n                last = i;\\n                count++;\\n                j = 0;\\n            }\\n        }\\n        sum += count;\\n        sums.add(sum);\\n        return last;\\n    }",
                "solutionTags": [],
                "code": "    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        //get count of s2 in s1*n1\\n        int count = getCount(s1, s2, n1);\\n        return count/n2;\\n    }\\n    \\n    private int getCount(String s1, String s2, int n) {\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        //store cumulative count of s2\\n        List<Integer> sums = new ArrayList<Integer>();\\n        String s = s1;\\n        int sum = 0;\\n        sums.add(sum);\\n        int i = 0;\\n        while (i < n) {\\n            //cycle caught, break\\n            if (map.containsKey(s))\\n                break;\\n            //count s2 in s, add sum and return suffix index\\n            int suffixIndex = countAndUpdateSums(sums, sum, s, s2);\\n            sum = sums.get(sums.size()-1);\\n            map.put(s, sums.size()-1);\\n            s = s.substring(suffixIndex) + s1;\\n            i++;\\n        }\\n        int result = sum;\\n        if (i < n) {\\n            int cycleCount = sum-sums.get(map.get(s)-1);\\n            int cycleLen = map.size()-map.get(s)+1;\\n            int cycleNum = (n-i)/cycleLen;\\n            int postCycleLen = (n-i)%cycleLen;\\n            int postCycleCount = sums.get(map.get(s)+postCycleLen-1)-sums.get(map.get(s)-1);\\n            result += cycleCount*cycleNum+postCycleCount;\\n        }\\n        return result;\\n    }\\n    \\n    private int countAndUpdateSums(List<Integer> sums, int sum, String s1, String s2) {\\n        int i = 0;\\n        int j = 0;\\n        int last = 0;\\n        int count = 0;\\n        while (i < s1.length()) {\\n            if (s1.charAt(i) == s2.charAt(j))\\n                j++;\\n            i++;\\n            if (j == s2.length()) {\\n                last = i;\\n                count++;\\n                j = 0;\\n            }\\n        }\\n        sum += count;\\n        sums.add(sum);\\n        return last;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 95415,
                "title": "some-simple-solutions",
                "content": "1. O(n1s1) brute force. I am unsure about the early termination condition. I appreciate it if someone can comment on it or give a counter example.\\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(!n2) return 0;\\n        int i = 0, j = 0, ct1 = 0, ct2 = 0, sz1 = s1.size(), sz2 = s2.size();\\n        while(ct1<n1) {\\n            if(s1[i++]==s2[j]) j++;\\n            if(i == sz1) {\\n                ct1++;\\n                i=0;\\n            }\\n            if(j == sz2) {\\n                ct2++;\\n                j=0;\\n            }\\n            if(!i&&!j) return (float)n1/ct1*ct2/n2; // is it correct?\\n        }\\n        return ct2/n2;\\n    }\\n```\\n2. O(n1*s1+s2s1^2) During brute force, the goal is count how many s2 can be obtained from S1. Assume the first s2 can be obtained from S1[0..i], the second s2 is checked starting from i+1. In brute force, time is wasted on scanning S1 to find the end point i for each s2. Since S1=[s1,n1], starting from the same index of s1, the length needed to obtain s2 is the same. So we can precompute the lengths. This runs much faster but worst case is same as brute force.  \\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz1=s1.size();\\n        vector<int> len(sz1); \\n        for(int i=0;i<sz1;i++){\\n            int j=i, k=0, p=j;\\n            while(k<s2.size())\\n                if(s2[k]==s1[j++%sz1]) {\\n                    k++;\\n                    p = j;\\n                } else if (j-p==sz1) return 0;\\n            len[i] = j-i;\\n        }\\n        int i=0, ct = 0;\\n        while((i+=len[i%sz1])<=n1*sz1) {\\n            ct++;\\n            if(i%sz1 ==0 && n1*sz1%i ==0) return n1*sz1/i*ct/n2;\\n        }\\n        return ct/n2;\\n    }\\n```\\n3. O(s1*s2+n1) In #2 we are matching each s2 to S1. If we match s1 to S2, it will be much faster.The great idea is from [@sanxi](https://discuss.leetcode.com/topic/78575/simple-c-code-16-lines-but-slow-179ms).\\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz2=s2.size();\\n        vector<int> len(sz2); //dp[i]-assume s2 is repeating, starting at idx i of s2, the length that can be obtained from s1.\\n        for(int i=0;i<sz2;i++){\\n            int j=i;\\n            for(char c : s1) if(c==s2[j%sz2]) j++;\\n            if(j==i) return 0; //s1 does not have s2[i]\\n            len[i] = j-i;\\n        }\\n        int idx=0;\\n        while(n1--) idx+=len[idx%sz2];\\n        return idx/sz2/n2;\\n    }\\n```\\n4. There are some O(s1s2) solutions, too difficult for me to understand....",
                "solutionTags": [],
                "code": "```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if(!n2) return 0;\\n        int i = 0, j = 0, ct1 = 0, ct2 = 0, sz1 = s1.size(), sz2 = s2.size();\\n        while(ct1<n1) {\\n            if(s1[i++]==s2[j]) j++;\\n            if(i == sz1) {\\n                ct1++;\\n                i=0;\\n            }\\n            if(j == sz2) {\\n                ct2++;\\n                j=0;\\n            }\\n            if(!i&&!j) return (float)n1/ct1*ct2/n2; // is it correct?\\n        }\\n        return ct2/n2;\\n    }\\n```\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz1=s1.size();\\n        vector<int> len(sz1); \\n        for(int i=0;i<sz1;i++){\\n            int j=i, k=0, p=j;\\n            while(k<s2.size())\\n                if(s2[k]==s1[j++%sz1]) {\\n                    k++;\\n                    p = j;\\n                } else if (j-p==sz1) return 0;\\n            len[i] = j-i;\\n        }\\n        int i=0, ct = 0;\\n        while((i+=len[i%sz1])<=n1*sz1) {\\n            ct++;\\n            if(i%sz1 ==0 && n1*sz1%i ==0) return n1*sz1/i*ct/n2;\\n        }\\n        return ct/n2;\\n    }\\n```\n```\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        int sz2=s2.size();\\n        vector<int> len(sz2); //dp[i]-assume s2 is repeating, starting at idx i of s2, the length that can be obtained from s1.\\n        for(int i=0;i<sz2;i++){\\n            int j=i;\\n            for(char c : s1) if(c==s2[j%sz2]) j++;\\n            if(j==i) return 0; //s1 does not have s2[i]\\n            len[i] = j-i;\\n        }\\n        int idx=0;\\n        while(n1--) idx+=len[idx%sz2];\\n        return idx/sz2/n2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95417,
                "title": "572-ms-accepted-c-solutions-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if (n1 == 0 || n2 == 0) return 0;\\n        int len1 = s1.size() * n1;\\n        int res = 0, turn = 0;\\n        int i = 0, j = 0;\\n        unordered_map<int, int> mymap;\\n        while (turn < n1) {\\n        \\twhile (i < s1.size() && s2[j] != s1[i]) ++i;\\n        \\tif (i == s1.size()) {\\n        \\t\\tif (++turn == n1 || j == 0) break;\\n        \\t\\ti = 0;\\n        \\t} else {\\n        \\t\\t++i;\\n        \\t\\tif (++j == s2.size()) {\\n        \\t\\t    ++res;\\n        \\t\\t    j = 0;\\n        \\t    }\\n        \\t}\\n        }\\n        return (res * (n1 / turn) + mymap[n1 % turn]) / n2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n        if (n1 == 0 || n2 == 0) return 0;\\n        int len1 = s1.size() * n1;\\n        int res = 0, turn = 0;\\n        int i = 0, j = 0;\\n        unordered_map<int, int> mymap;\\n        while (turn < n1) {\\n        \\twhile (i < s1.size() && s2[j] != s1[i]) ++i;\\n        \\tif (i == s1.size()) {\\n        \\t\\tif (++turn == n1 || j == 0) break;\\n        \\t\\ti = 0;\\n        \\t} else {\\n        \\t\\t++i;\\n        \\t\\tif (++j == s2.size()) {\\n        \\t\\t    ++res;\\n        \\t\\t    j = 0;\\n        \\t    }\\n        \\t}\\n        }\\n        return (res * (n1 / turn) + mymap[n1 % turn]) / n2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95419,
                "title": "java-solution-with-explanation-7s-please-add-more-test-cases",
                "content": "My initial solution got accepted with 6s but there is missing test cases to catch the flaw of this solution.  This solution cannot pass case like s1=\"aaa\" n1=20  s2=\"aaaaa\" n2=1\\n```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0, i = 0, j=0;\\n        int remMark = 0; //used to detect loop \\n        while(m1<=n1) {\\n            i = 0;\\n            int remIndex = 0;\\n            boolean foundMatch = false;\\n            while(i<s1.length()) {\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    foundMatch=true;\\n                    if(++j==s2.length()) {\\n                        remIndex = i;\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n                i++;\\n            }\\n            if(!foundMatch || (m2>0 && remMark==remIndex)) break;\\n            else if(a==0 && m2>0) {\\n                remMark = remIndex;\\n                a=m2;\\n                b=m1;\\n            }\\n            m1++;\\n        }\\n        return ((m2-a)*(n1-b)/(m1-b)+a)/n2;\\n   }\\n```\\nThe missing part is the calculation of incomplete loop. The following is the fixed solution:\\n```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0,j=0, next = 0;\\n        int[] loop = new int[s2.length()]; //every s1 will at least move one index forward in s2, so loop size at most s2.length()\\n        for(;m1<=n1;m1++) {\\n            for(int i=0; i<s1.length(); i++) {//two pointers to iterate s1 and s2. Move both if they are equal other wise advance i only\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    if(++j==s2.length()) {\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n            }\\n            if(j==next) break; //Every time we finish s1, we check if we found a loop by checking the next  index in s2\\n            else if(a==0 && m2>0) {\\n                next = j; //the point entering loop\\n                a=m1;\\n                b=m2;\\n            }\\n            if(m2>0) loop[m1-a] = m2-b;\\n        }\\n        return ((n1-a)/(m1-a)*(m2-b)+b + loop[(m2-b)*(n1-a)%(m1-a)])/n2; //before entering cycle we used s1 a times and got b number of s2\\n   }\\n```\\nThe key idea is to find a repeative pattern or loop such that every x numbers of s1 can get y numbers of s2. Here we use the next index of s2 to detect loop. Another key point is before entering loop we need to find out how many numbers of s1 we need and how many numbers of s2 we can get. In the code we use b, and a to denote that.\\nFor instance s1 = \"aaa\", n1=20, s2 = \"aaaaa\", n2 = 1 after -> m1=7 m2=4 a=2 b=1, loop [0,0,1,2,2], every 5 (7-2) s1 gets 3 (4-1) s2\\npart1: s1 2 s2 1, part2: 18/5 * 3 = 9, part3: 18%5 = 3 -> s2  3\\nresults: (1+9+2)/1 = 12\\n\\n![0_1483672071760_leetcountrepetition.JPG](/uploads/files/1483672066976-leetcountrepetition.jpg)",
                "solutionTags": [],
                "code": "```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0, i = 0, j=0;\\n        int remMark = 0; //used to detect loop \\n        while(m1<=n1) {\\n            i = 0;\\n            int remIndex = 0;\\n            boolean foundMatch = false;\\n            while(i<s1.length()) {\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    foundMatch=true;\\n                    if(++j==s2.length()) {\\n                        remIndex = i;\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n                i++;\\n            }\\n            if(!foundMatch || (m2>0 && remMark==remIndex)) break;\\n            else if(a==0 && m2>0) {\\n                remMark = remIndex;\\n                a=m2;\\n                b=m1;\\n            }\\n            m1++;\\n        }\\n        return ((m2-a)*(n1-b)/(m1-b)+a)/n2;\\n   }\\n```\n```\\n   public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        int m1 = 1, m2 = 0, a=0, b=0,j=0, next = 0;\\n        int[] loop = new int[s2.length()]; //every s1 will at least move one index forward in s2, so loop size at most s2.length()\\n        for(;m1<=n1;m1++) {\\n            for(int i=0; i<s1.length(); i++) {//two pointers to iterate s1 and s2. Move both if they are equal other wise advance i only\\n                if(s2.charAt(j)==s1.charAt(i)) {\\n                    if(++j==s2.length()) {\\n                        m2++;\\n                        j=0;\\n                    }\\n                }\\n            }\\n            if(j==next) break; //Every time we finish s1, we check if we found a loop by checking the next  index in s2\\n            else if(a==0 && m2>0) {\\n                next = j; //the point entering loop\\n                a=m1;\\n                b=m2;\\n            }\\n            if(m2>0) loop[m1-a] = m2-b;\\n        }\\n        return ((n1-a)/(m1-a)*(m2-b)+b + loop[(m2-b)*(n1-a)%(m1-a)])/n2; //before entering cycle we used s1 a times and got b number of s2\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95414,
                "title": "nice-o-len-s1-len-s2-worst-case",
                "content": "The trick is to find minimum number - n1count such that [s2,n2count] matches **exactly** into [s1, n1count]. Exactly means that next character to be matched in both strings is the first character. \\n\\n\\n\\npublic class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1.length() == 0 || s2.length() == 0 || n2 == 0 || n1 == 0) return 0;\\n        int n2count = 0, n1count = 0;\\n        int i = 0;\\n        int j = 0;\\n        while (n1count < n1) {\\n            if (s1.charAt(i) == s2.charAt(j)) j++;\\n            i++;\\n            \\n            if (i == s1.length()) {\\n                i = 0;\\n                n1count++;\\n            }\\n            if (j == s2.length()) {\\n                j = 0;\\n                n2count++;\\n            }\\n            if (i == 0 && j == 0) break;\\n        }\\n        return (int)((long)n1*n2count/n1count/n2);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\\n        if (s1.length() == 0 || s2.length() == 0 || n2 == 0 || n1 == 0) return 0;\\n        int n2count = 0, n1count = 0;\\n        int i = 0;\\n        int j = 0;\\n        while (n1count < n1) {\\n            if (s1.charAt(i) == s2.charAt(j)) j++;\\n            i++;\\n            \\n            if (i == s1.length()) {\\n                i = 0;\\n                n1count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 95423,
                "title": "ruby-solution",
                "content": "An related but slightly easier problem to the original one is finding the maximal # of `s2` that can be obtained from `S1`. \\n\\nFor example, assume `n2 = 3` and we can get 7 `s2` from `S1`, the final answer will be `7/3 = 2`\\n\\nI start w/ a brute force algorithm by having two pointer `p1` and `p2`, which iterate through `S1` and `S2` respectively. This part is pretty straightforward.\\n\\nThe brute force algorithm has some room to improve when the `n1` is large. After some iterations, we may have enough information to calculate the answer w/o continuing.\\n\\nFor example, assume the following input\\n- s1 = \"aaaaaab\"\\n- n1 = 1,000,000\\n- s2 = \"bc\"\\n\\nAfter the second iteration, we know we won't be able to find a match.\\n\\nFor those cases in which there are an answer, it's very like that there will be recurring pattern. \\n\\nFor example, assume the following input\\n- s1 = \"ababc\"\\n- n1 = 1,000,000\\n- s2 = \"ba\"\\n\\n```\\ndef get_max_repetitions(s1, n1, s2, n2)\\n  count = get_max_repetitions_helper(s1, n1, s2)\\n  count / n2\\nend\\n\\ndef get_max_repetitions_helper(s1, n1, s2)\\n  p2 = 0\\n  positions = []\\n\\n  (0...s1.size*n1).each do |p1|\\n      # Give up when no char when can be matched w/ a full cyle\\n      cycle = p1 / s1.size\\n      return 0 if positions.size < cycle    \\n\\n      c1, c2 = s1[p1 % s1.size], s2[p2 % s2.size]\\n      if c1 == c2\\n        positions[p2] = p1\\n        # puts positions.each_with_index.map { |k,i| \"(#{i}, #{k})\" }.join(\", \")\\n\\n        (p2-s2.size).step(0, -s2.size) do |i|\\n          # Found pair (i, positions[i]) and (p2, positions[p2])\\n          # where (p2-i) % s2.size == 0 and\\n          #       (positions[p2] - positions[i]) % s1.size == 0\\n          if (p1 - positions[i]) % s1.size == 0\\n            \\n            parts = [\\n              (positions.size-1),\\n              (s1.size*n1-p1) / (positions[p2] - positions[i]) * (p2-i),\\n              # How many extra s2 char can we match if\\n              # if move p1 from [positions[i], positions[i+remain])\\n              positions[i..-1].select do |k|\\n                #   [ -------- remaining step for s1 -----------   ]\\n                k <= (s1.size*n1-p1) % (positions[p2] - positions[i]) + positions[i] - 1\\n              end.size\\n            ]\\n\\n            num_of_chars = parts.reduce(&:+)\\n            return num_of_chars / s2.size\\n          end\\n          i -= s2.size\\n        end\\n        \\n        p2 += 1\\n      end\\n  end\\n\\n  positions.size / s2.size\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef get_max_repetitions(s1, n1, s2, n2)\\n  count = get_max_repetitions_helper(s1, n1, s2)\\n  count / n2\\nend\\n\\ndef get_max_repetitions_helper(s1, n1, s2)\\n  p2 = 0\\n  positions = []\\n\\n  (0...s1.size*n1).each do |p1|\\n      # Give up when no char when can be matched w/ a full cyle\\n      cycle = p1 / s1.size\\n      return 0 if positions.size < cycle    \\n\\n      c1, c2 = s1[p1 % s1.size], s2[p2 % s2.size]\\n      if c1 == c2\\n        positions[p2] = p1\\n        # puts positions.each_with_index.map { |k,i| \"(#{i}, #{k})\" }.join(\", \")\\n\\n        (p2-s2.size).step(0, -s2.size) do |i|\\n          # Found pair (i, positions[i]) and (p2, positions[p2])\\n          # where (p2-i) % s2.size == 0 and\\n          #       (positions[p2] - positions[i]) % s1.size == 0\\n          if (p1 - positions[i]) % s1.size == 0\\n            \\n            parts = [\\n              (positions.size-1),\\n              (s1.size*n1-p1) / (positions[p2] - positions[i]) * (p2-i),\\n              # How many extra s2 char can we match if\\n              # if move p1 from [positions[i], positions[i+remain])\\n              positions[i..-1].select do |k|\\n                #   [ -------- remaining step for s1 -----------   ]\\n                k <= (s1.size*n1-p1) % (positions[p2] - positions[i]) + positions[i] - 1\\n              end.size\\n            ]\\n\\n            num_of_chars = parts.reduce(&:+)\\n            return num_of_chars / s2.size\\n          end\\n          i -= s2.size\\n        end\\n        \\n        p2 += 1\\n      end\\n  end\\n\\n  positions.size / s2.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 95425,
                "title": "c-with-string-s1-pre-process-but-got-tle",
                "content": "Re: [Ugly Java brute force solution](but accepted. 1088ms.)\\n\\nSimilar to @shawngao 's Java brute force solution, I pre-processed string `s1` to \"cache\" for each index `j` and char `c`, pre-calculate `pos[j][c-'a']` as the index of first occurrence of char `c` stating from position `j`. This should help for two-pointer scanning, but I got TLE for test case with both `s1`, `s2` as `\"aaaaaaaa...\"` and `n1 = n2 = 1000000`.\\n\\nAfter reading other posts, I see some coders also got TLE for C++ only (?). I am wondering whether my following C++ code indeed has defects.\\n```\\n    // pos[j][c]: index of first occurrence in string starting from index j for char c\\n    vector<vector<int>> pos;\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n      int counter = -1, ls1 = s1.size(), is = 0, cnt = 0; buildPos(s1, ls1); \\n      while (++counter >= 0) {\\n          for (char c:s2) {\\n            if (is == ls1) { is = 0; if ((++cnt) >= n1) return counter/n2; }\\n            int next = pos[is][c-'a'];\\n            if (next == ls1) { \\n                if ((next = pos[0][c-'a']) == ls1) return counter/n2; \\n                if ((++cnt) >= n1) return counter/n2; \\n            }\\n            is = next + 1;\\n          }\\n      }\\n      return -1; // should never comes here\\n    }\\n    // pre-process string s to find index of first occurrence starting from index j for char c\\n    void buildPos(string& s, int npos) {\\n      pos = vector<vector<int>>(s.size(), vector<int>(26, npos));\\n      vector<vector<int>> idx(26); int c;\\n      for (int i = 0; i < s.size(); ++i) {\\n        int last = idx[c = (s[i]-'a')].empty()? -1 : idx[c].back();\\n        idx[c].push_back(i);\\n        for (int j = last+1; j <= i; ++j) pos[j][c] = i;\\n      }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // pos[j][c]: index of first occurrence in string starting from index j for char c\\n    vector<vector<int>> pos;\\n    int getMaxRepetitions(string s1, int n1, string s2, int n2) {\\n      int counter = -1, ls1 = s1.size(), is = 0, cnt = 0; buildPos(s1, ls1); \\n      while (++counter >= 0) {\\n          for (char c:s2) {\\n            if (is == ls1) { is = 0; if ((++cnt) >= n1) return counter/n2; }\\n            int next = pos[is][c-'a'];\\n            if (next == ls1) { \\n                if ((next = pos[0][c-'a']) == ls1) return counter/n2; \\n                if ((++cnt) >= n1) return counter/n2; \\n            }\\n            is = next + 1;\\n          }\\n      }\\n      return -1; // should never comes here\\n    }\\n    // pre-process string s to find index of first occurrence starting from index j for char c\\n    void buildPos(string& s, int npos) {\\n      pos = vector<vector<int>>(s.size(), vector<int>(26, npos));\\n      vector<vector<int>> idx(26); int c;\\n      for (int i = 0; i < s.size(); ++i) {\\n        int last = idx[c = (s[i]-'a')].empty()? -1 : idx[c].back();\\n        idx[c].push_back(i);\\n        for (int j = last+1; j <= i; ++j) pos[j][c] = i;\\n      }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95427,
                "title": "python-solution-by-finding-cycle",
                "content": "We match string `s1*n1` and multiple `s2` in a greedy way, trying to find a cycle. Here a cycle means that when we match `s2` `k` times and `k + cycle_length` times, the last characters in both cases match to the characters of the same index in `s1`. \\nThen `s1*n1` can be decomposed into three parts: the part before the cycle, cycle part, the remaining incomplete cycle part. \\nThe greediness of the our matching procedure guarantee that the number of `s2` matched in the first part and last part is the same as the one we would get if these two parts are concatenated, which will be a multiple of `s1`.\\n```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        set_s1, set_s2 = set(s1), set(s2)\\n        if not all(ch in set_s1 for ch in s2):\\n            return 0\\n        s1 = ''.join(ch for ch in s1 if ch in set_s2) # get rid of redundant character in s1.'\\n        tmap = dict()\\n        # tmap[i] = k means that at the first time s1[i] matchs to the last character in s2, we have matched s2 k times in total.\\n        record = [0]\\n        # record[i] = k means that k is the smallest number such that s2*i is a subsequence of s1*k.\\n        cnt1 = 0\\n        beg = 0\\n        while True:\\n            for ch in s2:\\n                i = s1.find(ch, beg)\\n                if i == -1:\\n                    cnt1 += 1\\n                    i = s1.find(ch)\\n                beg = i+1\\n            record.append(cnt1 + 1)\\n            if record[-1] > n1:\\n                return (len(record)-2)//n2\\n            if i in tmap: # when find a full cycle, exit the loop.\\n                break\\n            else:\\n                tmap[i] = len(record)-1\\n        '''\\n        cycle_beg denotes the number of times we have scanned s1 (including the current one) when the cycle begins.\\n        cycle_s1 denotes the number of s1 in a full cycle.\\n        cycle_s2 denotes the number of s2 in a full cycle.\\n        '''\\n        cycle_beg = record[tmap[i]]\\n        cycle_s1 = cnt1+1 - cycle_beg\\n        cycle_s2 = len(record)-1 - tmap[i]\\n        d, r = divmod(n1 - cycle_beg, cycle_s1)\\n        # d denotes the number of full cycles, r denotes the remaining number of s1 in the last incomplete cycle.\\n        remain = cycle_beg + r # concatenate the part before the cycle begins and the incomplete cycle remaining.\\n        j = 0\\n        while record[j] <= remain: # record[-1] > remain is yet to be proved.\\n            j += 1\\n        cnt = cycle_s2*d + j-1\\n        return cnt//n2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getMaxRepetitions(self, s1, n1, s2, n2):\\n        set_s1, set_s2 = set(s1), set(s2)\\n        if not all(ch in set_s1 for ch in s2):\\n            return 0\\n        s1 = ''.join(ch for ch in s1 if ch in set_s2) # get rid of redundant character in s1.'\\n        tmap = dict()\\n        # tmap[i] = k means that at the first time s1[i] matchs to the last character in s2, we have matched s2 k times in total.\\n        record = [0]\\n        # record[i] = k means that k is the smallest number such that s2*i is a subsequence of s1*k.\\n        cnt1 = 0\\n        beg = 0\\n        while True:\\n            for ch in s2:\\n                i = s1.find(ch, beg)\\n                if i == -1:\\n                    cnt1 += 1\\n                    i = s1.find(ch)\\n                beg = i+1\\n            record.append(cnt1 + 1)\\n            if record[-1] > n1:\\n                return (len(record)-2)//n2\\n            if i in tmap: # when find a full cycle, exit the loop.\\n                break\\n            else:\\n                tmap[i] = len(record)-1\\n        '''\\n        cycle_beg denotes the number of times we have scanned s1 (including the current one) when the cycle begins.\\n        cycle_s1 denotes the number of s1 in a full cycle.\\n        cycle_s2 denotes the number of s2 in a full cycle.\\n        '''\\n        cycle_beg = record[tmap[i]]\\n        cycle_s1 = cnt1+1 - cycle_beg\\n        cycle_s2 = len(record)-1 - tmap[i]\\n        d, r = divmod(n1 - cycle_beg, cycle_s1)\\n        # d denotes the number of full cycles, r denotes the remaining number of s1 in the last incomplete cycle.\\n        remain = cycle_beg + r # concatenate the part before the cycle begins and the incomplete cycle remaining.\\n        j = 0\\n        while record[j] <= remain: # record[-1] > remain is yet to be proved.\\n            j += 1\\n        cnt = cycle_s2*d + j-1\\n        return cnt//n2\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1872841,
                "content": [
                    {
                        "username": "bahoang3105",
                        "content": "I think the example should have explanation so as not to cause confusion"
                    },
                    {
                        "username": "bahoang3105",
                        "content": "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\\nOutput: 2\\n=> str1 = \"acbacbacbacb\"\\n      str2 = \"abab\"\\n      str = [str2, 2] = \"abababab\"\\n2 is the maximum integer such that str can be obtained from str1"
                    },
                    {
                        "username": "nguyenngocquang296",
                        "content": "It should be an easy problem."
                    }
                ]
            },
            {
                "id": 1960272,
                "content": [
                    {
                        "username": "bahoang3105",
                        "content": "I think the example should have explanation so as not to cause confusion"
                    },
                    {
                        "username": "bahoang3105",
                        "content": "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\\nOutput: 2\\n=> str1 = \"acbacbacbacb\"\\n      str2 = \"abab\"\\n      str = [str2, 2] = \"abababab\"\\n2 is the maximum integer such that str can be obtained from str1"
                    },
                    {
                        "username": "nguyenngocquang296",
                        "content": "It should be an easy problem."
                    }
                ]
            }
        ]
    }
]