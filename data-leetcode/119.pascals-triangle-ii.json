[
    {
        "title": "Remove Nth Node From End of List",
        "question_content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is sz.\n\t1 <= sz <= 30\n\t0 <= Node.val <= 100\n\t1 <= n <= sz\n\n&nbsp;\nFollow up: Could you do this in one pass?",
        "solutions": [
            {
                "id": 1164542,
                "title": "js-python-java-c-easy-two-pointer-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith a singly linked list, the _only_ way to find the end of the list, and thus the **n**\\'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the **n**\\'th from the end once we reach the end, but that would take **O(M) extra space**, where **M** is the length of the linked list.\\n\\nA slightly less naive approach would be to only store only the last **n+1** node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the **space complexity** to **O(N+1)**.\\n\\nIn order to solve this problem in only one pass and **O(1) extra space**, however, we would need to find a way to _both_ reach the end of the list with one pointer _and also_ reach the **n**\\'th node from the end simultaneously with a second pointer.\\n\\nTo do that, we can simply stagger our two pointers by **n** nodes by giving the first pointer (**fast**) a head start before starting the second pointer (**slow**). Doing this will cause **slow** to reach the **n**\\'th node from the end at the same time that **fast** reaches the end.\\n\\n![Visual 1](https://i.imgur.com/BSiLKj0.png)\\n\\nSince we will need access to the node _before_ the target node in order to remove the target node, we can use **fast.next == null** as our exit condition, rather than **fast == null**, so that we stop one node earlier.\\n\\nThis will unfortunately cause a problem when **n** is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node _before_ the target node. If that\\'s the case, however, we can just **return head.next** without needing to stitch together the two sides of the target node.\\n\\nOtherwise, once we succesfully find the node _before_ the target, we can then stitch it together with the node _after_ the target, and then **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **60ms / 40.6MB** (beats 100% / 13%).\\n```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 92% / 99%).\\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.6MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8804,
                "title": "simple-java-solution-in-one-pass",
                "content": "A one pass solution can be done using  pointers. Move one pointer **fast** -->  **n+1** places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be **n+1** places behind - just the right spot for it to be able to skip the next node.\\n\\nSince the question gives that **n** is valid, not too many checks have to be put in place. Otherwise, this would be necessary.\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode start = new ListNode(0);\\n        ListNode slow = start, fast = start;\\n        slow.next = head;\\n        \\n        //Move fast in front so that the gap between slow and fast becomes n\\n        for(int i=1; i<=n+1; i++)   {\\n            fast = fast.next;\\n        }\\n        //Move fast to the end, maintaining the gap\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Skip the desired node\\n        slow.next = slow.next.next;\\n        return start.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A one pass solution can be done using  pointers. Move one pointer **fast** -->  **n+1** places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be **n+1** places behind - just the right spot for it to be able to skip the next node.\\n\\nSince the question gives that **n** is valid, not too many checks have to be put in place. Otherwise, this would be necessary.\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode start = new ListNode(0);\\n        ListNode slow = start, fast = start;\\n        slow.next = head;\\n        \\n        //Move fast in front so that the gap between slow and fast becomes n\\n        for(int i=1; i<=n+1; i++)   {\\n            fast = fast.next;\\n        }\\n        //Move fast to the end, maintaining the gap\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Skip the desired node\\n        slow.next = slow.next.next;\\n        return start.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8802,
                "title": "3-short-python-solutions",
                "content": "**Value-Shifting - AC in 64 ms**\\n\\nMy first solution is \"cheating\" a little. Instead of really removing the nth *node*, I remove the nth *value*. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def index(node):\\n                if not node:\\n                    return 0\\n                i = index(node.next) + 1\\n                if i > n:\\n                    node.next.val = node.val\\n                return i\\n            index(head)\\n            return head.next\\n\\n---\\n\\n**Index and Remove - AC in 56 ms**\\n\\nIn this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def remove(head):\\n                if not head:\\n                    return 0, head\\n                i, head.next = remove(head.next)\\n                return i+1, (head, head.next)[i+1 == n]\\n            return remove(head)[1]\\n\\n---\\n\\n**n ahead - AC in 48 ms**\\n\\nThe standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            fast = slow = head\\n            for _ in range(n):\\n                fast = fast.next\\n            if not fast:\\n                return head.next\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Value-Shifting - AC in 64 ms**\\n\\nMy first solution is \"cheating\" a little. Instead of really removing the nth *node*, I remove the nth *value*. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def index(node):\\n                if not node:\\n                    return 0\\n                i = index(node.next) + 1\\n                if i > n:\\n                    node.next.val = node.val\\n                return i\\n            index(head)\\n            return head.next\\n\\n---\\n\\n**Index and Remove - AC in 56 ms**\\n\\nIn this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            def remove(head):\\n                if not head:\\n                    return 0, head\\n                i, head.next = remove(head.next)\\n                return i+1, (head, head.next)[i+1 == n]\\n            return remove(head)[1]\\n\\n---\\n\\n**n ahead - AC in 48 ms**\\n\\nThe standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start.\\n\\n    class Solution:\\n        def removeNthFromEnd(self, head, n):\\n            fast = slow = head\\n            for _ in range(n):\\n                fast = fast.next\\n            if not fast:\\n                return head.next\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 1164537,
                "title": "short-simple-one-pass-solution-w-explanation-beats-100-no-dummy-node-required",
                "content": "This problem is very similar to the **[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)** , just that we have to **remove** the kth node from the end instead of swapping it.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (One-Pointer, Two-Pass)***\\n\\nThis approach is very intuitive and easy to get. \\n\\n* We just iterate in the first-pass to find the length of the linked list - **`len`**.\\n\\n* In the next pass, iterate **`len - n - 1`** nodes from start and delete the next node (which would be *`nth`* node from end).\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. \\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution (Two-Pointer, One-Pass)***\\n\\nWe are required to remove the nth node from the end of list. For this, we need to traverse *`N - n`* nodes from the start of the list, where *`N`* is the length of linked list. We can do this in one-pass as follows -\\n\\n* Let\\'s assign two pointers - **`fast`** and **`slow`** to head. We will first iterate for *`n`* nodes from start using the *`fast`* pointer. \\n\\n* Now, between the *`fast`*  and *`slow`* pointers, **there is a gap of `n` nodes**. Now, just Iterate and increment both the pointers till `fast` reaches the last node. The gap between `fast` and `slow` is still of `n` nodes, meaning that **`slow` is nth node from the last node (which currently is `fast`)**.\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\\n\\n * Since we have to **delete the nth node from end of list** (And not nth from the last of list!), we just delete the next node to **`slow`** pointer and return the head.\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. Although, the time complexity is same as above solution, we have reduced the constant factor in it to half.\\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it**. A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n\\n---\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/6c81d074-139d-4de5-96f5-5943f62a2cca_1618736585.2373421.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1037986,
                "title": "python-two-pointer-solution-with-comments-easy-to-understand",
                "content": "Please upvote once you get this :)\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        slow = head\\n        # advance fast to nth position\\n        for i in range(n):\\n            fast = fast.next\\n            \\n        if not fast:\\n            return head.next\\n        # then advance both fast and slow now they are nth postions apart\\n        # when fast gets to None, slow will be just before the item to be deleted\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        # delete the node\\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        slow = head\\n        # advance fast to nth position\\n        for i in range(n):\\n            fast = fast.next\\n            \\n        if not fast:\\n            return head.next\\n        # then advance both fast and slow now they are nth postions apart\\n        # when fast gets to None, slow will be just before the item to be deleted\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        # delete the node\\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8812,
                "title": "my-short-c-solution",
                "content": "    class Solution\\n    {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n)\\n        {\\n            ListNode** t1 = &head, *t2 = head;\\n            for(int i = 1; i < n; ++i)\\n            {\\n                t2 = t2->next;\\n            }\\n            while(t2->next != NULL)\\n            {\\n                t1 = &((*t1)->next);\\n                t2 = t2->next;\\n            }\\n            *t1 = (*t1)->next;\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n)\\n        {\\n            ListNode** t1 = &head, *t2 = head;\\n            for(int i = 1; i < n; ++i)\\n            {\\n                t2 = t2->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8843,
                "title": "c-solution-easy-to-understand-with-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe difference between the final node and the `to_be_delete` node is N. And here the assumption is that n is <b>always</b> valid.\\n\\n`fast` pointer points to the node which is N step away from the `to_be_delete` node.<br>\\n`slow` pointer points to the `to_be_delete` node.\\n\\nThe algorithms is described as below:\\n\\n<b>Firstly</b>, move `fast` pointer N step forward.<br>\\n<b>Secondly</b>,move `fast` and `slow` pointers simultaneously <b>one step a time</b> forward till the `fast` pointer reach the end, which will cause the `slow` pointer points to the previous node of the `to_be_delete` node.\\n\\n<b>Finally</b>, `slow->next = slow->next->next`.\\n\\n    ListNode *removeNthFromEnd(ListNode *head, int n) \\n    {\\n        if (!head)\\n            return nullptr;\\n    \\n        ListNode new_head(-1);\\n        new_head.next = head;\\n\\n        ListNode *slow = &new_head, *fast = &new_head;\\n\\n        for (int i = 0; i < n; i++)\\n            fast = fast->next;\\n\\n        while (fast->next) \\n        {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode *to_de_deleted = slow->next;\\n        slow->next = slow->next->next;\\n        \\n        delete to_be_deleted;\\n\\n        return new_head.next;\\n    }\\n**Fixed : Added code for deleting the N-th node.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe difference between the final node and the `to_be_delete` node is N. And here the assumption is that n is <b>always</b> valid.\\n\\n`fast` pointer points to the node which is N step away from the `to_be_delete` node.<br>\\n`slow` pointer points to the `to_be_delete` node.\\n\\nThe algorithms is described as below:\\n\\n<b>Firstly</b>, move `fast` pointer N step forward.<br>\\n<b>Secondly</b>,move `fast` and `slow` pointers simultaneously <b>one step a time</b> forward till the `fast` pointer reach the end, which will cause the `slow` pointer points to the previous node of the `to_be_delete` node.\\n\\n<b>Finally</b>, `slow->next = slow->next->next`.\\n\\n    ListNode *removeNthFromEnd(ListNode *head, int n) \\n    {\\n        if (!head)\\n            return nullptr;\\n    \\n        ListNode new_head(-1);\\n        new_head.next = head;\\n\\n        ListNode *slow = &new_head, *fast = &new_head;\\n\\n        for (int i = 0; i < n; i++)\\n            fast = fast->next;\\n\\n        while (fast->next) \\n        {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode *to_de_deleted = slow->next;\\n        slow->next = slow->next->next;\\n        \\n        delete to_be_deleted;\\n\\n        return new_head.next;\\n    }\\n**Fixed : Added code for deleting the N-th node.**",
                "codeTag": "Unknown"
            },
            {
                "id": 589304,
                "title": "clear-java-solution-with-detailed-explanation",
                "content": "ok lets do this!!\\nso we are given a linked list and an number \\'n\\'\\nthis n is the number of root from last which needs to be removed!!\\nfor example\\n1->2->3->4->5->6->7\\nn=3\\nmeans we have to delete the 3rd node from the last(5th node from the beginning).\\nnow that the question is clear !\\n\\nlets move to the answer!\\npiece of advice-whenever you see a linked list removal type question ,always make a dummy node at the beginning!\\nanyways!\\n\\nLOGIC-\\n1>we keep two pointer slow and fast(both move one at a time)both initially at start of list(at the dummy node)\\n2>we move the fast to n+1 places away from the slow pointer\\n3>we then traverse the list we check if fast is equal to null or not,if it is null we know that the slow pointer has reached just one node  before the node we need to delete!\\n4>then we slow.next=slow.next.next!\\n\\nshould we do a dry run!\\nwhy not!\\nsuppose:\\n1->2->3->4->5->6\\nn=2\\nmake a dummy node with val=0;(we call this start)\\nso now our list looks like\\n0->1->2->3->4->5->6\\nslow ,start , fast all are pointing to 0 valued node!\\nafter executing step 2 of our algorithm we have \\nslow and start still at 0\\nbut fast is at node with val 3;\\nnow we execute step 3\\ndifferent positions of slow and fast is shown below!\\n[slow=1,fast=4]->[slow=2,fast=5]->[slow=3,fast=6]->[slow=4,fast=null]\\nwow!!slow have reached  one node before out target node\\nnow just do slow.next=slow.next.next;\\n\\ndo a couple of dry runs on your own to get the logic!\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    \\n    ListNode start = new ListNode(0);\\n    ListNode slow = start, fast = start;\\n    start.next = head;\\n    \\n    \\n    for(int i=1; i<=n+1; i++)   {\\n        fast = fast.next;\\n    }\\n    \\n    while(fast != null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\n    slow.next = slow.next.next;\\n    return start.next;\\n}\\n```\\n\\nhope it helps!\\nupvote the answer if you like it so that more people can benefit !\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    \\n    ListNode start = new ListNode(0);\\n    ListNode slow = start, fast = start;\\n    start.next = head;\\n    \\n    \\n    for(int i=1; i<=n+1; i++)   {\\n        fast = fast.next;\\n    }\\n    \\n    while(fast != null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\n    slow.next = slow.next.next;\\n    return start.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492814,
                "title": "beats-100-full-proper-explanation-with-images",
                "content": "# Intuition\\nwe can find the nth node just by one traversal by using two pointer approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake two dummy nodes, who\\u2019s next will be pointing to the head.\\nTake another node to store the head, initially,s a dummy node(start), and the next node will be pointing to the head. The reason why we are using this extra dummy node is that there is an edge case. If the node is equal to the length of the LinkedList, then this slow will point to slow\\u2019s next\\u2192 next. And we can say our dummy start node will be broken and will be connected to the slow next\\u2192 next.\\n\\nStart traversing until the fast pointer reaches the nth node.\\n![image.png](https://assets.leetcode.com/users/images/6d30920b-bf59-4564-897d-869a54148190_1683371160.3817167.png)\\n\\nNow start traversing by one step both of the pointers until the fast pointers reach the end.\\n    \\n![image.png](https://assets.leetcode.com/users/images/6e6e1af9-8863-4eff-988c-decc91e86746_1683371181.7739182.png)\\n\\nWhen the traversal is done, just do the deleting part. Make slow pointers next to the next of the slow pointer to ignore/disconnect the given node.\\n![image.png](https://assets.leetcode.com/users/images/8fd772c7-a44b-4569-99bd-293d4c5dcd32_1683371203.3690717.png)\\n\\n\\nLast, return to the next start.\\nDry Run:  We will be taking the first example for the dry run, so, the LinkedList is [1,2,3,4,5] and the node which has to be deleted is 2 from the last. For the first time, fast ptr starts traversing from node 1 and reaches 2, as it traverses for node number 2, then the slow ptr starts increasing one, and as well as the fast ptr until it reaches the end.\\n\\n1st traversal : fast=3, slow=1\\n2nd traversal : fast=4, slow=2\\n3rd traversal : fast=5, slow=3\\nNow, the slow->next->next will be pointed to the slow->next\\n\\nSo , the new linked list will be [1,2,3,5]\\n\\nNote that the above approach is provided by Striver on Youtube I highly recommend to checkout  his video solutions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757145,
                "title": "c-del-n-th-node-from-the-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) .\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n\\n        ListNode* fast=temp;\\n        ListNode* slow=temp;\\n\\n        for(int i=1;i<=n;i++){\\n             fast=fast->next;\\n        }\\n\\n        while(fast->next!=NULL){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n\\n        ListNode* gaya=slow->next;\\n        slow->next=slow->next->next;\\n        delete(gaya);\\n        \\n        return temp->next;\\n    }\\n};\\nif it helps plzz don\\'t Forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n\\n        ListNode* fast=temp;\\n        ListNode* slow=temp;\\n\\n        for(int i=1;i<=n;i++){\\n             fast=fast->next;\\n        }\\n\\n        while(fast->next!=NULL){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n\\n        ListNode* gaya=slow->next;\\n        slow->next=slow->next->next;\\n        delete(gaya);\\n        \\n        return temp->next;\\n    }\\n};\\nif it helps plzz don\\'t Forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8806,
                "title": "my-one-pass-solution",
                "content": "    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        ListNode h1=head, h2=head;\\n        while(n-->0) h2=h2.next;\\n        if(h2==null)return head.next;  // The head need to be removed, do it.\\n        h2=h2.next;\\n        \\n        while(h2!=null){\\n            h1=h1.next;\\n            h2=h2.next;\\n        }\\n        h1.next=h1.next.next;   // the one after the h1 need to be removed\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        ListNode h1=head, h2=head;\\n        while(n-->0) h2=h2.next;\\n        if(h2==null)return head.next;  // The head need to be removed, do it.\\n        h2=h2.next;\\n        \\n        while(h2!=null){\\n            h1=h1.next;\\n            h2=h2.next;\\n        }\\n        h1.next=h1.next.next;   // the one after the h1 need to be removed\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9032,
                "title": "python-concise-one-pass-solution-with-dummy-head",
                "content": "\\n    def removeNthFromEnd(self, head, n):\\n        fast = slow = dummy = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(n):\\n            fast = fast.next\\n        while fast and fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def removeNthFromEnd(self, head, n):\\n        fast = slow = dummy = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(n):\\n            fast = fast.next\\n        while fast and fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 1401309,
                "title": "single-pass-python-solution-o-n-easy-sr",
                "content": "**Please upvote if you get this**\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        i,j=head, head\\n        for k in range(n):\\n            j = j.next\\n        #now i and j will be at difference n\\n        if j == None: #Only happens when we are supposed to remove the first element\\n            return head.next\\n        while j.next != None:\\n            i = i.next\\n            j = j.next\\n        i.next = i.next.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        i,j=head, head\\n        for k in range(n):\\n            j = j.next\\n        #now i and j will be at difference n\\n        if j == None: #Only happens when we are supposed to remove the first element\\n            return head.next\\n        while j.next != None:\\n            i = i.next\\n            j = j.next\\n        i.next = i.next.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632794,
                "title": "c-diagram-related-problems",
                "content": "**Approach**\\n- Take two pointers p and q at the head of linked list.\\n- Move q pointers by n to the right. Here n = 2.\\n- Then move both p and q pointers to right until q reaches the end.\\n- Then change pointer of p node to its next to next node.\\n- Don\\'t forget to delete the last nth node.\\n\\n**Digram Representation**\\n\\n![image](https://assets.leetcode.com/users/images/295d90c6-c36f-48b5-a83a-7028b8640f4e_1664330424.1773272.png)\\n\\n**C++ Code**\\n\\n```cpp\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) return head->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        ListNode* toDelete = p->next;\\n        p->next = p->next->next;\\n        delete toDelete;\\n        return head;\\n}\\n```\\n\\n**Related Problems**\\n[1. Linked List Cycle ](https://leetcode.com/problems/linked-list-cycle/)\\n[2. Linked List Cycle II ](https://leetcode.com/problems/linked-list-cycle-ii/)\\n[3. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[4. Sort List ](https://leetcode.com/problems/sort-list/)\\n[5. Swapping Nodes in a Linked List ](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) return head->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        ListNode* toDelete = p->next;\\n        p->next = p->next->next;\\n        delete toDelete;\\n        return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9000,
                "title": "a-simple-2ms-c-solution",
                "content": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {\\n\\n    struct ListNode* front = head;\\n    struct ListNode* behind = head;\\n    \\n    while (front != NULL) {\\n        front = front->next;\\n        \\n        if (n-- < 0) behind = behind->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else behind->next = behind->next->next;\\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {\\n\\n    struct ListNode* front = head;\\n    struct ListNode* behind = head;\\n    \\n    while (front != NULL) {\\n        front = front->next;\\n        \\n        if (n-- < 0) behind = behind->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else behind->next = behind->next->next;\\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 8822,
                "title": "java-solution-1ms-u5bb9-u6613-u7406-u89e3",
                "content": "    //\\u8fd8\\u662f\\u8d70\\u7684\\u5feb\\u7684\\u70b9(fastNode)\\u4e0e\\u8d70\\u5f97\\u6162\\u7684\\u70b9(slowNode)\\u8def\\u7a0b\\u5dee\\u7684\\u95ee\\u9898\\n    \\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n            ListNode headNode = new ListNode(9527);\\n            headNode.next = head;\\n            ListNode fastNode = headNode;\\n            ListNode slowNode = headNode;\\n            while(fastNode.next != null){\\n            \\tif(n <= 0)\\n            \\t\\tslowNode = slowNode.next;\\n            \\tfastNode = fastNode.next;\\n            \\tn--;\\n            }\\n            if(slowNode.next != null)\\n            \\tslowNode.next = slowNode.next.next;\\n            return headNode.next;\\n        }",
                "solutionTags": [],
                "code": "    //\\u8fd8\\u662f\\u8d70\\u7684\\u5feb\\u7684\\u70b9(fastNode)\\u4e0e\\u8d70\\u5f97\\u6162\\u7684\\u70b9(slowNode)\\u8def\\u7a0b\\u5dee\\u7684\\u95ee\\u9898\\n    \\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n            ListNode headNode = new ListNode(9527);\\n            headNode.next = head;\\n            ListNode fastNode = headNode;\\n            ListNode slowNode = headNode;\\n            while(fastNode.next != null){\\n            \\tif(n <= 0)\\n            \\t\\tslowNode = slowNode.next;\\n            \\tfastNode = fastNode.next;\\n            \\tn--;\\n            }\\n            if(slowNode.next != null)\\n            \\tslowNode.next = slowNode.next.next;\\n            return headNode.next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 510175,
                "title": "python-solution-using-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n\\t\\n        slow = head # finally point to the previous node of the target node\\n        fast = head # finally point to the last node\\n        for i in range(n): # let the fast pointer move n steps ahead of the slow pointer\\n            fast = fast.next\\n        \\n        # This situation would happen when we are required to del the first node (n = len(List))\\n        # Also, it can handle the [] case\\n        if not fast:\\n            return slow.next\\n        \\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n            \\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n\\t\\n        slow = head # finally point to the previous node of the target node\\n        fast = head # finally point to the last node\\n        for i in range(n): # let the fast pointer move n steps ahead of the slow pointer\\n            fast = fast.next\\n        \\n        # This situation would happen when we are required to del the first node (n = len(List))\\n        # Also, it can handle the [] case\\n        if not fast:\\n            return slow.next\\n        \\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n            \\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307508,
                "title": "100-faster-java-code-you-will-not-get-this-much-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot 2023-03-15 185755.png](https://assets.leetcode.com/users/images/7db3581c-70aa-44f5-a6ad-bbc9a83cd0c9_1679056324.048882.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        // Create a temporary node and a counter to find the length of the linked list\\n        ListNode temp = head;\\n        int count = 0;\\n\\n        // Traverse the linked list and count the number of nodes\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        // Calculate the index of the node to be removed from the beginning of the list\\n        int len = count - n;\\n\\n        // If the first node needs to be removed, update the head and return\\n        if (len == 0) {\\n            head = head.next;\\n        } \\n        else {\\n             // Traverse the list until the node before the one to be removed\\n            ListNode prev = head;\\n            while (len - 1 != 0) {\\n                prev = prev.next;\\n                len--;\\n            }\\n        // Remove the node by updating the previous node\\'s next pointer\\n        prev.next = prev.next.next;\\n        }\\n\\n    // Return the head node of the modified list\\n    return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        // Create a temporary node and a counter to find the length of the linked list\\n        ListNode temp = head;\\n        int count = 0;\\n\\n        // Traverse the linked list and count the number of nodes\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        // Calculate the index of the node to be removed from the beginning of the list\\n        int len = count - n;\\n\\n        // If the first node needs to be removed, update the head and return\\n        if (len == 0) {\\n            head = head.next;\\n        } \\n        else {\\n             // Traverse the list until the node before the one to be removed\\n            ListNode prev = head;\\n            while (len - 1 != 0) {\\n                prev = prev.next;\\n                len--;\\n            }\\n        // Remove the node by updating the previous node\\'s next pointer\\n        prev.next = prev.next.next;\\n        }\\n\\n    // Return the head node of the modified list\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644146,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev: ListNode? = node\\n        var post: ListNode? = node\\n        \\n        for _ in 0..<n {\\n            guard let next = post?.next else { continue }\\n            post = next\\n        }\\n        \\n        while let postNext = post?.next, let prevNext = prev?.next {\\n            prev = prevNext\\n            post = postNext\\n        }\\n        \\n        prev!.next = prev!.next!.next\\n        \\n        return node.next\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><b>ListNode + Extension</b></summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    // An additional initializer that can be used to implement nodes from an array\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n```swift\\nextension ListNode: Equatable {\\n    public static func == (lhs: ListNode, rhs: ListNode) -> Bool {\\n        return lhs.val == rhs.val && lhs.next == rhs.next\\n    }\\n}\\n```\\n\\n</details>\\n</p>\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<br>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.034 (0.036) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value, ListNode([1,2,3,5]))\\n    }\\n    func test1() {\\n        let value = solution.removeNthFromEnd(ListNode([1]), 1)\\n        XCTAssertEqual(value, ListNode([]))\\n    }\\n    func test2() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2]), 1)\\n        XCTAssertEqual(value, ListNode([1]))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        let node = ListNode(0)\\n        node.next = head\\n        \\n        var prev: ListNode? = node\\n        var post: ListNode? = node\\n        \\n        for _ in 0..<n {\\n            guard let next = post?.next else { continue }\\n            post = next\\n        }\\n        \\n        while let postNext = post?.next, let prevNext = prev?.next {\\n            prev = prevNext\\n            post = postNext\\n        }\\n        \\n        prev!.next = prev!.next!.next\\n        \\n        return node.next\\n    }\\n}\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    // An additional initializer that can be used to implement nodes from an array\\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\n```swift\\nextension ListNode: Equatable {\\n    public static func == (lhs: ListNode, rhs: ListNode) -> Bool {\\n        return lhs.val == rhs.val && lhs.next == rhs.next\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2,3,4,5]), 2)\\n        XCTAssertEqual(value, ListNode([1,2,3,5]))\\n    }\\n    func test1() {\\n        let value = solution.removeNthFromEnd(ListNode([1]), 1)\\n        XCTAssertEqual(value, ListNode([]))\\n    }\\n    func test2() {\\n        let value = solution.removeNthFromEnd(ListNode([1,2]), 1)\\n        XCTAssertEqual(value, ListNode([1]))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612328,
                "title": "python-go-js-c-o-n-by-two-pointers-w-visualization",
                "content": "O(n) one-pass by two-pointers and delay\\n\\n---\\n\\n**Hint**:\\n\\nThink of **two-pointers** with **n-step delay**.\\n\\nFirst pointer keeps going till the end.\\nSecond pointer traverses to the previous node of the one being removed with n-step delay.\\n\\nWhen first pointer reach the end, the second one will be on the right position.\\nThen update linkage of second pointer and remove the N-th node from the end.\\n\\n---\\n\\n**Visualization & Diagram**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588180.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588255.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588288.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588588310.png)\\n\\n---\\n\\n**Implementation** by two-pointers and delay in Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        # use dummy head will make the removal of head node easier\\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        # cur keeps iteration till the end\\n        # prev_of_removal traverses to the previous node of the one of being removed\\n        cur, prev_of_removal = dummy_head, dummy_head\\n        \\n        \\n        while cur.next != None:\\n            \\n            # n-step delay for prev_of_removal\\n            if n <= 0:\\n                prev_of_removal = prev_of_removal.next\\n                \\n            cur = cur.next\\n            \\n            n -=1\\n        \\n        \\n        # Remove the N-th node from end of list\\n        n_th_node = prev_of_removal.next\\n        prev_of_removal.next = n_th_node.next\\n        \\n        del n_th_node\\n        \\n        return dummy_head.next\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    \\n    // use dummy head will make the removal of head node easier\\n    let dummyHead = new ListNode( -1, head);\\n    \\n    // cur keeps iteration till the end\\n    // prev_of_removal traverses to the previous node of the one of being removed    \\n    let cur = dummyHead;\\n    let prevOfRemoval = dummyHead;\\n    \\n    while( cur.next != null ){\\n        \\n        // n-step delay for prevOfRemoval\\n        if( n <= 0 ){\\n            prevOfRemoval = prevOfRemoval.next;\\n        }\\n        \\n        cur = cur.next;\\n        \\n        // update counter of n-step delay\\n        n -= 1;\\n    }\\n    \\n    \\n    nThNode = prevOfRemoval.next;\\n    prevOfRemoval.next = nThNode.next;\\n    \\n    return dummyHead.next;\\n    \\n};\\n```\\n\\n---\\n\\n**Implementation** by two-pointers and delay in Go:\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    \\n    dummyHead := &ListNode{-1, head}\\n    \\n    cur, prevOfRemoval := dummyHead, dummyHead\\n    \\n    for cur.Next != nil{\\n        \\n        // n step delay for prevOfRemoval\\n        if n <= 0 {\\n            prevOfRemoval = prevOfRemoval.Next\\n        }\\n        \\n        cur = cur.Next\\n        \\n        n -= 1\\n    }\\n    \\n    // Remove the N-th node from end of list\\n    nthNode := prevOfRemoval.Next\\n    prevOfRemoval.Next = nthNode.Next\\n    \\n    return dummyHead.Next\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        // use dummy head will make the removal of head node easier\\n        ListNode* dummyHead = new ListNode(-1, head);\\n        \\n        // cur keeps iteration till the end\\n        // prevOfRemoval traverses to the previous node of the one of being removied\\n        ListNode* cur = dummyHead;\\n        ListNode* prevOfRemoval = dummyHead;\\n        \\n        while( cur->next != nullptr ){\\n            \\n            // n-step delay for prevOfRemoval\\n            if( n <= 0 ){\\n                prevOfRemoval = prevOfRemoval->next;\\n            }\\n            \\n            cur = cur->next;\\n            \\n            // update counter of n step delay\\n            n -= 1;\\n        }\\n        \\n        // Remove the n-th node from end of list\\n        ListNode* nThNode = prevOfRemoval->next;\\n        prevOfRemoval->next = nThNode->next;\\n        \\n        delete nThNode;\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        # use dummy head will make the removal of head node easier\\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        # cur keeps iteration till the end\\n        # prev_of_removal traverses to the previous node of the one of being removed\\n        cur, prev_of_removal = dummy_head, dummy_head\\n        \\n        \\n        while cur.next != None:\\n            \\n            # n-step delay for prev_of_removal\\n            if n <= 0:\\n                prev_of_removal = prev_of_removal.next\\n                \\n            cur = cur.next\\n            \\n            n -=1\\n        \\n        \\n        # Remove the N-th node from end of list\\n        n_th_node = prev_of_removal.next\\n        prev_of_removal.next = n_th_node.next\\n        \\n        del n_th_node\\n        \\n        return dummy_head.next\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    \\n    // use dummy head will make the removal of head node easier\\n    let dummyHead = new ListNode( -1, head);\\n    \\n    // cur keeps iteration till the end\\n    // prev_of_removal traverses to the previous node of the one of being removed    \\n    let cur = dummyHead;\\n    let prevOfRemoval = dummyHead;\\n    \\n    while( cur.next != null ){\\n        \\n        // n-step delay for prevOfRemoval\\n        if( n <= 0 ){\\n            prevOfRemoval = prevOfRemoval.next;\\n        }\\n        \\n        cur = cur.next;\\n        \\n        // update counter of n-step delay\\n        n -= 1;\\n    }\\n    \\n    \\n    nThNode = prevOfRemoval.next;\\n    prevOfRemoval.next = nThNode.next;\\n    \\n    return dummyHead.next;\\n    \\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    \\n    dummyHead := &ListNode{-1, head}\\n    \\n    cur, prevOfRemoval := dummyHead, dummyHead\\n    \\n    for cur.Next != nil{\\n        \\n        // n step delay for prevOfRemoval\\n        if n <= 0 {\\n            prevOfRemoval = prevOfRemoval.Next\\n        }\\n        \\n        cur = cur.Next\\n        \\n        n -= 1\\n    }\\n    \\n    // Remove the N-th node from end of list\\n    nthNode := prevOfRemoval.Next\\n    prevOfRemoval.Next = nthNode.Next\\n    \\n    return dummyHead.Next\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        // use dummy head will make the removal of head node easier\\n        ListNode* dummyHead = new ListNode(-1, head);\\n        \\n        // cur keeps iteration till the end\\n        // prevOfRemoval traverses to the previous node of the one of being removied\\n        ListNode* cur = dummyHead;\\n        ListNode* prevOfRemoval = dummyHead;\\n        \\n        while( cur->next != nullptr ){\\n            \\n            // n-step delay for prevOfRemoval\\n            if( n <= 0 ){\\n                prevOfRemoval = prevOfRemoval->next;\\n            }\\n            \\n            cur = cur->next;\\n            \\n            // update counter of n step delay\\n            n -= 1;\\n        }\\n        \\n        // Remove the n-th node from end of list\\n        ListNode* nThNode = prevOfRemoval->next;\\n        prevOfRemoval->next = nThNode->next;\\n        \\n        delete nThNode;\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734524,
                "title": "0ms-faster-than-100-java-easy-sol-only-iteration-no-stacks",
                "content": "Please **Upvote** if it helped you.\\n\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 0; // creating a counter variable to get the number of Nodes\\n        \\n        ListNode list = head;  // here creating a Node that will point to the head Node, so the list is now pointing to the head Node\\n        \\n        while(list != null) {    // as list is pointing to head Node and I wanna reach to the end Node, \\n                                // I will run a loop starting from head Node until the end of the list i.e. until the list becomes null\\n            \\n            list = list.next;   // this statement will make \"list\" point to the next Node ( like in i++, if i is 1 then it will become 2 )\\n                                // before list ---> head..... now list ---> head.next ( for easy understanding )\\n            count++;            // as we\\'ll go forward, we\\'ll keep on increasing our counter variable to know the size of the list\\n        }\\n        \\n        int node = count - n;   // this is position of required Node from the start \\n                                // if list.size() == 9 and we need to delete 2nd element from end\\n                                // node = 9 (size) - 2 (end position)  == 7 (position from start)\\n        \\n        if( node == 0) {        // suppose in above example position from end is 9\\n                                // means position from start ==> 9-9 = 0\\n                                // we have to delete the first element that is head so we\\'ll simply return head.next \\n                                \\n            return head.next;   // list that will pass the whole list except head because we wanna delete it so head.next \\n                                // as mentioned earlier head.next will point to second Node head here\\n\\n        }\\n        list = head;            // now if you remember, we have iterated through this list pointer to know the size, so it will be pointing to the \\n                                // last Node, in this statement I made sure that it again will point to the head Node ( Now you can understand why \\n                                // we created a seperate Node \"list\" and not used the head Node in the argument\\n        \\n        while(node-- > 1) {     // here I\\'m simply running a loop till node becomes less than 1 (not 0 because we need to go the Node before the \\n                                // Node we wanna delete ( like if we wanna delete 7th Node so we\\'ll go to Node 6 ) you\\'ll see why\\n            list = list.next;   // now the list Node will point to the 6th Node if we wanna delete 7th, after this loop completes\\n        }\\n        list.next = list.next.next;     // simply understand it by the notations below\\n                                        // current situation :-  list ----> Node (6th)\\n                                        //                       list.next = 7th Node\\n                                        //                       list.next.next = 8th Node ( null if not present )\\n                                        //  so here\\'s the basic logic  :- if we wanna remove 7th Node we\\'ll just cut it\\'s link from 6th Node \\n                                        //  and we\\'ll make our 8th Node as 7th by pointing 6th Node\\'s next to the 8th Node so 6th ----> 8th \\n                                        \\n        return head;                    // we can\\'t return \"list\" for reasons explained earlier beacaue currently list is pointing to 6th Node\\n                                        // and we have to return the starting Node so we\\'ll return head Node\\n                                        // if you\\'re wondering how? then let me make this also clear that \"list\" is not a copy of head, it\\'s just pointing \\n                                        // to head Node, so the changes made will also reflect in the head Node\\n                                        // I hope I explained everything, so Please Upvote if you haven\\'t already\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 0; // creating a counter variable to get the number of Nodes\\n        \\n        ListNode list = head;  // here creating a Node that will point to the head Node, so the list is now pointing to the head Node\\n        \\n        while(list != null) {    // as list is pointing to head Node and I wanna reach to the end Node, \\n                                // I will run a loop starting from head Node until the end of the list i.e. until the list becomes null\\n            \\n            list = list.next;   // this statement will make \"list\" point to the next Node ( like in i++, if i is 1 then it will become 2 )\\n                                // before list ---> head..... now list ---> head.next ( for easy understanding )\\n            count++;            // as we\\'ll go forward, we\\'ll keep on increasing our counter variable to know the size of the list\\n        }\\n        \\n        int node = count - n;   // this is position of required Node from the start \\n                                // if list.size() == 9 and we need to delete 2nd element from end\\n                                // node = 9 (size) - 2 (end position)  == 7 (position from start)\\n        \\n        if( node == 0) {        // suppose in above example position from end is 9\\n                                // means position from start ==> 9-9 = 0\\n                                // we have to delete the first element that is head so we\\'ll simply return head.next \\n                                \\n            return head.next;   // list that will pass the whole list except head because we wanna delete it so head.next \\n                                // as mentioned earlier head.next will point to second Node head here\\n\\n        }\\n        list = head;            // now if you remember, we have iterated through this list pointer to know the size, so it will be pointing to the \\n                                // last Node, in this statement I made sure that it again will point to the head Node ( Now you can understand why \\n                                // we created a seperate Node \"list\" and not used the head Node in the argument\\n        \\n        while(node-- > 1) {     // here I\\'m simply running a loop till node becomes less than 1 (not 0 because we need to go the Node before the \\n                                // Node we wanna delete ( like if we wanna delete 7th Node so we\\'ll go to Node 6 ) you\\'ll see why\\n            list = list.next;   // now the list Node will point to the 6th Node if we wanna delete 7th, after this loop completes\\n        }\\n        list.next = list.next.next;     // simply understand it by the notations below\\n                                        // current situation :-  list ----> Node (6th)\\n                                        //                       list.next = 7th Node\\n                                        //                       list.next.next = 8th Node ( null if not present )\\n                                        //  so here\\'s the basic logic  :- if we wanna remove 7th Node we\\'ll just cut it\\'s link from 6th Node \\n                                        //  and we\\'ll make our 8th Node as 7th by pointing 6th Node\\'s next to the 8th Node so 6th ----> 8th \\n                                        \\n        return head;                    // we can\\'t return \"list\" for reasons explained earlier beacaue currently list is pointing to 6th Node\\n                                        // and we have to return the starting Node so we\\'ll return head Node\\n                                        // if you\\'re wondering how? then let me make this also clear that \"list\" is not a copy of head, it\\'s just pointing \\n                                        // to head Node, so the changes made will also reflect in the head Node\\n                                        // I hope I explained everything, so Please Upvote if you haven\\'t already\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 449061,
                "title": "simple-and-fast-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n\\t\\t// move fast pointer to the n + 1 element\\n        while (n--) { fast = fast->next; }\\n        \\n        // handle edge case: given n is always valid, \\n        // if fast reached the end, we need to remove the first element\\n        if (fast == nullptr) return head->next;\\n\\n        // move both pointers at the same time maintaing the difference\\n        while (fast->next != nullptr) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        // slow will be pointing to the element before the one we want to remove\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n\\t\\t// move fast pointer to the n + 1 element\\n        while (n--) { fast = fast->next; }\\n        \\n        // handle edge case: given n is always valid, \\n        // if fast reached the end, we need to remove the first element\\n        if (fast == nullptr) return head->next;\\n\\n        // move both pointers at the same time maintaing the difference\\n        while (fast->next != nullptr) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        // slow will be pointing to the element before the one we want to remove\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524116,
                "title": "javascript-one-pass-two-pointer",
                "content": "**algorithm**\\n1. To remove n-th node from the end, send node `hare` as far as `n`.\\n2. Move node `curr` and `hare` in same speed until `hare` gets the last node.\\n3. Since `curr` and `hare` has gap as `n`, `curr` has n+1-th node from the end when `hare` has 1th node from the end. So change `curr.next` to `curr.next.next`.\\n\\n**edge case**\\n`n = 3` `linked list = [1,2,3]`\\n- When `n` is same with the length of the list. We need to remove first element, instead remove next element of `curr`.\\n- In this case, you can find that `hare` would be `null`, because the last element of list points `null` such as `[1,2,3,null]`\\n\\n**complexity**\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let hare = head, curr = head;\\n    while (n--) {\\n        hare = hare.next;\\n    }\\n    while (hare && hare.next) {\\n        curr = curr.next;\\n        hare = hare.next;\\n    }\\n    if (!hare) {\\n        head = head.next;\\n    } else {\\n        curr.next = curr.next ? curr.next.next : null;\\n    }\\n    return head;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let hare = head, curr = head;\\n    while (n--) {\\n        hare = hare.next;\\n    }\\n    while (hare && hare.next) {\\n        curr = curr.next;\\n        hare = hare.next;\\n    }\\n    if (!hare) {\\n        head = head.next;\\n    } else {\\n        curr.next = curr.next ? curr.next.next : null;\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651738,
                "title": "c-simplest-solution-one-pass-two-pointer-technique",
                "content": "* To solve this problem in one-pass & O(n) space, we need to find a way to both reach the end of the linked list & reach the nth node from the end simultaneoulsy.\\n* To do that, we initialize 2 pointers ```*fast``` & ```*slow``` both pointing to the head of the linked lits, the stagger the both by ```n``` nodes, so that ```fast``` is ```n``` nodes ahead of ```slow```.\\n* Doing this will cause ```slow``` to reach the ```n```\\'th node from the end at the same time that ```fast``` reaches the end.\\n* Since we will need access to the node before the target node in order to remove the target node, we are going to loop until ```fast->next != NULL``` rather than until ```fast != null```, so that we stop one node earlier.\\n* This method will be a problem when ```n``` is same as the no. of nodes in the linked list, which would make the first node the target node, and hence it\\'s not possible to find the node before the target node. If that\\'s the case, we can just return ```head->next```\\n\\n**Time Complexity :** O(N) - N = sz\\n\\n**Auxiliary Space :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        \\n        for(int i=0; i<n; i++) fast = fast->next;\\n        \\n        if(!fast) return head->next;\\n        \\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**If you like my solution & explanation, please upvote my post :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```*fast```\n```*slow```\n```n```\n```fast```\n```n```\n```slow```\n```slow```\n```n```\n```fast```\n```fast->next != NULL```\n```fast != null```\n```n```\n```head->next```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        \\n        for(int i=0; i<n; i++) fast = fast->next;\\n        \\n        if(!fast) return head->next;\\n        \\n        while(fast->next) fast = fast->next, slow = slow->next;\\n        \\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 9090,
                "title": "my-simple-java-solution-in-one-pass",
                "content": "     public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy;\\n        ListNode slow=dummy;\\n        int temp=n;\\n        for(;fast.next!=null;temp--){\\n            if(temp<=0){ //control\\n                slow=slow.next;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;//delete Nth\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "     public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode fast=dummy;\\n        ListNode slow=dummy;\\n        int temp=n;\\n        for(;fast.next!=null;temp--){\\n            if(temp<=0){ //control\\n                slow=slow.next;\\n            }\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;//delete Nth\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2633625,
                "title": "c-dear-deleted-node-rest-in-peace",
                "content": "### Approach 1: actually delete the removed node\\n\\nThis solution is similar to many others, with one difference: actually delete the removed node. :)\\n\\n```cpp\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode prehead(-1, head);\\n        ListNode* prev = &prehead;\\n        for (int i = 0; i < n; ++i) {\\n            head = head->next;\\n        }\\n        while (head) {\\n            head = head->next;\\n            prev = prev->next;\\n        }\\n        ListNode* rip = prev->next;\\n        prev->next = prev->next->next;\\n        // Don\\'t be that person that leaks memory. :)\\n        delete rip;\\n        return prehead.next;\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode prehead(-1, head);\\n        ListNode* prev = &prehead;\\n        for (int i = 0; i < n; ++i) {\\n            head = head->next;\\n        }\\n        while (head) {\\n            head = head->next;\\n            prev = prev->next;\\n        }\\n        ListNode* rip = prev->next;\\n        prev->next = prev->next->next;\\n        // Don\\'t be that person that leaks memory. :)\\n        delete rip;\\n        return prehead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708527,
                "title": "java-solution-100-faster-with-explanation-also-asked-in-interviews",
                "content": "**Upvote if you found this use full**\\n\\n**Also asked in Adobe, Amazon, Arcesium, Factset, Intuit, Zoho, HCL**\\n\\n```\\n// Steps-\\n    \\n// Use a dummy variable pointing to head\\n\\n// Use two pointer fast and slow pointing to dummy variable . Move first pointer for n steps\\n\\n// Then start moving both until first pointer reaches the last node and slow pointer reaches (size of list - n)th node.\\n    \\n// Then delete the next node of slow and return dummy.next;\\n\\n\\n// Concept-\\n    \\n// When you move the fast pointer to nth node, the remaining nodes to traverse is (size_of_linked_list - n).     \\n// After that, when you start moving slow pointer and fast pointer by 1 node each, \\n// it is guaranteed that slow pointer will cover a distance of (size_of_linked_list - n) nodes. And that\\'s node we want to remove.\\n\\n\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode slow=dummy;\\n        ListNode fast=dummy;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        while(fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return dummy.next;\\n    }\\n}\\n\\n```\\n\\n**Without using dummy node**\\n\\n```\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        // edge case handeled when we have to delete the 1st node i.e n=size of linked list\\n        \\n        if(fast==null)\\n            return head.next;\\n        \\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Steps-\\n    \\n// Use a dummy variable pointing to head\\n\\n// Use two pointer fast and slow pointing to dummy variable . Move first pointer for n steps\\n\\n// Then start moving both until first pointer reaches the last node and slow pointer reaches (size of list - n)th node.\\n    \\n// Then delete the next node of slow and return dummy.next;\\n\\n\\n// Concept-\\n    \\n// When you move the fast pointer to nth node, the remaining nodes to traverse is (size_of_linked_list - n).     \\n// After that, when you start moving slow pointer and fast pointer by 1 node each, \\n// it is guaranteed that slow pointer will cover a distance of (size_of_linked_list - n) nodes. And that\\'s node we want to remove.\\n\\n\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode slow=dummy;\\n        ListNode fast=dummy;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        while(fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return dummy.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution \\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        if(head.next==null)\\n            return null;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head;\\n        \\n        for(int i=1;i<=n;i++)\\n            fast=fast.next;\\n        \\n        // edge case handeled when we have to delete the 1st node i.e n=size of linked list\\n        \\n        if(fast==null)\\n            return head.next;\\n        \\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next;\\n            slow=slow.next;\\n        }\\n        \\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588515,
                "title": "go",
                "content": "```\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {    \\n    dummy := &ListNode{Next: head}\\n    slow, fast := dummy, dummy\\n    \\n    for i := 0; i <= n; i++ {\\n        fast = fast.Next\\n    }\\n    \\n    for fast != nil {\\n        fast = fast.Next\\n        slow = slow.Next\\n    }\\n    \\n    slow.Next = slow.Next.Next\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {    \\n    dummy := &ListNode{Next: head}\\n    slow, fast := dummy, dummy\\n    \\n    for i := 0; i <= n; i++ {\\n        fast = fast.Next\\n    }\\n    \\n    for fast != nil {\\n        fast = fast.Next\\n        slow = slow.Next\\n    }\\n    \\n    slow.Next = slow.Next.Next\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9094,
                "title": "here-is-my-solution-in-c-one-pass-2-pointers-with-comments",
                "content": "    struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* HEAD1;\\n    struct ListNode* HEAD2;\\n    HEAD1=head;\\n    HEAD2=head;\\n    for(int i=0;i<n;i++) //take pointer HEAD1 n places ahead of HEAD2\\n    {   \\n        HEAD1=HEAD1->next;\\n        if(!HEAD1)          // when we have to delete the first node\\n        return head->next;\\n    }  \\n    while(HEAD1->next)   //take HEAD1 to last node so that HEAD2 is 1 behind the node we want to delete\\n    {   \\n        HEAD2=HEAD2->next;\\n        HEAD1=HEAD1->next;\\n        \\n    }\\n    HEAD2->next=HEAD2->next->next; // delete the node next to HEAD2\\n    \\n    \\n    return head;\\n    \\n}",
                "solutionTags": [],
                "code": "    struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\\n    struct ListNode* HEAD1;\\n    struct ListNode* HEAD2;\\n    HEAD1=head;\\n    HEAD2=head;\\n    for(int i=0;i<n;i++) //take pointer HEAD1 n places ahead of HEAD2\\n    {   \\n        HEAD1=HEAD1->next;\\n        if(!HEAD1)          // when we have to delete the first node\\n        return head->next;\\n    }  \\n    while(HEAD1->next)   //take HEAD1 to last node so that HEAD2 is 1 behind the node we want to delete\\n    {   \\n        HEAD2=HEAD2->next;\\n        HEAD1=HEAD1->next;\\n        \\n    }\\n    HEAD2->next=HEAD2->next->next; // delete the node next to HEAD2\\n    \\n    \\n    return head;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1164532,
                "title": "remove-nth-node-from-end-of-list-simple-one-pass-solution-w-explanation",
                "content": "This problem is very similar to the **[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/)** (which was given in *March LeetCoding Challenge 2021* as well), just that we have to **remove** the kth node from the end instead of swapping it.\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (One-Pointer, Two-Pass)***\\n\\nThis approach is very intuitive and easy to get. \\n\\n* We just iterate in the first-pass to find the length of the linked list - **`len`**.\\n\\n* In the next pass, iterate **`len - n - 1`** nodes from start and delete the next node (which would be *`nth`* node from end).\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. \\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution (Two-Pointer, One-Pass)***\\n\\nWe are required to remove the nth node from the end of list. For this, we need to traverse *`N - n`* nodes from the start of the list, where *`N`* is the length of linked list. We can do this in one-pass as follows -\\n\\n* Let\\'s assign two pointers - **`fast`** and **`slow`** to head. We will first iterate for *`n`* nodes from start using the *`fast`* pointer. \\n\\n* Now, between the *`fast`*  and *`slow`* pointers, **there is a gap of `n` nodes**. Now, just Iterate and increment both the pointers till `fast` reaches the last node. The gap between `fast` and `slow` is still of `n` nodes, meaning that **`slow` is nth node from the last node (which currently is `fast`)**.\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\\n\\n * Since we have to **delete the nth node from end of list** (And not nth from the last of list!), we just delete the next node to **`slow`** pointer and return the head.\\n\\n---\\n\\n**C++**\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**, where, `N` is the number of nodes in the given list. Although, the time complexity is same as above solution, we have reduced the constant factor in it to half.\\n***Space Complexity :*** **`O(1)`**, since only constant space is used.\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it**. A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n\\n---\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/6c81d074-139d-4de5-96f5-5943f62a2cca_1618736585.2373421.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any questions or mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode* iter = head;\\n\\tint len = 0, i = 1;\\n\\twhile(iter) iter = iter -> next, len++;    // finding the length of linked list\\n\\tif(len == n) return head -> next;          // if head itself is to be deleted, just return head -> next\\n\\tfor(iter = head; i < len - n; i++) iter = iter -> next; // iterate first len-n nodes\\n\\titer -> next = iter -> next -> next;      // remove the nth node from the end\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tptr, length = head, 0\\n\\twhile ptr:\\n\\t\\tptr, length = ptr.next, length + 1\\n\\tif length == n : return head.next\\n\\tptr = head\\n\\tfor i in range(1, length - n):\\n\\t\\tptr = ptr.next\\n\\tptr.next = ptr.next.next\\n\\treturn head\\n```\n```\\nFor eg. let the list be 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9, and n = 4.\\n\\n1. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n   ^slow               ^fast\\n   |<--gap of n nodes-->|\\n \\n => Now traverse till fast reaches end\\n \\n 2. 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> null\\n                        ^slow               ^fast\\n                        |<--gap of n nodes-->|\\n\\t\\t\\t\\t\\t\\t\\n\\'slow\\' is at (n+1)th node from end.\\nSo just delete nth node from end by assigning slow -> next as slow -> next -> next (which would remove nth node from end of list).\\n```\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tListNode *fast = head, *slow = head;\\n\\twhile(n--) fast = fast -> next;      // iterate first n nodes using fast\\n\\tif(!fast) return head -> next;       // if fast is already null, it means we have to delete head itself. So, just return next of head\\n\\twhile(fast -> next)                  // iterate till fast reaches the last node of list\\n\\t\\tfast = fast -> next, slow = slow -> next;            \\n\\tslow -> next = slow -> next -> next; // remove the nth node from last\\n\\treturn head;\\n}\\n```\n```\\ndef removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n\\tfast = slow = head\\n\\tfor i in range(n):\\n\\t\\tfast = fast.next\\n\\tif not fast: return head.next\\n\\twhile fast.next:\\n\\t\\tfast, slow = fast.next, slow.next\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1164545,
                "title": "remove-nth-node-from-end-of-list-js-python-java-c-easy-two-pointer-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWith a singly linked list, the _only_ way to find the end of the list, and thus the **n**\\'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the **n**\\'th from the end once we reach the end, but that would take **O(M) extra space**, where **M** is the length of the linked list.\\n\\nA slightly less naive approach would be to only store only the last **n+1** node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the **space complexity** to **O(N+1)**.\\n\\nIn order to solve this problem in only one pass and **O(1) extra space**, however, we would need to find a way to _both_ reach the end of the list with one pointer _and also_ reach the **n**\\'th node from the end simultaneously with a second pointer.\\n\\nTo do that, we can simply stagger our two pointers by **n** nodes by giving the first pointer (**fast**) a head start before starting the second pointer (**slow**). Doing this will cause **slow** to reach the **n**\\'th node from the end at the same time that **fast** reaches the end.\\n\\n![Visual 1](https://i.imgur.com/BSiLKj0.png)\\n\\nSince we will need access to the node _before_ the target node in order to remove the target node, we can use **fast.next == null** as our exit condition, rather than **fast == null**, so that we stop one node earlier.\\n\\nThis will unfortunately cause a problem when **n** is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node _before_ the target node. If that\\'s the case, however, we can just **return head.next** without needing to stitch together the two sides of the target node.\\n\\nOtherwise, once we succesfully find the node _before_ the target, we can then stitch it together with the node _after_ the target, and then **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences between the code of all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **60ms / 40.6MB** (beats 100% / 13%).\\n```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 92% / 99%).\\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.5MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 10.6MB** (beats 100% / 93%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar removeNthFromEnd = function(head, n) {\\n    let fast = head, slow = head\\n    for (let i = 0; i < n; i++) fast = fast.next\\n    if (!fast) return head.next\\n    while (fast.next) fast = fast.next, slow = slow.next\\n    slow.next = slow.next.next\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast, slow = head, head\\n        for _ in range(n): fast = fast.next\\n        if not fast: return head.next\\n        while fast.next: fast, slow = fast.next, slow.next\\n        slow.next = slow.next.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        for (int i = 0; i < n; i++) fast = fast.next;\\n        if (fast == null) return head.next;\\n        while (fast.next != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n        for (int i = 0; i < n; i++) fast = fast->next;\\n        if (!fast) return head->next;\\n        while (fast->next) fast = fast->next, slow = slow->next;\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512706,
                "title": "c-java-python-javascript-with-explanation-linked-list",
                "content": "# Intuition:\\nThe problem is to remove the nth node from the end of a linked list. We can find the total number of nodes in the linked list and then traverse the list again to find the nth node from the end. We can then remove the node by updating the pointer of the previous node.\\n\\n# Approach:\\n\\n1. Initialize a pointer to the head of the linked list and a count variable to 0.\\n2. Traverse the linked list and increment the count for each node until the end of the list is reached.\\n3. If the count is equal to n, remove the head node and return the next node as the new head.\\n4. Otherwise, initialize the pointer to the head of the linked list again and set n to count - n - 1.\\n5. Traverse the linked list again and update the pointer of the previous node to remove the nth node from the end.\\n6. Return the head of the linked list.\\n\\n# Complexity:\\n\\n- Time Complexity: O(n), where n is the total number of nodes in the linked list. We need to traverse the linked list twice - once to count the total number of nodes and then to find the nth node from the end.\\n\\n- Space Complexity: O(1), as we are not using any extra space and only using constant space for the pointers and count variable.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* ptr=head;\\n        int count = 0;\\n        while(ptr){\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        if(count==n){\\n            head=head->next;\\n            return head;\\n        }\\n        ptr=head;\\n        n=count-n-1;\\n        count=0;\\n        while(ptr){\\n            if(count==n){\\n                ptr->next=ptr->next->next;\\n            }\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode ptr = head;\\n        int count = 0;\\n        while (ptr != null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count == n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr != null) {\\n            if (count == n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        if head is None:\\n            return head\\n        \\n        ptr = head\\n        count = 0\\n        while ptr is not None:\\n            count += 1\\n            ptr = ptr.next\\n        \\n        if count == n:\\n            head = head.next\\n            return head\\n        \\n        ptr = head\\n        n = count - n - 1\\n        count = 0\\n        while ptr is not None:\\n            if count == n:\\n                ptr.next = ptr.next.next\\n            count += 1\\n            ptr = ptr.next\\n        \\n        return head\\n\\n```\\n---\\n\\n# JavaScript\\n```\\nvar removeNthFromEnd = function(head, n) {\\n        if (head === null) {\\n            return head;\\n        }\\n        \\n        let ptr = head;\\n        let count = 0;\\n        while (ptr !== null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count === n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr !== null) {\\n            if (count === n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* ptr=head;\\n        int count = 0;\\n        while(ptr){\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        if(count==n){\\n            head=head->next;\\n            return head;\\n        }\\n        ptr=head;\\n        n=count-n-1;\\n        count=0;\\n        while(ptr){\\n            if(count==n){\\n                ptr->next=ptr->next->next;\\n            }\\n            count++;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if (head == null) {\\n            return head;\\n        }\\n        \\n        ListNode ptr = head;\\n        int count = 0;\\n        while (ptr != null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count == n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr != null) {\\n            if (count == n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        if head is None:\\n            return head\\n        \\n        ptr = head\\n        count = 0\\n        while ptr is not None:\\n            count += 1\\n            ptr = ptr.next\\n        \\n        if count == n:\\n            head = head.next\\n            return head\\n        \\n        ptr = head\\n        n = count - n - 1\\n        count = 0\\n        while ptr is not None:\\n            if count == n:\\n                ptr.next = ptr.next.next\\n            count += 1\\n            ptr = ptr.next\\n        \\n        return head\\n\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n        if (head === null) {\\n            return head;\\n        }\\n        \\n        let ptr = head;\\n        let count = 0;\\n        while (ptr !== null) {\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        if (count === n) {\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ptr = head;\\n        n = count - n - 1;\\n        count = 0;\\n        while (ptr !== null) {\\n            if (count === n) {\\n                ptr.next = ptr.next.next;\\n            }\\n            count++;\\n            ptr = ptr.next;\\n        }\\n        \\n        return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993889,
                "title": "c-solution-with-complexity-analysis-two-methods-two-pointers",
                "content": "### T = O(m) where m is number of iterations\\n### S = O(1) no extra space used\\n```\\n  // approach using single pass using fast and slow pointer\\n\\n\\tListNode* fast = head;\\n\\tListNode* slow = head;\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfast= fast->next;\\n\\t}\\n\\n\\tif (fast == nullptr) return head->next;\\n\\n\\twhile(fast->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next;\\n\\t}\\n\\n\\tslow->next = slow->next->next;\\n\\treturn head;\\n```\\n\\n```\\n// approach using double pass\\nListNode* temp = head;\\nint l = 0;\\nwhile(temp) {\\n   temp = temp->next;\\n   l++;\\n}\\n\\n// corner case\\nif(l == n) {\\n\\treturn head->next;\\n}\\nListNode* p = head;\\nint j = 0;\\nfor(int i = 0; i < l-n-1; i++) {\\n\\tp = p->next;\\n\\tj++;\\n}\\n\\ncout << j;\\nListNode* del = p->next;\\np->next = del->next;\\ndelete del;\\nreturn head;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n  // approach using single pass using fast and slow pointer\\n\\n\\tListNode* fast = head;\\n\\tListNode* slow = head;\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfast= fast->next;\\n\\t}\\n\\n\\tif (fast == nullptr) return head->next;\\n\\n\\twhile(fast->next) {\\n\\t\\tslow = slow->next;\\n\\t\\tfast = fast->next;\\n\\t}\\n\\n\\tslow->next = slow->next->next;\\n\\treturn head;\\n```\n```\\n// approach using double pass\\nListNode* temp = head;\\nint l = 0;\\nwhile(temp) {\\n   temp = temp->next;\\n   l++;\\n}\\n\\n// corner case\\nif(l == n) {\\n\\treturn head->next;\\n}\\nListNode* p = head;\\nint j = 0;\\nfor(int i = 0; i < l-n-1; i++) {\\n\\tp = p->next;\\n\\tj++;\\n}\\n\\ncout << j;\\nListNode* del = p->next;\\np->next = del->next;\\ndelete del;\\nreturn head;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 982619,
                "title": "4-simple-solutions-explained-recursion-two-pointers-100-stack-two-runs",
                "content": "In the time complexity, I will refer to the length of the list as `m` and n and the index from the end.\\nNote: all of the solutions are run in less than  or equal to O(2 * n) but with closer look some are faster than others\\n\\nSolution 1:\\nThis solution runs in O(m + (m - n)) time with two runs once to count length second to get to the n -1 node from the end.\\nSpace O(1).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // exection with two runs\\n    {\\n        int length = 0;\\n        ListNode *p = head;\\n\\n        while (p) // find length\\n        {\\n            length++;\\n            p = p->next;\\n        }\\n\\n        if (n == length) // check if need to remove the first node\\n            return head->next;\\n\\n        length -= n;\\n        length--;\\n\\n        p = head;\\n        while (length--) // get p the node before the n-th from the end\\n            p = p->next;\\n        p->next = p->next->next; // the move the node\\n\\n        return head;\\n    }\\n```\\n\\nSolution 2:\\nThis solution runs in O(m + n) time using a stack.\\nspace O(m).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // excution using stack\\n{\\n\\tstack<ListNode *> s;\\n\\tint length = 0;\\n\\n\\tListNode *t = head;\\n\\twhile (t) // push all nodes\\n\\t{\\n\\t\\ts.push(t);\\n\\t\\tt = t->next;\\n\\t\\tlength++;\\n\\t}\\n\\n\\tif (length == n) // if need to remove the first node\\n\\t\\treturn head->next;\\n\\n\\twhile (n--) // get the n-1 node from the end\\n\\t\\ts.pop();\\n\\tt = s.top();\\n\\tt->next = t->next->next; // remove the node\\n\\n\\treturn head;\\n}\\n```\\n\\nSolution 3:\\nThis solution runs in O(m) time using backtracking and rebuilding the list.\\nSpace O(m)\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n)\\n{\\n\\tif(head == NULL) // if end\\n\\t\\treturn NULL;\\n\\n\\thead->next = removeNthFromEnd(head->next,n);// set to the next node\\n\\n\\tif(--n == 0) // do I need to remove this node\\n\\t\\treturn head->next;\\n\\treturn head;\\n}\\n```\\n\\n\\n\\nSolution 4:\\nThis solution runs in O(m) time with two pointers with space between them thus when the one before the end the other can remove the node.\\nspace O(1).\\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // execution with two pointers\\n{\\n\\tListNode *t1 = head;\\n\\n\\twhile (t1 && n--) // get t1 to the  n+1 node thus the difference between t1 and t2 is n at all times\\n\\t\\tt1 = t1->next;\\n\\n\\tif (t1 == NULL) // if need to remove teh first Node\\n\\t\\treturn head->next;\\n\\n\\tListNode *t2 = head;\\n\\twhile (t1->next) // find the node before n-th from the end\\n\\t{\\n\\t\\tt1 = t1->next;\\n\\t\\tt2 = t2->next;\\n\\t}\\n\\tt2->next = t2->next->next;\\n\\n\\treturn head;\\n}\\n```\\nIf it helps vote up so it will reach others!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // exection with two runs\\n    {\\n        int length = 0;\\n        ListNode *p = head;\\n\\n        while (p) // find length\\n        {\\n            length++;\\n            p = p->next;\\n        }\\n\\n        if (n == length) // check if need to remove the first node\\n            return head->next;\\n\\n        length -= n;\\n        length--;\\n\\n        p = head;\\n        while (length--) // get p the node before the n-th from the end\\n            p = p->next;\\n        p->next = p->next->next; // the move the node\\n\\n        return head;\\n    }\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // excution using stack\\n{\\n\\tstack<ListNode *> s;\\n\\tint length = 0;\\n\\n\\tListNode *t = head;\\n\\twhile (t) // push all nodes\\n\\t{\\n\\t\\ts.push(t);\\n\\t\\tt = t->next;\\n\\t\\tlength++;\\n\\t}\\n\\n\\tif (length == n) // if need to remove the first node\\n\\t\\treturn head->next;\\n\\n\\twhile (n--) // get the n-1 node from the end\\n\\t\\ts.pop();\\n\\tt = s.top();\\n\\tt->next = t->next->next; // remove the node\\n\\n\\treturn head;\\n}\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n)\\n{\\n\\tif(head == NULL) // if end\\n\\t\\treturn NULL;\\n\\n\\thead->next = removeNthFromEnd(head->next,n);// set to the next node\\n\\n\\tif(--n == 0) // do I need to remove this node\\n\\t\\treturn head->next;\\n\\treturn head;\\n}\\n```\n```\\nListNode *removeNthFromEnd(ListNode *head, int &n) // execution with two pointers\\n{\\n\\tListNode *t1 = head;\\n\\n\\twhile (t1 && n--) // get t1 to the  n+1 node thus the difference between t1 and t2 is n at all times\\n\\t\\tt1 = t1->next;\\n\\n\\tif (t1 == NULL) // if need to remove teh first Node\\n\\t\\treturn head->next;\\n\\n\\tListNode *t2 = head;\\n\\twhile (t1->next) // find the node before n-th from the end\\n\\t{\\n\\t\\tt1 = t1->next;\\n\\t\\tt2 = t2->next;\\n\\t}\\n\\tt2->next = t2->next->next;\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222301,
                "title": "javascript",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n  let root = head;\\n  let clone = head;\\n  let len = 0;\\n \\n  while (clone) {\\n    len++;\\n    clone = clone.next;\\n  }\\n  \\n  let count = len - n;\\n  if (count === 0) return head.next;\\n  while (root && count > 1) {\\n    root = root.next;\\n    count--;\\n  }\\n\\n  root.next = root.next && root.next.next;\\n  return head;\\n};\\n```\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const help = (root, count) => {\\n    if (root.next) count = help(root.next, count);\\n    \\n    if (count === n) root.next = root.next.next;\\n    return ++count;\\n  }\\n  const count = help(head, 0);\\n  return count === n ? head.next : head;\\n};\\n```\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const root = new ListNode(0);\\n  root.next = head;\\n  let front = root;\\n  let back = root;\\n  while (n >= 0) {\\n    front = front.next;\\n    n--;\\n  }\\n  while (front) {\\n    front = front.next;\\n    back = back.next;\\n  }\\n  back.next = back.next.next;\\n  return root.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n  let root = head;\\n  let clone = head;\\n  let len = 0;\\n \\n  while (clone) {\\n    len++;\\n    clone = clone.next;\\n  }\\n  \\n  let count = len - n;\\n  if (count === 0) return head.next;\\n  while (root && count > 1) {\\n    root = root.next;\\n    count--;\\n  }\\n\\n  root.next = root.next && root.next.next;\\n  return head;\\n};\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const help = (root, count) => {\\n    if (root.next) count = help(root.next, count);\\n    \\n    if (count === n) root.next = root.next.next;\\n    return ++count;\\n  }\\n  const count = help(head, 0);\\n  return count === n ? head.next : head;\\n};\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n  const root = new ListNode(0);\\n  root.next = head;\\n  let front = root;\\n  let back = root;\\n  while (n >= 0) {\\n    front = front.next;\\n    n--;\\n  }\\n  while (front) {\\n    front = front.next;\\n    back = back.next;\\n  }\\n  back.next = back.next.next;\\n  return root.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9112,
                "title": "javascript-solution",
                "content": "    var removeNthFromEnd = function(head, n) {\\n        var nullHead = new ListNode(null);\\n        nullHead.next = head;\\n        var p1 = nullHead;\\n        var p2 = nullHead;\\n        \\n        for(var i = 0; i < n + 1; i++)\\n            p1 = p1.next;\\n        while(p1 !== null){\\n            p2 = p2.next;\\n            p1 = p1.next;\\n        }\\n        p2.next = p2.next.next;\\n        return nullHead.next;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeNthFromEnd = function(head, n) {\\n        var nullHead = new ListNode(null);\\n        nullHead.next = head;\\n        var p1 = nullHead;\\n        var p2 = nullHead;\\n        \\n        for(var i = 0; i < n + 1; i++)\\n            p1 = p1.next;\\n        while(p1 !== null){\\n            p2 = p2.next;\\n            p1 = p1.next;\\n        }\\n        p2.next = p2.next.next;\\n        return nullHead.next;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1899619,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        var fast = head\\n        var slow = head\\n        var count = n\\n\\n        while count > 0 {\\n            count -= 1\\n            fast = fast?.next\\n        }\\n\\n        if fast == nil { return head?.next }\\n\\n        while slow != nil && fast != nil {\\n            if fast?.next == nil { slow?.next = slow?.next?.next } // end\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return head\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {\\n        var fast = head\\n        var slow = head\\n        var count = n\\n\\n        while count > 0 {\\n            count -= 1\\n            fast = fast?.next\\n        }\\n\\n        if fast == nil { return head?.next }\\n\\n        while slow != nil && fast != nil {\\n            if fast?.next == nil { slow?.next = slow?.next?.next } // end\\n            slow = slow?.next\\n            fast = fast?.next\\n        }\\n\\n        return head\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698834,
                "title": "19-c-solution-easy-to-understand-with-explanation-conceptual-knowledgable",
                "content": "**Knockcat**\\n```\\n* Detailed Understanding of each Case.\\n* Conceptual Approach.\\n* Worth it Approach.\\n* C syntax also given.\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *temp = new ListNode;                 //Allocating Memory For New Node using new Keyword;\\n        temp = head;                                   //Initializing it to head;\\n        int cnt = 0;\\n        \\n        while(temp != NULL)\\n        {\\n            cnt++;\\n            temp = temp->next;\\n        }\\n        \\n        if(cnt == 0)\\n            return head;\\n        \\n        int cnt_first = (cnt - n) + 1;               //position of nth node from head\\n        \\n        head = Delete(head , cnt_first , cnt);       //function Delete to Delete the Node\\n        \\n        return head;\\n    }\\n    \\n    ListNode *Delete(ListNode *head, int  pos,int cnt)\\n    {\\n        if(head == NULL)\\n            return head;\\n        \\n        //If Deleted Node happen to be first Node\\n        else if(head != NULL && pos == 1)\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head\\n            curr = head;\\n            // ListNode *curr = head;           //C syntax\\n            head = head -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        //If Deleted Node happen to be Last Node\\n        else if(head != NULL && pos == cnt )    \\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            while (curr->next->next != NULL)\\n            {\\n                curr = curr->next;\\n            }\\n            ListNode *temp = new ListNode;\\n            temp = curr->next;\\n            // free(temp);                      //C syntax\\n            delete temp;\\n            temp = NULL;\\n            curr->next = NULL;\\n        }\\n        \\n        else if(cnt < pos || cnt < 1)\\n        {\\n            // cout<<\"Not a valid position\"<<end;\\n        }\\n        \\n        //If Deleted Node happen to be the Intermediate Node\\n        else\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            ListNode *prev = new ListNode;\\n            prev = head;\\n            // ListNode *prev = NULL, *curr = head; //C syntax\\n            while(pos > 1)\\n            {\\n                prev = curr;\\n                curr = curr -> next;\\n                pos--;\\n            }\\n            prev -> next = curr -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n* Detailed Understanding of each Case.\\n* Conceptual Approach.\\n* Worth it Approach.\\n* C syntax also given.\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *temp = new ListNode;                 //Allocating Memory For New Node using new Keyword;\\n        temp = head;                                   //Initializing it to head;\\n        int cnt = 0;\\n        \\n        while(temp != NULL)\\n        {\\n            cnt++;\\n            temp = temp->next;\\n        }\\n        \\n        if(cnt == 0)\\n            return head;\\n        \\n        int cnt_first = (cnt - n) + 1;               //position of nth node from head\\n        \\n        head = Delete(head , cnt_first , cnt);       //function Delete to Delete the Node\\n        \\n        return head;\\n    }\\n    \\n    ListNode *Delete(ListNode *head, int  pos,int cnt)\\n    {\\n        if(head == NULL)\\n            return head;\\n        \\n        //If Deleted Node happen to be first Node\\n        else if(head != NULL && pos == 1)\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head\\n            curr = head;\\n            // ListNode *curr = head;           //C syntax\\n            head = head -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        //If Deleted Node happen to be Last Node\\n        else if(head != NULL && pos == cnt )    \\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            while (curr->next->next != NULL)\\n            {\\n                curr = curr->next;\\n            }\\n            ListNode *temp = new ListNode;\\n            temp = curr->next;\\n            // free(temp);                      //C syntax\\n            delete temp;\\n            temp = NULL;\\n            curr->next = NULL;\\n        }\\n        \\n        else if(cnt < pos || cnt < 1)\\n        {\\n            // cout<<\"Not a valid position\"<<end;\\n        }\\n        \\n        //If Deleted Node happen to be the Intermediate Node\\n        else\\n        {\\n            ListNode *curr = new ListNode;      //Allocating memory using keyword new & then initializing node to head;\\n            curr = head;\\n            ListNode *prev = new ListNode;\\n            prev = head;\\n            // ListNode *prev = NULL, *curr = head; //C syntax\\n            while(pos > 1)\\n            {\\n                prev = curr;\\n                curr = curr -> next;\\n                pos--;\\n            }\\n            prev -> next = curr -> next;\\n            // free(curr);                      //C syntax\\n            delete curr;\\n            curr = NULL;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1164614,
                "title": "python-two-pointers-approch-explained",
                "content": "Two passes solution is straightforward. For one pass solution we use the idea of `2` iterators, let one of them start at the beginning, another at index `n`, then when the second one is finished, the first one will be on the right place.\\n\\n#### Complexity\\nTime complexity is `O(L)`, more precisely we make `2L-n` steps, where `L` is length of list, space complexity is `O(1)`. So it the end it is exactly the same as staightforward two passes solution. So, if you meet this problem in real interview, you can just explain two pass solution, and when interviewer say can you do better: explain him that another one pass solution in fact is exaclty the same time and space.\\n\\n#### Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        P1, P2 = dummy, dummy\\n        for _ in range(n): P2 = P2.next\\n        \\n        while P2.next:\\n            P1 = P1.next\\n            P2 = P2.next\\n            \\n        P1.next = P1.next.next\\n        \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        P1, P2 = dummy, dummy\\n        for _ in range(n): P2 = P2.next\\n        \\n        while P2.next:\\n            P1 = P1.next\\n            P2 = P2.next\\n            \\n        P1.next = P1.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222616,
                "title": "java-solution-for-beginners-linkedlist-easy-to-understand",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 1;\\n        ListNode c = head;\\n        while(c.next!=null){\\n            count++;\\n            c=c.next;\\n        }\\n        \\n        if(n == count){\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ListNode ln = head;\\n        int i= 0;\\n        while(++i<count-n){\\n            ln = ln.next;  \\n        }\\n        ln.next = ln.next.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int count = 1;\\n        ListNode c = head;\\n        while(c.next!=null){\\n            count++;\\n            c=c.next;\\n        }\\n        \\n        if(n == count){\\n            head = head.next;\\n            return head;\\n        }\\n        \\n        ListNode ln = head;\\n        int i= 0;\\n        while(++i<count-n){\\n            ln = ln.next;  \\n        }\\n        ln.next = ln.next.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552644,
                "title": "faster-than-100-c-code",
                "content": "idea is to take two pointers and traverse the first pointer n nodes\\ntill the time 2nd pointer will be as it is\\nnow when you\\'ll traverse the both poniters simultaneously then definitely first pointer\\nis gonna be at the position last and 2nd pointer will be just before the node we\\'ve to delete\\n\\nhere first pointer is fast and 2nd pointer is slow; \\nhere is the code implementation os the above approach------------------------\\n```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *start=new ListNode(); \\n        start->next=head;\\n        ListNode *slow=start,*fast=start;\\n        for(int i=0;i<n;i++)\\n            fast=fast->next; //traverse n nodes\\n        \\n        while(fast->next!=nullptr){  //as i told fast will be at the last node\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        ListNode *del=slow->next; //step to finish matlab khatam krna hai node ko\\n        slow->next=slow->next->next; //next pointer of the slow will point on just after the victim node\\n        delete(del); //Khatam \\uD83D\\uDC7B\\n        return start->next;\\n    }\\n```\\n\\nmy english ;P\\n\\uD83D\\uDE42 why you guys always forget to upvote, it motivates me to post such answers.\\n<a href=\"https://cutt.ly/KalyanChannel\">You can checkout the Youtube channel \\uD83D\\uDCF1  </a>",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *start=new ListNode(); \\n        start->next=head;\\n        ListNode *slow=start,*fast=start;\\n        for(int i=0;i<n;i++)\\n            fast=fast->next; //traverse n nodes\\n        \\n        while(fast->next!=nullptr){  //as i told fast will be at the last node\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        ListNode *del=slow->next; //step to finish matlab khatam krna hai node ko\\n        slow->next=slow->next->next; //next pointer of the slow will point on just after the victim node\\n        delete(del); //Khatam \\uD83D\\uDC7B\\n        return start->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8874,
                "title": "golang-solution-3ms",
                "content": "Example Input:\\n```\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 1\\n```\\n#### First Approach \\n- The idea is to use two pointers `left` and `right`.\\n- `right` will advance `n` nodes into the list.\\n- At this point `left` will point to the head of the list. (Figure 2)\\n- Then, we walk `left` and `right` in tandem, until `right` reaches the end of the list.\\n- At this point `left` will point to the *Nth node from the end*, which we want to remove.  (Figure 3)\\n```\\nleft                       right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 2\\n```\\n```\\n                  left                    right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 3\\n```\\nThis will work. However, we have to maintain a previous pointer to `left`, in order to delete `left`. We also need to take care of the corner case where, the node to be deleted is the `head` of our list. i.e when `n` = 5 in our example.\\n\\nWe'll instead follow a cleaner approach which is discussed next.\\n#### Second Approach\\n- We employ a node called the `preHeader` node, whose `Next` pointer points to the head of our list.\\n- Then we point our `left` pointer to the `preHeader` to start off with. (Figure 4)\\n- The advantage of this approach is that, when our `right` pointer gets to the end of our list, `left` will be pointing to the node just before the *Nth node from the end*, which makes deleting that node very straight forward.  (Figure 5/6)\\n- Another advantage is that, we do not need to code anything special for handling the corner case where `n` = 5 in our example. \\n```\\nleft                                 right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 4\\n```\\n```\\n                   left                             right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 5\\n```\\n```\\n                   left                    right\\n| ph | -> | 1 | -> | 2 | -> | 4 | -> | 5 |   *\\n\\nFig 6\\n```\\n\\n```c\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    if head == nil || n <= 0 {return head}\\n    preHeader := &ListNode{Next: head}\\n    left, right := preHeader, head\\n\\n    for i := 0; right != nil && i < n; i++ {\\n        right = right.Next\\n    }\\n    for right != nil {\\n        left, right = left.Next, right.Next\\n    }\\n    left.Next = left.Next.Next\\n    return preHeader.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 1\\n```\n```\\nleft                       right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 2\\n```\n```\\n                  left                    right\\n| 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 3\\n```\n```\\nleft                                 right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |\\n\\nFig 4\\n```\n```\\n                   left                             right\\n| ph | -> | 1 | -> | 2 | -> | 3 | -> | 4 | -> | 5 |   *\\n\\nFig 5\\n```\n```\\n                   left                    right\\n| ph | -> | 1 | -> | 2 | -> | 4 | -> | 5 |   *\\n\\nFig 6\\n```\n```c\\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\\n    if head == nil || n <= 0 {return head}\\n    preHeader := &ListNode{Next: head}\\n    left, right := preHeader, head\\n\\n    for i := 0; right != nil && i < n; i++ {\\n        right = right.Next\\n    }\\n    for right != nil {\\n        left, right = left.Next, right.Next\\n    }\\n    left.Next = left.Next.Next\\n    return preHeader.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9028,
                "title": "my-java-solution",
                "content": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode voidHead = new ListNode(-1);\\n        voidHead.next = head;\\n        ListNode p1 = voidHead;\\n        ListNode p2 = voidHead;\\n        while (p1.next!=null){\\n            p1=p1.next;\\n            if (n--<=0)p2=p2.next;\\n        }\\n        if (p2.next!=null) p2.next=p2.next.next;\\n        return voidHead.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode voidHead = new ListNode(-1);\\n        voidHead.next = head;\\n        ListNode p1 = voidHead;\\n        ListNode p2 = voidHead;\\n        while (p1.next!=null){\\n            p1=p1.next;\\n            if (n--<=0)p2=p2.next;\\n        }\\n        if (p2.next!=null) p2.next=p2.next.next;\\n        return voidHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1668618,
                "title": "python-one-pass-o-n-faster-than-93-19",
                "content": "```class Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        \\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        \\n        while fast is not None and fast.next is not None:\\n            slow = slow.next\\n            fast = fast.next\\n\\n        if fast is not None:\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        \\n        return head",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```class Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow, fast = head, head\\n        \\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        \\n        while fast is not None and fast.next is not None:\\n            slow = slow.next\\n            fast = fast.next\\n\\n        if fast is not None:\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 723171,
                "title": "2-pointer-with-original-submission-and-thought-process-faster-than-98",
                "content": "So this is the original code in my submission. I\\'d apparently visited this a few months back and made a hash of it, but after revisiting having learnt some base techniques it\\'s much easier.\\n\\n**(1)** \\nOk obviously need to delete a node. So best know how to do that. Already in my mind i\\'m seeing:\\n\\n``` \\nconst deleteNextNode = (node) => node.next = node.next.next\\n```\\n\\nWhich means if we want to delete a node, we need to get the node before it.\\n\\n**(2)**\\nThen the other bit, which actually comes before in the description, is to get the `Nth` node from the end. In our case, as we want to get the `Nth` node from the end of the linked list to delete it, we actually want to get the `Nth+1` node **from the end**. Seems like a slow/fast 2 pointer solution.\\n\\nTo do this, i\\'m seeing the beginning of the answer to the entire question:\\n\\n```\\nvar removeNthFromEnd = function(head, n) {\\n\\n    if(!head) return head\\n\\n    let [slow, fast] = [head, head]\\n\\t\\n    // move fast ahead by n\\n\\t// have to be careful about --n or n-- here. \\n\\t// As we want the node before the one we are deleting,\\n\\t// we want fast to be ahead by an additional node\\n\\t// if the question was just to return slow, i\\'d probably use --n instead\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n\\t// we want to stop when fast.next is null\\n\\t// we move both along the linked list \\n\\t// keeping the same distance between them\\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n\\t...\\n}\\n```\\n\\nOne final issue came up when submitting. What happens when `n` is equal to the length of the linked list. We\\'ll we run into problems. Easiest solution I could think of is to create a dummy node that is before the linked list. That allows us to remove the head node if the Nth node from the end is the head node.\\n\\n**Final submission:**\\n```\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    if(!head) return head\\n    let begin = { val: -1, next: head }\\n       \\n    let [slow, fast] = [begin, begin]\\n    // move fast ahead by n\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n    \\n    // remove slow.next\\n    removeNextNode(slow)\\n    \\n    return begin.next\\n};\\n\\nconst removeNextNode = (node) => { \\n    node.next = node.next.next\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "``` \\nconst deleteNextNode = (node) => node.next = node.next.next\\n```\n```\\nvar removeNthFromEnd = function(head, n) {\\n\\n    if(!head) return head\\n\\n    let [slow, fast] = [head, head]\\n\\t\\n    // move fast ahead by n\\n\\t// have to be careful about --n or n-- here. \\n\\t// As we want the node before the one we are deleting,\\n\\t// we want fast to be ahead by an additional node\\n\\t// if the question was just to return slow, i\\'d probably use --n instead\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n\\t// we want to stop when fast.next is null\\n\\t// we move both along the linked list \\n\\t// keeping the same distance between them\\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n\\t...\\n}\\n```\n```\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    if(!head) return head\\n    let begin = { val: -1, next: head }\\n       \\n    let [slow, fast] = [begin, begin]\\n    // move fast ahead by n\\n    while(n--){\\n        fast = fast.next\\n    }\\n    \\n    while(fast.next){\\n        [slow, fast] = [slow.next, fast.next]\\n    }\\n    \\n    // remove slow.next\\n    removeNextNode(slow)\\n    \\n    return begin.next\\n};\\n\\nconst removeNextNode = (node) => { \\n    node.next = node.next.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 337245,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int size=0;\\n        ListNode* ans=head;\\n        ListNode* check=head;\\n        while(head){\\n            size++;\\n            head=head->next;\\n        }\\n        if(size==1) return NULL;\\n        if(size <= n){\\n            return ans->next;\\n        }\\n        for(int i=1;i<size-n;i++){\\n            check=check->next;\\n        }\\n        check->next=check->next->next;\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int size=0;\\n        ListNode* ans=head;\\n        ListNode* check=head;\\n        while(head){\\n            size++;\\n            head=head->next;\\n        }\\n        if(size==1) return NULL;\\n        if(size <= n){\\n            return ans->next;\\n        }\\n        for(int i=1;i<size-n;i++){\\n            check=check->next;\\n        }\\n        check->next=check->next->next;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632933,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\nLL = **1 -> 2 -> 3 -> 4-> 5 -> null** & n=2\\n\\n1. Initially slow = head, fast = head\\n2. Fast is initialised **\\'n+1\\' positions ahead**.\\n3. Thus, **slow = 1 and fast = 4** (n+1 positions ahead i.e. 2+1 = 3 positions ahead). \\n4. While fast!=NULL, increment **both slow and fast by one**.\\n5. Therefore, slow = 2, fast = 5\\n6. Now, slow = 3, fast = NULL, hence exit form while loop\\n7. Now update **slow->next = slow->next->next.**\\n\\n**TC** = O(N), **SC** = O(1)\\n\\n\\t  ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(head==NULL) return head;\\n        \\n        ListNode *s=head, *f=head;          //2 pointers, slow=head\\n        \\n        for(int i=1;i<=n+1;i++){            //fast is initialised \\'n+1\\' positions ahead\\n            if(f==NULL) return head->next;  \\n            f=f->next;\\n        }\\n        \\n        while(f!=NULL){                     //when fast is NULL, exit\\n            s=s->next;\\n            f=f->next;\\n        }\\n        \\n        s->next=s->next->next;              //update connection\\n        return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\nLL = **1 -> 2 -> 3 -> 4-> 5 -> null** & n=2\\n\\n1. Initially slow = head, fast = head\\n2. Fast is initialised **\\'n+1\\' positions ahead**.\\n3. Thus, **slow = 1 and fast = 4** (n+1 positions ahead i.e. 2+1 = 3 positions ahead). \\n4. While fast!=NULL, increment **both slow and fast by one**.\\n5. Therefore, slow = 2, fast = 5\\n6. Now, slow = 3, fast = NULL, hence exit form while loop\\n7. Now update **slow->next = slow->next->next.**\\n\\n**TC** = O(N), **SC** = O(1)\\n\\n\\t  ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(head==NULL) return head;\\n        \\n        ListNode *s=head, *f=head;          //2 pointers, slow=head\\n        \\n        for(int i=1;i<=n+1;i++){            //fast is initialised \\'n+1\\' positions ahead\\n            if(f==NULL) return head->next;  \\n            f=f->next;\\n        }\\n        \\n        while(f!=NULL){                     //when fast is NULL, exit\\n            s=s->next;\\n            f=f->next;\\n        }\\n        \\n        s->next=s->next->next;              //update connection\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2428116,
                "title": "one-pass-simple-c-solution-w-comments-and-explanation",
                "content": "Here\\'s a one-pass solution with the following algorithm:\\n1. Create a dummy node and let the 2 pointers, `fast` and `slow` point to that node. Dummy nodes make things easier, especially when we delete the **first node/head**.\\n2. Position `fast` so that the gap between them is `n`\\n3. To position `slow` just **behind/before the node-to-delete**, move both pointers until `fast.next` is `null` \\n4. After the pointers are positioned where they should, delete the node by pointing `slow.next` to `slow.next.next`\\n5. Return the head via `dummy.next`\\n\\n**Implementation**\\n\\n```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n\\tListNode dummy = new(0, head); // Create a dummy node\\n\\tListNode slow = dummy, fast = dummy;\\n\\n\\t// Gap of fast and slow is n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t// Move slow to the node behind the node to delete\\n\\twhile (fast?.next != null) {\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t\\t\\t// Delete the node\\n\\tslow.next = slow.next.next;\\n\\n\\treturn dummy.next;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n\\tListNode dummy = new(0, head); // Create a dummy node\\n\\tListNode slow = dummy, fast = dummy;\\n\\n\\t// Gap of fast and slow is n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t// Move slow to the node behind the node to delete\\n\\twhile (fast?.next != null) {\\n\\t\\tslow = slow.next;\\n\\t\\tfast = fast.next;\\n\\t}\\n\\n\\t\\t\\t// Delete the node\\n\\tslow.next = slow.next.next;\\n\\n\\treturn dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658772,
                "title": "rust-0ms-faster-than-100-recursive-solution-with-backtracking-no-cloning",
                "content": "I want to make a shout out to the online booklet [Learn Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) -- it\\'s a good way to learn how to use Rust\\'s built-in tools to massage code to satisfy the borrow chcker. It provides a nice exlaination for using `mem::replace`, when to use it, and `Option\\'s` helpful `take()` function.\\n\\n\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove_nth_from_end_recr(head, n).0\\n    }\\n}\\n    \\nfn remove_nth_from_end_recr(head: Option<Box<ListNode>>, n: i32) -> (Option<Box<ListNode>>, usize) {\\n    match head {\\n        None => (None, 1),\\n        Some(mut node) => {\\n            let (prev, num) = remove_nth_from_end_recr(node.next.take(), n);\\n            if n == num as i32 {\\n                (prev, num+1)\\n            } else {\\n                node.next = prev;\\n                (Some(node), num+1)\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Remove Nth Node From End of List.\\nMemory Usage: 2.1 MB, less than 37.35% of Rust online submissions for Remove Nth Node From End of List.\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove_nth_from_end_recr(head, n).0\\n    }\\n}\\n    \\nfn remove_nth_from_end_recr(head: Option<Box<ListNode>>, n: i32) -> (Option<Box<ListNode>>, usize) {\\n    match head {\\n        None => (None, 1),\\n        Some(mut node) => {\\n            let (prev, num) = remove_nth_from_end_recr(node.next.take(), n);\\n            if n == num as i32 {\\n                (prev, num+1)\\n            } else {\\n                node.next = prev;\\n                (Some(node), num+1)\\n            }\\n        }\\n    }\\n}\\n```\n```\\nRuntime: 0 ms, faster than 100.00% of Rust online submissions for Remove Nth Node From End of List.\\nMemory Usage: 2.1 MB, less than 37.35% of Rust online submissions for Remove Nth Node From End of List.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472058,
                "title": "javascript-99-single-loop-clean-code",
                "content": "1. dummy head to keep the \\'prev\\' for the real head.\\n2. counting in the single loop to avoid the second loop many other solutions used.\\n\\n```\\nvar removeNthFromEnd = function(head, n) { \\n    let dummy = new ListNode(0, head);\\n    let prev = dummy;\\n    let node = head;\\n    let count = 1;\\n    while (node.next) {\\n        if (count === n) {\\n            prev = prev.next;\\n        } else {\\n            count++;\\n        }\\n        node = node.next;\\n    }\\n    prev.next = prev.next.next;\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeNthFromEnd = function(head, n) { \\n    let dummy = new ListNode(0, head);\\n    let prev = dummy;\\n    let node = head;\\n    let count = 1;\\n    while (node.next) {\\n        if (count === n) {\\n            prev = prev.next;\\n        } else {\\n            count++;\\n        }\\n        node = node.next;\\n    }\\n    prev.next = prev.next.next;\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168502,
                "title": "simple-javascript-99-solution-with-comments",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let nodeToReturn = head;\\n    \\n    //Have two pointers, one that is n ahead of the other\\n    let pointer1 = head;\\n    let pointer2 = head;\\n    \\n    //Move pointer2 to be n ahead\\n    for(let i = 0; i<n;i++){\\n        pointer2 = pointer2.next;\\n    }\\n    \\n    //If pointer2 doesn\\'t exist, that means we must remove the head of the list\\n    if(!pointer2){\\n        return nodeToReturn.next;\\n    }\\n    \\n    //Move both pointers until pointer2 reaches the end\\n    while(pointer2.next){\\n        pointer1 = pointer1.next;\\n        pointer2 = pointer2.next;\\n    }\\n\\n    //Save the node two places ahead of pointer1;    \\n    pointer1.next = pointer1.next.next;\\n    \\n    return nodeToReturn;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let nodeToReturn = head;\\n    \\n    //Have two pointers, one that is n ahead of the other\\n    let pointer1 = head;\\n    let pointer2 = head;\\n    \\n    //Move pointer2 to be n ahead\\n    for(let i = 0; i<n;i++){\\n        pointer2 = pointer2.next;\\n    }\\n    \\n    //If pointer2 doesn\\'t exist, that means we must remove the head of the list\\n    if(!pointer2){\\n        return nodeToReturn.next;\\n    }\\n    \\n    //Move both pointers until pointer2 reaches the end\\n    while(pointer2.next){\\n        pointer1 = pointer1.next;\\n        pointer2 = pointer2.next;\\n    }\\n\\n    //Save the node two places ahead of pointer1;    \\n    pointer1.next = pointer1.next.next;\\n    \\n    return nodeToReturn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8971,
                "title": "simple-6-line-java-one-pass-solution",
                "content": "public class Solution {\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode start=new ListNode(0),slow=start,fast=start;\\n        start.next=head;\\n        for(int i=0;i<n;i++) fast=fast.next;\\n        while(fast.next!=null) {fast=fast.next;slow=slow.next;}\\n        slow.next=slow.next.next;\\n        return start.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode start=new ListNode(0),slow=start,fast=start;\\n        start.next=head;\\n        for(int i=0;i<n;i++) fast=fast.next;\\n        while(fast.next!=null) {fast=fast.next;slow=slow.next;}",
                "codeTag": "Java"
            },
            {
                "id": 9007,
                "title": "python-solution-one-pass",
                "content": "nearly one pass, O(1) space. 44 ms\\n\\n    def removeNthFromEnd(self, head, n):\\n        slow = fast = self\\n        self.next = head\\n        while fast.next:\\n            if n:\\n                n -= 1\\n            else:\\n                slow = slow.next\\n            fast = fast.next\\n        slow.next = slow.next.next\\n        return self.next   \\n\\nreal one pass, but O(n) space,  44 ms  \\n\\n    def removeNthFromEnd(self, head, n):\\n        self.next, nodelist  = head, [self]\\n        while head.next:\\n            if len(nodelist) == n:\\n                nodelist.pop(0)\\n            nodelist += head,\\n            head = head.next\\n        nodelist[0].next = nodelist[0].next.next \\n        return self.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "nearly one pass, O(1) space. 44 ms\\n\\n    def removeNthFromEnd(self, head, n):\\n        slow = fast = self\\n        self.next = head\\n        while fast.next:\\n            if n:\\n                n -= 1\\n            else:\\n                slow = slow.next\\n            fast = fast.next\\n        slow.next = slow.next.next\\n        return self.next   \\n\\nreal one pass, but O(n) space,  44 ms  \\n\\n    def removeNthFromEnd(self, head, n):\\n        self.next, nodelist  = head, [self]\\n        while head.next:\\n            if len(nodelist) == n:\\n                nodelist.pop(0)\\n            nodelist += head,\\n            head = head.next\\n        nodelist[0].next = nodelist[0].next.next \\n        return self.next",
                "codeTag": "Python3"
            },
            {
                "id": 3469283,
                "title": "c-easy-explanation-simple",
                "content": "/* question me dia apko ek linked list di h or bola h Nth node from the end delete krdo  mtlb agar linked list h \\nL1 = [1,2,3,4,5] or N=2 to last 2nd node delete krdo to vo konsi hogi vo hogi vo node jiska data h 4 to hme 4 ko delete krna h iske lia hmne kya kia hmne ek fast pointer lia jo head pe khada h ek slow ha vo bhi head pe h to phle fast ko jb tk chala lo jb tk fast \\'n\\' nhi ho jata fir hmne kya kia ek slow pointer lia usko chlao fast ke sath jb tk fast null nhi ho jata (slow bhi ek step , fast bhi ek step) jse hi fast null ho jae to appka slow us position pe ho jisko delete krna h to abb kya kro slow ke next ko krdo slow ke next ka next */\\n\\n\\n\\n\\nclass Solution {\\n\\npublic:\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\t\\n        ListNode* fast = head;\\n\\t\\t\\n        if(head == NULL)\\n\\t\\t\\n            return NULL;\\n\\t\\t\\t\\n        ListNode* slow = head;\\n        \\n        int count = 1;\\n        while(n--){\\n            cout<<fast->val<<\" \";\\n           fast = fast->next;\\n        }\\n        if(fast== NULL)\\n            return slow->next;\\n            \\n        while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n          slow->next = slow->next->next;\\n          return head;\\n       }\\n  \\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\t\\n        ListNode* fast = head;\\n\\t\\t\\n        if(head == NULL)\\n\\t\\t\\n            return NULL;\\n\\t\\t\\t\\n        ListNode* slow = head;\\n        \\n        int count = 1;\\n        while(n--){\\n            cout<<fast->val<<\" \";\\n           fast = fast->next;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2632802,
                "title": "java-2-solutions-explained",
                "content": "```\\n// 1. In one traversal : using slow and fast pointer\\n/*\\ntake two pointer slow and fast\\n- fast will move n position forwards\\n- now move forwards slow and fast both, till fast not reach to end of LL\\n- after performing upper operations, slow will reach to the previous node to the node which we want to delete\\n*/\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode slow = head, fast = head;\\n        \\n        // move fast n position forwards\\n        while(n != 0){\\n            fast = fast.next;\\n            n--;\\n        }\\n        \\n        // now move slow and fast both till fast not reach to end of LL\\n        while(fast != null && fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        // if fast is null, its mean we want to delete head node\\n        if(fast == null) return head.next;\\n        \\n        // remove node\\n        slow.next = slow.next.next;\\n        \\n        return head;\\n    }\\n}\\n\\n\\n// 2. In two traversal\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        // find length\\n        int len = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            temp = temp.next;\\n            len++;\\n        }\\n        \\n        if(len == n) return head.next;\\n        \\n        // Reach to the previous node of the last node\\n        temp = head;\\n        n = len-n-1;\\n        while(temp.next != null && n != 0){\\n            temp = temp.next;\\n            n--;\\n        }\\n        \\n        // remove \\n        if(temp.next != null)\\n            temp.next = temp.next.next;\\n        \\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n        ListNode slow = head, fast = head;\\n        \\n        // move fast n position forwards\\n        while(n != 0){\\n            fast = fast.next;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2599256,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        if head.next is None:\\n            return None\\n        \\n        size=0\\n        curr= head\\n        while curr!= None:\\n            curr= curr.next\\n            size+=1\\n        if n== size:\\n            return head.next\\n        \\n        indexToSearch= size-n\\n        prev= head\\n        i=1\\n        while i< indexToSearch:\\n            prev= prev.next\\n            i+=1\\n        prev.next= prev.next.next\\n        return head\\n```\\n\\n**UPVOTE** *is the best encouragement for me... Thank you*\\uD83D\\uDE01",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        if head.next is None:\\n            return None\\n        \\n        size=0\\n        curr= head\\n        while curr!= None:\\n            curr= curr.next\\n            size+=1\\n        if n== size:\\n            return head.next\\n        \\n        indexToSearch= size-n\\n        prev= head\\n        i=1\\n        while i< indexToSearch:\\n            prev= prev.next\\n            i+=1\\n        prev.next= prev.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768626,
                "title": "c-efficient-two-pointers-with-comments-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(n--) fast = fast -> next;//iterate first n nodes using fast\\n\\t    if(!fast) return head -> next; //if fast is already null, it means we have to delete head itself. So, just return next of head\\n        while(fast->next){//iterate till fast reaches the last node of list\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next=slow->next->next;// remove the nth node from last\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(n--) fast = fast -> next;//iterate first n nodes using fast\\n\\t    if(!fast) return head -> next; //if fast is already null, it means we have to delete head itself. So, just return next of head\\n        while(fast->next){//iterate till fast reaches the last node of list\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next=slow->next->next;// remove the nth node from last\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563061,
                "title": "python-2-simple-solutions",
                "content": "**Python :**\\n\\n**1 :**\\n\\n```\\nclass Solution:\\n    def getLengthOfLL(self, head: Optional[ListNode]) -> int:\\n        length = 0\\n        \\n        while head:\\n            length += 1\\n            head = head.next\\n            \\n        return length\\n            \\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        temp = head\\n        length = self.getLengthOfLL(temp)\\n        if n == length:\\n            return head.next\\n        \\n        if length == 1:\\n            return None\\n        \\n        i = 1\\n        \\n        while temp and i < (length - n):\\n            temp = temp.next\\n            i += 1\\n        \\n        temp.next = temp.next.next        \\n        return head\\n```\\n\\n**2 :**\\n```\\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\tfast = head\\n\\tslow = head\\n\\n\\twhile n:\\n\\t\\tfast = fast.next\\n\\t\\tn -= 1\\n\\n\\tif not fast:\\n\\t\\treturn head.next\\n\\n\\twhile fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n**Like it ? please upvote !**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getLengthOfLL(self, head: Optional[ListNode]) -> int:\\n        length = 0\\n        \\n        while head:\\n            length += 1\\n            head = head.next\\n            \\n        return length\\n            \\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        temp = head\\n        length = self.getLengthOfLL(temp)\\n        if n == length:\\n            return head.next\\n        \\n        if length == 1:\\n            return None\\n        \\n        i = 1\\n        \\n        while temp and i < (length - n):\\n            temp = temp.next\\n            i += 1\\n        \\n        temp.next = temp.next.next        \\n        return head\\n```\n```\\ndef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\tfast = head\\n\\tslow = head\\n\\n\\twhile n:\\n\\t\\tfast = fast.next\\n\\t\\tn -= 1\\n\\n\\tif not fast:\\n\\t\\treturn head.next\\n\\n\\twhile fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726055,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n         let mut dummy = Box::new(ListNode {\\n            val: -1,\\n            next: head,\\n        });\\n\\n        let mut right = dummy.clone();\\n        let mut left = dummy.as_mut();\\n\\n        for _ in 0..n {\\n            right = right.next.unwrap();\\n        }\\n\\n        while let Some(node) = right.next {\\n            right = node;\\n            left = left.next.as_mut().unwrap();\\n        }\\n\\n        left.next = left.next.as_mut().unwrap().next.clone();\\n\\n        dummy.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n         let mut dummy = Box::new(ListNode {\\n            val: -1,\\n            next: head,\\n        });\\n\\n        let mut right = dummy.clone();\\n        let mut left = dummy.as_mut();\\n\\n        for _ in 0..n {\\n            right = right.next.unwrap();\\n        }\\n\\n        while let Some(node) = right.next {\\n            right = node;\\n            left = left.next.as_mut().unwrap();\\n        }\\n\\n        left.next = left.next.as_mut().unwrap().next.clone();\\n\\n        dummy.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414563,
                "title": "rust-safe-code-one-pass-has-to-use-clone-to-bypass-borrow-checker",
                "content": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = ListNode::new(0);\\n        dummy.next = head;\\n        let mut dummy = Box::new(dummy);\\n        let mut fast = dummy.clone();\\n        let mut slow =  dummy.as_mut();\\n        // move fast n forward\\n        for _ in 0..n {\\n            fast = fast.next.unwrap();\\n        }\\n\\n        while fast.next.is_some() {\\n            fast = fast.next.unwrap();\\n            slow = slow.next.as_mut().unwrap();\\n        }\\n        let next = slow.next.as_mut().unwrap();\\n        slow.next = next.next.clone();\\n        dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = ListNode::new(0);\\n        dummy.next = head;\\n        let mut dummy = Box::new(dummy);\\n        let mut fast = dummy.clone();\\n        let mut slow =  dummy.as_mut();\\n        // move fast n forward\\n        for _ in 0..n {\\n            fast = fast.next.unwrap();\\n        }\\n\\n        while fast.next.is_some() {\\n            fast = fast.next.unwrap();\\n            slow = slow.next.as_mut().unwrap();\\n        }\\n        let next = slow.next.as_mut().unwrap();\\n        slow.next = next.next.clone();\\n        dummy.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8996,
                "title": "easy-java-o-1-space-complexity-solution",
                "content": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        ListNode start = new ListNode(0);\\n        ListNode n1 = start, n2 = start;\\n        n2.next = head;\\n        \\n        for(int i =0;i<n+1;i++){\\n            n2 = n2.next; // trying o create gab n between two pointers\\n        }\\n        \\n        while(n2 != null){\\n            n1 = n1.next;\\n            n2 = n2.next;\\n        }\\n        \\n        //time to change\\n        n1.next = n1.next.next;\\n        return start.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        ListNode start = new ListNode(0);\\n        ListNode n1 = start, n2 = start;\\n        n2.next = head;\\n        \\n        for(int i =0;i<n+1;i++){\\n            n2 = n2.next; // trying o create gab n between two pointers\\n        }\\n        \\n        while(n2 != null){\\n            n1 = n1.next;\\n            n2 = n2.next;\\n        }\\n        \\n        //time to change\\n        n1.next = n1.next.next;\\n        return start.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9040,
                "title": "simple-one-pass-4ms-c-implementation",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {\\n            ListNode realHead(0);\\n            realHead.next = head;\\n            head = &realHead;\\n            ListNode *curr = &realHead;\\n            while (n-- > 0)\\n                curr = curr->next;\\n            while (curr->next != nullptr) {\\n                curr = curr->next;\\n                head = head->next;\\n            }\\n    \\n            head->next = head->next->next;\\n            return realHead.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {\\n            ListNode realHead(0);\\n            realHead.next = head;\\n            head = &realHead;\\n            ListNode *curr = &realHead;\\n            while (n-- > 0)\\n                curr = curr->next;\\n            while (curr->next != nullptr) {\\n                curr = curr->next;\\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3916930,
                "title": "python3-beats-95-efficient-removal-of-nth-node-from-the-end-of-a-linked-list",
                "content": "# Solution no. 01\\nThe first solution helps you understand the basics with simple steps. \\n\\n# Intuition\\n\\nTo determine the node to remove, which is n positions from the end, we need to figure out how many positions we should move from the front to reach the desired node. By counting the total number of nodes in the linked list, we gain this insight and can then adjust the connections accordingly to remove the targeted node from the end.\\n\\n# Approach\\n1. Count the total number of nodes in the linked list by traversing it with a curr pointer.\\n1. Calculate the position to move from the front to reach the node n positions from the end.\\n1. Reset the count and curr to traverse the list again.\\n1. If the node to be removed is the first node, return head.next.\\n1. Traverse the list while keeping track of the count.\\n1. When the count matches the calculated position before the node to be removed, update the connection to skip the node.\\n1. Exit the loop after performing the removal.\\n1. Return the updated head.\\n\\n# Complexity\\n- Time complexity:\\nWe traverse the linked list twice, so the time complexity is O(n), where n is the number of nodes in the list.\\n\\n- Space complexity:\\nWe only use a few variables, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        count = 0\\n        curr = head\\n        while curr:\\n            count += 1\\n            curr = curr.next\\n\\n        check = count - n - 1\\n        count = 0\\n        curr = head\\n\\n        # Removing the first node\\n        if check == -1:  \\n            return head.next\\n\\n        while curr:\\n            if count == check:\\n                curr.next = curr.next.next\\n                # As the removal is done, Exit the loop\\n                break  \\n            curr = curr.next\\n            count += 1\\n\\n        return head\\n\\n```\\n\\n\\n---\\n\\n# Solution no. 02\\n\\n# Intuition\\nIn our first approach we counted the total number of nodes in the linked list and then identify the n-th node from the end by its position from the beginning. While this counting approach could work, it involves traversing the list twice: once to count the nodes and once to find the node to remove. This double traversal can be inefficient, especially for large lists.\\n\\nA more efficient approach comes from recognizing that we don\\'t really need to know the total number of nodes in the list to solve this problem. Instead, we can utilize two pointers to maintain a specific gap between them as they traverse the list. This gap will be the key to identifying the n-th node from the end.\\n\\n# Approach\\n1. We\\'ll use two pointers, first and second, initialized to a dummy node at the beginning of the linked list. The goal is to maintain a gap of n+1 nodes between the two pointers as we traverse the list.\\n\\n1. Move the first pointer n+1 steps ahead, creating a gap of n nodes between first and second.\\n\\n1. Now, move both first and second pointers one step at a time until the first pointer reaches the end of the list. This ensures that the gap between the two pointers remains constant at n nodes.\\n\\n1. When first reaches the end, the second pointer will be pointing to the node right before the node we want to remove (n-th node from the end).\\n\\n1. Update the second.next pointer to skip the n-th node, effectively removing it from the list.\\n\\n# Complexity\\n- Time complexity:\\n The solution involves a single pass through the linked list, so the time complexity is **O(N)**, where N is the number of nodes in the linked list.\\n\\n- Space complexity:\\nWe are using a constant amount of extra space to store the dummy, first, and second pointers, so the space complexity is **O(1)**.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        first = dummy\\n        second = dummy\\n        \\n        # Advance first pointer so that the gap between first and second is n+1 nodes apart\\n        for i in range(n+1):\\n            first = first.next\\n        \\n        # Move first to the end, maintaining the gap\\n        while first:\\n            first = first.next\\n            second = second.next\\n        \\n        # Remove the nth node from the end\\n        second.next = second.next.next\\n        \\n        return dummy.next \\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        count = 0\\n        curr = head\\n        while curr:\\n            count += 1\\n            curr = curr.next\\n\\n        check = count - n - 1\\n        count = 0\\n        curr = head\\n\\n        # Removing the first node\\n        if check == -1:  \\n            return head.next\\n\\n        while curr:\\n            if count == check:\\n                curr.next = curr.next.next\\n                # As the removal is done, Exit the loop\\n                break  \\n            curr = curr.next\\n            count += 1\\n\\n        return head\\n\\n```\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        first = dummy\\n        second = dummy\\n        \\n        # Advance first pointer so that the gap between first and second is n+1 nodes apart\\n        for i in range(n+1):\\n            first = first.next\\n        \\n        # Move first to the end, maintaining the gap\\n        while first:\\n            first = first.next\\n            second = second.next\\n        \\n        # Remove the nth node from the end\\n        second.next = second.next.next\\n        \\n        return dummy.next \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558592,
                "title": "2-different-python-solutions-with-explanation",
                "content": "# Solution 1: Two Passes\\nThe reason why this problem is a medium and not an easy one is because we need to remove the nth node **from the end**. To do this, we need to find the length of the linked list. That is why we need 2 passes: one to find the length of the linked list and another to actually remove the node.\\n\\nWe first set `i` as the head and iterate the entire list, with each iteration adding 1 to the length. That is really basic.\\n\\nNow that we have our length, we can remove the node. To remove a node, you set the previous node\\'s link to the node after the one we remove. \\n\\nSay we want to remove node 2: we set 1\\'s next link to 3 instead of 2. Therefore the linked list becomes 0, 1, 3.\\n```txt\\n 0------->1------->2------->3\\n 0        1        2        3\\n|_|----->|_|-------------->|_|\\n```\\n\\nAlso, the corner case is that `n` is the length, in which we don\\'t do anything but return the node after `head`.\\n\\nNow onto removing the node:\\nWe move our `j` pointer to the node **before** the node we want to remove. To do that, we need to mvoe it `length-n-1` times. \\n\\nOnce we are at that desired node, we just set `j`\\'s next pointer to the node after the node we want to remove. \\n\\nFor those of you who are worried about memory leaks: python has a garbage collection system that\\'s automated, so you don\\'t have to take care of that.\\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        i = head\\n        length = 0\\n        while i:\\n            i = i.next\\n            length += 1\\n            \\n        if length == n:\\n            return head.next\\n        j = head\\n        for x in range(length-n-1):\\n            j = j.next\\n        j.next = j.next.next\\n        return head\\n```\\n\\n# Solution 2: One Pass\\nThis is the optimal solution: we maintain two pointers and are able to do the entire thing (find length and remove node) in **one pass**.\\n\\nThe trick is that the distance between the 2 pointers is `n`, so when we have the right pointer at the end, the left pointer will be exactly at the node before the node we want to remove. \\n\\nNote: to prevent the right node from becoming None (go after the last node), I use `while right.next` instead of `while right` as my loop definition\\n\\nWe first move the right pointer `n` times, so that the distance between the left and right pointers is `n`.\\n\\nNow we maintain this \"window\" and move both pointers until the right pointer is at the end of the list. Now, the left pointer is at the node before the node we want to remove, so we can just remove the node. \\n\\nIf you want to know how to remove a node, I explain it in the first solution (so scroll up). \\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left = right = head\\n        for i in range(n):\\n            right = right.next\\n            \\n        if not right:\\n            return left.next\\n        \\n        while right.next:\\n            left = left.next\\n            right = right.next\\n        left.next = left.next.next\\n        return head\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```txt\\n 0------->1------->2------->3\\n 0        1        2        3\\n|_|----->|_|-------------->|_|\\n```\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        i = head\\n        length = 0\\n        while i:\\n            i = i.next\\n            length += 1\\n            \\n        if length == n:\\n            return head.next\\n        j = head\\n        for x in range(length-n-1):\\n            j = j.next\\n        j.next = j.next.next\\n        return head\\n```\n```py\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        left = right = head\\n        for i in range(n):\\n            right = right.next\\n            \\n        if not right:\\n            return left.next\\n        \\n        while right.next:\\n            left = left.next\\n            right = right.next\\n        left.next = left.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109517,
                "title": "python3-beats-99-97-remove-nth-node-from-list-s-end",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        first = second = head\\n        for _ in range(n):\\n            first = first.next\\n            \\n        if not first:\\n            return head.next\\n        while first.next:\\n            first = first.next\\n            second = second.next\\n        \\n        second.next = second.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        first = second = head\\n        for _ in range(n):\\n            first = first.next\\n            \\n        if not first:\\n            return head.next\\n        while first.next:\\n            first = first.next\\n            second = second.next\\n        \\n        second.next = second.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504455,
                "title": "my-c-solution-one-pass",
                "content": "Runtime: 92 ms, faster than 75.77% of C# online submissions for Remove Nth Node From End of List.\\nMemory Usage: 24.8 MB, less than 10.00% of C# online submissions for Remove Nth Node From End of List.\\n\\n```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n    var left = head;\\n    var right = head;\\n\\n    while(right != null) {\\n        right = right.next;\\n        if (n-- < 0) left = left.next; \\n    } \\n\\n    if (n == 0) head = head.next;\\n    else left.next = left.next.next;\\n\\n    return head;        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode RemoveNthFromEnd(ListNode head, int n) {\\n    var left = head;\\n    var right = head;\\n\\n    while(right != null) {\\n        right = right.next;\\n        if (n-- < 0) left = left.next; \\n    } \\n\\n    if (n == 0) head = head.next;\\n    else left.next = left.next.next;\\n\\n    return head;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9025,
                "title": "simple-python-solution-one-pass",
                "content": "    # Definition for singly-linked list.\\n    # class ListNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution(object):\\n        def removeNthFromEnd(self, head, n):\\n            \"\"\"\\n            :type head: ListNode\\n            :type n: int\\n            :rtype: ListNode\\n            \"\"\"\\n            runner = head\\n            slow = head\\n            for i in xrange(n):\\n                runner = runner.next\\n            if runner is None:       # case where n is the length of the list -- remove first node\\n                head = head.next\\n                return head\\n            while runner.next != None:\\n                runner = runner.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for singly-linked list.\\n    # class ListNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.next = None\\n    \\n    class Solution(object):\\n        def removeNthFromEnd(self, head, n):\\n            \"\"\"\\n            :type head: ListNode\\n            :type n: int\\n            :rtype: ListNode\\n            \"\"\"\\n            runner = head\\n            slow = head\\n            for i in xrange(n):\\n                runner = runner.next\\n            if runner is None:       # case where n is the length of the list -- remove first node\\n                head = head.next\\n                return head\\n            while runner.next != None:\\n                runner = runner.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 9095,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\t\\twhile(fast != null) {\\n\\t\\t\\tfast = fast.next;\\n        \\tif(n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}\\n        }\\n\\t\\t\\n\\t\\tif(n == 0) {\\n\\t\\t\\thead = head.next;\\n\\t\\t} else if(n < 0) {\\n\\t\\t\\tslow.next = slow.next.next;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        ListNode slow = head;\\n\\t\\twhile(fast != null) {\\n\\t\\t\\tfast = fast.next;\\n        \\tif(n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3748032,
                "title": "c-2-pointers",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\\n        ListNode *pre_slow, *slow, *fast;\\n        pre_slow=NULL;\\n        slow=fast=head;\\n        \\n        for(int i=0;i<k;i++) fast=fast->next;\\n        \\n        while(fast!=NULL){\\n            pre_slow=slow;\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        \\n        if(pre_slow==NULL){\\n            ListNode* new_head = head->next;\\n            delete head;\\n            return new_head;\\n        }\\n    \\n        pre_slow->next=slow->next;\\n        slow->next=NULL;\\n        delete slow;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\\n        ListNode *pre_slow, *slow, *fast;\\n        pre_slow=NULL;\\n        slow=fast=head;\\n        \\n        for(int i=0;i<k;i++) fast=fast->next;\\n        \\n        while(fast!=NULL){\\n            pre_slow=slow;\\n            slow=slow->next;\\n            fast=fast->next;\\n        }\\n        \\n        if(pre_slow==NULL){\\n            ListNode* new_head = head->next;\\n            delete head;\\n            return new_head;\\n        }\\n    \\n        pre_slow->next=slow->next;\\n        slow->next=NULL;\\n        delete slow;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257400,
                "title": "c-python-easy-one-pass-0-ms-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> nodes;\\n        ListNode* temp = head;\\n        while (temp)\\n        {\\n            nodes.push_back(temp);\\n            temp = temp->next;\\n        }\\n        if (nodes.size()==1) return NULL;\\n        if (nodes.size()-n<=0) return nodes[1];\\n        ListNode* node = nodes[nodes.size()-1-n];\\n        node->next = node->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        nodes = []\\n        temp = head\\n        while (temp):\\n            nodes.append(temp)\\n            temp = temp.next\\n        if (len(nodes)==1): return None\\n        if (len(nodes)-n<=0): return nodes[1]\\n        node = nodes[len(nodes)-1-n]\\n        node.next= node.next.next\\n        return head\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> nodes;\\n        ListNode* temp = head;\\n        while (temp)\\n        {\\n            nodes.push_back(temp);\\n            temp = temp->next;\\n        }\\n        if (nodes.size()==1) return NULL;\\n        if (nodes.size()-n<=0) return nodes[1];\\n        ListNode* node = nodes[nodes.size()-1-n];\\n        node->next = node->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        nodes = []\\n        temp = head\\n        while (temp):\\n            nodes.append(temp)\\n            temp = temp.next\\n        if (len(nodes)==1): return None\\n        if (len(nodes)-n<=0): return nodes[1]\\n        node = nodes[len(nodes)-1-n]\\n        node.next= node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198611,
                "title": "python-two-pointer-clean-simple-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n\\n        pnt1, pnt2 = dummy, head\\n        for _ in range(n):\\n            pnt2 = pnt2.next\\n\\n        while pnt2:\\n            pnt1, pnt2 = pnt1.next, pnt2.next\\n        \\n        pnt1.next = pnt1.next.next\\n        return dummy.next\\n\\n```\\n\\n## Easy To Understand Solution :\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        trav = head\\n        size = 0\\n        while True:\\n            size += 1\\n            trav = trav.next\\n            if trav == None:\\n                break\\n        \\n        if size == 1:\\n            return None\\n        \\n        if size == n:\\n            return head.next\\n        \\n        \\n        trav = head\\n        while size != n + 1:# or you can write size - n - 1 != 0 :\\n            trav = trav.next\\n            n+=1\\n        \\n        trav.next = trav.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n\\n        pnt1, pnt2 = dummy, head\\n        for _ in range(n):\\n            pnt2 = pnt2.next\\n\\n        while pnt2:\\n            pnt1, pnt2 = pnt1.next, pnt2.next\\n        \\n        pnt1.next = pnt1.next.next\\n        return dummy.next\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        trav = head\\n        size = 0\\n        while True:\\n            size += 1\\n            trav = trav.next\\n            if trav == None:\\n                break\\n        \\n        if size == 1:\\n            return None\\n        \\n        if size == n:\\n            return head.next\\n        \\n        \\n        trav = head\\n        while size != n + 1:# or you can write size - n - 1 != 0 :\\n            trav = trav.next\\n            n+=1\\n        \\n        trav.next = trav.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061329,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\n\\n\\nhttps://youtu.be/yvYtR-KPD6c\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr.length-i == n) continue;\\n        copy.next = new ListNode(arr[i])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function(head, n) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr.length-i == n) continue;\\n        copy.next = new ListNode(arr[i])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632628,
                "title": "python3-19-remove-nth-node-from-end-of-list-t-m-93-70",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        sz, ptr = 0, head\\n        \\n        while ptr:\\n            ptr = ptr.next\\n            sz+=1\\n\\n        if n==sz:\\n            return head.next\\n\\n        sz -= n+1\\n        ptr = head \\n          \\n        while sz > 0:\\n            ptr = ptr.next\\n            sz-=1\\n            \\n        ptr.next = ptr.next.next   \\n        \\n        return head\\n\\t\\t\\n```\\t\\n\\n[https://leetcode.com/submissions/detail/787596599/](http://)\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        \\n        sz, ptr = 0, head\\n        \\n        while ptr:\\n            ptr = ptr.next\\n            sz+=1\\n\\n        if n==sz:\\n            return head.next\\n\\n        sz -= n+1\\n        ptr = head \\n          \\n        while sz > 0:\\n            ptr = ptr.next\\n            sz-=1\\n            \\n        ptr.next = ptr.next.next   \\n        \\n        return head\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632561,
                "title": "daily-leetcoding-challenge-september-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two pass algorithm\n\n  \n**Approach 2:** One pass algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1460289,
                "title": "java-solution-using-two-pointer-and-in-one-pass",
                "content": "Idea:- For solving this question in one pass we can use two pointer approach. In this approach we make two pointer and maintain a gap of size n-1 between these two pointers. \\nWhen first pointer is at the end of the list we sure that second pointer at n+1 position from end . Now we need only remove nth element with the help of second pointer.\\nThe Only edge case is when (n==size of list).\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode p1=head,p2=head;\\n        while(p1!=null&&p1.next!=null){\\n            if(n<=0){\\n                p2=p2.next;\\n            }\\n            p1=p1.next;\\n            --n;\\n        }\\n        if(n>0){                      // The only edge case removed with this condition\\n            head=head.next;\\n        }else{\\n            p2.next=p2.next.next;\\n        }\\n        return head;\\n    }\\n}\\n// If you like the code and concept than Please UpVote me :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode p1=head,p2=head;\\n        while(p1!=null&&p1.next!=null){\\n            if(n<=0){\\n                p2=p2.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1376782,
                "title": "simple-one-pass-solution-in-java-explained-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        // Create two nodes pointing to head;\\n        var first = head;\\n        var second = head;\\n        \\n        // make second node n nodes ahead of first node;\\n        for (int i =0; i <n; i++)\\n            second = second.next;\\n        \\n        // If second node is null, that mean n == list.size-1;\\n        // that means we have to remove the head of the list;\\n        if (second == null)\\n            return first.next;\\n        \\n        // if second node is not null, lets move both first and second nodes\\n        // until second.next == null;\\n        // remember after this, first node will n+1 nodes from the end;\\n        while(second.next != null) {\\n            first = first.next;\\n            second = second.next;\\n        }\\n        \\n        // we can easily skip nth node and make first.next point to n.next;\\n        first.next = first.next.next;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        // Create two nodes pointing to head;\\n        var first = head;\\n        var second = head;\\n        \\n        // make second node n nodes ahead of first node;\\n        for (int i =0; i <n; i++)\\n            second = second.next;\\n        \\n        // If second node is null, that mean n == list.size-1;\\n        // that means we have to remove the head of the list;\\n        if (second == null)\\n            return first.next;\\n        \\n        // if second node is not null, lets move both first and second nodes\\n        // until second.next == null;\\n        // remember after this, first node will n+1 nodes from the end;\\n        while(second.next != null) {\\n            first = first.next;\\n            second = second.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 922955,
                "title": "clean-c-solution",
                "content": "```c\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode *p=head, *q=head;\\n\\t// delay by n nodes.\\n    for(int i=0; i<n; i++) {\\n        p = p->next;\\n    }\\n    if(!p) {\\n        //remove head\\n        return head->next;\\n    }\\n\\t// pass through\\n    while(p->next) {\\n        p = p->next;\\n        q = q->next;\\n    }\\n    q->next = q->next->next;\\n    return head;\\n}\\n```\\n\\nAlthough there are two loop, but it is still a one pass solution.",
                "solutionTags": [],
                "code": "```c\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode *p=head, *q=head;\\n\\t// delay by n nodes.\\n    for(int i=0; i<n; i++) {\\n        p = p->next;\\n    }\\n    if(!p) {\\n        //remove head\\n        return head->next;\\n    }\\n\\t// pass through\\n    while(p->next) {\\n        p = p->next;\\n        q = q->next;\\n    }\\n    q->next = q->next->next;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913192,
                "title": "two-pointers-farer-than-99-67-memory-less-than-99-98",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        if not fast: return head.next\\n        slow = head\\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast = head\\n        while n > 0:\\n            fast = fast.next\\n            n -= 1\\n        if not fast: return head.next\\n        slow = head\\n        while fast.next:\\n            fast = fast.next\\n            slow = slow.next\\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288895,
                "title": "unsafe-rust-single-pass-solution",
                "content": "The fastest solution is to use two pointers, one in front and the other n step back. When the front pointer hits the end of the list, the tail pointer points at the node to remove. So the front pointer can be immutable while the tail one must be mutable. \\n\\nHowever, we cannot have both an immutable and a mutable reference to the same object in safe rust --- I spent quite some time fighting with the borrow checker and realised this is impossible (correct me if I\\'m wrong) --- so the safe rust solution requires two passes: one for the length of list, the other for removing the node.\\n\\nHere is a solution with unsafe rust which should be the most performant.\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        unsafe {\\n            let mut head = head;\\n            let mut front: *mut Option<Box<ListNode>> = &mut head;\\n            let mut tail: *mut Option<Box<ListNode>> = &mut head;\\n            for _ in 0..n {\\n                front = &mut (*front).as_mut().unwrap().next;\\n            }\\n            if (*front).is_none() {\\n                return head.take().unwrap().next;\\n            }\\n            loop {\\n                front = &mut (*front).as_mut().unwrap().next;\\n                if (*front).is_none() {\\n                    break;\\n                }\\n                tail = &mut (*tail).as_mut().unwrap().next;\\n            }\\n            (*tail).as_mut().unwrap().next = (*tail).as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            head\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        unsafe {\\n            let mut head = head;\\n            let mut front: *mut Option<Box<ListNode>> = &mut head;\\n            let mut tail: *mut Option<Box<ListNode>> = &mut head;\\n            for _ in 0..n {\\n                front = &mut (*front).as_mut().unwrap().next;\\n            }\\n            if (*front).is_none() {\\n                return head.take().unwrap().next;\\n            }\\n            loop {\\n                front = &mut (*front).as_mut().unwrap().next;\\n                if (*front).is_none() {\\n                    break;\\n                }\\n                tail = &mut (*tail).as_mut().unwrap().next;\\n            }\\n            (*tail).as_mut().unwrap().next = (*tail).as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            head\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247310,
                "title": "python-one-pass",
                "content": "Suppose the length of linked list is L, the distance between the node to delete and the tail is **|node-tail| = N**. Then **|node-head| = L-N**. So we can use two pointers here to get that **L-N**.\\n\\nPointer **a** first walks N units and there are L-N units left that **a** can walk. Then we have **b** start walking from the head and **a** keep walking simultaneously. \\nAfter **L-N** rounds,  **a** will reach the tail and **b** has walked L-N from the head, with a distance N away from the tail. So when **a** reaches the tail, we know the node that **b** is pointing at is what to delete.\\n\\nIn case the head node is what to delete, we can create a dummy head whose next node is the **head**. Then we have both a and b point at the dummy and eventually return **dummy.next**.\\n```\\ndef removeNthFromEnd(head, n):\\n\\ta = b = dummy = ListNode(0)\\n\\tdummy.next = head\\n\\tfor _ in range(n): \\n\\t\\ta = a.next\\n\\twhile a.next: \\n\\t\\ta, b = a.next, b.next\\n\\tb.next = b.next.next\\n\\treturn dummy.next\\n```\\nIt\\'s a one pass O(n) time O(1) space solution.",
                "solutionTags": [],
                "code": "```\\ndef removeNthFromEnd(head, n):\\n\\ta = b = dummy = ListNode(0)\\n\\tdummy.next = head\\n\\tfor _ in range(n): \\n\\t\\ta = a.next\\n\\twhile a.next: \\n\\t\\ta, b = a.next, b.next\\n\\tb.next = b.next.next\\n\\treturn dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 220627,
                "title": "rust-0-ms-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = Some(Box::new(ListNode {\\n            val: 0, next: head,\\n        }));\\n        let mut len = 0;\\n        {\\n            let mut p = dummy_head.as_ref();\\n            while p.unwrap().next.is_some() {\\n                len += 1;\\n                p = p.unwrap().next.as_ref();\\n            }\\n        }\\n        let idx = len - n;\\n        {\\n            let mut p = dummy_head.as_mut();\\n            for _ in 0..(idx) {\\n                p = p.unwrap().next.as_mut();\\n            }\\n            let next = p.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            p.as_mut().unwrap().next = next;\\n        }\\n        dummy_head.unwrap().next\\n    }\\n}\\n```\\nAfter hours figting with borrow checker, I think the \"One Pass\" algorithm cannot be written in Rust without `unsafe`. \\nBut actually the two pass solution is just as fast as one pass solution (times of moving pointer should be same), so just take it.",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = Some(Box::new(ListNode {\\n            val: 0, next: head,\\n        }));\\n        let mut len = 0;\\n        {\\n            let mut p = dummy_head.as_ref();\\n            while p.unwrap().next.is_some() {\\n                len += 1;\\n                p = p.unwrap().next.as_ref();\\n            }\\n        }\\n        let idx = len - n;\\n        {\\n            let mut p = dummy_head.as_mut();\\n            for _ in 0..(idx) {\\n                p = p.unwrap().next.as_mut();\\n            }\\n            let next = p.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n            p.as_mut().unwrap().next = next;\\n        }\\n        dummy_head.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9101,
                "title": "my-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode *removeNthFromEnd(ListNode *head, int n) {\\n            ListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\tListNode* prev = front;\\n    \\t\\tListNode* post = front;\\n    \\t\\twhile (prev != nullptr){\\n    \\t\\t\\tprev = prev->next;\\n    \\t\\t\\tif (n<0)\\tpost = post->next;\\n    \\t\\t\\tn--;\\n    \\t\\t}\\n    \\t\\tListNode* temp = post->next;\\n    \\t\\tpost->next = temp->next;\\n    \\t\\tdelete temp;\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *removeNthFromEnd(ListNode *head, int n) {\\n            ListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\tListNode* prev = front;\\n    \\t\\tListNode* post = front;\\n    \\t\\twhile (prev != nullptr){\\n    \\t\\t\\tprev = prev->next;\\n    \\t\\t\\tif (n<0)\\tpost = post->next;\\n    \\t\\t\\tn--;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 8819,
                "title": "my-one-pass-solution-with-two-pointers",
                "content": "    class Solution:\\n\\tdef removeNthFromEnd(self, head, n):\\n\\t\\tcur = head\\n\\t\\tnpre= head\\n\\t\\tdis = 0\\n\\t\\tcount = 1\\n\\t\\twhile cur.next is not None:\\n\\t\\t\\tcur = cur.next\\n\\t\\t\\tcount += 1\\n\\t\\t\\tdis += 1\\n\\t\\t\\twhile dis > n:\\n\\t\\t\\t\\tnpre = npre.next\\n\\t\\t\\t\\tdis -= 1\\n\\t\\tif count <= n:\\n\\t\\t\\treturn head.next\\n\\t\\tnpre.next = npre.next.next\\n\\t\\treturn head\\n\\nYou should pay attention to the case which removes the first node.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n\\tdef removeNthFromEnd(self, head, n):\\n\\t\\tcur = head\\n\\t\\tnpre= head\\n\\t\\tdis = 0\\n\\t\\tcount = 1\\n\\t\\twhile cur.next is not None:\\n\\t\\t\\tcur = cur.next\\n\\t\\t\\tcount += 1\\n\\t\\t\\tdis += 1\\n\\t\\t\\twhile dis > n:\\n\\t\\t\\t\\tnpre = npre.next\\n\\t\\t\\t\\tdis -= 1\\n\\t\\tif count <= n:\\n\\t\\t\\treturn head.next\\n\\t\\tnpre.next = npre.next.next\\n\\t\\treturn head\\n\\nYou should pay attention to the case which removes the first node.",
                "codeTag": "Java"
            },
            {
                "id": 3145684,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nTwo Pass\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }\\n        if (count == n)\\n            return head->next;\\n        int cnt = count - n - 1;\\n        curr = head;\\n        while (cnt--) \\n            curr = curr->next;\\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Approach 2\\nOne Pass\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* slow = head, * fast = head;\\n        while (n--) \\n            fast = fast->next;\\n        if (fast == NULL)\\n            return head->next;    \\n        while (fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }    \\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }\\n        if (count == n)\\n            return head->next;\\n        int cnt = count - n - 1;\\n        curr = head;\\n        while (cnt--) \\n            curr = curr->next;\\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (head->next == NULL && n == 1)\\n            return NULL;\\n        ListNode* slow = head, * fast = head;\\n        while (n--) \\n            fast = fast->next;\\n        if (fast == NULL)\\n            return head->next;    \\n        while (fast->next != NULL) {\\n            slow = slow->next;\\n            fast = fast->next;\\n        }    \\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100048,
                "title": "beats-100-c-easy-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a gap of N between two pointers, \\nthen increment both pointer one step at a time, until succeeding pointer reaches the end!\\nThe preceding pointer will automatically be pointing at \\n(LL.size() - n)th position.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(!head->next){\\n            return head->next;\\n        }\\n        ListNode* prevHold = NULL;\\n        ListNode* prev = head;\\n        ListNode* fwd = head;\\n        --n;\\n        while(n--){\\n            fwd = fwd->next;\\n        }\\n        if(!fwd->next){\\n            return head->next;\\n        }\\n        while(fwd->next){\\n            prevHold = prev;\\n            prev = prev->next;\\n            fwd = fwd->next;\\n        }\\n        prevHold->next = prev->next;\\n        delete prev;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(!head->next){\\n            return head->next;\\n        }\\n        ListNode* prevHold = NULL;\\n        ListNode* prev = head;\\n        ListNode* fwd = head;\\n        --n;\\n        while(n--){\\n            fwd = fwd->next;\\n        }\\n        if(!fwd->next){\\n            return head->next;\\n        }\\n        while(fwd->next){\\n            prevHold = prev;\\n            prev = prev->next;\\n            fwd = fwd->next;\\n        }\\n        prevHold->next = prev->next;\\n        delete prev;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637475,
                "title": "simple-beginner-friendly-easy-to-understand-0ms",
                "content": "```class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummynode = new ListNode(0);  // creating dummy node;\\n\\t\\t\\n\\t\\t// if head has only one node (base case)\\n        if(head->next==NULL){\\n            head=head->next;\\n            delete(head);\\n            return dummynode->next;\\n        }\\n        dummynode->next=head; // dummy node pointing to head\\n        ListNode* prev=head;  // previous pointer to store previous node\\n        ListNode* curr=head; // current poninter to point current node\\n        int count=1;\\n        while(curr->next!=NULL){\\n                if(count!=n){\\n                    count++;\\n                    curr=curr->next;\\n                    continue;\\n                }\\n            curr=curr->next;\\n            prev=prev->next;\\n        }\\n        \\n\\t\\t\\n\\t\\t//if we have to delete head;\\n\\t\\t\\n        if(dummynode->next==head && count!=1 && prev==head){\\n            dummynode->next=head->next;\\n            return dummynode->next;\\n        }\\n\\t\\t// traversing till one node begind prev node\\n        while(head->next!=prev && head!=prev){\\n            head=head->next;\\n        }\\n        head->next=prev->next;\\n        \\n        return dummynode->next;\\n        \\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummynode = new ListNode(0);  // creating dummy node;\\n\\t\\t\\n\\t\\t// if head has only one node (base case)\\n        if(head->next==NULL){\\n            head=head->next;\\n            delete(head);\\n            return dummynode->next;\\n        }\\n        dummynode->next=head; // dummy node pointing to head\\n        ListNode* prev=head;  // previous pointer to store previous node\\n        ListNode* curr=head; // current poninter to point current node\\n        int count=1;\\n        while(curr->next!=NULL){\\n                if(count!=n){\\n                    count++;\\n                    curr=curr->next;\\n                    continue;\\n                }\\n            curr=curr->next;\\n            prev=prev->next;\\n        }\\n        \\n\\t\\t\\n\\t\\t//if we have to delete head;\\n\\t\\t\\n        if(dummynode->next==head && count!=1 && prev==head){\\n            dummynode->next=head->next;\\n            return dummynode->next;\\n        }\\n\\t\\t// traversing till one node begind prev node\\n        while(head->next!=prev && head!=prev){\\n            head=head->next;\\n        }\\n        head->next=prev->next;\\n        \\n        return dummynode->next;\\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2423563,
                "title": "python-simple-and-clean-beats-90-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n**Runner Method**\\n1. Instantiate the fast and slow runner\\n2. *fast* runner moves *n* steps ahead of the *slow* runner\\n3. Meanwhile, the *fast* runner reaches the end, *slow* runner will be at the prev node of the target node.\\n4. Then we just delete the target node and return the head the of the LL.\\n\\n***Implementation***\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        #Step 1\\n\\t\\tslow = fast = head\\n\\t\\t\\n\\t\\t#Step 2\\n        while(n>0):\\n            fast = fast.next\\n            n-=1\\n\\t\\t\\t\\n\\t\\t#Step 3\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next\\n\\t\\t\\t\\n\\t\\t#Step 4\\n        if(fast):\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        #Step 1\\n\\t\\tslow = fast = head\\n\\t\\t\\n\\t\\t#Step 2\\n        while(n>0):\\n            fast = fast.next\\n            n-=1\\n\\t\\t\\t\\n\\t\\t#Step 3\\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next\\n\\t\\t\\t\\n\\t\\t#Step 4\\n        if(fast):\\n            slow.next = slow.next.next\\n        else:\\n            head = head.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706885,
                "title": "my-single-loop-solution-in-c-o-n-time-o-1-space-complexity",
                "content": "```\\nListNode *removeNthFromEnd(ListNode *head, int n){\\n    ListNode *p = head, *q = head;\\n    while (q) {\\n        if (n < 0)  p = p->next;\\n        else  n--;\\n        q = q->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else  p->next = p->next->next;\\n    return head;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode *removeNthFromEnd(ListNode *head, int n){\\n    ListNode *p = head, *q = head;\\n    while (q) {\\n        if (n < 0)  p = p->next;\\n        else  n--;\\n        q = q->next;\\n    }\\n    if (n == 0) head = head->next;\\n    else  p->next = p->next->next;\\n    return head;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677829,
                "title": "c-two-pointer-easy-to-understand-time-o-n-space-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/aa9908c4-58aa-4d16-a850-5885515a9064_1642417916.7980297.jpeg)\\n**Please Upvote if it helps...!**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        int count = n;\\n        while(count > 0)\\n        {\\n            fast = fast->next;\\n            count--;\\n        }      \\n        if(fast == NULL)\\n        {\\n            return head->next; // edge case handled\\n        }   \\n        while(fast->next!=NULL)\\n        {\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        int count = n;\\n        while(count > 0)\\n        {\\n            fast = fast->next;\\n            count--;\\n        }      \\n        if(fast == NULL)\\n        {\\n            return head->next; // edge case handled\\n        }   \\n        while(fast->next!=NULL)\\n        {\\n            slow=slow->next; \\n            fast=fast->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529913,
                "title": "c-one-pass-100-fast-recursion-solution-with-picture",
                "content": "\\n![image](https://assets.leetcode.com/users/images/263aacc8-9c23-403b-b1b0-4ea6dd31b992_1634740578.2843018.jpeg)\\n\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int remove(ListNode* head, int n)\\n    {\\n        if(head==NULL)\\n            return 0;\\n        \\n        int steps = remove(head->next, n); //steps to reach the last node from head->next node\\n            \\n        if(steps == n)   //if head->next is the node that we need to remove\\n            head->next = head->next->next;   //then remove it\\n        \\n        return steps+1;\\n    }\\n\\t\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        if(remove(head, n) == n)   //if head is the node that we need to remove \\n            head = head->next;     \\n        \\n        return head;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int remove(ListNode* head, int n)\\n    {\\n        if(head==NULL)\\n            return 0;\\n        \\n        int steps = remove(head->next, n); //steps to reach the last node from head->next node\\n            \\n        if(steps == n)   //if head->next is the node that we need to remove\\n            head->next = head->next->next;   //then remove it\\n        \\n        return steps+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1517658,
                "title": "javascript-100-very-simple-tortoise-hare-array-versions",
                "content": "![image](https://assets.leetcode.com/users/images/200ef282-0c57-426a-885e-d02d887785ab_1634065405.0991726.png)\\n\\n\\nEDIT: Upon further testing, the Array tracking version at the bottom seems to consistently score better runtimes here on LC.  They\\'re both O(n).  I still think that this is a classic Tortoise and Hare problem, and that\\'s what they\\'ll be looking for.  But you can Easily defend the Array version as well imo (On Time Complexity at least.  It\\'s still worse on space because it\\'s O(n) space whereas Tortoise and Hare is O(1).).  Take your pick. \\n\\nI wrote two solutions for this problem.  First is the most performant, and the most \\'clever\\' solution that they\\'ll probably want in an interview.  First solution uses tortoise and hare pointers to locate the node which needs to be removed.  Second is FAR easier to code imo, but I\\'m not sure they would consider it optimal in an interview if they\\'re looking for constant space.  Second stores linked list nodes in an array and then we can locate which nodes we need Very easily and remove them.  That said, it does take extra space to store in the array and this is a classic \\'tortoise and hare\\' problem - so if they\\'re asking it, they\\'re likely looking for the first solution.  If you strugle to implement it on the spot though, the second version might save face in a pinch.\\n\\nEitherway though, the basic intuition is to \\'locate\\' the node Before the one to be removed.  There are three possibilities here.  1.) Node to be removed is the head node.  I.E. - The one we need to locate Before it doesn\\'t exist.  In this case, our hare will end up at null after it loops. Or in the Array version, llMap.length - n - 1 will be -1.  We then just simply return head.next which \\'removes\\' the original head node.  2.) Node to be removed is at the End of the list.  In this case, our node Before it has a node.next, but node.next.next = null.  Here our code for case 3 works as well because it will just set node.next = null, which \\'removes\\' our node.next (The last node.) 3.)  Normal Linked List node removal.  There is a node.next (One to be removed since we located the node Before it.), and there is a node.next.next.  In this case, we just set node.next = node.next.next and the node is removed.  Hardest part about this problem is locating the correct node.  Tortoise and Hare both start at head.  We then move hare forward n.  After moving hare, we check to see if hare === null (!hare).  If it does, we know the node to remove is the first and we go with case 1.  Then we begin to move tortoise and hare in tandem until hare.next === null.  This means hare is now at the end of the list and turtle is one before the node we need to remove. We have located the correct node.  The storing in an array one is pretty simple, we just store them, and can instantly look up the nth from the end by its array index.\\n\\n```\\nconst removeNthFromEnd = (head, n) => {  \\n  let tortoise = head, hare = head;\\n  \\n  while (n) hare = hare.next, n--;\\n  if (!hare) return head.next;\\n  \\n  while (hare.next) hare = hare.next, tortoise = tortoise.next;       \\n         \\n  tortoise.next = tortoise.next.next\\n  \\n  return head\\n}\\n```\\n\\nTrack by array version.\\n\\n```\\nconst removeNthFromEnd = (head, n) => {\\n  const llMap = [];\\n  \\n  while (head) {\\n    llMap.push(head);\\n    head = head.next;\\n  }\\n    \\n  const prevNode = llMap[llMap.length - n - 1];\\n  \\n  if (!prevNode) return llMap[0].next;\\n  \\n  prevNode.next = prevNode.next.next;\\n    \\n  return llMap[0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeNthFromEnd = (head, n) => {  \\n  let tortoise = head, hare = head;\\n  \\n  while (n) hare = hare.next, n--;\\n  if (!hare) return head.next;\\n  \\n  while (hare.next) hare = hare.next, tortoise = tortoise.next;       \\n         \\n  tortoise.next = tortoise.next.next\\n  \\n  return head\\n}\\n```\n```\\nconst removeNthFromEnd = (head, n) => {\\n  const llMap = [];\\n  \\n  while (head) {\\n    llMap.push(head);\\n    head = head.next;\\n  }\\n    \\n  const prevNode = llMap[llMap.length - n - 1];\\n  \\n  if (!prevNode) return llMap[0].next;\\n  \\n  prevNode.next = prevNode.next.next;\\n    \\n  return llMap[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1406874,
                "title": "java-brute-force-appraoch",
                "content": "**This is not most optimise!!**\\n1.First we find out the length of linkedlist ;\\n2.then we will loop till the length - n ;\\n3.then we change the **curr.next** to **curr.next.next** ;\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode p = head;\\n        head = dummy;\\n            \\n        ListNode temp  = head;\\n        int len = size(head);\\n        int i = 0;\\n        if(len <= 1){\\n            return null;\\n        }\\n        \\n        while( i < len - n-1){\\n            temp = temp.next;\\n            i += 1;\\n        }\\n        temp.next = temp.next.next;\\n        return head.next;\\n        \\n    }\\n    public int size(ListNode head){\\n        int size = 0;\\n        while(head != null){\\n            head = head.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n}\\n//This is not most optimise but still we get 0ms Runtime\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode p = head;\\n        head = dummy;\\n            \\n        ListNode temp  = head;\\n        int len = size(head);\\n        int i = 0;\\n        if(len <= 1){\\n            return null;\\n        }\\n        \\n        while( i < len - n-1){\\n            temp = temp.next;\\n            i += 1;\\n        }\\n        temp.next = temp.next.next;\\n        return head.next;\\n        \\n    }\\n    public int size(ListNode head){\\n        int size = 0;\\n        while(head != null){\\n            head = head.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n}\\n//This is not most optimise but still we get 0ms Runtime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304109,
                "title": "c-edge-case-handled-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n//         making three pointers to listNode curr,prev and fi\\n        ListNode* curr=head,*prev=head;\\n        ListNode* fi=NULL;\\n\\n        int x=n;\\n        int count=0;\\n//         incrementing curr n times\\n        while(n--)\\n        {\\n            curr=curr->next;\\n            count++;\\n        }\\n//         check if the number is first to delete or not\\n          if(curr==NULL && x==count)\\n                return head->next;\\n//         if its not the first to delete and the nth node is out of bound\\n            else if(curr==NULL)\\n                return head;\\n       \\n//        simply increment curr till NULL and increment prev as well mainaining a previous pointer\\n        while(curr!=NULL)\\n        {\\n            curr=curr->next;\\n            fi=prev;\\n            prev=prev->next;\\n        }\\n//         deleting the pointer\\n        fi->next=prev->next;\\n//         return the head \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n//         making three pointers to listNode curr,prev and fi\\n        ListNode* curr=head,*prev=head;\\n        ListNode* fi=NULL;\\n\\n        int x=n;\\n        int count=0;\\n//         incrementing curr n times\\n        while(n--)\\n        {\\n            curr=curr->next;\\n            count++;\\n        }\\n//         check if the number is first to delete or not\\n          if(curr==NULL && x==count)\\n                return head->next;\\n//         if its not the first to delete and the nth node is out of bound\\n            else if(curr==NULL)\\n                return head;\\n       \\n//        simply increment curr till NULL and increment prev as well mainaining a previous pointer\\n        while(curr!=NULL)\\n        {\\n            curr=curr->next;\\n            fi=prev;\\n            prev=prev->next;\\n        }\\n//         deleting the pointer\\n        fi->next=prev->next;\\n//         return the head \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867059,
                "title": "c-recursion-faster-than-92-78",
                "content": "```\\n    private int m = 0;\\n    \\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n            \\n        if (head == null)\\n        {\\n            return null;\\n        }\\n\\n        var h = RemoveNthFromEnd(head.next, n);\\n\\n        m++;\\n        if (m == n) return h;\\n\\n        head.next = h;\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int m = 0;\\n    \\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n            \\n        if (head == null)\\n        {\\n            return null;\\n        }\\n\\n        var h = RemoveNthFromEnd(head.next, n);\\n\\n        m++;\\n        if (m == n) return h;\\n\\n        head.next = h;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609269,
                "title": "javascript-solution",
                "content": "```\\nlet removeNthFromEnd = function(head, n) {\\n    let p = head, node = head\\n    \\n    while(n--){\\n        p = p.next\\n    }\\n    while(p && p.next ) {\\n        p = p.next\\n        node = node.next\\n    }\\n    \\n    if(!p)  head = head.next\\n    else node.next = node.next.next\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet removeNthFromEnd = function(head, n) {\\n    let p = head, node = head\\n    \\n    while(n--){\\n        p = p.next\\n    }\\n    while(p && p.next ) {\\n        p = p.next\\n        node = node.next\\n    }\\n    \\n    if(!p)  head = head.next\\n    else node.next = node.next.next\\n\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364537,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode newHead = new ListNode(0);\\n        newHead.next = head;\\n        ListNode a = newHead;\\n        ListNode b = newHead;\\n        while(n > 0){\\n            b = b.next;\\n            n--;\\n        }\\n        while(b.next != null){\\n            b = b.next;\\n            a = a.next;\\n        }\\n        a.next = a.next.next;\\n        return newHead.next;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove Nth Node From End of List.\\nMemory Usage: 34.8 MB, less than 100.00% of Java online submissions for Remove Nth Node From End of List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode newHead = new ListNode(0);\\n        newHead.next = head;\\n        ListNode a = newHead;\\n        ListNode b = newHead;\\n        while(n > 0){\\n            b = b.next;\\n            n--;\\n        }\\n        while(b.next != null){\\n            b = b.next;\\n            a = a.next;\\n        }\\n        a.next = a.next.next;\\n        return newHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295314,
                "title": "c-brute-force-to-clean-solution-with-explanation",
                "content": "When displaying these problems, developers should show the thought process. \\nHere I show the brute force solution and the cleaner solution. \\n\\n\\nNote the similarities:\\n1. Intialization - Creating that first empty node handles the zero condition\\n2. Deletion - Basic principle of a linked list\\n\\n--------------------------------\\n\\n**BRUTE FORCE**\\nThe brute force uses getting a count first. \\nIt\\'s not pretty but the biggest issue is looping through the list twice. \\n\\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        var start = new ListNode(0);\\n        var node = start;\\n        node.next = head;\\n\\t\\t\\n        // Get Count\\n        var count = GetCount(head);\\n\\t\\t\\n        // Iterate to node to Skip\\n        for(int i = 0; i < count - n; i++) {\\n            node = node.next;\\n        }\\n\\t\\t\\n        // Remove Node\\n        node.next = node.next.next;\\n\\n        return start.next;\\n    }\\n    \\n    private int GetCount(ListNode head) {\\n        var count = 0;\\n        var current = head;\\n        while(current != null) {\\n            count++;\\n            current = current.next;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n------------------------------------------------------------------\\n\\n**DOUBLE POINTER**\\n\\nIf you understand the method to get the count, this becomes more feasible. \\n\\nThe solution that everyone has posted repeatedly. \\n1. Fast pointer - exactly n ahead slow\\n2. Slow pointer - the pointer that will hit length - n\\n\\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) { \\n        var start = new ListNode(0);\\n        var slow = start;\\n        var fast = start;\\n        slow.next = head;\\n    \\n        // Fast is n in front of slow\\n        for(int i = 0; i <= n;  i++)   {\\n            fast = fast.next;\\n        }\\n        \\n        // When Fast is at end, Slow is at end - n\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Remove Node\\n        slow.next = slow.next.next;\\n\\n        return start.next;\\n    }    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\\n        var start = new ListNode(0);\\n        var node = start;\\n        node.next = head;\\n\\t\\t\\n        // Get Count\\n        var count = GetCount(head);\\n\\t\\t\\n        // Iterate to node to Skip\\n        for(int i = 0; i < count - n; i++) {\\n            node = node.next;\\n        }\\n\\t\\t\\n        // Remove Node\\n        node.next = node.next.next;\\n\\n        return start.next;\\n    }\\n    \\n    private int GetCount(ListNode head) {\\n        var count = 0;\\n        var current = head;\\n        while(current != null) {\\n            count++;\\n            current = current.next;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public ListNode RemoveNthFromEnd(ListNode head, int n) { \\n        var start = new ListNode(0);\\n        var slow = start;\\n        var fast = start;\\n        slow.next = head;\\n    \\n        // Fast is n in front of slow\\n        for(int i = 0; i <= n;  i++)   {\\n            fast = fast.next;\\n        }\\n        \\n        // When Fast is at end, Slow is at end - n\\n        while(fast != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Remove Node\\n        slow.next = slow.next.next;\\n\\n        return start.next;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229716,
                "title": "rust-recursion-0ms",
                "content": "```rust\\npub fn remove(head: Option<Box<ListNode>>, n: i32) -> (i32, Option<Box<ListNode>>) {\\n    if let Some(boxed) = head {\\n        let (mut tail_index, tail) = remove(boxed.next, n);\\n        tail_index += 1;\\n\\n        if tail_index == n {\\n            (tail_index, tail)\\n        } else {\\n            (tail_index, Some(Box::new(ListNode {\\n                val: boxed.val,\\n                next: tail\\n            })))\\n        }\\n    } else {\\n        (0, None)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove(head, n).1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn remove(head: Option<Box<ListNode>>, n: i32) -> (i32, Option<Box<ListNode>>) {\\n    if let Some(boxed) = head {\\n        let (mut tail_index, tail) = remove(boxed.next, n);\\n        tail_index += 1;\\n\\n        if tail_index == n {\\n            (tail_index, tail)\\n        } else {\\n            (tail_index, Some(Box::new(ListNode {\\n                val: boxed.val,\\n                next: tail\\n            })))\\n        }\\n    } else {\\n        (0, None)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        remove(head, n).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 9034,
                "title": "java-solution-using-recursion",
                "content": "      public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n\\t    int count = helper(cur, 0, n);\\n\\t    if (count+1 == n) head = head.next;\\n\\t    return head; \\n    }\\n    \\n    public int helper(ListNode head, int count, int target) {\\n        if (head == null || head.next == null) {\\n            return 0;\\n        }\\n        count = helper(head.next, count, target);\\n        count++;\\n        if (count == target) {\\n            head.next = head.next.next;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "      public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n\\t    int count = helper(cur, 0, n);\\n\\t    if (count+1 == n) head = head.next;\\n\\t    return head; \\n    }\\n    \\n    public int helper(ListNode head, int count, int target) {\\n        if (head == null || head.next == null) {\\n            return 0;\\n        }\\n        count = helper(head.next, count, target);\\n        count++;\\n        if (count == target) {\\n            head.next = head.next.next;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 9039,
                "title": "share-my-4ms-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {//\\u5f00\\u8f9f\\u4e00\\u4e2a\\u5934\\u7ed3\\u70b9\\u5c31\\u53ef\\u4ee5\\u89e3\\u51b3\\u95ee\\u9898\\u5566\\uff01\\n            if(!head -> next) return NULL;\\n            ListNode* headt = new ListNode(0);\\n            headt -> next = head;\\n            ListNode* forward = headt;\\n            ListNode* tail = headt;\\n            for(int i = 0; i < n; i++){\\n                if(forward -> next) forward = forward -> next;\\n            }\\n            while(forward -> next){\\n                forward = forward -> next;\\n                tail = tail -> next;\\n            }\\n            tail -> next = tail -> next -> next;\\n            return headt -> next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeNthFromEnd(ListNode* head, int n) {//\\u5f00\\u8f9f\\u4e00\\u4e2a\\u5934\\u7ed3\\u70b9\\u5c31\\u53ef\\u4ee5\\u89e3\\u51b3\\u95ee\\u9898\\u5566\\uff01\\n            if(!head -> next) return NULL;\\n            ListNode* headt = new ListNode(0);\\n            headt -> next = head;\\n            ListNode* forward = headt;\\n            ListNode* tail = headt;\\n            for(int i = 0; i < n; i++){\\n                if(forward -> next) forward = forward -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 9051,
                "title": "java-short-and-clean-solution",
                "content": "    public class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null) {\\n        \\tif (n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}\\n        \\tfast = fast.next;\\n        }\\n        if (n < 0) \\n        \\tslow.next = slow.next.next;\\n        else \\n        \\thead = head.next;\\n        \\n        return head;\\n    } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head, slow = head;\\n        while (fast != null) {\\n        \\tif (n-- < 0) {\\n        \\t\\tslow = slow.next;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 9163,
                "title": "python-solution-with-dummy-head-less-edge-cases-make-life-easier",
                "content": "Try to consider the extreme case. What if n = len(list)? What if n = 0? (impossible, but you need to demonstrate that you have thought of the edge cases)\\n\\nUsing the dummy head ensures that you can always return something, as the head itself could be removed.\\n\\n    class Solution:\\n        # @return a ListNode\\n        '''\\n        n = 5\\n        (-1)->1->2->3->4->5\\n        \\n        i    =    0->1->2->3->4->5\\n        fast = (-1)->1->2->3->4->5\\n        \\n        fast = 5\\n        slow = (-1)\\n        \\n        slow.next = head.next = 2\\n        '''\\n        def removeNthFromEnd(self, head, n):\\n            assert n > 0\\n            dummy = ListNode(-1)\\n            dummy.next = head\\n            slow, fast = dummy, dummy\\n            for i in range(n):\\n                fast = fast.next\\n                assert fast\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return dummy.next",
                "solutionTags": [],
                "code": "Try to consider the extreme case. What if n = len(list)? What if n = 0? (impossible, but you need to demonstrate that you have thought of the edge cases)\\n\\nUsing the dummy head ensures that you can always return something, as the head itself could be removed.\\n\\n    class Solution:\\n        # @return a ListNode\\n        '''\\n        n = 5\\n        (-1)->1->2->3->4->5\\n        \\n        i    =    0->1->2->3->4->5\\n        fast = (-1)->1->2->3->4->5\\n        \\n        fast = 5\\n        slow = (-1)\\n        \\n        slow.next = head.next = 2\\n        '''\\n        def removeNthFromEnd(self, head, n):\\n            assert n > 0\\n            dummy = ListNode(-1)\\n            dummy.next = head\\n            slow, fast = dummy, dummy\\n            for i in range(n):\\n                fast = fast.next\\n                assert fast\\n            while fast.next:\\n                fast = fast.next\\n                slow = slow.next\\n            slow.next = slow.next.next\\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 3446797,
                "title": "keep-it-simple-baby",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1 for loop\\n1 love\\n1 live\\n\\n# Code\\n```\\npublic class Solution\\n    {\\n        public ListNode RemoveNthFromEnd(ListNode head, int n)\\n        {\\n            ListNode prev = null;\\n\\n            for (var (node, i) = (head, 0); node != null; node = node.next, i++)            \\n                if (i >= n)                \\n                    if (prev == null) prev = head;\\n                    else prev = prev.next;    \\n            \\n            if (prev == null) return head.next;\\n            if (prev.next != null) prev.next = prev.next.next;\\n            return head;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n    {\\n        public ListNode RemoveNthFromEnd(ListNode head, int n)\\n        {\\n            ListNode prev = null;\\n\\n            for (var (node, i) = (head, 0); node != null; node = node.next, i++)            \\n                if (i >= n)                \\n                    if (prev == null) prev = head;\\n                    else prev = prev.next;    \\n            \\n            if (prev == null) return head.next;\\n            if (prev.next != null) prev.next = prev.next.next;\\n            return head;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394224,
                "title": "java-linked-list-remove-elem",
                "content": "\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ArrayList<ListNode> arr = new ArrayList<>();\\n        while (head != null)\\n        {\\n            arr.add(head);\\n            head = head.next;\\n        }\\n        if (arr.size() == 0 || n > arr.size())\\n            return null;\\n        if (n == arr.size())\\n            return arr.get(0).next;\\n        arr.get(arr.size() - n - 1).next = arr.get(arr.size() - n).next;\\n        return arr.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ArrayList<ListNode> arr = new ArrayList<>();\\n        while (head != null)\\n        {\\n            arr.add(head);\\n            head = head.next;\\n        }\\n        if (arr.size() == 0 || n > arr.size())\\n            return null;\\n        if (n == arr.size())\\n            return arr.get(0).next;\\n        arr.get(arr.size() - n - 1).next = arr.get(arr.size() - n).next;\\n        return arr.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633008,
                "title": "simple-js",
                "content": "```\\nconst removeNthFromEnd = function(head, n) {\\n\\n    const nodeFromStart = totalNoOfNodes(head) - n;\\n    \\n    if(nodeFromStart==0) return head.next\\n    \\n    let prev = head;\\n    let next = head.next;\\n    for(let i=1; i<nodeFromStart; i++) {\\n        prev=prev.next;\\n        next=next.next;\\n    }\\n    \\n    prev.next = next.next; //CRUX\\n    \\n    return head;\\n    \\n};\\n\\nfunction totalNoOfNodes(head){\\n    let count = 0;\\n    while(head){\\n        head = head.next;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeNthFromEnd = function(head, n) {\\n\\n    const nodeFromStart = totalNoOfNodes(head) - n;\\n    \\n    if(nodeFromStart==0) return head.next\\n    \\n    let prev = head;\\n    let next = head.next;\\n    for(let i=1; i<nodeFromStart; i++) {\\n        prev=prev.next;\\n        next=next.next;\\n    }\\n    \\n    prev.next = next.next; //CRUX\\n    \\n    return head;\\n    \\n};\\n\\nfunction totalNoOfNodes(head){\\n    let count = 0;\\n    while(head){\\n        head = head.next;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2411474,
                "title": "python-3-one-pass-approach-explained",
                "content": "**Context**\\\\\\nWe\\'re given two parameters: `head` and `n`. The former stores a reference to the head of the linked list. The latter stores an integer representing the xth final node that we must remove (*i.e. if `n` is 2, then we must remove the 2nd final node*). The problem requires us to remove the nth final node from the linked list.\\n\\n**Solution**\\\\\\nThe way to solve this problem in one-pass is by utilizing two pointer variables: `slow` and `fast`. In order to find the nth final node, we\\'ll need to find the total number of nodes in the linked list. However, this (finding the total number of nodes) requires N additional time - which prevents us from solving the problem in one pass.\\n\\nRather than finding the nth final node, we can find the nth node instead (*i.e. if the total number of nodes is 5 and `n` is 2, then we\\'ll want to remove the 3rd node*). This can be achieved by executing two tasks:\\n* move `fast` `n` times beforehand\\n* move `slow` and `fast` in parallel until `fast.next` is null.\\n\\nBy the time `fast.next` is null, `slow` should be storing a reference to the nth node\\'s previous node. The way to remove the nth node is by having `slow` point to the nth node\\'s next node (`slow.next = slow.next.next`).\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = fast = head\\n        \\n        for _ in range(n):\\n            fast = fast.next\\n        \\n        # if fast is null, then it implies that we must remove\\n        # the first node. Hence, we\\'ll return the next node\\n        # (after the first node) as an answer.\\n        if not fast:\\n            return head.next\\n        \\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        slow.next = slow.next.next\\n        return head\\n```\\n\\\\\\nThe time complexity is O(N) because we must iterate through the linked list at most once (moving `fast` `n` times beforehand + moving `fast` until it\\'s null).\\n\\nThe space complexity is O(1) because we\\'re only using few additional spaces to initialize few variables.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = fast = head\\n        \\n        for _ in range(n):\\n            fast = fast.next\\n        \\n        # if fast is null, then it implies that we must remove\\n        # the first node. Hence, we\\'ll return the next node\\n        # (after the first node) as an answer.\\n        if not fast:\\n            return head.next\\n        \\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        \\n        slow.next = slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270564,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n// Naive Solution :: Time : O(N) + O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        int count = 0;\\n        ListNode *curr = head;\\n\\n        while(curr){\\n            count++;\\n            curr = curr->next;\\n        }\\n\\n        if(count == n){\\n            head = head->next;\\n            return head;\\n        }\\n\\n\\n        int k = count-n;\\n\\n        ListNode *temp = head;\\n        count = 1;\\n\\n        while(count!=k){\\n\\n            temp = temp->next;\\n            count++;\\n        }\\n\\n        ListNode *var = temp->next;\\n        temp->next = temp->next->next;\\n        delete(var);\\n\\n        return head;\\n    }\\n};\\n\\n// Efficient Solutin :: Time : O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* curr = new ListNode();\\n        curr->next = head;\\n        ListNode* fast = curr;\\n        ListNode* slow = curr;\\n\\n        int k = n;\\n\\n        while(k--){\\n            fast = fast->next;\\n        }\\n\\n        while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n\\n        slow->next = slow->next->next;\\n\\n        return curr->next;\\n\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        int count = 0;\\n        ListNode *curr = head;\\n\\n        while(curr){\\n            count++;\\n            curr = curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2192124,
                "title": "java-0ms-beats-100-in-time-simple-and-easy-with-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/2e075c52-0509-4921-afd1-8763fa174e10_1656090668.9436104.png)\\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int len=0;\\n        ListNode temp=head;\\n        // Find the length/size of list.\\n        while(temp!=null)\\n        {\\n            len++;\\n            temp=temp.next;\\n        }\\n        System.out.println(len);\\n        if(len==1) return null;\\n        if(len-n==0) return head.next;\\n      \\n        int count=1;\\n        temp=head;\\n\\t\\t//Reach to the node before the one you want to delete.\\n        //If len is 5, 2nd element from last means 3rd element from start.\\n        while(count!=len-n)\\n        {\\n            temp=temp.next;\\n            count++;\\n        }\\n        System.out.println(temp.val);\\n        temp.next=temp.next.next;\\n    return head;\\n    }\\n}\\n```\\n***Pls upvote the solution if you find it helpful.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int len=0;\\n        ListNode temp=head;\\n        // Find the length/size of list.\\n        while(temp!=null)\\n        {\\n            len++;\\n            temp=temp.next;\\n        }\\n        System.out.println(len);\\n        if(len==1) return null;\\n        if(len-n==0) return head.next;\\n      \\n        int count=1;\\n        temp=head;\\n\\t\\t//Reach to the node before the one you want to delete.\\n        //If len is 5, 2nd element from last means 3rd element from start.\\n        while(count!=len-n)\\n        {\\n            temp=temp.next;\\n            count++;\\n        }\\n        System.out.println(temp.val);\\n        temp.next=temp.next.next;\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127566,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Kotlin ***\\n\\n```\\n\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n      fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\\n    if (head == null) return null\\n    \\n    var nodeCount = 0\\n    var current = head\\n    \\n    while (current != null) {\\n      nodeCount++\\n      current = current.next\\n    }\\n    \\n    if (nodeCount == n) return head.next\\n    \\n    var prev: ListNode? = null\\n    current = head\\n    val dummy = ListNode(-1)\\n    dummy.next = current\\n    \\n    var step = nodeCount - n\\n    while (step-- > 0) {\\n      prev = current\\n      current = current?.next\\n    }\\n    \\n    prev?.next = current?.next\\n    \\n    return dummy.next\\n  }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n      fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {\\n    if (head == null) return null\\n    \\n    var nodeCount = 0\\n    var current = head\\n    \\n    while (current != null) {\\n      nodeCount++\\n      current = current.next\\n    }\\n    \\n    if (nodeCount == n) return head.next\\n    \\n    var prev: ListNode? = null\\n    current = head\\n    val dummy = ListNode(-1)\\n    dummy.next = current\\n    \\n    var step = nodeCount - n\\n    while (step-- > 0) {\\n      prev = current\\n      current = current?.next\\n    }\\n    \\n    prev?.next = current?.next\\n    \\n    return dummy.next\\n  }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087843,
                "title": "c-solution-in-two-pass-and-one-pass",
                "content": "**Code in two pass**\\n```\\nint lenList(struct ListNode* head){\\n    struct ListNode* ptr = head;\\n    int l = 0;\\n    while(ptr != NULL) {\\n        l++;\\n        ptr = ptr->next;\\n    }\\n    return l;\\n}\\n\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    if(!head || !head->next) return NULL;\\n\\n    int len = lenList(head);\\n    if(len == n) {\\n        head = head->next;\\n        return head;\\n    }\\n    struct ListNode* ptr = head;\\n    int count = len - n;\\n    while(count > 1) {\\n        ptr = ptr->next;\\n        count--;\\n    }\\n    struct ListNode* q = ptr->next;\\n    ptr->next = ptr->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\\n\\n**Code in one pass**\\n```\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    \\n    for(int i=0; i<n; i++) fast = fast->next;\\n    if(!fast) return head->next;\\n    \\n    while(fast->next){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n    \\n    struct ListNode* q = slow->next;\\n    slow->next = slow->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\\n\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint lenList(struct ListNode* head){\\n    struct ListNode* ptr = head;\\n    int l = 0;\\n    while(ptr != NULL) {\\n        l++;\\n        ptr = ptr->next;\\n    }\\n    return l;\\n}\\n\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    if(!head || !head->next) return NULL;\\n\\n    int len = lenList(head);\\n    if(len == n) {\\n        head = head->next;\\n        return head;\\n    }\\n    struct ListNode* ptr = head;\\n    int count = len - n;\\n    while(count > 1) {\\n        ptr = ptr->next;\\n        count--;\\n    }\\n    struct ListNode* q = ptr->next;\\n    ptr->next = ptr->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```\n```\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    struct ListNode* fast = head;\\n    struct ListNode* slow = head;\\n    \\n    for(int i=0; i<n; i++) fast = fast->next;\\n    if(!fast) return head->next;\\n    \\n    while(fast->next){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n    \\n    struct ListNode* q = slow->next;\\n    slow->next = slow->next->next;\\n    free(q);\\n    \\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989690,
                "title": "javascript-solution",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let tempList = new ListNode(0);\\n    tempList.next = head;\\n\\t\\n    // set variables for next node and current node\\n    let slow = tempList;\\n    let fast = tempList;\\n\\t\\n    // set fast to n nodes ahead of slow\\n    for (let i = 0; i <= n; i++) {\\n        fast = fast.next;\\n    }\\n\\t\\n    // While we haven\\'t reached the end of the list\\n    // set slow to n nodes behind fast\\n    while (fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\t\\n    // set slow.next to two nodes ahead of slow\\n    // then return the nth node of the list\\n    slow.next = slow.next.next;\\n    return tempList.next;\\n}\\n```\\n\\nTime complexity is 0(n)\\nSpace complexity 0(1)\\n\\nRuntime: 60 ms, faster than 95.08% of JavaScript online submissions for Remove Nth Node From End of List.\\nMemory Usage: 42.7 MB, less than 72.68% of JavaScript online submissions for Remove Nth Node From End of List.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    let tempList = new ListNode(0);\\n    tempList.next = head;\\n\\t\\n    // set variables for next node and current node\\n    let slow = tempList;\\n    let fast = tempList;\\n\\t\\n    // set fast to n nodes ahead of slow\\n    for (let i = 0; i <= n; i++) {\\n        fast = fast.next;\\n    }\\n\\t\\n    // While we haven\\'t reached the end of the list\\n    // set slow to n nodes behind fast\\n    while (fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n\\t\\n    // set slow.next to two nodes ahead of slow\\n    // then return the nth node of the list\\n    slow.next = slow.next.next;\\n    return tempList.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725772,
                "title": "two-pointer-approach",
                "content": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode result = head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t //moving fast pointer to n+starting position\\n       while(n-- > 0){\\n           \\n           fast = fast.next;\\n       }\\n\\t   \\n\\t   \\n        if(fast == null){\\n            return result.next;\\n        }\\n       \\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        System.out.println(\"deleting value\"+ slow.next.val);\\n       \\n        slow.next = slow.next.next;\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode result = head;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t //moving fast pointer to n+starting position\\n       while(n-- > 0){\\n           \\n           fast = fast.next;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1699955,
                "title": "easy-and-clean-optimized-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* fast = head , *slow = head;\\n        for(int i = 0 ; i < n ; i++) fast = fast->next;\\n        if(!fast) return head->next;\\n        while(fast->next){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* fast = head , *slow = head;\\n        for(int i = 0 ; i < n ; i++) fast = fast->next;\\n        if(!fast) return head->next;\\n        while(fast->next){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645734,
                "title": "slow-and-fast-pointer-java-code",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        \\n        // move fast pointer n time\\n        for(int i = 1; i <=n; ++i)\\n            fast = fast.next;\\n        \\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        \\n        // move fast pointer n time\\n        for(int i = 1; i <=n; ++i)\\n            fast = fast.next;\\n        \\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431330,
                "title": "java-o-n-one-pass-solution",
                "content": "This is a great problem to grasp the concept of linked lists, and uses a technique that occurs in other linked list problems.\\n\\n**Two-Pass Solution**\\nThe obvious approach to this problem is to use 2 passes through the linked list, the first pass for counting the number of nodes, and the second pass to find the node to remove and remove it. \\n```\\n//Sorry if my code is a little long, just trying to be as descriptive as possible\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n        int count = 0;\\n        while(cur != null){\\n            count++;\\n            cur = cur.next;\\n        }\\n        \\n        if(n == count){\\n            return head.next;\\n        }\\n        \\n        cur = head;\\n        ListNode pred = null;\\n        for(int i = 0; i < count - n; i++){\\n            pred = cur;\\n            cur = cur.next;\\n        }\\n       \\n        pred.next = cur.next;\\n        return head;\\n    }\\n}\\n```\\nThis code is not \"bad\" by any means, 2 passes still means ```O(n)``` time, and a constant number of new variables means ```O(1)``` space, but can we use the fact that we are looking to remove the ```n```th node from the end to create a one-pass solution?\\n\\n**One-Pass Solution**\\nA common way of doing one-pass solutions for linked list search/remove/insert problems is to use some variation of the slow-fast pointer technique. In this question, we can start by initializing a pointer ```fast``` at the head of the linked list given. Then we can move this pointer ```n``` nodes further. Then we can intialize a pointer ```slow``` to ```head```, and ```prev``` to ```null``` (this pointer being the one trailing ```slow```). We can move ```fast```, ```slow```, and ```prev``` simultaneously, and once ```fast``` becomes ```null``` (passes the end of the list), ```slow``` will be pointing to the ```n```th node from the end, which can now be removed. \\n\\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        for(int i = 0; i < n; i++){\\n            fast = fast.next;\\n        }\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast != null){\\n            fast = fast.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        if(prev == null){\\n            return head.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\\nThis solution is also done in ```O(n)``` time, and ```O(1)``` space, but the difference being that it is done in one pass. \\n\\nHope this helps!!",
                "solutionTags": [],
                "code": "```\\n//Sorry if my code is a little long, just trying to be as descriptive as possible\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode cur = head;\\n        int count = 0;\\n        while(cur != null){\\n            count++;\\n            cur = cur.next;\\n        }\\n        \\n        if(n == count){\\n            return head.next;\\n        }\\n        \\n        cur = head;\\n        ListNode pred = null;\\n        for(int i = 0; i < count - n; i++){\\n            pred = cur;\\n            cur = cur.next;\\n        }\\n       \\n        pred.next = cur.next;\\n        return head;\\n    }\\n}\\n```\n```O(n)```\n```O(1)```\n```n```\n```fast```\n```n```\n```slow```\n```head```\n```prev```\n```null```\n```slow```\n```fast```\n```slow```\n```prev```\n```fast```\n```null```\n```slow```\n```n```\n```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fast = head;\\n        for(int i = 0; i < n; i++){\\n            fast = fast.next;\\n        }\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast != null){\\n            fast = fast.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        if(prev == null){\\n            return head.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1416454,
                "title": "2-pointer-approach-with-comments-typescript",
                "content": "```ts\\n// N: number of nodes\\n// Time: O(N)\\n// Space: O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    const dummyHead = new ListNode(0, head);\\n    let slow = dummyHead;\\n    let fast = dummyHead;\\n    \\n    // Move fast n nodes ahead of slow\\n    for (let i = 0; i < n; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // When fast reaches 1st node from the end, slow will be n+1th node from the end\\n    while (fast.next) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    \\n    // Skip over the nth node from the end\\n    slow.next = slow.next.next;\\n    \\n    return dummyHead.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```ts\\n// N: number of nodes\\n// Time: O(N)\\n// Space: O(1)\\n\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    const dummyHead = new ListNode(0, head);\\n    let slow = dummyHead;\\n    let fast = dummyHead;\\n    \\n    // Move fast n nodes ahead of slow\\n    for (let i = 0; i < n; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // When fast reaches 1st node from the end, slow will be n+1th node from the end\\n    while (fast.next) {\\n        fast = fast.next;\\n        slow = slow.next;\\n    }\\n    \\n    // Skip over the nth node from the end\\n    slow.next = slow.next.next;\\n    \\n    return dummyHead.next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366565,
                "title": "c-simple-one-pass-o-n-time-o-1-space",
                "content": "curr refers to the first node and nPlusOneNodesFromCurris n plus nodes\\nfar from the curr node so if it becomes null we need to delete the next value\\nof curr\\n\\nEDGE CASES\\n\\ndeleting the first node and second node\\nif its first node nPlusOneNodesFromCurr will be NULL when n=1\\nand if its second node n will be 0 and nPlusOneNodesFromCurr will be NULL\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *curr=head,*nPlusOneNodesFromCurr=head;\\n        n++;\\n        while(nPlusOneNodesFromCurr!=NULL&&n--){\\n            nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;\\n        }\\n        if(nPlusOneNodesFromCurr==NULL&&n==1)\\n         return head->next;\\n     \\n        while(nPlusOneNodesFromCurr!=NULL){\\n            curr=curr->next;\\n           nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;     \\n        }\\n        curr->next=curr->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *curr=head,*nPlusOneNodesFromCurr=head;\\n        n++;\\n        while(nPlusOneNodesFromCurr!=NULL&&n--){\\n            nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;\\n        }\\n        if(nPlusOneNodesFromCurr==NULL&&n==1)\\n         return head->next;\\n     \\n        while(nPlusOneNodesFromCurr!=NULL){\\n            curr=curr->next;\\n           nPlusOneNodesFromCurr=nPlusOneNodesFromCurr->next;     \\n        }\\n        curr->next=curr->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354890,
                "title": "c-brute-to-optimal-easy",
                "content": "**1. Brute Force**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        //if only one element \\n        if(!head->next){\\n            return nullptr;\\n        }\\n        //if two element\\n        if(!head->next->next){\\n            if(n==1){\\n                head->next=nullptr;\\n                return head;\\n            }\\n            else{\\n                return head->next;\\n            }\\n        }\\n        //more than two element\\n        int ctr=0, length=0;\\n        ListNode *temp=head;\\n        ListNode *ptr =head;\\n        \\n        //checking length\\n        while(ptr){\\n            ptr = ptr->next;\\n            length++;\\n        }\\n        \\n        //1st edge case if first element removed\\n        if(n==length){\\n            return head->next;\\n        }\\n        //removing length-n element\\n        while(temp){\\n            //if element found is n-1th from end\\n            if(ctr==length-n-1){\\n      \\n                if(temp->next->next!=nullptr){\\n                    temp->next=temp->next->next;\\n                }\\n                //2nd edge case if last element removed\\n                else{\\n                    temp->next = nullptr;\\n                }\\n            }\\n            temp = temp->next;\\n            ctr++;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n**2. Two Pointer**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode(0);\\n        start->next = head;\\n        ListNode* fast=start;\\n        ListNode* slow=start;\\n        \\n        for(int i=1; i<=n; ++i){\\n            fast = fast->next;\\n        }\\n            \\n            while(fast->next!=NULL){\\n                fast = fast->next;\\n                slow = slow->next;\\n            }\\n            slow->next = slow->next->next;\\n        return start->next;\\n       \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        //if only one element \\n        if(!head->next){\\n            return nullptr;\\n        }\\n        //if two element\\n        if(!head->next->next){\\n            if(n==1){\\n                head->next=nullptr;\\n                return head;\\n            }\\n            else{\\n                return head->next;\\n            }\\n        }\\n        //more than two element\\n        int ctr=0, length=0;\\n        ListNode *temp=head;\\n        ListNode *ptr =head;\\n        \\n        //checking length\\n        while(ptr){\\n            ptr = ptr->next;\\n            length++;\\n        }\\n        \\n        //1st edge case if first element removed\\n        if(n==length){\\n            return head->next;\\n        }\\n        //removing length-n element\\n        while(temp){\\n            //if element found is n-1th from end\\n            if(ctr==length-n-1){\\n      \\n                if(temp->next->next!=nullptr){\\n                    temp->next=temp->next->next;\\n                }\\n                //2nd edge case if last element removed\\n                else{\\n                    temp->next = nullptr;\\n                }\\n            }\\n            temp = temp->next;\\n            ctr++;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode(0);\\n        start->next = head;\\n        ListNode* fast=start;\\n        ListNode* slow=start;\\n        \\n        for(int i=1; i<=n; ++i){\\n            fast = fast->next;\\n        }\\n            \\n            while(fast->next!=NULL){\\n                fast = fast->next;\\n                slow = slow->next;\\n            }\\n            slow->next = slow->next->next;\\n        return start->next;\\n       \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256656,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        ListNode* p1 = head;\\n        ListNode* p2;\\n        ListNode* prevP2 = NULL;\\n        \\n        while(n){\\n            p1 = p1->next;\\n            n--;\\n        }\\n        \\n        p2 = head;\\n        while(p1){\\n            prevP2 = p2;\\n            p2 = p2->next;\\n            p1 = p1->next;\\n        }\\n        \\n        //Trying to delete the head\\n        if(!prevP2) return p2->next;\\n        else{\\n            prevP2->next = p2->next;\\n            return head;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        \\n        ListNode* p1 = head;\\n        ListNode* p2;\\n        ListNode* prevP2 = NULL;\\n        \\n        while(n){\\n            p1 = p1->next;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164484,
                "title": "c-super-simple-short-one-pass-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (!head) \\n            return NULL;\\n        \\n        ListNode* dummy_head = new ListNode();\\n        dummy_head->next = head;\\n        ListNode *fast = dummy_head, *slow = dummy_head;\\n        \\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n        \\n        while (fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;        \\n        }\\n        \\n        ListNode *to_delete = slow->next;\\n        slow->next = slow->next->next;\\n        delete to_delete;\\n        \\n        return dummy_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if (!head) \\n            return NULL;\\n        \\n        ListNode* dummy_head = new ListNode();\\n        dummy_head->next = head;\\n        ListNode *fast = dummy_head, *slow = dummy_head;\\n        \\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n        \\n        while (fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;        \\n        }\\n        \\n        ListNode *to_delete = slow->next;\\n        slow->next = slow->next->next;\\n        delete to_delete;\\n        \\n        return dummy_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961866,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast=slow=head\\n        for i in range(n):\\n            fast=fast.next\\n        if not fast:return head.next\\n        while fast.next:\\n            slow=slow.next\\n            fast=fast.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        fast=slow=head\\n        for i in range(n):\\n            fast=fast.next\\n        if not fast:return head.next\\n        while fast.next:\\n            slow=slow.next\\n            fast=fast.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503293,
                "title": "javascript-detailed-explanation",
                "content": "```\\nvar removeNthFromEnd = function(head, n) {\\n    // create a newlistnode which we will use to store our answer\\n    let dummy = new ListNode(-1);\\n    // keep a reference to head, which we will return\\n    dummy.next = head;\\n    \\n    // we\\'re starting these are our dummy value (-1)\\n    let slow = dummy;\\n    let fast = dummy;\\n    \\n    // get one ahead of N # of nodes, so given n =2, then 1->2->3->4->5 we\\'d be at 3\\n    // effectively creating a distance of size N from the fast pointer (3) and the slow (1)\\n    for(let i = 1; i <= n + 1; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // slow is at head still, fast is ahead of slow at a distance of N\\n    // we move slow and fast one at a time, when fast is at the end of the list (null)\\n    // slow will be at distance N-1 from the end of the list\\n    while(fast !== null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    // slow is now one before N, lets skip it\\n    slow.next = slow.next.next;\\n    \\n    // dummy contains our initial value (-1->1->2->3->4->5)\\n    // we don\\'t need the dummy value (-1)\\n    // so return the next value (1->2->3->4->5)\\n    return dummy.next;\\n};\\n\\n\\n// this is algo looks manually stepping through it. Given: 1->2->3->4->5, n = 2\\n// move fast to N + 1\\n// fast     i    n+1 (end point)\\n//  1       1    3\\n//  2       2    3\\n//  3       3    3\\n// fast: 3, slow : -1, distance between fast slow: 2 (which will always be n)\\n\\n// loop until fast !== null\\n// slow    fast    distance between (not difference)\\n//  1       4             2\\n//  2       5             2\\n//  3       null(eol)     2\\n\\n// so now our slow pointer is one before the node we need to skip (n)\\n// so lets skip it, slow.next is the value we need to skip (4), so\\n// slow.next -> slow.next.next(5)\\n// 1->2->3->5```",
                "solutionTags": [],
                "code": "```\\nvar removeNthFromEnd = function(head, n) {\\n    // create a newlistnode which we will use to store our answer\\n    let dummy = new ListNode(-1);\\n    // keep a reference to head, which we will return\\n    dummy.next = head;\\n    \\n    // we\\'re starting these are our dummy value (-1)\\n    let slow = dummy;\\n    let fast = dummy;\\n    \\n    // get one ahead of N # of nodes, so given n =2, then 1->2->3->4->5 we\\'d be at 3\\n    // effectively creating a distance of size N from the fast pointer (3) and the slow (1)\\n    for(let i = 1; i <= n + 1; i++) {\\n        fast = fast.next;\\n    }\\n    \\n    // slow is at head still, fast is ahead of slow at a distance of N\\n    // we move slow and fast one at a time, when fast is at the end of the list (null)\\n    // slow will be at distance N-1 from the end of the list\\n    while(fast !== null) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    // slow is now one before N, lets skip it\\n    slow.next = slow.next.next;\\n    \\n    // dummy contains our initial value (-1->1->2->3->4->5)\\n    // we don\\'t need the dummy value (-1)\\n    // so return the next value (1->2->3->4->5)\\n    return dummy.next;\\n};\\n\\n\\n// this is algo looks manually stepping through it. Given: 1->2->3->4->5, n = 2\\n// move fast to N + 1\\n// fast     i    n+1 (end point)\\n//  1       1    3\\n//  2       2    3\\n//  3       3    3\\n// fast: 3, slow : -1, distance between fast slow: 2 (which will always be n)\\n\\n// loop until fast !== null\\n// slow    fast    distance between (not difference)\\n//  1       4             2\\n//  2       5             2\\n//  3       null(eol)     2\\n\\n// so now our slow pointer is one before the node we need to skip (n)\\n// so lets skip it, slow.next is the value we need to skip (4), so\\n// slow.next -> slow.next.next(5)\\n// 1->2->3->5```",
                "codeTag": "Unknown"
            },
            {
                "id": 368217,
                "title": "remove-nth-node-from-end-of-list",
                "content": "Given a linked list, remove the n-th node from the end of list and return its head.\\n\\nExample:\\n\\nGiven linked list: 1->2->3->4->5, and n = 2.\\n\\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\\n\\n```\\n\\t# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        p = head\\n        i = 0\\n        while p:\\n            p = p.next\\n            i += 1\\n        p = head\\n        step = i-n#total length - n\\n        if step == 0:\\n            head = head.next\\n        else:\\n            l = 1\\n            while l<step :\\n                p = p.next\\n                l += 1\\n            p.next = p.next.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\t# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        p = head\\n        i = 0\\n        while p:\\n            p = p.next\\n            i += 1\\n        p = head\\n        step = i-n#total length - n\\n        if step == 0:\\n            head = head.next\\n        else:\\n            l = 1\\n            while l<step :\\n                p = p.next\\n                l += 1\\n            p.next = p.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287711,
                "title": "solution-in-python",
                "content": "Runtime: 40 ms, faster than 93.06% of Python3 online submissions for Remove Nth Node From End of List.\\nMemory Usage: 13.2 MB, less than 5.60% of Python3 online submissions for Remove Nth Node From End of List.\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        if head.next == None:\\n            return None\\n        tmp = head\\n        size = 0\\n        \\n        # find the size of the linked list\\n        while tmp:\\n            size += 1\\n            tmp = tmp.next\\n        tmp = head\\n        \\n        #if we have to remove the first node:\\n        if n == size: \\n            return head.next\\n        \\n        for i in range(size-n-1):\\n            tmp = tmp.next\\n        tmp.next = tmp.next.next\\n        return head",
                "solutionTags": [],
                "code": "Runtime: 40 ms, faster than 93.06% of Python3 online submissions for Remove Nth Node From End of List.\\nMemory Usage: 13.2 MB, less than 5.60% of Python3 online submissions for Remove Nth Node From End of List.\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\\n        if head.next == None:\\n            return None\\n        tmp = head\\n        size = 0\\n        \\n        # find the size of the linked list\\n        while tmp:\\n            size += 1\\n            tmp = tmp.next\\n        tmp = head\\n        \\n        #if we have to remove the first node:\\n        if n == size: \\n            return head.next\\n        \\n        for i in range(size-n-1):\\n            tmp = tmp.next\\n        tmp.next = tmp.next.next\\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 209699,
                "title": "javascript-o-n-time-o-1-space-with-comments",
                "content": "```javascript\\n/**\\n * Time: O(n)\\n * Space: O(1)\\n * n - # of nodes\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nfunction removeNthFromEnd(head, n) {\\n  const dummy = new ListNode(); // use dummy to handle removing head\\n  dummy.next = head;\\n  let fast = dummy;\\n  let slow = dummy;\\n\\n  // Move fast n + 1 nodes ahead of slow\\n  for (let i = 0; i < n + 1; i++) {\\n    fast = fast.next;\\n  }\\n\\n  // Move fast to end, slow will be (n + 1)th from last node, just before the node to remove\\n  while (fast) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n\\n  // Remove the nth from last node\\n  slow.next = slow.next.next;\\n  return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n)\\n * Space: O(1)\\n * n - # of nodes\\n */\\n\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nfunction removeNthFromEnd(head, n) {\\n  const dummy = new ListNode(); // use dummy to handle removing head\\n  dummy.next = head;\\n  let fast = dummy;\\n  let slow = dummy;\\n\\n  // Move fast n + 1 nodes ahead of slow\\n  for (let i = 0; i < n + 1; i++) {\\n    fast = fast.next;\\n  }\\n\\n  // Move fast to end, slow will be (n + 1)th from last node, just before the node to remove\\n  while (fast) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n\\n  // Remove the nth from last node\\n  slow.next = slow.next.next;\\n  return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167577,
                "title": "java-two-pointers-with-explanations",
                "content": "**Logical Thought**\\nThe loop invariant is that two pointers `s, e` such that `s is always n nodes distance in front of e`. In this way, `s` is always the preceding node of the node to remove.When e is the `tail` node of the List (i.e. when `e.next = null`), we simply remove s.next (`s.next = s.next.next`). For example,\\n```\\nGiven 1 - 2 - 3 - 4 - 5 - N, n = 2,\\ns is always 2 nodes distance in front of e\\nD - 1 - 2 - 3 - 4 - 5 - N\\n            s\\n                    e\\n3 is the node to remove.\\n```\\n**Code**\\n```\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        if (head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode dummyHead = new ListNode(0), s = dummyHead, e = s;\\n        dummyHead.next = head;\\n\\n        for (int i = 0; i < n; i++) {\\n            e = e.next;\\n        }\\n        while (e.next != null) {\\n            e = e.next;\\n            s = s.next;\\n        }\\n        s.next = s.next.next;\\n\\n        return dummyHead.next;\\n    }\\n```\\n**Trick**\\nTo remove a node in List, we need to figure out its preceding node. Since we may remove the List\\'s head, which does not have a preceding node, we establish a `dummyHead` for simplicity (`dummyHead.next = head`).\\n\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\nGiven 1 - 2 - 3 - 4 - 5 - N, n = 2,\\ns is always 2 nodes distance in front of e\\nD - 1 - 2 - 3 - 4 - 5 - N\\n            s\\n                    e\\n3 is the node to remove.\\n```\n```\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n\\n        if (head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode dummyHead = new ListNode(0), s = dummyHead, e = s;\\n        dummyHead.next = head;\\n\\n        for (int i = 0; i < n; i++) {\\n            e = e.next;\\n        }\\n        while (e.next != null) {\\n            e = e.next;\\n            s = s.next;\\n        }\\n        s.next = s.next.next;\\n\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8816,
                "title": "minimal-recursive-java-solution-12ms",
                "content": "```\\n\\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n\\t\\tif(head==null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n        int depth=removeHelper(head,n);\\n        head=depth>n?head:head.next;\\n        return head;\\n \\n    }\\n\\t public static int removeHelper(ListNode head,int n){\\n\\t\\tif(head.next==null){\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint cur=1+removeHelper(head.next, n);\\n\\t\\tif(cur==n+1){\\n\\t\\t\\thead.next=head.next==null?null:head.next.next;\\n\\t\\t}\\n\\t\\treturn cur;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic static ListNode removeNthFromEnd(ListNode head, int n) {\\n\\t\\tif(head==null){\\n\\t\\t\\treturn null;\\n\\t\\t}\\n        int depth=removeHelper(head,n);\\n        head=depth>n?head:head.next;\\n        return head;\\n \\n    }\\n\\t public static int removeHelper(ListNode head,int n){\\n\\t\\tif(head.next==null){\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint cur=1+removeHelper(head.next, n);\\n\\t\\tif(cur==n+1){\\n\\t\\t\\thead.next=head.next==null?null:head.next.next;\\n\\t\\t}\\n\\t\\treturn cur;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8910,
                "title": "o-n-time-o-1-space-ruby-solution-single-pass",
                "content": "``` ruby\\ndef remove_nth_from_end(head, n)\\n    return nil unless head.next\\n    count = 0\\n    h, p = head, head\\n    while h\\n        p = p.next if count > n\\n        h = h.next\\n        count += 1\\n    end\\n    return head.next if count == n\\n    p.next = p.next.next\\n    head\\nend\\n```",
                "solutionTags": [],
                "code": "``` ruby\\ndef remove_nth_from_end(head, n)\\n    return nil unless head.next\\n    count = 0\\n    h, p = head, head\\n    while h\\n        p = p.next if count > n\\n        h = h.next\\n        count += 1\\n    end\\n    return head.next if count == n\\n    p.next = p.next.next\\n    head\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 8984,
                "title": "one-pass-javascript-solution",
                "content": "    var removeNthFromEnd = function(head, n) {\\n      var left, before, right = head;\\n      left = before = {next: head}; \\n      while (n--) right = right.next;\\n      while (right) {\\n        right = right.next;\\n        left = left.next;\\n      }\\n      left.next = left.next.next;\\n      return before.next;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeNthFromEnd = function(head, n) {\\n      var left, before, right = head;\\n      left = before = {next: head}; \\n      while (n--) right = right.next;\\n      while (right) {\\n        right = right.next;\\n        left = left.next;\\n      }\\n      left.next = left.next.next;\\n      return before.next;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4086979,
                "title": "accepted-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    if(head == null) return head;\\n    int k = 0;\\n    ListNode curr = head;\\n    for(; curr != null; curr = curr.next) k++;\\n    k -= n; //to get position of given element from first node\\n    if(k == 0) return head.next;\\n    for(curr = head; k > 1; k--, curr = curr.next) ;\\n    curr.next = curr.next.next; // to remove that node\\n    return head;\\n    }\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```JAVA []\\nclass Solution {\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n    if(head == null) return head;\\n    int k = 0;\\n    ListNode curr = head;\\n    for(; curr != null; curr = curr.next) k++;\\n    k -= n; //to get position of given element from first node\\n    if(k == 0) return head.next;\\n    for(curr = head; k > 1; k--, curr = curr.next) ;\\n    curr.next = curr.next.next; // to remove that node\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799083,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode();\\n        start->next = head;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        for(int i = 0; i < n; ++i) {\\n            fast = fast->next;\\n        }\\n        while(fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* start = new ListNode();\\n        start->next = head;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        for(int i = 0; i < n; ++i) {\\n            fast = fast->next;\\n        }\\n        while(fast->next) {\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725716,
                "title": "easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp = head;\\n<!-- Iterate till end to find length of list -->\\n        int cnt = 0;\\n        while (temp) {\\n            temp = temp->next;\\n            cnt++;\\n        }\\n<!-- If single node then return head->next i.e NULL -->\\n        cnt = cnt - n;\\n        if (cnt == 0) {\\n            return head->next;\\n        }\\n<!-- mark the length till which you have to iterate -->\\n        temp = head;\\n        while (cnt - 1) {\\n            temp = temp->next;\\n            cnt--;\\n        }\\n<!-- After iterating till just previous node of node which is to be removed, mark the next of node by skipping the node in between -->\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* temp = head;\\n<!-- Iterate till end to find length of list -->\\n        int cnt = 0;\\n        while (temp) {\\n            temp = temp->next;\\n            cnt++;\\n        }\\n<!-- If single node then return head->next i.e NULL -->\\n        cnt = cnt - n;\\n        if (cnt == 0) {\\n            return head->next;\\n        }\\n<!-- mark the length till which you have to iterate -->\\n        temp = head;\\n        while (cnt - 1) {\\n            temp = temp->next;\\n            cnt--;\\n        }\\n<!-- After iterating till just previous node of node which is to be removed, mark the next of node by skipping the node in between -->\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370715,
                "title": "typescript-2-pointers-smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    let fastP: ListNode = head\\n    let slowP: ListNode = head\\n    for (let i = 0; i < n; i++) {\\n        fastP = fastP.next;\\n    }\\n    if (!fastP) return head.next;\\n\\n    while (fastP.next) {\\n        fastP = fastP.next\\n        slowP = slowP.next;\\n    }\\n    slowP.next = slowP.next.next;\\n\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\\n    let fastP: ListNode = head\\n    let slowP: ListNode = head\\n    for (let i = 0; i < n; i++) {\\n        fastP = fastP.next;\\n    }\\n    if (!fastP) return head.next;\\n\\n    while (fastP.next) {\\n        fastP = fastP.next\\n        slowP = slowP.next;\\n    }\\n    slowP.next = slowP.next.next;\\n\\n    return head\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254467,
                "title": "c-easy-solution-using-length-of-linkedlist",
                "content": "# Intuition\\nWe can traverse the linked list and find the length of the list. Then, we can traverse the list again to reach the nth node from the end and remove it. To remove the node, we need to modify the \\'next\\' pointer of its previous node to point to its next node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a helper function \\'getlength()\\' that takes the head of the linked list as input and returns its length.\\n2. Compute the length of the linked list using the \\'getlength()\\' function.\\n3. Traverse the linked list again until the node n nodes from the end is reached.\\n4. Modify the next pointer of the previous node to point to the next node of the node to be removed.\\n5. Delete the node to be removed.\\n6. Return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the length of the linked list. We traverse the linked list twice.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), We only use constant extra space to store the pointers.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getlength(ListNode* head){\\n        ListNode* curr = head;\\n        int length = 0;\\n        while(curr!=NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        if (head == nullptr) {\\n            return nullptr;\\n        }\\n\\n       int length = getlength(head);\\n       ListNode* node = NULL;\\n       if(length<=1) return node;\\n\\n       ListNode* curr = head;\\n       ListNode* prev = NULL;\\n\\n       int position = length - n;\\n       int count = 1;\\n\\n       if(length==n){\\n            head = head->next;\\n           curr->next = NULL;\\n           delete curr;\\n           return head;\\n       }\\n\\n       while(count<=position){\\n           prev = curr;\\n           curr = curr->next;\\n           count++;\\n       }\\n\\n        if(curr==NULL){\\n           prev->next = NULL;\\n       }\\n        else{\\n        prev->next = curr->next;\\n        curr->next = NULL;\\n        delete curr;\\n        }     \\n\\n        return head;\\n               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int getlength(ListNode* head){\\n        ListNode* curr = head;\\n        int length = 0;\\n        while(curr!=NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        return length;\\n    }\\n\\n\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        if (head == nullptr) {\\n            return nullptr;\\n        }\\n\\n       int length = getlength(head);\\n       ListNode* node = NULL;\\n       if(length<=1) return node;\\n\\n       ListNode* curr = head;\\n       ListNode* prev = NULL;\\n\\n       int position = length - n;\\n       int count = 1;\\n\\n       if(length==n){\\n            head = head->next;\\n           curr->next = NULL;\\n           delete curr;\\n           return head;\\n       }\\n\\n       while(count<=position){\\n           prev = curr;\\n           curr = curr->next;\\n           count++;\\n       }\\n\\n        if(curr==NULL){\\n           prev->next = NULL;\\n       }\\n        else{\\n        prev->next = curr->next;\\n        curr->next = NULL;\\n        delete curr;\\n        }     \\n\\n        return head;\\n               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245946,
                "title": "0ms-beats-100-one-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n){\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n        ListNode fast=ans;\\n        ListNode slow=ans;\\n\\n        for(int i=1;i<=n;i++){\\n            fast=fast.next;\\n        }\\n\\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n){\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n        ListNode fast=ans;\\n        ListNode slow=ans;\\n\\n        for(int i=1;i<=n;i++){\\n            fast=fast.next;\\n        }\\n\\n        while(fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041441,
                "title": "0ms-100-beats-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int size=findSize(head);\\n        ListNode ans= new ListNode();\\n        ListNode prev=ans;\\n        ListNode cur=head;\\n        for(int i=0;i<size-n;i++){\\n            prev.next=cur;\\n            cur=cur.next;\\n            prev=prev.next;\\n        } \\n        prev.next=cur.next;\\n        return ans.next;\\n    }\\n    public int findSize(ListNode head){\\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        int size=findSize(head);\\n        ListNode ans= new ListNode();\\n        ListNode prev=ans;\\n        ListNode cur=head;\\n        for(int i=0;i<size-n;i++){\\n            prev.next=cur;\\n            cur=cur.next;\\n            prev=prev.next;\\n        } \\n        prev.next=cur.next;\\n        return ans.next;\\n    }\\n    public int findSize(ListNode head){\\n        ListNode temp=head;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016097,
                "title": "single-pass-recursive-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursion to accumulate new list with a single pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use a recursive helper function that returns a tuple containing the accumulated result ListNode along with a count of nodes that begins from the end of the list. At each recursive step, I first call the recursive helper function, then check if the current node is the nth node from the end of the list. If it is, then I do not accumulate the current node value, if it isn\\'t then I add the current node value and continue. \\n\\n[Quick Video Explanation with Diagram](https://youtu.be/p3CPh_hjcpk)\\nhttps://youtu.be/p3CPh_hjcpk\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def recursiveHelper(self, head: Optional[ListNode], n: int) -> (Optional[ListNode], int):\\n        if (head == None):\\n            return (None, 0)\\n        else:\\n            (chain, location) = self.recursiveHelper(head.next, n)\\n            location += 1\\n            if (location == n):\\n                return (chain, location)\\n            else:\\n                return (ListNode(head.val, chain), location)\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        (head, location) = self.recursiveHelper(head, n)\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def recursiveHelper(self, head: Optional[ListNode], n: int) -> (Optional[ListNode], int):\\n        if (head == None):\\n            return (None, 0)\\n        else:\\n            (chain, location) = self.recursiveHelper(head.next, n)\\n            location += 1\\n            if (location == n):\\n                return (chain, location)\\n            else:\\n                return (ListNode(head.val, chain), location)\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        (head, location) = self.recursiveHelper(head, n)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833601,
                "title": "concise-java-solution-faster-than-100-with-explanation",
                "content": "**Explanation**: First, I get the length of the list by looping through it. Then I calculate the node to be removed as `listLength - n`. A standard algorithm to  remove the node is then implemented. Below is the full code.\\n\\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fakeHead = head;\\n        int listLength = 1;\\n        while(fakeHead.next != null) {\\n            listLength++;\\n            fakeHead = fakeHead.next;\\n        }\\n        if(n == listLength) {\\n            head = head.next;\\n            return head;\\n        }\\n        int nodeToRemove = listLength - n;\\n        fakeHead = head;\\n        for(int i=0; fakeHead.next!=null && i<nodeToRemove-1; i++){\\n            fakeHead = fakeHead.next;\\n        }\\n        fakeHead.next = fakeHead.next.next;\\n        return head;\\n    }\\n```\\n\\nIf this solution helped you, an upvote would be greatly appreciated :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fakeHead = head;\\n        int listLength = 1;\\n        while(fakeHead.next != null) {\\n            listLength++;\\n            fakeHead = fakeHead.next;\\n        }\\n        if(n == listLength) {\\n            head = head.next;\\n            return head;\\n        }\\n        int nodeToRemove = listLength - n;\\n        fakeHead = head;\\n        for(int i=0; fakeHead.next!=null && i<nodeToRemove-1; i++){\\n            fakeHead = fakeHead.next;\\n        }\\n        fakeHead.next = fakeHead.next.next;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634465,
                "title": "javascript-solution-88-36-percent-faster",
                "content": "``` \\nvar removeNthFromEnd = function(head, n) {\\n    var node = new ListNode()\\n    var rep = node\\n    var hash = []\\n    while(head!==null){\\n        hash.push(head.val)\\n        head = head.next\\n    }\\n    var count = hash.length-n\\n    let i = 0\\n    while(i<hash.length){\\n        if(count!==0){\\n            node.next = new ListNode(hash[i])\\n            count--\\n            node = node.next\\n        }else{\\n            count+=n-1 \\n        }\\n        i++\\n    }\\n    return rep.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar removeNthFromEnd = function(head, n) {\\n    var node = new ListNode()\\n    var rep = node\\n    var hash = []\\n    while(head!==null){\\n        hash.push(head.val)\\n        head = head.next\\n    }\\n    var count = hash.length-n\\n    let i = 0\\n    while(i<hash.length){\\n        if(count!==0){\\n            node.next = new ListNode(hash[i])\\n            count--\\n            node = node.next\\n        }else{\\n            count+=n-1 \\n        }\\n        i++\\n    }\\n    return rep.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2633583,
                "title": "rust-concise-two-pass-with-iterators-with-comments",
                "content": "After solving this, I read through **all** the published Rust solutions, and despite all the posted variations, I think this brings something new to the table in terms of using standard library features of Rust to avoid reinventing the wheel. The algorithm itself is the same as every other iterative Rust solution, though - count the number of total nodes, step up to the node immediately before the node to be deleted, and link it to the node immediately after the deleted node.\\n\\nImplementation notes:\\n* `std::iter::successors` yields elements as long as the state is `Some(...)`. Could it be more ideal for counting the number of nodes in our linked list? :)\\n* `fold` gives us exactly what we need to iterate over the list and give us the node we want.\\n\\n```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let cnt = std::iter::successors(head.as_ref(), |last| last.next.as_ref()).count();\\n        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));\\n        let mut prev = (0..cnt - n as usize).fold(dummy.as_mut(), |curr, _| curr.unwrap().next.as_mut() );\\n        prev.unwrap().next = prev.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n        dummy.unwrap().next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\\n        let cnt = std::iter::successors(head.as_ref(), |last| last.next.as_ref()).count();\\n        let mut dummy = Some(Box::new(ListNode{val: 0, next: head}));\\n        let mut prev = (0..cnt - n as usize).fold(dummy.as_mut(), |curr, _| curr.unwrap().next.as_mut() );\\n        prev.unwrap().next = prev.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n        dummy.unwrap().next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2603476,
                "title": "0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp=head;\\n        ListNode slow=head;\\n        ListNode fast=slow.next;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        count=count-n;\\n        while(count!=1 && fast!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n            count--;\\n        }\\n        if(fast==null){\\n            head=head.next;\\n        }else{\\n            slow.next=fast.next;\\n        }\\n        return head;\\n    }\\n}\\nPLEASE UPVOTE \\uD83D\\uDE0A```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode temp=head;\\n        ListNode slow=head;\\n        ListNode fast=slow.next;\\n        int count=0;\\n        while(temp!=null){\\n            count++;\\n            temp=temp.next;\\n        }\\n        count=count-n;\\n        while(count!=1 && fast!=null){\\n            slow=slow.next;\\n            fast=fast.next;\\n            count--;\\n        }\\n        if(fast==null){\\n            head=head.next;\\n        }else{\\n            slow.next=fast.next;\\n        }\\n        return head;\\n    }\\n}\\nPLEASE UPVOTE \\uD83D\\uDE0A```",
                "codeTag": "Java"
            },
            {
                "id": 2384172,
                "title": "c-solution-0ms-better-than-100-comments-easy",
                "content": "![image](https://assets.leetcode.com/users/images/9bbc3ebd-149a-43b6-afb5-b312d3eed80a_1659721445.167148.png)\\n```\\n// to calculate the number of elements in linked list\\nint length(ListNode* head){\\n\\tint len=0;\\n\\twhile(head!=NULL)\\n\\t\\thead = head->next, len++;\\n\\treturn len;\\n}\\n\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tint len = length(head);\\n\\t// if n is same as length, it means we need to remove the first element\\n\\tif(n==len){\\n\\t\\thead = head->next; return head;\\n\\t}\\n\\t\\n\\tint count=1;\\n\\tListNode* temp = head;\\n\\t// running the while loop n number of times, \\n\\t// and stopping just before the last nth node, i.e., prev node before last nth node.\\n\\twhile(count!=len-n){\\n\\t\\ttemp= temp->next;\\n\\t\\tcount++;\\n\\t}\\n\\t\\n\\t// now its just simple delete node example\\n\\t// we point the next of the prev node to next of last nth node.\\n\\tif(temp!= NULL && temp->next!=NULL)\\n\\t\\ttemp->next= temp->next->next;\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// to calculate the number of elements in linked list\\nint length(ListNode* head){\\n\\tint len=0;\\n\\twhile(head!=NULL)\\n\\t\\thead = head->next, len++;\\n\\treturn len;\\n}\\n\\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\tint len = length(head);\\n\\t// if n is same as length, it means we need to remove the first element\\n\\tif(n==len){\\n\\t\\thead = head->next; return head;\\n\\t}\\n\\t\\n\\tint count=1;\\n\\tListNode* temp = head;\\n\\t// running the while loop n number of times, \\n\\t// and stopping just before the last nth node, i.e., prev node before last nth node.\\n\\twhile(count!=len-n){\\n\\t\\ttemp= temp->next;\\n\\t\\tcount++;\\n\\t}\\n\\t\\n\\t// now its just simple delete node example\\n\\t// we point the next of the prev node to next of last nth node.\\n\\tif(temp!= NULL && temp->next!=NULL)\\n\\t\\ttemp->next= temp->next->next;\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317493,
                "title": "c-slow-fast-pointers",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode * start = new ListNode();\\n        start -> next = head;\\n        ListNode* fast = start;\\n        ListNode* slow = start;     \\n\\n        for(int i = 1; i <= n; ++i) fast = fast->next;\\n    \\n        while(fast->next != NULL){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        \\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode * start = new ListNode();\\n        start -> next = head;\\n        ListNode* fast = start;\\n        ListNode* slow = start;     \\n\\n        for(int i = 1; i <= n; ++i) fast = fast->next;\\n    \\n        while(fast->next != NULL){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        \\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299971,
                "title": "easy-to-understand-one-pass-solution",
                "content": "***Fast and slow pointers*** [0ms 40.3MB](https://leetcode.com/submissions/detail/750313835/)\\nHey there! Just another popular problem - boy, they really into LinkedList problems. Idea is simples - we put the slow pointer in the beginning of the list, and n-1 to right of it we put another (call it slow and fast respectivly). Then traverse until last node for **fast pointer**, then simply delete.  Here goes the code! \\n```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fastPointer = head;\\n        if (fastPointer.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = null;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fastPointer = fastPointer.next;\\n        }\\n        \\n        while (fastPointer.next != null) {\\n            fastPointer = fastPointer.next;\\n            if (slowPointer == null) {\\n                slowPointer = head;\\n            } else {\\n                slowPointer = slowPointer.next;\\n            }\\n        }\\n        \\n        if (slowPointer == null) {\\n            return head.next;\\n        }\\n        slowPointer.next = slowPointer.next.next;\\n        return head;\\n    }\\n``` \\nTime complexity: O(n) - since we traverse list in one pass\\nSpace complexity: O(1) - no additional space required",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Interactive"
                ],
                "code": "```\\npublic ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode fastPointer = head;\\n        if (fastPointer.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = null;\\n        \\n        for (int i = 1; i < n; i++) {\\n            fastPointer = fastPointer.next;\\n        }\\n        \\n        while (fastPointer.next != null) {\\n            fastPointer = fastPointer.next;\\n            if (slowPointer == null) {\\n                slowPointer = head;\\n            } else {\\n                slowPointer = slowPointer.next;\\n            }\\n        }\\n        \\n        if (slowPointer == null) {\\n            return head.next;\\n        }\\n        slowPointer.next = slowPointer.next.next;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246932,
                "title": "java-in-depth-explanation-two-pointers-technique",
                "content": "You need to know how to remove element from the LinkedList.\\n \\n **Intuition**\\n\\nThe optimal solution for the problem is using **Two Pointer Technique**.  Let\\'s say `n = 2` and we have a LinkedList `1 -> 2 -> 3 -> 4 -> 5 `. Then we want to make it as `1 -> 2 -> 3 -> 5`. Therefore, we want to have make `left` pointer points to `3`, and we could do `left.next = left.next.next`. But how do we achieve it?\\n  \\n**Oberservation**\\nThis is what we want eventually so we can perform the operation mentioned above. We can obeserve that the distance between `left` and `right` are `n+1`. \\n```\\n1   ->   2   ->   3   ->   4   ->   5  ->  null\\n                 left                      right\\n\\t\\t\\t\\t |----      n+1        ------|\\n```\\n\\nHow do we achieve it? We can place `left` on `dummyHead` position, and place `right` on position where is `n` distance away from `head`. Therefore, the distance between `left` and `right` will be `n+1` eventually.\\n\\n```\\ndummyHead   ->   1   ->   2   ->   3   ->   4   ->   5\\n   left                          right \\n   |----         n+1         ------|\\n```\\n\\n**Java code implementation**\\n\\n```\\nclass Solution\\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        // O(L) time | O(1) space\\n        // two pointer technique\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n        ListNode left = dummyHead;\\n        ListNode right = head;\\n        \\n        while(n > 0)\\n        {\\n            n -= 1;\\n            right = right.next;\\n        }\\n        \\n        while(right != null)\\n        {\\n            left = left.next;\\n            right = right.next;\\n        }\\n        left.next = left.next.next;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1   ->   2   ->   3   ->   4   ->   5  ->  null\\n                 left                      right\\n\\t\\t\\t\\t |----      n+1        ------|\\n```\n```\\ndummyHead   ->   1   ->   2   ->   3   ->   4   ->   5\\n   left                          right \\n   |----         n+1         ------|\\n```\n```\\nclass Solution\\n{\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        // O(L) time | O(1) space\\n        // two pointer technique\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n        ListNode left = dummyHead;\\n        ListNode right = head;\\n        \\n        while(n > 0)\\n        {\\n            n -= 1;\\n            right = right.next;\\n        }\\n        \\n        while(right != null)\\n        {\\n            left = left.next;\\n            right = right.next;\\n        }\\n        left.next = left.next.next;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136314,
                "title": "easy-and-simple-python-solution-with-explanation",
                "content": "-We take two pointers. Keep the first pointer start at the begining of the list and second traverse to position N+1 th element in the list. \\n-Here we consider the head to be initially null. \\n-This will help the 2 pointers to be seperated by exactly N nodes.\\n-The N node difference gap will be maintained as we advance both pointers at the same pace.\\n-We continue to traverse untill the second pointer reaches Null.\\n-When the second pointer reaches Null, the first pointer will exactly point one position before the target node which is to be deleted.\\n-With first.next.next we jump that node and return head for the result\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        \\n        ans=ListNode(0)\\n        ans.next=head\\n        first=ans\\n        second=ans\\n        for i in range(1,n+2):\\n            second=second.next\\n        while(second is not None):\\n            second=second.next\\n            first=first.next\\n        first.next=first.next.next\\n        return ans.next\\n```\\n\\n**Please upvote if it helped :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        \\n        ans=ListNode(0)\\n        ans.next=head\\n        first=ans\\n        second=ans\\n        for i in range(1,n+2):\\n            second=second.next\\n        while(second is not None):\\n            second=second.next\\n            first=first.next\\n        first.next=first.next.next\\n        return ans.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090746,
                "title": "easy-cpp-two-piointer-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head == NULL)\\n        return NULL;\\n \\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n \\n    for(int i=0; i<n; i++){\\n        fast = fast->next; //Firstly move the pointer by one step till it reaches nth node from starting\\n    }\\n \\n    //if remove the first node\\n    if(fast == NULL){\\n        head = head->next;\\n        return head;\\n    }\\n \\n    while(fast->next != NULL){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n        //slow will reach at the (n-1)th position from end of the list\\n    slow->next = slow->next->next;\\n \\n    return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head == NULL)\\n        return NULL;\\n \\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n \\n    for(int i=0; i<n; i++){\\n        fast = fast->next; //Firstly move the pointer by one step till it reaches nth node from starting\\n    }\\n \\n    //if remove the first node\\n    if(fast == NULL){\\n        head = head->next;\\n        return head;\\n    }\\n \\n    while(fast->next != NULL){\\n        fast = fast->next;\\n        slow = slow->next;\\n    }\\n        //slow will reach at the (n-1)th position from end of the list\\n    slow->next = slow->next->next;\\n \\n    return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079645,
                "title": "python-using-two-pointers-and-dummy-node-in-o-n-time",
                "content": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        first = dummy\\n        second = head\\n        while n > 0 and second:\\n            n-=1\\n            second = second.next\\n        \\n        while second:\\n            first = first.next\\n            second = second.next\\n        \\n        first.next = first.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        first = dummy\\n        second = head\\n        while n > 0 and second:\\n            n-=1\\n            second = second.next\\n        \\n        while second:\\n            first = first.next\\n            second = second.next\\n        \\n        first.next = first.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077600,
                "title": "java-single-pass-two-pointer-o-n-time-and-o-1-space",
                "content": "```\\n//TC: O(n)\\n//SC: O(1)\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        //base case\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        int count = 0;\\n        ListNode dummy = new ListNode(-1);\\n        //Adding a dummy node befor the head, gives us the ease to write to code\\n        //without having to handle seperately the case where we have to delete\\n        //head node or even if there is only one node in the list\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;//ahead of slow, and heance the name\\n        \\n        //We move the fast pointer until the count is <= n\\n        while(count <= n){\\n            count++;\\n            fast = fast.next;\\n        }\\n        //Then we move slow and fast at 1x speed, until fast is null\\n        //This places the slow at (n-1)th position form end\\n        //As we want to remove nth node, we reset links and we remove\\n        //the nth node\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Reset the links and remove nth node\\n        slow.next = slow.next.next;\\n        //As head is at dummy.next, we return that\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n//TC: O(n)\\n//SC: O(1)\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        //base case\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        int count = 0;\\n        ListNode dummy = new ListNode(-1);\\n        //Adding a dummy node befor the head, gives us the ease to write to code\\n        //without having to handle seperately the case where we have to delete\\n        //head node or even if there is only one node in the list\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;//ahead of slow, and heance the name\\n        \\n        //We move the fast pointer until the count is <= n\\n        while(count <= n){\\n            count++;\\n            fast = fast.next;\\n        }\\n        //Then we move slow and fast at 1x speed, until fast is null\\n        //This places the slow at (n-1)th position form end\\n        //As we want to remove nth node, we reset links and we remove\\n        //the nth node\\n        while(fast != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        //Reset the links and remove nth node\\n        slow.next = slow.next.next;\\n        //As head is at dummy.next, we return that\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024693,
                "title": "python-solution-faster-than-95",
                "content": "Take a dummy node connect it with head (if we take a dummy node then it would be easy to delete the first node if target node is head ie. n = length of list). Take 2 pointers fast and slow. Increase the fast pointer by n steps. Then in next pass increase both slow and fast together by one step. Slow will stop before the target element then delete the link.\\n\\n```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast = head\\n        slow = dummy\\n        \\n        for i in range(n):\\n            fast = fast.next\\n        \\n        while fast:\\n            fast = fast.next\\n            slow = slow.next\\n        \\n        tmp = slow.next.next\\n        slow.next.next = None\\n        slow.next = tmp\\n        \\n        return dummy.next\\n\\n# Time: O(N)    where N is the length of Linkedlist\\n# Space: O(1)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast = head\\n        slow = dummy\\n        \\n        for i in range(n):\\n            fast = fast.next\\n        \\n        while fast:\\n            fast = fast.next\\n            slow = slow.next\\n        \\n        tmp = slow.next.next\\n        slow.next.next = None\\n        slow.next = tmp\\n        \\n        return dummy.next\\n\\n# Time: O(N)    where N is the length of Linkedlist\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575851,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1564857,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1566736,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1565826,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576041,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576258,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1571048,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576900,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567166,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1820945,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1575851,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1564857,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1566736,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1565826,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576041,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576258,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1571048,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1576900,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567166,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1820945,
                "content": [
                    {
                        "username": "antx2021",
                        "content": "Leet code expects the answer to be [1] but i understood that we have to remove the 2nd element from end which would be 1 in this case and answer should be [2]. \\nMy submission is failing only due to this case and remaining pass which means I have understood and coded the problem correctly except for this input - [1,2] , 2.\\nPlease let me know what am I not able to understand."
                    },
                    {
                        "username": "YASH70",
                        "content": "boys but there need to remove last elemnent in second example as n=1. see that first there is no 2 there is 1 to remove(node)"
                    },
                    {
                        "username": "princek890",
                        "content": "I did the same mistake, so i do understand your question. In the question its said to remove n\\'th element from last. So if we remove 2nd element from last of [1,2] then we get 2 as expected."
                    },
                    {
                        "username": "intijk",
                        "content": "It is meaningless to use the 2 pointers technique, you won't get benefit from that, it still has the same dereference compare to 1 pointer 2 pass. \\n\\nYou want to have cache benefit when n is small?\\n\\nI hope leetcode can remove this misleading question because it encourages those people to use this \"technique\" to \"optimize\" code. It is silly."
                    },
                    {
                        "username": "firezdog",
                        "content": "I agree.  If you think of the number of operations as the number of times a pointer is moved, then it seems the pointers get moved between them the same number of times either way.  This seems to be true for many \"two pointer\" solutions."
                    },
                    {
                        "username": "soruabh_rout",
                        "content": "no!! there is difference I have done this with 2 pointer it passes only one time but when I use length logic it took 2 passes TC and SC was same but yeah! passes differs."
                    },
                    {
                        "username": "averagebloke",
                        "content": "Can you elaborate please?\\nWith 2 pointers, my code does exactly 1 pass.\\nWith 1 pointer, my code needs 2 passes"
                    },
                    {
                        "username": "GeekErra",
                        "content": "https://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Agreed test 22 even goes against their instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. "
                    },
                    {
                        "username": "Alpher",
                        "content": "Many people think a fast-slow pointer solution is one-pass. Actually, it is not. It is more than one pass and less than two.\\n\\nThis is the same as if the list is iterated once to count the number of nodes, and then traversed from the beginning again for the count of slow-pointer."
                    },
                    {
                        "username": "firezdog",
                        "content": "agree"
                    },
                    {
                        "username": "seansean",
                        "content": "My solution has one pass and uses an ArrayList to capture all nodes. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "user3574YA",
                        "content": "[@magicsign](/magicsign) not if you keep your pointers n nodes apart"
                    },
                    {
                        "username": "magicsign",
                        "content": "[@AmolOnLC](/AmolOnLC) If it\\'s a singly linked list what\\'s the benefit of using two pointers? You still need to go through the end of the linked list to get the last element and then discover the node to be deleted."
                    },
                    {
                        "username": "AmolOnLC",
                        "content": "You could use two pointers"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "[@Vithesh](/Vithesh) There are maximum 100 nodes, meaning the space taken up would be miniscule. Storing pointers is cheap, the code is easy, and it finishes in one pass. Neither preference is really superior to one another, especially in this case. If we were scaling this the right solution would just depend on the product needs. Not to mention... why would we be using a linked list at all if we were worried about removing from the middle often?"
                    },
                    {
                        "username": "Vithesh",
                        "content": "Avoid using that extra space. Using two pass is better than using extra space.\\nBecause time complexity will still be O(n) with space of O(1)."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/e3d1c56f-39e8-44d8-a496-23b38df6f556_1638458283.9324853.png)\\n\\n![image](https://assets.leetcode.com/users/images/31ae3725-3d9e-494a-ba17-726296e55e1f_1638458288.5079703.png)\\n\\n![image](https://assets.leetcode.com/users/images/af227fd1-b00b-4dff-bee3-bfc4fad1a79b_1638554273.2627227.png)\\n\\n![image](https://assets.leetcode.com/users/images/a9c56a89-115f-4bdb-bed5-063d746626e5_1638554275.4155414.png)\\n\\n![image](https://assets.leetcode.com/users/images/176365c3-bbee-4d97-8fe3-89c827d75c6f_1638554280.9999838.png)\\n\\n![image](https://assets.leetcode.com/users/images/c4fce921-a7ab-4793-939c-41abffcef8ea_1638554284.8512917.png)\\n"
                    },
                    {
                        "username": "vera1221",
                        "content": "genius! "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "Is it okay to ignore the memory leakage here?"
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "if u using java then theres no problem\\n"
                    },
                    {
                        "username": "risenrigel",
                        "content": "In C++, the leaked memory is ignored."
                    },
                    {
                        "username": "chickooo",
                        "content": "If you are using python, it will automatically take care of non linked nodes"
                    },
                    {
                        "username": "superMask",
                        "content": "Hi,\\n\\nAs the question suggests, do you think there is a more efficient way besides counting the length of the list and decide the position of the node to delete from the front?\\n\\nMany thanks."
                    },
                    {
                        "username": "Aravind_1234567",
                        "content": "![image](https://assets.leetcode.com/users/images/4b0ae1a8-4cf7-435c-ad13-383a108d096a_1655265646.3596597.png)\\n"
                    },
                    {
                        "username": "mohit_2824",
                        "content": "chutiyo ke sardar solution ni dalna hota idhar"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@manish814142](/manish814142) \\n\\nthat is an important condition .\\nif nth node to be removed to equal to total nodes then we have to remove the first node. \\nAnyway this code is so complicated .\\nI didn\\'t even use any variables."
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "if(k<0) that means n>count, how is it possible??"
                    },
                    {
                        "username": "manish814142",
                        "content": "i think you used if(k<0) statement for case [(1,2), 2]. your count only count=1 bcz in while statement temp.next != null encounter and stop by counting 1 position only.\\n\\nso by subtracting k=count-k => 2-1= -1. we will get which means we need to delete starting node.\\n\\nso i think you used k<0 (-1<0) so return 2nd nodes.\\n\\ni figured out by using this code\\n\\n        System.out.println(\"value of count \"+count);\\n        int k=count-n;\\n        System.out.println(\"value of k \"+k);\\n\\n"
                    },
                    {
                        "username": "manish814142",
                        "content": "if(k<0){\n            return head.next;\n        }\n\nwhat's the meaning of this line of code? "
                    },
                    {
                        "username": "autekwing",
                        "content": "Sorry, I google it and can not find enough explanation..\\nCan any one explain that to me?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "okay, so the question is to delete the last nth node. \\nOne way of doing it is by first calculating length of the linked list, then calculate the exact distance from head to the node we want to delete.\\nAnother way is the same, just we don\\'t explicitly calculate length, \\ni.e., First iterate pointer 1 to n nodes ahead, then iterate another pointer from start till pointer 1 is not null, this will let our pointer 2 to be at the node we want to delete.\\nTry to dry run the codes of others, you\\'ll get it"
                    },
                    {
                        "username": "jgs6156",
                        "content": "How are we supposed to implement the following edge case in Python3:\\nInput: head = [1], n = 1\\nOutput: []\\n\\nReturning anything but a ListNode object results in an error being thrown. But returning a list node that contains anything in the val property results in an incorrect output."
                    },
                    {
                        "username": "fibarrola",
                        "content": "I think you can use an empty string"
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "[@zmn17](/zmn17) But would that work always? If it is 1 in another case like the third example where we should still be returning [1]. Would it work there? \\n\\nI thought of a case like that and my solution was - \\n\\nif head.next == None:\\n    head = head.next\\n    return head"
                    },
                    {
                        "username": "kerminek",
                        "content": "[@zmn17](/zmn17) THANK YOU!!!"
                    },
                    {
                        "username": "zmn17",
                        "content": "if(n==1) return null\\n"
                    }
                ]
            },
            {
                "id": 1567809,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1571049,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1568838,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1941941,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1575528,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1573790,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 2031745,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1699663,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1576661,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1576621,
                "content": [
                    {
                        "username": "what_if",
                        "content": "I see many people use two pointers, which I think is actually the same as two passes."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@chickooo](/chickooo) Your analysis isn't correct for two pointers. The first pointer moves k steps. Then **both** pointers move (n - k) steps so it's 2*(n-k) steps.\n\nTotal number of steps is k + 2*(n-k) = 2n - k which is exactly the same as the two pass approach."
                    },
                    {
                        "username": "kuelf",
                        "content": "[@chickooo](/chickooo) It is the same.\nBoth reduce to O(n).\nAlso k is meaningless."
                    },
                    {
                        "username": "chickooo",
                        "content": "For two pointers, the complexity is **O(n+k)**\\nBut for two pass it is **O(n + (n-k))**\\n\\nhere, k is nth position from end."
                    },
                    {
                        "username": "xiaoxiaoxiaoV",
                        "content": "if  we ignore the note,\"Given n will always be valid\", how we handle the situation that n is bigger than the length of the linked list?"
                    },
                    {
                        "username": "scrabbletank",
                        "content": "It says in the problem description that n is always valid, but this doesn't seem to be the case. One of the final test passes uses this test case:\\n\\n[1]\\n1\\n\\nThere isn't a 2nd element to remove, so in this case N is invalid. What's more, the expected answer is [] and not [1]."
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Initialize a `dummy` node  `(None -> head)`\\nthis will help you to cater the issue of removing `first(head)` node."
                    },
                    {
                        "username": "forresthopkinsa",
                        "content": "If you\\'re getting weird JS test failures and you don\\'t know why, here\\'s some help: this problem tests for tail nodes with `{ next: null }`.\\n\\n`{ next: undefined }` and `{}` will not work.\\n\\nThis is the first time I\\'ve seen a problem with this requirement. This expectation is undocumented and the resulting errors can be cryptic."
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Thanks a lot for that! My code was getting that error and I was looking for a comment related to it. A simple if(node.next === undefined)node.next = null   did the trick."
                    },
                    {
                        "username": "MPMoka",
                        "content": "Test system is not providing right \\'n\\' to the code."
                    },
                    {
                        "username": "ronlek",
                        "content": "Here's a solution that's actually \"one-pass\".\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        vector<ListNode*> nodeList;\n        ListNode *node = head;\n\n        while(node){\n            nodeList.push_back(node);\n            node = node -> next;\n        }\n\n        int nlSize = nodeList.size();\n        if(nlSize - n == 0){\n            return head -> next;\n        }\n\n        ListNode *cur = nodeList[nlSize - n - 1];\n        cur -> next = cur -> next -> next;\n\n        return head;\n    }\n};\n```\n\nTime Complexity: `O(N)`. Each node is traversed once.\nSpace Complexity: `O(N)`. Each node is stored in the vector."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nHere are the rules...\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yawend",
                        "content": "To delete the Nth Node from end, N+1th Node from end is required.\\nhighlight:\\nhow to find the nth node from end:\\nUse two pointers, both pointers points the the head initially.\\nThen pointer1 moves nth steps first.\\nThen both 2 pointer moves together.\\nWhen pointer1 moves to the end of the linklist,\\npointer2 points to the nth node from end.\\n\\n`class Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        \\n        #find the N+1th Node from end\\n        p=self.findFromEnd(dummy,n+1)\\n        \\n        #let the N+1th Node from end next to the N-1th Node from end\\n        p.next=p.next.next\\n        return dummy.next\\n\\n    def findFromEnd(self, head, n):\\n        p1=ListNode(-1)\\n        p2=ListNode(-1)\\n        \\n        #both p1 and p2 points to head\\n        p1.next=head\\n        p2.next=head\\n        \\n        #pointer p1 moves to the Nth node first\\n        for i in range(n):\\n            p1=p1.next\\n        \\n        #move p1 and p2 at the same time, when p1 moves to the end,p2 move to the Nth Node from end\\n        while p1 != None:\\n            p2=p2.next\\n            p1=p1.next\\n        \\n        return p2`"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Faster C++ || Java Script || Java || Python \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-remove-nth-node-from-end-of-list-c-python-java-javascript-solution/"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/remove-nth-node-from-end-of-list-leetcode-python/\\n"
                    }
                ]
            },
            {
                "id": 1572845,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 1573521,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 1569186,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2074292,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2069230,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2068894,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2067748,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2064136,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2049900,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2045973,
                "content": [
                    {
                        "username": "burcukaptikacti",
                        "content": "I solve like this : \\n\\n![image](https://assets.leetcode.com/users/burcukaptikacti/image_1563436209.png)\\n\\n"
                    },
                    {
                        "username": "user0856Nl",
                        "content": "The test case [1, 2], n = 2 should give as output [ ] since, starting from the end, the node to be removed is out of list.\\nYour expected output is [2] but it\\'s completely wrong!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Not wrong! The counting from the end starts at 1. So if n = 1 you would remove the last element. If n = 2 you remove the second last element.\\n\\nHere, removing the second last element means remove `1` which gives an output of `[2]`."
                    },
                    {
                        "username": "acmol",
                        "content": "I think it's nonsence..\nIthink this method is not better than iterating two times."
                    },
                    {
                        "username": "ParagVarshney",
                        "content": "in this question head={1,2,3,4,5} or head=1   ????"
                    },
                    {
                        "username": "trololo999",
                        "content": "Is it cheating if use an array to store the nodes ?"
                    },
                    {
                        "username": "geoffreyn",
                        "content": "Can anyone fix this edge case?\\n\\n ```\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        slow = head\\n        fast = head.next\\n\\n        cnt = 0\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            cnt += 1\\n\\n        while cnt > n:\\n            slow = slow.next\\n            cnt -= 1\\n\\n        if slow.next:\\n            slow.next = slow.next.next\\n        else:\\n            return head.next\\n        return head\\n```\\n\\nInput\\nhead =\\n[1,2]\\nn =\\n2\\n\\nOutput\\n[1]\\nExpected\\n[2]"
                    },
                    {
                        "username": "alanzh",
                        "content": "so i know thats not best solution but why in the case when head = [1,2] and n = 1 output is still [1,2]? When i put node.next = None it works but without it output is [1,2]\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        g = head\\n        #cnt = 0\\n        ar = []\\n        \\n        while g:\\n            ar.append(g)\\n            g = g.next\\n        \\n        \\n\\n        ar.pop(len(ar)-n)\\n        dummy = node = ListNode()\\n        for i in ar:\\n            node.next = i\\n            node = node.next\\n            #node.next = None\\n        \\n        return dummy.next"
                    },
                    {
                        "username": "vk1610",
                        "content": "I solved it by first calculating the length of LL , and simply iterated the LL from head to length-n .\\nit manages to solve Q , but my code is not efficient as it beats only 25% python users, does anyone know any other technique?"
                    },
                    {
                        "username": "lpinyi1012",
                        "content": "how is it possible to know where to stop if we are doing it in one pass without knowing where the end is?\nis there a way to know the end node like ListNode.size() without traversing the whole list?"
                    },
                    {
                        "username": "aydayka555",
                        "content": "I always find examples soo much less in leetcode, given 2 samples doesnt explain code properly, and always one of smaples are given with one which is not enough explanative!\\n"
                    }
                ]
            },
            {
                "id": 2038012,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2033169,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2023084,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2021460,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2021264,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2018477,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2010908,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 2005098,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1989947,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1981274,
                "content": [
                    {
                        "username": "HarshSaini07",
                        "content": "Line 24: Char 20: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:20\\n\\nhow i solve this type of error "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "700 problems solved sweet"
                    },
                    {
                        "username": "arpit_055",
                        "content": "I guess since this solution has been accepted.....there has to be some reason, if it doesn\\'t work for [1,2] case then the solution would not have been accepted...It is the correct solution... pls check again\\n"
                    },
                    {
                        "username": "user7140ci",
                        "content": "The provided ListNode class can\\'t give answer from Example 2: the primitive int val can\\'t be null, so the result will be [0].    "
                    },
                    {
                        "username": "Ashik543",
                        "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n\n\n\n\n\n\n\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n   \n     newNode=ListNode(0)\n    newNode=fast\n    newNode=slow\n    count=1\n    while fast != None:\n           fast=fast.next\n           count=count+1\n        \n           for i in range(0,count-n):\n               slow=slow.next\n               slow.next=slow.next.next\n        \n            return fast.next\n\nI still find errors ,what's the reason? Please do let me know."
                    },
                    {
                        "username": "buzz_shocker",
                        "content": "I could be reading it wrong and you may have already corrected it, but you create a newNode and then assign fast and slow to it with no previous declaration of fast and slow. Do you mean to assign newNode to fast and slow? Try doing that. That should hopefully fix the error you are getting. Other than that, you are on the right track to get the solution. "
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "Tip using two pointers and overthinking this question is waste of time. All you need to do is to connect correct nodes with each other. How to do it? Store nodes in arraylist"
                    },
                    {
                        "username": "i_am_guts",
                        "content": "good question , the two pointer approach is not the only solution, i will recommend not go with brute force O(n^2)"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "I was of the impression the 2 pointer approach is O(n), am I incorrect? I would like to learn of a better solution than 2 pointer"
                    },
                    {
                        "username": "sharonshaliyo",
                        "content": "Using 2 pointers (fast, slow) keeps the code simple\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Is there any way to solve this problem using only one loop ? I had an interview and was asked to solve this problem using only one loop ,any suggestions?"
                    },
                    {
                        "username": "kldpsh77",
                        "content": "by using dictionary (map) you can map index number with node and modify the element before the element we have to remove by node.next to node.next.next\\nSee below solution\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/3857386/simple-python-solution-using-single-loop/"
                    },
                    {
                        "username": "kaushikbor2018",
                        "content": "I came out with the solution with the following process:\\n1. check whether the head is null. if it is then return it then and there.\\n2. count the size of the linked list.\\n3. declare a variable \\'diff\\' storing the difference between n and the size of the linked list.\\n\" here diff represents the no. nodes we need to pass through from head to get to the next element we want to delete \"\\n4. if diff = 0, then first element is to be deleted. if diff=1, then second element is to be deleted. similarly if diff = k, then k+1th is to be deleted.\\n\\n"
                    }
                ]
            },
            {
                "id": 1947920,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1941870,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1928350,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1927944,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1912962,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1903794,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1902347,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1885458,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1878243,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1856530,
                "content": [
                    {
                        "username": "zmn17",
                        "content": "head =\\n[1,2]\\nn =\\n2\\nUse Testcase\\nOutput\\n[1]\\nExpected\\n[2]\\n\\ncan someone explain this test case?? n =2 so the 2nd node from the end which is 1?? isnt it?? "
                    },
                    {
                        "username": "Afroz_shah",
                        "content": "you need to put one condition \\nwhere num=number of the node which can be get through traversal\\nand n=position from back\\nif(num-n<0){\\n            return head->next;\\n        }"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Start by adding an extra node in the beginning"
                    },
                    {
                        "username": "vivekkt",
                        "content": "I used the two pointer solution. But for some reason, the second test case in Run fails. The same test case works on my local machine as a unit test though!!!\nTest Case : \n `head = [1], n = 1`\n\nSolution:\n ```\nfunc RemoveNthFromEnd(head *ListNode, n int) *ListNode {\n\tif head == nil || n == 0 || head.Next == nil {\n\t\treturn head\n\t}\n\tdummy := &ListNode{Val: -1, Next: head}\n\tfirst, second := dummy, dummy\n\tfor i := 1; i <= n+1; i++ {\n\t\tfirst = first.Next\n\t}\n\tfor first != nil {\n\t\tfirst = first.Next\n\t\tsecond = second.Next\n\t}\n\tsecond.Next = second.Next.Next\n\treturn dummy.Next\n}\n```\n\nThe following unit test passes on my local for the above solution:\n ```\nfunc TestRemoveNthFromEnd(t *testing.T) {\n\t// GIVEN\n\thead := &ListNode{\n\t\tVal:  -1,\n\t\tNext: nil,\n\t}\n\tnode := &ListNode{\n\t\tVal:  1,\n\t\tNext: nil,\n\t}\n\thead.Next = node\n\n\t// WHEN\n\tn := RemoveNthFromEnd(head, 1)\n\n\t// THEN\n\tassert.Equal(t, (*ListNode)(nil), n.Next)\n}\n\n```\n\nWhy does this test case fail on leet code? "
                    },
                    {
                        "username": "user4346Sy",
                        "content": "100% beat\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (head == NULL)\\n                return NULL; // List does not have n nodes\\n            \\n            head = head->next;\\n        }\\n        \\n        while (head != NULL) {\\n            if (prev == NULL)\\n                prev = curr;\\n            else\\n                prev = prev->next;\\n            \\n            head = head->next;\\n        }\\n        \\n        if (prev == NULL)\\n            return curr->next; // Remove the head node\\n        else\\n            prev->next = prev->next->next; // Remove the nth node\\n        \\n        return curr;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "100% beat rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xenojohn",
                        "content": "Leetcode seems to be broken at this question.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\n        element_number = 0\\n\\n        head_copy = head\\n\\n        while head:\\n            element_number += 1\\n            head = head.next\\n        \\n        head = head_copy\\n        \\n        how_far = element_number - n\\n        prev_node= None\\n        print(how_far)\\n\\n        while head:\\n            print(\"how_far: \", how_far)\\n            if how_far == 0:\\n                print(\"We\\'re in if, we are breaking after this..\")\\n                print(head.val, prev_node, head, head.next)\\n                prev_node.next = head.next\\n                break\\n                print(\"We\\'re printing after break..\")\\n\\n            prev_node = head\\n            head = head.next\\n            how_far -= 1\\n\\n        return head_copy\\n```\\n\\nit seems to just purely ignore the break (i\\'ve tried with return but it still doesn\\'t return, but continue looping). This is a weird behaviour. Did anyone else also find this?\\n\\nDebug;\\n\\n3\\nhow_far:  3\\nhow_far:  2\\nhow_far:  1\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n4 ListNode{val: 3, next: ListNode{val: 4, next: ListNode{val: 5, next: None}}} ListNode{val: 4, next: ListNode{val: 5, next: None}} ListNode{val: 5, next: None}\\n0\\nhow_far:  0\\nWe\\'re in if, we are breaking after this..\\n1 None ListNode{val: 1, next: None} None"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I don\\'t understand what exactly happen. It seems that \\'break\\' behaves like \\'continue\\'. The text after \\'break\\' is missing.\\nYou use while loop. Why use head? I suggest that you use \\'how_far\\' instead, like that:\\nwhile how_far:\\nor\\nwhile how_far != 0:\\nWe are that we reach the node in how_far position before head.\\n"
                    },
                    {
                        "username": "Shashank1524",
                        "content": "ListNode temp = head;\n        ListNode tempN = head;\n        int length = 0;\n        while(temp!=null) {\n            temp = temp.next;\n            length++;\n        }\n        temp = head;\n        for(int i = 0; i<length-n-1; i++) {\n            temp = temp.next;\n        }`\n        tempN = temp.next;\n        System.out.print(tempN.next); \n\ncan anyone please help me with this code? \nSo the issue is, I don't understand why the NullPointerException is thrown at Sysout even though the console shows the expected output, what am I doing worng?(please ignore the complexity of the code) "
                    },
                    {
                        "username": "zelyony",
                        "content": "IMO test2 and test3 contradict each other\\ntest2: n=1 and 0th node removed. (node0 is removed, node1 is absent)\\ntest3: n=1 and 1st node removed. (node0 is left, node1 is removed)\\nso for same n=1 different order nodes are removed.\\nwtf?"
                    },
                    {
                        "username": "Vish_sp",
                        "content": "Hi ,in c# int is not nullable then how can i return a empty List i am getting error at test case [1]  out put [] can any one help here..?"
                    },
                    {
                        "username": "kaninaba94",
                        "content": "It is misleading that head is specified as type list in the description, but in the function argument it\\'s type ListNode."
                    },
                    {
                        "username": "shashwat1319",
                        "content": "how to access element in linklist?"
                    }
                ]
            },
            {
                "id": 1846477,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1845450,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1838225,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1832920,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1826013,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1817380,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1807847,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1807283,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1806956,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1803178,
                "content": [
                    {
                        "username": "user4711ok",
                        "content": "Tearing my hair out; why does this give a runtime error?\\n\\nOk so I run these two pointers through the list, simple. One does it in a for loop and one does it unrolled. Looking at the stdout, the pointer in the loop goes through 5 times (as it should) but I get a runtime error trying to go through it unrolled. If I put a \"return if null\" statement beforehand, I still get a runtime error, so it\\'s not that it\\'s null.\\n\\nCame across this on the way to a solution. The error is:\\n\\nLine 26: Char 59: runtime error: member access within null pointer of type \\'const ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior\\n\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        const ListNode* scanPtr = head;\\n\\n        while(scanPtr)\\n        {\\n            printf(\"G: %X links to %X\\\\n\", scanPtr, scanPtr->next);\\n            scanPtr = scanPtr->next;\\n        }\\n\\n        const ListNode* breakPtr = head;\\n\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n        breakPtr = breakPtr->next;\\n        printf(\"B: %X links to %X\\\\n\", breakPtr, breakPtr->next);\\n\\n        printf(\"Done!\\\\n\");\\n\\n        return head;\\n    }"
                    },
                    {
                        "username": "vanavi",
                        "content": "Hi everybody! \\nI proposed a solution using method `.at()`.  And i prove it in my local server and works perfectly fine. But i test it in here and returns `TypeError: head.at is not a function`\\n\\nWhy i cant apply it in this problem? "
                    },
                    {
                        "username": "nklwwlkn",
                        "content": "Hey, \\n\\nIt\\'s a Linked list data structure, and not an array. You see the TypeError because the ListNode class doesn\\'t have an \"at\" method."
                    },
                    {
                        "username": "Vithesh",
                        "content": "Everyone is doing it alright. But yall forgetting one if condition that\\'s it."
                    },
                    {
                        "username": "user3948b",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p=head,*q=head;\\n        int m =0;\\n        while(p!=NULL ) {\\n            m++;\\n            p=p->next;\\n        }\\n        for(int i=0;i<m-n;i++) {\\n            q=q->next;\\n        }\\n        ListNode *d= q->next;\\n        q->next = d->next;\\n       delete d;\\n        return head;\\n        \\n         }`\\nwhy this is not working"
                    },
                    {
                        "username": "cagils",
                        "content": "**O(1) 2-pointers approach, optimized algorithm explanation:**\n\n0. Assign fast pointer to head.next, slow pointer to the head (named 'node')\n1. Traverse the list from the head n-1 times with the fast pointer (named 'cur'). It started at head.next, so we have traversed the list now n times\n2. If you have arrived at null (edge case of head removal), return head.next\n3. Now we move both pointers at the same time until fast pointer (cur) reaches the end\n4. Remove the node next of the current slow pointer (node). So node.next = node.next.next\n5. Return head\n\nFor a 6-line implementation in JS you can look at my solution."
                    },
                    {
                        "username": "user8170Cm",
                        "content": "Hint: use a stack"
                    },
                    {
                        "username": "Fantaseaxx",
                        "content": "Dose anyone know what\\'s wrong with my code? Cant pass the test : head=[1],n=1 the output should be [ ],I ran my code in my IDE, shows the same results, but on Leetcode console output is [1]\\nclass Solution {\\n    static int cur =0;\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        if(head == null) return null;\\n        head.next = removeNthFromEnd(head.next,n);\\n        cur++;\\n        if(cur == n) return head.next;\\n        return head;\\n\\n    }\\n}"
                    },
                    {
                        "username": "ravilsqrt",
                        "content": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n       arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        if len(arr) == 1:\n            return None\n\n        arr.pop(len(arr) - n)\n\n        cur_new = ListNode(arr[0].val)\n        for i in range(len(arr)):\n            if i != 0:\n                exec('cur_new{amount}'.format(amount='.next' * i + '= arr[i]'))\n        return cur_new\n\nI failed on 194 test with this solution, but I got correct answer in pycharm and online interpreter"
                    },
                    {
                        "username": "Amangupta97656",
                        "content": "IT\\'S EASY SOLUTION\\n\\n\\n\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        //if Single element list, thus returning empty list\\n        if(head.next == null)\\n            return null;\\n\\n        ListNode ptr = head;\\n        ListNode ptr2 = head;\\n\\n        int len = 0;\\n\\n        //finding the lenght of the list\\n        while(ptr != null)\\n        {\\n            len++;\\n            ptr = ptr.next;\\n        }\\n\\n        //required index\\n        int index = len - n;\\n        ptr = head;\\n\\n        boolean start = false;\\n\\n        while(true)\\n        {\\n            if(index == 0)\\n            {\\n                // if head element\\n                if(ptr == head)\\n                {\\n                    ptr2 = ptr2.next;\\n                    ptr.next = null;\\n                    head = ptr2;\\n                    break;\\n                }\\n\\n                else\\n                {\\n                    ptr2.next = ptr.next;\\n                    ptr.next = null;\\n                    break;\\n                }\\n            }\\n\\n            index--;\\n\\n            //for letting the second pointer start late\\n            if(start)\\n                ptr2 = ptr2.next;\\n\\n            start = true;\\n\\n            ptr = ptr.next;\\n        }    \\n\\n        return head;    \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "It\\'s easy rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "arpit_055",
                        "content": "I have compiled my solution \\nListNode* removeNthFromEnd(ListNode* head, int n) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        for(int i=0;i<(n-1);i++){\\n            fast=fast->next;\\n        }\\n        while(fast->next!=nullptr){\\n            fast=fast->next;\\n            slow=slow->next;\\n        }\\n        if(slow==head){\\n            head=head->next;\\n            delete slow;\\n            return head;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n\\nbut I\\'m keep getting this error member access within null pointer in this line /*slow->next=slow->next->next*/ ,I have also tried writing temp=slow->next and then slow->next=temp->next but it didn\\'t work.Is there any other way to write this line..\\n"
                    }
                ]
            },
            {
                "id": 1798329,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1794340,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1793531,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1793259,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1792058,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1789844,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1785417,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1774792,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1772792,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1768698,
                "content": [
                    {
                        "username": "iamravirajesh",
                        "content": "Class Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n         ListNode curr = head;\\n         int cnt=0;\\n         \\n         while(curr!=null)\\n         {\\n             cnt++;\\n             curr=curr.next;\\n         }\\n         curr=head;\\n         cnt=cnt-n;\\n\\n         if(cnt==0)\\n         {\\n             curr.val=curr.next.val;\\n             curr.next=curr.next.next;\\n         }\\n\\n         while(cnt>1)\\n         {\\n             cnt--;\\n             curr=curr.next;\\n         }\\n\\n         curr.next=curr.next.next;\\n\\n         return head;\\n    }\\n}\\n\\ncan someone please explain what\\'s wrong with my code? It is giving null pointer error at  \"curr.val=curr.next.val;\" ans \"curr.next=curr.next.next;\""
                    },
                    {
                        "username": "Drakath2812",
                        "content": "I don\\'t follow the logic of the problem, I can\\'t work out which node is supposed to be removed, the numbering in the examples given seem inconsistent at best, and when I thought i\\'d figured it out, apparently [1,2] and n=2, should return 2? why?"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python Question...\\n\\nI understand that one of the objects of this problem is to look at this as a problem in C. There are no such things as linked lists in C. But there are in Python and to force a python programmer to ignore this doesn\\'t make sense. The solution to this problem utilizing a linked list and popping an element out of it is two lines of code (and the second line is a return statement). It seems to me that if the programming language that we are using has built in commands that allow us to do things more efficiently then Leetcode should allow us to use them. Can anyone explain to me why we can\\'t?\\n\\nThanks in advance."
                    },
                    {
                        "username": "Curious_hritik",
                        "content": "ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *fast = head, *slow = head;\\n\\n        for (int i = 0; i < n; i++) \\n            fast = fast->next;\\n\\n        //If node to be remove is the first node from starting .i.e head node\\n        if (fast == NULL){\\n            slow = slow->next;\\n            delete head;\\n            return slow;\\n        } \\n    \\n        \\n        while (fast->next!=NULL)\\n           fast = fast->next, slow = slow->next;\\n\\n        ListNode *temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n        \\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "lionezzz",
                        "content": "Some utility code for those who don\\'t use LeetCode\\'s environment for tests and use other IDE:\\n\\npublic static void main(String[] args) {\\n    int[] nodes = {1,2,3,4,5};\\n    int n = 2;\\n    ListNode head = constructListNode(nodes);\\n    ListNode result = new Solution().removeNthFromEnd(head, n);\\n    System.out.println(result == null ? \"[]\" : result.toString());\\n}\\n\\npublic static ListNode constructListNode(int[] nodes) {\\n    ListNode current = new ListNode(nodes[nodes.length - 1]);\\n    for (int i = nodes.length - 2; i >= 0; i--) {\\n        current = new ListNode(nodes[i], current);\\n    }\\n    return current;\\n}\\n\\npublic static class ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {\\n    }\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + val + (next == null ? \"]\" : \", \" + next.toStringInner() + \"]\");\\n    }\\n\\n    public String toStringInner() {\\n        return val + (next == null ? \"\" : \", \" + next.toStringInner());\\n    }\\n}"
                    },
                    {
                        "username": "propercthulhu",
                        "content": "What is the python3 solution here for the input of [1], as you literally cannot delete the val attribute with any form of del or delattr, as you repeatedly get an AttributeError. Literally only case that won\\'t pass and all my attempts to return what they expect fails."
                    },
                    {
                        "username": "AlanD88",
                        "content": "Can someone explain testcase 22 for me?\\n\\n`head = [1,2]\\nn = 2`\\n\\nWe\\'re supposed to remove the nth node.  So in this case we remove the node at index 2, which is 2.\\n\\nBut the test case removes node at position one and shows head to point to node with val 2?  \\n\\nIm so confused"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhila01](/nikhila01) Thank you! I was having the same question. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're supposed to remove the nth node _counting from the end_. `n = 1` means remove the last node. `n = 2` means remove the second last node.\n\nSo for `head = [1,2] n = 2` you need to remove the second last node, which is `1`.  That means the result is `[2]`."
                    },
                    {
                        "username": "smartnealll",
                        "content": "I get a NullPointerException, and it said there is a bug at 25 line(check.next = check.next.next;). However, I debug it. Before line 25, the check is [3, 4, 5]. I think my line 25 is correct, but it said  cannot read field because \"\"<local3>.next\" is null. Can anyone please give me some suggestion?\\n\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        ListNode check = head;\\n        int count = 1;\\n        while(check.next != null) {\\n        check = check.next;\\n            count++;\\n        }\\n        count = count - n - 1;\\n        check = head;\\n        while(count > 0) {\\n            check = check.next;\\n            count--;\\n        }\\n        check.next = check.next.next;\\n        return check; \\n    }\\n\\n\\n\\n"
                    },
                    {
                        "username": "badmusamuda",
                        "content": "Runtime: 0 ms, Beats : 100%\\nMemory:40.5 MB, Beats 90 to 64.30%\\n\\n[1.] Reverse the ListNode by adding from the tail\\n\\n `ListNode cp = null;\\n        ListNode temp = head;\\n        while(temp != null){\\n            cp = new ListNode(temp.val, cp);\\n            temp = temp.next;\\n        }`\\n\\n\\n[2.] Re-add, and skip when the condition is satisfied\\n\\n`int start = 1;\\n        temp = null;\\n        while (cp != null){\\n            if(start != n){\\n                temp = new ListNode(cp.val, temp);\\n            }\\n            cp = cp.next;\\n            start++;\\n        }\\n        cp = null;\\n        return temp;`"
                    },
                    {
                        "username": "bugbreaker7",
                        "content": " ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int length = 0;\\n        ListNode* temp = head;\\n\\n\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        \\n        \\n        if(length==1 && n==1){  //EDGE CASE1\\n            return NULL;\\n        }\\n        \\n\\n        length = length-n;\\n        if(length==0){\\n            return head->next; //EDGE CASE2\\n        }\\n        int count =0;\\n        ListNode* temp1 = head;\\n\\n\\n\\n        while(temp1){\\n            count++;\\n            if(count==length){\\n                ListNode* sub=temp1->next;\\n                temp1->next=sub->next ;\\n                return head;\\n            }\\n            temp1=temp1->next;\\n        }\\n        return head;\\n    }\\n\\nJust take a counter variable to count length of an linkedlist and then do length-n to get the position, now iterate over linkedlist again until you get that point, once you get that node you can remove to get your answer. \\n\\nThere are 2 further edge cases which I have mentioned above."
                    }
                ]
            },
            {
                "id": 1767986,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1767463,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1762738,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1761939,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1760978,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1759142,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1757564,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1757307,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1752948,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1752910,
                "content": [
                    {
                        "username": "skodzh",
                        "content": "why head.next is null for the first test case?\\nListNode tmp=head.next.next;\\nCrashes with npe."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/19_Remove_Nth_Node_From_End_of_List.cpp"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "_tushar_13",
                        "content": "it gives error for a testcase with one element [1]\\nclass Solution:\\n\\tdef removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n\\t\\tdummy=head;curr=dummy\\n\\t\\tlength=0\\n\\t\\twhile curr:\\n\\t\\t\\tlength+=1\\n\\t\\t\\tcurr=curr.next\\n\\t\\tindex=(length-n);now=dummy\\n\\t\\twhile (now):\\n\\t\\t\\tindex-=1\\n\\t\\t\\tif index==0:\\n\\t\\t\\t\\tnow.next=now.next.next  \\n\\t\\t\\tnow=now.next\\n\\t\\treturn dummy\\n##help##"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ravichaudhary2372000",
                        "content": "   Java solution \n\n class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}"
                    },
                    {
                        "username": "magpro_18",
                        "content": "why is my code showing this error on using a while loop-\\nLine 24: Char 22: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:22"
                    },
                    {
                        "username": "BenArviv",
                        "content": "Can someone explain to me why my code doesn\\'t work?\\nIn fact, it do works in my environment, but here it fails on the test {[1, 2, 3, 4, 5], 2}.\\nIf anyone has some insights, it would be great!\\nFor some reason it doesn\\'t let me display my entire code as a code, so it starts from the \\'if\\'.\\n\\nif head == None:\\n        return None\\n    temp = ListNode()\\n    prev = ListNode()\\n    length = 0 # The length of the linked-list\\n    temp = head\\n    while temp.next != None:\\n        temp = temp.next\\n        length += 1\\n    \\n    temp = head\\n    prev = None\\n    k = length - n\\n    for i in range(k):\\n        prev = temp\\n        temp = temp.next\\n        \\n    if prev != None:\\n        prev.next = temp.next\\n    \\n    return head"
                    },
                    {
                        "username": "pramodacharya",
                        "content": "You have several mistakes in your code, as pointed below\\n\\n1) First, your calculation of length is incorrect. It is counting one less node. Check it by printing the length after you calculate\\n\\n2) Second you are not handling the edge case of k = 0, which is the case where head itself needs to be removed\\n\\n3) Finally, at the end you are checking whether prev is None, which is wrong. You should check whether temp is None instead.\\n\\nI copied your code and fixed above 3 mistakes and it passed. \\nLet me know if you need more help."
                    },
                    {
                        "username": "akku18tiwari",
                        "content": " `/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fill(vector<ListNode*>& vec, ListNode* head){\\n        if(head == NULL) return;\\n\\n        vec.push_back(head);\\n        fill(vec, head->next);\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        vector<ListNode*> vec;\\n        fill(vec, head);\\n        int t = vec.size() - n;\\n        vec[t-1]->next = vec[t+1];\\n        delete(vec[t]);\\n        return head;\\n        // int sz = vec.size();\\n        // vec[sz-2]->next = NULL;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(int i=0;i<vec.size();i++){\\n        //     cout<<vec[i]->val<<\" \";\\n        // }\\n        \\n    }\\n};`\\n\\ncan someone please tell why this code is giving error?\\nI am clueless what is wrong. "
                    },
                    {
                        "username": "mrdemoncyborg007",
                        "content": "# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNthFromEnd(self, head, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        k=1\\n        p=head\\n        while p.next!=None:\\n            k+=1\\n            p=p.next\\n        print(k)\\n        k=k-n\\n        p=head\\n        q=head.next\\n        while k>1:\\n            k-=1\\n            p=p.next\\n            q=q.next\\n        print(p.next)\\n        p.next=q.next\\n        q.next=None\\n        return head\\n        \\n\\n\\nhere it says on line 27 p.next=q.next \"Nonetype\" object has no attribute \\'next\\' but if i dont do assign and just print p.next it prints and when i see its type with type() it shows linklist what is the problem if anyone could tell it will be of great help"
                    }
                ]
            },
            {
                "id": 1751930,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1743442,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1742860,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1731185,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1729271,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1729034,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1727125,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1725040,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1716796,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1716023,
                "content": [
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nhttps://youtu.be/IWYWvfbINug"
                    },
                    {
                        "username": "CAPL1",
                        "content": "Can someone explain the usage of a dummy pointer. What edge cases would we run into if we were to just separate the fast/slow pointers from head."
                    },
                    {
                        "username": "tisha_2702",
                        "content": "Cannot read field \"next\" because \"<local3>\" is null\\n\\nI am getting this problem please suggest solution"
                    },
                    {
                        "username": "gyangav01",
                        "content": "Remove Nth Node From End of List Problem Solution in Leet code\\nHere is the solution:-[Click Here](https://gyangroupindia.blogspot.com/2022/12/remove-nth-node-from-end-of-list.html)"
                    },
                    {
                        "username": "Lucifer-dragneel00",
                        "content": "class Solution {\\n     \\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        \\n   int length = 0; for(ListNode cur = head; cur != null; cur = cur.next) length++;\\n\\nif(length == n) {head = head.next; return head;}\\n\\nif(length == 1) return head;\\n\\nListNode l = head; for(int i = 1; i<length-n; i++) l = l.next;\\n\\nl.next = l.next.next;\\n        \\n       return  head;\\n           \\n    }\\n}"
                    },
                    {
                        "username": "Akashverma212",
                        "content": "My solution has passed and use to capture all nodes without using tail. I wonder if there is a better solution to this problem, with O(1) space."
                    },
                    {
                        "username": "deezyto",
                        "content": "In the test case [1], you need to return null."
                    },
                    {
                        "username": "ryanrenjith19",
                        "content": "Can anyone help me find the problem with this code?\\n\\nIts showing the following error :\\n\\nLine 39: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:48:36\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n\\n        ListNode* ptr1 = head;\\n        int count = 0;\\n\\n        if(ptr1->next == NULL)\\n            return NULL;\\n\\n        while(ptr1 != NULL)\\n        {\\n            count++;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1 = head;\\n\\n        count = count - n + 1;\\n\\n        while(count > 0)\\n        {\\n            count--;\\n\\n            ptr1 = ptr1->next;\\n        }\\n\\n        ptr1->next = (ptr1->next)->next;    //error line\\n\\n        return head;\\n    }\\n}; `"
                    },
                    {
                        "username": "havish05",
                        "content": "can somebody point out the mistake? It says 187 /208 testcases passed.\\n\\nllist=self.count(head)\\n        if head == None:\\n            return None\\n\\n        if head.next == None and n==1:\\n            return None\\n\\n        curr=head\\n        # print(llist)\\n        i=1\\n        while curr.next:\\n            if i==llist-n:\\n                curr.next=curr.next.next\\n                break\\n            else:\\n                curr=curr.next\\n                i+=1\\n        return head"
                    },
                    {
                        "username": "eugene09",
                        "content": "head = [1,2] and n = 2, more interestingly output is [2]\\n\\nWhy output is [2]? Can someone explain this problem, pls?\\n\\nI guess output should be [1];\\n"
                    }
                ]
            },
            {
                "id": 1714258,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1711080,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1710159,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709843,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709177,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1709090,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1707734,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1706368,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1704391,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1703301,
                "content": [
                    {
                        "username": "pranathi1163",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        int num=0;\\n        ListNode* ptr=head;\\n        //count number of elements in list\\n        while(ptr!=nullptr)\\n        {\\n            num=num+1;\\n            ptr=ptr->next;\\n        }\\n        //if one elt in list return null\\n        if(num==1)\\n        {\\n            head=nullptr;\\n            return head;\\n        }\\n        //if first elt shoud be deleted...return head->next\\n        if(num==n)\\n        {\\n            return head->next;\\n        }\\n        //else traverse till that elt and change the pointers\\n        int ct=1;\\n        ptr=head;\\n        while(ptr!=nullptr)\\n        {\\n            if(ct==num-n)\\n            {\\n                ptr->next=ptr->next->next;\\n                break;\\n            }\\n            ct=ct+1;\\n            ptr=ptr->next;\\n        }\\n        return head;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Just count the nodes from behind using Recursion and once you meet the nth node, delete it and adjust the pointers."
                    },
                    {
                        "username": "anikethbr73",
                        "content": "I recommend  to keep track of nodes traversed until you reach the node previous to target node. then change the link in order to delete the node."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705EASY O(n) Optimized || Amazon\\uD83D\\uDD25| Microsoft\\uD83D\\uDCA5 | Adobe\\uD83D\\uDE0E\\nhttps://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/2890792/easy-o-n-optimized-amazon-microsoft-adobe/?orderBy=most_votes"
                    },
                    {
                        "username": "briecheese7",
                        "content": "For Java, I get that returning dummy.next skips the dummy node of 0. But what exactly does dummy.next do? How does it return this modified linkedlist?"
                    },
                    {
                        "username": "christopherblodgett",
                        "content": "Test 22 goes against the instructions of `1 <= n <= sz`, because head = [1,2] is smaller than n = 2. What gives with the bad documentation and or test?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "n and sz are equals in that case."
                    },
                    {
                        "username": "HarshExploring",
                        "content": "is these two pieces of code not same ???\\n\\n1) ListNode *node,*temp=head;\\n    \\n\\n2)ListNode *node=head;\\nListNode *temp=head;\\n\\nBecause when i am using the 1) the compiler is showing error."
                    },
                    {
                        "username": "blah777",
                        "content": "I solve this one in golang. But It seems the test stub calls removeNthFromEnd twice?\\nDo anyone get the same problem?"
                    },
                    {
                        "username": "Ajay_Singh9990",
                        "content": "why this types question is in medium level it must be in easy level ye direct\\nquestion hai no need to think too much, rather than many easy level questions gets more time to solve and also tricky Leetcode must maintain the level of questions "
                    },
                    {
                        "username": "___Toppo___",
                        "content": " #include<stdio.h>\\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n){\\n    int l = 0;\\n    struct ListNode* curr = head;\\n    struct ListNode* temp = head;\\n    \\n    while(curr!=NULL){\\n        curr = curr->next;\\n        l++;\\n    }\\n    \\n    int index = l-n;\\n    \\n    int i = 0;\\n    while(i<index-1){\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    temp->next = (temp->next)->next;\\n    return head;\\n}\\n\\nwhy is it showing runtime error for \"temp->next = (temp->next)->next;\" ???"
                    }
                ]
            },
            {
                "id": 1677246,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1673854,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1671271,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1671268,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1670269,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1668685,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1664371,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1662071,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1651400,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            },
            {
                "id": 1632513,
                "content": [
                    {
                        "username": "adityamishra19_",
                        "content": "//c++\\nListNode*reverselist(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode*recursedhead = reverselist(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return recursedhead;\\n    }\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode*ptr=reverselist(head);\\n        if(ptr==NULL || ptr->next==NULL) return NULL;\\n        if(n==1){\\n            ptr=ptr->next;\\n            return reverselist(ptr);\\n        }\\n        ListNode*ref=ptr;\\n        if(ref==NULL|| ref->next==NULL) return ref;\\n        int i=1;\\n        while(i!=n-1){\\n            ref=ref->next;\\n            i++;\\n        }\\n        ListNode*q=ref->next;\\n        ref->next=ref->next->next;\\n        delete(q);\\n        ListNode*adi=reverselist(ptr);\\n        return adi;\\n    }"
                    },
                    {
                        "username": "rampanda",
                        "content": "# Python solution simple and easy. Explained properly\n\n\nAproach1: We can traverse through the whole linked list once and get the lenght of the list, then subtract the\n                  nth node from end to ge that nth position from the start, again traverse untill you reach n-1th node \n\nApproach2: Here instead of traversing twice we will try to traverse only once. \n                   Create two node pointers i, j. Start j from (i+n)th node, so that when we reach end for jth node that \n                   time we will have ith node at nth from behind\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        tempi, tempj = head, head\n        i = 0 \n\n        # this condition will handle when we have only one element in the linked list\n        if not tempi.next:\n            return None\n\n        while i<n:\n            tempj = tempj.next\n            i+=1\n\n        # this condition handles when we need to remove head of the linked list\n        # only while will cause error, because tempj will be None,  So None.next will give error\n        if not tempj:\n            head = tempi.next\n        else:\n            while tempj.next: \n                tempi = tempi.next\n                tempj = tempj.next\n        tempi.next = tempi.next.next\n\n        return head \n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-nth-node-from-end-of-list-problem-solution.html)"
                    },
                    {
                        "username": "paddyveith987",
                        "content": "This question is silly in Python and super easy in C++, where you can pass by reference."
                    },
                    {
                        "username": "jmat",
                        "content": "Why is this code not working?\\n\\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\\n        curr = head\\n        second_pointer = head\\n        count = 1\\n        while curr.next:\\n            curr=curr.next\\n            if count > n:\\n                second_pointer = second_pointer.next\\n                print(curr.val, second_pointer.val)\\n            count +=1\\n\\n        second_pointer.next = second_pointer.next.next\\n\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, head, n):\\n        head.pop(-n)\\n        return head"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#python3\\nclass Solution:\\n    def removeNthFromEnd(self, list, n):\\n        list.pop(-n)\\n        return list\\n\\n\\nl = Solution()\\nprint(l.removeNthFromEnd([1,2,3,4,5], 2))\\nprint(l.removeNthFromEnd([1], 1))\\nprint(l.removeNthFromEnd([1,2], 1))\\n"
                    },
                    {
                        "username": "PriyankaTaneja",
                        "content": "java.lang.NullPointerException: Cannot read field \"next\" because \"<local6>.next\" is null\\n\\n    public ListNode removeNthFromEnd(ListNode head, int n) \\n    {\\n        int count = 0;\\n        ListNode temp = head;\\n            while(temp != null) {\\n                temp = temp.next;\\n                count++;\\n            }\\n        int pos = count-n+1;\\n    \\n        ListNode slow = head;\\n        for(int i=1;i<pos-1;i++) {  \\n            slow = slow.next;     \\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n\\nWhat\\'s wrong with this code, Can anyone suggest."
                    },
                    {
                        "username": "heyharshit",
                        "content": "dekho bakchodi toh karo mat"
                    }
                ]
            }
        ]
    },
    {
        "title": "Pascal's Triangle II",
        "question_content": "<p>Given an integer <code>rowIndex</code>, return the <code>rowIndex<sup>th</sup></code> (<strong>0-indexed</strong>) row of the <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 3\n<strong>Output:</strong> [1,3,3,1]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 0\n<strong>Output:</strong> [1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 1\n<strong>Output:</strong> [1,1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you optimize your algorithm to use only <code>O(rowIndex)</code> extra space?</p>\n",
        "solutions": [
            {
                "id": 38420,
                "title": "here-is-my-brief-o-k-solution",
                "content": "The basic idea is to iteratively update the array from the end to the beginning. \\n\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> A(rowIndex+1, 0);\\n            A[0] = 1;\\n            for(int i=1; i<rowIndex+1; i++)\\n                for(int j=i; j>=1; j--)\\n                    A[j] += A[j-1];\\n            return A;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> A(rowIndex+1, 0);\\n            A[0] = 1;\\n            for(int i=1; i<rowIndex+1; i++)\\n                for(int j=i; j>=1; j--)\\n                    A[j] += A[j-1];\\n            return A;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38467,
                "title": "very-simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        row = [1]\\n        for _ in range(rowIndex):\\n            row = [x + y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\\n\\nUpdated according to @greg-irl 's suggestion below. It runs 30% faster than using ```map()```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        row = [1]\\n        for _ in range(rowIndex):\\n            row = [x + y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\n```map()```",
                "codeTag": "Java"
            },
            {
                "id": 38584,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public List<Integer> getRow(int k) {\\n            Integer[] arr = new Integer[k + 1];\\n            Arrays.fill(arr, 0);\\n            arr[0] = 1;\\n            \\n            for (int i = 1; i <= k; i++) \\n                for (int j = i; j > 0; j--) \\n                    arr[j] = arr[j] + arr[j - 1];\\n            \\n            return Arrays.asList(arr);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> getRow(int k) {\\n            Integer[] arr = new Integer[k + 1];\\n            Arrays.fill(arr, 0);\\n            arr[0] = 1;\\n            \\n            for (int i = 1; i <= k; i++) \\n                for (int j = i; j > 0; j--) \\n                    arr[j] = arr[j] + arr[j - 1];\\n            \\n            return Arrays.asList(arr);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1203260,
                "title": "very-easy-o-n-time-0-ms-beats-100-simple-maths-all-languages",
                "content": "This solution here, is **Linear** in time.\\n\\n---\\nAs you know you can get any element of Pascal\\'s Triangle in **O(N)** time and constant space complexity. \\nfor first row first column we have **1C1**\\nfor second row first column we have **2C1**\\nfor second row second column we have **2C2**\\n..... and so on\\nTherefore we can infer, for ith row and jth column we have the number **iCj**\\n\\nAnd calculating this is pretty easy just in ***N*** time (factorial basically).\\n\\n==> `nCr = n*(n-1)*(n-2)...(r terms) /  1*2*..........*(r-2)*(r-1)*r`\\n\\nNow the question asks us to find the complete row.\\nIf we calculate all the elements in this manner it would be quadratic in time. But, since its formula is pretty sleek, we proceed as follows:\\n\\nsuppose we have **nCr** and we have to find **nC(r+1)**, like **5C3** and **5C4**\\n==> `5C3 = 5*4*3 / 1*2*3`\\n\\nto get the next term we multiply numerator with its next term and denominator with its next term. As, \\n==> `5C4 = 5*4*3 * 2 / 1*2*3 * 4`\\n\\nWe are following this simple maths logic to get the complete row in **O(N)** time.\\n\\n**Note:-** We didnt actually need the variable temp. But the test cases are such that multiplying in one case exceeds the **int range**, and since we cannot change return type we have to take the **long** data type variable as temporary.\\n\\n---\\n**Python Code:**\\nThe result for this code is **8 ms / 13.3 MB** (beats 99.82% / 88.54%): \\n```\\nclass Solution(object):\\n    def getRow(self, r):\\n        ans = [1]*(r+1);\\n        up = r\\n        down = 1\\n        for i in range(1, r):\\n            ans[i] = ans[i-1]*up/down;\\n            up = up - 1\\n            down = down + 1\\n        return ans;\\n```\\n\\n---\\n**Java Code:**\\nThe result for this code is **0 ms / 36.3 MB** (beats 100% / 91.45%): \\n```\\nclass Solution {\\n    public List<Integer> getRow(int r) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        long temp = 1;\\n        for(int i=1,up=r,down=1;i<=r;i++,up--, down++){\\n            temp=temp*up/down;\\n            ans.add((int)temp);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n**JavaScript Code:**\\nThe result for this code is **72 ms / 38.7 MB** (beats 90.29% / 40.05%): \\n```\\nvar getRow = function(r) {\\n    var ans = new Array(r+1)\\n    ans[0]=ans[r]=1\\n    for(i=1,up=r;i<r;i++,up--)\\n        ans[i] = ans[i-1]*up/i\\n    return ans\\n};\\n```\\n\\n---\\n**C++ Code:**\\nThe result for this code is **0 ms / 6.2 MB** (beats 100% / 84.20%): \\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1);\\n        long temp=1;\\n        v[0]=v[r]=1;\\n        for(int i=1,up=r,down=1;i<r;i++,up--,down++){\\n            temp = temp*up/down;\\n            v[i]=temp;\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n---\\n**C Code:**\\nThe result for this code is **0 ms / 5.6 MB** (beats 100% / 85.96%): \\n```\\nint* getRow(int r, int* rS){\\n    int*ans = calloc(r + 1, sizeof(int));\\n    long temp=1;\\n    ans[0]=1;\\n    for(int i=1,up=r;i<=r;i++,up--){\\n        temp=temp*up/i;\\n        ans[i]=temp;\\n    }\\n    *rS = r+1;\\n    return ans;\\n}\\n```\\n\\n---\\n\\n**C# Code:**\\nThe result for this code is **188 ms / 26.2 MB** (beats 99.37% / 69.62%): \\n```\\npublic class Solution {\\n    public IList<int> GetRow(int r) {\\n        var ans = new int[r+1];\\n        ans[0]=ans[r]=1;\\n        long temp=1;\\n        for(int i=1,up=r;i<r;i++,up--){\\n            temp = temp * up / i;\\n            ans[i]=(int)temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n**Ruby Code:**\\nThe result for this code is **48 ms / 209.8 MB** (beats 80.65% / 35.48%): \\n```\\ndef get_row(r)\\n    return [1] if r==0\\n    ans = [1]\\n    temp = 1\\n    for i in 1...r do\\n        temp = temp * (r-i+1)/i\\n        ans << temp\\n    end\\n    ans << 1\\n    return ans\\nend\\n```\\n\\n---\\n\\n**Switft Code:**\\nThe result for this code is **0 ms / 14 MB** (beats 100.00% / 68.04%)\\n```\\nclass Solution {\\n    func getRow(_ r: Int) -> [Int] {\\n        if r==0 {\\n            return [1]\\n        }\\n        var ans = [Int](repeating: 1, count: r+1)\\n        for i in 1...r {\\n            ans[i] = ans[i-1]*(r-i+1)/i\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n---\\n\\n**Go Code:**\\nThe result for this code is **0 ms / 2 MB** (beats 100.00% / 100.00%)\\n```\\nfunc getRow(r int) []int {\\n    var ans = make([]int,r+1)\\n    ans[0] = 1\\n    ans[r] = 1\\n    for i:=1; i<=r; i++ {\\n        ans[i] = ans[i-1]*(r-i+1)/i\\n    }\\n    return ans\\n}\\n```\\n\\n---\\n\\n**Scala Code:**\\nThe result for this code is **388 ms / 49.4 MB** (beats 100.00% / 95.00%)\\n**Note:** `implicit def` function is used to implicitly convert array to List\\n```\\nobject Solution {\\n    implicit def arrayToList[A](a: Array[A]) = a.toList\\n    def getRow(r: Int): List[Int] = {\\n        var ans = new Array[Int](r+1)\\n        ans(0) = 1\\n        var temp: Long = 1\\n        for( i <- 1 to r){\\n            temp = temp*(r-i+1)/i\\n            ans(i) = temp.asInstanceOf[Int]\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n---\\n\\n**Kotlin Code:**\\nThe result for this code is **132 ms / 33.1 MB** (beats 91.67% / 98.81%)\\n```\\nclass Solution {\\n    fun getRow(r: Int): List<Int> {\\n        var ans = MutableList<Int>(r+1){1}\\n        var temp: Long = 1\\n        for (i in 1..r){\\n            temp = temp*(r-i+1)/i\\n            ans[i] = temp.toInt()\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n---\\n\\n**Rust Code:**\\nThe result for this code is **0 ms /1.9 MB** (beats 100.00% / 92.31%)\\n```\\nimpl Solution {\\n    pub fn get_row(r: i32) -> Vec<i32> {\\n        let mut ans : Vec<i32> = Vec::new();  \\n        ans.push(1);\\n        let mut temp: i64 = 1;\\n        let mut up = r as i64;\\n        let mut down = 1 as i64;\\n        for i in 1..=r {\\n            temp = temp*up/down;\\n            ans.push(temp as i32);\\n            up-=1;\\n            down+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n**PHP Code:**\\nThe result for this code is **0 ms /15.7 MB** (beats 100.00% / 48.15%)\\n```\\nclass Solution {\\n    function getRow($r) {\\n        $ans = array(1);\\n        $temp = 1;\\n        for($i=1;$i<=$r;$i++){\\n            $temp = $temp*($r-$i+1)/$i;\\n            array_push($ans, $temp);\\n        }\\n        return $ans;\\n    }\\n}\\n```\\n\\n---\\n\\n**TypeScript Code:**\\nThe result for this code is **80 ms /39.2 MB** (beats 74.58% / 72.88%)\\n```\\nfunction getRow(r: number): number[] {\\n    var ans:number[] = [1]\\n    var temp:number = 1\\n    for(var i:number=1;i<=r;i++){\\n        temp = temp*(r-i+1)/i\\n        ans.push(temp)\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift"
                ],
                "code": "```\\nclass Solution(object):\\n    def getRow(self, r):\\n        ans = [1]*(r+1);\\n        up = r\\n        down = 1\\n        for i in range(1, r):\\n            ans[i] = ans[i-1]*up/down;\\n            up = up - 1\\n            down = down + 1\\n        return ans;\\n```\n```\\nclass Solution {\\n    public List<Integer> getRow(int r) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        long temp = 1;\\n        for(int i=1,up=r,down=1;i<=r;i++,up--, down++){\\n            temp=temp*up/down;\\n            ans.add((int)temp);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nvar getRow = function(r) {\\n    var ans = new Array(r+1)\\n    ans[0]=ans[r]=1\\n    for(i=1,up=r;i<r;i++,up--)\\n        ans[i] = ans[i-1]*up/i\\n    return ans\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1);\\n        long temp=1;\\n        v[0]=v[r]=1;\\n        for(int i=1,up=r,down=1;i<r;i++,up--,down++){\\n            temp = temp*up/down;\\n            v[i]=temp;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nint* getRow(int r, int* rS){\\n    int*ans = calloc(r + 1, sizeof(int));\\n    long temp=1;\\n    ans[0]=1;\\n    for(int i=1,up=r;i<=r;i++,up--){\\n        temp=temp*up/i;\\n        ans[i]=temp;\\n    }\\n    *rS = r+1;\\n    return ans;\\n}\\n```\n```\\npublic class Solution {\\n    public IList<int> GetRow(int r) {\\n        var ans = new int[r+1];\\n        ans[0]=ans[r]=1;\\n        long temp=1;\\n        for(int i=1,up=r;i<r;i++,up--){\\n            temp = temp * up / i;\\n            ans[i]=(int)temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\ndef get_row(r)\\n    return [1] if r==0\\n    ans = [1]\\n    temp = 1\\n    for i in 1...r do\\n        temp = temp * (r-i+1)/i\\n        ans << temp\\n    end\\n    ans << 1\\n    return ans\\nend\\n```\n```\\nclass Solution {\\n    func getRow(_ r: Int) -> [Int] {\\n        if r==0 {\\n            return [1]\\n        }\\n        var ans = [Int](repeating: 1, count: r+1)\\n        for i in 1...r {\\n            ans[i] = ans[i-1]*(r-i+1)/i\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nfunc getRow(r int) []int {\\n    var ans = make([]int,r+1)\\n    ans[0] = 1\\n    ans[r] = 1\\n    for i:=1; i<=r; i++ {\\n        ans[i] = ans[i-1]*(r-i+1)/i\\n    }\\n    return ans\\n}\\n```\n```\\nobject Solution {\\n    implicit def arrayToList[A](a: Array[A]) = a.toList\\n    def getRow(r: Int): List[Int] = {\\n        var ans = new Array[Int](r+1)\\n        ans(0) = 1\\n        var temp: Long = 1\\n        for( i <- 1 to r){\\n            temp = temp*(r-i+1)/i\\n            ans(i) = temp.asInstanceOf[Int]\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun getRow(r: Int): List<Int> {\\n        var ans = MutableList<Int>(r+1){1}\\n        var temp: Long = 1\\n        for (i in 1..r){\\n            temp = temp*(r-i+1)/i\\n            ans[i] = temp.toInt()\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn get_row(r: i32) -> Vec<i32> {\\n        let mut ans : Vec<i32> = Vec::new();  \\n        ans.push(1);\\n        let mut temp: i64 = 1;\\n        let mut up = r as i64;\\n        let mut down = 1 as i64;\\n        for i in 1..=r {\\n            temp = temp*up/down;\\n            ans.push(temp as i32);\\n            up-=1;\\n            down+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    function getRow($r) {\\n        $ans = array(1);\\n        $temp = 1;\\n        for($i=1;$i<=$r;$i++){\\n            $temp = $temp*($r-$i+1)/$i;\\n            array_push($ans, $temp);\\n        }\\n        return $ans;\\n    }\\n}\\n```\n```\\nfunction getRow(r: number): number[] {\\n    var ans:number[] = [1]\\n    var temp:number = 1\\n    for(var i:number=1;i<=r;i++){\\n        temp = temp*(r-i+1)/i\\n        ans.push(temp)\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38478,
                "title": "my-accepted-java-solution-any-better-code",
                "content": "      public List<Integer> getRow(int rowIndex) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif (rowIndex < 0)\\n\\t\\t\\treturn list;\\n\\n\\t\\tfor (int i = 0; i < rowIndex + 1; i++) {\\n\\t\\t\\tlist.add(0, 1);\\n\\t\\t\\tfor (int j = 1; j < list.size() - 1; j++) {\\n\\t\\t\\t\\tlist.set(j, list.get(j) + list.get(j + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}",
                "solutionTags": [],
                "code": "      public List<Integer> getRow(int rowIndex) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif (rowIndex < 0)\\n\\t\\t\\treturn list;\\n\\n\\t\\tfor (int i = 0; i < rowIndex + 1; i++) {\\n\\t\\t\\tlist.add(0, 1);\\n\\t\\t\\tfor (int j = 1; j < list.size() - 1; j++) {\\n\\t\\t\\t\\tlist.set(j, list.get(j) + list.get(j + 1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 38454,
                "title": "sharing-my-c-code-very-simple",
                "content": "    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> vi(rowIndex + 1);\\n           \\tvi[0] = 1;\\n            for (int i = 0; i <= rowIndex ; ++i)\\n            {\\n            \\tfor (int j = i; j > 0; --j)\\n            \\t{\\n    \\t        \\tvi[j] = vi[j] + vi[j-1];\\n            \\t}\\n            }\\n            return vi;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> vi(rowIndex + 1);\\n           \\tvi[0] = 1;\\n            for (int i = 0; i <= rowIndex ; ++i)\\n            {\\n            \\tfor (int j = i; j > 0; --j)\\n            \\t{\\n    \\t        \\tvi[j] = vi[j] + vi[j-1];\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 38437,
                "title": "my-8-lines-java-solution-use-arraylist",
                "content": "    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0;i<rowIndex+1;i++) {\\n        \\t\\tres.add(1);\\n        \\t\\tfor(int j=i-1;j>0;j--) {\\n        \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n        \\t\\t}\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0;i<rowIndex+1;i++) {\\n        \\t\\tres.add(1);\\n        \\t\\tfor(int j=i-1;j>0;j--) {\\n        \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n        \\t\\t}\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38473,
                "title": "java-o-k-solution-with-explanation",
                "content": "When generating each row, we can use the previous row directly, so this way we only use O(k) space with k being the number of row.  For each new row, we append a `1`, letting j iterate from `i - 1` backward to `1`, and set the `jth` element as `res.set(j, res.get(j-1) + res.get(j))`.  For example, when `k = 4`, the process goes like this:\\n\\n    k == 0\\n    [1] \\n    k == 1\\n    [11] \\n    k == 2\\n    [111]  add 1\\n    [121]  calculate jth spot\\n    k == 3\\n    [1211]  add 1\\n    [1331]   calculate jth spot\\n    k == 4\\n    [13311]  add 1\\n    [14641]  calculate jth spot\\n\\n\\nJava\\n\\n       public List<Integer> getRow(int rowIndex) {\\n            List<Integer> res = new ArrayList<>();\\n            for(int i = 0; i <= rowIndex; i++) {\\n                res.add(1);\\n                for(int j = i-1; j > 0; j--) {\\n                    res.set(j, res.get(j-1) + res.get(j));\\n                }\\n            }\\n            return res;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "When generating each row, we can use the previous row directly, so this way we only use O(k) space with k being the number of row.  For each new row, we append a `1`, letting j iterate from `i - 1` backward to `1`, and set the `jth` element as `res.set(j, res.get(j-1) + res.get(j))`.  For example, when `k = 4`, the process goes like this:\\n\\n    k == 0\\n    [1] \\n    k == 1\\n    [11] \\n    k == 2\\n    [111]  add 1\\n    [121]  calculate jth spot\\n    k == 3\\n    [1211]  add 1\\n    [1331]   calculate jth spot\\n    k == 4\\n    [13311]  add 1\\n    [14641]  calculate jth spot\\n\\n\\nJava\\n\\n       public List<Integer> getRow(int rowIndex) {\\n            List<Integer> res = new ArrayList<>();\\n            for(int i = 0; i <= rowIndex; i++) {\\n                res.add(1);\\n                for(int j = i-1; j > 0; j--) {\\n                    res.set(j, res.get(j-1) + res.get(j));\\n                }\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 38513,
                "title": "my-clean-o-k-java-solution",
                "content": "Based on rules:\\n\\nrow k of Pascal's Triangle: \\n\\n`[C(k,0), C(k,1), ..., C(k, k-1), C(k, k)]`\\n\\nand\\n\\n`C[k,i] = C[k,i-1]*(k-i+1)/i`\\n\\n \\n \\n\\n        public class Solution {\\n            public List<Integer> getRow(int rowIndex) {\\n                Integer[] rowList = new Integer[rowIndex+1];\\n                rowList[0] = 1;\\n                for(int i=1; i<rowList.length;i++) {\\n                    rowList[i] = (int)((long)rowList[i-1]*(rowIndex-(i-1))/(i));\\n                }\\n                return Arrays.asList(rowList);\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public List<Integer> getRow(int rowIndex) {\\n                Integer[] rowList = new Integer[rowIndex+1];\\n                rowList[0] = 1;\\n                for(int i=1; i<rowList.length;i++) {\\n                    rowList[i] = (int)((long)rowList[i-1]*(rowIndex-(i-1))/(i));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 38482,
                "title": "my-12-lines-of-c-solution-in-2ms-with-only-one-loop-o-k-time-and-o-k-space",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans(rowIndex+1,1);\\n        int small = rowIndex/2;\\n        long comb = 1;\\n        int j = 1;\\n        for (int i=rowIndex; i>=small; i--){\\n            comb *= i;\\n            comb /= j;\\n            j ++;\\n            ans[i-1] = (int)comb;\\n            ans[j-1] = (int)comb;\\n        }\\n        return ans;\\n    }\\n\\n};\\n\\nNote that this solution is math derived from number of Combinations. \\n\\nEach line of Pascal's Triangle is a full set of Combination number based on k .\\n\\ncomb(k,p) = k! /( p! *(k-p)!) = comb(k,k-p)\\n\\nif p < k-p\\n\\ncomb(k,p) = comb(k,p-1) * (k-p+1) / p\\n\\n                                          \\nBecause :\\n\\ncomb(k,p) =     [ k * (k-1) * (k-2) *... (k-p+1)] /   [1 * 2      * 3       *...(p)]",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans(rowIndex+1,1);\\n        int small = rowIndex/2;\\n        long comb = 1;\\n        int j = 1;\\n        for (int i=rowIndex; i>=small; i--){\\n            comb *= i;\\n            comb /= j;\\n            j ++;\\n            ans[i-1] = (int)comb;\\n            ans[j-1] = (int)comb;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1697627,
                "title": "understand-the-recursive-approach",
                "content": "1. What we know?\\n    - We Know that, if `rowIndex==0` (first row) then we only have `{1}` in the row.\\n    - We also know that first and last element of our row will be `1` **always**.\\n    - We also Know that we can find `currentRow[i]` by adding `previousRow[i-1]` and `previousRow[i]`.\\n2. Data for recursion,\\n    - from above discussion, now we can get 2 important things for recursion\\n    1. **Base Case:** `if(rowIndex==0) return {1};`\\n    2. **Recurrence Relation:** `currentRow[i] = (previousRow[i-1]+previousRow[i]);`\\n> Before reading out please give it a try now.\\n3. Algorithm\\n    - We can start with `currentRow[0] = 1`\\n    - Now **believe** that, we get the previous row with recursive call `previousRow = getRow(rowIndex-1);`\\n    - Then fill the remaining elements of current row with recurrence relation \\n        `currentRow[i] = (previousRow[i-1]+previousRow[i]);`\\n    - As we know, last element of row is 1, push 1 in the vector.\\n    - Return the current row i.e. `currentRow`.\\n\\n### C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1}; // Base Case\\n\\n        vector<int> currentRow = {1}; // current row with 1 value in it\\n        vector<int> previousRow = getRow(rowIndex-1); // get the previous row\\n\\n        // Now fill the current row based on previous row\\n        for(int i=1;i<rowIndex;i++){\\n            currentRow.push_back(previousRow[i-1]+previousRow[i]);\\n        }\\n\\n        currentRow.push_back(1); // fill the last element of current row\\n        return currentRow;\\n    }\\n};\\n```\\n\\n**If you like it then please upvote !**\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1}; // Base Case\\n\\n        vector<int> currentRow = {1}; // current row with 1 value in it\\n        vector<int> previousRow = getRow(rowIndex-1); // get the previous row\\n\\n        // Now fill the current row based on previous row\\n        for(int i=1;i<rowIndex;i++){\\n            currentRow.push_back(previousRow[i-1]+previousRow[i]);\\n        }\\n\\n        currentRow.push_back(1); // fill the last element of current row\\n        return currentRow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38574,
                "title": "simple-python-5-lines-36ms",
                "content": "    def getRow(rowIndex):\\n        pascal = [1]*(rowIndex + 1)\\n        for i in range(2,rowIndex+1):\\n            for j in range(i-1,0,-1):\\n                pascal[j] += pascal[j-1]\\n        return pascal",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def getRow(rowIndex):\\n        pascal = [1]*(rowIndex + 1)\\n        for i in range(2,rowIndex+1):\\n            for j in range(i-1,0,-1):\\n                pascal[j] += pascal[j-1]\\n        return pascal",
                "codeTag": "Python3"
            },
            {
                "id": 38438,
                "title": "7-lines-c-solution-one-pass-o-k-space-for-return-with-detailed-explanation",
                "content": "We know that the elements of the ith line of pascal triangle is just the coefficients of the expansion of \\n\\n> (a + b) ^ i\\n\\nFor example, the 4th line:\\n\\n> 1 4 6 4 1  \\n(a + b) ^ 4 = a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + b^4\\n\\nAnd the we know the coefficients can be computed by composition. For the above example, the coefficients are respectively C(4, 0), C(4, 1), C(4, 2), C(4, 3), C(4, 4).\\n\\nThen we have the following code:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ret(rowIndex + 1, 1);\\n        long C = 1;\\n        for (int i = 1; i < rowIndex; i++) {\\n            C = C * (rowIndex - i + 1) / i;\\n            ret[i] = C;\\n        }\\n        return ret;\\n    }\\n\\nNotice that C(n, i) = C(n, n - i). We can optimize the code for only computing the first half.I didn't do the optimization here for simplicity.",
                "solutionTags": [],
                "code": "We know that the elements of the ith line of pascal triangle is just the coefficients of the expansion of \\n\\n> (a + b) ^ i\\n\\nFor example, the 4th line:\\n\\n> 1 4 6 4 1  \\n(a + b) ^ 4 = a^4 + 4a^3b + 6a^2b^2 + 4ab^3 + b^4\\n\\nAnd the we know the coefficients can be computed by composition. For the above example, the coefficients are respectively C(4, 0), C(4, 1), C(4, 2), C(4, 3), C(4, 4).\\n\\nThen we have the following code:\\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ret(rowIndex + 1, 1);\\n        long C = 1;\\n        for (int i = 1; i < rowIndex; i++) {\\n            C = C * (rowIndex - i + 1) / i;\\n            ret[i] = C;\\n        }\\n        return ret;\\n    }\\n\\nNotice that C(n, i) = C(n, n - i). We can optimize the code for only computing the first half.I didn't do the optimization here for simplicity.",
                "codeTag": "Unknown"
            },
            {
                "id": 727336,
                "title": "c-simple-and-short-solution-0-ms-beats-100",
                "content": "```\\n// Please, UpVote, if you like it :-) Thank you\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, UpVote, if you like it :-) Thank you\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38645,
                "title": "c-solution-0ms-one-pass-no-extra-space",
                "content": "Two considerations:\\n1) At Nth row, each k-th element is determined by a well-known formula: C(n, k) = n! / (k!*(n-k)!). Obviously, we don't want to calculate factorial each time since we need to fill in the whole row, so we can just multiply both the numerator and denominator sequentially\\n\\n2) A row in Pascal triangle is always symmetric, so we fill up two elements at each loop iteration\\n\\nA drawback: In order to avoid overflows, we need to employ ugly casts to unsigned long\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> r;\\n            r.resize(rowIndex + 1);\\n            r[0] = r[rowIndex] = 1;\\n            for(auto i = 1; i < (r.size() + 1)/2; ++i)\\n            {\\n                r[i] = r[rowIndex - i] = (unsigned long)r[i - 1]*(unsigned long)(rowIndex - i + 1)/i;\\n            }\\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> r;\\n            r.resize(rowIndex + 1);\\n            r[0] = r[rowIndex] = 1;\\n            for(auto i = 1; i < (r.size() + 1)/2; ++i)\\n            {\\n                r[i] = r[rowIndex - i] = (unsigned long)r[i - 1]*(unsigned long)(rowIndex - i + 1)/i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38598,
                "title": "elegant-javascript-o-k-space-solution",
                "content": "    var getRow = function(rowIndex) {\\n        var row = [1];\\n        \\n        for(var i = 1 ; i <= rowIndex ; i++) {\\n            for(var j = i; j > 0; j--) {\\n                if(j === i)\\n                    row[j] = 1;\\n                else\\n                    row[j] = row[j - 1] + row[j];\\n            }\\n        }\\n        return row;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var getRow = function(rowIndex) {\\n        var row = [1];\\n        \\n        for(var i = 1 ; i <= rowIndex ; i++) {\\n            for(var j = i; j > 0; j--) {\\n                if(j === i)\\n                    row[j] = 1;\\n                else\\n                    row[j] = row[j - 1] + row[j];\\n            }\\n        }\\n        return row;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1552264,
                "title": "3-lines-code-space-o-1-and-time-o-rowindex-no-dp-no-recursion",
                "content": "let say rowIndex = n\\n```\\nwe have entries like\\n4C0  4C1 , 4C2 4C3 4C4\\n```\\n` #now if we calculate factorial then nCr , will give  `**overflow** \\n\\n## So what we do is calculate nCr+1 from nCr\\n![image](https://assets.leetcode.com/users/images/47267fd3-4d4a-4391-8072-65a53979934f_1635747712.5746357.jpeg)\\n\\n\\n#### *Here n is rowindex , and r is column* \\n\\n```\\n\\nclass Solution {\\n   public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ans = new ArrayList<>();                \\n        long val=1;\\n\\t\\t\\n        for(int j = 0; j <= rowIndex; j++){\\n                ans.add((int)val );\\n                val = (val * (rowIndex - j)) / (j + 1);\\n            }\\n\\t\\t\\t\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwe have entries like\\n4C0  4C1 , 4C2 4C3 4C4\\n```\n```\\n\\nclass Solution {\\n   public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ans = new ArrayList<>();                \\n        long val=1;\\n\\t\\t\\n        for(int j = 0; j <= rowIndex; j++){\\n                ans.add((int)val );\\n                val = (val * (rowIndex - j)) / (j + 1);\\n            }\\n\\t\\t\\t\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177710,
                "title": "best-c-2-solutions-ever-dp-tabulation-bottom-up-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Two Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\\n2. Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which creates the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of program.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> output(rowIndex+1);\\n        for(int i=0; i<=rowIndex; i++){\\n            output[i].resize(i+1, 1);\\n            for(int j=1; j<i; j++){\\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\\n            }\\n        }\\n        return output.back();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> output(rowIndex+1, 0);\\n        output[0] = 1;\\n        for(int i=0; i<rowIndex; i++){\\n            for(int j=i+1; j>=1; j--){\\n                output[j] += output[j-1];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating 2D Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 2D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> output(rowIndex+1);\\n        for(int i=0; i<=rowIndex; i++){\\n            output[i].resize(i+1, 1);\\n            for(int j=1; j<i; j++){\\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\\n            }\\n        }\\n        return output.back();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the rowIndex+1. Here total number of iterations are : N*(N+1)/2 which\\n    creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating Array(output) as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up) With 1D Array(output) Extra Space.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> output(rowIndex+1, 0);\\n        output[0] = 1;\\n        for(int i=0; i<rowIndex; i++){\\n            for(int j=i+1; j>=1; j--){\\n                output[j] += output[j-1];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626185,
                "title": "0-ms-beats-100-99-19-possibly-best-solution-with-explanation",
                "content": "# Using temp vector || 0ms\\nBased on fact that : nCr = n-1Cr-1 + n-1Cr\\n```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        vector<int> temp = dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = 1; j < i; j++) {\\n                temp[j] = dp[j] + dp[j-1];\\n            }\\n            dp = temp;\\n        }\\n        return dp;\\n    }\\n```\\n\\n# Space optimization\\n```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = i-1; j >= 1; j--) {\\n                dp[j] = dp[j] + dp[j-1];\\n            }\\n        }\\n        return dp;\\n    }\\n```\\n\\n# Optimal (beats 100% / 99.19%)\\nBased on fact :\\nSince 4C1 = 4/1 ,  4C2 = 4  *3/1  *2  ,  4C3 = 4*3  *2 /1*2  *3\\nLet up = 4,  down = 1 And we can observe that \\n4C1 = up/down\\n4C2 = 4C1 *[ (up-1) / (down+1) ]\\n......\\n```\\n\\tvector<int> getRow(int n) {\\n        vector<int> res(n+1);\\n        res[0] = res[n] = 1;\\n        long temp = 1;\\n        int up = n, down = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * up /down;\\n            res[i] = temp;\\n            up--;down++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        vector<int> temp = dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = 1; j < i; j++) {\\n                temp[j] = dp[j] + dp[j-1];\\n            }\\n            dp = temp;\\n        }\\n        return dp;\\n    }\\n```\n```\\n\\tvector<int> getRow(int rowIndex) {\\n        vector<int> dp(rowIndex+1, 1);\\n        if(rowIndex <= 1) return dp;\\n        for(int i = 2; i <= rowIndex; i++) {\\n            for(int j = i-1; j >= 1; j--) {\\n                dp[j] = dp[j] + dp[j-1];\\n            }\\n        }\\n        return dp;\\n    }\\n```\n```\\n\\tvector<int> getRow(int n) {\\n        vector<int> res(n+1);\\n        res[0] = res[n] = 1;\\n        long temp = 1;\\n        int up = n, down = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * up /down;\\n            res[i] = temp;\\n            up--;down++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38629,
                "title": "my-simple-python-solution",
                "content": "    class Solution(object):\\n        def getRow(self, rowIndex):\\n            row = [1]\\n            for i in range(1, rowIndex + 1):\\n                row = [1] + [ row[x] + row[x - 1] for x in range(1, i)] + [1]\\n            return row",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def getRow(self, rowIndex):\\n            row = [1]\\n            for i in range(1, rowIndex + 1):\\n                row = [1] + [ row[x] + row[x - 1] for x in range(1, i)] + [1]\\n            return row",
                "codeTag": "Java"
            },
            {
                "id": 787858,
                "title": "python-2-solution-using-combination-formula-o-n-o-n-beats-97-submission",
                "content": "When we\\'re talking about Pascal\\'s Triangle, we\\'re acctually discussing about grabbing a specific value, from a specific row.\\nFor example, when doing statistics, we often end up needing to compute \"nCk\" (Binomial Coefficients) which systematically resolve themselves to the \"Kth value of the Nth row of Pascal\\'s Triangle\".\\nThe default algorithm for this is:\\n![image](https://assets.leetcode.com/users/images/9e77ced7-6cc5-47bc-b60b-32ccd72e0c68_1597242485.9083786.png)\\nWe can improve this calculation by using Combination Formula:\\n\\n***C(n,k+1) = C(n,k)  (n-k) / (k+1)***\\n\\n#### **Implemention:**\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [1]\\n        \\n        for i in range(1, rowIndex + 1):\\n            triangle.append(int(triangle[i - 1] * (rowIndex - (i - 1)) / i))\\n        \\n        return triangle\\n```\\n\\nThere\\'s some things we can do to above function to improve it\\'s execution time.\\n* We don\\'t need to compute the full row, it mirrors itself at the center. So, we only need to compute the first half.\\n* We shouldn\\'t be calling append in the inner loop so many times. Instead of this we can pre-allocate the full row in one call, and index into it as we need.\\n\\n#### **Implemention:**\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [0] * (rowIndex + 1)\\n        triangle[0] = triangle[rowIndex] = 1\\n        \\n        for i in range(0, rowIndex >> 1):\\n            col_val = triangle[ i ] * (rowIndex - i) / (i + 1)\\n            triangle[i + 1]= triangle[rowIndex - 1 - i] = int(col_val)\\n\\n        return triangle\\n```\\n **Study:**\\n [Pascal\\'s Triangle - Wiki Pedia](https://en.wikipedia.org/wiki/Pascal\\'s_triangle)\\n [Pascal\\'s Triangle - Math World](https://mathworld.wolfram.com/PascalsTriangle.html)\\n [Binomial Coefficients](https://mathworld.wolfram.com/BinomialCoefficient.html)\\n \\nPlease feel free to ans any question and give suggestions.\\n***If you like this solutions then please upvote it.***",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [1]\\n        \\n        for i in range(1, rowIndex + 1):\\n            triangle.append(int(triangle[i - 1] * (rowIndex - (i - 1)) / i))\\n        \\n        return triangle\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [0] * (rowIndex + 1)\\n        triangle[0] = triangle[rowIndex] = 1\\n        \\n        for i in range(0, rowIndex >> 1):\\n            col_val = triangle[ i ] * (rowIndex - i) / (i + 1)\\n            triangle[i + 1]= triangle[rowIndex - 1 - i] = int(col_val)\\n\\n        return triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38586,
                "title": "c-4-lines-solution-using-math-6-lines-solution-using-for-loop-both-0ms",
                "content": "     \\n\\n Based on math, the kth element for nth row is C(n, k) = n! / (k!*(n-k)!),  then res[k] = res[n - k]\\n \\n\\n so the relationship between res[i] and res[i-1] is  n! / (k!*(n-k)!) / n! **/** ((k-1)!*(n-k + 1)!) = (n - k + 1) / k;\\n   \\n\\n     vector<int> getRow(int rowIndex) {\\n       vector<int> res(rowIndex + 1, 1);\\n       for(int k = 1; k <= (rowIndex + 1)/2; k++)\\n            res[k] = res[rowIndex - k] = (long)res[k - 1]*(long)(rowIndex - k + 1)/k;\\n       return res;\\n    }\\n\\n   // normal loop \\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> res;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            res.push_back(1);\\n            for (int j = i - 1; j >= 1; --j) res[j] = res[j] + res[j-1];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     \\n\\n Based on math, the kth element for nth row is C(n, k) = n! / (k!*(n-k)!),  then res[k] = res[n - k]\\n \\n\\n so the relationship between res[i] and res[i-1] is  n! / (k!*(n-k)!) / n! **/** ((k-1)!*(n-k + 1)!) = (n - k + 1) / k;\\n   \\n\\n     vector<int> getRow(int rowIndex) {\\n       vector<int> res(rowIndex + 1, 1);\\n       for(int k = 1; k <= (rowIndex + 1)/2; k++)\\n            res[k] = res[rowIndex - k] = (long)res[k - 1]*(long)(rowIndex - k + 1)/k;\\n       return res;\\n    }\\n\\n   // normal loop \\n\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> res;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            res.push_back(1);\\n            for (int j = i - 1; j >= 1; --j) res[j] = res[j] + res[j-1];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38444,
                "title": "here-is-my-o-n-solution-and-the-proof",
                "content": "the mth element of  the nth row of the Pascal's triangle is C(n, m) = n!/(m! * (n-m)!)\\n\\nC(n, m-1) = n!/((m-1)! * (n-m+1)!)\\n\\nso C(n, m) = C(n, m-1) * (n-m+1) / m\\n\\nIn additional, C(n, m) == C(n, n-m)\\n\\n      class Solution {\\n        public:\\n            vector<int> getRow(int rowIndex) {\\n                vector<int> row;\\n                if(rowIndex < 0) {\\n                \\treturn row;\\n                }\\n                row.resize(rowIndex + 1);\\n                row[0] = row[rowIndex] = 1;\\n                for(int m =1; m < rowIndex /2 + 1; m++) {\\n                \\trow[m] = row[rowIndex - m] = ((long long int)row[m - 1] * (rowIndex - m + 1)) / m;\\n                }\\n                return row;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector<int> getRow(int rowIndex) {\\n                vector<int> row;\\n                if(rowIndex < 0) {\\n                \\treturn row;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 787212,
                "title": "python-two-o-k-memory-oneliners-explained",
                "content": "### Solution 1\\n\\nWhat we need to do in this problem is to follow definition. Let us generate row `r` and do `k` iterations until we reached desired `k`-tho row. How we generate next row, using current? We need:\\n1. Add `1` to the beginning of new row.\\n2. Evaluate sums of elements with indexes differ by `1`.\\n3. Add `1` to the end of new row.\\n\\nThis can be written as `[1]+[r[j]+r[j+1] for j in range(len(r)-1)]+[1]`.\\n\\nWhat we need to do now is to repeat this `k` times and this is all, we can use `reduce` function to do it.\\n\\n**Complexity**: space complexity as it asked is only `O(k)`, each moment of time we have only one(two) rows. Time complexity is `O(k^2)` because for each row we do `k` iterations. Theoretically time complexity can be reduced to `O(k)` if we use direct formulas for elements of pascal triangle, but `k` is very small and there will no be difference in this problem.\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        return reduce(lambda r,_:[1]+[r[j]+r[j+1] for j in range(len(r)-1)]+[1], range(rowIndex),[1])\\n```\\n\\n### Solution 2\\n\\nLet us note, that `1001^5 = 1 005 010 010 005 001`, so if we want to find row of Pascal triangle for small numbers `k`, then we can just use power of number `1000...001` and then split it into parts. For thes problem it is enough to take `10000000001` and then split by blocks with size `10`. \\n\\n**Complexity**: Space complexity is also `O(k)`, but more like `O(10k)`, because we have string of length `10k` in the end. Time complexity is more difficult to compute, I think it is `O(k)` also.\\n\\n```\\nclass Solution:\\n    def getRow(self, k):\\n        return [1] + [int(str((10**10+1)**k)[-10*(i+1):-10*i]) for i in range(1,k+1)]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        return reduce(lambda r,_:[1]+[r[j]+r[j+1] for j in range(len(r)-1)]+[1], range(rowIndex),[1])\\n```\n```\\nclass Solution:\\n    def getRow(self, k):\\n        return [1] + [int(str((10**10+1)**k)[-10*(i+1):-10*i]) for i in range(1,k+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712268,
                "title": "python-easy-to-read-recursion",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex+1)\\n        if rowIndex == 0: return row\\n        prev_row = self.getRow(rowIndex-1)\\n        for i in range(1, len(row)-1):\\n            row[i] = prev_row[i-1] + prev_row[i]\\n        return row",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex+1)\\n        if rowIndex == 0: return row\\n        prev_row = self.getRow(rowIndex-1)\\n        for i in range(1, len(row)-1):\\n            row[i] = prev_row[i-1] + prev_row[i]\\n        return row",
                "codeTag": "Java"
            },
            {
                "id": 3527485,
                "title": "c-java-python-javascript-5-lines-of-code-easy-to-understand",
                "content": "# Intuition:\\nThis solution is based on Pascal\\'s Triangle, where each element in a row is the sum of the two elements directly above it. By initializing the row with 1s and then calculating each element based on the previous row, we can generate the desired row efficiently.\\n\\n# Approach:\\n1. Initialize a vector called row with rowIndex+1 elements, all of which are set to 1. This is the first row in Pascal\\'s Triangle.\\n2. Iterate through each row of Pascal\\'s Triangle up to and including the desired rowIndex. For each row:\\n   a. Starting from the second last element of the row, iterate backwards to the second element, and update each element as the sum of the two elements directly above it.\\n3. Return the final row.\\n\\n# Complexity:\\n- Time Complexity: O(rowIndex^2)\\n    - The outer loop runs rowIndex times, and the inner loop runs i-1 times for each i, resulting in a total of 1+2+3+...+rowIndex = rowIndex*(rowIndex+1)/2 iterations. Since this is O(rowIndex^2), the time complexity of the algorithm is O(rowIndex^2).\\n\\n- Space Complexity: O(rowIndex)\\n    - The space complexity of the algorithm is O(rowIndex) since we only store a single row of Pascal\\'s Triangle at a time.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        vector<int> row(rowIndex + 1, 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            for (int j = i - 1; j > 0; --j) {\\n                row[j] = row[j] + row[j - 1];\\n            }\\n        }\\n        return row;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java\\n```java\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        List<Integer> row = new ArrayList<>(rowIndex + 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            row.add(1);\\n            for (int j = i - 1; j > 0; --j) {\\n                row.set(j, row.get(j) + row.get(j - 1));\\n            }\\n        }\\n        return row;\\n    }\\n}\\n```\\n---\\n\\n# Python\\n```py\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        # Initialize the row with 1s\\n        row = [1] * (rowIndex + 1) \\n        # Calculate each element of the row based on the previous row\\n        for i in range(rowIndex + 1):\\n            for j in range(i - 1, 0, -1):\\n                row[j] = row[j] + row[j - 1]\\n        return row\\n\\n```\\n---\\n\\n# JavaScript\\n```js\\nvar getRow = function(rowIndex) {\\n    // Initialize the row with 1s\\n    var row = new Array(rowIndex + 1).fill(1);  \\n    // Calculate each element of the row based on the previous row\\n    for (var i = 0; i <= rowIndex; ++i) {\\n        for (var j = i - 1; j > 0; --j) {\\n            row[j] = row[j] + row[j - 1];\\n        }\\n    }\\n    return row;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        vector<int> row(rowIndex + 1, 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            for (int j = i - 1; j > 0; --j) {\\n                row[j] = row[j] + row[j - 1];\\n            }\\n        }\\n        return row;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        // Initialize the row with 1s\\n        List<Integer> row = new ArrayList<>(rowIndex + 1);  \\n        // Calculate each element of the row based on the previous row\\n        for (int i = 0; i <= rowIndex; ++i) {\\n            row.add(1);\\n            for (int j = i - 1; j > 0; --j) {\\n                row.set(j, row.get(j) + row.get(j - 1));\\n            }\\n        }\\n        return row;\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        # Initialize the row with 1s\\n        row = [1] * (rowIndex + 1) \\n        # Calculate each element of the row based on the previous row\\n        for i in range(rowIndex + 1):\\n            for j in range(i - 1, 0, -1):\\n                row[j] = row[j] + row[j - 1]\\n        return row\\n\\n```\n```js\\nvar getRow = function(rowIndex) {\\n    // Initialize the row with 1s\\n    var row = new Array(rowIndex + 1).fill(1);  \\n    // Calculate each element of the row based on the previous row\\n    for (var i = 0; i <= rowIndex; ++i) {\\n        for (var j = i - 1; j > 0; --j) {\\n            row[j] = row[j] + row[j - 1];\\n        }\\n    }\\n    return row;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467945,
                "title": "pythonic-o-k-space-sol-based-on-math-formula-90",
                "content": "[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/new-editor/65124b7ffd89780001d7ff9e)\\n\\nPythonic O( k ) space sol. based on math formula\\n\\nReference:\\nhttps://en.wikipedia.org/wiki/Pascal\\'s_triangle\\n\\n```\\nfrom math import factorial\\n\\nclass Solution:\\n    \\n    def comb(self, n, m):\\n        \\n        if n == m or m == 0:\\n            return 1\\n        else:\\n            return factorial(n) // ( factorial(m) * factorial(n-m) )\\n\\n        \\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        # the coefficient of level k is as following\\n        #\\n        # C(k,0), C(k,1), ... , C(k,k)\\n        \\n        return [ self.comb(rowIndex,i) for i in range(0, rowIndex+1) ]\\n```\\n\\n---\\n\\nWatch the gif and observe the generation pattern could help a lot\\nhttps://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\\n\\n\\nAnother **Implementation** by recursion:\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        if rowIndex == 0:\\n            # Base case\\n            return [1]\\n        \\n        elif rowIndex == 1:\\n            # Base case\\n            return [1, 1]\\n        \\n        else:\\n            # General case:\\n            last_row = self.getRow( rowIndex-1 )\\n            size = len(last_row)\\n            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfrom math import factorial\\n\\nclass Solution:\\n    \\n    def comb(self, n, m):\\n        \\n        if n == m or m == 0:\\n            return 1\\n        else:\\n            return factorial(n) // ( factorial(m) * factorial(n-m) )\\n\\n        \\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        # the coefficient of level k is as following\\n        #\\n        # C(k,0), C(k,1), ... , C(k,k)\\n        \\n        return [ self.comb(rowIndex,i) for i in range(0, rowIndex+1) ]\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        if rowIndex == 0:\\n            # Base case\\n            return [1]\\n        \\n        elif rowIndex == 1:\\n            # Base case\\n            return [1, 1]\\n        \\n        else:\\n            # General case:\\n            last_row = self.getRow( rowIndex-1 )\\n            size = len(last_row)\\n            return [ last_row[0] ] + [ last_row[idx] + last_row[idx+1] for idx in range( size-1) ] + [ last_row[-1] ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122469,
                "title": "c-accepted-easy-explanation-0ms-beats-100",
                "content": "**Approach for Pascal\\'s Triangle II**\\n\\nTaking up the vector array upto the given index, i.e rowIndex.\\n=> push_back(1) to the array at each iteration.\\nBasic flow of calculating the given rowIndex of Pascal\\'s triangle\\uD83D\\uDC47.\\n\\n*First iteration*:\\n```\\n1 \\n```\\n*2nd iteration* :\\n``` \\n1,1 \\n```\\n*3rd iteration*\\n``` \\n1,1,1\\n1,2,1 <= final row\\n```\\n*4th iteration*\\n```\\n1,2,1,1\\n1,3,3,1 <= final row \\n```\\nHere what\\'s happening, we are pushing 1 to the previous row and then modifying it by changing the elements(except first and lastelement).\\nThe modification is => the value of the particular index eg. \\n``` \\n1,2,1,1=> {1,(1+2),(2+1),1} => {1,3,3,1} \\n```\\n``` \\n1,1,1=> {1,(1+1),1} => {1,2,1}\\n```\\n``` \\n1,3,3,1,1=> {1,(1+3),(3+3),(3+1),1} => {1,4,6,4,1}\\n```\\n\\n#### Here\\'s the whole code \\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n       vector<int> r;\\n       for(int i=0;i<=rowIndex;i++){\\n           r.push_back(1);\\n           for(int j=i-1;j>=1;--j){\\n               r[j]=r[j]+r[j-1];\\n           }\\n       }\\n       return r;\\n    }\\n};\\n```\\n### Please upvote if you liked the explaination :) thanks \\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1 \\n```\n``` \\n1,1 \\n```\n``` \\n1,1,1\\n1,2,1 <= final row\\n```\n```\\n1,2,1,1\\n1,3,3,1 <= final row \\n```\n``` \\n1,2,1,1=> {1,(1+2),(2+1),1} => {1,3,3,1} \\n```\n``` \\n1,1,1=> {1,(1+1),1} => {1,2,1}\\n```\n``` \\n1,3,3,1,1=> {1,(1+3),(3+3),(3+1),1} => {1,4,6,4,1}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n       vector<int> r;\\n       for(int i=0;i<=rowIndex;i++){\\n           r.push_back(1);\\n           for(int j=i-1;j>=1;--j){\\n               r[j]=r[j]+r[j-1];\\n           }\\n       }\\n       return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040210,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic List<Integer> getRow(int rowIndex) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    for(int i = 0;i<rowIndex+1;i++) {\\n    \\t\\tres.add(1);\\n    \\t\\tfor(int j=i-1;j>0;j--) {\\n    \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n    \\t\\t}\\n    }\\n    return res;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar getRow = function(rowIndex) {\\n    return findRow([1], rowIndex);\\n};\\n\\nconst findRow = (arr, depth) => {\\n    if (arr.length - 1 === depth) return arr;\\n    \\n    const newArr = new Array(arr.length + 1);\\n    for (let i = 0; i < newArr.length; i++) {\\n        const l = arr[i - 1] || 0;\\n        const r = arr[i] || 0;\\n        newArr[i] = l + r;\\n    }\\n    \\n    return findRow(newArr, depth);\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun getRow(rowIndex: Int): List<Int> {\\n        var initial = listOf<Int>(1)\\n        if (rowIndex == 0) return initial\\n        for (i in 0..rowIndex) {\\n            val current = mutableListOf<Int>(1)\\n            for (j in 1 until i) {\\n                current.add(initial[j] + initial[j-1])\\n            }\\n            current.add(1)\\n            initial = current\\n        }\\n        return initial\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic List<Integer> getRow(int rowIndex) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    for(int i = 0;i<rowIndex+1;i++) {\\n    \\t\\tres.add(1);\\n    \\t\\tfor(int j=i-1;j>0;j--) {\\n    \\t\\t\\tres.set(j, res.get(j-1)+res.get(j));\\n    \\t\\t}\\n    }\\n    return res;\\n}\\n```\n```\\n```\n```\\n```\n```\\nvector<int> getRow(int rowIndex) {\\n\\tvector<int> ret { 1 }, cur { 1 };\\n\\tfor (int i = 1; i <= rowIndex; i++) {\\n\\t\\tret.push_back(1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tret[j] = cur[j] + cur[j - 1];\\n\\t\\t}\\n\\t\\tcur = ret;\\n\\t}\\n\\treturn ret;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```\n```\\n```\n```\\n```\n```\\nvar getRow = function(rowIndex) {\\n    return findRow([1], rowIndex);\\n};\\n\\nconst findRow = (arr, depth) => {\\n    if (arr.length - 1 === depth) return arr;\\n    \\n    const newArr = new Array(arr.length + 1);\\n    for (let i = 0; i < newArr.length; i++) {\\n        const l = arr[i - 1] || 0;\\n        const r = arr[i] || 0;\\n        newArr[i] = l + r;\\n    }\\n    \\n    return findRow(newArr, depth);\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun getRow(rowIndex: Int): List<Int> {\\n        var initial = listOf<Int>(1)\\n        if (rowIndex == 0) return initial\\n        for (i in 0..rowIndex) {\\n            val current = mutableListOf<Int>(1)\\n            for (j in 1 until i) {\\n                current.add(initial[j] + initial[j-1])\\n            }\\n            current.add(1)\\n            initial = current\\n        }\\n        return initial\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831889,
                "title": "java-simple-detailed-explanation-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution **\\n\\n```\\nclass Solution {\\n    \\n    /***\\n     *  Lets take example for the below triangle\\n     *\\n     *          1   ------------> Row 0\\n     *        1   1  -----------> Row 1\\n     *       1  2  1  ----------> Row 2\\n     *     1  3  3  1  ---------> Row 3\\n     *    1  4  6  4  1  -------> Row 4\\n     *\\n     *\\n     *    Each of the position can be represented as nCj  (n = row number and j = column number)\\n     *\\n     *                   0c0   ------------> Row 0\\n     *               1c0    1c1  -----------> Row 1\\n     *            2c0   2c1     2c2  ----------> Row 2\\n     *        3c0    3c1    3c2    3c3  ---------> Row 3\\n     *    4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     *\\n     *   Formula of  NcR = N! / (N - R)! * R!\\n     *\\n     *   Note :  Nc0 >> 1  &   NcN >> 1\\n     *\\n     *   Suppose we have to get the 4th Row\\n     *                              4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     * This can be represented as : NcR   NcR+1  NcR+2  NcR+3   NcR+4\\n     *\\n     * Properties of combination :  NcR * factor = NcR+1 now if we can figure out the value of factor we can make the whole row.\\n     *\\n     *         n!                         n!\\n     *     ------------ * factor =  ---------------------------\\n     *     (n-r)! * r!                (n - (r+1))! * (r+1)!\\n     *\\n     *                   (n-r)! * r!                      (n-r) *  (n-r-1)!         n - r\\n     *     factor = ----------------------------  =   ------------------------- = ----------\\n     *                (n - r - 1)! * (r+1) * r!            (n - r - 1)! * (r+1)     r + 1\\n     *\\n     *\\n     *    So, the value of factor = (n - r) / ( r + 1)\\n     *\\n     *    With this we can compute the factor and get the next value\\n     */\\n    public List<Integer> getRow(int i) {\\n\\n        List<Integer> result = new ArrayList<>();\\n        long val = 1;\\n\\n        for (int j = 0; j <= i; j++) {\\n            result.add((int) val);\\n            val = val * (i - j) / (j + 1);\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /***\\n     *  Lets take example for the below triangle\\n     *\\n     *          1   ------------> Row 0\\n     *        1   1  -----------> Row 1\\n     *       1  2  1  ----------> Row 2\\n     *     1  3  3  1  ---------> Row 3\\n     *    1  4  6  4  1  -------> Row 4\\n     *\\n     *\\n     *    Each of the position can be represented as nCj  (n = row number and j = column number)\\n     *\\n     *                   0c0   ------------> Row 0\\n     *               1c0    1c1  -----------> Row 1\\n     *            2c0   2c1     2c2  ----------> Row 2\\n     *        3c0    3c1    3c2    3c3  ---------> Row 3\\n     *    4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     *\\n     *   Formula of  NcR = N! / (N - R)! * R!\\n     *\\n     *   Note :  Nc0 >> 1  &   NcN >> 1\\n     *\\n     *   Suppose we have to get the 4th Row\\n     *                              4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     * This can be represented as : NcR   NcR+1  NcR+2  NcR+3   NcR+4\\n     *\\n     * Properties of combination :  NcR * factor = NcR+1 now if we can figure out the value of factor we can make the whole row.\\n     *\\n     *         n!                         n!\\n     *     ------------ * factor =  ---------------------------\\n     *     (n-r)! * r!                (n - (r+1))! * (r+1)!\\n     *\\n     *                   (n-r)! * r!                      (n-r) *  (n-r-1)!         n - r\\n     *     factor = ----------------------------  =   ------------------------- = ----------\\n     *                (n - r - 1)! * (r+1) * r!            (n - r - 1)! * (r+1)     r + 1\\n     *\\n     *\\n     *    So, the value of factor = (n - r) / ( r + 1)\\n     *\\n     *    With this we can compute the factor and get the next value\\n     */\\n    public List<Integer> getRow(int i) {\\n\\n        List<Integer> result = new ArrayList<>();\\n        long val = 1;\\n\\n        for (int j = 0; j <= i; j++) {\\n            result.add((int) val);\\n            val = val * (i - j) / (j + 1);\\n        }\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912234,
                "title": "o-1",
                "content": "JUST FOR FUN! lol\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [[1], \\n        [1, 1], \\n        [1, 2, 1], \\n        [1, 3, 3, 1], \\n        [1, 4, 6, 4, 1], \\n        [1, 5, 10, 10, 5, 1], \\n        [1, 6, 15, 20, 15, 6, 1], \\n        [1, 7, 21, 35, 35, 21, 7, 1], \\n        [1, 8, 28, 56, 70, 56, 28, 8, 1], \\n        [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], \\n        [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], \\n        [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], \\n        [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], \\n        [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], \\n        [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], \\n        [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], \\n        [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], \\n        [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], \\n        [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], \\n        [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], \\n        [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], \\n        [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], \\n        [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], \\n        [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], \\n        [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], \\n        [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], \\n        [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], \\n        [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], \\n        [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], \\n        [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1], \\n        [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1], \\n        [1, 31, 465, 4495, 31465, 169911, 736281, 2629575, 7888725, 20160075, 44352165, 84672315, 141120525, 206253075, 265182525, 300540195, 300540195, 265182525, 206253075, 141120525, 84672315, 44352165, 20160075, 7888725, 2629575, 736281, 169911, 31465, 4495, 465, 31, 1], \\n        [1, 32, 496, 4960, 35960, 201376, 906192, 3365856, 10518300, 28048800, 64512240, 129024480, 225792840, 347373600, 471435600, 565722720, 601080390, 565722720, 471435600, 347373600, 225792840, 129024480, 64512240, 28048800, 10518300, 3365856, 906192, 201376, 35960, 4960, 496, 32, 1], \\n        [1, 33, 528, 5456, 40920, 237336, 1107568, 4272048, 13884156, 38567100, 92561040, 193536720, 354817320, 573166440, 818809200, 1037158320, 1166803110, 1166803110, 1037158320, 818809200, 573166440, 354817320, 193536720, 92561040, 38567100, 13884156, 4272048, 1107568, 237336, 40920, 5456, 528, 33, 1]][rowIndex]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [[1], \\n        [1, 1], \\n        [1, 2, 1], \\n        [1, 3, 3, 1], \\n        [1, 4, 6, 4, 1], \\n        [1, 5, 10, 10, 5, 1], \\n        [1, 6, 15, 20, 15, 6, 1], \\n        [1, 7, 21, 35, 35, 21, 7, 1], \\n        [1, 8, 28, 56, 70, 56, 28, 8, 1], \\n        [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], \\n        [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], \\n        [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], \\n        [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], \\n        [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], \\n        [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], \\n        [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], \\n        [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], \\n        [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], \\n        [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], \\n        [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], \\n        [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], \\n        [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], \\n        [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], \\n        [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], \\n        [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], \\n        [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], \\n        [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], \\n        [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], \\n        [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], \\n        [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1], \\n        [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1], \\n        [1, 31, 465, 4495, 31465, 169911, 736281, 2629575, 7888725, 20160075, 44352165, 84672315, 141120525, 206253075, 265182525, 300540195, 300540195, 265182525, 206253075, 141120525, 84672315, 44352165, 20160075, 7888725, 2629575, 736281, 169911, 31465, 4495, 465, 31, 1], \\n        [1, 32, 496, 4960, 35960, 201376, 906192, 3365856, 10518300, 28048800, 64512240, 129024480, 225792840, 347373600, 471435600, 565722720, 601080390, 565722720, 471435600, 347373600, 225792840, 129024480, 64512240, 28048800, 10518300, 3365856, 906192, 201376, 35960, 4960, 496, 32, 1], \\n        [1, 33, 528, 5456, 40920, 237336, 1107568, 4272048, 13884156, 38567100, 92561040, 193536720, 354817320, 573166440, 818809200, 1037158320, 1166803110, 1166803110, 1037158320, 818809200, 573166440, 354817320, 193536720, 92561040, 38567100, 13884156, 4272048, 1107568, 237336, 40920, 5456, 528, 33, 1]][rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190206,
                "title": "single-loop-solution-with-concise-explanation-c-maths-magic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPascal triangle rows can be defined as combinations nCr.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n//           n!\\n// nCr = -----------\\n//        r!.(n-r)!\\n\\n//                  n!\\n// nC(r-1) = -----------------\\n//            (r-1)!.(n-r+1)!\\n\\n//                     n!        (r-1)!x(n-r+1)!\\n// nCr / nC(r-1) = ----------- x ---------------\\n//                  r!.(n-r)!          n!\\n\\n//                 (n-r+1)\\n//               = -------\\n//                    r\\n\\n// nC0 = 1\\n// nCr = nC(r-1) x (n-r+1) / r\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ ``` because n <= 33```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        vector<int> vec(n+1, 1);\\n        long long int temp = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * (n-i+1) / i;\\n            vec[i] = temp;\\n        } return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//           n!\\n// nCr = -----------\\n//        r!.(n-r)!\\n\\n//                  n!\\n// nC(r-1) = -----------------\\n//            (r-1)!.(n-r+1)!\\n\\n//                     n!        (r-1)!x(n-r+1)!\\n// nCr / nC(r-1) = ----------- x ---------------\\n//                  r!.(n-r)!          n!\\n\\n//                 (n-r+1)\\n//               = -------\\n//                    r\\n\\n// nC0 = 1\\n// nCr = nC(r-1) x (n-r+1) / r\\n```\n``` because n <= 33```\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        vector<int> vec(n+1, 1);\\n        long long int temp = 1;\\n        for(int i = 1; i < n; i++) {\\n            temp = temp * (n-i+1) / i;\\n            vec[i] = temp;\\n        } return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932131,
                "title": "100-fastest-swift-solution-time-o-k-space-o-k",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(k), where k is the rowIndex.\\n    //   - space: O(k), where k is the rowIndex.\\n    \\n    func getRow(_ rowIndex: Int) -> [Int] {\\n        var row = Array(repeating: 0, count: rowIndex + 1)\\n\\t\\trow[0] = 1\\n\\t\\tvar index = 0\\n\\t\\t\\n        while index <= rowIndex {\\n\\t\\t\\tfor i in 0...index / 2 {\\n\\t\\t\\t\\tlet a = i > 0 ? row[i - 1] : 0\\n\\t\\t\\t\\tlet b = row[i]\\n\\t\\t\\t\\trow[index - i] = a + b\\n\\t\\t\\t}\\n\\t\\t\\t\\n            for i in 0...index / 2 {\\n\\t\\t\\t\\trow[i] = row[index - i]\\n\\t\\t\\t}\\n\\t\\t\\t\\n            index += 1\\n\\t\\t}\\n        \\n\\t\\treturn row\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654390,
                "title": "python-clean-recursion-o-rowindex-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea here is to return the row at each index. Then use that row to build the next row on the next index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - n is rowIndex\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$ - k is rowIndex\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        prevRow = self.getRow(rowIndex - 1)\\n        currentRow = [1]\\n        for i in range(len(prevRow) - 1):\\n            currentRow.append(prevRow[i] + prevRow[i + 1])\\n        currentRow.append(1)\\n        return currentRow\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        prevRow = self.getRow(rowIndex - 1)\\n        currentRow = [1]\\n        for i in range(len(prevRow) - 1):\\n            currentRow.append(prevRow[i] + prevRow[i + 1])\\n        currentRow.append(1)\\n        return currentRow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311465,
                "title": "python-recursive-solution-95-42-time-91-63-memory",
                "content": "```\\ndef getRow(self, rowIndex: int) -> List[int]:\\n\\n\\tif rowIndex == 0:\\n\\t\\treturn [1]\\n\\n\\tif rowIndex == 1:\\n\\t\\treturn [1, 1]\\n\\n\\tprev = self.getRow(rowIndex - 1)\\n\\n\\tcur = [1] + [prev[i] + prev[i+1] for i in range(len(prev) - 1)] + [1]\\n\\n\\treturn cur\\n```\\n\\n\\nThe list comprehension is with time complexity of O(k). In the recursion, T(k) = O(k) + T(k-1), thus the time complexity would be O(k^2). \\n\\nThe space complexity would be O(k).",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef getRow(self, rowIndex: int) -> List[int]:\\n\\n\\tif rowIndex == 0:\\n\\t\\treturn [1]\\n\\n\\tif rowIndex == 1:\\n\\t\\treturn [1, 1]\\n\\n\\tprev = self.getRow(rowIndex - 1)\\n\\n\\tcur = [1] + [prev[i] + prev[i+1] for i in range(len(prev) - 1)] + [1]\\n\\n\\treturn cur\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38682,
                "title": "solution-based-on-mathematics",
                "content": "If anyone has ever learnt the mathematics equations related to the pascal triangle, they would know the following:\\n\\nThe nth row of pascal triangle will have the following format: 1 a(1) a(2) ... a(n)\\nhere we have a(1) = n; a(k+1) = a(k) * (n-k)/(k+1).\\n\\nHence, the following code is based on the above knowledge. However, there would be a test case that this solution won't work. Do you know any?\\n\\n    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            \\n            if(rowIndex<0) return results;\\n            \\n            results.add(1);\\n            if(rowIndex == 0) return results;\\n            long pre = 1;\\n            for(int k = 0; k<rowIndex; k++){\\n                pre = pre * (rowIndex - k) / (k+1);\\n                results.add((int) pre);\\n            }\\n            \\n            return results;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            \\n            if(rowIndex<0) return results;\\n            \\n            results.add(1);\\n            if(rowIndex == 0) return results;\\n            long pre = 1;\\n            for(int k = 0; k<rowIndex; k++){\\n                pre = pre * (rowIndex - k) / (k+1);\\n                results.add((int) pre);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38699,
                "title": "my-very-simple-c-solution",
                "content": "Basically, I will insert 1 at the head of vector each iteration and calculate result[j] based on result[j] and result[j+1].\\nFor example, if I want to get [1, 3, 3, 1] from [1, 2, 1], I will first insert 1 and get [1, 1, 2, 1].\\nThen begin with j = 1, result[j] = result[j] + result[j+1]. second position is 1+2=3, third position is 2+1=3\\nFinally we get [1, 3, 3, 1]\\n\\n\\n\\n    #include <vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1;i<=rowIndex;i++){\\n                result.insert(result.begin(),1);\\n                for(int j=1;j<result.size()-1;j++){\\n                    result[j] = result[j] + result[j+1];\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1;i<=rowIndex;i++){\\n                result.insert(result.begin(),1);\\n                for(int j=1;j<result.size()-1;j++){\\n                    result[j] = result[j] + result[j+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1092502,
                "title": "fast-recursive-solution-for-beginners-for-understanding",
                "content": "Here\\'s how to do it recursively.\\n \\n```\\n class Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t# base cases\\n        if rowIndex < 2:\\n            return [1] * (rowIndex + 1)\\n        \\n\\t\\t# do recursive call to get to the base case\\n        prev_row = self.getRow(rowIndex - 1)\\n\\t\\t\\n\\t\\t# the recurrence relation\\n        new_row = [1] * (len(prev_row) + 1)\\n        for i in range(1, len(new_row)-1):\\n            new_row[i] = prev_row[i-1] + prev_row[i]\\n        \\n        return new_row\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n class Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t# base cases\\n        if rowIndex < 2:\\n            return [1] * (rowIndex + 1)\\n        \\n\\t\\t# do recursive call to get to the base case\\n        prev_row = self.getRow(rowIndex - 1)\\n\\t\\t\\n\\t\\t# the recurrence relation\\n        new_row = [1] * (len(prev_row) + 1)\\n        for i in range(1, len(new_row)-1):\\n            new_row[i] = prev_row[i-1] + prev_row[i]\\n        \\n        return new_row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38516,
                "title": "recursive-solution-java-3ms",
                "content": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        if (rowIndex == 0) return Arrays.asList(1);\\n        List<Integer> previousList = getRow(rowIndex - 1);\\n        List<Integer> thisList = new ArrayList<>();\\n        for (int i =0; i < previousList.size(); i++) {\\n            if (i == 0) thisList.add(1);\\n            if (i > 0) thisList.add(previousList.get(i) + previousList.get(i-1));\\n            if (i == previousList.size() -1) thisList.add(1);\\n        }\\n        return thisList;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        if (rowIndex == 0) return Arrays.asList(1);\\n        List<Integer> previousList = getRow(rowIndex - 1);\\n        List<Integer> thisList = new ArrayList<>();\\n        for (int i =0; i < previousList.size(); i++) {\\n            if (i == 0) thisList.add(1);\\n            if (i > 0) thisList.add(previousList.get(i) + previousList.get(i-1));\\n            if (i == previousList.size() -1) thisList.add(1);\\n        }\\n        return thisList;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38647,
                "title": "a-concise-7-line-java-solution-o-k",
                "content": "    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            Integer[] ret = new Integer[rowIndex+1];\\n            Arrays.fill(ret, 0);       \\n            for (int i=0; i<= rowIndex; i++)\\n                for (int j=i; j>0; j--)\\n                    ret[j] = ret[j] + ret[j-1];\\n                ret[0] = 1;\\n            return Arrays.asList(ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            Integer[] ret = new Integer[rowIndex+1];\\n            Arrays.fill(ret, 0);       \\n            for (int i=0; i<= rowIndex; i++)\\n                for (int j=i; j>0; j--)\\n                    ret[j] = ret[j] + ret[j-1];\\n                ret[0] = 1;\\n            return Arrays.asList(ret);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38695,
                "title": "accepted-java-solution-using-recursion",
                "content": "    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            if (rowIndex==0) {\\n                List<Integer> r = new ArrayList<Integer>();\\n                r.add(1);\\n                return r;\\n            } \\n            if (rowIndex==1) {\\n                List<Integer> r = new ArrayList<Integer>();\\n                r.add(1);\\n                r.add(1);\\n                return r;\\n            }\\n            List<Integer> oldRow = getRow(rowIndex-1);\\n            List<Integer> newRow = new ArrayList<Integer>();\\n            newRow.add(1);\\n            for(int i=0;i<oldRow.size()-1;i++) {\\n                newRow.add(oldRow.get(i)+oldRow.get(i+1));\\n            }\\n            newRow.add(1);\\n            return newRow;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            if (rowIndex==0) {\\n                List<Integer> r = new ArrayList<Integer>();\\n                r.add(1);\\n                return r;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3754774,
                "title": "simple-easy-to-understand-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0; i<=rowIndex; i++){\\n            List<Integer> sum = new ArrayList<>();\\n            \\n            for(int j=0; j<=i; j++){\\n                if(j==0 || j==i){\\n                    sum.add(1);\\n                }\\n                else{\\n                    sum.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));\\n                }\\n            }\\n            ans.add(sum);\\n        }\\n\\n        return ans.get(rowIndex);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0; i<=rowIndex; i++){\\n            List<Integer> sum = new ArrayList<>();\\n            \\n            for(int j=0; j<=i; j++){\\n                if(j==0 || j==i){\\n                    sum.add(1);\\n                }\\n                else{\\n                    sum.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));\\n                }\\n            }\\n            ans.add(sum);\\n        }\\n\\n        return ans.get(rowIndex);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644927,
                "title": "java-easy-solution-6-7-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      Integer arr[] = new Integer[rowIndex + 1];\\n      Arrays.fill(arr, 0);\\n      arr[0] = 1;\\n\\n      for(int i = 1; i <= rowIndex; i ++) {\\n          for(int j = i; j > 0; j --) {\\n              arr[j] = arr[j] + arr[j - 1];\\n          }\\n      }\\n      return Arrays.asList(arr);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL !",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      Integer arr[] = new Integer[rowIndex + 1];\\n      Arrays.fill(arr, 0);\\n      arr[0] = 1;\\n\\n      for(int i = 1; i <= rowIndex; i ++) {\\n          for(int j = i; j > 0; j --) {\\n              arr[j] = arr[j] + arr[j - 1];\\n          }\\n      }\\n      return Arrays.asList(arr);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566040,
                "title": "python-beginner-friendly",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        numRows = rowIndex+1\\n        l=[1]*numRows\\n        for i in range(numRows):\\n            l[i]=[1]*(i+1)\\n            for j in range(1,i):\\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\\n        return l[rowIndex]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        numRows = rowIndex+1\\n        l=[1]*numRows\\n        for i in range(numRows):\\n            l[i]=[1]*(i+1)\\n            for j in range(1,i):\\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\\n        return l[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219048,
                "title": "c-faster-then-100-simple-to-understand",
                "content": "```\\n   vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> pt;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=pt[i-1][j-1]+pt[i-1][j];\\n         pt.push_back(row);\\n     }\\n     return pt[rowIndex];\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n   vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> pt;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=pt[i-1][j-1]+pt[i-1][j];\\n         pt.push_back(row);\\n     }\\n     return pt[rowIndex];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 562371,
                "title": "python-recursion-approach",
                "content": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if rowIndex == 0:\\n            return [1]\\n        lastRow = self.getRow(rowIndex-1)\\n        res = [1]\\n        for i in range(len(lastRow)-1):\\n            res.append(lastRow[i]+lastRow[i+1])\\n        res.append(1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if rowIndex == 0:\\n            return [1]\\n        lastRow = self.getRow(rowIndex-1)\\n        res = [1]\\n        for i in range(len(lastRow)-1):\\n            res.append(lastRow[i]+lastRow[i+1])\\n        res.append(1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471808,
                "title": "c-0ms-o-n",
                "content": "```\\nint* getRow(int rowIndex, int* returnSize){\\n    *returnSize = rowIndex + 1;\\n    \\n    int* ans = malloc(*returnSize * sizeof(int));\\n\\n    ans[0]        = 1;\\n    ans[rowIndex] = 1;\\n    \\n    for (int i = 1; i < rowIndex/2 + 1; ++i) {\\n        ans[i] = (long) ans[i - 1] * (rowIndex - i + 1) / i;       \\n        ans[rowIndex - i] = ans[i];\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* getRow(int rowIndex, int* returnSize){\\n    *returnSize = rowIndex + 1;\\n    \\n    int* ans = malloc(*returnSize * sizeof(int));\\n\\n    ans[0]        = 1;\\n    ans[rowIndex] = 1;\\n    \\n    for (int i = 1; i < rowIndex/2 + 1; ++i) {\\n        ans[i] = (long) ans[i - 1] * (rowIndex - i + 1) / i;       \\n        ans[rowIndex - i] = ans[i];\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3308980,
                "title": "8-lines-dp-solution-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[[1]]\\n        for i in range(rowIndex):\\n            temp=[0]+res[-1]+[0]\\n            row=[]\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j]+temp[j+1])\\n            res.append(row)\\n        return res[-1]\\n```\\n# plz consider upvoting\\n![4m44lc.jpg](https://assets.leetcode.com/users/images/34e4b956-8c38-499d-bbec-0dad1c9770e8_1679083370.333633.jpeg)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[[1]]\\n        for i in range(rowIndex):\\n            temp=[0]+res[-1]+[0]\\n            row=[]\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j]+temp[j+1])\\n            res.append(row)\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055911,
                "title": "c-java-100-solution-using-dynamic-programming-pascal-s-triangle-ii",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```Java []\\npublic class Solution {\\n    public List<Integer> getRow(int k) {\\n        Integer[] arr = new Integer[k + 1];\\n        Arrays.fill(arr, 0);\\n        arr[0] = 1;\\n        \\n        for (int i = 1; i <= k; i++) \\n            for (int j = i; j > 0; j--) \\n                arr[j] = arr[j] + arr[j - 1];\\n        \\n        return Arrays.asList(arr);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ansArray(rowIndex+1,0);\\n        ansArray[0] = 1;\\n        \\n        for (int i = 1; i <= rowIndex; i++) \\n            for (int j = i; j > 0; j--) \\n                ansArray[j] = ansArray[j] + ansArray[j - 1];\\n        \\n        return ansArray;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```Java []\\npublic class Solution {\\n    public List<Integer> getRow(int k) {\\n        Integer[] arr = new Integer[k + 1];\\n        Arrays.fill(arr, 0);\\n        arr[0] = 1;\\n        \\n        for (int i = 1; i <= k; i++) \\n            for (int j = i; j > 0; j--) \\n                arr[j] = arr[j] + arr[j - 1];\\n        \\n        return Arrays.asList(arr);\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ansArray(rowIndex+1,0);\\n        ansArray[0] = 1;\\n        \\n        for (int i = 1; i <= rowIndex; i++) \\n            for (int j = i; j > 0; j--) \\n                ansArray[j] = ansArray[j] + ansArray[j - 1];\\n        \\n        return ansArray;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606554,
                "title": "easy-python-solution",
                "content": "```\\nnumRows = rowIndex+1\\nres = [] \\nfor i in range(0,numRows):\\n        res.append([1]*(i+1))\\n       \\nfor i in range(numRows):\\n\\tfor j in range(1,i):\\n\\t\\tres[i][j] = res[i-1][j-1]+res[i-1][j]\\nreturn res[rowIndex]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nnumRows = rowIndex+1\\nres = [] \\nfor i in range(0,numRows):\\n        res.append([1]*(i+1))\\n       \\nfor i in range(numRows):\\n\\tfor j in range(1,i):\\n\\t\\tres[i][j] = res[i-1][j-1]+res[i-1][j]\\nreturn res[rowIndex]",
                "codeTag": "Unknown"
            },
            {
                "id": 1532130,
                "title": "c-recursive-permutation-and-combinations",
                "content": "using the formula of permutation and combinations we will find that\\nat nth row we have [nCo,nC1,nC2..........nCn]\\nso only considering last line of pascal triangle \\n```class Solution {\\npublic:\\n    long double fact(int n){\\n        if(n<2)\\n            return 1;\\n        return n*fact(n-1);\\n    }\\n    vector<int> getRow(int i) {\\n        vector<int>ans;\\n         for(int j=0;j<=i;j++){\\n                double temp=(fact(i)/(fact(j)*fact(i-j)));\\n                ans.push_back(temp);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```class Solution {\\npublic:\\n    long double fact(int n){\\n        if(n<2)\\n            return 1;\\n        return n*fact(n-1);\\n    }\\n    vector<int> getRow(int i) {\\n        vector<int>ans;\\n         for(int j=0;j<=i;j++){\\n                double temp=(fact(i)/(fact(j)*fact(i-j)));\\n                ans.push_back(temp);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378284,
                "title": "explanation-using-binomial-theorem-runtime-0-ms-memory-usage-36-4-mb-java",
                "content": "**What does every row of Pascal\\'s traingle represents?**\\nnth row represent coefficient of (1+x)^n. Let\\'s observe this\\n\\n0th row: (1+x)^0   = 1                                    = [1]\\n1st row: (1+x)^1   = 1 + x                              = [1, 1]\\n2nd row: (1+x)^2  = 1 + 2x + x^2                 = [1, 2, 1]\\n3rd row: (1+x)^3   = 1 + 3x  + 3x^2 + x^3    = [1, 3, 3, 1]\\nand so on..\\nWe just need to keep the values in increasing order of their power of x.\\n\\n**Binomial Theorem**\\nWe can use [binomial theorem](https://en.wikipedia.org/wiki/Binomial_theorem) to calculate (1+x)^n.\\n\\n\\n![image](https://assets.leetcode.com/users/images/9bb0fb39-bb0a-4099-8c55-d055157f324b_1627894981.7081034.png)\\n\\n\\nWe just need to calculate coefficient of above formula from left to right. First value is `1`, and if we compare any two consecutive values, then we can consume some caluclation from last coefficient in building a new coefficient. \\n\\nTry to find out that comman value in 2 consecutive coefficient.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public List<Integer> getRow(int n) {\\n        // nth row will contain n+1 numbers.\\n        List<Integer> ans = new ArrayList<>(n+1);\\n        \\n\\t\\t// First number will be always 1\\n        ans.add(1);\\n        \\n        long lastCoefficient = 1;\\n        int fact = 1;\\n        \\n\\t\\t// We have already fixed first number as 1, we need to calculate n more numbers\\n        for(int i = n; i >=1; i--) {\\n            lastCoefficient = (lastCoefficient * i)/fact;\\n            ans.add((int)lastCoefficient);\\n            fact++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int n) {\\n        // nth row will contain n+1 numbers.\\n        List<Integer> ans = new ArrayList<>(n+1);\\n        \\n\\t\\t// First number will be always 1\\n        ans.add(1);\\n        \\n        long lastCoefficient = 1;\\n        int fact = 1;\\n        \\n\\t\\t// We have already fixed first number as 1, we need to calculate n more numbers\\n        for(int i = n; i >=1; i--) {\\n            lastCoefficient = (lastCoefficient * i)/fact;\\n            ans.add((int)lastCoefficient);\\n            fact++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788355,
                "title": "pascal-s-triangle-ii-python-easy-solution-with-explanation-beats-98-96",
                "content": "Hints:\\n* Consider the triangle as a collection of rows and each row is a list of numbers where first and the last elements of a row is 1\\n* The number of additional elements in a row except the first and the last element is `length(previous_row) - 1`. For example, if you consider the image below where `row 3` has `[1,3,3,1]` and `row 2` has `[1,2,1]`. Therefore row 3 will have `length(row 2) - 1 = 3-1 = 2` additional numbers between first and the last element. \\n* These additional numbers have a sequence and it\\'s the sum of two numbers from the previous row. If you are looking for a number whose position is `i` in the current row then the resultant number would be `current_row[i] = previous_row[i] + previous_row[i-1]`. \\n* Since any given row can be generated from the immediate previous row, we do not need to store all rows except the current row.\\n* Finally return your current row and you are done :-)\\n![image](https://assets.leetcode.com/users/images/10f8a7b0-51d8-4bc1-99a7-3abe1c36899f_1597262380.3813298.png)\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = []\\n\\t\\t\\n\\t\\t# add first 1\\n        row.append(1)\\n        \\n\\t\\tfor i in range(rowIndex):\\n\\t\\t\\t# compute additional numbers in between 1\\'s\\n\\t\\t\\t# iterate from right to left\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1] + row[j]\\n            \\n\\t\\t\\t# add last 1\\n            row.append(1)\\n            \\n        return row\\n```\\n\\nReference https://www.youtube.com/watch?v=tTYU4PAiqOE",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = []\\n\\t\\t\\n\\t\\t# add first 1\\n        row.append(1)\\n        \\n\\t\\tfor i in range(rowIndex):\\n\\t\\t\\t# compute additional numbers in between 1\\'s\\n\\t\\t\\t# iterate from right to left\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1] + row[j]\\n            \\n\\t\\t\\t# add last 1\\n            row.append(1)\\n            \\n        return row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375920,
                "title": "cleanest-js-solution",
                "content": "```\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nconst getRow = rowIndex => {\\n    const res = []\\n    \\n    while (res.length <= rowIndex) {\\n        res.unshift(1)\\n        for(let i = 1; i < res.length - 1; i++) {\\n            res[i] += res[i + 1]\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nconst getRow = rowIndex => {\\n    const res = []\\n    \\n    while (res.length <= rowIndex) {\\n        res.unshift(1)\\n        for(let i = 1; i < res.length - 1; i++) {\\n            res[i] += res[i + 1]\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311494,
                "title": "python-recursion",
                "content": "\\'\\'\\'\\n\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        output_pre = self.getRow(rowIndex-1)\\n        output = [1] * (rowIndex+1)\\n        for i in range(1, len(output)-1):\\n            output[i] = output_pre[i-1] + output_pre[i]\\n        return output\\n\\t\\t\\n\\'\\'\\'\\t\\t\\n\\npython recursive solution with time complexity of O(k^2), space complexity of O(k)",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0:\\n            return [1]\\n        output_pre = self.getRow(rowIndex-1)\\n        output = [1] * (rowIndex+1)\\n        for i in range(1, len(output)-1):\\n            output[i] = output_pre[i-1] + output_pre[i]\\n        return output\\n\\t\\t\\n\\'\\'\\'\\t\\t\\n\\npython recursive solution with time complexity of O(k^2), space complexity of O(k)",
                "codeTag": "Python3"
            },
            {
                "id": 4065086,
                "title": "simple-java-solutions-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        list.add(Arrays.asList(1));\\n\\n        for (int i = 1; i < rowIndex + 1; i++) {\\n            List<Integer> list1 = new LinkedList<>();\\n            list1.add(1);\\n            List<Integer> list2 = list.get(i-1);\\n\\n            for (int k = 0; k < list2.size() - 1 ; k++)\\n            {\\n                list1.add(list2.get(k) + list2.get(k+1));\\n            }\\n            list1.add(1);\\n\\n            list.add(list1);\\n        }\\n\\n\\n        return list.get(rowIndex);\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/20cb17d7-a2a6-40f4-b950-61eb9393eacc_1695139685.6894486.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        list.add(Arrays.asList(1));\\n\\n        for (int i = 1; i < rowIndex + 1; i++) {\\n            List<Integer> list1 = new LinkedList<>();\\n            list1.add(1);\\n            List<Integer> list2 = list.get(i-1);\\n\\n            for (int k = 0; k < list2.size() - 1 ; k++)\\n            {\\n                list1.add(list2.get(k) + list2.get(k+1));\\n            }\\n            list1.add(1);\\n\\n            list.add(list1);\\n        }\\n\\n\\n        return list.get(rowIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324397,
                "title": "the-best-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        for(long i = 1; i <= rowIndex; i++) {\\n            ans.push_back((ans[i-1]*(rowIndex-i+1))/i);\\n        }      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        for(long i = 1; i <= rowIndex; i++) {\\n            ans.push_back((ans[i-1]*(rowIndex-i+1))/i);\\n        }      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765160,
                "title": "c-for-the-win",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> A(rowIndex+1, 0);\\n        A[0] = 1;\\n        for(int i=1; i<rowIndex+1; i++)\\n            for(int j=i; j>=1; j--)\\n                A[j] += A[j-1];\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> A(rowIndex+1, 0);\\n        A[0] = 1;\\n        for(int i=1; i<rowIndex+1; i++)\\n            for(int j=i; j>=1; j--)\\n                A[j] += A[j-1];\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612506,
                "title": "simple-python3-solution-easy-approach",
                "content": "**UPVOTE** if it is helpful\\n``` \\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1 = []\\n        for i in range(rowIndex+1):\\n            temp_list = []\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    temp_list.append(1)\\n                else:\\n                    temp_list.append(list1[i-1][j-1] + list1[i-1][j])\\n            list1.append(temp_list)\\n        return list1[rowIndex]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1 = []\\n        for i in range(rowIndex+1):\\n            temp_list = []\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    temp_list.append(1)\\n                else:\\n                    temp_list.append(list1[i-1][j-1] + list1[i-1][j])\\n            list1.append(temp_list)\\n        return list1[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055396,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "**//PLEASE UPVOTE IF IT IS HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> v;\\n        long long int val=1;\\n        for(int i=0; i<=rowIndex; i++){\\n            v.push_back(val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int> v;\\n        long long int val=1;\\n        for(int i=0; i<=rowIndex; i++){\\n            v.push_back(val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456044,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> PAS;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=PAS[i-1][j-1]+PAS[i-1][j];\\n         PAS.push_back(row);\\n     }\\n     return PAS[rowIndex];\\n    }\\n};\\n\\n//Please upvote if you like the solution!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n     vector<vector<int>> PAS;\\n     for(int i=0;i<=rowIndex;i++){\\n         vector<int>row(i+1,1);\\n         for(int j=1;j<i;j++)row[j]=PAS[i-1][j-1]+PAS[i-1][j];\\n         PAS.push_back(row);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 787732,
                "title": "very-simple-python-solution-using-combinatorics-faster-than-98",
                "content": "Easy if you understand what Pascal\\'s Triangle is used for. It\\'s used for [combinatorics](https://mathigon.org/world/Combinatorics). In fact, if you google \"combinatorics\", you\\'ll find a picture of Pascal\\'s Triangle. Each row in the triangle tells us the `n_choose_k` result where `n` is the row index and `k` is `[0 ... n]`, the column index.\\n\\nExamples:\\n```\\nn = 0 (top of the triangle)\\ncomb(0, 0) = 1\\n\\nn = 1\\ncomb(1, 0) = 1\\ncomb(1, 1) = 1\\n\\nn = 2\\ncomb(2, 0) = 1\\ncomb(2, 1) = 2\\ncomb(2, 2) = 1\\n\\nn = 3\\ncomb(3, 0) = 1\\ncomb(3, 1) = 3\\ncomb(3, 2) = 3\\ncomb(3, 3) = 1\\n```\\n\\nWith that the code becomes simple in python as the `math` library has a function for `comb`.\\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        result = []\\n        for i in range(rowIndex+1):\\n            result.append(comb(rowIndex, i))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nn = 0 (top of the triangle)\\ncomb(0, 0) = 1\\n\\nn = 1\\ncomb(1, 0) = 1\\ncomb(1, 1) = 1\\n\\nn = 2\\ncomb(2, 0) = 1\\ncomb(2, 1) = 2\\ncomb(2, 2) = 1\\n\\nn = 3\\ncomb(3, 0) = 1\\ncomb(3, 1) = 3\\ncomb(3, 2) = 3\\ncomb(3, 3) = 1\\n```\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        result = []\\n        for i in range(rowIndex+1):\\n            result.append(comb(rowIndex, i))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787705,
                "title": "python-simplest-3-line-recursive-solution-faster-than-99",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0: return [1]\\n        prev = self.getRow(rowIndex-1)\\n        return [1] + [prev[i]+prev[i+1] for i in range(len(prev)-1)] + [1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0: return [1]\\n        prev = self.getRow(rowIndex-1)\\n        return [1] + [prev[i]+prev[i+1] for i in range(len(prev)-1)] + [1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787676,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar getRow = function(rowIndex) {\\n    if(!rowIndex) return [1];\\n    \\n    let res = [1, 1]\\n    \\n    while(--rowIndex) {\\n        const next = [];\\n        \\n        for(let i = 0; i < res.length-1; i++) {\\n            next.push(res[i] + res[i+1]);\\n        }\\n        res = [1, ...next, 1];\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getRow = function(rowIndex) {\\n    if(!rowIndex) return [1];\\n    \\n    let res = [1, 1]\\n    \\n    while(--rowIndex) {\\n        const next = [];\\n        \\n        for(let i = 0; i < res.length-1; i++) {\\n            next.push(res[i] + res[i+1]);\\n        }\\n        res = [1, ...next, 1];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787291,
                "title": "pascal-s-triangle-one-liner",
                "content": "```\\nfrom math import comb\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex, i) for i in range(rowIndex+1)]\\n            \\n```\\nhttps://www.dummies.com/education/math/calculus/how-to-find-binomial-coefficients/",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex, i) for i in range(rowIndex+1)]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 787246,
                "title": "java-pascal-triangle-o-k-space",
                "content": "```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i=0; i <=rowIndex ; i++){\\n            int j =0;\\n            while (result.size()-1 > j){\\n                result.add(result.get(0) + result.get(1));\\n                result.remove(0);\\n                j++;\\n            }\\n            result.add(1);\\n        }\\n        return  result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i=0; i <=rowIndex ; i++){\\n            int j =0;\\n            while (result.size()-1 > j){\\n                result.add(result.get(0) + result.get(1));\\n                result.remove(0);\\n                j++;\\n            }\\n            result.add(1);\\n        }\\n        return  result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197755,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [1]*(rowIndex+1)\\n        for i in range(2, rowIndex+1):\\n            prev = res[0]\\n            for j in range(1,i):\\n                tmp = res[j]\\n                res[j] = prev+res[j]\\n                prev = tmp\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [1]*(rowIndex+1)\\n        for i in range(2, rowIndex+1):\\n            prev = res[0]\\n            for j in range(1,i):\\n                tmp = res[j]\\n                res[j] = prev+res[j]\\n                prev = tmp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38537,
                "title": "java-o-n-solution-concise-and-easy-to-understand",
                "content": "    public List<Integer> getRow(int rowIndex) {\\n    \\t\\tList<Integer> row = null, pre = null;\\n    \\t\\tfor (int i = 0; i <= rowIndex; i++) {\\n    \\t\\t\\trow = new ArrayList<>();\\n    \\t\\t\\tfor (int j = 0; j <= i; j++) {\\n    \\t\\t\\t\\trow.add(j == 0 || i == j ? 1 : pre.get(j) + pre.get(j-1));\\n    \\t\\t\\t}\\n    \\t\\t\\tpre = row;\\n    \\t\\t}\\n    \\t\\treturn row;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> getRow(int rowIndex) {\\n    \\t\\tList<Integer> row = null, pre = null;\\n    \\t\\tfor (int i = 0; i <= rowIndex; i++) {\\n    \\t\\t\\trow = new ArrayList<>();\\n    \\t\\t\\tfor (int j = 0; j <= i; j++) {\\n    \\t\\t\\t\\trow.add(j == 0 || i == j ? 1 : pre.get(j) + pre.get(j-1));\\n    \\t\\t\\t}\\n    \\t\\t\\tpre = row;\\n    \\t\\t}\\n    \\t\\treturn row;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 38670,
                "title": "my-concise-java-solution-within-10-lines",
                "content": "My Concise Java Solution within 10 lines. Any improvement?\\n\\n    public class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> ans = new ArrayList<Integer>();\\n            \\n            for(int i=0;i<rowIndex+1;i++){\\n                ans.add(1);\\n                for(int j=i-1;j>0;j--){\\n                    ans.set(j,ans.get(j)+ans.get(j-1));\\n                }\\n            }\\n            \\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> getRow(int rowIndex) {\\n            List<Integer> ans = new ArrayList<Integer>();\\n            \\n            for(int i=0;i<rowIndex+1;i++){\\n                ans.add(1);\\n                for(int j=i-1;j>0;j--){\\n                    ans.set(j,ans.get(j)+ans.get(j-1));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3465917,
                "title": "beats-100-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> temp;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            vector<int> ans(i+1,1);\\n            for(int j=1;j<i;j++)\\n            {\\n                ans[j]=temp[i-1][j]+temp[i-1][j-1];\\n            }\\n                temp.push_back(ans);\\n                if(i==rowIndex)\\n                {\\n                    return ans;\\n                }\\n        }\\n        vector<int>vis;\\n        return vis;\\n    }\\n};\\n\\nDO UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> temp;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            vector<int> ans(i+1,1);\\n            for(int j=1;j<i;j++)\\n            {\\n                ans[j]=temp[i-1][j]+temp[i-1][j-1];\\n            }\\n                temp.push_back(ans);\\n                if(i==rowIndex)\\n                {\\n                    return ans;\\n                }\\n        }\\n        vector<int>vis;\\n        return vis;\\n    }\\n};\\n\\nDO UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198598,
                "title": "efficiently-compute-the-k-th-row-of-pascal-s-triangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to find the `rowIndex`-th row of the Pascal\\'s triangle. One approach is to calculate the entire Pascal\\'s triangle up to the given row, and then return the row. However, this approach requires calculating all the previous rows, which is inefficient.\\n\\nA better approach is to use the formula for the i-th element of the k-th row of the triangle, which is the binomial coefficient C(k, i-1). This formula allows us to calculate each element of the row separately, without having to compute the entire triangle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to iterate from i = 0 to i = rowIndex, and compute each element of the row using the formula for the binomial coefficient. We can use the previously computed value to optimize the calculation of the coefficient. We only store the current row, rather than storing the entire triangle.\\n# Complexity\\n- Time complexity:The algorithm computes each element of the row from scratch, and there are rowIndex elements in the row. Therefore, the time complexity is O(rowIndex).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:The algorithm stores only one row at a time, and there are rowIndex elements in the row. Therefore, the space complexity is O(rowIndex).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for i in range(1, rowIndex+1):\\n            # compute the i-th element of the current row\\n            element = row[-1] * (rowIndex-i+1) // i\\n            row.append(element)\\n        return row\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for i in range(1, rowIndex+1):\\n            # compute the i-th element of the current row\\n            element = row[-1] * (rowIndex-i+1) // i\\n            row.append(element)\\n        return row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195751,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSolution:\\n\\nTo generate the row of Pascal\\'s triangle at a given index rowIndex, we can use the fact that each element of the kth row is C(k, i), where C(k, i) is the binomial coefficient k choose i, i.e., the number of ways to choose i items from a set of k items. We can calculate the binomial coefficients using the formula C(k, i) = C(k, i-1) * (k-i+1) / i, which can be derived from the fact that C(k, i) = C(k-1, i-1) + C(k-1, i).\\n\\nWe can initialize the row with 1, and then compute each element by multiplying the previous element by (rowIndex-i+1) and dividing by i.\\n\\nWe only need to keep track of the previous element to compute the next element, so we can use only O(rowIndex) extra space.\\n\\n# Complexity\\n- Time complexity:\\nO(rowIndex^2), as we need to compute all binomial coefficients from row 0 to row rowIndex.\\n\\n- Space complexity:\\nO(rowIndex), as we only need to store the previous element to compute the next element.\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex + 1)\\n        for i in range(1, rowIndex):\\n            row[i] = row[i-1] * (rowIndex-i+1) // i\\n        return row\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1] * (rowIndex + 1)\\n        for i in range(1, rowIndex):\\n            row[i] = row[i-1] * (rowIndex-i+1) // i\\n        return row\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017325,
                "title": "1ms-most-optimal-solution-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer>prev=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer>temp=new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==0 || j==i){\\n                    temp.add(1);\\n                }\\n                else{\\n                    temp.add(prev.get(j-1)+prev.get(j));\\n                }\\n                \\n            }\\n            prev=temp;\\n            \\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer>prev=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer>temp=new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==0 || j==i){\\n                    temp.add(1);\\n                }\\n                else{\\n                    temp.add(prev.get(j-1)+prev.get(j));\\n                }\\n                \\n            }\\n            prev=temp;\\n            \\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672163,
                "title": "java-solution-faster-than-100",
                "content": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row = new ArrayList<>();\\n\\n        double ncr = 1.0;\\n        for(int i = 0; i <= rowIndex; i++){\\n            row.add((int)ncr);\\n            ncr = (ncr * (rowIndex - i)) / (i+1);\\n        }\\n        return row;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row = new ArrayList<>();\\n\\n        double ncr = 1.0;\\n        for(int i = 0; i <= rowIndex; i++){\\n            row.add((int)ncr);\\n            ncr = (ncr * (rowIndex - i)) / (i+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2626364,
                "title": "java-3-approaches-clean-and-easy",
                "content": "##### 1. Same as **Pascal\\'s Triangle 1**:\\nCreate the whole triangle till that row and at the end return that last row.\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> currRow, prevRow = null;\\n\\n        for (int i = 0; i <= rowIndex; i++) {\\n            currRow = new ArrayList<>();\\n\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) currRow.add(1);\\n                else {\\n                    currRow.add(\\n                            prevRow.get(j - 1) + prevRow.get(j)\\n                    );\\n                }\\n            }\\n\\n            ans.add(currRow);\\n            prevRow = currRow;\\n        }\\n\\n        return ans.get(rowIndex);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC; O(n ^ 2)\\n```\\n\\n##### 2. A little memory optimization:\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        Arrays.fill(ans, 0);    // O(n)\\n        ans[0] = 1;\\n\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = i; j > 0; j--) {\\n                ans[j] += ans[j - 1];\\n            }\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n// SC: O(n)\\n```\\n##### 3. Optimal solution (Using formula):\\nFormula: **```nCr = nC(r - 1) * (n - r + 1) / r;```**\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        ans[0] = 1;\\n\\n        for (int r = 1; r <= rowIndex; r++) {\\n            ans[r] = (int) ((long) ans[r - 1] * (rowIndex - r + 1) / r);\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> currRow, prevRow = null;\\n\\n        for (int i = 0; i <= rowIndex; i++) {\\n            currRow = new ArrayList<>();\\n\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) currRow.add(1);\\n                else {\\n                    currRow.add(\\n                            prevRow.get(j - 1) + prevRow.get(j)\\n                    );\\n                }\\n            }\\n\\n            ans.add(currRow);\\n            prevRow = currRow;\\n        }\\n\\n        return ans.get(rowIndex);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC; O(n ^ 2)\\n```\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        Arrays.fill(ans, 0);    // O(n)\\n        ans[0] = 1;\\n\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = i; j > 0; j--) {\\n                ans[j] += ans[j - 1];\\n            }\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n) + O(n ^ 2) => O(n ^ 2)\\n// SC: O(n)\\n```\n```nCr = nC(r - 1) * (n - r + 1) / r;```\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        Integer[] ans = new Integer[rowIndex + 1];\\n        ans[0] = 1;\\n\\n        for (int r = 1; r <= rowIndex; r++) {\\n            ans[r] = (int) ((long) ans[r - 1] * (rowIndex - r + 1) / r);\\n        }\\n\\n        return Arrays.asList(ans);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429494,
                "title": "1-ms-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        int n=rowIndex;\\n       List<Integer> res=new ArrayList<Integer>();\\n       res.add(1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n           int x= (int) ( ((long)res.get(res.size()-1)*(n-i+1) ) /i);\\n           res.add(x);\\n        }\\n        \\n        return res;\\n    }\\n  \\n}       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        int n=rowIndex;\\n       List<Integer> res=new ArrayList<Integer>();\\n       res.add(1);\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n           int x= (int) ( ((long)res.get(res.size()-1)*(n-i+1) ) /i);\\n           res.add(x);\\n        }\\n        \\n        return res;\\n    }\\n  \\n}       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742190,
                "title": "python-3-40ms-iterative-easy-approach",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res=[]\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538576,
                "title": "c-100-faster-simple-solution",
                "content": "This solution is based on the relation between row, column, and digits of pascal\\'s triangle. This way, we don\\'t have to store any rows of the pascal\\'s triangle for further calculation, thus making the program, fast.\\n\\nFeel free to ask any doubts below.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> result;\\n        \\n        long temp = 1;\\n        \\n        for(int i=0; i<=rowIndex; i++){\\n            \\n            for(int j=0; j<=i; j++){\\n                \\n                if(j == 0 || i == 0)\\n                    temp = 1;\\n                \\n                else\\n                    temp = temp * (i-j+1)/j;\\n                \\n                if(i == rowIndex)\\n                    result.push_back(temp);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> result;\\n        \\n        long temp = 1;\\n        \\n        for(int i=0; i<=rowIndex; i++){\\n            \\n            for(int j=0; j<=i; j++){\\n                \\n                if(j == 0 || i == 0)\\n                    temp = 1;\\n                \\n                else\\n                    temp = temp * (i-j+1)/j;\\n                \\n                if(i == rowIndex)\\n                    result.push_back(temp);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459365,
                "title": "python-top-down-dp-o-n-space-clean-concise",
                "content": "```python\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        dpPrev = [1] * (rowIndex + 1)\\n        dp = [1] * (rowIndex + 1)\\n        for r in range(1, rowIndex+1):\\n            for c in range(1, r):\\n                dp[c] = dpPrev[c-1] + dpPrev[c]\\n            dp, dpPrev = dpPrev, dp\\n        \\n        return dpPrev\\n```\\nComplexity:\\n- Time: `O(rowIndex^2)`, where `rowIndex <= 33)`.\\n- Space: `O(rowIndex)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        dpPrev = [1] * (rowIndex + 1)\\n        dp = [1] * (rowIndex + 1)\\n        for r in range(1, rowIndex+1):\\n            for c in range(1, r):\\n                dp[c] = dpPrev[c-1] + dpPrev[c]\\n            dp, dpPrev = dpPrev, dp\\n        \\n        return dpPrev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294924,
                "title": "c-o-n-time-and-o-n-space-solution-with-explanation",
                "content": "**Concept: Assuming the rows of pascal triangle to be 0-indexed, the terms of the nth   row will be: nC0,nC1,nC2,nC3.......nCn.**\\n**Now we know that nC0 is equal to 1.Let us store it in variable \\'prev\\'.**\\n**We will calculate next terms of the sequence using standard formula which is: nCr=((nCr-1)(n-r+1))/r**\\n**Let us store this value in a variable named \\'curr\\'.**\\n**Now at each step we will update prev=curr for calculation of next term of sequence.**\\n\\n\\n**Points to Remember:**\\n**while calculating next term the value calculated may overflow for higher values of n. So store \\'previous\\' term in a long long int variable**\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        if(n==0){\\n            return {1};\\n        }\\n        long long int prev=1;\\n        vector<int>result;\\n        result.push_back(1);\\n        for(int i=1;i<=n;++i){\\n            int curr=(prev*(n-i+1))/i;\\n            prev=curr;\\n            result.push_back(prev);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int n) {\\n        if(n==0){\\n            return {1};\\n        }\\n        long long int prev=1;\\n        vector<int>result;\\n        result.push_back(1);\\n        for(int i=1;i<=n;++i){\\n            int curr=(prev*(n-i+1))/i;\\n            prev=curr;\\n            result.push_back(prev);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070447,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {        \\n        List<Integer> row = new ArrayList<>();\\n        row.add(1);\\n        \\n        if (rowIndex == 0) {\\n            return row;\\n        }\\n\\n        row.add(1);\\n        if (rowIndex == 1) {\\n            return row;\\n        }\\n        \\n        int currentIndex = 1;\\n        while (currentIndex < rowIndex) {\\n            int size = row.size();\\n            int current = 0;\\n            while (current < size - 1) {\\n                row.add(row.get(0) + row.get(1));\\n                row.remove(0);\\n                current++;\\n            }\\n            row.add(1);\\n            currentIndex++;\\n        }\\n        \\n        return row;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {        \\n        List<Integer> row = new ArrayList<>();\\n        row.add(1);\\n        \\n        if (rowIndex == 0) {\\n            return row;\\n        }\\n\\n        row.add(1);\\n        if (rowIndex == 1) {\\n            return row;\\n        }\\n        \\n        int currentIndex = 1;\\n        while (currentIndex < rowIndex) {\\n            int size = row.size();\\n            int current = 0;\\n            while (current < size - 1) {\\n                row.add(row.get(0) + row.get(1));\\n                row.remove(0);\\n                current++;\\n            }\\n            row.add(1);\\n            currentIndex++;\\n        }\\n        \\n        return row;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913200,
                "title": "python3-just-1-line-using-binomial-theorem",
                "content": "comb function\\uFF1A**comb(n,m) = n!/(m!(n-m)!)**\\nFor line n in Pasca triangle, the numbers from left to right are:\\n`comb(n-1,0), comb(n-1,1),......, comb(n-1, n-2), comb(n-1, n-1)`\\nAnd this is **Binomial Theorem**\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex,j) for j in range(rowIndex+1)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        return [comb(rowIndex,j) for j in range(rowIndex+1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418061,
                "title": "javascript-solution-recursive",
                "content": "> Runtime: 52 ms, faster than 80.61% of JavaScript online submissions for Pascal\\'s Triangle II.\\n> Memory Usage: 33.7 MB, less than 90.00% of JavaScript online submissions for Pascal\\'s Triangle II.\\n\\n```js\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) {\\n        return [1]\\n    }\\n    if (rowIndex > 0) {\\n        let a = [1]\\n        let p = getRow(rowIndex - 1)\\n        for (let i = 1; i < rowIndex; i++) {\\n            a[i] = p[i - 1] + p[i]\\n        }\\n        a.push(1)\\n        return a\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\n/**\\n * @param {number} rowIndex\\n * @return {number[]}\\n */\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) {\\n        return [1]\\n    }\\n    if (rowIndex > 0) {\\n        let a = [1]\\n        let p = getRow(rowIndex - 1)\\n        for (let i = 1; i < rowIndex; i++) {\\n            a[i] = p[i - 1] + p[i]\\n        }\\n        a.push(1)\\n        return a\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245504,
                "title": "python-recursive",
                "content": "```python\\ndef getRow(self, rowIndex: \\'int\\') -> \\'List[int]\\':\\n\\tif rowIndex == 0: return [1]\\n\\tans = self.getRow(rowIndex - 1)\\n\\treturn [1] + [sum(x) for x in zip(ans, ans[1:])] + [1]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\ndef getRow(self, rowIndex: \\'int\\') -> \\'List[int]\\':\\n\\tif rowIndex == 0: return [1]\\n\\tans = self.getRow(rowIndex - 1)\\n\\treturn [1] + [sum(x) for x in zip(ans, ans[1:])] + [1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38484,
                "title": "my-0ms-accepted-java-solution-using-a-property-of-ncr",
                "content": "**High level description:**\\nWe know that each element of Pascal's triangle is just nCr, where n is the row number and r is the column number.\\nNow, if we know the value of nCr, then we can calculate the value of nCr+1 (i.e. for the next column).\\nIf you expand nCr+1, it can be written as: nCr * (n-r)/(r+1).\\nThus, I make a for loop which runs k time and calculates nCr+1 by using nCr.\\nHere is the code. Feel free to ask questions and make suggestions.\\n\\n**Code:**\\n```\\npublic class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        long coeff = 1; // nC0\\n        // n = rowIndex, j=r\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int j=0;j<=rowIndex;j++){\\n                result.add((int)coeff);\\n                coeff = coeff * (rowIndex-j)/(j+1); // calculating nCr using nCr-1\\n            }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        long coeff = 1; // nC0\\n        // n = rowIndex, j=r\\n        List<Integer> result = new ArrayList<Integer>();\\n        for(int j=0;j<=rowIndex;j++){\\n                result.add((int)coeff);\\n                coeff = coeff * (rowIndex-j)/(j+1); // calculating nCr using nCr-1\\n            }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38560,
                "title": "c-implementation",
                "content": "    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(rowIndex+1, 0);\\n            result[0]=1;\\n            for(int i=1; i<=rowIndex; i++){\\n                for(int j=i; j>=1; j--)\\n                    result[j]=result[j]+result[j-1];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(rowIndex+1, 0);\\n            result[0]=1;\\n            for(int i=1; i<=rowIndex; i++){\\n                for(int j=i; j>=1; j--)\\n                    result[j]=result[j]+result[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38571,
                "title": "o-k-python-code",
                "content": "class Solution(object):\\n\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        for i in range(1,rowIndex+2):\\n            # there are i elements\\n            result.append(1)\\n            for j in range(i-2,0,-1):\\n                result[j] += result[j-1]\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        for i in range(1,rowIndex+2):\\n            # there are i elements\\n            result.append(1)\\n            for j in range(i-2,0,-1):\\n                result[j] += result[j-1]\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 38575,
                "title": "share-my-c-code-easy-understand",
                "content": "int* getRow(int rowIndex, int* returnSize) {\\n\\n    if (rowIndex < 0)\\n        return NULL;\\n\\n    int *res = (int*)malloc(sizeof(int) * (rowIndex + 1));\\n\\n    for (int row = 0; row <= rowIndex; row++)\\n        for (int col = row; col >= 0; col--)\\n            res[col] = (col == 0 || col == row) ? 1 : res[col] + res[col - 1];\\n\\n    *returnSize = rowIndex + 1;\\n    return res;\\n}",
                "solutionTags": [],
                "code": "int* getRow(int rowIndex, int* returnSize) {\\n\\n    if (rowIndex < 0)\\n        return NULL;\\n\\n    int *res = (int*)malloc(sizeof(int) * (rowIndex + 1));\\n\\n    for (int row = 0; row <= rowIndex; row++)\\n        for (int col = row; col >= 0; col--)\\n            res[col] = (col == 0 || col == row) ? 1 : res[col] + res[col - 1];\\n\\n    *returnSize = rowIndex + 1;\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4034497,
                "title": "python-solution-with-briefly-explanation",
                "content": "# Explanation\\nLet\\'s break down the given code step by step.\\n\\n```python\\ndef getRow(self, rowIndex: int) -> List[int]:\\n    res = [[1]]\\n```\\n- This function is defined as a method within a class, as it has `self` as its first parameter. It takes an integer `rowIndex` as input and is expected to return a list of integers.\\n- `res` is initialized as a list containing a single list with the value `[1]`. This list represents the first row of Pascal\\'s Triangle.\\n\\n```python\\n    for i in range(rowIndex):\\n        temp = [0] + res[-1] + [0]\\n        row = []\\n```\\n- A loop is set up to iterate from 0 to `rowIndex - 1`. This loop is used to calculate the subsequent rows of Pascal\\'s Triangle.\\n- `temp` is initialized as a new list, which is formed by adding `0` at the beginning and end of the last row in `res`. This is done to create a buffer of zeros around the row to calculate the next row.\\n- `row` is initialized as an empty list. This list will store the values of the current row being calculated.\\n\\n```python\\n        for j in range(len(res[-1])+1):\\n            row.append(temp[j] + temp[j+1])\\n```\\n- Another nested loop is set up to iterate over the elements of `temp` and calculate the values of the current row.\\n- For each element at index `j` in `temp`, it adds the value at index `j` and the value at index `j+1` and appends the result to the `row` list.\\n\\n```python\\n        res.append(row)\\n```\\n- After calculating all the values for the current row, the `row` list is appended to the `res` list. This adds a new row to the list, representing the current row of Pascal\\'s Triangle.\\n\\n```python\\n    return res[-1]\\n```\\n- After the loop completes (i.e., all rows up to `rowIndex` have been calculated and added to `res`), the function returns the last row of `res`, which corresponds to the row at index `rowIndex` in Pascal\\'s Triangle.\\n\\nIn summary, this code calculates and returns the `rowIndex`-th row of Pascal\\'s Triangle using a list-based approach, where each row is calculated based on the previous row. It builds up the rows one by one, starting with the first row as `[1]` and using the values from the previous row to calculate the next row.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = [[1]]\\n        \\n        for i in range(rowIndex):\\n            temp = [0] + res[-1] + [0]\\n            row = []\\n\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j] + temp[j+1])\\n            res.append(row)\\n\\n        return res[-1]\\n```\\n**Please upvote if you like the solution & feel free to give your opinion. \\nHappy Coding! \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python\\ndef getRow(self, rowIndex: int) -> List[int]:\\n    res = [[1]]\\n```\n```python\\n    for i in range(rowIndex):\\n        temp = [0] + res[-1] + [0]\\n        row = []\\n```\n```python\\n        for j in range(len(res[-1])+1):\\n            row.append(temp[j] + temp[j+1])\\n```\n```python\\n        res.append(row)\\n```\n```python\\n    return res[-1]\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = [[1]]\\n        \\n        for i in range(rowIndex):\\n            temp = [0] + res[-1] + [0]\\n            row = []\\n\\n            for j in range(len(res[-1])+1):\\n                row.append(temp[j] + temp[j+1])\\n            res.append(row)\\n\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977562,
                "title": "intuitive-dynamic-programming-o-n-2",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> prev = new ArrayList<Integer>();\\n        prev.add(1);\\n        for(int i=0;i< rowIndex; i++){\\n            List<Integer> pres = new ArrayList<Integer>();\\n            pres.add(1);\\n            for(int j=1;j < prev.size(); j++){\\n                pres.add(j, prev.get(j)+prev.get(j-1));\\n            }\\n            pres.add(1);\\n            prev = pres;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> prev = new ArrayList<Integer>();\\n        prev.add(1);\\n        for(int i=0;i< rowIndex; i++){\\n            List<Integer> pres = new ArrayList<Integer>();\\n            pres.add(1);\\n            for(int j=1;j < prev.size(); j++){\\n                pres.add(j, prev.get(j)+prev.get(j-1));\\n            }\\n            pres.add(1);\\n            prev = pres;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231430,
                "title": "easy-to-understand-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n       List<List<Integer>> dp = new ArrayList<List<Integer>>();\\n        ArrayList<Integer> sp = new ArrayList<Integer>();\\n        sp.add(1);\\n        dp.add(sp);\\n        \\n        ArrayList<Integer> sp2 = new ArrayList<Integer>();\\n        sp2.add(1);\\n        sp2.add(1);\\n        dp.add(sp2);\\n        \\n        for(int i = 2; i <= rowIndex; i++){\\n            ArrayList<Integer> sp3 = new ArrayList<Integer>();\\n            sp3.add(1);\\n            List<Integer> use = dp.get(i-1);\\n            int p1 = 0;\\n            int p2 = 1;\\n            while(p2 < use.size()){\\n                int sum = use.get(p1)+use.get(p2);\\n                sp3.add(sum);\\n                p1++;\\n                p2++;\\n            }\\n            sp3.add(1);\\n            dp.add(sp3);\\n        }\\n        return dp.get(rowIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n       List<List<Integer>> dp = new ArrayList<List<Integer>>();\\n        ArrayList<Integer> sp = new ArrayList<Integer>();\\n        sp.add(1);\\n        dp.add(sp);\\n        \\n        ArrayList<Integer> sp2 = new ArrayList<Integer>();\\n        sp2.add(1);\\n        sp2.add(1);\\n        dp.add(sp2);\\n        \\n        for(int i = 2; i <= rowIndex; i++){\\n            ArrayList<Integer> sp3 = new ArrayList<Integer>();\\n            sp3.add(1);\\n            List<Integer> use = dp.get(i-1);\\n            int p1 = 0;\\n            int p2 = 1;\\n            while(p2 < use.size()){\\n                int sum = use.get(p1)+use.get(p2);\\n                sp3.add(sum);\\n                p1++;\\n                p2++;\\n            }\\n            sp3.add(1);\\n            dp.add(sp3);\\n        }\\n        return dp.get(rowIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197044,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>>v;\\n        for (int i=0; i<rowIndex+1; i++) {\\n            vector<int>v1(i+1, 1);\\n            for (int j=1; j<i; j++) {\\n                v1[j]=v[i-1][j]+v[i-1][j-1];\\n            }\\n            v.push_back(v1);\\n        }\\n        return v[rowIndex];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>>v;\\n        for (int i=0; i<rowIndex+1; i++) {\\n            vector<int>v1(i+1, 1);\\n            for (int j=1; j<i; j++) {\\n                v1[j]=v[i-1][j]+v[i-1][j-1];\\n            }\\n            v.push_back(v1);\\n        }\\n        return v[rowIndex];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073377,
                "title": "c-fastest-submission-tc-o-n-sc-o-1-tabulation",
                "content": "TC: O(N^2)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int row) {\\n        \\n        vector<int>prev(row+1);\\n        vector<int>curr(row+1);\\n        prev[0]=1;\\n        for(int i=1;i<=row;i++){\\n            for(int j=0;j<=i;j++){\\n                curr[j] = (j-1<0 ? 0: prev[j-1]) + prev[j];\\n            }\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int row) {\\n        \\n        vector<int>prev(row+1);\\n        vector<int>curr(row+1);\\n        prev[0]=1;\\n        for(int i=1;i<=row;i++){\\n            for(int j=0;j<=i;j++){\\n                curr[j] = (j-1<0 ? 0: prev[j-1]) + prev[j];\\n            }\\n            prev=curr;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971864,
                "title": "0ms-c-solution-beats-100-using-just-1-array-returnsize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2) - Every single row above rowIndex is iterated, but not stored\\n\\n- Space complexity:\\nO(1) - No extra space used scaling with input size\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* getRow(int rowIndex, int* returnSize){\\n\\n\\n        //challenge to use O(rowIndex) space\\n        //at rowIndex, there are (rowIndex+1) space\\n\\n        int* ret = (int*)malloc(sizeof(int)*(rowIndex+1));\\n        ret[0]=1; // base case on top\\n        for (int i=1; i<rowIndex+1;i++){\\n            ret[i]=1; //sets last index of current row to 1\\n            int o=1;\\n            for (int j=1; j<i;j++){ \\n                //sum up \"prev row\" index j-1 and j and put in j\\n                //-> index j original value needs to be saved\\n                ret[j] = o + ret[j];\\n                o=ret[j]-o;\\n            }\\n        }\\n\\n        *returnSize=rowIndex+1;\\n        return ret;\\n\\n\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* getRow(int rowIndex, int* returnSize){\\n\\n\\n        //challenge to use O(rowIndex) space\\n        //at rowIndex, there are (rowIndex+1) space\\n\\n        int* ret = (int*)malloc(sizeof(int)*(rowIndex+1));\\n        ret[0]=1; // base case on top\\n        for (int i=1; i<rowIndex+1;i++){\\n            ret[i]=1; //sets last index of current row to 1\\n            int o=1;\\n            for (int j=1; j<i;j++){ \\n                //sum up \"prev row\" index j-1 and j and put in j\\n                //-> index j original value needs to be saved\\n                ret[j] = o + ret[j];\\n                o=ret[j]-o;\\n            }\\n        }\\n\\n        *returnSize=rowIndex+1;\\n        return ret;\\n\\n\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601956,
                "title": "3-lines-answer-for-super-concise-nerd-enthusiast",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> list = new ArrayList<Integer>(); list.add(1);\\n        for(long i=1,temp=1,l=rowIndex,r=1;i<=rowIndex;i++)\\n            list.add((int)(temp=(temp*l--)/r++));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> list = new ArrayList<Integer>(); list.add(1);\\n        for(long i=1,temp=1,l=rowIndex,r=1;i<=rowIndex;i++)\\n            list.add((int)(temp=(temp*l--)/r++));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469676,
                "title": "javascript-simple-solution-beats-75",
                "content": "```\\nvar getRow = function(rowIndex) {\\n    let res = [];\\n    for(let i=0;i<=rowIndex;i++){\\n        res[i] = [];\\n        res[i][0] = 1;\\n        for(let j=1;j<i;j++){\\n            res[i][j] = res[i-1][j-1]+ res[i-1][j];\\n        }\\n        res[i][i] = 1;\\n    }\\n    return res[rowIndex];\\n};\\n```\\n\\nConsider **Upvote** if you find it useful \\uD83D\\uDE00",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getRow = function(rowIndex) {\\n    let res = [];\\n    for(let i=0;i<=rowIndex;i++){\\n        res[i] = [];\\n        res[i][0] = 1;\\n        for(let j=1;j<i;j++){\\n            res[i][j] = res[i-1][j-1]+ res[i-1][j];\\n        }\\n        res[i][i] = 1;\\n    }\\n    return res[rowIndex];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2415016,
                "title": "c-o-n-2-100-faster-0ms-very-easy-to-understand",
                "content": "**Pascal\\'s Triangle II**\\n **nCr** *approach*\\n **nCr** = **nC(r-1)** *x (n-r)/(r+1)    (main approach)*\\n\\n\\n    vector<int> getRow(int n) {\\n        n++;\\n        vector<int> ans (n,1);\\n        for(int i=1;i<(n+1)/2;i++)\\n\\t\\t\\tans[i]=ans[n-i-1]=((long long)ans[i-1]*(n-i))/i;\\n        return ans;\\n    }\\n\\n\\n**Time Complexity = O(n)** *~O(n/2)*\\n**Space Complexity = O(n)** *~no extra space other then the returning vec*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**Pascal\\'s Triangle II**\\n **nCr** *approach*\\n **nCr** = **nC(r-1)** *x (n-r)/(r+1)    (main approach)*\\n\\n\\n    vector<int> getRow(int n) {\\n        n++;\\n        vector<int> ans (n,1);\\n        for(int i=1;i<(n+1)/2;i++)\\n\\t\\t\\tans[i]=ans[n-i-1]=((long long)ans[i-1]*(n-i))/i;\\n        return ans;\\n    }\\n\\n\\n**Time Complexity = O(n)** *~O(n/2)*\\n**Space Complexity = O(n)** *~no extra space other then the returning vec*\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2411635,
                "title": "easy-c-code",
                "content": "public class Solution {\\n    public IList<int> GetRow(int r) {\\n       \\n       int[] v=new int[r+1]; \\n        v[0]=1;\\n        for(int i=0;i<=r;++i)\\n        {\\n            for(int j=i;j>0;--j)\\n            {\\n               v[j]=v[j]+v[j-1];\\n            }\\n        }\\n        return v;\\n    \\n\\t}\\n}\\n\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "class Solution {\\n    public IList<int> GetRow(int r) {\\n       \\n       int[] v=new int[r+1]; \\n        v[0]=1;\\n        for(int i=0;i<=r;++i)\\n        {\\n            for(int j=i;j>0;--j)\\n            {\\n               v[j]=v[j]+v[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2329211,
                "title": "c-4-lines-combinatroics",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowindex) {\\n     vector<int> res;\\n        int i=rowindex;\\n        long val=1;\\n        for(int j=0;j<=i;j++){\\n            res.push_back(val);\\n        val=val*(i-j)/(j+1);    //formula to generate val of next row\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowindex) {\\n     vector<int> res;\\n        int i=rowindex;\\n        long val=1;\\n        for(int j=0;j<=i;j++){\\n            res.push_back(val);\\n        val=val*(i-j)/(j+1);    //formula to generate val of next row\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994482,
                "title": "100-faster-solution-with-very-less-space",
                "content": "![image](https://assets.leetcode.com/users/images/4e96562f-28f4-44e5-bce7-f9c44d40c179_1651330470.2597287.png)\\n\\n\\'\\'\\' \\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> v(rowIndex+1,1);         // intilizing with 1  \\n        \\n        for( int i=3 ; i <= rowIndex+1 ; i++)            \\n            for( int j=i-1 ; j > 1 ; j--)    \\n                v[ j-1 ] =  v[  j-1 ] + v[ j-2 ] ;\\n        \\n        return v;\\n    }\\n};\\n\\n\\'\\'\\'\\nLet\\'s see solution for rowIndex = 0\\n\\nv={1}  // as v is intialized to rowIndex+1 so 0+1 =1 will be vector size with value 1\\n\\ni=3 and it will check i <= rowIndex+1 i.e  (3<=0+1) which is false so it will not enter inside\\nso it will return v i.e {1} and we got our Correct answer \\n\\n*************************************\\n\\nNow Let\\'s see solution for rowIndex = 1\\n\\nv={1,1}  // as v is intialized to rowIndex+1 so 1+1 =2 will be vector size with values 1\\n\\ni=3 and it will check i <= rowIndex+1 i.e  (3<=1+1) which is false so it will not enter inside\\nso it will return v i.e {1,1} and we got our Correct answer \\n\\n\\n************************************\\n\\nNow last let\\'s see Solution for rowIndex =2\\n\\nv={1,1,1}  // as v is intialized to rowIndex+1 so 2+1 =3 will be vector size with values 1\\n\\ni=3 and it will check i <= rowIndex+1 i.e  (3<=2+1) which is true  so it will enter inside\\n   now j=i-1 i.e 3-1 = 2 and will check 2 > 1 which is true so it will  go inside .\\n   // v is {1 , 1 , 1}\\n   v[j-1] i.e v[2-1] i.e v[1] = v[1] + v[2] means v[1] = 1+1 = 2\\n   so now V is {1 , 2 , 1}\\n   j will become 1 and condition will fail and come out of j loop \\n   and i will increase to 4\\n   \\ni=4 and it will check i <= rowIndex+1 i.e  (4<=2+1) which is false so it will not enter inside\\n \\nso it will return V i.e {1,2,1}  and we Got same Correct Answer .\\n\\n****************************\\n\\nAnd So On .........................\\n\\nIf you feel it\\'s good solution then Upvote it\\n\\nThank You so Much for taking look at my 1st  posted solution !!!\\n   \\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        vector<int> v(rowIndex+1,1);         // intilizing with 1  \\n        \\n        for( int i=3 ; i <= rowIndex+1 ; i++)            \\n            for( int j=i-1 ; j > 1 ; j--)    \\n                v[ j-1 ] =  v[  j-1 ] + v[ j-2 ] ;\\n        \\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1889644,
                "title": "java-solution-three-possible-solutions-1-simple-approach-2-dp-approach-3-ncr-approach",
                "content": "1) Simple approach with O(n^2) Time complexity and O(n^2) Space complexity:\\n```\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> mainPascii=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer> subPascii=new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                if(j==0){\\n                    subPascii.add(1);\\n                    continue;\\n                }\\n                else\\n                {\\n                    subPascii.add(mainPascii.get(i-1).get(j-1)+mainPascii.get(i-1).get(j));\\n                }\\n            }\\n            subPascii.add(1);\\n            mainPascii.add(subPascii);\\n        }\\n        return mainPascii.get(rowIndex);\\n    }\\n```\\n2) DP approach with O(n^2) Time complexity and O(n) Space complexity:\\n```\\n  public List<Integer> getRow(int rowIndex) {\\n        Integer[]dp=new Integer[rowIndex+1];\\n        dp[0]=1;\\n        long prev=1;\\n        long curr=0;\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = 1; j <i ; j++) {\\n                curr=dp[j];\\n                dp[j]=(int)(prev+curr);\\n                prev=curr;\\n            }\\n            dp[i]=1;\\n        }\\n        return Arrays.asList(dp);\\n    }\\n```\\n3) nCr approach with O(n) Time complexity and O(n) Space complexity:\\n\\nAdded the nCr logic below:\\n\\n       Lets take example for the below triangle\\n     \\n               1   ------------> Row 0\\n             1   1  -----------> Row 1\\n            1  2  1  ----------> Row 2\\n          1  3  3  1  ---------> Row 3\\n        1  4  6  4  1  -------> Row 4\\n     \\n     \\n         Each of the position can be represented as nCj  (n = row number and j = column number)\\n     \\n                        0c0   ------------> Row 0\\n                    1c0    1c1  -----------> Row 1\\n                 2c0   2c1     2c2  ----------> Row 2\\n             3c0    3c1    3c2    3c3  ---------> Row 3\\n         4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n     \\n        Formula of  NcR = N! / (N - R)! * R!\\n     \\n        Note :  Nc0 >> 1  &   NcN >> 1\\n     \\n        Suppose we have to get the 4th Row\\n                                  4c0    4c1    4c2    4c3     4c4  -------> Row 4\\n      This can be represented as : NcR   NcR+1  NcR+2  NcR+3   NcR+4\\n     \\n      Properties of combination :  NcR * factor = NcR+1 now if we can figure out the value of factor we can make the whole row.\\n     \\n              n!                         n!\\n          ------------ * factor =  ---------------------------\\n          (n-r)! * r!                (n - (r+1))! * (r+1)!\\n     \\n                        (n-r)! * r!                      (n-r) *  (n-r-1)!         n - r\\n          factor = ----------------------------  =   ------------------------- = ----------\\n                     (n - r - 1)! * (r+1) * r!            (n - r - 1)! * (r+1)     r + 1\\n     \\n     \\n         So, the value of factor = (n - r) / ( r + 1)\\n     \\n         With this we can compute the factor and get the next value\\n     \\n```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> rowVal=new ArrayList<>();\\n        long val=1;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            rowVal.add((int)val);\\n            val=val*(rowIndex-i)/(i+1);\\n        }\\n        return rowVal;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        List<List<Integer>> mainPascii=new ArrayList<>();\\n        for(int i=0;i<=rowIndex;i++){\\n            List<Integer> subPascii=new ArrayList<>();\\n            for (int j = 0; j < i; j++) {\\n                if(j==0){\\n                    subPascii.add(1);\\n                    continue;\\n                }\\n                else\\n                {\\n                    subPascii.add(mainPascii.get(i-1).get(j-1)+mainPascii.get(i-1).get(j));\\n                }\\n            }\\n            subPascii.add(1);\\n            mainPascii.add(subPascii);\\n        }\\n        return mainPascii.get(rowIndex);\\n    }\\n```\n```\\n  public List<Integer> getRow(int rowIndex) {\\n        Integer[]dp=new Integer[rowIndex+1];\\n        dp[0]=1;\\n        long prev=1;\\n        long curr=0;\\n        for (int i = 1; i <= rowIndex; i++) {\\n            for (int j = 1; j <i ; j++) {\\n                curr=dp[j];\\n                dp[j]=(int)(prev+curr);\\n                prev=curr;\\n            }\\n            dp[i]=1;\\n        }\\n        return Arrays.asList(dp);\\n    }\\n```\n```\\npublic List<Integer> getRow(int rowIndex) {\\n        List<Integer> rowVal=new ArrayList<>();\\n        long val=1;\\n        for (int i = 0; i <= rowIndex; i++) {\\n            rowVal.add((int)val);\\n            val=val*(rowIndex-i)/(i+1);\\n        }\\n        return rowVal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594620,
                "title": "c-easy-to-understand-faster-than-100-0ms",
                "content": "class Solution {\\npublic:\\n    vector<int> getRow(int n) \\n    {\\n*         vector<vector<int>> ans;\\n        ans.push_back({1});                // 0th row\\n        ans.push_back({1,1});            // 1st row\\n        \\n        // now build the pascle traingle from the 2nd row till nth row\\n        for(int i=2;i<=n;i++)\\n        {\\n            vector<int> v;              // i th row vector\\n            v.push_back(1);             // first eleement of i th row \\n            \\n            for(int j=1;j<i;j++)\\n            {\\n                int k=ans[i-1][j-1]+ans[i-1][j];\\n                v.push_back(k);\\n            }\\n            v.push_back(1);                        // last element of i th row \\n            ans.push_back(v);\\n        }\\n        return ans[n];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int n) \\n    {\\n*         vector<vector<int>> ans;\\n        ans.push_back({1}",
                "codeTag": "Java"
            },
            {
                "id": 1432491,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-pascal-s-triangle-ii",
                "content": "# Easy solution using simple mathematical formula\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int k) {\\n    long long n=1;\\n    vector<int> ans;\\n        for(int i=0;i<=k;i++){\\n            ans.push_back(n);\\n            n=n*(k-i)/(i+1);    //maths\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you find it helpful :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int k) {\\n    long long n=1;\\n    vector<int> ans;\\n        for(int i=0;i<=k;i++){\\n            ans.push_back(n);\\n            n=n*(k-i)/(i+1);    //maths\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338801,
                "title": "c-code-beats-100-in-speed-simple-math",
                "content": "//            1           -> row 0\\n//         1   1         -> row 1\\n//         1   2   1       -> row 2\\n//       1   3   3   1     -> row 3\\n//     1   4   6   4   1   -> row 4       \\n//       By analyzing the row of pascal triangle we can find that every element of row-index row (0-indexed) \\n//          and column-index col (0-indexed)  can be find by using formula C(row,col) i.e. combination(row,col)\\n               \\n//                 C(n,r) = n! / ( r! * (n -r)!) \\n                        \\n//                         = (n*(n-1).... r terms) / (r*(r-1)*(r-2)....1)     short form \\n                \\n//                 Example : C(6,3) = (6 * 5 * 4)/(3 * 2 * 1) = 20\\n\\n//  We are using the same method in this solution to find the element of pascal triangle \\n        \\n```\\nvector<int> getRow(int rowIndex) {    \\n        vector<int> result;\\n        long int temp = rowIndex;\\n        int a=rowIndex, b=1;\\n        for(int i=0;i<rowIndex+1;i++){\\n            if(i==0 || i==rowIndex) result.push_back(1);\\n            else {\\n                result.push_back(temp);\\n                temp = (temp*(--a))/++b; \\n            }\\n        }\\n        return result;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> getRow(int rowIndex) {    \\n        vector<int> result;\\n        long int temp = rowIndex;\\n        int a=rowIndex, b=1;\\n        for(int i=0;i<rowIndex+1;i++){\\n            if(i==0 || i==rowIndex) result.push_back(1);\\n            else {\\n                result.push_back(temp);\\n                temp = (temp*(--a))/++b; \\n            }\\n        }\\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1336265,
                "title": "my-solution-in-o-n-based-on-properties-of-pascals-s-triangle",
                "content": "The property of pascal triangle used here is Nc(R+1) = NcR * (N-R)/(R+1) where N is the row number 0-indexed and R is the column number also 0-indexed.\\n\\nYou can derive the formulae for yourself by doing some simple math after expanding Nc(R+1).\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n    List<Integer> list = new ArrayList<>();\\n    \\n    list.add(1);\\n    for(int i=1; i<=rowIndex; i++){\\n        long factor = (long)list.get(i-1) * (long)(rowIndex-(i-1));\\n        long num = factor/i;\\n        list.add((int)num);\\n    }\\n    return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n    List<Integer> list = new ArrayList<>();\\n    \\n    list.add(1);\\n    for(int i=1; i<=rowIndex; i++){\\n        long factor = (long)list.get(i-1) * (long)(rowIndex-(i-1));\\n        long num = factor/i;\\n        list.add((int)num);\\n    }\\n    return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323926,
                "title": "various-solutions-with-python-implementation",
                "content": "## Solution#1 - Using Recursion\\n* We can get the `j`th element in `i`th row using the following recurrence:\\n\\t* Recurrence: `f(i, j) = f(i-1, j-1) + f(i-1, j)`\\n\\t* Base cases: `f(0, j) = f(i, 0) = f(i, j) = 1`\\n* We have to use memoization/caching to save repeated work\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* It computes all the values of the pascal triangle upto the row queried.\\n* Space Complexity: `O(n)` \\n\\t* Stores only the required row.\\n\\t* I believe stack space used is also `O(n)` as at any time there won\\'t be more than `n` recursive calls in the stack\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        @cache\\n        def get(i,j):            \\n            if i == 0 or j == 0 or j == i: return 1\\n            return get(i-1,j-1) + get(i-1,j)\\n        \\n        return [get(rowIndex,j) for j in range(rowIndex+1)]\\n```\\n## Solution#2 - Iterative \\n* Same approach as the recursive solution, but implemented in an iterative way.\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* Two nested `O(n)` for loops\\n* Space Complexity: `O(n)` \\n\\t* Stores only the required row.\\n\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]*(rowIndex+1)\\n        for i in range(1, rowIndex):\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1]+row[j]\\n        return row\\n```\\n\\n## Solution #3 - Using Binomial Coefficients\\n* `nCr = C(n, r)` = number of ways to choose `r` items from a set of `n` items (amonth many other interpretations)\\n* `iCj = C(i, j)` is the `j`th element in the `i`th row of the pascal triangle\\n* Time Complexity: `O(n)` where `n = rowIndex`\\n\\t* We directly compute elements of the required row\\n* Space Complexity: `O(n)` \\n\\t* Stores only the required row.\\n* We compute `nCr = n!/(r!*(n-r)!) = (n * n-1 * n-2 * ....) / (1 * 2 * 3 * ...)`\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\'\\'\\'\\n        using C(n, r) = n!/(r!*(n-r)!)\\n        row-0: C(0,0)\\n        row-1: C(1,0) C(1,1)\\n        row-2: C(2,0) C(2,1) C(2,2)\\n        row-3: C(3,0) C(3,1) C(3,2) C(3,3)\\n        row-4: C(4,0) C(4,1) C(4,2) C(4,3) C(4,4)\\n        \\'\\'\\'\\n        answer = [1]\\n        numerator = rowIndex\\n        denominator = 1\\n        while numerator:\\n            answer.append(answer[-1] * numerator//denominator)\\n            denominator += 1\\n            numerator -= 1\\n        return answer\\n```\\n* To write the same thing in a more compact way:\\n```\\n    def getRow(self, R: int) -> List[int]:\\n        row = [1]\\n        for i in range(R):\\n            row.append(row[-1]*(R-i)//(i+1))\\n        return row\\n```\\n\\n## Solution #4 - Pairwise Sum of two lists\\n* Pairwise sum of two lists is denoted by # below\\n* We can generate a row from the previous row in the following way:\\n\\t* Row#0  `[1]`\\n\\t* Row#1  `[0,1] # [1,0] = [1,1]`\\n\\t* Row#2  `[0,1,1] # [1,1,0] = [1,2,1]`\\n\\t* Row#3  `[0,1,2,1] # [1,2,1,0] = [1,3,3,1]`\\n\\t* Row#4  `[0,1,3,3,1] # [1,3,3,1,0] = [1,4,6,4,1]`\\n\\t* and so on .......\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* We are essentially computing all previous rows to arrive to the required row\\n* Space Complexity: `O(n)` \\n\\t* Needs storage for two (or three) lists of `O(n)` length each.\\n\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for _ in range(rowIndex): \\n            row = [x+y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\\n## Solution#5 - Using the Power of 1000...0001\\n* Every row of the pascal triangle has an interesting relationship with powers of 11, 101, 1001, etc.\\n* This allows us to generate the row using the power `100..001^rowIndex`\\n* Let\\'s take an example:\\n\\t* `rowIndex = 6`\\n\\t* `num = 10^6+1 = 1000001`\\n\\t* `string = num^6 = 1000001^6 = 1000006000015000020000015000006000001`\\n\\t* Split this string into chunks of length `6` from the end (leaving the leading 1 alone)\\n\\t* chunks: `1 000006 000015 000020 000015 000006 000001`\\n\\t* convert these chunks to integers: `1 6 15 20 15 6 1`\\n\\t* This gives us the pascal triangle row #6\\n* Time Complexity: `O(n^2)` where `n = rowIndex`\\n\\t* We are directly computing the elements of the required row\\n\\t* However, we have to process a string of length `1+n^2`\\n* Space Complexity: `O(n^2)` \\n\\t* To store the string of length `1+n^2`\\n* *Note:* Complexity of computing `(1+10^n)^n` renders this solution inefficient and impractical.\\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0 : return [1]\\n        num = 10**rowIndex+1\\n        string = str(num**rowIndex)\\n        row = [1]\\n        # for j in range(1, len(string), rowIndex):\\n        #     row.append(int(string[j:j+rowIndex])\\n        # return row\\n        return [1] + [int(string[j:j+rowIndex]) for j in range(1, len(string), rowIndex)]\\n```\\n\\n### A Possible Solution using 11^n ???\\n**THIS IS NOT A SOLUTION, IT\\'S STILL JUST AN IDEA**\\n* It\\'s a well known fact that every row of pascal triangle corresponds to a power of 11.\\n\\t* Row#0 `11^0 = 1`\\n\\t* Row#1  `11^1 = 11`\\n\\t* Row#2  `11^2 = 121`\\n\\t* Row#3  `11^3 = 1331`\\n\\t* Row#4  `11^4 = 14641`\\n* However things get tricky beyond this. You have to carry over the digits other than the unit digit to the previous element and so on.\\n\\t* Row#5 `1 5 10 10 5 1 >> 161051 = 11^5`\\n* If this process is reversible, it may allow us to compute the `n`th row using the digits of `11^n`.\\n* We have to only compute the first `n/2` numbers.\\n* Following is my attempt to figure this out that works only till `n=7` after which it produces incorrect results. If someone can figure it out, please post in comments. I am unlikely to spend more time on this problem.\\n```\\n    # WORK IN PROGRESS\\n\\t# Following works only upto rowIndex = 7\\n    def getRow_power11(self, rowIndex: int) -> List[int]:\\n        row = []\\n        power11 = 11**rowIndex\\n        for _ in range(1+rowIndex//2):\\n            a = power11%10\\n            power11 = power11//10\\n            # TODO: figure out a way to adjust the \"a\" by borrowing from higher digits\\n            while len(row) > 1 and (a - row[-1]) < (row[-1] - row[-2]):\\n                a += 10\\n                power11 -= 1\\n            row.append(a)\\n        return row + row[:rowIndex//2][::-1]    \\n```\\n\\n*Comments and feedback are welcome*",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\n        @cache\\n        def get(i,j):            \\n            if i == 0 or j == 0 or j == i: return 1\\n            return get(i-1,j-1) + get(i-1,j)\\n        \\n        return [get(rowIndex,j) for j in range(rowIndex+1)]\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]*(rowIndex+1)\\n        for i in range(1, rowIndex):\\n            for j in range(i, 0, -1):\\n                row[j] = row[j-1]+row[j]\\n        return row\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        \\'\\'\\'\\n        using C(n, r) = n!/(r!*(n-r)!)\\n        row-0: C(0,0)\\n        row-1: C(1,0) C(1,1)\\n        row-2: C(2,0) C(2,1) C(2,2)\\n        row-3: C(3,0) C(3,1) C(3,2) C(3,3)\\n        row-4: C(4,0) C(4,1) C(4,2) C(4,3) C(4,4)\\n        \\'\\'\\'\\n        answer = [1]\\n        numerator = rowIndex\\n        denominator = 1\\n        while numerator:\\n            answer.append(answer[-1] * numerator//denominator)\\n            denominator += 1\\n            numerator -= 1\\n        return answer\\n```\n```\\n    def getRow(self, R: int) -> List[int]:\\n        row = [1]\\n        for i in range(R):\\n            row.append(row[-1]*(R-i)//(i+1))\\n        return row\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        row = [1]\\n        for _ in range(rowIndex): \\n            row = [x+y for x, y in zip([0]+row, row+[0])]\\n        return row\\n```\n```\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        if rowIndex == 0 : return [1]\\n        num = 10**rowIndex+1\\n        string = str(num**rowIndex)\\n        row = [1]\\n        # for j in range(1, len(string), rowIndex):\\n        #     row.append(int(string[j:j+rowIndex])\\n        # return row\\n        return [1] + [int(string[j:j+rowIndex]) for j in range(1, len(string), rowIndex)]\\n```\n```\\n    # WORK IN PROGRESS\\n\\t# Following works only upto rowIndex = 7\\n    def getRow_power11(self, rowIndex: int) -> List[int]:\\n        row = []\\n        power11 = 11**rowIndex\\n        for _ in range(1+rowIndex//2):\\n            a = power11%10\\n            power11 = power11//10\\n            # TODO: figure out a way to adjust the \"a\" by borrowing from higher digits\\n            while len(row) > 1 and (a - row[-1]) < (row[-1] - row[-2]):\\n                a += 10\\n                power11 -= 1\\n            row.append(a)\\n        return row + row[:rowIndex//2][::-1]    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1078617,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        IList<int> prev = new List<int> { 1 };\\n        \\n        for (int i = 1; i <= rowIndex; i++)\\n        {\\n            IList<int> cur = new List<int> { 1 };\\n            \\n            for (int j = 1; j < i; j++)\\n                cur.Add(prev[j - 1] + prev[j]);\\n            \\n            cur.Add(1);\\n            \\n            prev = cur;\\n        }\\n        \\n        return prev;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        IList<int> prev = new List<int> { 1 }",
                "codeTag": "Java"
            },
            {
                "id": 912314,
                "title": "java-beats-100",
                "content": "Java beats 100%  \\nMemory Usage: 37 MB\\n\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      int [][] pascal = new int [rowIndex+1][rowIndex+1];\\n        \\n      pascal[0][0]=1;\\n      for(int i=1;i<=rowIndex;i++){\\n          for(int j=0;j<=rowIndex;j++){\\n              \\n              if(i==j)\\n                  pascal[i][j]=1;  \\n              \\n             else if(j==0)\\n                   pascal[i][j]=1;\\n            \\n              else{\\n                   pascal[i][j]= pascal[i-1][j-1]+pascal[i-1][j];\\n              }\\n              \\n          }\\n        } \\n        \\n        List<Integer>answer = new ArrayList<>(); \\n        for(int i=0;i<=rowIndex;i++){\\n                answer.add(pascal[rowIndex][i]);\\n        }\\n        \\n        return answer;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n      int [][] pascal = new int [rowIndex+1][rowIndex+1];\\n        \\n      pascal[0][0]=1;\\n      for(int i=1;i<=rowIndex;i++){\\n          for(int j=0;j<=rowIndex;j++){\\n              \\n              if(i==j)\\n                  pascal[i][j]=1;  \\n              \\n             else if(j==0)\\n                   pascal[i][j]=1;\\n            \\n              else{\\n                   pascal[i][j]= pascal[i-1][j-1]+pascal[i-1][j];\\n              }\\n              \\n          }\\n        } \\n        \\n        List<Integer>answer = new ArrayList<>(); \\n        for(int i=0;i<=rowIndex;i++){\\n                answer.add(pascal[rowIndex][i]);\\n        }\\n        \\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787469,
                "title": "java-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic List<Integer> getRow (int rowIndex) {\\n\\t\\t\\n\\t\\tList<Integer> ans = new ArrayList <>();\\n\\t\\tans.add (1);\\n\\t\\t\\n\\t\\tfor (int row = 1; row <= rowIndex; row++) {\\n\\t\\t\\tList<Integer> list = new ArrayList <>();\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tfor (int col = 1; col < row; col++) {\\n\\t\\t\\t\\tlist.add (ans.get (col - 1) + ans.get (col));\\n\\t\\t\\t}\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tans.clear ();\\n\\t\\t\\tans.addAll (list);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic List<Integer> getRow (int rowIndex) {\\n\\t\\t\\n\\t\\tList<Integer> ans = new ArrayList <>();\\n\\t\\tans.add (1);\\n\\t\\t\\n\\t\\tfor (int row = 1; row <= rowIndex; row++) {\\n\\t\\t\\tList<Integer> list = new ArrayList <>();\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tfor (int col = 1; col < row; col++) {\\n\\t\\t\\t\\tlist.add (ans.get (col - 1) + ans.get (col));\\n\\t\\t\\t}\\n\\t\\t\\tlist.add (1);\\n\\t\\t\\tans.clear ();\\n\\t\\t\\tans.addAll (list);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659031,
                "title": "clean-java-recursive-solution",
                "content": "```\\n    public List<Integer> getRow(int i) {\\n        if(i  < 0) return new ArrayList();\\n        if(i == 0) return Arrays.asList(1);\\n        if(i == 1) return Arrays.asList(1,1);\\n\\n        List<Integer> op = getRow(i-1);\\n        List<Integer> last = new ArrayList<>(Arrays.asList(1));\\n        for (int j = 0; j < op.size() - 1; j++){\\n            last.add(op.get(j) + op.get(j + 1));\\n        }\\n        last.add(1);\\n        return last; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public List<Integer> getRow(int i) {\\n        if(i  < 0) return new ArrayList();\\n        if(i == 0) return Arrays.asList(1);\\n        if(i == 1) return Arrays.asList(1,1);\\n\\n        List<Integer> op = getRow(i-1);\\n        List<Integer> last = new ArrayList<>(Arrays.asList(1));\\n        for (int j = 0; j < op.size() - 1; j++){\\n            last.add(op.get(j) + op.get(j + 1));\\n        }\\n        last.add(1);\\n        return last; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629622,
                "title": "math-formula-based-rust-solution",
                "content": "Procedural:\\n```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n        let mut res = vec![];\\n        res.push(1);\\n        \\n        for i in 1..row_index + 1 {\\n            let tmp = res[i - 1] as usize * (row_index + 1 - i) / i;\\n            res.push(tmp as i32);\\n        }\\n\\n        res\\n    }\\n}\\n```\\n\\nFunctional:\\n```rust\\nuse std::iter;\\n\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n\\n        iter::once(1)\\n            .chain((1..row_index + 1).scan(1, |prev, i| {\\n                *prev = (*prev as usize * (row_index + 1 - i) / i) as i32;\\n                Some(*prev)\\n            }))\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n        let mut res = vec![];\\n        res.push(1);\\n        \\n        for i in 1..row_index + 1 {\\n            let tmp = res[i - 1] as usize * (row_index + 1 - i) / i;\\n            res.push(tmp as i32);\\n        }\\n\\n        res\\n    }\\n}\\n```\n```rust\\nuse std::iter;\\n\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        let row_index = row_index as usize;\\n\\n        iter::once(1)\\n            .chain((1..row_index + 1).scan(1, |prev, i| {\\n                *prev = (*prev as usize * (row_index + 1 - i) / i) as i32;\\n                Some(*prev)\\n            }))\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 622596,
                "title": "recursion-with-memoization",
                "content": "Assume that row numbering starts at 1. This will make calculations easy.\\n\\nRecurrence relation:\\n*f(r, c) = f(r-1, c-1) + f(r-1, c)*\\n\\nBase case:\\n*f(r, c) = 1* when r == c or when c = 1\\n\\nWe use memoization as we will make same function calls a number of times\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        rowIndex += 1\\n        \\n        mem = {}\\n        \\n        def getVal(row, col):\\n            if col == 1 or col == row:\\n                return 1\\n            else:\\n                if (row-1, col-1) not in mem:\\n                    mem[(row-1, col-1)] = getVal(row-1, col-1)\\n                v1 = mem[(row-1, col-1)]\\n                \\n                if (row-1, col) not in mem:\\n                    mem[(row-1, col)] = getVal(row-1, col)\\n                v2 = mem[(row-1, col)]\\n                \\n                return v1 + v2\\n        \\n        ans = []\\n        \\n        for i in range(1, rowIndex+1):\\n            ans.append(getVal(rowIndex, i))\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        rowIndex += 1\\n        \\n        mem = {}\\n        \\n        def getVal(row, col):\\n            if col == 1 or col == row:\\n                return 1\\n            else:\\n                if (row-1, col-1) not in mem:\\n                    mem[(row-1, col-1)] = getVal(row-1, col-1)\\n                v1 = mem[(row-1, col-1)]\\n                \\n                if (row-1, col) not in mem:\\n                    mem[(row-1, col)] = getVal(row-1, col)\\n                v2 = mem[(row-1, col)]\\n                \\n                return v1 + v2\\n        \\n        ans = []\\n        \\n        for i in range(1, rowIndex+1):\\n            ans.append(getVal(rowIndex, i))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439748,
                "title": "readable-python3-code-o-k-extra-space",
                "content": "This is very similar to question [#118, Pascal\\'s Triangle](https://leetcode.com/problems/pascals-triangle/solution/), but we only need to return the last row, not the whole triangle. Therefore, we do not need to store the whole triangle. It\\'s enough to keep track of the previous row and then calculate the elements of current row based on the previous row. At the end of each main loop, we update the previous row (now it is equal to current row).\\n\\n```\\n        if not rowIndex: return [1]\\n        for i in range(1,rowIndex+1):\\n            row = [1]\\n            for j in range(1,i):\\n                row.append(prev_row[j-1] + prev_row[j]) \\n            row.append(1)\\n            prev_row = row\\n        return row  \\n```",
                "solutionTags": [],
                "code": "```\\n        if not rowIndex: return [1]\\n        for i in range(1,rowIndex+1):\\n            row = [1]\\n            for j in range(1,i):\\n                row.append(prev_row[j-1] + prev_row[j]) \\n            row.append(1)\\n            prev_row = row\\n        return row  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296455,
                "title": "c-concise-beatss-100",
                "content": "```\\npublic class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        var result = new List<int>() {1};\\n        for (int i = 0; i < rowIndex; i++) {\\n            var arr = new List<int>(){1};\\n            arr.AddRange(result.Zip(result.Skip(1), (a, b) => a + b));\\n            arr.Add(1);\\n            result = arr;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> GetRow(int rowIndex) {\\n        var result = new List<int>() {1};\\n        for (int i = 0; i < rowIndex; i++) {\\n            var arr = new List<int>(){1};\\n            arr.AddRange(result.Zip(result.Skip(1), (a, b) => a + b));\\n            arr.Add(1);\\n            result = arr;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210571,
                "title": "simple-python-solution",
                "content": "``` python\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [1] * (rowIndex + 1)\\n        \\n        for row in range(2, rowIndex + 1):\\n            for idx in reversed(range(1, row)):\\n                ans[idx] += ans[idx - 1]\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def getRow(self, rowIndex):\\n        \"\"\"\\n        :type rowIndex: int\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [1] * (rowIndex + 1)\\n        \\n        for row in range(2, rowIndex + 1):\\n            for idx in reversed(range(1, row)):\\n                ans[idx] += ans[idx - 1]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163223,
                "title": "o-k-extra-space-go-solution",
                "content": "if we know the k-1 row, we can get k row.\\nif rowIndex = 1, because rowIndex starts from 0,  my code run like this: \\n\\ni = 0, result is : 1 0 0 \\ni = 1, j = 1, result is : 1 1 0 \\ni = 2, j = 2, result is : 1 1 1\\ni = 2, j = 1, result is : 1 2 1, end the loop \\n\\nHere is my code:\\n```\\nfunc getRow(rowIndex int) []int {\\n    // rowIndex start from 0\\n    rowIndex = rowIndex+1\\n    \\n\\tresult := make([]int, rowIndex)\\n\\tfor i := 0; i < rowIndex; i++ {\\n\\t\\tif i == 0 {\\n\\t\\t\\tresult[i] = 1\\n\\t\\t} else {\\n\\t\\t\\tfor j := rowIndex - 1; j > 0; j-- {\\n\\t\\t\\t\\tresult[j] += result[j-1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getRow(rowIndex int) []int {\\n    // rowIndex start from 0\\n    rowIndex = rowIndex+1\\n    \\n\\tresult := make([]int, rowIndex)\\n\\tfor i := 0; i < rowIndex; i++ {\\n\\t\\tif i == 0 {\\n\\t\\t\\tresult[i] = 1\\n\\t\\t} else {\\n\\t\\t\\tfor j := rowIndex - 1; j > 0; j-- {\\n\\t\\t\\t\\tresult[j] += result[j-1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38551,
                "title": "java-o-k-concise-solution",
                "content": "    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ret = new ArrayList<>(Collections.nCopies(rowIndex+1, 1));\\n        for (int i = 1; i < rowIndex; i++) {\\n            for (int j = rowIndex-i; j < rowIndex; j++) // from left to right\\n                ret.set(j, ret.get(j) + ret.get(j+1));\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> ret = new ArrayList<>(Collections.nCopies(rowIndex+1, 1));\\n        for (int i = 1; i < rowIndex; i++) {\\n            for (int j = rowIndex-i; j < rowIndex; j++) // from left to right\\n                ret.set(j, ret.get(j) + ret.get(j+1));\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38588,
                "title": "10-lines-0ms-c-solution",
                "content": "    vector<int> getRow(int rowIndex) {\\n        vector<int> pascal(rowIndex+1, 0);\\n        pascal[0]=1;\\n        for(int i=1; i<rowIndex+1; ++i){\\n            for(int j=i; j>0; j--){\\n                pascal[j] += pascal[j-1];\\n            }\\n        }\\n        return pascal;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> getRow(int rowIndex) {\\n        vector<int> pascal(rowIndex+1, 0);\\n        pascal[0]=1;\\n        for(int i=1; i<rowIndex+1; ++i){\\n            for(int j=i; j>0; j--){\\n                pascal[j] += pascal[j-1];\\n            }\\n        }\\n        return pascal;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38665,
                "title": "2ms-short-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1; i<=rowIndex; i++) {\\n                result.push_back(1);\\n                for(int j=result.size()-2; j>0; j--)\\n                    result[j] += result[j-1];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> result(1,1);\\n            for(int i=1; i<=rowIndex; i++) {\\n                result.push_back(1);\\n                for(int j=result.size()-2; j>0; j--)\\n                    result[j] += result[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38641,
                "title": "pascal-s-triangle-ii-with-o-1-space",
                "content": "I got an answer with O(1) space.\\n\\nThe idea is that, for n-th row, the value at col j is (n,j) (I mean n choose j here).\\nAnd we have (n,j) = (n, j-1) * (n-j+1) / j. \\n\\nThen we can have the solution as below:\\n\\n    class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> res;\\n            if (rowIndex >= 0) {\\n                res.push_back(1);\\n            }\\n            for (int j = 1; j <= rowIndex; j++) {\\n                res.push_back((double)res.back() * (double)(rowIndex - j + 1) / (double)j);\\n            }\\n            return res;\\n        }\\n    };\\n\\nOne further question I'm wondering is, is it possible eliminate type cast here (which was to avoid overflow)?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> getRow(int rowIndex) {\\n            vector<int> res;\\n            if (rowIndex >= 0) {\\n                res.push_back(1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4081687,
                "title": "100-faster-5-line-code-o-n-derived-easy-permutation-formula",
                "content": "Video Link :\\n\\n[https://youtu.be/LgLcWJrfLmQ?si=MCCrgzemn2LJoaI6]()\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n      vector<int>res;\\n      long long factor = 1 ;\\n      for(int i = 0 ; i <= rowIndex ; i++){\\n        res.push_back(factor);\\n        factor = factor * (rowIndex - i)/(i+1);\\n      }\\n      return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n      vector<int>res;\\n      long long factor = 1 ;\\n      for(int i = 0 ; i <= rowIndex ; i++){\\n        res.push_back(factor);\\n        factor = factor * (rowIndex - i)/(i+1);\\n      }\\n      return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721617,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to return the `rowIndex`th row of Pascal\\'s triangle. Pascal\\'s triangle is a triangle of numbers where each number is the sum of the two numbers directly above it. The first two rows are always `[1]` and `[1,1]`. We can use this information to generate subsequent rows until we reach the desired row.\\n\\n# Approach\\n1. Initialize a `triangle` list with the first two rows of Pascal\\'s triangle: `[[1],[1,1]]`.\\n2. Check if `rowIndex` is 0 or 1, and return the corresponding row if it is.\\n3. Initialize an empty list `curr` to store the current row, and a list `prev` to store the previous row.\\n4. Use a while loop to iterate from 2 to `rowIndex`, inclusive.\\n5. For each iteration, use a for loop to iterate from 0 to `i+1`, where `i` is the current row index.\\n6. If `j` (the current column index) is 0 or `i`, append 1 to `curr`.\\n7. Otherwise, append the sum of the two numbers directly above (`prev[j-1]` and `prev[j]`) to `curr`.\\n8. Set `prev` to `curr`, and reset `curr` to an empty list.\\n9. Return `prev`.\\n\\n# Complexity\\n- Time complexity: $$O(rowIndex^2)$$\\n- Space complexity: $$O(rowIndex)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [[1],[1,1]]\\n        if rowIndex==0:\\n            return triangle[0]\\n        if rowIndex==1:\\n            return triangle[1]\\n        curr = []\\n        prev = [1,1]\\n        i = 2\\n        while i<=rowIndex:\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    curr.append(1)\\n                else:\\n                    curr.append(prev[j-1]+prev[j])\\n            prev = curr\\n            curr = []\\n            i+=1\\n        return prev\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        triangle = [[1],[1,1]]\\n        if rowIndex==0:\\n            return triangle[0]\\n        if rowIndex==1:\\n            return triangle[1]\\n        curr = []\\n        prev = [1,1]\\n        i = 2\\n        while i<=rowIndex:\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    curr.append(1)\\n                else:\\n                    curr.append(prev[j-1]+prev[j])\\n            prev = curr\\n            curr = []\\n            i+=1\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532948,
                "title": "pascal-s-triangle-ii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int i, j;\\n        vector<vector<int>> ans;\\n        vector<int> arr;\\n        for(i=0 ; i<=rowIndex ; i++)\\n        {\\n            if(i==0)\\n            {\\n                arr.push_back(1);\\n            }\\n            else if(i==1)\\n            {\\n                arr.push_back(1);\\n                arr.push_back(1);\\n            }\\n            else\\n            {\\n                arr.push_back(1);\\n                for(j=1 ; j<i ; j++)\\n                {\\n                    arr.push_back(ans[i-1][j-1]+ans[i-1][j]);\\n                }\\n                arr.push_back(1);\\n            }\\n            ans.push_back(arr);\\n            arr.clear();\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a7be070f-bc82-4f27-af71-370e04889b67_1684296650.9412372.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int i, j;\\n        vector<vector<int>> ans;\\n        vector<int> arr;\\n        for(i=0 ; i<=rowIndex ; i++)\\n        {\\n            if(i==0)\\n            {\\n                arr.push_back(1);\\n            }\\n            else if(i==1)\\n            {\\n                arr.push_back(1);\\n                arr.push_back(1);\\n            }\\n            else\\n            {\\n                arr.push_back(1);\\n                for(j=1 ; j<i ; j++)\\n                {\\n                    arr.push_back(ans[i-1][j-1]+ans[i-1][j]);\\n                }\\n                arr.push_back(1);\\n            }\\n            ans.push_back(arr);\\n            arr.clear();\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518583,
                "title": "java-solution-for-pascal-s-triangle-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code leverages the pattern observed in Pascal\\'s Triangle, where each element in a row can be obtained by adding the two elements directly above it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an ArrayList named result to store the elements of the row.\\n2. Handle the edge case where rowIndex is less than 0 by returning an empty list.\\n3. Add the first element, which is always 1, to the result list.\\n4. Iterate from row 1 to rowIndex (inclusive):\\n- Within each row, iterate backwards starting from the second-to-last element to the first element.\\n- Update each element by setting it to the sum of the current element and the next element in the result list.\\n- This operation effectively calculates the value at each position in the current row using the values from the previous row.\\n5. After the inner loop completes, add the last element (which is always 1) to the result list.\\n6. Return the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(rowIndex^2). This is because for each row from 1 to rowIndex, the inner loop iterates from the second-to-last element to the first element, which takes roughly rowIndex/2 iterations on average. Therefore, the overall time complexity is proportional to the sum of 1 + 2 + 3 + ... + rowIndex, which is equivalent to rowIndex * (rowIndex + 1) / 2, resulting in O(rowIndex^2) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(rowIndex) since the size of the result list is equal to rowIndex + 1, which stores the elements of the generated row. The additional space required is negligible compared to the size of the result list, making the space complexity O(rowIndex).  \\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if (rowIndex < 0)\\n            return result;\\n        result.add(1);\\n        for (int i = 1; i <= rowIndex; i++) \\n        {\\n            for (int j = result.size() - 2; j >= 0; j--) \\n            {\\n                result.set(j + 1, result.get(j) + result.get(j + 1));\\n            }\\n            result.add(1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if (rowIndex < 0)\\n            return result;\\n        result.add(1);\\n        for (int i = 1; i <= rowIndex; i++) \\n        {\\n            for (int j = result.size() - 2; j >= 0; j--) \\n            {\\n                result.set(j + 1, result.get(j) + result.get(j + 1));\\n            }\\n            result.add(1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303968,
                "title": "normal-math-approach-two-approches-python3",
                "content": "\\n# Brute Force\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1=[]\\n        for i in range(rowIndex+1):\\n            level=[]\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    level.append(1)\\n                else:\\n                    level.append(list1[i-1][j-1]+list1[i-1][j])\\n            list1.append(level)\\n        return list1[-1]\\n```\\n# Smart Approches\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        def value(numRows,col):\\n            ans=1\\n            for i in range(col):\\n                ans=ans*(numRows-i)\\n                ans=ans//(i+1)\\n            return ans\\n        res=[]\\n        for k in range(1,rowIndex+):\\n            res.append(value(rowIndex,k-1))\\n        return res\\n            \\n  ```\\n # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        list1=[]\\n        for i in range(rowIndex+1):\\n            level=[]\\n            for j in range(i+1):\\n                if j==0 or j==i:\\n                    level.append(1)\\n                else:\\n                    level.append(list1[i-1][j-1]+list1[i-1][j])\\n            list1.append(level)\\n        return list1[-1]\\n```\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        def value(numRows,col):\\n            ans=1\\n            for i in range(col):\\n                ans=ans*(numRows-i)\\n                ans=ans//(i+1)\\n            return ans\\n        res=[]\\n        for k in range(1,rowIndex+):\\n            res.append(value(rowIndex,k-1))\\n        return res\\n            \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3266408,
                "title": "iterative-o-n-solution-using-binomial-coefficients",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought that comes to mind is to straight up use the algorithm for constructing such triangle, from the problem\\'s description. But then, it is easy to realise, that there must be some kind of solution, which doesn\\'t require calculating all values in each row from top to bottom (which is O(n^2)).\\n\\nAfter a short while, I remembered, that the values in Pascal\\'s triangle are connected with a thing called Binomial coefficient.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSince each value in such triangle can be calculated using the formula for binomial coefficient (n over k) = n! / (k! * (n-k)!), where n is the row of the Pascal\\'s triangle and k is the \"column\". \\n\\nExpanding the above formula and considering the fact, that the triangle is vertically symmetrical, each row can be expressed as:\\n\\n$$n! / (0! * (n-0)!)$$  |  $$n! / (1! * (n-1)!)$$  |  $$n! / (2! * (n-2)!)$$  ...  $$n! / ((1 + n//2)! * (n-(1 + n//2)!)$$   ...   $$n! / (2! * (n-2)!)$$  |  $$n! / (1! * (n-1)!)$$  |  $$n! / (0! * (n-0)!)$$\\n\\nand after manipulating the factorials:\\n\\n$$1 / 0!$$  |  $$n! / 1!$$  |  $$(n * (n-1)) / 2!$$   ...  $$(n * (n-1) * ... * (n//2)) / (1+n//2)!$$  ...   $$(n * (n-1)) / 2!  |  n! / 1!$$  |  $$1 / 0!$$\\n\\nIt can be noticed, that after calculating the first element of a given row, the i-th element can be calculated by multiplying the previous one by (n - i + 1) and dividing it by i (assuming the elements are indexed from 0).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we only iterate over the row, we\\'re interested in, the time complexity is: $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only space we use, dependent on $$rowIndex$$ is the array, we\\'re supposed to return, the space complexity is: $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        ar = [1 for i in range(rowIndex + 1)]\\n        \\n        for i in range(1, rowIndex//2+1):\\n            ar[i] = ar[i-1] * (rowIndex - i + 1)//i\\n            ar[rowIndex - i] = ar[i]\\n      \\n        return ar\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        ar = [1 for i in range(rowIndex + 1)]\\n        \\n        for i in range(1, rowIndex//2+1):\\n            ar[i] = ar[i-1] * (rowIndex - i + 1)//i\\n            ar[rowIndex - i] = ar[i]\\n      \\n        return ar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244594,
                "title": "o-n-solution-c-simple-approach",
                "content": "# Intuition Pascal\\'s Triangle II\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nutilizing the concept of nCr $${N}\\\\choose{k}\\n$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe know from binomial theorem that $${N}\\\\choose{R}\\n$$ = $${N}\\\\choose{N-R}$$  \\n1st element is 1 \\n2nd element is N\\n3rd element is N*(N-1)/2  ie a[1]*(N-1)/2\\n4th element is  N*(N-1)(N-3)/(2*3) ie a[3]*(n-2)/3 \\n\\nthis way we can build till (N+1)/2 th element then we can copy the value of rth to N-r index\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1};\\n        if(rowIndex==1) return {1,1};\\n        vector<int> result(rowIndex+1, 1);\\n        int m=rowIndex/2;  //getting the mid element index as it\\'s zero based index. Had it been N given then (N+1)/2\\n        result[1]=rowIndex;\\n        for(int i=2; i<=m; i++ ){\\n            result[i] =( ((long)result[i-1]) * (rowIndex-i+1) )/i; //(used (long) to avoid Integer OverFlow)\\n        }\\n        int r=rowIndex;\\n        int l=0;\\n        while(r>l) result[r--]=result[l++]; // rth value to (N-r)\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        if(rowIndex==0) return {1};\\n        if(rowIndex==1) return {1,1};\\n        vector<int> result(rowIndex+1, 1);\\n        int m=rowIndex/2;  //getting the mid element index as it\\'s zero based index. Had it been N given then (N+1)/2\\n        result[1]=rowIndex;\\n        for(int i=2; i<=m; i++ ){\\n            result[i] =( ((long)result[i-1]) * (rowIndex-i+1) )/i; //(used (long) to avoid Integer OverFlow)\\n        }\\n        int r=rowIndex;\\n        int l=0;\\n        while(r>l) result[r--]=result[l++]; // rth value to (N-r)\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988509,
                "title": "4-lines-java-code-with-readable-comments",
                "content": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        // first we initialize arrayList\\n        List<Integer> list = new ArrayList<>();\\n        // iterate over list with respect to the rowIndex\\n        for (int i = 0; i <= rowIndex; i++) {\\n            // normaly add 1 at the starting\\n            list.add(0,1);\\n            // now this loop will remains last one\\'s(1)\\n            for(int j = 1; j < i; j ++) {\\n                // everytime set list to the new value\\n                list.set(j, list.get(j) + list.get(j + 1));\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> getRow(int rowIndex) {\\n        // first we initialize arrayList\\n        List<Integer> list = new ArrayList<>();\\n        // iterate over list with respect to the rowIndex\\n        for (int i = 0; i <= rowIndex; i++) {\\n            // normaly add 1 at the starting\\n            list.add(0,1);\\n            // now this loop will remains last one\\'s(1)\\n            for(int j = 1; j < i; j ++) {\\n                // everytime set list to the new value\\n                list.set(j, list.get(j) + list.get(j + 1));\\n            }\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2986458,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> ans;\\n        for(int i=0; i<=rowIndex; i++) {\\n            vector<int> tmp;\\n            for(int j=0; j<=i; j++) tmp.push_back(1);\\n            ans.push_back(tmp);\\n        }\\n        for(int i=2; i<=rowIndex; i++) {\\n            for(int j=1; j<i; j++) {\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>> ans;\\n        for(int i=0; i<=rowIndex; i++) {\\n            vector<int> tmp;\\n            for(int j=0; j<=i; j++) tmp.push_back(1);\\n            ans.push_back(tmp);\\n        }\\n        for(int i=2; i<=rowIndex; i++) {\\n            for(int j=1; j<i; j++) {\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans[rowIndex];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938432,
                "title": "easy-solution-with-the-written-dry-run-photo",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int>A(rowIndex+1,0);\\n        A[0]=1;\\n        for(int i=1;i<=rowIndex;++i){\\n            for(int j=i;j>=1;--j){\\n                A[j]+=A[j-1];\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```\\n![WhatsApp Image 2022-12-22 at 3.02.14 PM.jpeg](https://assets.leetcode.com/users/images/5da9ef8b-22a4-42cf-8c3d-0812940d28a8_1671701567.4670691.jpeg)\\n![WhatsApp Image 2022-12-22 at 3.02.25 PM.jpeg](https://assets.leetcode.com/users/images/5e1ee3e1-6291-4e37-87eb-32136a1cc36f_1671701582.1436455.jpeg)\\n\\n***like it then UpVote***\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<int>A(rowIndex+1,0);\\n        A[0]=1;\\n        for(int i=1;i<=rowIndex;++i){\\n            for(int j=i;j>=1;--j){\\n                A[j]+=A[j-1];\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717014,
                "title": "easy-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<int> getRow(int rowIndex)\\n  {\\n  vector<vector<int>> result(rowIndex+1);\\n  int i;\\n  for(i=0;i<=rowIndex;i++)\\n  {\\n      result[i].resize(i+1);\\n      result[i][0]=result[i][i]=1;\\n      for(int j=1;j<i;j++)\\n      {\\n          result[i][j]=result[i-1][j-1]+result[i-1][j];\\n      }\\n  }\\n      return result[i-1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> getRow(int rowIndex)\\n  {\\n  vector<vector<int>> result(rowIndex+1);\\n  int i;\\n  for(i=0;i<=rowIndex;i++)\\n  {\\n      result[i].resize(i+1);\\n      result[i][0]=result[i][i]=1;\\n      for(int j=1;j<i;j++)\\n      {\\n          result[i][j]=result[i-1][j-1]+result[i-1][j];\\n      }\\n  }\\n      return result[i-1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601569,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row, prev_row = null;\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i <= rowIndex; i++){\\n            row = new ArrayList<>();\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i){\\n                    row.add(1);\\n                }else{\\n                    row.add(prev_row.get(j-1) + prev_row.get(j));\\n                }\\n            }\\n            prev_row = row;\\n            res = row;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> row, prev_row = null;\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i <= rowIndex; i++){\\n            row = new ArrayList<>();\\n            for(int j = 0; j <= i; j++){\\n                if(j == 0 || j == i){\\n                    row.add(1);\\n                }else{\\n                    row.add(prev_row.get(j-1) + prev_row.get(j));\\n                }\\n            }\\n            prev_row = row;\\n            res = row;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586299,
                "title": "python3-solution-faster-than-94-4-using-binomial-theorem",
                "content": "Pascals triangle can also demonstrated through the used of combinations:\\n\\n\\t\\t\\t\\t\\t\\t1                                           0C0\\n\\t\\t\\t\\t\\t1      1                                   1C0      1C0\\n\\t\\t\\t\\t1       2     1                            2C0      2C1     2C2\\n\\t\\t\\t1      3       3     1                     3C0     3C1      3C2     3C3\\n\\t\\t\\t\\n\\nWhere nCr is equivilent to: n! / r! x (n - r)!\\n\\nnCr is a method of finding the number of combinations where repetition doesn\\'t matter for example you might use it to find the number of ways a committies could be chosen with a certain number of male and female members\\n\\nSolution:\\n\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\tarr = []\\n\\n\\t\\t# Factorial function (e.g. 4! would be 4 x 3 x 2 x 1 and 6! would be 6 x 5 x 4 x 3 x 2 x 1 and 0! would be 1)\\n\\t\\tdef factorial(num):\\n\\t\\t\\tans = 1\\n\\t\\t\\tfor x in range(1, num+1):\\n\\t\\t\\t\\tans *= x\\n\\t\\t\\treturn ans\\n\\n\\t\\t# This is just the nCr formula from above\\n\\n\\t\\tdef nCr(n, r):\\n\\t\\t\\treturn int(factorial(n) / ((factorial(r)) * factorial(n - r)))\\n\\n\\n\\t\\tfor y in range(0, rowIndex + 1):\\n\\t\\t\\tarr.append(int(factorial(rowIndex) / ((factorial(y)) * factorial(rowIndex - y)))) # rowIndex represents n in the nCr formula and y represents r\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n\\t\\tarr = []\\n\\n\\t\\t# Factorial function (e.g. 4! would be 4 x 3 x 2 x 1 and 6! would be 6 x 5 x 4 x 3 x 2 x 1 and 0! would be 1)\\n\\t\\tdef factorial(num):\\n\\t\\t\\tans = 1\\n\\t\\t\\tfor x in range(1, num+1):\\n\\t\\t\\t\\tans *= x\\n\\t\\t\\treturn ans\\n\\n\\t\\t# This is just the nCr formula from above\\n\\n\\t\\tdef nCr(n, r):\\n\\t\\t\\treturn int(factorial(n) / ((factorial(r)) * factorial(n - r)))\\n\\n\\n\\t\\tfor y in range(0, rowIndex + 1):\\n\\t\\t\\tarr.append(int(factorial(rowIndex) / ((factorial(y)) * factorial(rowIndex - y)))) # rowIndex represents n in the nCr formula and y represents r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862508,
                "title": "java-solution-simple",
                "content": "```\\nList<Integer> list = new ArrayList<Integer>();\\n        for(int i = 0;i<n+1;i++) {\\n                list.add(1);\\n                for(int j=i-1;j>0;j--) {\\n                    list.set(j, list.get(j-1)+list.get(j));\\n                }\\n        }\\n        return list;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<Integer> list = new ArrayList<Integer>();\\n        for(int i = 0;i<n+1;i++) {\\n                list.add(1);\\n                for(int j=i-1;j>0;j--) {\\n                    list.set(j, list.get(j-1)+list.get(j));\\n                }\\n        }\\n        return list;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840543,
                "title": "rust-dp-without-extra-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        // 1 0 0 0\\n        // 1 1 0 0\\n        // 1 2 1 0\\n        // 1 3 3 1\\n        // f(x, y) = f(x - 1, y - 1) + f(x, y - 1)\\n\\n        let row_index = row_index as usize;\\n        let mut arr = vec![0; row_index + 1];\\n        arr[0] = 1;\\n\\n        for i in 1..arr.len() {\\n            for j in (1..=i).rev() {\\n                arr[j] = arr[j] + arr[j - 1]\\n            }\\n        }\\n\\n        arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_row(row_index: i32) -> Vec<i32> {\\n        // 1 0 0 0\\n        // 1 1 0 0\\n        // 1 2 1 0\\n        // 1 3 3 1\\n        // f(x, y) = f(x - 1, y - 1) + f(x, y - 1)\\n\\n        let row_index = row_index as usize;\\n        let mut arr = vec![0; row_index + 1];\\n        arr[0] = 1;\\n\\n        for i in 1..arr.len() {\\n            for j in (1..=i).rev() {\\n                arr[j] = arr[j] + arr[j - 1]\\n            }\\n        }\\n\\n        arr\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788852,
                "title": "c-100-faster",
                "content": "```\\n vector<int> getRow(int row) {\\n        vector<vector<int>> v;\\n        \\n        for(int i=0;i<=row;++i)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<=i;++j)\\n            {\\n                if(j==0 || j==i)\\n                {\\n                    temp.push_back(1);\\n                }\\n                else\\n                    temp.push_back(v[i-1][j-1]+v[i-1][j]);\\n            }\\n            v.push_back(temp);\\n        }\\n        return v[row];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> getRow(int row) {\\n        vector<vector<int>> v;\\n        \\n        for(int i=0;i<=row;++i)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<=i;++j)\\n            {\\n                if(j==0 || j==i)\\n                {\\n                    temp.push_back(1);\\n                }\\n                else\\n                    temp.push_back(v[i-1][j-1]+v[i-1][j]);\\n            }\\n            v.push_back(temp);\\n        }\\n        return v[row];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764731,
                "title": "c-100-fast-o-n-solution-no-extra-space-with-simple-math-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/498f5e25-e3d6-46da-b657-71f503f048d1_1644647839.7259436.png)\\nlets take row index as 6. as first element is always 1, intilize a varibale called x=1 and two more variables n=6, and c=1( you can assume c as column number ) now next element will be (xn/c)  and then decrease n and increase c  and keep this till half way as after that same elements will repeat themselves just in reverse order.\\n\\n**Edit**- I did not explain exactly how i come up to this solution. So here is the explanation-\\npascle triangle actually represent coefficients of  biionomial expention\\nso lets take a example to understand how\\nhere when i talk about power it means sum of power of **a** and **b**\\n\\nlets take x(row index) =0, which is equal to (a+b)^0 which is equal to 1 and as total power will be zero , so only 1 way to represent it.\\n\\nlets take x =1, which is equal to ((a+b)^0) *(a+b) and as we know it will be [1,1]  as now we want to represent power 1 and it can either be done as \\'a\\' or \\'b\\'.\\n\\nlets  take x=2, which is (a+b)(a+b), now as we want to represent power 2, we can do it by  a^2, ab,b^2. we have already got [1,1] for (a+b) and now we want a^2 so it can only possible if we take \\'a\\' from (a+b) and it can be done in only one way. For \\'ab\\' we  can take \\'a\\'from (a+b) and then b from next (a+b) or \\'b\\' from (a+b) and then \\'a\\' from next (a+b). We can get b^2 same way as a^2.  So answer is [1,2,1]\\n\\nlets take x=3, which is (a+b)^2(a+b). as we already got [1,2,1] from (a+b)^2. Now we want to represent power 3 and it can be done as a^3,a^2b,ab^2,b^3. Now to represent a^3, we need a^2 from (a+b)^2 and it can be done in only one way, for a^2b we can done it by using following combinations (ab,a), (a^2,b). as \\'ab\\' can be represented by 2 ways in (a+b)^2. So, total 3 ways for a^b. After, that we can take similar action to get other values.\\n\\nHonestly when I solve this question I did not solve it by using this explanation. I have solved some \\'find next number in series\\' aptitude  questions in past  and I applied same logic in it and came with this formula. Then i thought of some logical reason and find its just binomial coefficients.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,0);\\n        long long x=1,n=r;\\n        for(int i=0;i<=r/2;i++,n--){\\n             v[i]=x;\\n             v[r-i]=x;\\n             x=x*n/(i+1);\\n         }\\n        return v;\\n       \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,0);\\n        long long x=1,n=r;\\n        for(int i=0;i<=r/2;i++,n--){\\n             v[i]=x;\\n             v[r-i]=x;\\n             x=x*n/(i+1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1741684,
                "title": "python3-faster-solution-easiest-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = []\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        res = []\\n        for i in range(rowIndex+1):\\n            res.append([])\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701770,
                "title": "easy-java-solution-0-ms-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n  private int getNum(int row, int col, int[][]memo) {\\n    if (row == 0 || col == 0 || row == col) {\\n      return 1;\\n    }\\n    if (memo[row][col] != 0) {\\n        return memo[row][col];\\n    }\\n    int sum = getNum(row - 1, col - 1, memo) + getNum(row - 1, col, memo);\\n    memo[row][col] = sum;\\n    return sum;\\n  }\\n\\n  public List<Integer> getRow(int rowIndex) {\\n    List<Integer> ans = new ArrayList<>();\\n    int[][] memo = new int[rowIndex + 1][rowIndex + 1];\\n\\n    for (int i = 0; i <= rowIndex; i++) {\\n      ans.add(getNum(rowIndex, i, memo));\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  private int getNum(int row, int col, int[][]memo) {\\n    if (row == 0 || col == 0 || row == col) {\\n      return 1;\\n    }\\n    if (memo[row][col] != 0) {\\n        return memo[row][col];\\n    }\\n    int sum = getNum(row - 1, col - 1, memo) + getNum(row - 1, col, memo);\\n    memo[row][col] = sum;\\n    return sum;\\n  }\\n\\n  public List<Integer> getRow(int rowIndex) {\\n    List<Integer> ans = new ArrayList<>();\\n    int[][] memo = new int[rowIndex + 1][rowIndex + 1];\\n\\n    for (int i = 0; i <= rowIndex; i++) {\\n      ans.add(getNum(rowIndex, i, memo));\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537135,
                "title": "java-simplest-solution-must-watch-0ms",
                "content": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        if(rowIndex == 0){\\n            res.add(1);\\n            return res;\\n        }\\n        \\n        \\n        long val = 1;          \\n        for(int i=0; i<=rowIndex; ++i){\\n            \\n            res.add( (int) val);            // To avoid OverFLow\\n            \\n            val = val * (rowIndex - i) / (i + 1);      //Using Binomial Theorem\\n            \\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        \\n        List <Integer> res = new ArrayList <> ();\\n        \\n        if(rowIndex == 0){\\n            res.add(1);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1527391,
                "title": "4-line-in-python",
                "content": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        r = [1]\\n        for _ in range(rowIndex):\\n            r = [1, *(map(sum, zip(r, r[1:]))), 1]\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        r = [1]\\n        for _ in range(rowIndex):\\n            r = [1, *(map(sum, zip(r, r[1:]))), 1]\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525804,
                "title": "c-100-fast-90-space-efficient-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n        //initialise ans vector for if rowIndex is 0 or 1\\n        vector<int>ans(n+1,1);\\n        if(n==0||n==1)\\n        return ans;\\n        \\n        //make prev <1,1> \\n        vector<int>prev(2,1);\\n        \\n        n=rowIndex-1;\\n        \\n        //increase size of ans by 1. start updating ans from previous. Once loop is completed,store ans in           prev \\n        \\n        while(n--){\\n            ans.resize(prev.size()+1,1);\\n            for(int i=1;i<ans.size()-1;i++){\\n                ans[i]=prev[i-1]+prev[i];\\n            }    \\n                prev = ans;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n        //initialise ans vector for if rowIndex is 0 or 1\\n        vector<int>ans(n+1,1);\\n        if(n==0||n==1)\\n        return ans;\\n        \\n        //make prev <1,1> \\n        vector<int>prev(2,1);\\n        \\n        n=rowIndex-1;\\n        \\n        //increase size of ans by 1. start updating ans from previous. Once loop is completed,store ans in           prev \\n        \\n        while(n--){\\n            ans.resize(prev.size()+1,1);\\n            for(int i=1;i<ans.size()-1;i++){\\n                ans[i]=prev[i-1]+prev[i];\\n            }    \\n                prev = ans;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517650,
                "title": "c-easy-to-understand-solution-short-simple-dp-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,1);\\n        for(int i=1;i<=r-1;i++){\\n            int prev=1,c;\\n            for(int j=1;j<=i;j++){\\n                c=v[j];\\n                v[j]+=prev;\\n                prev=c;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n***Time Complexity : O(r^2) \\nSpace Complexity : O(1)** - (not including the vector to be returned)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int r) {\\n        vector<int>v(r+1,1);\\n        for(int i=1;i<=r-1;i++){\\n            int prev=1,c;\\n            for(int j=1;j<=i;j++){\\n                c=v[j];\\n                v[j]+=prev;\\n                prev=c;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434922,
                "title": "java-0ms-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<>();\\n        long val = 1;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            res.add((int)val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> getRow(int rowIndex) {\\n        List<Integer> res = new ArrayList<>();\\n        long val = 1;\\n        for(int i=0;i<=rowIndex;i++)\\n        {\\n            res.add((int)val);\\n            val = val*(rowIndex-i)/(i+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365320,
                "title": "js-recursive-solution",
                "content": "```\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) return [1]\\n    if (rowIndex === 1) return [1, 1]\\n    \\n    const row = getRow(rowIndex - 1)\\n    let prev = 1\\n    let tmp = prev\\n\\n    row.push(1)\\n\\n    for (let i = 1; i < rowIndex; i++) {\\n        tmp = row[i]\\n        row[i] = prev + row[i]\\n        prev = tmp\\n    }\\n    \\n    return row\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getRow = function(rowIndex) {\\n    if (rowIndex === 0) return [1]\\n    if (rowIndex === 1) return [1, 1]\\n    \\n    const row = getRow(rowIndex - 1)\\n    let prev = 1\\n    let tmp = prev\\n\\n    row.push(1)\\n\\n    for (let i = 1; i < rowIndex; i++) {\\n        tmp = row[i]\\n        row[i] = prev + row[i]\\n        prev = tmp\\n    }\\n    \\n    return row\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158468,
                "title": "two-golang-solutions-100-100-with-explanation",
                "content": "[119. Pascal\\'s Triangle II](https://leetcode.com/problems/pascals-triangle-ii/)\\n\\nI will explain the first solution.\\n\\nIf you want to understand the second solution, click on the link above the code.\\n\\nSo the first solution only wants us to return the last row of the triangle.\\n\\nSince we always need two rows for this problem, the current row, and the previous row, in this problem, `res` is the current row and `temp` is the previous row.\\n\\nHere is how the problem works\\n\\n* We have `res[0]` equal to `1`, so all we have to do is keep on appending `1` to `res` every time we iterate.\\n* Then we have to loop through `res`\\'s indexes starting at `1` and ending at `len(res) - 1` because we don\\'t want to count the start and end `1`\\'s.\\n* Inside the nested for we can make `res[j] = temp[j-1] + temp[j]`. If you don\\'t understand why this works, look at the image below: ![](https://i.imgur.com/vPafRCe.png)\\n* After iterating through everything we can return `res`.\\n\\n\\n**The Code:** *This is the one that is 100%, 100%*\\n\\n``` go\\nfunc getRow(rowIndex int) []int {\\n    res := []int{}\\n\\n    for i := 0; i <= rowIndex; i++ {\\n        temp := make([]int, len(res))\\n        copy(temp, res)\\n        res = append(res, 1)\\n        for j := 1; j < len(res)-1; j++ {\\n            res[j] = temp[j-1] + temp[j]\\n        }\\n    }\\n    return res\\n}\\n```\\n\\n**We could do something similar to what we did in [Leetcode 118](https://nathannaveen.dev/posts/leetcode-118/) But it is a pretty brute force solution for this problem:** \\n\\n``` go\\nfunc getRow(rowIndex int) []int {\\n    res := [][]int{}\\n\\n    for i := 0; i < rowIndex; i++ {\\n        temp := make([]int, i+1)\\n        temp[0], temp[len(temp)-1] = 1, 1\\n        for j := 1; j < len(temp)-1; j++ {\\n            temp[j] = res[i-1][j-1] + res[i-1][j]\\n        }\\n        res = append(res, temp)\\n    }\\n\\n    return res[len(res) - 1]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc getRow(rowIndex int) []int {\\n    res := []int{}\\n\\n    for i := 0; i <= rowIndex; i++ {\\n        temp := make([]int, len(res))\\n        copy(temp, res)\\n        res = append(res, 1)\\n        for j := 1; j < len(res)-1; j++ {\\n            res[j] = temp[j-1] + temp[j]\\n        }\\n    }\\n    return res\\n}\\n```\n``` go\\nfunc getRow(rowIndex int) []int {\\n    res := [][]int{}\\n\\n    for i := 0; i < rowIndex; i++ {\\n        temp := make([]int, i+1)\\n        temp[0], temp[len(temp)-1] = 1, 1\\n        for j := 1; j < len(temp)-1; j++ {\\n            temp[j] = res[i-1][j-1] + res[i-1][j]\\n        }\\n        res = append(res, temp)\\n    }\\n\\n    return res[len(res) - 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906279,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        if(rowIndex == 0)\\n            return {1};\\n        \\n        if(rowIndex == 1)\\n            return {1, 1};\\n        \\n        vector<int> row, prev = getRow(rowIndex - 1);\\n        \\n        row.push_back(1);\\n        for(int n = 1; n < prev.size(); n++)\\n        {\\n            row.push_back(prev[n] + prev[n-1]);\\n        }\\n        row.push_back(1);\\n                                       \\n        return row;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        \\n        if(rowIndex == 0)\\n            return {1};\\n        \\n        if(rowIndex == 1)\\n            return {1, 1};\\n        \\n        vector<int> row, prev = getRow(rowIndex - 1);\\n        \\n        row.push_back(1);\\n        for(int n = 1; n < prev.size(); n++)\\n        {\\n            row.push_back(prev[n] + prev[n-1]);\\n        }\\n        row.push_back(1);\\n                                       \\n        return row;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897377,
                "title": "c-solution",
                "content": "```\\nint* getRow(int rowIndex, int* returnSize){\\n\\tint *ret = NULL;\\n\\t*returnSize = rowIndex + 1;\\n\\tret = malloc(sizeof(int)* (rowIndex + 1));\\n\\n\\tret[0] = 1;\\n\\tif(rowIndex == 0) \\n\\t\\treturn ret;\\n\\n\\tret[1] = 1;\\n\\tif(rowIndex == 1)\\n\\t\\treturn ret;\\n\\n\\tfor(int row = 2; row <= rowIndex; row++) {\\n        int prev = ret[0];\\n\\t\\tfor(int col = 1; col <= row - 1; col++) {\\n            int temp = prev + ret[col];\\n            prev = ret[col];\\n\\t\\t\\tret[col] = temp;\\n\\t\\t}\\n\\t\\tret[row] = 1;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* getRow(int rowIndex, int* returnSize){\\n\\tint *ret = NULL;\\n\\t*returnSize = rowIndex + 1;\\n\\tret = malloc(sizeof(int)* (rowIndex + 1));\\n\\n\\tret[0] = 1;\\n\\tif(rowIndex == 0) \\n\\t\\treturn ret;\\n\\n\\tret[1] = 1;\\n\\tif(rowIndex == 1)\\n\\t\\treturn ret;\\n\\n\\tfor(int row = 2; row <= rowIndex; row++) {\\n        int prev = ret[0];\\n\\t\\tfor(int col = 1; col <= row - 1; col++) {\\n            int temp = prev + ret[col];\\n            prev = ret[col];\\n\\t\\t\\tret[col] = temp;\\n\\t\\t}\\n\\t\\tret[row] = 1;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789241,
                "title": "python-3-solution-faster-than-95-36",
                "content": "\\n```\\n\\tclass Solution:\\n\\t\\tdef getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t\\ttri=[[1], [1,1]]\\n\\t\\t\\tfor i in range(2, rowIndex+1):\\n\\t\\t\\t\\trow=[None]*(i+1)\\n\\t\\t\\t\\trow[0]=1\\n\\t\\t\\t\\trow[i]=1\\n\\t\\t\\t\\tfor j in range(1,i):\\n\\t\\t\\t\\t\\trow[j]=tri[i-1][j]+tri[i-1][j-1]\\n\\t\\t\\t\\ttri.append(row)\\n\\t\\t\\treturn tri[rowIndex]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tclass Solution:\\n\\t\\tdef getRow(self, rowIndex: int) -> List[int]:\\n\\t\\t\\ttri=[[1], [1,1]]\\n\\t\\t\\tfor i in range(2, rowIndex+1):\\n\\t\\t\\t\\trow=[None]*(i+1)\\n\\t\\t\\t\\trow[0]=1\\n\\t\\t\\t\\trow[i]=1\\n\\t\\t\\t\\tfor j in range(1,i):\\n\\t\\t\\t\\t\\trow[j]=tri[i-1][j]+tri[i-1][j-1]\\n\\t\\t\\t\\ttri.append(row)\\n\\t\\t\\treturn tri[rowIndex]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787379,
                "title": "java-simple-list-beats-100",
                "content": "\\t\\tList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        if(rowIndex == 0)return res;\\n        for(int i = 1; i <= rowIndex; i++){\\n            long num = ((long)res.get(i-1)*(long)(rowIndex-i+1))/i;\\n            res.add((int)num);\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "\\t\\tList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        if(rowIndex == 0)return res;\\n        for(int i = 1; i <= rowIndex; i++){\\n            long num = ((long)res.get(i-1)*(long)(rowIndex-i+1))/i;\\n            res.add((int)num);\\n        }\\n        return res;",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1574200,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1567863,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1762280,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 2071808,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1930720,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1918945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1867901,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1803740,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1799687,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1574945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1574200,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1567863,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1762280,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 2071808,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1930720,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1918945,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1867901,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1803740,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            },
            {
                "id": 1799687,
                "content": [
                    {
                        "username": "dheberer",
                        "content": "If you want to do this time and space complexity order k where k is the row number you are generating you have to construct the formula to derive a given element of the row based on it\\'s position and the row number you are on that doesn\\'t seem to me to be quite intuitive. If someone hasn\\'t seen this before, or if I don\\'t remember what the formula is this will be a struggle. I do not recommend it as an interview question."
                    },
                    {
                        "username": "CodingBeastOfficial",
                        "content": "https://youtu.be/orLD0-vEOc0\\n\\nI have tried to explain the problem in detail in my native language i.e. Hindi.\\nPlease let me know if you like the explanation."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def get_row(k)\\n      [p=1]+(1..k).map{|i|p=p*(k-i+1)/i}\\n    end"
                    },
                    {
                        "username": "Pragnesh2208",
                        "content": "Please help me to solve below doubt \\n\\n\\nI have used int as type of val  , but got a error that number so large that can\\'t store in Int type  , then i changed it to long long int as shown in below code , im surprised how long long int val store in vector of Int\\n\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        int n = rowIndex;\\n       vector<int>ans;\\n       long long int val = 1;\\n       for(int i = 0 ; i <= n ; i++) {\\n           ans.push_back(val);\\n           val = val * (n - i) / (i + 1);\\n       }\\n      \\n       return ans; \\n    }\\n};\\n"
                    },
                    {
                        "username": "yukimora",
                        "content": "In C++, you can use the `<boost/multiprecision>` library to work with arbitrary-precision integers. This library provides the `cpp_int` class, which represents integers with arbitrary precision."
                    },
                    {
                        "username": "its_rush",
                        "content": "if you just use a formula like A[i] = ((long long) A[i -1] * (rowIndex -i+11))/i;\\n\\n"
                    },
                    {
                        "username": "branh",
                        "content": "Honestly not a bad interview question. Went in blind and came out with a working solution in ~15 minutes including drawing and understanding the question. Tests logic and mapping out mathematical solutions"
                    },
                    {
                        "username": "yukimora",
                        "content": "To find a specific element, you can use the formula `C = n! / (k! * (n-k)!)`. Where n = row number (starting from 0) and k = element number (also starting from 0). For those working with C#, use BigInteger from `System.Numerics`. `Long` is unable to handle numbers above 20.\n(It is possible for small sizes and it is better to use the full construction of a triangle, as many do and select only the desired line from there. But if these are large values, I think it will be faster to calculate the factorial)"
                    },
                    {
                        "username": "Devchoubey",
                        "content": " int[]num=new int[rowIndex+1];\\n        int value=1;\\n           int i=rowIndex;\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(j==0)\\n                {\\n                    value=1;\\n                }\\n                else\\n                {\\n                    value=(value*(i-j+1))/j;\\n                }\\n                num[j]=value;\\n            }\\n        return num;\\n\\n30/34 testcases"
                    },
                    {
                        "username": "jngk07",
                        "content": "What is wrong in this code. I am getting outOfBound error at return list2.get(rowIndex-1).\\n\\nI used same code to solve pascal\\'s Triangle I. \\n \\npublic List<Integer> getRow(int rowIndex) {\\n         \\n        int[][] dp = new int[rowIndex][rowIndex];\\n\\n        List<List<Integer>> list2 = new ArrayList<>();\\n                 \\n        for(int i=0; i<rowIndex; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int j=0; j<i+1; j++) {\\n\\n                if(j==0 || (j==i)){\\n                    dp[i][j] = 1;\\n                } else {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n                }\\n                list.add(dp[i][j]);\\n            }\\n            list2.add(list);\\n        }\\n\\n        return list2.get(rowIndex-1);\\n    }"
                    },
                    {
                        "username": "supermoonpie",
                        "content": "outer loop begins with i=0 and inner loop u are using i-1 which is causing the out of bounds error "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "I\\'m having some trouble parsing through your code. This problem is supposed to be about dynamic programming. I think you have made  your code more complex to account for edge cases you ran into when trying to submit, but if you used dynamic programming you would be able to make your code neater. The equation to figure out the pascal\\'s triangle value at a given index is number * (i-j)/(j+1), where number is initialized to 1 within the first for loop. It would eliminate the need to create a multidimensional array, and could reduce your space complexity, as well as make your answer less easy to break.\\n\\nTo answer your question, I think the issue is that the previous problem was base-1, and this one is base-0, causing your previous grabbing of array values to need tweaking. Maybe in your return value. Trying it with dynamic programming could be a good problem for you to practice."
                    },
                    {
                        "username": "itundefined",
                        "content": "So, you have to go through all of the index No and you also have to keep track of all the previous row in order to solve this one. This is the only to solve this solution in O(n^2) Time Complexity. \\n\\ndoes that mean you can\\'t make it better? well you can I have been trying to figure out the solution with building a custom formula for that particular index no but till now I just know these things to build the formula - \\n\\n1.) Total Sum of the all numbers at a particular index is =  2^index_Number\\n\\n2.) and the last and the first element always would be it 1  = [1, 1] \\n\\n3.) and the half of the array of the current index that all you wanna find then you can just flip it to find the rest of it. - [1, |2|  here comes the reverse],  [1, 3 |  here comes the reverse]\\n\\n4.) the second and the last second element is the as same as the index no - \\n \\nindex no  = 2 ,  - [1, (2), 1], \\nindex no =3,  - [1, (3) | here comes the reverse]\\n\\n\\ni just wanna Know how to find the array[2] and till the middle then this problem is just o(1) Which is literally gonna be amazing. \\n\\nthanks if you care to help me then you can always email me  - tusharsharmaek@gmail.com or GitHub - https://github.com/itundefined \\n"
                    },
                    {
                        "username": "k014",
                        "content": "I saw other solutions and there is a formula, I found it depends on the rowIndex, and the position in the row and the previous element, something like, for each number starting from the second since the first is always 1:\\n\\nprevious*(rowIndex-i)//i"
                    }
                ]
            }
        ]
    }
]