[
    {
        "title": "Memoize",
        "question_content": "Given a function fn, return a&nbsp;memoized&nbsp;version of that function.\nA&nbsp;memoized&nbsp;function is a function that will never be called twice with&nbsp;the same inputs. Instead it will return&nbsp;a cached value.\nYou can assume there are&nbsp;3&nbsp;possible input functions:&nbsp;sum, fib,&nbsp;and&nbsp;factorial.\n\n\tsum&nbsp;accepts two integers&nbsp;a and b and returns a + b.\n\tfib&nbsp;accepts a&nbsp;single integer&nbsp;n and&nbsp;returns&nbsp;1 if n <= 1 or&nbsp;fib(n - 1) + fib(n - 2)&nbsp;otherwise.\n\tfactorial&nbsp;accepts a single integer&nbsp;n and returns 1&nbsp;if&nbsp;n <= 1&nbsp;or&nbsp;factorial(n - 1) * n&nbsp;otherwise.\n\n&nbsp;\nExample 1:\n\nInput:\nfnName = \"sum\"\nactions = [\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\nvalues = [[2,2],[2,2],[],[1,2],[]]\nOutput: [4,4,1,3,2]\nExplanation:\nconst sum = (a, b) => a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum(2, 2); // \"call\" - returns 4. sum() was called as (2, 2) was not seen before.\nmemoizedSum(2, 2); // \"call\" - returns 4. However sum() was not called because the same inputs were seen before.\n// \"getCallCount\" - total call count: 1\nmemoizedSum(1, 2); // \"call\" - returns 3. sum() was called as (1, 2) was not seen before.\n// \"getCallCount\" - total call count: 2\n\nExample 2:\n\nInput:\nfnName = \"factorial\"\nactions = [\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\nvalues = [[2],[3],[2],[],[3],[]]\nOutput: [2,6,2,2,6,2]\nExplanation:\nconst factorial = (n) => (n <= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // \"call\" - returns 2.\nmemoFactorial(3); // \"call\" - returns 6.\nmemoFactorial(2); // \"call\" - returns 2. However factorial was not called because 2 was seen before.\n// \"getCallCount\" - total call count: 2\nmemoFactorial(3); // \"call\" - returns 6. However factorial was not called because 3 was seen before.\n// \"getCallCount\" - total call count: 2\n\nExample 3:\n\nInput:\nfnName = \"fib\"\nactions = [\"call\",\"getCallCount\"]\nvalues = [[5],[]]\nOutput: [8,1]\nExplanation:\nfib(5) = 8 // \"call\"\n// \"getCallCount\" - total call count: 1\n\n&nbsp;\nConstraints:\n\n\t0 <= a, b <= 105\n\t1 <= n <= 10\n\t0 <= actions.length <= 105\n\tactions.length === values.length\n\tactions[i] is one of \"call\" and \"getCallCount\"\n\tfnName is one of \"sum\", \"factorial\" and&nbsp;\"fib\"",
        "solutions": [
            {
                "id": 3517845,
                "title": "learn-memoized-function-caching-js-typescript-day-9",
                "content": "# Intuition\\nThe question is asking to create a `memoized version` of a given `function (sum, fib, or factorial)` that will `cache` previously computed results and return them for subsequent calls with the same inputs, rather than recomputing them.\\n\\n# Approach\\n- Define a function called` memoize` that takes in a function fn as its parameter.\\n- Create an empty object called `cache` to store previously computed results.\\n- Return a new function that takes in any number of arguments using the `spread syntax`.\\n- Use `JSON.stringify()` to convert the arguments into a string to use as a key for the cache object\\n- Check if the key already exists in the cache object. If it does, return the cached value.\\n- If the key doesn\\'t exist in the cache, call the original function fn using `apply() `to pass the arguments and store the result in the cache object using the key as the property name.\\n- Finally, return the computed result.\\n\\n# Caching\\n\\n- Question involves the concept of caching.\\n- `Caching` is a technique used to improve the performance of a program by storing the results of expensive `operations` and returning the cached result\\n- In this question, the `memoized function` stores the results of the expensive operations `(sum, fib, and factorial)` and returns the cached result when the same input values are requested again. This can improve the performance of the program significantly as it reduces the number of expensive operations that need to be performed.\\n\\n# Memoized Function\\n\\n- Memoization is a technique used to optimize functions that are expensive to compute or have repeated computations with the same input.\\n- The cache is usually implemented as an object or a map that stores the previously computed results.\\n- When the memoized function is called with a new input, it first checks if the input exists in the cache. If it does, it returns the cached value. If it doesn\\'t, it computes the result, stores it in the cache, and returns it.\\n\\n\\n# Complexity\\n\\n- Time complexity: memoized function depends on the original function being memoized, and can range from O(1) to O(n) to O(2^n).\\n\\n- Space complexity:\\nO(n), where n is the number of unique inputs to the function.\\n\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    \\n   const cache = {};\\n  \\n   return function(...args) {\\n    const key = JSON.stringify(args);\\n    \\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    \\n    const result = fn.apply(this, args);\\n    cache[key] = result;\\n    \\n    return result;\\n  }\\n  \\n}\\n\\n\\nconst memoizedSum = memoize(function(a, b) {\\n  return a + b;\\n});\\n\\nconsole.log(memoizedSum(2, 3)); // Output: Computing sum, 5\\nconsole.log(memoizedSum(2, 3)); // Output: 5\\n\\n```\\n\\n# Code In TypeScript \\n```\\ntype Func<T, U> = (arg: T) => U;\\n\\ninterface Cache<T, U> {\\n  [key: string]: U;\\n}\\n\\nfunction memoize<T, U>(fn: Func<T, U>): Func<T, U> {\\n  const cache: Cache<T, U> = {};\\n\\n  return function (...args: T[]): U {\\n    const key = JSON.stringify(args);\\n\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n\\n    const result = fn.apply(this, args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n\\nconst memoizedSum = memoize(function (a: number, b: number): number {\\n  return a + b;\\n});\\n\\nconst memoizedFib = memoize(function (n: number): number {\\n  if (n <= 1) {\\n    return 1;\\n  }\\n\\n  return memoizedFib(n - 1) + memoizedFib(n - 2);\\n});\\n\\nconst memoizedFactorial = memoize(function (n: number): number {\\n  if (n <= 1) {\\n    return 1;\\n  }\\n\\n  return memoizedFactorial(n - 1) * n;\\n});\\n\\nconsole.log(memoizedSum(2, 3)); // Output: Computing sum, 5\\nconsole.log(memoizedSum(2, 3)); // Output: 5\\n\\nconsole.log(memoizedFib(5)); // Output: Computing fib, 8\\nconsole.log(memoizedFib(5)); // Output: 8\\n\\nconsole.log(memoizedFactorial(5));\\nconsole.log(memoizedFactorial(5)); \\n\\n```\\n![upvote-2.png](https://assets.leetcode.com/users/images/a253f572-aef7-4771-85d3-890a2548d3ab_1683940233.6214747.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    \\n   const cache = {};\\n  \\n   return function(...args) {\\n    const key = JSON.stringify(args);\\n    \\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    \\n    const result = fn.apply(this, args);\\n    cache[key] = result;\\n    \\n    return result;\\n  }\\n  \\n}\\n\\n\\nconst memoizedSum = memoize(function(a, b) {\\n  return a + b;\\n});\\n\\nconsole.log(memoizedSum(2, 3)); // Output: Computing sum, 5\\nconsole.log(memoizedSum(2, 3)); // Output: 5\\n\\n```\n```\\ntype Func<T, U> = (arg: T) => U;\\n\\ninterface Cache<T, U> {\\n  [key: string]: U;\\n}\\n\\nfunction memoize<T, U>(fn: Func<T, U>): Func<T, U> {\\n  const cache: Cache<T, U> = {};\\n\\n  return function (...args: T[]): U {\\n    const key = JSON.stringify(args);\\n\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n\\n    const result = fn.apply(this, args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n\\nconst memoizedSum = memoize(function (a: number, b: number): number {\\n  return a + b;\\n});\\n\\nconst memoizedFib = memoize(function (n: number): number {\\n  if (n <= 1) {\\n    return 1;\\n  }\\n\\n  return memoizedFib(n - 1) + memoizedFib(n - 2);\\n});\\n\\nconst memoizedFactorial = memoize(function (n: number): number {\\n  if (n <= 1) {\\n    return 1;\\n  }\\n\\n  return memoizedFactorial(n - 1) * n;\\n});\\n\\nconsole.log(memoizedSum(2, 3)); // Output: Computing sum, 5\\nconsole.log(memoizedSum(2, 3)); // Output: 5\\n\\nconsole.log(memoizedFib(5)); // Output: Computing fib, 8\\nconsole.log(memoizedFib(5)); // Output: 8\\n\\nconsole.log(memoizedFactorial(5));\\nconsole.log(memoizedFactorial(5)); \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518516,
                "title": "easy-solution-2623-function-composition-level-up-your-javascript-skills-day-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>Memoization is a technique used to speed up the execution of a function by caching its results for a given set of input parameters. When a function is called with the same set of input parameters, instead of re-executing the function, the cached result is returned. This technique can be used to optimize recursive functions and functions with expensive computations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>To memoize a function, we can create a cache object that stores the results of previous function calls. Whenever the function is called, we check if the cache already has a result for the given input parameters. If it does, we return the cached result. Otherwise, we compute the result and store it in the cache for future use.\\n\\n>To implement memoization in JavaScript/TypeScript, we can create a higher-order function that takes in the original function and returns a memoized version of it. The memoized function can use a closure to store the cache object.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The time complexity of the memoized function is O(1) for each call if the cache hit rate is high. In the worst case, where all input parameters are unique, the memoized function will perform the same number of function calls as the original function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity of the memoized function depends on the number of unique input parameters and the size of the cache object. If the number of unique input parameters is small and the cache object is not too large, then the space complexity will be reasonable. However, if the number of unique input parameters is very large and/or the cache object is very large, then the space complexity can become a concern.\\n\\n# Code\\n```JavaScript []\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n      const key = String(args);\\n      if (key in cache) {\\n        return cache[key];\\n      }\\n      const result = fn(...args);\\n      cache[key] = result;\\n      return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\n``` TypeScript []\\ntype Args = any[];\\ntype MemoizedFn<T> = (...args: Args) => T;\\n\\nfunction memoize<T>(fn: MemoizedFn<T>): MemoizedFn<T> {\\n  const cache: Record<string, T> = {};\\n  return function (...args: Args) {\\n    const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const result = fn(...args);\\n    cache[key] = result;\\n    return result;\\n  }\\n}\\n```\\n\\n```\\n\\n// Fibonacci function\\nconst fib = (n) => (n <= 1 ? 1 : fib(n - 1) + fib(n - 2));\\n\\n// Factorial function\\nconst factorial = (n) => (n <= 1 ? 1 : factorial(n - 1) * n);\\n\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n> There are other ways to implement memoization in JavaScript. Here are a few:\\n\\n\\n1. Using a `Map`::\\n```\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    return result;\\n  }\\n}\\n\\n```\\n2. Using `function properties`:\\n```\\nfunction memoize(fn) {\\n  fn.cache = {};\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in fn.cache) {\\n      return fn.cache[key];\\n    }\\n    const result = fn(...args);\\n    fn.cache[key] = result;\\n    return result;\\n  }\\n}\\n\\n\\n```\\n3. Using `closures`::\\n```\\nfunction memoize(fn) {\\n  const cache = {};\\n  return function memoized(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const result = fn(...args);\\n    cache[key] = result;\\n    return result;\\n  }\\n}\\n```\\n\\n\\n# Important topic to Learn\\n\\n| Sr No. | Topic |\\n|-----|-----|\\n1.|Array methods|\\n2.|Functional programming|\\n3.|Higher-order functions|\\n4.|Memoization|\\n5.|Fibonacci function, Factorial function|\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```JavaScript []\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n      const key = String(args);\\n      if (key in cache) {\\n        return cache[key];\\n      }\\n      const result = fn(...args);\\n      cache[key] = result;\\n      return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\n``` TypeScript []\\ntype Args = any[];\\ntype MemoizedFn<T> = (...args: Args) => T;\\n\\nfunction memoize<T>(fn: MemoizedFn<T>): MemoizedFn<T> {\\n  const cache: Record<string, T> = {};\\n  return function (...args: Args) {\\n    const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const result = fn(...args);\\n    cache[key] = result;\\n    return result;\\n  }\\n}\\n```\n```\\n\\n// Fibonacci function\\nconst fib = (n) => (n <= 1 ? 1 : fib(n - 1) + fib(n - 2));\\n\\n// Factorial function\\nconst factorial = (n) => (n <= 1 ? 1 : factorial(n - 1) * n);\\n\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    return result;\\n  }\\n}\\n\\n```\n```\\nfunction memoize(fn) {\\n  fn.cache = {};\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in fn.cache) {\\n      return fn.cache[key];\\n    }\\n    const result = fn(...args);\\n    fn.cache[key] = result;\\n    return result;\\n  }\\n}\\n\\n\\n```\n```\\nfunction memoize(fn) {\\n  const cache = {};\\n  return function memoized(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const result = fn(...args);\\n    cache[key] = result;\\n    return result;\\n  }\\n}\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517932,
                "title": "what-is-caching-issue-with-cacheobject-o-1-beginner-friendly-js-ts-day9",
                "content": "## **What is Caching?**\\n* Caching is the process of storing data in a **temporary storage area**, known as **cache**, to improve performance and reduce the amount of times data needs to be fetched from the original source\\n* **In a 5year old language** caching is like saving a cookie or a toy in your pocket so you can quickly find it later when you want to use it again. It helps make things **faster** and **easier** to find!\\n***\\n## **Problem Summary:** \\n\\n* The `memoized` function should only be called **once** for each unique set of inputs, and all subsequent calls with the same inputs should return the `cached` value. \\n* The `memoize` function should work with three possible input functions: `sum`, which takes two `integers` and returns their **sum**; `fib`, which takes a single integer `n` and returns the `nth` number in the **Fibonacci sequence**; and `factorial`, which takes a single integer `n` and returns the **factorial of `n`**.\\n***\\n**Approach:**\\n* we use an object `cacheObject` to store the cached results.\\n* Each time the `memoized` function is called with a set of `arguments`, those arguments are converted to a **JSON string** and used as a `key` to look up the cached result. \\n* If the `key` is found in the `cacheObject`, the cached result is returned. \\n* Otherwise, the original function is called with the arguments, and the result is stored in the `cacheObject` and returned.\\n***\\n**JavaScript Solution:** \\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cacheObject = {};\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in cacheObject) {\\n      return cacheObject[key];\\n    } else {\\n      const result = fn(...args);\\n      cacheObject[key] = result;\\n      return result;\\n    }\\n  }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\n\\n**TypeScript Solution:** \\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n  const cacheObject = {};\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in cacheObject) {\\n      return cacheObject[key];\\n    }else{\\n    const functionOutput = fn(...args);\\n    cacheObject[key] = functionOutput;\\n    return functionOutput;\\n    }\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\n## #Note: \\n* *This implementation has a drawback i.e it assumes that the arguments to the function are JSON-serializable.* \\n* *If the arguments include non-serializable values (such as functions or objects with circular references), you would need to use a different strategy for generating the cacheObjcet key (or avoid memoizing this function altogether).*\\n***\\n**Alternate Approach for non-serialized arguments:**\\n* This time we use a `Map object` instead of a **plain object** to store the cached results, and generates a cache `key` using the arguments object itself, rather than converting it to a JSON string\\n* By using the `args` object itself as the cache `key`, we **avoid the need for serialization**, and should work for any type of arguments **(well as long as they are comparable for equality)**. \\n* The `key` for each set of arguments is generated by concatenating the **type** and **JSON** representation of each argument with a `delimiter` **(in this case, \\'|\\')** and **joining them with commas**. *This ensures that arguments with different types or values are not considered equal.*\\n* The use of a `Map` object also ensures that the order of the arguments is preserved, which may be important for some cases.\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function(...args) {\\n    const key = args.map(a => typeof a + \\'|\\' + JSON.stringify(a)).join(\\',\\');\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    } else {\\n      const result = fn(...args);\\n      cache.set(key, result);\\n      return result;\\n    }\\n  }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\n***\\n**Time Complexity: O(1)\\nSpace Complexity: O(n)**",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cacheObject = {};\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in cacheObject) {\\n      return cacheObject[key];\\n    } else {\\n      const result = fn(...args);\\n      cacheObject[key] = result;\\n      return result;\\n    }\\n  }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n  const cacheObject = {};\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (key in cacheObject) {\\n      return cacheObject[key];\\n    }else{\\n    const functionOutput = fn(...args);\\n    cacheObject[key] = functionOutput;\\n    return functionOutput;\\n    }\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function(...args) {\\n    const key = args.map(a => typeof a + \\'|\\' + JSON.stringify(a)).join(\\',\\');\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    } else {\\n      const result = fn(...args);\\n      cache.set(key, result);\\n      return result;\\n    }\\n  }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407362,
                "title": "typescript-overkill",
                "content": "```typescript\\n// We\\'re told there are only three possible input functions,\\n// which means we can choose a hash function which will work for any of them.\\n\\n// Let\\'s define their types to make this easier:\\n\\n/** \"sum accepts two integers a and b and returns a + b.\" */\\ntype Sum = (a: number, b: number) => number;\\n/** \"fib accepts a single integer n and returns 1 if n <= 1 or fib(n - 1) + fib(n - 2) otherwise.\" */\\ntype Fib = (n: number) => number;\\n/** \"factorial accepts a single integer n and returns 1 if n <= 1 or factorial(n - 1) * n otherwise.\" */\\ntype Factorial = (n: number) => number;\\n\\n// Since they\\'re all just number arguments, we can obtain a unique hash\\n// by joining them as a comma-separated string.\\n\\ntype Fn = Sum & Fib & Factorial;\\n\\nfunction memoize(fn: Fn): Fn {\\n    const argsToResult: Map<string, ReturnType<Fn>> = new Map();\\n    return function(...args: Parameters<Fn>): ReturnType<Fn> {\\n        const hash: string = args.join(\\',\\');\\n        // The order in which we do this is a bit weird because\\n        // TypeScript doesn\\'t know when we\\'ve set a `Map` key.\\n        // The extra `get()` call shouldn\\'t affect performance.\\n        const result: ReturnType<Fn> = argsToResult.get(hash) ?? fn(...args);\\n        if (!argsToResult.has(hash)) {\\n            argsToResult.set(hash, result);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\n// We\\'re told there are only three possible input functions,\\n// which means we can choose a hash function which will work for any of them.\\n\\n// Let\\'s define their types to make this easier:\\n\\n/** \"sum accepts two integers a and b and returns a + b.\" */\\ntype Sum = (a: number, b: number) => number;\\n/** \"fib accepts a single integer n and returns 1 if n <= 1 or fib(n - 1) + fib(n - 2) otherwise.\" */\\ntype Fib = (n: number) => number;\\n/** \"factorial accepts a single integer n and returns 1 if n <= 1 or factorial(n - 1) * n otherwise.\" */\\ntype Factorial = (n: number) => number;\\n\\n// Since they\\'re all just number arguments, we can obtain a unique hash\\n// by joining them as a comma-separated string.\\n\\ntype Fn = Sum & Fib & Factorial;\\n\\nfunction memoize(fn: Fn): Fn {\\n    const argsToResult: Map<string, ReturnType<Fn>> = new Map();\\n    return function(...args: Parameters<Fn>): ReturnType<Fn> {\\n        const hash: string = args.join(\\',\\');\\n        // The order in which we do this is a bit weird because\\n        // TypeScript doesn\\'t know when we\\'ve set a `Map` key.\\n        // The extra `get()` call shouldn\\'t affect performance.\\n        const result: ReturnType<Fn> = argsToResult.get(hash) ?? fn(...args);\\n        if (!argsToResult.has(hash)) {\\n            argsToResult.set(hash, result);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407780,
                "title": "easy-js-solution-memoization-technique",
                "content": "# Approach\\nI have instantiated an object and assigned the argument to a key. If the key already exists in the object, the value is returned. If not, the callback function is called.\\n\\n\\n\\n# Time complexity and space complexity\\nThe **time complexity** of the memoize function is **O(1)** for cache retrieval and assignment, and **O(n)**.\\n\\nThe cache array will store the results of all unique function calls, so the space complexity is **O(n)** where n is the number of unique function call arguments.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    var cache = [];\\n\\n    return function(...args) {       \\n        var key = args.join(\"-\").toString();\\n\\n        if(cache[`${key}`] != undefined ){\\n            return cache[`${key}`];\\n        }\\n\\n        return cache[`${key}`] = Number(fn(...args));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    var cache = [];\\n\\n    return function(...args) {       \\n        var key = args.join(\"-\").toString();\\n\\n        if(cache[`${key}`] != undefined ){\\n            return cache[`${key}`];\\n        }\\n\\n        return cache[`${key}`] = Number(fn(...args));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518421,
                "title": "day-o-1-o-8-commented-with-examples",
                "content": "The code provided implements a **higher-order function** called `memoize`. This function takes another function `fn` as an argument and returns a memoized version of that function. ***Memoization*** is a technique used to optimize function calls by caching the results of expensive function calls and returning the cached result when the same input is encountered again.\\n\\nHere\\'s how the `memoize` function works:\\n\\n1. It creates a new `Map` object called `dp` (short for \"dynamic programming\") to store the cached results.\\n2. It defines and returns an ***anonymous function*** that takes any number of arguments using the rest parameter syntax `...args`.\\n3. Inside the anonymous function, it converts the arguments into a string representation using `JSON.stringify()` and assigns it to the `key` variable.\\n4. It checks if the `dp` map already has a value associated with the `key` using the `has()` method. If it does, it retrieves the value using the `get()` method and returns it. This avoids recomputing the function result if it has already been computed for the same set of arguments.\\n5. If the `dp` map does not have a value associated with the `key`, it calls the original function `fn` with the provided arguments using the spread syntax `...args` and assigns the result to the `ans` variable.\\n6. It sets the `ans` as the value associated with the `key` in the `dp` map using the `set()` method.\\n7. Finally, it returns the `ans` value.\\n\\nHere\\'s an example to illustrate the usage of the `memoize` function:\\n\\n```javascript\\nfunction add(a, b) {\\n    console.log(\\'Calculating...\\');\\n    return a + b;\\n}\\n\\nconst memoizedAdd = memoize(add);\\n\\nconsole.log(memoizedAdd(5, 3));  // Output: Calculating... 8\\nconsole.log(memoizedAdd(5, 3));  // Output: 8 (cached result)\\nconsole.log(memoizedAdd(2, 4));  // Output: Calculating... 6\\nconsole.log(memoizedAdd(2, 4));  // Output: 6 (cached result)\\n```\\n\\nIn this example, the `add` function is passed to `memoize`, creating a memoized version called `memoizedAdd`. When `memoizedAdd` is called with the same arguments multiple times, it only computes the result once and caches it for future use. Subsequent calls with the same arguments retrieve the cached result directly, avoiding the expensive computation\\n\\n\\n***Here is the code to the current problem :-*** \\n\\n```\\nfunction memoize(fn) {\\n    \\n    let dp = new Map();\\n    \\n    return function(...args) {\\n        \\n        let key = JSON.stringify(args);\\n        if(dp.has(key)){\\n            return dp.get(key);\\n        }\\n        let ans = fn(...args);\\n        dp.set(key, ans);\\n        \\n    return ans;\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```javascript\\nfunction add(a, b) {\\n    console.log(\\'Calculating...\\');\\n    return a + b;\\n}\\n\\nconst memoizedAdd = memoize(add);\\n\\nconsole.log(memoizedAdd(5, 3));  // Output: Calculating... 8\\nconsole.log(memoizedAdd(5, 3));  // Output: 8 (cached result)\\nconsole.log(memoizedAdd(2, 4));  // Output: Calculating... 6\\nconsole.log(memoizedAdd(2, 4));  // Output: 6 (cached result)\\n```\n```\\nfunction memoize(fn) {\\n    \\n    let dp = new Map();\\n    \\n    return function(...args) {\\n        \\n        let key = JSON.stringify(args);\\n        if(dp.has(key)){\\n            return dp.get(key);\\n        }\\n        let ans = fn(...args);\\n        dp.set(key, ans);\\n        \\n    return ans;\\n    }\\n}\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3860150,
                "title": "3-lines-beats-99-32-best-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n1. The function utilizes a **Map** to store the cached results, which is considered faster for caching purposes compared to using a regular object.\\n2. **Arrow functions** are used to minimize the code and keep it concise\\n3. The **ternary operator** is employed to make the code more compact and efficient.\\n4. A **chaining strategy** is used to perform multiple operations on the same Map object in a single line, enhancing code readability and brevity.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\nPlease **Upvote** if you find helpful.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518178,
                "title": "easy-to-understand-js-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n   let cache = new Map();\\n    return function(...args) {\\n        let key = JSON.stringify(args);\\n        if(cache.has(key)){\\n            return cache.get(key);\\n        }\\n        let result = fn(...args);\\n        cache.set(key, result);\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n   let cache = new Map();\\n    return function(...args) {\\n        let key = JSON.stringify(args);\\n        if(cache.has(key)){\\n            return cache.get(key);\\n        }\\n        let result = fn(...args);\\n        cache.set(key, result);\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517996,
                "title": "easy-javascript-solution-faster-than-90-using-map-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n 1. Using Map in Javascript we first check wheather we compute result for corresponding parameters earliar or not , if yes then we simple return value corresponding to parameters that we have store in Map.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. Declare the Map , this will store value of fn(parameters) .\\n    `let m=new Map()`\\n 1. Declare callcount, this will store count of times given function has been called.\\n    `callcount=0`\\n 1. Declare the key .\\n    `key=\"`\\n 1. Intialize the key.\\n    - if Memoize of sum(a,b) is called then key will be \"a+b\".\\n    - if fact(n) is called then key will be \"n\".\\n    - if fib(n) is called then key will be \"n\".\\n 1. if(m.has(key)) is true that means we have already compute it\\'s value so no need to compute once again,simply return m.get(key).\\n 2. Otherwise we will compute its value and store it in map.\\n    \\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let callcount=0;\\n    let Mp=new Map();\\n    return function(...args) {\\n           let key;\\n            key=`${args[0]}`;   \\n           if(args.length==2)\\n           {\\n              key+=\"+\"+`${args[1]}`;\\n           }\\n           if(Mp.has(key))\\n           {\\n              return Mp.get(key);  \\n           }\\n           callcount+=1;\\n           let res=fn(...args);  \\n           Mp.set(key,res);\\n           return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let callcount=0;\\n    let Mp=new Map();\\n    return function(...args) {\\n           let key;\\n            key=`${args[0]}`;   \\n           if(args.length==2)\\n           {\\n              key+=\"+\"+`${args[1]}`;\\n           }\\n           if(Mp.has(key))\\n           {\\n              return Mp.get(key);  \\n           }\\n           callcount+=1;\\n           let res=fn(...args);  \\n           Mp.set(key,res);\\n           return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519758,
                "title": "javascript-day-8-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        let key = String(args);\\n\\n        if(key in cache){\\n            return cache[key];\\n        }\\n        \\n        return cache[key] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        let key = String(args);\\n\\n        if(key in cache){\\n            return cache[key];\\n        }\\n        \\n        return cache[key] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518964,
                "title": "easy-javascript-solution-faster-than-95-clearly-explained-day-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to implement a memoization technique to cache the results of function calls. By caching the results, we can avoid redundant computations and improve the performance of the function.\\n\\n# What is caching ?\\n<!-- Describe your approach to solving the problem. -->\\nCaching is a technique used to store and retrieve data in a faster manner. If the same arguments are encountered again, instead of recomputing the result, we can directly retrieve it from the cache, resulting in improved efficiency. It is especially helpful when the operation is expensive.\\n\\n---\\n# Approach\\n- Create map **inputs** , which stores arguments of previous function calls\\n- Return a new function that can take any number of arguments\\n- Create *key* converting arguments using ``JSON.stringify()``\\n- Check if function was previously called with these arguments using ``.has()`` method on **inputs**\\n- If it does return the cached value.But if the key does not exist in **inputs** calculate value using ``fn(key)``\\n- Set the arguments and calculated value in **inputs** and return it\\n\\n\\n\\n# Why JSON.stringify() is necessary ?\\nJavaScript arrays are reference types, and by default, when used as keys in a Map or Object, they are compared by reference rather than their content. ``JSON.stringify(args)`` convert args into a string representation, so we can easily check if function was previously called with these arguments.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n O(N) - if value was previously caluculated\\n In other case it depends on fn complexity\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n  //Map for inputs\\n  const inputs = new Map();\\n  return function(...args) {\\n\\n    //Convert fn arguments to a string key\\n    const key = JSON.stringify(args);\\n\\n    //Check if this value was calulated\\n    if (inputs.has(key)) {\\n      return inputs.get(key);\\n    } else {\\n      const result = fn(...args);\\n      inputs.set(key, result);\\n      return result;\\n    }\\n  }\\n};\\n\\n```\\n\\n    Please Upvote \\uD83D\\uDC4D if my solution was helpful for you \\uD83D\\uDE0A\\n    Feel free to comment below \\uD83D\\uDC47\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\nfunction memoize(fn) {\\n  //Map for inputs\\n  const inputs = new Map();\\n  return function(...args) {\\n\\n    //Convert fn arguments to a string key\\n    const key = JSON.stringify(args);\\n\\n    //Check if this value was calulated\\n    if (inputs.has(key)) {\\n      return inputs.get(key);\\n    } else {\\n      const result = fn(...args);\\n      inputs.set(key, result);\\n      return result;\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518507,
                "title": "java-script-solution-for-memoize-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to optimize the execution of a function by caching its results for specific input arguments. It avoids recomputing the function output if the same input arguments have been used before.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach:\\nThe memoize function accepts a function fn as its argument. It creates a closure with a cache object to store the computed results. The returned function takes any number of arguments using the rest parameter syntax (...args).\\n\\nWhen the returned function is invoked with arguments, it converts the arguments into a string format (key) using JSON.stringify. It then checks if the key exists in the cache. If so, it returns the cached value.\\n\\nIf the key is not present in the cache, it invokes the original function fn with the given arguments and stores the result in the cache using the key as the cache key. Finally, it returns the computed result.\\n\\nThe provided example demonstrates the usage of memoize by wrapping a function that calculates the sum of two numbers. The first invocation triggers the function to be executed and returns the sum. The subsequent invocation with the same arguments retrieves the result from the cache, avoiding the actual computation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the memoized function depends on the original function (fn) being memoized. If fn has a time complexity of O(f(n)), the memoized function will have the same time complexity when computing uncached results. However, for cached results, the time complexity reduces to O(1) since the cached value is immediately returned.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the memoized function is determined by the number of unique input arguments and the size of the cache. In this case, the cache is implemented as an object (cache), and its size depends on the number of distinct argument combinations. The space complexity is proportional to the number of unique argument combinations encountered during the execution of the memoized function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const functionOutput = fn(...args);\\n    cache[key] = functionOutput;\\n    return functionOutput;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const functionOutput = fn(...args);\\n    cache[key] = functionOutput;\\n    return functionOutput;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3510427,
                "title": "javascript-solution",
                "content": "\\n\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const mem={};\\n    return function(...args) {\\n        if (mem[args]!==undefined) return mem[args];\\n        mem[args]=fn(...args);\\n        return mem[args];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const mem={};\\n    return function(...args) {\\n        if (mem[args]!==undefined) return mem[args];\\n        mem[args]=fn(...args);\\n        return mem[args];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3699713,
                "title": "full-explanation-unlike-anyothers",
                "content": "# Intuition\\nThe intiution behind solving this problem is to understand a very important concept  \" Caching \"\\n# What is Caching ?\\n is a technique used to store the results of expensive or time-consuming operations so that they can be retrieved quickly in subsequent calls with the same inputs.\\n# Why do we need it ?\\n It helps to improve performance by avoiding the need to recompute the result every time the function is called with the same arguments.\\n\\n# A Question you might be asking : But where was caching mentioned here? I have read the problem and no one mentioned anything bout Caching.\\nWell , that\\'s correct. BUT they did mention \"memomize function\" .\\nA Memoization function is any function that applies the concept of caching and Memorizes .\\n\\n# Pre-requistes \\n\\n***Maps and their methods\\nJSON.stringify method\\nClosures\\nRest Operator\\nNested Functions***\\n\\n*Let\\'s explain it in even further simpler terms*\\nIt memorizes previous results or computations by storing them somewhere , this way instead of recomputing them. We\\'d be just calling the results again or getting them , such results are **cached** . They\\'re already stored somewhere and then cached easily.\\n\\nIn our Approach , I have used Maps to store previous results. \\nYou can use anything but Maps are efficient and much better.\\n# Approach\\nLet\\'s Break Down my solution and explain it in detail .\\n- Create a Map called \"cache\" .\\n- Then we have our other returned function that takes args or previous function via Rest opperator.\\n- Then we convert those args into a string via JSON.stringify , and store them in a variable called input .\\n- Later on we check if cache has input in it via the has method if it does then we return that via the get method .\\n- Finally we return result which will be what the function fn returns.\\n- IF that wasn\\'t the case , then we store that in cache via the set method . We store via input key and results as the value.\\n\\n\\nIF YOU HAVE ANY FURTHER QUESTIONS MAKE SURE TO ASK BELOW :)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n// Decorator Function\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return function(...args) {\\n        const input = JSON.stringify(args);\\n        if(cache.has(input))  return cache.get(input);\\n         const result = fn(...args);\\n          //else//\\n        cache.set(input,result);\\n        return result;\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n// Decorator Function\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return function(...args) {\\n        const input = JSON.stringify(args);\\n        if(cache.has(input))  return cache.get(input);\\n         const result = fn(...args);\\n          //else//\\n        cache.set(input,result);\\n        return result;\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520195,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const k = {};\\n    return function(...args) {\\n        const a = String(args);\\n        if(a in k) return k[a];\\n        const ans = fn(...args);\\n        k[a] = ans;\\n        return ans;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const k = {};\\n    return function(...args) {\\n        const a = String(args);\\n        if(a in k) return k[a];\\n        const ans = fn(...args);\\n        k[a] = ans;\\n        return ans;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520143,
                "title": "memoize-easy-way",
                "content": "Explanation of the below code line by line\\n\\n.  function memoize(fn) {\\n\\nThis defines a function named memoize that takes another function fn as an argument. The purpose of memoize is to create a new function that caches the results of fn so that it doesn\\'t have to be recomputed every time it\\'s called with the same arguments.\\n*********************************************************\\n  .  const dictionary = {};\\n\\nThis creates an empty object named dictionary that will be used to store the cached results of fn.\\n\\n********************************************************\\n  . return function(...args) {\\n\\t\\t\\nThis returns a new function that takes any number of arguments and will be used to call fn or return the cached result if it exists.\\n\\n********************************************************\\n     .   const key = String(args);\\n\\nThis creates a new string key that uniquely identifies the set of arguments passed to the function. The String function is used to convert the arguments to a string so that they can be used as a key in the dictionary object.\\n\\n********************************************************\\n        if(key in dictionary)\\n        {\\n            return dictionary[key];\\n        }\\n\\nThis checks if the key already exists in the dictionary object. If it does, it returns the cached result for that key.\\n\\n********************************************************\\n        const result = fn(...args);\\n\\t\\t\\nIf the key is not found in the dictionary, this calls the original fn function with the given arguments to compute a new result.\\n\\n********************************************************\\n        dictionary[key] = result;\\n        return result;\\n\\t\\t\\nThis stores the newly computed result in the dictionary object under the key for future use, and returns the computed result.\\n\\nOverall, this memoize function can be used to optimize the performance of functions that are called with the same arguments multiple times, by caching the results and returning them from the cache instead of recomputing them every time.\\n\\n********************************************************\\n\\n\\n\\nfunction memoize(fn) {\\n    const dictionary = {};\\n    \\n    return function(...args) {\\n        \\n        const key = String(args);\\n        if(key in dictionary)\\n        {\\n            return dictionary[key];\\n        }\\n        const result = fn(...args);\\n        dictionary[key] = result;\\n        return result;\\n        \\n        \\n    }\\n}\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Explanation of the below code line by line\\n\\n.  function memoize(fn) {\\n\\nThis defines a function named memoize that takes another function fn as an argument. The purpose of memoize is to create a new function that caches the results of fn so that it doesn\\'t have to be recomputed every time it\\'s called with the same arguments.\\n*********************************************************\\n  .  const dictionary = {};\\n\\nThis creates an empty object named dictionary that will be used to store the cached results of fn.\\n\\n********************************************************\\n  . return function(...args) {\\n\\t\\t\\nThis returns a new function that takes any number of arguments and will be used to call fn or return the cached result if it exists.\\n\\n********************************************************\\n     .   const key = String(args);\\n\\nThis creates a new string key that uniquely identifies the set of arguments passed to the function. The String function is used to convert the arguments to a string so that they can be used as a key in the dictionary object.\\n\\n********************************************************\\n        if(key in dictionary)\\n        {\\n            return dictionary[key];\\n        }\\n\\nThis checks if the key already exists in the dictionary object. If it does, it returns the cached result for that key.\\n\\n********************************************************\\n        const result = fn(...args);\\n\\t\\t\\nIf the key is not found in the dictionary, this calls the original fn function with the given arguments to compute a new result.\\n\\n********************************************************\\n        dictionary[key] = result;\\n        return result;\\n\\t\\t\\nThis stores the newly computed result in the dictionary object under the key for future use, and returns the computed result.\\n\\nOverall, this memoize function can be used to optimize the performance of functions that are called with the same arguments multiple times, by caching the results and returning them from the cache instead of recomputing them every time.\\n\\n********************************************************\\n\\n\\n\\nfunction memoize(fn) {\\n    const dictionary = {};\\n    \\n    return function(...args) {\\n        \\n        const key = String(args);\\n        if(key in dictionary)\\n        {\\n            return dictionary[key];\\n        }\\n        const result = fn(...args);\\n        dictionary[key] = result;\\n        return result;\\n        \\n        \\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3518818,
                "title": "easiest-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Create** a cache object(dictionary).\\n2. **Generate** a *Key* from the given input.\\n3. **Check** the *Key* in cache object.\\n    1. If *Key is present*.\\n        - Return the respective value from the cache object.\\n    2. Else\\n        - Call the function, store the value in cache object, then return the calculated value.\\n\\n\\n# Code\\n``` javaScript []\\nfunction memoize(fn) {\\n    var cache = {};\\n\\n    return function(...args) {\\n        let key = String(args);\\n\\n        if(key in cache) return cache[key];\\n        return cache[key] = fn(...args);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nfunction memoize(fn) {\\n    var cache = {};\\n\\n    return function(...args) {\\n        let key = String(args);\\n\\n        if(key in cache) return cache[key];\\n        return cache[key] = fn(...args);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518322,
                "title": "why-leetcode-mention-input-function-will-be-sum-or-fib-or-factorial-decorator-caching",
                "content": "Let\\'s first understand some terminology and concept\\n\\n**What is pure function ?**\\n\\nPure function is function which will give same output for same inputs.\\ne.g. Like sum , it will give same output for same inputs.\\n\\n\\n**What is caching ?**\\n\\nDo not repeat yourself, if we have done some task in previous and we get same task again , task is pure , then we are not going to perform same task again .\\n\\n**What is Decorator in javascript ?**\\n\\nDecorator is special type of function, that take function as an input and change the behaviour of that function . (Please note that decorator in javascript different from decorator in typescript).\\n\\n**What is the role of pure function in this question ?**\\n\\nIn this question we are assuming that the function which leetcode give as an input should be pure, that\\'s why we get an opportunity to use a caching here. \\n\\n**Leetcode mention input will be sum or fib or factorial because all these function are pure and we can use caching here.**\\n\\n**Why I told you about Decorator here ?**\\n\\n`memoize` function known as decorator because it is taking a function as an input and alter this behaviour.\\n\\n**Why we need caching ?**\\n\\nIf that task is taking lot of resource like CPU power, time then it is not good idea to perform task , use the output of the previous task . \\n\\n\\n# Code\\n```\\n// Decorator Function\\nfunction memoize(fn) {\\n    // Caching\\n    let cachedData = new Map();\\n    return function(...args) {\\n        const input = JSON.stringify(args);\\n        // checking same input is present previously or not\\n        if(cachedData.has(input)){\\n            return cachedData.get(input);\\n        }\\n        const result = fn(...args);\\n        // if not create new entry and set in map\\n        cachedData.set(input,result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Decorator Function\\nfunction memoize(fn) {\\n    // Caching\\n    let cachedData = new Map();\\n    return function(...args) {\\n        const input = JSON.stringify(args);\\n        // checking same input is present previously or not\\n        if(cachedData.has(input)){\\n            return cachedData.get(input);\\n        }\\n        const result = fn(...args);\\n        // if not create new entry and set in map\\n        cachedData.set(input,result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517870,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const map = new Map();\\n    return function(...args) {\\n        if(!map.has(args.join(\",\"))) {\\n            map.set(args.join(\",\"), fn(...args));\\n        }\\n        return map.get(args.join(\",\"));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const map = new Map();\\n    return function(...args) {\\n        if(!map.has(args.join(\",\"))) {\\n            map.set(args.join(\",\"), fn(...args));\\n        }\\n        return map.get(args.join(\",\"));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502235,
                "title": "js-simplest-solution",
                "content": "# Intuition\\nWe need to come up with a function that will compute our key from given arguments. The easiest way to do it is to create a String that is unique to every combination of arguments.\\n\\nBecause the arguments are purely numeric, we can just join them to string with some kind of separator:\\n```js\\nconst keyOf = args => args.join(\\'|\\')\\n```\\nBut it is more efficient (and more extendable if the arguments weren\\'t purely numeric or primitive) to convert it to JSON.\\n```js\\nconst keyOf = args => JSON.stringify(args)\\n```\\n\\nIf we have an approach on how to compute the key, we can use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) data structure to store the result for a given key.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ for n distinct calls\\n\\n- Space complexity:\\n$$O(n)$$ after n distinct calls\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = fn => {\\n    const memo = new Map()\\n\\n    return (...args) => {\\n        const key = keyOf(args)\\n        if (!memo.has(key)) {\\n            memo.set(key, fn(...args))\\n        }\\n        return memo.get(key)\\n    }\\n}\\n\\nconst keyOf = args => JSON.stringify(args)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst keyOf = args => args.join(\\'|\\')\\n```\n```js\\nconst keyOf = args => JSON.stringify(args)\\n```\n```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = fn => {\\n    const memo = new Map()\\n\\n    return (...args) => {\\n        const key = keyOf(args)\\n        if (!memo.has(key)) {\\n            memo.set(key, fn(...args))\\n        }\\n        return memo.get(key)\\n    }\\n}\\n\\nconst keyOf = args => JSON.stringify(args)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471803,
                "title": "efficient-solution-leveraging-modern-syntax",
                "content": "# Intuition\\nThe intuition behind this solution is to implement memoization, which allows us to cache the results of function calls and retrieve them for future calls with the same arguments. This can help reduce redundant computations and improve overall performance.\\n\\n\\n# Approach\\nThe approach involves creating a higher-order function memoize that takes a function fn as input. Inside memoize, we initialize a cache using a Map object to store the results of function calls.\\n\\nWhen the memoized function is invoked with arguments, we convert the arguments into a string representation using JSON.stringify and use it as a key in the cache. If the cache already contains the key, we retrieve and return the cached result.\\n\\nIf the cache does not have the key, it means that the function call with these arguments has not been made before. In this case, we invoke the original function fn with the arguments, store the result in the cache using the key, and return the result.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the memoized function depends on the time complexity of the original function fn and the efficiency of cache lookup and insertion operations. In this case, assuming the cache operations take constant time, the time complexity can be considered as the same as the original function, which is typically denoted as O(f(n)) based on the time complexity of fn.\\n\\n- Space complexity:\\nThe space complexity is determined by the size of the cache, which grows as more function calls are made with unique argument combinations. In this case, the space complexity can be considered as O(m), where m is the number of unique argument combinations stored in the cache.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n\\n        if (cache.has(key)){\\n            return cache.get(key);\\n        }\\n\\n        const output = fn(...args);\\n\\n        cache.set(key, output);\\n\\n        return output;        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n\\n        if (cache.has(key)){\\n            return cache.get(key);\\n        }\\n\\n        const output = fn(...args);\\n\\n        cache.set(key, output);\\n\\n        return output;        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462998,
                "title": "the-easiest-trie-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nYou will create a tree for the new args called by the function. If they were called before, just go to the root created before.\\n\\nThat\\'s the most perfect example to understand memoization.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ $$n$$ number of args\\n\\n- Space complexity:\\n$$O(2^n)$$ \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    var memTrie = new Map();\\n    return function(...args) {\\n        let X = memTrie;\\n        for (let A of args){\\n            if (!X.has(A))\\n                X.set(A, new Map());\\n            X = X.get(A);            \\n        }\\n        if (!X.has(null))\\n            X.set(null, fn(...args))\\n        return X.get(null);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    var memTrie = new Map();\\n    return function(...args) {\\n        let X = memTrie;\\n        for (let A of args){\\n            if (!X.has(A))\\n                X.set(A, new Map());\\n            X = X.get(A);            \\n        }\\n        if (!X.has(null))\\n            X.set(null, fn(...args))\\n        return X.get(null);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414748,
                "title": "2-liner-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize=(fn)=> {\\n    const memo ={}\\n    return (...args) => memo[args.join()] ?? (memo[args.join()] = fn(...args)); \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize=(fn)=> {\\n    const memo ={}\\n    return (...args) => memo[args.join()] ?? (memo[args.join()] = fn(...args)); \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407782,
                "title": "common-javascript-solution-easy-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to create a memoized version of the given function. The memoized version of the function should return cached results for repeated inputs to save computation time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create a closure function memoize that takes in the original function fn as input. We then define a variable cached to store the cached values and return a new function that takes in the arguments args. We then convert the args into a string argsString and check if the value exists in the cache. If the value exists in the cache, we return it. Otherwise, we call the original function with the given arguments and cache the result before returning it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: The time complexity of the memoized function is dependent on the original function. For the given sum, fib, and factorial functions, the time complexity is O(1), O(2^n), and O(n) respectively. The memoization adds constant time to the function execution.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the memoized function is dependent on the number of unique inputs to the original function. The memoization cache stores these inputs and their respective outputs. In the worst-case scenario where all possible inputs are unique, the space complexity is O(n) where n is the number of inputs.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    let answer = {};\\n    return function(...args) {\\n        const argsString = args.join(\".\");\\n        const cacheValue = answer[argsString]\\n        if(cacheValue != undefined) {\\n            return cacheValue;\\n        }\\n        return answer[argsString] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    let answer = {};\\n    return function(...args) {\\n        const argsString = args.join(\".\");\\n        const cacheValue = answer[argsString]\\n        if(cacheValue != undefined) {\\n            return cacheValue;\\n        }\\n        return answer[argsString] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407690,
                "title": "easy-to-understand-by-using-cache",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const mem = {};\\n  return function(...args) {\\n    if (mem[args] !== undefined) return mem[args];\\n    mem[args] = fn(...args);\\n    return mem[args]\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const mem = {};\\n  return function(...args) {\\n    if (mem[args] !== undefined) return mem[args];\\n    mem[args] = fn(...args);\\n    return mem[args]\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407402,
                "title": "easy-beats-100-full-and-easy-explanation",
                "content": "# Explanation\\nThe code defines a higher-order function called $$memoize$$ that takes a single argument $$fn$$, which is a function to be memoized. Memoization is a technique used in programming to optimize function calls by caching the results of expensive function calls and returning the cached result for the same input arguments instead of re-computing the result.\\n\\nInside the $$memoize$$ function, a cache object is created to store the results of function calls. The cache object will be used to store key-value pairs, where the key is a string representation of the input arguments passed to the memoized function, and the value is the result of the function call.\\n\\nNext, an $$anonymous function$$ is returned, which takes any number of arguments using the spread syntax $$...args$$. This anonymous function acts as the memoized version of the original function fn.\\n\\nInside the memoized function, a string representation of the input arguments args is used as the key to access the cached result in the cache object. The string representation of the arguments is obtained using the template literal ${args}.\\n\\nThe function then checks if the cache object has a property with the key key using the hasOwnProperty method. If the cached result is found in the cache object, it is returned immediately using the return $$cache[key]$$.\\n\\nIf the cached result is not found, the original function fn is called with the input arguments ...args using the spread syntax, and the result is stored in the cache object with the key key using the assignment operator =. The stored result is then returned using return $$cache[key]$$ = $$fn(...args)$$. This allows subsequent calls with the same input arguments to directly return the cached result, avoiding redundant computations and improving performance.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n    return function(...args) {\\n        let key = `${args}`\\n        if (cache.hasOwnProperty(key)) {\\n            return cache[key]\\n        }\\n        else {\\n            return cache[key] = fn(...args)\\n        }\\n    } \\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n    return function(...args) {\\n        let key = `${args}`\\n        if (cache.hasOwnProperty(key)) {\\n            return cache[key]\\n        }\\n        else {\\n            return cache[key] = fn(...args)\\n        }\\n    } \\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407134,
                "title": "easy-solution-short-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const map={}\\n    return function(...args) {\\n        const key=args.join(\\'~\\')\\n        if(map[key]==undefined)map[key]=fn(...args)\\n        return map[key]\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const map={}\\n    return function(...args) {\\n        const key=args.join(\\'~\\')\\n        if(map[key]==undefined)map[key]=fn(...args)\\n        return map[key]\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500116,
                "title": "ts-hashing-scoping-337ms-107-9mb",
                "content": "A classic challenge we can solve with some scoping that we used in previous JS challenges: [memoize II](https://leetcode.com/problems/memoize-ii/) ([cracked here](https://leetcode.com/problems/memoize-ii/solutions/3583987/ts-custom-hashing-vs-trie-like-approach/)) presents a more complex scenario; in this case, we will need access to a resource \"external\" to both `fn` and the wrapper we are creating around it, in order to store, retrieve and check the existence of precomputed results.\\n\\nThis store is going to be a normal object aptly called `stored` and created just before our wrapper.\\n\\nThe wrapper function that we are going to `return` will then:\\n* create a hash `key` out of `args` (I kept it simple and created it by just joining the parameters with `+` in a string);\\n* check if we already pre-computed that result (ie: `store[key] !== undefine`) and if so, `return` it;\\n* compute the required result (ie: `fn(...args)`) otherwise and store it where it belongs (ie: `store[key]`) before `return`ing it.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ (for `sum`) $$O(n)$$ (for the rest)\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```ts\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = {};\\n    return function(...args) {\\n        const key = args.join(\"+\");\\n        if (store[key] !== undefined) return store[key];\\n        return store[key] = fn(...args);\\n    }\\n}\\n```\\n\\nAlternative version using a `Map` as a `store`; it gave me a marginally faster average time, but with slightly higher (~0.5MB) memory consumption.\\n\\n```ts\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return function(...args) {\\n        const key = args.join(\"+\");\\n        let res = store.get(key);\\n        if (res !== undefined) return res;\\n        res = res = fn(...args);\\n        store.set(key, res);\\n        return res;\\n    }\\n}\\n```\\n\\nFunnier version of the last with lazy evaluation and comma operator in the `return` statement:\\n\\n```ts\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return function(...args) {\\n        const key = args.join(\"+\");\\n        let res;\\n        return store.get(key) ?? (\\n            res = fn(...args), store.set(key, res), res\\n        );\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Memoization"
                ],
                "code": "```ts\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = {};\\n    return function(...args) {\\n        const key = args.join(\"+\");\\n        if (store[key] !== undefined) return store[key];\\n        return store[key] = fn(...args);\\n    }\\n}\\n```\n```ts\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return function(...args) {\\n        const key = args.join(\"+\");\\n        let res = store.get(key);\\n        if (res !== undefined) return res;\\n        res = res = fn(...args);\\n        store.set(key, res);\\n        return res;\\n    }\\n}\\n```\n```ts\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return function(...args) {\\n        const key = args.join(\"+\");\\n        let res;\\n        return store.get(key) ?? (\\n            res = fn(...args), store.set(key, res), res\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3482400,
                "title": "simple-solution-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let mp = new Map();\\n    return function newfn(...params){       \\n        if(mp.has(JSON.stringify(params))){\\n            return mp.get(JSON.stringify(params));\\n        }\\n         let res = fn(params[0],params[1]);\\n        mp.set(JSON.stringify(params),res);\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let mp = new Map();\\n    return function newfn(...params){       \\n        if(mp.has(JSON.stringify(params))){\\n            return mp.get(JSON.stringify(params));\\n        }\\n         let res = fn(params[0],params[1]);\\n        mp.set(JSON.stringify(params),res);\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427392,
                "title": "easy-beginner-friendly-explanation",
                "content": "1. First, let\\u2019s define a simple function that we want to memoize. For example, let\\u2019s say we have a sum function that takes two numbers a and b as arguments and returns their sum:\\n```\\nconst sum = (a, b) => a + b;\\n```\\n2.Now let\\u2019s define the memoize function. This function takes another function fn as an argument and returns a new function memoizedFn:\\n```const memoize = (fn) => {\\n    // ...\\n    const memoizedFn = (...args) => {\\n        // ...\\n    };\\n    return memoizedFn;\\n};\\n```\\n3.Inside the memoize function, we create an empty object called cache. This object will be used to store the results of previous function calls:\\n```const memoize = (fn) => {\\n    const cache = {};\\n    // ...\\n};\\n```\\n4.The memoizedFn function takes any number of arguments using the spread operator (...args). This means that all the arguments passed to this function will be collected into an array called args.\\n\\n5.Inside the memoizedFn function, we first create a string representation of the arguments using JSON.stringify(args). This string will be used as a key to store and retrieve results from the cache.\\n\\n6.Next, we check if this key is already in the cache using the in operator (key in cache). If it is, it means that we have already called the original function with these arguments before, so we can just return the cached result instead of calling the original function again:\\n```const memoize = (fn) => {\\n    const cache = {};\\n    const memoizedFn = (...args) => {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        // ...\\n    };\\n    return memoizedFn;\\n};\\n```\\n7.If the key is not in the cache, it means that this is the first time we are calling the original function with these arguments. In this case, we call the original function fn with these arguments using the spread operator (...args) and store the result in a variable called result.\\n\\n8.Then we add a new entry to the cache with this key and value (cache[key] = result) and return the result:\\n```const memoize = (fn) => {\\n    const cache = {};\\n    const memoizedFn = (...args) => {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = fn(...args);\\n        cache[key] = result;\\n        return result;\\n    };\\n    return memoizedFn;\\n};\\n```\\n9.Now we can use this memoize function to create a memoized version of our sum function like this:\\n```\\nconst memoizedSum = memoize(sum);\\n```\\n10.We can now call this memoizedSum function instead of the original sum function to avoid redundant calculations. For example:\\n```console.log(memoizedSum(1, 2)); // 3 (calculated)\\nconsole.log(memoizedSum(1, 2)); // 3 (cached)\\n```\\nIn this example, the first call to memoizedSum(1, 2) calculates the result by calling the original sum function and stores it in the cache. The second call to memoizedSum(1, 2) returns the cached result instead of recalculating it.\\nI hope you find this explanation. if you do please feel free to drop a upvoted and ask me any questions.\\n\\nfinal code is here\\n```const memoize = (fn) => {\\n    const cache = {};\\n    const memoizedFn = (...args) => {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = fn(...args);\\n        cache[key] = result;\\n        return result;\\n    };\\n    return memoizedFn;\\n};\\n\\nconst sum = (a, b) => a + b;\\n\\nconst fib = (n) => {\\n    if (n <= 1) {\\n        return 1;\\n    }\\n    return fib(n - 1) + fib(n - 2);\\n};\\n\\nconst factorial = (n) => {\\n    if (n <= 1) {\\n        return 1;\\n    }\\n    return factorial(n - 1) * n;\\n};\\n\\nconst memoizedSum = memoize(sum);\\nconst memoizedFib = memoize(fib);\\nconst memoizedFactorial = memoize(factorial);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sum = (a, b) => a + b;\\n```\n```const memoize = (fn) => {\\n    // ...\\n    const memoizedFn = (...args) => {\\n        // ...\\n    };\\n    return memoizedFn;\\n};\\n```\n```const memoize = (fn) => {\\n    const cache = {};\\n    // ...\\n};\\n```\n```const memoize = (fn) => {\\n    const cache = {};\\n    const memoizedFn = (...args) => {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        // ...\\n    };\\n    return memoizedFn;\\n};\\n```\n```const memoize = (fn) => {\\n    const cache = {};\\n    const memoizedFn = (...args) => {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = fn(...args);\\n        cache[key] = result;\\n        return result;\\n    };\\n    return memoizedFn;\\n};\\n```\n```\\nconst memoizedSum = memoize(sum);\\n```\n```console.log(memoizedSum(1, 2)); // 3 (calculated)\\nconsole.log(memoizedSum(1, 2)); // 3 (cached)\\n```\n```const memoize = (fn) => {\\n    const cache = {};\\n    const memoizedFn = (...args) => {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        const result = fn(...args);\\n        cache[key] = result;\\n        return result;\\n    };\\n    return memoizedFn;\\n};\\n\\nconst sum = (a, b) => a + b;\\n\\nconst fib = (n) => {\\n    if (n <= 1) {\\n        return 1;\\n    }\\n    return fib(n - 1) + fib(n - 2);\\n};\\n\\nconst factorial = (n) => {\\n    if (n <= 1) {\\n        return 1;\\n    }\\n    return factorial(n - 1) * n;\\n};\\n\\nconst memoizedSum = memoize(sum);\\nconst memoizedFib = memoize(fib);\\nconst memoizedFactorial = memoize(factorial);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416076,
                "title": "javascript-hash-object-for-memoization",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep results of previous function calls in an object where a key is a unique string for a set of parameters. If we have these parameters we return value from hash otherwise call function and keep the result.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const hash = {};\\n\\n    return function(...args) {\\n        const key = args.join(\\',\\');\\n\\n        if (hash[key] === undefined) {\\n            hash[key] = fn(...args);\\n        }\\n\\n        return hash[key];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const hash = {};\\n\\n    return function(...args) {\\n        const key = args.join(\\',\\');\\n\\n        if (hash[key] === undefined) {\\n            hash[key] = fn(...args);\\n        }\\n\\n        return hash[key];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3415749,
                "title": "js-map-cache",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the args + function name as a unique cache key.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the unique cache key to cache in declared map.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map()\\n    return function(...args) {\\n        const key = fn.name + \"-\" + args.join(\"-\");\\n        if (cache.has(key)) {\\n            return cache.get(key);\\n        }\\n        const result = fn(...args);\\n        cache.set(key, result);\\n        return result;    \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map()\\n    return function(...args) {\\n        const key = fn.name + \"-\" + args.join(\"-\");\\n        if (cache.has(key)) {\\n            return cache.get(key);\\n        }\\n        const result = fn(...args);\\n        cache.set(key, result);\\n        return result;    \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408715,
                "title": "simple-and-explained-typescript-solution",
                "content": "# Intuition\\nWe need to apply cache concept to memorize the result.\\n\\n# Approach\\n- we want to store every new input and its result in a Map(cache).\\n- if the input is new, we will call the function and add the result in the map.\\n- if the same input come again we will return the old output.\\n\\n- NOTE: we store the input as a key in the map in format \"in1,in2,in3,..\" (String)\\n\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n\\n    let map = new Map();\\n    let ans = function(...params:any):any\\n    {\\n        let input:string = params.join(\",\").toString();\\n        if(map.get(input) == undefined)\\n        {\\n            map.set(input,fn(...params));\\n        }\\n        return map.get(input);\\n        \\n    }\\n\\n    \\n    return ans;\\n    \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\nPlease up vote \\u2B06\\uFE0F\\u2B06\\uFE0F if you find this solution useful, Thank you.",
                "solutionTags": [
                    "TypeScript",
                    "Memoization"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n\\n    let map = new Map();\\n    let ans = function(...params:any):any\\n    {\\n        let input:string = params.join(\",\").toString();\\n        if(map.get(input) == undefined)\\n        {\\n            map.set(input,fn(...params));\\n        }\\n        return map.get(input);\\n        \\n    }\\n\\n    \\n    return ans;\\n    \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100481,
                "title": "js-ts-record-method-to-cache",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: number[]) => number\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache: Record<string, any> = {};\\n    return (...args) => {\\n        let key = args.join(\"-\");\\n        return key in cache ? cache[key] : (cache[key] = fn(...args));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: number[]) => number\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache: Record<string, any> = {};\\n    return (...args) => {\\n        let key = args.join(\"-\");\\n        return key in cache ? cache[key] : (cache[key] = fn(...args));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097600,
                "title": "2623-memoize-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nfunction memoize(fn) {\\n    const memo = new Map();\\n\\n    return function(...args) {\\n        const key = args.join(\\'-\\');\\n        if (!memo.has(key)) memo.set(key, fn(...args));\\n        return memo.get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nfunction memoize(fn) {\\n    const memo = new Map();\\n\\n    return function(...args) {\\n        const key = args.join(\\'-\\');\\n        if (!memo.has(key)) memo.set(key, fn(...args));\\n        return memo.get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096219,
                "title": "easy-solution-explain",
                "content": "\\n# Solution Code \\n```\\nfunction memoize(fn) {\\n    \\n      let memo = {};\\n      return function (...args)\\n      {\\n            const jsonyArges = JSON.stringify(args)\\n            if (memo.hasOwnProperty(jsonyArges))\\n            {\\n                  return memo[jsonyArges]\\n            }\\n            else\\n            {\\n                  memo[jsonyArges] = fn(...args);\\n                  return memo[jsonyArges];\\n            }\\n\\n      }\\n}\\n\\n```\\n# what is json.stringify(args) ? \\n`JSON.stringify` is a built-in JavaScript function that converts a JavaScript value or object into a JSON string representation. JSON stands for \"JavaScript Object Notation,\" and it\\'s a widely used data interchange format for representing structured data.\\n\\nHere\\'s how you use `JSON.stringify`:\\n\\n```javascript\\nconst obj = { name: \"John\", age: 30, city: \"New York\" };\\n\\nconst jsonString = JSON.stringify(obj);\\n\\nconsole.log(jsonString);\\n// Output: {\"name\":\"John\",\"age\":30,\"city\":\"New York\"}\\n```\\n\\nIn this example, the `JSON.stringify` function takes the `obj` object and converts it into a JSON string, which can be easily transmitted over the network or saved to a file. JSON strings are commonly used for data exchange between a client and a server in web applications.\\n\\n`JSON.stringify` can also take an optional second argument called a \"replacer\" function or an array. This allows you to customize the serialization process by specifying which properties of an object should be included in the resulting JSON string.\\n\\nHere\\'s an example using a replacer function:\\n\\n```javascript\\nconst obj = { name: \"John\", age: 30, city: \"New York\" };\\n\\nconst jsonString = JSON.stringify(obj, (key, value) => {\\n  if (key === \"age\") {\\n    return undefined; // Exclude the \"age\" property from the JSON string\\n  }\\n  return value;\\n});\\n\\nconsole.log(jsonString);\\n// Output: {\"name\":\"John\",\"city\":\"New York\"}\\n```\\n\\nIn this example, we use a replacer function to exclude the \"age\" property from the resulting JSON string.\\n# what is \"hasOwnProperty(jsonyArges)\"?\\n`hasOwnProperty` is a built-in JavaScript method that is used to check if an object has a specific property. It is a method inherited by all objects in JavaScript from the `Object.prototype` object. \\n\\nHere\\'s how you typically use `hasOwnProperty`:\\n\\n```javascript\\nconst obj = {\\n  name: \"John\",\\n  age: 30,\\n};\\n\\nconsole.log(obj.hasOwnProperty(\"name\")); // true\\nconsole.log(obj.hasOwnProperty(\"age\"));  // true\\nconsole.log(obj.hasOwnProperty(\"city\")); // false\\n```\\n\\nIn this example, `hasOwnProperty` is used to check if the `obj` object has the properties \"name,\" \"age,\" and \"city.\" It returns `true` if the object has the specified property, and `false` otherwise.\\n\\nIt\\'s often used to avoid issues that can arise when you iterate over the properties of an object using a `for...in` loop. When iterating over an object, you may encounter properties inherited from its prototype chain (properties added to `Object.prototype`), and `hasOwnProperty` helps filter out these inherited properties.\\n\\nHere\\'s an example of using `hasOwnProperty` with a `for...in` loop:\\n\\n```javascript\\nconst obj = {\\n  name: \"John\",\\n  age: 30,\\n};\\n\\nfor (const prop in obj) {\\n  if (obj.hasOwnProperty(prop)) {\\n    console.log(`Property ${prop} has a value of ${obj[prop]}`);\\n  }\\n}\\n```\\n\\nIn this loop, `hasOwnProperty` is used to ensure that only the object\\'s own properties are processed, not properties inherited from the prototype chain. This can be important when you want to work with an object\\'s own properties in certain situations.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    \\n      let memo = {};\\n      return function (...args)\\n      {\\n            const jsonyArges = JSON.stringify(args)\\n            if (memo.hasOwnProperty(jsonyArges))\\n            {\\n                  return memo[jsonyArges]\\n            }\\n            else\\n            {\\n                  memo[jsonyArges] = fn(...args);\\n                  return memo[jsonyArges];\\n            }\\n\\n      }\\n}\\n\\n```\n```javascript\\nconst obj = { name: \"John\", age: 30, city: \"New York\" };\\n\\nconst jsonString = JSON.stringify(obj);\\n\\nconsole.log(jsonString);\\n// Output: {\"name\":\"John\",\"age\":30,\"city\":\"New York\"}\\n```\n```javascript\\nconst obj = { name: \"John\", age: 30, city: \"New York\" };\\n\\nconst jsonString = JSON.stringify(obj, (key, value) => {\\n  if (key === \"age\") {\\n    return undefined; // Exclude the \"age\" property from the JSON string\\n  }\\n  return value;\\n});\\n\\nconsole.log(jsonString);\\n// Output: {\"name\":\"John\",\"city\":\"New York\"}\\n```\n```javascript\\nconst obj = {\\n  name: \"John\",\\n  age: 30,\\n};\\n\\nconsole.log(obj.hasOwnProperty(\"name\")); // true\\nconsole.log(obj.hasOwnProperty(\"age\"));  // true\\nconsole.log(obj.hasOwnProperty(\"city\")); // false\\n```\n```javascript\\nconst obj = {\\n  name: \"John\",\\n  age: 30,\\n};\\n\\nfor (const prop in obj) {\\n  if (obj.hasOwnProperty(prop)) {\\n    console.log(`Property ${prop} has a value of ${obj[prop]}`);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091728,
                "title": "using-map",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let mp = new Map();\\n\\n    return function(...args) {\\n        let key = JSON.stringify(args)\\n        if(mp.get(key) !== undefined){\\n            return mp.get(key)\\n        }    \\n        else{\\n            let t = fn(...args)\\n            mp.set(key, t)\\n            return t;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let mp = new Map();\\n\\n    return function(...args) {\\n        let key = JSON.stringify(args)\\n        if(mp.get(key) !== undefined){\\n            return mp.get(key)\\n        }    \\n        else{\\n            let t = fn(...args)\\n            mp.set(key, t)\\n            return t;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090599,
                "title": "memoize-with-linear-time-complexity-using-js",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(n) - Linear$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    } else {\\n      const result = fn(...args);\\n      cache.set(key, result)\\n      return result;\\n    }\\n  };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    } else {\\n      const result = fn(...args);\\n      cache.set(key, result)\\n      return result;\\n    }\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088293,
                "title": "with-map-object-using-typescript",
                "content": "\\n# Approach\\nUse args as a key to search for cached result in Map object.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: number[]) => number\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache=new Map()\\n    \\n    return function(...args) {\\n        const key=JSON.stringify(args)\\n        if(cache.has(key)){\\n            return cache.get(key)\\n        }\\n\\n        const result = fn(...args);\\n\\n        cache.set(key,result)\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: number[]) => number\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache=new Map()\\n    \\n    return function(...args) {\\n        const key=JSON.stringify(args)\\n        if(cache.has(key)){\\n            return cache.get(key)\\n        }\\n\\n        const result = fn(...args);\\n\\n        cache.set(key,result)\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088221,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbest way to memoize is to use a object and save the keys as arguments and their output as values, and return those values,wehn same key is hit.\\nthe use of object.hasOwnProperty is used to check if the key is present, because dircrly calling for value, if the value is zero then, the condition will fail. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let obj={}\\n    return function(...args) {\\n        if(obj.hasOwnProperty(args)){\\n            return obj[args]\\n        }\\n        let k=fn(...args);\\n        obj[args]=k\\n        return k\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let obj={}\\n    return function(...args) {\\n        if(obj.hasOwnProperty(args)){\\n            return obj[args]\\n        }\\n        let k=fn(...args);\\n        obj[args]=k\\n        return k\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087555,
                "title": "memoize",
                "content": "# Intuition\\nThe first thought on how to solve this problem is to use a cache to store the results of previous calls to the function. This way, we can avoid recalculating the same results multiple times.\\n\\n# Approach\\nThe following is a possible approach to solving this problem:\\n\\n1. Create a cache object to store the results of previous calls to the function.\\n2. When the function is called, check the cache to see if the result for the given inputs has already been calculated. If so, return the cached result. Otherwise, calculate the result and store it in the cache before returning it.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the memoized function will depend on the time complexity of the original function. However, in general, memoization will improve the time complexity of the function by avoiding recalculating the same results multiple times.\\n\\n- Space complexity:\\nThe space complexity of the memoized function will depend on the size of the cache. The cache will need to store the results of all previous calls to the function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        cache[key] = fn(...args);\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key];\\n        }\\n        cache[key] = fn(...args);\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085023,
                "title": "caching-results",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};   \\n \\n    return function(...args) {\\n        const resultKey = JSON.stringify(args);\\n        if(resultKey in cache) return cache[resultKey]\\n        return cache[resultKey] = fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};   \\n \\n    return function(...args) {\\n        const resultKey = JSON.stringify(args);\\n        if(resultKey in cache) return cache[resultKey]\\n        return cache[resultKey] = fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076032,
                "title": "2623-memoize-soluation-with-js-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    // for storing unique key, value pair\\n    let m = new Map();\\n    return function (...args) {\\n        // Converting array of args to string for \\'key\\'\\n        let st = JSON.stringify(args);\\n        // Checking if given \"args/key\" is present in map or not?\\n        if (m.has(st)) {\\n            // If \"args/key\" is already present then simply return the value from that \"args/key\", without recalling the \"fn()\" function. (Caching mechanism) \\n            return m.get(st);\\n        }\\n        else{\\n            // If \"args/key\" is not present in map, then call the \"fn()\" function for calculating the ans and store the \"args/key\", value in map. and return the ans.\\n            let ans = fn(...args);\\n            m.set(st, ans);\\n            return ans;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    // for storing unique key, value pair\\n    let m = new Map();\\n    return function (...args) {\\n        // Converting array of args to string for \\'key\\'\\n        let st = JSON.stringify(args);\\n        // Checking if given \"args/key\" is present in map or not?\\n        if (m.has(st)) {\\n            // If \"args/key\" is already present then simply return the value from that \"args/key\", without recalling the \"fn()\" function. (Caching mechanism) \\n            return m.get(st);\\n        }\\n        else{\\n            // If \"args/key\" is not present in map, then call the \"fn()\" function for calculating the ans and store the \"args/key\", value in map. and return the ans.\\n            let ans = fn(...args);\\n            m.set(st, ans);\\n            return ans;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074235,
                "title": "most-optimize-solution-for-memoize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const memoMap = new Map();\\n  return function (...args) {\\n    const argString = args.toString();\\n    if (memoMap.has(argString)) {\\n      return memoMap.get(argString);\\n    } else {\\n      const result = fn(...args);\\n      memoMap.set(argString, result);\\n      return result;\\n    }\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const memoMap = new Map();\\n  return function (...args) {\\n    const argString = args.toString();\\n    if (memoMap.has(argString)) {\\n      return memoMap.get(argString);\\n    } else {\\n      const result = fn(...args);\\n      memoMap.set(argString, result);\\n      return result;\\n    }\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072355,
                "title": "fast-one-with-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: number[]) => number\\n\\nconst memoize = (fn: Fn): Fn => {\\n    const map = new Map();\\n    \\n    return (...args) => {\\n        const key = args.toString();\\n\\n        if (!map.has(key)) {\\n            map.set(key, fn(...args));\\n        }\\n\\n        return map.get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: number[]) => number\\n\\nconst memoize = (fn: Fn): Fn => {\\n    const map = new Map();\\n    \\n    return (...args) => {\\n        const key = args.toString();\\n\\n        if (!map.has(key)) {\\n            map.set(key, fn(...args));\\n        }\\n\\n        return map.get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066411,
                "title": "memoize-solution-amazing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nlong story\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nfunction memoize(fn) {\\n    let checker= {};\\n    return function(...args) {\\n        let nums= args.join(\\',\\');\\n        if(nums in checker){\\n            return checker[nums] ;\\n        }else{\\n            callCount +=1;\\n            checker[nums]= fn(...args)\\n            return checker[nums] ;\\n        }\\n    }\\n}\\nlet callCount  ;\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nfunction memoize(fn) {\\n    let checker= {};\\n    return function(...args) {\\n        let nums= args.join(\\',\\');\\n        if(nums in checker){\\n            return checker[nums] ;\\n        }else{\\n            callCount +=1;\\n            checker[nums]= fn(...args)\\n            return checker[nums] ;\\n        }\\n    }\\n}\\nlet callCount  ;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065875,
                "title": "my-solution-to-memoize-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be a bit confusing. I misread and thought that multiple different functions could be called, and thus, built it in a way that it generates a unique value using the function name and its parameters, and uses it as a key to later on keep the value if it didn\\'t exist before.\\n\\nWhat it ***really*** asks you to do is that you build a function that **stores** the **parameters sent and its resulting value** and **check if these were sent before**. If so, **return its cached value; otherwise execute the function sent and return** whatever the function returns.\\n\\nSo the key here (no pun intended) is to implement something that works as a `<Key, value>` pair, being `Key` the parameters and `Value` the result from the sent function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI started creating `let dictionary = []` inside `memoize(fn)` but outside the anonymous function; it worked as a dictionary adding objects with the function name, parameters and the cached value.\\n***However, I didn\\'t know that [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) exists (not the array one; the other one), let alone that it worked as a [Dictionary](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-7.0).*** \\nSo I created the following object: \\n`let memoized = { function: fn.name, parameters: JSON.stringify(arguments) }`\\n\\nFew things to note here: \\n\\n- ***fn.name***: `fn` is a variable that contains a `function`. In js, all functions have a [`name` property](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) that contains the name of the function\\n- ***arguments***: [`arguments`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments) is an object that contains all incoming parameters inside a function. You can use [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`...args`) instead\\n- ***[JSON.stringify()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)***: returns the string equivalent of the value passed. In this case, all parameters are converted into a single string. Why did I do this? Because it\\'s easier to use a unique string to compare instead of an object for this scenario; otherwise I\\'d have to compare each parameter from the dictionary against the current parameter.\\n\\nThen I used the `Array.find()` method to find the object inside the `dictionary` array that has the same function name and parameters, and if it such an object exists, I return its cached value. Otherwise, I add the new object to `dictionary`.\\n\\nUnfortunately, this approach failed during the last test because it was slow. So I googled how to implement a dictionary in js, and stumble upon Map(). After reading its documentation (thanks, Mozilla), I found out that I could make it simpler, so I started to refactor my code, and ended as you see it now:\\n\\nI create `dictionary` as a new `Map()` object outside the anonymous function but inside `memoize(fn)`. \\nThen, since I can use a direct key here, I decided to use both the function name (though it\\'s not required because of what I mentioned in the beginning) and the stringified parameters to join them into a single unique string as follows:\\n``const key = `function: ${fn.name}, parameters: ${JSON.stringify(arguments)}`;``\\n\\nAfter that, I use the `key` variable to check if the `dictionary` **does not** contain said `key` (using the `Map.has(key)`). If true, I execute the fn and add a new `<Key, Value>` pair (by using the `Map.set(key, value)` method) using the variable `key` as the `Key`, and the return from `fn`\\'s execution its `Value`. If false, I do nothing.\\nThen I return the `value` from said `key` variable.\\nThis way, I can pass all the tests, only need a single return and the code is pretty clear.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(f(n))**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    let dictionary = new Map();\\n    return function(...args) {\\n        const key = `function: ${fn.name}, parameters: ${JSON.stringify(arguments)}`;\\n        if(!dictionary.has(key)){\\n            dictionary.set(key, fn(...args));\\n        }\\n        return dictionary.get(key);        \\n    }\\n}\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    let dictionary = new Map();\\n    return function(...args) {\\n        const key = `function: ${fn.name}, parameters: ${JSON.stringify(arguments)}`;\\n        if(!dictionary.has(key)){\\n            dictionary.set(key, fn(...args));\\n        }\\n        return dictionary.get(key);        \\n    }\\n}\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057240,
                "title": "very-simple-hash-technique-for-memoiazation",
                "content": "# Intuition\\nStore the result in the hash and have a counter that keeps track of the number of calls\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    var callCount = 0;\\n    var result = {};\\n    var arg=[];\\n    return function(...args) {\\n        if(args.length==0) return callCount\\n        let s = args.toString()\\n        if(Object.hasOwn(result,s)){\\n            return result[s]\\n        }else{\\n            callCount++\\n            result[s] = fn(...args)\\n            arg= args\\n            console.log(args.toString())\\n            return result[s]\\n        }1\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    var callCount = 0;\\n    var result = {};\\n    var arg=[];\\n    return function(...args) {\\n        if(args.length==0) return callCount\\n        let s = args.toString()\\n        if(Object.hasOwn(result,s)){\\n            return result[s]\\n        }else{\\n            callCount++\\n            result[s] = fn(...args)\\n            arg= args\\n            console.log(args.toString())\\n            return result[s]\\n        }1\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057128,
                "title": "best-memory-saver-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache ={}\\n    return function(...args) {\\n        if(cache?.[args.toString()] ||cache?.[args.toString()]===0 ){\\n            return cache[args.toString()]\\n        }else{\\n            let item = fn(...args)\\n            cache[args.toString()] = item\\n            return item\\n        }\\n    }\\n}\\n\\n\\n// /** \\n//  * let callCount = 0;\\n//  * const memoizedFn = memoize(function (a, b) {\\n//  *\\t callCount += 1;\\n//  *   return a + b;\\n//  * })\\n//  * memoizedFn(0,0) // 5\\n//  * memoizedFn(0,0) // 5\\n//  * console.log(callCount) // 1 \\n//  */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache ={}\\n    return function(...args) {\\n        if(cache?.[args.toString()] ||cache?.[args.toString()]===0 ){\\n            return cache[args.toString()]\\n        }else{\\n            let item = fn(...args)\\n            cache[args.toString()] = item\\n            return item\\n        }\\n    }\\n}\\n\\n\\n// /** \\n//  * let callCount = 0;\\n//  * const memoizedFn = memoize(function (a, b) {\\n//  *\\t callCount += 1;\\n//  *   return a + b;\\n//  * })\\n//  * memoizedFn(0,0) // 5\\n//  * memoizedFn(0,0) // 5\\n//  * console.log(callCount) // 1 \\n//  */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056976,
                "title": "memoize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is heavily inspired by [@muneebshoukat60\\'s](https://leetcode.com/problems/memoize/solutions/3860150/3-lines-beats-9932-best-solution-with-minimal-code/) solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare a map object \\n2. Use stringify to stringify arguments\\n3. Use condition, if has(keys) in cache returns True, then return the cached solution\\n4. Else push the new solution whit ```key: key``` and ```Value: fn(...args)```\\n5. Lastly return the key \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return function(...args) {\\n      const key = JSON.stringify(args);\\n      if(cache.has(key)){\\n        return cache.get(key)\\n          }  else {\\n            cache.set(key,fn(...args))\\n            return cache.get(key)\\n          }\\n      }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```key: key```\n```Value: fn(...args)```\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return function(...args) {\\n      const key = JSON.stringify(args);\\n      if(cache.has(key)){\\n        return cache.get(key)\\n          }  else {\\n            cache.set(key,fn(...args))\\n            return cache.get(key)\\n          }\\n      }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054224,
                "title": "memoize-with-hashmap",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    \\n    return function(...args) {\\n        if(cache.has(`${args}`))\\n            return cache.get(`${args}`);\\n        else {\\n            const result = fn.apply(1, args);\\n            cache.set(`${args}`, result);\\n            return result;\\n        }  \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    \\n    return function(...args) {\\n        if(cache.has(`${args}`))\\n            return cache.get(`${args}`);\\n        else {\\n            const result = fn.apply(1, args);\\n            cache.set(`${args}`, result);\\n            return result;\\n        }  \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052747,
                "title": "memoize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  var memo = {};\\n    return function(...args) {       \\n        var key = args.toString()\\n        if(memo[key]!==undefined) return memo[key];\\n        return memo[key]=fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  var memo = {};\\n    return function(...args) {       \\n        var key = args.toString()\\n        if(memo[key]!==undefined) return memo[key];\\n        return memo[key]=fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031589,
                "title": "ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    // defualt memo\\n    let memo = {};\\n    let check_unique = {};\\n\\n    return function(...args) {\\n\\n        if(args.length === 2) {\\n            // save key unique\\n            let unique = args[0].toString() + args[1].toString();\\n            if(check_unique[unique] === args[1])  return memo[unique];\\n            check_unique[unique] = args[1];\\n            return memo[unique] = fn(...args);\\n        }\\n\\n        if(memo[args]) return memo[args];\\n    \\n        memo[args] = fn(...args);\\n        return memo[args];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    // defualt memo\\n    let memo = {};\\n    let check_unique = {};\\n\\n    return function(...args) {\\n\\n        if(args.length === 2) {\\n            // save key unique\\n            let unique = args[0].toString() + args[1].toString();\\n            if(check_unique[unique] === args[1])  return memo[unique];\\n            check_unique[unique] = args[1];\\n            return memo[unique] = fn(...args);\\n        }\\n\\n        if(memo[args]) return memo[args];\\n    \\n        memo[args] = fn(...args);\\n        return memo[args];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029817,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(!(key in cache)) {\\n            cache[key] = fn(...args);\\n        }\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(!(key in cache)) {\\n            cache[key] = fn(...args);\\n        }\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027240,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in cache){\\n        return cache[key]\\n        }\\nconst result = fn.apply(this,args)\\ncache[key] = result;\\nreturn result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in cache){\\n        return cache[key]\\n        }\\nconst result = fn.apply(this,args)\\ncache[key] = result;\\nreturn result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023941,
                "title": "simple-solution-97-45-clean",
                "content": "This is a bit lazy approach. Using arguments as a key in the map which is used as cache to store results. Why lazy: I didn\\'t bother with the cache key generation and just used a string version of arguments.\\n\\nP.S. I don\\'t agree that in this assignment sum(2,1) and sum(1,2) must be two different calls.\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    let cache = new Map()\\n\\n    return function(...args) {\\n        let key = args.join(\"+\")\\n        let ret = cache.has(key) \\n            ? cache.get(key)\\n            : fn(...args)\\n        cache.set(key, ret)\\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    let cache = new Map()\\n\\n    return function(...args) {\\n        let key = args.join(\"+\")\\n        let ret = cache.has(key) \\n            ? cache.get(key)\\n            : fn(...args)\\n        cache.set(key, ret)\\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019636,
                "title": "memoize-in-js",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function(...args) {\\n        let keys = JSON.stringify(args);\\n        if (cache.hasOwnProperty(keys)) {\\n            return cache[keys];\\n        } else {\\n            cache[keys] = fn.apply(this, args);\\n            return cache[keys];\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function(...args) {\\n        let keys = JSON.stringify(args);\\n        if (cache.hasOwnProperty(keys)) {\\n            return cache[keys];\\n        } else {\\n            cache[keys] = fn.apply(this, args);\\n            return cache[keys];\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018485,
                "title": "solution-with-detailed-explanation",
                "content": "# Intuition\\nThe tricky and key part of this problem is that we should assume the arguments that will be passed to the function `fn` will be of `unique pattern` that either matches with `sum`, `fib`, or `factorial`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an `object/hashmap` to store the value returned by the function. \\n2.  If the `args` is found in the `object/hashmap`, then return the stored value i.e. `memo[args]`.\\n3. If not, add args as the key in the `object/hashmap` and then store the value returned by the `fn(...args)` and return the `memo[args]`\\n4. **Note**: We dont need to `stringify` the args with `JSON.stringify`, `template string` etc., since ` memo[args]` stringifies automatically.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\n\\nfunction memoize(fn) {\\n    const memo  = {}\\n    return function(...args) {\\n        if(args in memo) return memo[args]\\n\\n        memo[args] = fn(...args)\\n\\n        return memo[args]\\n\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\n\\nfunction memoize(fn) {\\n    const memo  = {}\\n    return function(...args) {\\n        if(args in memo) return memo[args]\\n\\n        memo[args] = fn(...args)\\n\\n        return memo[args]\\n\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015517,
                "title": "memoized-function-with-ukrainian-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u0414\\u043B\\u044F \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F \\u0446\\u0456\\u0454\\u0457 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0456 \\u043F\\u043E\\u0442\\u0440\\u0456\\u0431\\u043D\\u043E \\u0437\\u0431\\u0435\\u0440\\u0456\\u0433\\u0430\\u0442\\u0438 \\u043F\\u0430\\u0440\\u0438 \\u043A\\u043B\\u044E\\u0447-\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F, \\u0434\\u0435 \\u043A\\u043B\\u044E\\u0447 - \\u0446\\u0435 \\u043C\\u0430\\u0441\\u0438\\u0432 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0438\\u0445 \\u0434\\u0430\\u043D\\u0438\\u0445, \\u0430 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F - \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0457 \\u0434\\u043B\\u044F \\u0446\\u0438\\u0445 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0438\\u0445 \\u0434\\u0430\\u043D\\u0438\\u0445. \\u0414\\u043B\\u044F \\u0437\\u0431\\u0435\\u0440\\u0456\\u0433\\u0430\\u043D\\u043D\\u044F \\u0442\\u0430\\u043A\\u0438\\u0445 \\u043F\\u0430\\u0440 \\u044F \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u044E Map, \\u043E\\u0441\\u043A\\u0456\\u043B\\u044C\\u043A\\u0438 \\u0443 \\u0437\\u0432\\u0438\\u0447\\u0430\\u0439\\u043D\\u043E\\u043C\\u0443 \\u043E\\u0431\\'\\u0454\\u043A\\u0442\\u0456 \\u043A\\u043B\\u044E\\u0447\\u0430\\u043C\\u0438 \\u043C\\u043E\\u0436\\u0443\\u0442\\u044C \\u0431\\u0443\\u0442\\u0438 \\u043B\\u0438\\u0448\\u0435 \\u0440\\u044F\\u0434\\u043A\\u0438, \\u0442\\u043E\\u0434\\u0456 \\u044F\\u043A \\u0443 Map \\u043D\\u0435\\u043C\\u0430\\u0454 \\u0442\\u0430\\u043A\\u0438\\u0445 \\u043E\\u0431\\u043C\\u0435\\u0436\\u0435\\u043D\\u044C.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. \\u0421\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044E `memoize`, \\u044F\\u043A\\u0430 \\u043F\\u0440\\u0438\\u0439\\u043C\\u0430\\u0454 \\u0456\\u043D\\u0448\\u0443 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044E \\u0432 \\u044F\\u043A\\u043E\\u0441\\u0442\\u0456 \\u0430\\u0440\\u0433\\u0443\\u043C\\u0435\\u043D\\u0442\\u0443.\\n2. \\u0421\\u0442\\u0432\\u043E\\u0440\\u0438\\u043C \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `cache`, \\u044F\\u043A\\u0430  \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u0434\\u043B\\u044F \\u0437\\u0431\\u0435\\u0440\\u0456\\u0433\\u0430\\u043D\\u043D\\u044F \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u0456\\u0432 \\u0432\\u0438\\u043A\\u043B\\u0438\\u043A\\u0456\\u0432 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0439, \\u0434\\u0435 `\\u043A\\u043B\\u044E\\u0447` - \\u0446\\u0435 \\u043C\\u0430\\u0441\\u0438\\u0432 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0438\\u0445 \\u0434\\u0430\\u043D\\u0438\\u0445, \\u0430 `\\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F` - \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0457.\\n3. \\u041F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u044E \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044E, \\u044F\\u043A\\u0430 \\u043F\\u0440\\u0438\\u0439\\u043C\\u0430\\u0454 \\u0431\\u0435\\u0437\\u043B\\u0456\\u0447 \\u0430\\u0440\\u0433\\u0443\\u043C\\u0435\\u043D\\u0442\\u0456\\u0432 \\u0437\\u0430 \\u0434\\u043E\\u043F\\u043E\\u043C\\u043E\\u0433\\u043E\\u044E spread \\u043E\\u043F\\u0435\\u0440\\u0430\\u0442\\u043E\\u0440\\u0430(...args).\\n4. \\u0423 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0457 \\u0441\\u043F\\u043E\\u0447\\u0430\\u0442\\u043A\\u0443 \\u043F\\u0435\\u0440\\u0435\\u0432\\u0456\\u0440\\u044F\\u044E, \\u0447\\u0438 \\u0454 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0432 \\u043A\\u0435\\u0448\\u0456.\\n5. \\u042F\\u043A\\u0449\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0454 \\u0432 \\u043A\\u0435\\u0448\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u044E \\u0439\\u043E\\u0433\\u043E.\\n6. \\u042F\\u043A\\u0449\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0432\\u0456\\u0434\\u0441\\u0443\\u0442\\u043D\\u0454 \\u0432 \\u043A\\u0435\\u0448\\u0456, \\u0432\\u0438\\u043A\\u043B\\u0438\\u043A\\u0430\\u044E \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044E \\u0456 \\u0437\\u0431\\u0435\\u0440\\u0456\\u0433\\u0430\\u044E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u0443 \\u043A\\u0435\\u0448\\u0456, \\u0430 \\u043F\\u043E\\u0442\\u0456\\u043C \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u044E \\u0446\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F.\\n\\n# Complexity\\n- Time complexity: \\u0424\\u0443\\u043D\\u043A\\u0446\\u0456\\u044F `memoize` \\u0437\\u0430\\u043B\\u0435\\u0436\\u0438\\u0442\\u044C \\u0432\\u0456\\u0434 \\u043E\\u0440\\u0438\\u0433\\u0456\\u043D\\u0430\\u043B\\u044C\\u043D\\u043E\\u0457 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u0457, \\u044F\\u043A\\u0430 \\u0437\\u0430\\u043F\\u0430\\u043C\\'\\u044F\\u0442\\u043E\\u0432\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F, \\u0456 \\u043C\\u043E\\u0436\\u0435 \\u0432\\u0430\\u0440\\u0456\\u044E\\u0432\\u0430\\u0442\\u0438\\u0441\\u044F \\u0432\\u0456\\u0434 O(1) \\u0434\\u043E O(n) \\u0434\\u043E O(2^n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), \\u0434\\u0435 n \\u2013 \\u043A\\u0456\\u043B\\u044C\\u043A\\u0456\\u0441\\u0442\\u044C \\u0443\\u043D\\u0456\\u043A\\u0430\\u043B\\u044C\\u043D\\u0438\\u0445 \\u0432\\u0445\\u043E\\u0434\\u0456\\u0432 \\u0443 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0456\\u044E.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n  const cache = new Map();\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args)\\n    if (cache.has(key)) {\\n      return cache.get(key)\\n    } \\n    const value = fn(...args);\\n    cache.set(key, value);\\n    return value;\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n  const cache = new Map();\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args)\\n    if (cache.has(key)) {\\n      return cache.get(key)\\n    } \\n    const value = fn(...args);\\n    cache.set(key, value);\\n    return value;\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008576,
                "title": "runtime-beats-96-30-of-users-with-javascript",
                "content": "# Approach\\nIf the key doesn\\'t exist in cache, set the value in cache. Then, return the value from cache. \\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(!(key in cache)){\\n            cache[key] = fn.apply(this, args);\\n        }\\n        return cache[key];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(!(key in cache)){\\n            cache[key] = fn.apply(this, args);\\n        }\\n        return cache[key];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005878,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003741,
                "title": "simple-and-clean",
                "content": "compact: >>\\n# Code\\n```\\ntype Fn = (...params: any) => any;\\n\\nfunction memoize(fn: Fn): Fn {\\n  const mem: Record<string, any> = {};\\n  return (...args) => {\\n    const key = args.join(\"-\");\\n    return key in mem ? mem[key] : (mem[key] = fn(...args));\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any;\\n\\nfunction memoize(fn: Fn): Fn {\\n  const mem: Record<string, any> = {};\\n  return (...args) => {\\n    const key = args.join(\"-\");\\n    return key in mem ? mem[key] : (mem[key] = fn(...args));\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002706,
                "title": "simple-js-solution-using-map-object",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  var cache=new Map();\\n    return function(...args) {\\n      var str=args.toString();\\n        if(cache.has(str))\\n        {\\n          return cache.get(str)\\n        }\\n        else\\n        {\\n          res=fn(...args);\\n          cache.set(str,res);\\n          return res;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  var cache=new Map();\\n    return function(...args) {\\n      var str=args.toString();\\n        if(cache.has(str))\\n        {\\n          return cache.get(str)\\n        }\\n        else\\n        {\\n          res=fn(...args);\\n          cache.set(str,res);\\n          return res;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992620,
                "title": "beats-88-in-typescript-runtime",
                "content": "# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const paramMap: Map<string, any> = new Map();\\n\\n    return function(...args) {\\n\\n        const params: string = JSON.stringify([...args])\\n\\n        if (!paramMap.has(params)) {\\n            const res = fn(...JSON.parse(params));\\n            paramMap.set(params, res);\\n            return res;\\n        } else {\\n            return paramMap.get(params);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const paramMap: Map<string, any> = new Map();\\n\\n    return function(...args) {\\n\\n        const params: string = JSON.stringify([...args])\\n\\n        if (!paramMap.has(params)) {\\n            const res = fn(...JSON.parse(params));\\n            paramMap.set(params, res);\\n            return res;\\n        } else {\\n            return paramMap.get(params);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985652,
                "title": "a-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n\\n  return function (...args) {\\n    const cacheKey = JSON.stringify(args);\\n\\n    if (cache.has(cacheKey)) {\\n      return cache.get(cacheKey);\\n    }\\n\\n    const result = fn(...args);\\n    cache.set(cacheKey, result);\\n    return result;\\n  };\\n}\\n\\nfunction sum(a, b) {\\n  return a + b;\\n}\\n\\nfunction fib(n) {\\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\\n}\\n\\nfunction factorial(n) {\\n  return n <= 1 ? 1 : n * factorial(n - 1);\\n}\\n\\nconst operations = {\\n  sum,\\n  fib,\\n  factorial\\n};\\n\\nfunction performOperations(opName, actions, values) {\\n  const memoizedOp = memoize(operations[opName]);\\n  const results = [];\\n  const callCounts = new Map();\\n\\n  for (let i = 0; i < actions.length; i++) {\\n    const action = actions[i];\\n    const value = values[i];\\n\\n    if (action === \"call\") {\\n      const result = memoizedOp(...value);\\n      results.push(result);\\n      const cacheKey = JSON.stringify(value);\\n      if (!callCounts.has(cacheKey)) {\\n        callCounts.set(cacheKey, 0);\\n      }\\n      callCounts.set(cacheKey, callCounts.get(cacheKey) + 1);\\n    } else if (action === \"getCallCount\") {\\n      const cacheKey = JSON.stringify(value);\\n      if (callCounts.has(cacheKey)) {\\n        results.push(callCounts.get(cacheKey));\\n      } else {\\n        results.push(0);\\n      }\\n    }\\n  }\\n\\n  return results;\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n\\n  return function (...args) {\\n    const cacheKey = JSON.stringify(args);\\n\\n    if (cache.has(cacheKey)) {\\n      return cache.get(cacheKey);\\n    }\\n\\n    const result = fn(...args);\\n    cache.set(cacheKey, result);\\n    return result;\\n  };\\n}\\n\\nfunction sum(a, b) {\\n  return a + b;\\n}\\n\\nfunction fib(n) {\\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\\n}\\n\\nfunction factorial(n) {\\n  return n <= 1 ? 1 : n * factorial(n - 1);\\n}\\n\\nconst operations = {\\n  sum,\\n  fib,\\n  factorial\\n};\\n\\nfunction performOperations(opName, actions, values) {\\n  const memoizedOp = memoize(operations[opName]);\\n  const results = [];\\n  const callCounts = new Map();\\n\\n  for (let i = 0; i < actions.length; i++) {\\n    const action = actions[i];\\n    const value = values[i];\\n\\n    if (action === \"call\") {\\n      const result = memoizedOp(...value);\\n      results.push(result);\\n      const cacheKey = JSON.stringify(value);\\n      if (!callCounts.has(cacheKey)) {\\n        callCounts.set(cacheKey, 0);\\n      }\\n      callCounts.set(cacheKey, callCounts.get(cacheKey) + 1);\\n    } else if (action === \"getCallCount\") {\\n      const cacheKey = JSON.stringify(value);\\n      if (callCounts.has(cacheKey)) {\\n        results.push(callCounts.get(cacheKey));\\n      } else {\\n        results.push(0);\\n      }\\n    }\\n  }\\n\\n  return results;\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980964,
                "title": "another-approach-using-array-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = {};\\n\\n  return function(...args) {\\n    const k = args.join(\"-\");\\n    if (cache.hasOwnProperty(k)) {\\n      return cache[k];\\n    }\\n    \\n    return cache[k] = fn(...args);\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = {};\\n\\n  return function(...args) {\\n    const k = args.join(\"-\");\\n    if (cache.hasOwnProperty(k)) {\\n      return cache[k];\\n    }\\n    \\n    return cache[k] = fn(...args);\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972843,
                "title": "my-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const fMap = new Map() \\n    return function(...args) {\\n        let result\\n        const keyArgs = args.toString() \\n        if(fMap.has(fn)) {\\n            const fnMap = fMap.get(fn)\\n            if (fnMap.has(keyArgs)) {\\n                result = fnMap.get(keyArgs)\\n            } else {\\n                result = fn(...args)\\n                fnMap.set(keyArgs, result)\\n            }\\n        } else {\\n            result = fn(...args)\\n            const fnMap = new Map()\\n            fnMap.set(keyArgs, result)\\n            fMap.set(fn, fnMap)\\n        }\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const fMap = new Map() \\n    return function(...args) {\\n        let result\\n        const keyArgs = args.toString() \\n        if(fMap.has(fn)) {\\n            const fnMap = fMap.get(fn)\\n            if (fnMap.has(keyArgs)) {\\n                result = fnMap.get(keyArgs)\\n            } else {\\n                result = fn(...args)\\n                fnMap.set(keyArgs, result)\\n            }\\n        } else {\\n            result = fn(...args)\\n            const fnMap = new Map()\\n            fnMap.set(keyArgs, result)\\n            fMap.set(fn, fnMap)\\n        }\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966764,
                "title": "2-very-simple-solutions",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n//key as a number\\nfunction memoize(fn) {\\n  const cache = {};\\n  return function(...args){\\n    let key = args[0];\\n    if(args[1]){\\n      key += args[1] * 100001;\\n    }\\n    if(key in cache){\\n      return cache[key];\\n    }\\n    const res = fn(...args);\\n    cache[key] = res;\\n    return res\\n  }\\n}\\n```\\n```\\n//key as a string\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(key in cache){\\n          return cache[key];\\n        }\\n        const res = fn(...args);\\n        cache[key] = res;\\n        return res;\\n    }\\n\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n//key as a number\\nfunction memoize(fn) {\\n  const cache = {};\\n  return function(...args){\\n    let key = args[0];\\n    if(args[1]){\\n      key += args[1] * 100001;\\n    }\\n    if(key in cache){\\n      return cache[key];\\n    }\\n    const res = fn(...args);\\n    cache[key] = res;\\n    return res\\n  }\\n}\\n```\n```\\n//key as a string\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(key in cache){\\n          return cache[key];\\n        }\\n        const res = fn(...args);\\n        cache[key] = res;\\n        return res;\\n    }\\n\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965288,
                "title": "memoize-function",
                "content": "# Intuition\\n1. Use the cache concepts here to store the every resposne in cache object and use arguments as a key in string format to store unique result.\\n2. Check the arguments and based on that decide to get result from cache or call function to compute new result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n\\n    return function(...args) {\\n        let key = JSON.stringify(args);\\n        if(key in cache){\\n            return cache[key];\\n        }\\n\\n        let response = fn(...args);\\n        cache[key] = response;\\n        return response; \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n\\n    return function(...args) {\\n        let key = JSON.stringify(args);\\n        if(key in cache){\\n            return cache[key];\\n        }\\n\\n        let response = fn(...args);\\n        cache[key] = response;\\n        return response; \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960313,
                "title": "solution-using-maps-and-json-stringify",
                "content": "# Intuition\\nI first thought of using a map to check if the function had already been run with the same arguments.\\n\\n# Approach\\nMy first intuition was to simply check if the `Map`contained the arguments and if so, return the corresponding result, else cache the data by assigning `args` as the key and the result as the value, and then return the result. \\n\\nAfter realizing that Map was using the `sameValueZero` algorithm to compare keys, meaning that the `args` array would always be a different object to the eyes of the `Map` (unless calling with the same reference each time which is very unpractical and would be the point of the function in the first place; `sameValueZero` compares by reference and not value), I had to resort to using `JSON.strigify` to store the arguments in the Map.\\n\\nThis method has the downfall of not working on types that are JSON serializable. One might think that `.toString` could be used as a better method but that wouldn\\'t work either if the argument didn\\'t implement the method. Hence `JSON.stringify` is a pretty generic solution that will work on most types, although not giving great performance if the arguments contain large amounts of data.\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const map = new Map()\\n\\n    return function(...args) {\\n        let strRep = JSON.stringify(args)\\n\\n        if(map.has(strRep)) {\\n            return map.get(strRep)\\n        }\\n\\n        const result = fn(...args)\\n        map.set(strRep, result)\\n\\n        return result\\n    }\\n}\\n```\\n\\nHope you enjoyed reading this little write-up! Keep on coding!",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const map = new Map()\\n\\n    return function(...args) {\\n        let strRep = JSON.stringify(args)\\n\\n        if(map.has(strRep)) {\\n            return map.get(strRep)\\n        }\\n\\n        const result = fn(...args)\\n        map.set(strRep, result)\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959125,
                "title": "js-used-cache-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n\\n    return function(...args) {\\n        const key=JSON.stringify(args)\\n        if(key in cache){\\n            return cache[key]\\n        }\\n\\n        const result = fn.apply(this,args)\\n        cache[key]=result\\n\\n        return result\\n    }   \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n\\n    return function(...args) {\\n        const key=JSON.stringify(args)\\n        if(key in cache){\\n            return cache[key]\\n        }\\n\\n        const result = fn.apply(this,args)\\n        cache[key]=result\\n\\n        return result\\n    }   \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955373,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let memo = new Map()\\n   \\n    return function(...args) {\\n        const key = Array.from(args).join(\"_\")\\n        if(memo.has(key)) return memo.get(key)\\n   \\n        memo.set(key, fn(...args))\\n        return memo.get(key)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let memo = new Map()\\n   \\n    return function(...args) {\\n        const key = Array.from(args).join(\"_\")\\n        if(memo.has(key)) return memo.get(key)\\n   \\n        memo.set(key, fn(...args))\\n        return memo.get(key)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947555,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key]\\n        }\\n        cache[key] = fn(...args)\\n        return cache[key]\\n    }\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (key in cache) {\\n            return cache[key]\\n        }\\n        cache[key] = fn(...args)\\n        return cache[key]\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3946666,
                "title": "using-key-value-pairs",
                "content": "# Approach\\nStringify arguments and use them as object keys to access their result.\\n\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    let argMem = {}\\n    return function (...args) {\\n        if (argMem[args.toString()] !== undefined) return argMem[args.toString()]\\n        const res = fn(...args)\\n        argMem[args.toString()] = res\\n        return res\\n    }\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nStringify arguments and use them as object keys to access their result.\\n\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    let argMem = {}\\n    return function (...args) {\\n        if (argMem[args.toString()] !== undefined) return argMem[args.toString()]\\n        const res = fn(...args)\\n        argMem[args.toString()] = res\\n        return res\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3941206,
                "title": "javascript-solution-2623-memoize",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function (...args) {\\n        let key = args.join(\\'.\\')\\n        console.log(cache[key])\\n        if (cache[key] || cache[key] === 0) {\\n            return cache[key]\\n        }\\n        else {\\n            return cache[key] = fn(...args)\\n        }\\n\\n        // return fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function (...args) {\\n        let key = args.join(\\'.\\')\\n        console.log(cache[key])\\n        if (cache[key] || cache[key] === 0) {\\n            return cache[key]\\n        }\\n        else {\\n            return cache[key] = fn(...args)\\n        }\\n\\n        // return fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940129,
                "title": "simple-2-sum-variant-soltuion",
                "content": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    // maybe we should save the input and return value into a hashmap\\n    let myMap = new Map();\\n    \\n    return function(...args){\\n        const str = JSON.stringify(args);\\n        if (myMap.has(str)){\\n           return myMap.get(str);\\n       }\\n        // console.log(fn(args));\\n        myMap.set(str, fn(...args));\\n        return myMap.get(str);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    // maybe we should save the input and return value into a hashmap\\n    let myMap = new Map();\\n    \\n    return function(...args){\\n        const str = JSON.stringify(args);\\n        if (myMap.has(str)){\\n           return myMap.get(str);\\n       }\\n        // console.log(fn(args));\\n        myMap.set(str, fn(...args));\\n        return myMap.get(str);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938355,
                "title": "one-liner-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = (fn, cache = {}) => (...args) => cache[args.join()] ?? (cache[args.join()] = fn.apply(null, args))\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = (fn, cache = {}) => (...args) => cache[args.join()] ?? (cache[args.join()] = fn.apply(null, args))\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935688,
                "title": "memoization",
                "content": "\\n# Approach\\nMemoization is an optimization technique used in computer programming to improve the performance of functions by caching their results. The idea behind memoization is to store the results of expensive function calls and return the cached result when the same inputs occur again. This can greatly reduce the time complexity of algorithms that involve repeated function calls with the same inputs.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map(); \\n    return function(...args) {\\n        const key = args[0] + (args[1] ? args[1] * 10001 : 0)\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    return result;\\n        \\n    }\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map(); \\n    return function(...args) {\\n        const key = args[0] + (args[1] ? args[1] * 10001 : 0)\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    return result;\\n        \\n    }\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927047,
                "title": "simple-solution-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nconst contains = (cache, arr) => {\\n    return cache[arr.toString()] !== undefined\\n}\\n\\nfunction memoize(fn) {\\n    const cache = {}\\n\\n    return function (...args) {\\n        if (contains(cache, args)) {\\n            return cache[args]\\n        } else {\\n            cache[args] = fn(...args)\\n            return cache[args]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nconst contains = (cache, arr) => {\\n    return cache[arr.toString()] !== undefined\\n}\\n\\nfunction memoize(fn) {\\n    const cache = {}\\n\\n    return function (...args) {\\n        if (contains(cache, args)) {\\n            return cache[args]\\n        } else {\\n            cache[args] = fn(...args)\\n            return cache[args]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926984,
                "title": "solution-using-hasownproperty-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemoization in general is a concept to avoid making unnnecasary function calls when the arguments being passed are the same . We can achieve this using hasOwnProperty method of Object prototype .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initially declare an empty object and check if key exists in the object . here , key is nothing but the arguments being received and if present we fetch its value from the object and not by making the actual function call hence the callCount property of the function wont be increased . If not present, we set the object\\'s key as args and its value will be by making the actual function call and hence  the callCount property will be increased by 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n\\n   let obj = {}\\n\\n   return function(...args){\\n       if(obj.hasOwnProperty(args)){\\n           return obj[args]\\n       } else {\\n           obj[args] = fn(...args)\\n           return obj[args]\\n       }\\n   }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n\\n   let obj = {}\\n\\n   return function(...args){\\n       if(obj.hasOwnProperty(args)){\\n           return obj[args]\\n       } else {\\n           obj[args] = fn(...args)\\n           return obj[args]\\n       }\\n   }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926072,
                "title": "js-easy-to-understand-with-explanation",
                "content": "# Approach\\nWhat the problem is saying that: \\nWe have to cache the solution and that is what memoization is.\\n\\n- So, for example if a add fn is called first it will compute the result and cache the result using map and set the key as args and value as computed result.\\n- Now, if add fn is called again it will check the cache first and then if it is present in the cache it will return the value of the key else caches the result.\\n\\n# Complexity\\n- Time complexity:\\nDepends on the fn\\n- Space complexity:\\nDepends on the functions calls.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = (fn) => {\\n    const cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        \\n        if(cache.has(key)){\\n            return cache.get(key);\\n        }\\n         \\n        const result = fn(...args)\\n        cache.set(key,result);\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = (fn) => {\\n    const cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        \\n        if(cache.has(key)){\\n            return cache.get(key);\\n        }\\n         \\n        const result = fn(...args)\\n        cache.set(key,result);\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924545,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cacheObj = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in cacheObj)\\n            return cacheObj[key]\\n        \\n        const res = fn(...args)\\n        cacheObj[key] = res\\n        return res\\n    }\\n}\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cacheObj = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in cacheObj)\\n            return cacheObj[key]\\n        \\n        const res = fn(...args)\\n        cacheObj[key] = res\\n        return res\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3923894,
                "title": "easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key] === undefined)\\n            cache[key] = fn(...args);\\n\\n        return cache[key];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key] === undefined)\\n            cache[key] = fn(...args);\\n\\n        return cache[key];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914963,
                "title": "memoization-a-technique-for-improving-the-performance-of-functions",
                "content": "# Intuition\\n\\nThe intuition to solve the problem of memoization is that if a function is called with the same arguments more than once, then the result of the function call will be the same each time. This means that we can store the result of the function call in a cache and then return the cached result when the function is called again with the same arguments. This can significantly improve the performance of the function, especially if it is called with a lot of different arguments.\\n# Approach\\nMemoization\\n\\n# Complexity\\n- Time complexity:\\nBest case: O(1)\\nThe key for the cache is already in the cache, so the function simply returns the value from the cache. This takes a constant amount of time, O(1).\\nWorst case: O(n)\\nThe key for the cache is not in the cache, so the function must first call the original function to compute the value. This takes a time that is proportional to the length of the arguments, O(n). Then, the function must add the key and value to the cache. This also takes a constant amount of time, O(1).\\n\\n- Space complexity:\\nThe cache stores a key-value pair for each invocation of the original function. The key is a string that is the JSON representation of the arguments to the function. The value is the result of calling the original function with those arguments. The length of the key and value can be proportional to the length of the arguments, so the space complexity is O(n).\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in cache){\\n            return cache[key]\\n        }\\n        const compute = fn(...args)\\n        cache[key] = compute\\n         return compute\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in cache){\\n            return cache[key]\\n        }\\n        const compute = fn(...args)\\n        cache[key] = compute\\n         return compute\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906491,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = {};\\n    \\n    return function(...args) {\\n        let key = args.join(\\',\\');\\n        if(key in memo) return memo[key];\\n        return memo[key] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = {};\\n    \\n    return function(...args) {\\n        let key = args.join(\\',\\');\\n        if(key in memo) return memo[key];\\n        return memo[key] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895513,
                "title": "easy-solution-3-lines-solution-and-fastest-solution",
                "content": "**Intuition**\\n\\nThe intuition behind memoization is that we can speed up functions by caching return values. If a function is called multiple times with the same inputs, we only need to execute it once and can return the cached result on subsequent calls.\\n\\n**Approach**\\n\\nThe approach is to create a cache object (Map) or (Object) to store function arguments as keys and return values as values.\\n\\nWhen the memoized function is called, we first check if the cache has the key of the current arguments. If yes, return the cached value immediately.\\n\\nIf not, we call the original function, store the result in the cache using the arguments as key, and return the result.\\n\\n**Complexity**\\n\\nTime Complexity: O(1) for cached inputs, O(n) for new inputs, where n is the complexity of the original function.\\n\\nSpace Complexity: O(n), proportional to the number of unique input combinations.\\n\\nThe overhead of memoization is the cache object storage. But for functions with repeated inputs it improves performance dramatically.\\n\\n**Conclusion**\\n\\nMemoization provides a powerful optimization by caching previous results. It works especially well for expensive pure functions with repeated argument combinations. The tradeoff is higher memory usage to store the cache.\\n\\n---\\n**1. Easy solution**\\n\\n```\\nfunction memoize(fn) {\\n  const cache = {};\\n\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (!cache[key]) {\\n      cache[key] = fn(...args);\\n    }\\n    return cache[key];\\n  };\\n}\\n```\\n---\\n**2. 3 lines solution and the fastest solution**\\n\\n```\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = args.toString();\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n```\\nI used *Map* object to store key-value pairs and remembers the original insertion order of the keys.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n  const cache = {};\\n\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (!cache[key]) {\\n      cache[key] = fn(...args);\\n    }\\n    return cache[key];\\n  };\\n}\\n```\n```\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = args.toString();\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888940,
                "title": "efficient-memoization-for-common-mathematical-functions",
                "content": "# Intuition and Approach:\\nThe intuition behind the solution is to utilize memoization to cache the results of function calls for common mathematical functions. The approach involves using a Map to store previously computed results based on the function\\'s input arguments. The memoized function first checks if the result is already cached. If it is, it returns the cached result; otherwise, it computes the result, caches it, and returns the result.\\n\\n# Time Complexity:\\nThe time complexity of the memoized function is reduced compared to the original functions. For functions like fib and factorial, the time complexity is improved from exponential to linear due to caching.\\n\\n# Space Complexity:\\nThe space complexity is influenced by the storage of cached results in the Map. The size of the cache grows as more unique inputs are encountered. Overall, the space complexity is proportional to the number of unique input combinations.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map();\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n\\n    const result = fn.apply(this, args);\\n    cache.set(key, result);\\n    return result;\\n  };\\n  \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```\\nThe memoize function enhances the efficiency of common mathematical functions by providing a memoized version that avoids redundant calculations. This solution employs memoization to reduce time complexity and introduces a cache to store previous results, thus improving overall performance.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map();\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n\\n    const result = fn.apply(this, args);\\n    cache.set(key, result);\\n    return result;\\n  };\\n  \\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885394,
                "title": "beats-99-82-users-memoize-problem-solved-by-map-and-tc-is-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI though to solve of having a one storage for memoized content, initially always check with memoized data if not present return actual data and then store into memoized storage and for subsequent call it go on the same way memoizeFirst then actual data check\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The appraoch I took over initially with array and I went with time exceeding error due to array loop for memoized data in the case of huge computation task test case\\n- So I came with idea of implementing with Map DS that was far most efficient way I seen while implement and it works as expected\\n- The speed a of getting data from Map using get and has method is very fast due to that this is the best solution\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    // store memoized args and its value\\n    let memoizedData= new Map()\\n    \\n    return function(...args) {  \\n        // making args as stringify to compare as we dont get nested data so this JSON.stringify itself sufficient\\n        const key = JSON.stringify(args) \\n        // if the size is not empty then we proceed for memoized data check\\n        if(memoizedData.size){\\n            if(memoizedData.has(key)){\\n                const value = memoizedData.get(key)\\n                return value\\n            }\\n        }\\n        const result = fn(...args)     \\n        memoizedData.set(key,result)\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    // store memoized args and its value\\n    let memoizedData= new Map()\\n    \\n    return function(...args) {  \\n        // making args as stringify to compare as we dont get nested data so this JSON.stringify itself sufficient\\n        const key = JSON.stringify(args) \\n        // if the size is not empty then we proceed for memoized data check\\n        if(memoizedData.size){\\n            if(memoizedData.has(key)){\\n                const value = memoizedData.get(key)\\n                return value\\n            }\\n        }\\n        const result = fn(...args)     \\n        memoizedData.set(key,result)\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882220,
                "title": "simplest-solution-easy-to-understand-memoization-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe memoization function is a way to speed up a function by storing the results of previous calls. This is useful for functions that are called repeatedly with the same input arguments.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe memoization function works by first creating a new object called a Map. The Map object stores a mapping between the input arguments of the function and the return value of the function. The JSON.stringify() function is used to convert the input arguments to a string, which is used as the key in the Map object.\\n\\nThe memoization function then returns a new function that is wrapped around the original function. The new function takes the same arguments as the original function, but it first checks the Map object to see if the result of the function has already been calculated for the given input arguments. If the result has already been calculated, the new function returns the result from the Map object. Otherwise, the new function calls the original function and stores the result in the Map object.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the memoization function is O(1).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the memoization function is O(n).\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    return function(...args) {\\n        var key = JSON.stringify(args);\\n        if(memo.has(key))return memo.get(key);\\n        else{\\n            var temp = fn(...args);\\n            memo.set(key,temp);\\n            return temp;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    return function(...args) {\\n        var key = JSON.stringify(args);\\n        if(memo.has(key))return memo.get(key);\\n        else{\\n            var temp = fn(...args);\\n            memo.set(key,temp);\\n            return temp;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882108,
                "title": "best-solution-ever-2-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return (...args) => {\\n        const key = JSON.stringify(args);\\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881267,
                "title": "simple-solution-with-explanation",
                "content": "# Explanation\\nOne possible way to write a function that will never be called twice with the same inputs is to use a technique called memoization. Memoization is a method of caching the results of previous function calls, so that if the same inputs are given again, the function can return the cached value instead of recomputing it. This can improve the performance and efficiency of the function, especially if it is computationally expensive or involves recursion.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = {}\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (key in memo) {\\n            return memo[key]\\n        }\\n        memo[key] = fn(...args)\\n        return memo[key]\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = {}\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (key in memo) {\\n            return memo[key]\\n        }\\n        memo[key] = fn(...args)\\n        return memo[key]\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881118,
                "title": "map-solution",
                "content": "\\n```\\nconst RES = Symbol(\"result\");\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const globalCache = new Map();\\n\\n    return (...params) => {\\n        let currentCache = globalCache;\\n        for(const param of params) {\\n            if (!currentCache.has(param)) {\\n                currentCache.set(param, new Map());\\n            }\\n            currentCache = currentCache.get(param);\\n        }\\n\\n        if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n        const result = fn(...params);\\n\\n        currentCache.set(RES, result);\\n        return result;\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst RES = Symbol(\"result\");\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const globalCache = new Map();\\n\\n    return (...params) => {\\n        let currentCache = globalCache;\\n        for(const param of params) {\\n            if (!currentCache.has(param)) {\\n                currentCache.set(param, new Map());\\n            }\\n            currentCache = currentCache.get(param);\\n        }\\n\\n        if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n        const result = fn(...params);\\n\\n        currentCache.set(RES, result);\\n        return result;\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878623,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)   // N => no of operations\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        if (args in cache)\\n            return cache[args];\\n        const res = fn(...args);\\n        cache[args] = res;\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        if (args in cache)\\n            return cache[args];\\n        const res = fn(...args);\\n        cache[args] = res;\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866490,
                "title": "beats-94-14-javascript-solution-hint-to-pass-time-execution-from-380-to-290-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let memo = {};\\n    return function(...args) {\\n        const key = String(args);\\n        if(key in memo) {\\n            return memo[key]\\n        } \\n        memo[key] = fn(...args);\\n        return memo[key];\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let memo = {};\\n    return function(...args) {\\n        const key = String(args);\\n        if(key in memo) {\\n            return memo[key]\\n        } \\n        memo[key] = fn(...args);\\n        return memo[key];\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859026,
                "title": "javascript-simple-soluton-with-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = {};\\n    \\n    return function(...args) {\\n        if(args in memo) return memo[args];\\n        memo[args] = fn(...args);\\n        return memo[args];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = {};\\n    \\n    return function(...args) {\\n        if(args in memo) return memo[args];\\n        memo[args] = fn(...args);\\n        return memo[args];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3852553,
                "title": "simple-js-solution-using-hash",
                "content": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function(...args) {\\n      if (cache[args] !== undefined) return cache[args];\\n      cache[args] = fn(...args);\\n      return cache[args];\\n    }\\n  }\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {};\\n    return function(...args) {\\n      if (cache[args] !== undefined) return cache[args];\\n      cache[args] = fn(...args);\\n      return cache[args];\\n    }\\n  }\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843932,
                "title": "typescript-based-dp",
                "content": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const dp = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args); // indivisual 2 ,3 , 5 like that convert to string.\\n        if(key in dp){\\n            return dp[key];\\n        }\\n        return dp[key] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const dp = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args); // indivisual 2 ,3 , 5 like that convert to string.\\n        if(key in dp){\\n            return dp[key];\\n        }\\n        return dp[key] = fn(...args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841805,
                "title": "2623-memoize-fully-explained-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->1)function memoize(fn): This is a higher-order function called memoize. It takes a function fn as an argument, which is the function that we want to memoize.\\n\\n2) const cacheObject = {};: This line creates an empty object called cacheObject. This object will be used to store the results of previously computed function calls so that we can avoid redundant computations by looking up the results from the cache.\\n\\n3) return function(...args) {: This line defines an anonymous function that takes any number of arguments using the rest parameter syntax (...args). This function will be returned by the memoize function and will be used to call the original function fn.\\n\\n 4) const key = JSON.stringify(args);: This line converts the arguments passed to the anonymous function into a single string key using JSON.stringify(). This string will be used as a unique identifier for the set of arguments passed to the original function fn, allowing us to use it as a key in the cache object.\\n 5) if (key in cacheObject) {: This condition checks if the key (representing the arguments passed to fn) exists in the cacheObject. If it does, it means that the function fn has been called with the same set of arguments before, and we have the result stored in the cache. In that case, we return the cached result directly, avoiding the computation of fn(...args).\\n\\n 6) return cacheObject[key];: If the condition in the previous line is true (i.e., the result exists in the cache), this line returns the cached result.\\n\\n 6) } else {: If the condition in the first if statement is false, it means that the result for the given set of arguments doesn\\'t exist in the cache, and we need to compute it.\\n\\n7) const result = fn(...args);: This line calls the original function fn with the provided arguments args and stores the result in the result variable.\\n\\n 8) cacheObject[key] = result;: After computing the result, we store it in the cache object using key as the identifier (representing the specific set of arguments).\\n\\n  return result;: Finally, we return the computed result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn){\\n    const cacheObject={};\\n    return function(...args){\\n        const key =JSON.stringify(args);\\n        if(key in cacheObject){\\n            return cacheObject[key];\\n\\n        }\\n        else{\\n            const result =fn(...args);\\n            cacheObject[key] =result;\\n            return result;\\n        }\\n    }\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn){\\n    const cacheObject={};\\n    return function(...args){\\n        const key =JSON.stringify(args);\\n        if(key in cacheObject){\\n            return cacheObject[key];\\n\\n        }\\n        else{\\n            const result =fn(...args);\\n            cacheObject[key] =result;\\n            return result;\\n        }\\n    }\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840127,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoMap = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        return memoMap[key] ?? (memoMap[key] = fn(...args))\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoMap = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        return memoMap[key] ?? (memoMap[key] = fn(...args))\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818338,
                "title": "memoization",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const test = {};\\n    return function(...args) {\\n        const key = args.toString();\\n        if (key in test) {\\n            return test[key];\\n        }\\n        else {\\n            test[key] = fn(...args);\\n            return test[key];\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const test = {};\\n    return function(...args) {\\n        const key = args.toString();\\n        if (key in test) {\\n            return test[key];\\n        }\\n        else {\\n            test[key] = fn(...args);\\n            return test[key];\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818336,
                "title": "memoization",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const test = {};\\n    return function(...args) {\\n        const key = args.toString();\\n        if (key in test) {\\n            return test[key];\\n        }\\n        else {\\n            test[key] = fn(...args);\\n            return test[key];\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const test = {};\\n    return function(...args) {\\n        const key = args.toString();\\n        if (key in test) {\\n            return test[key];\\n        }\\n        else {\\n            test[key] = fn(...args);\\n            return test[key];\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818091,
                "title": "typescript-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let map: Map<string, number> = new Map<string, number>();\\n    return function(...args) {\\n        let argsKey: string = args.join(\\',\\');\\n        if(map.has(argsKey)) return map.get(argsKey);\\n        let result: number = fn(...args);\\n        map.set(argsKey, result);\\n        return result;\\n    }\\n}\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let map: Map<string, number> = new Map<string, number>();\\n    return function(...args) {\\n        let argsKey: string = args.join(\\',\\');\\n        if(map.has(argsKey)) return map.get(argsKey);\\n        let result: number = fn(...args);\\n        map.set(argsKey, result);\\n        return result;\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3815973,
                "title": "javascript-time-fn-dependent-space-o-k-solution",
                "content": "# Intuition\\nmemo object that stores that creates cache for answers\\n\\n# Approach\\n1. Declare a memo object before returning the inner function.\\n2. Create a combination for arguments that acts as a key (representation for the input parameters)\\n3. Check if the key exists in the memo object.\\n4. If yes, return the cached value without executing the function.\\n5. If no, execute the function, store the value in memo and return the value from inner function.\\n\\n# Even Better But ...\\nAs far as I see, it is mentioned that we could assume that possible functions are fib, factorial and sum.\\n\\nSince sum is the only function that takes more than one parameters, we could assume that a+b = b+a\\n\\nSo we could\\'ve used Array.sort() to create only 1 unique cached value for both but the test cases don\\'t allow that. :V\\n\\n# Complexity\\n- Time complexity:\\nDepends on fn\\n\\n- Space complexity:\\no(k) where k is number of unique argument combinations\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = fn => {\\n    const memo = {};\\n    return (...args) => {\\n    const key = args.toString(); // Doesn\\'t allow test cases to pass if we use args.sort().toString() for some reason\\n    return key in memo ? memo[key] : memo[key] = fn(...args);\\n }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nconst memoize = fn => {\\n    const memo = {};\\n    return (...args) => {\\n    const key = args.toString(); // Doesn\\'t allow test cases to pass if we use args.sort().toString() for some reason\\n    return key in memo ? memo[key] : memo[key] = fn(...args);\\n }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815632,
                "title": "just-use-a-hash-table-to-store-the-args-and-its-val",
                "content": "# Complexity\\n- Time complexity:\\nO(n) in case where all the args are new so we have to run the function always\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    \\n    const cached = {}\\n\\n    return function(...args) {\\n\\n        const cachedVal = cached[args];\\n\\n        if (cachedVal !== undefined){\\n            return cachedVal\\n        }\\n        // run func\\n        const val = fn(...args)\\n        cached[args] = val;\\n        return val        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    \\n    const cached = {}\\n\\n    return function(...args) {\\n\\n        const cachedVal = cached[args];\\n\\n        if (cachedVal !== undefined){\\n            return cachedVal\\n        }\\n        // run func\\n        const val = fn(...args)\\n        cached[args] = val;\\n        return val        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810660,
                "title": "simple-and-clear-soln",
                "content": "\\n\\n# Code\\n```\\nconst memoize = (fn) => {\\n  let cache = {}\\n  return (...args) => {\\n    // Using cached result\\n    const key = args.toString()\\n    if (key in cache) return cache[key]\\n    // Caching the result\\n    const result = fn(...args)\\n    cache[key] = result\\n    return result\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst memoize = (fn) => {\\n  let cache = {}\\n  return (...args) => {\\n    // Using cached result\\n    const key = args.toString()\\n    if (key in cache) return cache[key]\\n    // Caching the result\\n    const result = fn(...args)\\n    cache[key] = result\\n    return result\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808786,
                "title": "typescript-o-m-t-fn-o-u",
                "content": "# Code\\n```ts\\ntype Fn = (...params: any[]) => unknown\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache = new Map<string, unknown>();\\n\\n    return function(...params: unknown[]) {\\n        const key = params.join(\\',\\');\\n\\n        if (!cache.has(key)) {\\n            const result = fn(...params);\\n            cache.set(key, result);\\n        }\\n        return cache.get(key);\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(m + T(fn))$$\\n\\nWhere `m` is the length of `params` and `T(fn)` is the time complexity of `fn`.\\n\\n- Space complexity: $$O(U)$$\\n\\nWhere `U` represents the total number of unique parameter combinations encountered during the lifetime of the memoized function.\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ntype Fn = (...params: any[]) => unknown\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache = new Map<string, unknown>();\\n\\n    return function(...params: unknown[]) {\\n        const key = params.join(\\',\\');\\n\\n        if (!cache.has(key)) {\\n            const result = fn(...params);\\n            cache.set(key, result);\\n        }\\n        return cache.get(key);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807920,
                "title": "memoize-with-map",
                "content": "# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let cache = new Map();\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        \\n        if (!cache.has(key)) {\\n            cache.set(key, fn(...args));\\n        }\\n        return cache.get(key);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let cache = new Map();\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        \\n        if (!cache.has(key)) {\\n            cache.set(key, fn(...args));\\n        }\\n        return cache.get(key);\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806569,
                "title": "simple-js-logic",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoized = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in memoized){\\n            return memoized[key]\\n        }\\n        const result = fn(...args)\\n        memoized[key] = result\\n        return result\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoized = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in memoized){\\n            return memoized[key]\\n        }\\n        const result = fn(...args)\\n        memoized[key] = result\\n        return result\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805484,
                "title": "memoize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n          const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n\\n    }\\n};\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n          const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n\\n    }\\n};\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800928,
                "title": "very-easy-three-line-code-which-improve-performance-and-speed",
                "content": "# **Hint:**\\nCache results to avoid redundant calculations and boost performance. Implement memoization for faster execution. Try it now!\\n\\n# **Explanation:**\\n1. Initialize an empty cache object to store results: `const cache = {};`\\n\\n2. Define a memoization function that wraps around the original function and takes advantage of the cache.\\n\\n3. Create a unique key for each function call using the provided arguments: `const key = args.join(\",\");`\\n\\n4. Check if the result for the given key exists in the cache: `if (!(key in cache)) { ... }`\\n\\n5. If the result is not in the cache, calculate it using the original function and store it: `cache[key] = fn(...args);`\\n\\n6. Return the cached result for the given key: `return cache[key];`\\n\\n# **Code**\\n```\\nfunction memoize(fn) {\\n   const cache ={};\\n    return function(...args) {\\n        const key = args.join(\",\");\\n        if(!(key in cache)){\\n          cache[key]=fn(...args);\\n        }\\n        return cache[key];\\n    }\\n}\\n```\\n\\nBy using memoization, you can significantly reduce computation time and improve the efficiency of your function, especially when dealing with repetitive function calls.\\n\\n> Remember, the key in memoization should uniquely represent the function call. **In this implementation, we use `args.join(\",\")` to create a string key based on the function\\'s arguments.** If the function is called with the same set of arguments again, the cached result will be returned directly, avoiding unnecessary recalculations.\\n\\n**If you found this memoization tip helpful, please show your support by giving this post an upvote! Your support motivates me to share more optimization techniques and coding tips to help the entire community.**\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n   const cache ={};\\n    return function(...args) {\\n        const key = args.join(\",\");\\n        if(!(key in cache)){\\n          cache[key]=fn(...args);\\n        }\\n        return cache[key];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795374,
                "title": "simple-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. initializing cache for memoize function then saving the key or paramter intput in form of string using json.stringify\\n2. checking the key is present in cache if not then creating a new key with calculating the result by simply calling the fn (which can be either sum or factorial and so forth) with paramters passed in args and assigning the new entry to chache.\\n3. if key is present in cache object then simply return the value of key in cache\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache={};\\n    return function(...args) {\\n       \\n       var key=JSON.stringify(args);\\n       if(key in cache)\\n       {\\n           return cache[key];\\n       }\\n        const result=fn(...args);\\n        cache[key]=result;\\n        return result;\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache={};\\n    return function(...args) {\\n       \\n       var key=JSON.stringify(args);\\n       if(key in cache)\\n       {\\n           return cache[key];\\n       }\\n        const result=fn(...args);\\n        cache[key]=result;\\n        return result;\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788594,
                "title": "memonization",
                "content": "# Intuition\\n    I have created the function and created cache object. whenever this functions called I save the result in the cache object with aurgments as a name.\\n\\n# Approach\\nTo provide a more detailed approach for the memoize function, let\\'s break it down into steps:\\n1. Initialize an empty cache object to store the computed results.\\n2. Define an anonymous function that takes any number of arguments (...args).\\n3. Inside the anonymous function:\\n    - Check if the cached result exists for the given arguments by using cache[args] !== undefined.\\n    - If the cached result exists:\\n    - Return the cached result by accessing cache[args].\\n    - If the cached result does not exist:\\n        - Invoke the original function fn with the provided arguments using the spread syntax (fn(...args)).\\n        - Store the result of the function call in the cache by assigning it to cache[args].\\n        - Return the result.\\n4. Return the anonymous function as the memoized version of the original function.\\n\\n# Complexity\\nTime complexity:\\nThe time complexity of the memoized function depends on the behavior of the underlying function fn and the number of distinct arguments passed to it.\\n\\nWhen the memoized function is called with new arguments that have not been memoized before, it invokes the original function fn and stores the result in the cache. This incurs the time complexity of fn itself.\\n\\nHowever, when the memoized function is called with previously memoized arguments, it can directly retrieve the result from the cache in constant time, resulting in a time complexity of O(1).\\n\\n### Space complexity:\\nThe space complexity of the memoized function depends on the number of distinct arguments passed to it and the size of the cache that stores the computed results.\\n\\nLet\\'s analyze the space complexity:\\n\\nCache:\\n\\nThe cache is implemented as an object (cache variable).\\nThe space required by the cache depends on the number of distinct arguments passed to the memoized function.\\nIf the memoized function is called with different arguments each time, the cache will grow, and the space complexity will increase accordingly.\\nThe cache stores the results of the function calls, so its size is directly proportional to the number of distinct arguments encountered.\\nAssuming the number of distinct arguments is denoted as n, the space complexity of the cache would be O(n).\\nAdditional space:\\n\\n- Apart from the cache, the memoized function does not require significant additional space.\\n- The function itself has a constant space complexity.\\n- The variables fn, args, and other internal variables are reused for each function call and do not grow with the size of the input.\\n- Therefore, the overall space complexity of the memoized function can be considered as O(n), where n represents the number of distinct arguments encountered by the memoized function over its lifetime.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {}\\n    return function(...args) {\\n        if(cache[args] !== undefined){\\n            return cache[args]\\n        }\\n        cache[args] = fn(...args)\\n        return cache[args]\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = {}\\n    return function(...args) {\\n        if(cache[args] !== undefined){\\n            return cache[args]\\n        }\\n        cache[args] = fn(...args)\\n        return cache[args]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784566,
                "title": "simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`memoization` is an optimization process, Making a cache for frequent calculation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep 1 - Define a cache object ex - `ob1`\\nstep 2 - Check if input already present in cache as the key of object, if present return the object value.\\nstep 3 - if not present, then store the key value pair, `key` will be the input and `value` will be the `fn(...args)` output.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let ob1 = {}\\n    return function(...args) {\\n        if (ob1[JSON.stringify([...args])] != undefined){   \\n            return ob1[JSON.stringify([...args])]\\n        }\\n        return ob1[JSON.stringify([...args])] = fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let ob1 = {}\\n    return function(...args) {\\n        if (ob1[JSON.stringify([...args])] != undefined){   \\n            return ob1[JSON.stringify([...args])]\\n        }\\n        return ob1[JSON.stringify([...args])] = fn(...args)\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784514,
                "title": "2623-memoize",
                "content": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let oldCalls = {};\\n    return function(...args) {\\n        let key = args.join();\\n        if (oldCalls[key] === undefined)\\n            oldCalls[key] = fn(...args);\\n            \\n        return oldCalls[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let oldCalls = {};\\n    return function(...args) {\\n        let key = args.join();\\n        if (oldCalls[key] === undefined)\\n            oldCalls[key] = fn(...args);\\n            \\n        return oldCalls[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780739,
                "title": "memoize-function-in-javascript",
                "content": "# Intuition\\nThe question is to solve memoize function using cache.\\n\\n# Approach\\nDeclare an empty object .Convert the arguments to String.Check if these arguments are in cache object.If they are,then return.If not,then store arguments from function into a variable and store that variable into cache and return that variable.\\n# Complexity\\n- Time complexity:\\nO(1) to O(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = String(args);\\n        if(key in cache){\\n            return cache[key];\\n        }\\n        const result = fn(...args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = String(args);\\n        if(key in cache){\\n            return cache[key];\\n        }\\n        const result = fn(...args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772644,
                "title": "simple-solution",
                "content": "\\n# Idea\\n The memoize function takes the original function fn as an argument and returns a new function. This new function checks if the cache contains a cached value for the given input parameters. If it does, it returns the cached value. Otherwise, it calls the original function fn with the input parameters, stores the result in the cache, and returns the result.\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n     const cache =new Map()\\n    return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n     const cache =new Map()\\n    return function(...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key);\\n    }\\n    const result = fn(...args);\\n    cache.set(key, result);\\n    return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3771658,
                "title": "easiest-solution-no-need-to-make-it-more-lengthy-runtime-faster-than-96-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasiest method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed JSON.stringify and ternary operators\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map()\\n    return function(...args) {\\n        let key = JSON.stringify(args);\\n        let result;\\n        return cache.has(key) \\n        ? (cache.get(key))\\n        : (result = fn(...args), cache.set(key, result), result);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map()\\n    return function(...args) {\\n        let key = JSON.stringify(args);\\n        let result;\\n        return cache.has(key) \\n        ? (cache.get(key))\\n        : (result = fn(...args), cache.set(key, result), result);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3763226,
                "title": "easy-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const mem_args: Map<string, any> = new Map<string, any> ();\\n    return function(...args) {\\n        const args_str = args.toString();\\n        if (mem_args.has(args_str)) {\\n            return mem_args.get(args_str);\\n        }\\n\\n        const result =  fn(...args);\\n        mem_args.set(args_str, result);\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const mem_args: Map<string, any> = new Map<string, any> ();\\n    return function(...args) {\\n        const args_str = args.toString();\\n        if (mem_args.has(args_str)) {\\n            return mem_args.get(args_str);\\n        }\\n\\n        const result =  fn(...args);\\n        mem_args.set(args_str, result);\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3763122,
                "title": "memoized-version-of-a-function-using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to use map to store computed value so that if we get the same input again, it would return the result from cache without computing the function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use Map data structure to cache computed value, then we need to focus on calulating the cache key which should be unique for different kind of inputs, here the function either can accept one argument or two arguments. Instead adding the arguments to calculate cache key we can concatenate the arguments as string which will result in unique key in this scenario. For example if we add arguments to create key it can give same key for different inputs eg. 1,2 result in 3 or 2,1 will also result in 3 and in case of single argument eg.3 which will also result 3 as key. I have used Array.join() to create cache key which will provide comma separated arguments as cache key.\\nWhen the memoized function is called we calculates our cache key and checks in map if it contains the value against it then we returns the value otherwise we call the function which computes the value and set in Map object and returns the computed value\\n\\n# Complexity\\n- Time complexity: Depends on the original function being memoized, and could be O(n!) + O(2^n) (because of factorial and fibonacci function).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n) where n is number of inputs.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cached = new Map();\\n    return function(...args) {\\n        const key = args.join()\\n        let result = cached.get(key) ?? \\'null\\';\\n        if (result === \\'null\\') {\\n            result = fn(...args);\\n            cached.set(key, result);\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cached = new Map();\\n    return function(...args) {\\n        const key = args.join()\\n        let result = cached.get(key) ?? \\'null\\';\\n        if (result === \\'null\\') {\\n            result = fn(...args);\\n            cached.set(key, result);\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755365,
                "title": "tricky-one-syntax-got-me",
                "content": "## Intuition and approach\\n\\nI knew I needed to set a conditionally set a variable for cacheing the results.\\n\\nUpon reflection and referencing the _Editorial_, I messed up quite a bit of syntax and learned that the `in` operator can be used outside a `for...in` loop.\\n\\nI learned a new approach of when the arguments are an array of numbers, a convenient way to convert them into a string key is with `JSON.stringify()`.\\n\\n## Tutorials\\n\\nI read the editorial and watched a [Web Dev Simplified](https://www.youtube.com/watch?v=WbwP4w6TpCk) explanation.\\n\\n### Use cases\\n\\nThis is good for caching results of a network API call.\\n\\nA potential downside of memoizing network requests is the risk of data staleness. If the value associated with a particular key in the database changes, the memoized function may still return the old cached result, leaving the user unaware of any updates.\\n\\n# Code\\n\\n```javascript\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  let cache = {};\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n    console.log(key);\\n    if (key in cache) {\\n      return cache[key];\\n    } else {\\n      var functionOutput = fn(...args);\\n      cache[key] = functionOutput;\\n      return functionOutput;\\n    }\\n  };\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  let cache = {};\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n    console.log(key);\\n    if (key in cache) {\\n      return cache[key];\\n    } else {\\n      var functionOutput = fn(...args);\\n      cache[key] = functionOutput;\\n      return functionOutput;\\n    }\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754623,
                "title": "memoize-30-days-of-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        if (!(JSON.stringify(args) in cache)) {\\n            cache[JSON.stringify(args)] = fn(...args);\\n        }\\n        return cache[JSON.stringify(args)];\\n    };\\n}\\n\\nlet callCount = 0;\\nconst memoizedFn = memoize(function (a, b) {\\n    callCount += 1;\\n    return a + b;\\n});\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        if (!(JSON.stringify(args) in cache)) {\\n            cache[JSON.stringify(args)] = fn(...args);\\n        }\\n        return cache[JSON.stringify(args)];\\n    };\\n}\\n\\nlet callCount = 0;\\nconst memoizedFn = memoize(function (a, b) {\\n    callCount += 1;\\n    return a + b;\\n});\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733189,
                "title": "easy-and-short-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  let memo = {};\\n  return function(...args) {\\n    if(memo.hasOwnProperty(args)) return memo[args];\\n      memo[args] = fn(...args);\\n      return memo[args];\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  let memo = {};\\n  return function(...args) {\\n    if(memo.hasOwnProperty(args)) return memo[args];\\n      memo[args] = fn(...args);\\n      return memo[args];\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732134,
                "title": "simple-and-concise-without-using-map",
                "content": "```\\nfunction memoize(fn) {\\n   let cache = {};\\n   let argString\\n   return function(...args) {\\n    argString = args.toString()\\n    if(argString in cache) return cache[argString]\\n    return cache[argString] = fn(...args);\\n  }\\n  \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n   let cache = {};\\n   let argString\\n   return function(...args) {\\n    argString = args.toString()\\n    if(argString in cache) return cache[argString]\\n    return cache[argString] = fn(...args);\\n  }\\n  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726170,
                "title": "map-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to use inbuilt map function\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSyntax for creating map and reading its value in js\\n\\nconst map = new Map(); // Create an empty Map object\\n\\n// Assign values using strings as keys\\nmap.set(\\'key1\\', \\'value1\\');\\nmap.set(\\'key2\\', \\'value2\\');\\nmap.set(\\'key3\\', \\'value3\\');\\n\\nconsole.log(map.get(\\'key1\\')); // Output: value1\\nconsole.log(map.get(\\'key2\\')); // Output: value2\\nconsole.log(map.get(\\'key3\\')); // Output: value3\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: memoized function depends on the original function being memoized, and can range from O(1) to O(n) to O(2^n).\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the number of unique inputs to the function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const mp=new Map();\\n    return function(...args) {\\n       const curr=JSON.stringify(args)\\n       if(mp.has(curr)){\\n           return mp.get(curr);\\n       }\\n      const result=fn(...args);\\n      mp.set(curr,result);\\n      return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const mp=new Map();\\n    return function(...args) {\\n       const curr=JSON.stringify(args)\\n       if(mp.has(curr)){\\n           return mp.get(curr);\\n       }\\n      const result=fn(...args);\\n      mp.set(curr,result);\\n      return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722129,
                "title": "fast-desicion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let inputArgsAndResults = new Map()\\n    return function(...args) {\\n        const keyString = String(args)\\n        if(inputArgsAndResults.has(keyString)) {\\n            return inputArgsAndResults.get(keyString)\\n        } else {\\n            const sum = fn(...args)\\n            inputArgsAndResults.set(keyString, sum)\\n            return sum\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let inputArgsAndResults = new Map()\\n    return function(...args) {\\n        const keyString = String(args)\\n        if(inputArgsAndResults.has(keyString)) {\\n            return inputArgsAndResults.get(keyString)\\n        } else {\\n            const sum = fn(...args)\\n            inputArgsAndResults.set(keyString, sum)\\n            return sum\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721724,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const functionOutput = fn(...args);\\n    cache[key] = functionOutput;\\n    return functionOutput;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n    const functionOutput = fn(...args);\\n    cache[key] = functionOutput;\\n    return functionOutput;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3720139,
                "title": "javascript-new-map-beats-95-317ms",
                "content": "First Contribution on Leetcode \\u2728\\u2728\\u2728.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought, I need check if a value exist from a previous operation, and if it does not exist, then run an operation and save the result, to check it next time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, this is a pair key-value problem, that can be resolved with a\\n\\nnew Map();\\n\\nSo, I create  Map.\\nconst cache = Map();\\n\\nI check if exist the value from the params as the key.\\ncache.has(key);\\n\\nIf true, return the value\\ncache.get(key);\\n\\nIf false, run the function, set the key-value in the Map and return the result...\\n    const result = fn.apply(this, args);\\n    cache.set(key, value);\\n    return result;\\n\\n\\n\\n\\n\\n# Complexity\\nI don\\'t understand this part very well yet, if someone can help me with this I would thank you very much.\\nThis were the result though...\\n-- Runtime 317 ms\\nBeats 95.28%\\n-- Memory 107.2 MB\\nBeats 55.57%\\n- Time complexity: ---\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ---\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n\\n  const cache = new Map();\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key)\\n    } else {\\n\\n      const result = fn.apply(this, args);\\n      cache.set(key, result);\\n\\n      return result;\\n    }\\n\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n\\n  const cache = new Map();\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n    if (cache.has(key)) {\\n      return cache.get(key)\\n    } else {\\n\\n      const result = fn.apply(this, args);\\n      cache.set(key, result);\\n\\n      return result;\\n    }\\n\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708673,
                "title": "3-line-solution-for-quick-copying-and-pasting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n     const cache = {};\\n  return (...args) =>\\n    args in cache ? cache[args] : (cache[args] = fn(...args));\\n\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n     const cache = {};\\n  return (...args) =>\\n    args in cache ? cache[args] : (cache[args] = fn(...args));\\n\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708176,
                "title": "javascript-new-map-memorizing-it-can-t-detect-type-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let inputMapRes = undefined;\\n\\n    return function(...args) {\\n        if (typeof inputMapRes === \"undefined\") {\\n            const res = fn(...args);\\n            inputMapRes = new Map();\\n            inputMapRes.set(args.join(\"-\"), res);\\n            return res;\\n        }\\n\\n        if (!inputMapRes.has(args.join(\"-\"))) {\\n            const res = fn(...args);\\n            inputMapRes.set(args.join(\"-\"), res);\\n            return res;\\n        }\\n        \\n        return inputMapRes.get(args.join(\"-\"));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let inputMapRes = undefined;\\n\\n    return function(...args) {\\n        if (typeof inputMapRes === \"undefined\") {\\n            const res = fn(...args);\\n            inputMapRes = new Map();\\n            inputMapRes.set(args.join(\"-\"), res);\\n            return res;\\n        }\\n\\n        if (!inputMapRes.has(args.join(\"-\"))) {\\n            const res = fn(...args);\\n            inputMapRes.set(args.join(\"-\"), res);\\n            return res;\\n        }\\n        \\n        return inputMapRes.get(args.join(\"-\"));\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704650,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    return function(...args) {\\n        const key = args.join(\\'::\\');\\n        \\n        if(memo.has(key)) return memo.get(key);\\n\\n        const result = fn(...args);\\n        memo.set(key, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    return function(...args) {\\n        const key = args.join(\\'::\\');\\n        \\n        if(memo.has(key)) return memo.get(key);\\n\\n        const result = fn(...args);\\n        memo.set(key, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704649,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    return function(...args) {\\n        const key = args.join(\\'::\\');\\n        \\n        if(memo.has(key)) return memo.get(key);\\n\\n        const result = fn(...args);\\n        memo.set(key, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    return function(...args) {\\n        const key = args.join(\\'::\\');\\n        \\n        if(memo.has(key)) return memo.get(key);\\n\\n        const result = fn(...args);\\n        memo.set(key, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703735,
                "title": "spaghetti",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoizedMap = { }\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in memoizedMap) return memoizedMap[key];\\n        return memoizedMap[key] = fn(...args)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoizedMap = { }\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        if(key in memoizedMap) return memoizedMap[key];\\n        return memoizedMap[key] = fn(...args)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700930,
                "title": "simple-concise-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemoization is about caching the results for each input value. So, we don\\'t have to recompute the results for the same input. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo implement memoization in this problem, we can save the cache values in simple JS object. The keys of the cache object will be the stringified args array, and value for each key will be the output of fn. \\n\\n# Complexity\\n- Time complexity: \\nThe time complexity of the memoize function can be generalized as $$O(f(n))$$ for the first invocation and $$O(1)$$ for subsequent invocations. \\n\\n\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity can be generalized as  $$O(m)$$ for the cache, where  $$m$$ is the number of unique argument combinations encountered.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(!cache.hasOwnProperty(key))\\n            cache[key] = fn(...args);\\n\\n        return cache[key];\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(!cache.hasOwnProperty(key))\\n            cache[key] = fn(...args);\\n\\n        return cache[key];\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695237,
                "title": "easy-solution",
                "content": "# Code\\n```\\nfunction memoize(fn) {\\n    var cache = {} ;\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(key in cache) {\\n            return cache[key] ;\\n        }\\n        const op = fn(...args);\\n        cache[key] = op ;\\n        return op ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    var cache = {} ;\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if(key in cache) {\\n            return cache[key] ;\\n        }\\n        const op = fn(...args);\\n        cache[key] = op ;\\n        return op ;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3682619,
                "title": "easy-javascript-and-typescript-solution",
                "content": "# Intuition\\nNeed something to remember the answers and get them by arguments in O(1)\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nconst memoize = (fn: Fn): Fn => {\\n    const memoHash = {}\\n\\n    return (...args: Parameters<Fn>) => {\\n        const stringifiedArgs = JSON.stringify(args)\\n        \\n        if (typeof memoHash[stringifiedArgs] === \\'number\\') {\\n            return memoHash[stringifiedArgs]\\n        }\\n\\n        const result = fn.apply(null, args)\\n        memoHash[stringifiedArgs] = result\\n\\n        return result\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Intuition\\nNeed something to remember the answers and get them by arguments in O(1)\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nconst memoize = (fn: Fn): Fn => {\\n    const memoHash = {}\\n\\n    return (...args: Parameters<Fn>) => {\\n        const stringifiedArgs = JSON.stringify(args)\\n        \\n        if (typeof memoHash[stringifiedArgs] === \\'number\\') {\\n            return memoHash[stringifiedArgs]\\n        }\\n\\n        const result = fn.apply(null, args)\\n        memoHash[stringifiedArgs] = result\\n\\n        return result\\n    }\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3681494,
                "title": "easy-solution-for-memoize-function",
                "content": "# Approach\\nThe memoize function takes a function fn as an argument and returns a memoized version of it. The memoized function stores previously computed results in a cache object, where the keys are the serialized string representation of the function arguments. \\n\\nWhen the memoized function is called, it first checks if the result for the given arguments is already cached. If so, it returns the cached result; otherwise, it calls the original function fn with the arguments, stores the result in the cache, and returns it.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn.apply(this, args);\\n    cache[key] = result;\\n\\n    return result;\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn.apply(this, args);\\n    cache[key] = result;\\n\\n    return result;\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680747,
                "title": "day11-js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n\\n    const cacheobj={};\\n\\n    return function(...args) {\\n        \\n        const key =JSON.stringify(args);\\n        if(key in cacheobj)\\n        {\\n            return cacheobj[key];\\n\\n        }\\n        else\\n        {\\n            const result= fn(...args);\\n            cacheobj[key]=result;\\n            return result;\\n            \\n\\n        }\\n\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n\\n    const cacheobj={};\\n\\n    return function(...args) {\\n        \\n        const key =JSON.stringify(args);\\n        if(key in cacheobj)\\n        {\\n            return cacheobj[key];\\n\\n        }\\n        else\\n        {\\n            const result= fn(...args);\\n            cacheobj[key]=result;\\n            return result;\\n            \\n\\n        }\\n\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680200,
                "title": "ts-solution",
                "content": "# Intuition\\nThe memoize function takes an input function fn and returns a memoized version of that function. The memoized function stores the results of previous function calls in a cache (implemented as a Map) and checks the cache before making a new function call. If the result for a given set of input parameters is already in the cache, it returns the cached value; otherwise, it computes the result, stores it in the cache, and returns the computed value.\\n\\n\\n# Approach\\nThe memoize function creates a new Map called memo to serve as the cache. It then returns an anonymous function that takes in a variable number of arguments args of type number[].\\n\\nWithin the anonymous function, a unique hash is generated based on the input arguments using args.join(\\',\\'). This hash is used as the key to check if the result is already stored in the cache. If the hash exists in the cache (memo.has(hash)), the corresponding value is retrieved using memo.get(hash) and returned.\\n\\nIf the hash is not present in the cache, it means the function has not been called with the given set of input parameters before. In this case, the original function fn is called with the input arguments using the spread operator fn(...args), and the result is stored in the cache using memo.set(hash, ans).\\n\\nFinally, the computed result ans is returned.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the memoized function depends on the number of unique function calls made and the size of the cache. The cache is implemented as a Map object, which requires additional memory to store the hash keys and corresponding values. Therefore, the space complexity of the memoized function is determined by the size of the cache and any additional memory used by the original function fn.\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let memo = new Map<string, number>();\\n    return function (...args: number[]) {\\n        let hash = args.join(\\',\\');\\n        if (memo.has(hash)) return memo.get(hash);\\n\\n        let ans = fn(...args);\\n        memo.set(hash, ans);\\n        return ans;\\n    };\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let memo = new Map<string, number>();\\n    return function (...args: number[]) {\\n        let hash = args.join(\\',\\');\\n        if (memo.has(hash)) return memo.get(hash);\\n\\n        let ans = fn(...args);\\n        memo.set(hash, ans);\\n        return ans;\\n    };\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664316,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#  Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const obj={}\\n    return function(...args) {\\n        const key=JSON.stringify(args)\\n        return obj[key]?? (obj[key]=fn(...args))\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const obj={}\\n    return function(...args) {\\n        const key=JSON.stringify(args)\\n        return obj[key]?? (obj[key]=fn(...args))\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663342,
                "title": "beginner-friendly-solution-using-map",
                "content": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map();\\n\\n    return function (...args) {\\n        const key = JSON.stringify(args);\\n\\n        if (cache.has(key)) return cache.get(key);\\n\\n        const res = fn(...args);\\n        cache.set(key, res);\\n        return res;\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map();\\n\\n    return function (...args) {\\n        const key = JSON.stringify(args);\\n\\n        if (cache.has(key)) return cache.get(key);\\n\\n        const res = fn(...args);\\n        cache.set(key, res);\\n        return res;\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662966,
                "title": "simple-typescript-solution",
                "content": "# Approach\\nStarted by storing the memoized values in an object. Then used a `Map` instead which decreased execution time by 50ms.\\n\\nImplementation is simple:\\n1. Check if value exists for current combination of inputs.\\n2. If exists, return that value.\\n3. If does not exist, run the function and get the value.\\n4. Store that value in the map and return the value.\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const memoizedMap = new Map<string, number>();\\n    return function(...args) {\\n      const key = args.join(\\'-\\');\\n      if (memoizedMap.has(key)) {\\n        return memoizedMap.get(key);\\n      }\\n\\n      const value = fn(...args);\\n      memoizedMap.set(key, value);\\n      return value;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const memoizedMap = new Map<string, number>();\\n    return function(...args) {\\n      const key = args.join(\\'-\\');\\n      if (memoizedMap.has(key)) {\\n        return memoizedMap.get(key);\\n      }\\n\\n      const value = fn(...args);\\n      memoizedMap.set(key, value);\\n      return value;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652722,
                "title": "easy-clean-ts-solution-faster-than-90-using-map",
                "content": "\\n# Complexity\\nTime complexity: O(NlogN)\\nSpace complexity: O(N)\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const memo = new Map();\\n    \\n    return function(...args) {\\n        const key = args.join(\\'-\\');\\n        if (memo.has(key)) {\\n            return memo.get(key);\\n        }\\n        const res = fn(...args);\\n        memo.set(key, res);\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const memo = new Map();\\n    \\n    return function(...args) {\\n        const key = args.join(\\'-\\');\\n        if (memo.has(key)) {\\n            return memo.get(key);\\n        }\\n        const res = fn(...args);\\n        memo.set(key, res);\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641310,
                "title": "very-easy-to-understand-just-three-line-code-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const obj = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        return obj[key]?? (obj[key] = fn(...args))\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const obj = {}\\n    return function(...args) {\\n        const key = JSON.stringify(args)\\n        return obj[key]?? (obj[key] = fn(...args))\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641201,
                "title": "super-easy-to-understand-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(N), not sure\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache={};\\n    return function(...args) {\\n        let key=JSON.stringify(args);\\n        if(key in cache)\\n            return cache[key];\\n        cache[key]=fn(...args);\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache={};\\n    return function(...args) {\\n        let key=JSON.stringify(args);\\n        if(key in cache)\\n            return cache[key];\\n        cache[key]=fn(...args);\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624733,
                "title": "easy-implementation-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse map to store args \\'stringified\\' value and function call results.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf same args are supplied don\\'t call the original method but return the results\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO log(n) for retriving and inserting values into the map where n is number of calls to the function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO log(n) extra space used.\\n# Code\\n```\\ntype Fn = (...params: any) => any;\\n\\nfunction memoize(fn: Fn): Fn {\\n\\tconst resultsArgsMap = new Map();\\n\\treturn function (...args) {\\n\\t\\tconst argsString = JSON.stringify(args);\\n\\t\\tif (resultsArgsMap.has(argsString)) {\\n\\t\\t\\treturn resultsArgsMap.get(argsString);\\n\\t\\t} else {\\n\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\tresultsArgsMap.set(argsString, result);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any;\\n\\nfunction memoize(fn: Fn): Fn {\\n\\tconst resultsArgsMap = new Map();\\n\\treturn function (...args) {\\n\\t\\tconst argsString = JSON.stringify(args);\\n\\t\\tif (resultsArgsMap.has(argsString)) {\\n\\t\\t\\treturn resultsArgsMap.get(argsString);\\n\\t\\t} else {\\n\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\tresultsArgsMap.set(argsString, result);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616317,
                "title": "simple-key-mindset-a-general-solution-to-all-cache-system-memoized-system",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe cached the same set of the params, including the order, quantity\\nso we expect: \\n\\n\\tsave(1,2,3);\\n\\tcheck(1,2,3); // true\\n\\tcheck(1,2,2); // false\\n\\tcheck(4,5,6); // false\\n\\tcheck(3,2,1); // false\\n\\tcheck(0,1,2,3) // false\\n\\n\\n# Approach\\nthe key point is using JSON.stringify to make it a fixed set\\n\\n`JSON.strinify({ ... args})`\\n\\nthen you can use Map() or Object to store it, and check if existed\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let memoMap = new Map();\\n    return function(...args) {\\n        let value = memoMap.get(JSON.stringify({ ...args }));\\n        if (value !== undefined) {\\n            return value;\\n        } else {\\n            let fnResult = fn(...args);\\n            memoMap.set(JSON.stringify({ ...args }), fnResult)\\n            return fnResult;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let memoMap = new Map();\\n    return function(...args) {\\n        let value = memoMap.get(JSON.stringify({ ...args }));\\n        if (value !== undefined) {\\n            return value;\\n        } else {\\n            let fnResult = fn(...args);\\n            memoMap.set(JSON.stringify({ ...args }), fnResult)\\n            return fnResult;\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605693,
                "title": "simple-js-solution-using-closure-ans-object",
                "content": "# Intuition\\nIt needs to keep track of previously called arguments, it is evident that we need to store the [args,res] pair and it must be using js closure to be able to access the stored in every fresh call to the passed function\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain a cache variable in the closure function. The main chllange here is that there could be any number of arguments. hence we need to use rest and spread operators. also key for an object (cache) needs to be a string, hence we comnbine all the arg with \" , \" and make a uniqu key to save the res.\\nNow whenever a call is made we fist check in the cache object and if the data is not present we call the fun and save the response in our cache object and return the response.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = args.join(\\',\\');\\n        if(cache[key]!== undefined) return cache[key];\\n        const res = fn(...args);\\n        cache[key] = res;\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = {};\\n    return function(...args) {\\n        const key = args.join(\\',\\');\\n        if(cache[key]!== undefined) return cache[key];\\n        const res = fn(...args);\\n        cache[key] = res;\\n        return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593714,
                "title": "easy-javascript-solution-using-map-object",
                "content": "# Intuition\\nUsing MAP Object in Javascript we first check wheather we compute result for corresponding parameters earliar or not , if yes then we simple return value corresponding to parameters that we have store in MAP Object.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let obj = new Map();\\n    return function (...args) {\\n        if (obj.has(args.join())) {\\n            return obj.get(args.join())\\n        } else {\\n            const val = fn(...args);\\n            obj.set(args.join(), val);\\n            return val\\n        }\\n    }\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let obj = new Map();\\n    return function (...args) {\\n        if (obj.has(args.join())) {\\n            return obj.get(args.join())\\n        } else {\\n            const val = fn(...args);\\n            obj.set(args.join(), val);\\n            return val\\n        }\\n    }\\n}\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588216,
                "title": "javascript-challenge-day-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n=> When a function is called multiple times with the same arguments, the result is cached to avoid redundant computations.\\n=> The cache stores results using a key-value pair structure, where the key is a string representation of the arguments, and the value is the corresponding function result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n=> Create a cache object to store the cached results and initialize a callCount variable to track the number of function calls.\\n\\n=> Return a new function that acts as a wrapper around the original function (fn). This function takes any number of arguments using the spread operator (...args).\\n\\n=> Convert the arguments array (args) into a string representation (key) using JSON.stringify(). This string will be used as the key to check if the result has already been cached.\\n\\n=> Check if the key exists in the cache object. If it does, return the cached result.\\n\\n=> If the key is not found in the cache, it means the function hasn\\'t been called with these arguments before. Increment the callCount variable.\\n\\n=> Execute the original function (fn) with the provided arguments (fn(...args)) to obtain the result.\\n\\n=> Store the result in the cache object using the key and the computed result.\\n\\n=> Return the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = {};\\n  let callCount = 0;\\n\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n\\n    callCount++;\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = {};\\n  let callCount = 0;\\n\\n  return function(...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (key in cache) {\\n      return cache[key];\\n    }\\n\\n    callCount++;\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n\\n\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587090,
                "title": "closure-typescript",
                "content": "# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (!cache.hasOwnProperty(key)){\\n            cache[key] = fn(...args);\\n        }\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const cache = {};\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n        if (!cache.hasOwnProperty(key)){\\n            cache[key] = fn(...args);\\n        }\\n        return cache[key];\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1867509,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891977,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 2008633,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891864,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891705,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1981162,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1907315,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1892072,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891823,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 2028870,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1867509,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891977,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 2008633,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891864,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891705,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1981162,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1907315,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1892072,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1891823,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 2028870,
                "content": [
                    {
                        "username": "dkapustin1998",
                        "content": "incorrect test cases."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@mishamio](/mishamio)  Coorection, I just clicked \\'show all\\' and it has over 1000 calls."
                    },
                    {
                        "username": "mishamio",
                        "content": "[@Pellyyy](/Pellyyy) I also have a problem. When I run it, it passes all three test cases but when I try to submit it, I get \\'Time Limit Exceeded\\' and it says \\'19/20 testcases passed\\'. Idk how big the test case should be, but this one has like ~100 calls to the function."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Which test case is incorrect? I didn\\'t run into any issues. "
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "great day to start straight from editorial \\uD83D\\uDE04"
                    },
                    {
                        "username": "tamalCodes",
                        "content": "TBH i find the problem \"hard\" to understand. I do understand and can implement code to memoize a function so that it doesnot calculate stuffs for same input, But this question in partcular i really don\\'t understand what they want us to do. I really wish they explained the question better."
                    },
                    {
                        "username": "aman1320",
                        "content": "Leetcode should add a feature to report a test case!!"
                    },
                    {
                        "username": "amansingh22160811",
                        "content": "On top right corner in problem statement section they have feedback option where you can report"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Code failing for last test case:\n\"sum\"\n[\"call\",\"call\",\"getCallCount\"]\n[[0,0],[0,0],[]]\nOutput: [0,0,2]\nExpected: [0,0,1]\n\nEdit:\nIt fails for if(!res[argsCache])\nIt passes for if(!(argsCache in res)).\n\nCan someone please explain why? Thanks"
                    },
                    {
                        "username": "RahulRC",
                        "content": "Good!! :)"
                    },
                    {
                        "username": "Mek_san",
                        "content": "if(!res[argsCache]) \\nthis code is for checking the truthness of the value of perticular key.\\nit is not for checking whether the exist or not.\\nlike consider \\nsum(0,0) =0 called so res will become\\n{\\n   \"0,0\":0\\n}\\n\\nnow again sum(0,0) called then \\n!res[argsCache] will be 1 as res[argsCache] is 0 & !0 =1\\nand 1 indicates that that key does not exist but in realilty the key exist it is just that the value that key hold is falsy - (0,\"\",null,undefined,false).\\n\\nin case of !(argsCache in res) , this (argsCache in res) return true only if key exist in respective of value that key hold\\n{\\n   \"0,0\":0\\n}\\nso for sum(0,0) the (argsCache in res) will be true & thus !(argsCache in res) will be false- indicating key already exist\\n\\nobj = {\\n    key1 : 0,\\n    key2 : null,\\n    key3 : undefined,\\n}\\n\\nkey1 in obj // true\\nkey2 in obj // true\\nkey3 in obj // true\\n\\nkey4 in obj // false\\n\\n:)"
                    },
                    {
                        "username": "I010101",
                        "content": "Hint:-\\n1. Initialize: Create an empty cache object: `const cache = {};`\\n2. Wrap Function: Define a memoization function that wraps the original function.\\n3. Unique Key: Generate a unique key using the function\\'s arguments: `const key = args.join(\",\");`\\n4. Check Cache: If the result exists in the cache, return it; otherwise, proceed.\\n5. Calculate & Cache: Execute the original function and store the result in the cache: `cache[key] = fn(...args);`\\n6. Return Cached Result: Return the cached result: `return cache[key];`"
                    },
                    {
                        "username": "yulianloaiza",
                        "content": "I\\'d understood this problem wrong. \\nI thought that at any given moment, you could have a call with sum, followed by a call\\nwith factorial, and so on, each with their respective parameters. So I was confused as to\\nhow to make a switch or similar that depended on the particular function.\\n\\nIn reality, the problem is to build a generic function, that can memoize the results\\nof either a factorial, a sum , or a fib function, taking in two parameters at most."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Try This \\n`\\nfunction memoize(fn,memo={}) {\\n    return function(...args) {\\n        let id=JSON.stringify(args)\\n        if(id in memo){\\n            return memo[id]\\n        }\\n            let x=fn(...args)\\n            memo[id]=x\\n            return x;\\n\\n    }\\n}\\n`"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "GENTLE REMINDER: Please don\\'t put solutions here \\uD83D\\uDE4F"
                    },
                    {
                        "username": "MikeSparrow",
                        "content": "As a few have mentioned, one of the test cases may confuse you. There are no incorrect cases here; the behavior is as expected. I advise you to take a look at falsy values."
                    },
                    {
                        "username": "tenzinwoz",
                        "content": "I believe the way the question was asked and the test cases were given was quite complicated. The solution was very simple if you know how to store key value pairs in object and just a simple stringily method."
                    }
                ]
            },
            {
                "id": 1892172,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 2065548,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 2064990,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 2058927,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 2013843,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 1972140,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 1955374,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 1951038,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 1948329,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            },
            {
                "id": 1939804,
                "content": [
                    {
                        "username": "Mshashikanth",
                        "content": "memorization technique for dp problems bring time complexity to O(n) in most cases"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "I'm getting a correct output in the debugger and locally in terminal using Node, but an incorrect output when I run. Any comments are welcome. Code:\n\n```(javascript)\nvar cache = {\n    a: [],\n    b: [],\n    res: []\n}\n\nfunction memoize(fn) {\n    return function (...args) {\n        if (args.length === 1) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            if (aIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.res.push(fn(args[0]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n        if (args.length === 2) {\n            var aIdx = cache.a.findIndex((e) => e === args[0])\n            var bIdx = cache.b.findIndex((e) => e === args[1])\n            if (aIdx != -1 && bIdx != -1) {\n                return cache.res[aIdx]\n            } else {\n                cache.a.push(args[0])\n                cache.b.push(args[1])\n                cache.res.push(fn(args[0], args[1]))\n                return cache.res[cache.res.length - 1]\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "thatdamn",
                        "content": "Haha sneaky that last test case, good practice."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "why that doesn\\'t work in the last testcase? \\n\\n `/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = []\\n    let inputs = []\\n    return function(...args) {\\n        let res = []\\n        let index = 0\\n        if(!inputs.includes(JSON.stringify(args))){\\n            inputs.push(JSON.stringify(args))\\n            res = fn(...args)\\n            cache.push(res)\\n            return res\\n        }\\n        else {\\n            index = inputs.indexOf(JSON.stringify(args))\\n            return cache[index]\\n        }\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */`"
                    },
                    {
                        "username": "roman-t",
                        "content": "hello hope you are having a great day i have a small doubut in my approch to the problem i hope you can share your valuable knowledge and point me out where im wrong i would really appreciate it `your inline code...your inline code... `your inline code...your inline code...``function memoize(fn) {\\n    let memory = [];\\n    let fnCall = 0;\\n    return function(...args) {\\n        if(args[0].length === 0) {\\n            return fnCall;\\n        }\\n      if(JSON.stringify(memory).includes(JSON.stringify(args))) {\\n        return memory[memory.findIndex(item => \\n        JSON.stringify(item) === JSON.stringify(args)) + 1]\\n      } else {\\n        memory.push([...args]);\\n        const result = \\n        args[0].length > 1 ? fn(args[0][0], args[0][1]) :\\n        fn(args[0]);\\n        fnCall++;\\n        memory.push(result);\\n        return (result);\\n      }\\n    }\\n}`\\n\\nas you can see in the code i have used a empty array to store the cache and namet it memory and then use it for the storing and returning the data.\\nI wrote this code in [one compiler](https://onecompiler.com/javascript/3zgw6uvtp) there i ran the code and the output was correct there but once i ran it here it showed NaN for all the new calculated result for the first case but its working there but not here if anyone knows i would appreciate your valuable responce"
                    },
                    {
                        "username": "MahaCodeIt",
                        "content": "why does this not work? \\n```\\nfunction memoize(fn) {\\n    return function(...args) {\\n        memoizedFunction = memoize(fn(...args));\\n        return fn(...args);\\n    }\\n}"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "we are supposed to memoize (cache) the values. That means you should not be calling fn(...args) for everything. fn(...args) should only be called if you have not seen the value before. To memoize the value, store the result in a javascript object and retrieve it if you ever see it again. e.g let memo = {};  if (args in memo) //retrieve it;  else {\\n//store the result in the memo, and return the value}"
                    },
                    {
                        "username": "renatoximenes",
                        "content": "For each [ ] in [[2,2],[2,2],[ ],[1,2],[ ]] the test gives the input \"console.log(callCount)\". It is not necessary to implement the callCount counter as it is already built into the functions that are sent by the test. And you don't need to define the functions as they are sent as input parameter.\nyou need to think the test like:\n console.log(memoizedFn(2, 2))\n console.log(memoizedFn(2, 2))\n console.log(callCount) \n console.log(memoizedFn(1, 2))\n console.log(callCount)"
                    },
                    {
                        "username": "ahimCode",
                        "content": "function memoize(fn) {\\n  const cache = {};\\n\\n  return function (...args) {\\n    const key = JSON.stringify(args);\\n\\n    if (cache.hasOwnProperty(key)) {\\n      return cache[key];\\n    }\\n\\n    const result = fn(...args);\\n    cache[key] = result;\\n\\n    return result;\\n  };\\n}\\n"
                    },
                    {
                        "username": "imgauravrawat8",
                        "content": "i am getting wrong output : for this test case\\nInput\\n\"sum\"\\n[\"call\",\"call\",\"getCallCount\"]\\n[[0,0],[0,0],[]]\\nOutput\\n[0,0,2]\\nExpected\\n[0,0,1]\\n\\nand this is my code:\\n\\nfunction memoize(fn) {\\n    const cache = {};\\n\\n    return function(...args) {\\n        const key = JSON.stringify(args);\\n\\n        if(cache[key]) {\\n            return cache[key];\\n        }\\n\\n        const result = fn.apply(this,args);\\n        cache[key] = result;\\n        return result;\\n    }\\n}\\n\\n\\ncan anyone help me in this......"
                    },
                    {
                        "username": "maxevilmind",
                        "content": "Who wrote this description and test cases?"
                    }
                ]
            }
        ]
    }
]