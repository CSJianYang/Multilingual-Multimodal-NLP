[
    {
        "title": "Node With Highest Edge Score",
        "question_content": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.\n&nbsp;\nExample 1:\n\nInput: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.\n\nExample 2:\n\nInput: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0.\n\n&nbsp;\nConstraints:\n\n\tn == edges.length\n\t2 <= n <= 105\n\t0 <= edges[i] < n\n\tedges[i] != i",
        "solutions": [
            {
                "id": 2422312,
                "title": "counting",
                "content": "Just need to use 64-bit integer when counting the score to avoid overflow.\\n\\n**C++**\\n```cpp\\nint edgeScore(vector<int>& edges) {\\n    vector<long long> score(edges.size());\\n    for (int i = 0; i < edges.size(); ++i)\\n        score[edges[i]] += i;\\n    return max_element(begin(score), end(score)) - begin(score);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint edgeScore(vector<int>& edges) {\\n    vector<long long> score(edges.size());\\n    for (int i = 0; i < edges.size(); ++i)\\n        score[edges[i]] += i;\\n    return max_element(begin(score), end(score)) - begin(score);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422139,
                "title": "c-easy-solution-o-n-without-graph-counting",
                "content": "Upvote if it helps :)\\n```\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> score(n);\\n\\t\\t//score[i] = sum of all the nodes that have an edge pointing to i.\\n        for(int i = 0; i < n; i++){\\n            score[edges[i]] += i;\\n        }\\n        long long mx = INT_MIN;\\n        int idx = 0;\\n\\t\\t//Finding the maximum score and it\\'s index\\n        for(int i = 0; i < n; i++){\\n            if(score[i] > mx){\\n                mx = score[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> score(n);\\n\\t\\t//score[i] = sum of all the nodes that have an edge pointing to i.\\n        for(int i = 0; i < n; i++){\\n            score[edges[i]] += i;\\n        }\\n        long long mx = INT_MIN;\\n        int idx = 0;\\n\\t\\t//Finding the maximum score and it\\'s index\\n        for(int i = 0; i < n; i++){\\n            if(score[i] > mx){\\n                mx = score[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422406,
                "title": "c-easy-explanation-in-comments-finding-in-degree-in-graph",
                "content": "In simple language. **Question is about finding a node having maximum in-degree in given graph.**\\n*In-Degree for a node is number of incoming edges towards a node.*\\n\\n\\n**The Logic behind approach  : )**\\n* We know that if we are at index \\'i\\' in edges array and say it has a value \\'val\\' at this index. Then this means there is a edge from node named \\'i\\' to node named \\'val\\'.\\n* This also means node \\'i\\' contributes to in-degree of node \\'val\\' by one.\\n* So if edges array is like say [val,val,val]. This means in-degree of node named val is 3. Bcoz there are 3 edges coming from nodes 0,1,2 to some node \\'val\\'.\\n\\n**The approach  : )**\\n1. So count in-degree of each node and store it in a seperate array (say inDegree) which is of size = n. (where n is total no. of nodes)\\n2. Say value at index \\'i\\' of inDegree array is \\'b\\'. That means node \\'i\\' has in-degree value \\'b\\'.\\n2. Traverse this inDegree array to get the max in-degree value of all the nodes.\\n3. While checking for the max value in inDegree array also keep track of index where we are getting this max value.\\n4. Finally our index where we got the max in-degree value is our required node with maximum in-degree.\\n5. Happily return that found index **: )**\\n\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        // This array will store in-degree for each node.\\n        vector<long long> inDegree(n,0);\\n        \\n        // This variable will store max in-degree number. It means max of all the values in \\'inDegree\\' vector.\\n        long long maxVal = LONG_MIN;\\n        \\n        \\n        // This will store index of max value in \\'inDegree\\' vector. This index will correspond to our required node with maximum in-degree.\\n        int minIndx = -1;\\n        \\n        \\n        // Traverse and fill the \\'inDegree\\' vector.\\n        for(int i=0;i<edges.size();i++)\\n            inDegree[edges[i]] += i;\\n        \\n        \\n        \\n        // Traversed our \\'inDegree\\' vector to get max value (max in-degree) in array and keep record of the index where we get that max in-degree value.\\n        for(int i=0;i<n;i++)\\n        {\\n            if(maxVal < inDegree[i])\\n            {\\n                maxVal = inDegree[i];\\n                minIndx = i;\\n            }\\n                \\n        }\\n        \\n        // Happily return the index of maximum in-degree. That is our node with maximum in-degree.\\n        return minIndx;\\n    }\\n};\\n```\\n\\n**Happy coding : )**",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        // This array will store in-degree for each node.\\n        vector<long long> inDegree(n,0);\\n        \\n        // This variable will store max in-degree number. It means max of all the values in \\'inDegree\\' vector.\\n        long long maxVal = LONG_MIN;\\n        \\n        \\n        // This will store index of max value in \\'inDegree\\' vector. This index will correspond to our required node with maximum in-degree.\\n        int minIndx = -1;\\n        \\n        \\n        // Traverse and fill the \\'inDegree\\' vector.\\n        for(int i=0;i<edges.size();i++)\\n            inDegree[edges[i]] += i;\\n        \\n        \\n        \\n        // Traversed our \\'inDegree\\' vector to get max value (max in-degree) in array and keep record of the index where we get that max in-degree value.\\n        for(int i=0;i<n;i++)\\n        {\\n            if(maxVal < inDegree[i])\\n            {\\n                maxVal = inDegree[i];\\n                minIndx = i;\\n            }\\n                \\n        }\\n        \\n        // Happily return the index of maximum in-degree. That is our node with maximum in-degree.\\n        return minIndx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427781,
                "title": "java-c-one-pass",
                "content": "#### Java\\n```java\\npublic int edgeScore(int[] edges) {\\n        Map<Integer, Integer> scores = new HashMap<>();\\n        int highestScoreNode = 0;\\n        for (int i = 0; i < edges.length; i++) {\\n            scores.put(edges[i], scores.getOrDefault(edges[i], 0) + i);\\n            int lastScore = scores.get(edges[i]), highestScore = scores.getOrDefault(highestScoreNode, 0);\\n            if (lastScore > highestScore)\\n                highestScoreNode = edges[i];\\n            else if (lastScore == highestScore)\\n                highestScoreNode = Math.min(edges[i], highestScoreNode);\\n        }\\n        return highestScoreNode;\\n    }\\n```\\n\\n#### C++\\n```c++\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int, long> scores;\\n        int highestScoreNode = 0;\\n        for (int i = 0; i < edges.size(); i++) {\\n            scores[edges[i]] += i;\\n            int lastScore = scores[edges[i]], highestScore = scores[highestScoreNode];\\n            if (lastScore > highestScore)\\n                highestScoreNode = edges[i];\\n            else if (lastScore == highestScore)\\n                highestScoreNode = min(edges[i], highestScoreNode);\\n        }\\n        return highestScoreNode;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int edgeScore(int[] edges) {\\n        Map<Integer, Integer> scores = new HashMap<>();\\n        int highestScoreNode = 0;\\n        for (int i = 0; i < edges.length; i++) {\\n            scores.put(edges[i], scores.getOrDefault(edges[i], 0) + i);\\n            int lastScore = scores.get(edges[i]), highestScore = scores.getOrDefault(highestScoreNode, 0);\\n            if (lastScore > highestScore)\\n                highestScoreNode = edges[i];\\n            else if (lastScore == highestScore)\\n                highestScoreNode = Math.min(edges[i], highestScoreNode);\\n        }\\n        return highestScoreNode;\\n    }\\n```\n```c++\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int, long> scores;\\n        int highestScoreNode = 0;\\n        for (int i = 0; i < edges.size(); i++) {\\n            scores[edges[i]] += i;\\n            int lastScore = scores[edges[i]], highestScore = scores[highestScoreNode];\\n            if (lastScore > highestScore)\\n                highestScoreNode = edges[i];\\n            else if (lastScore == highestScore)\\n                highestScoreNode = min(edges[i], highestScoreNode);\\n        }\\n        return highestScoreNode;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422228,
                "title": "java-array-problem-score-of-node-edges-i-i",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n_length=edges.length;\\n\\t\\t//to avoid overflow we will take long size score array \\n        long score_of_node[]=new long[n_length];\\n        for(int i=0; i<n_length; i++){\\n            score_of_node[edges[i]]+=i; //score of the node will be update to (prev score + incomming node) here every i denotes income incomming vertex\\n        }\\n        int max_ans_index=0;\\n        \\n        for(int i=0; i<n_length; i++){\\n            if(score_of_node[i]>score_of_node[max_ans_index]){\\n                max_ans_index=i; // simply just find the node with maximum score and\\n            }\\n        }\\n        return max_ans_index; // return the node\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n_length=edges.length;\\n\\t\\t//to avoid overflow we will take long size score array \\n        long score_of_node[]=new long[n_length];\\n        for(int i=0; i<n_length; i++){\\n            score_of_node[edges[i]]+=i; //score of the node will be update to (prev score + incomming node) here every i denotes income incomming vertex\\n        }\\n        int max_ans_index=0;\\n        \\n        for(int i=0; i<n_length; i++){\\n            if(score_of_node[i]>score_of_node[max_ans_index]){\\n                max_ans_index=i; // simply just find the node with maximum score and\\n            }\\n        }\\n        return max_ans_index; // return the node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422163,
                "title": "java-python-3-iterative-o-n-codes-w-brief-explanation-and-analysis",
                "content": "1. Traverse the input `edges`, acculumate the score for each edge-pointed node;\\n2. Traverse the `scores` array and find the solution.\\n\\n**Note:** Java code need a `long` type `scores` array, otherwise it would cause `int` overflow that will result wrong answer.\\n```java\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length, ans = 0;\\n        long[] scores = new long[n];\\n        for (int src = 0; src < n; ++src) {\\n            scores[edges[src]] += src;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (scores[i] > scores[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n, ans = len(edges), 0\\n        scores = [0] * n\\n        for src, tgt in enumerate(edges):\\n            scores[tgt] += src\\n        for i, score in enumerate(scores):\\n            if score > scores[ans]:\\n                ans = i\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = edges.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length, ans = 0;\\n        long[] scores = new long[n];\\n        for (int src = 0; src < n; ++src) {\\n            scores[edges[src]] += src;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            if (scores[i] > scores[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n, ans = len(edges), 0\\n        scores = [0] * n\\n        for src, tgt in enumerate(edges):\\n            scores[tgt] += src\\n        for i, score in enumerate(scores):\\n            if score > scores[ans]:\\n                ans = i\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2422253,
                "title": "easy-understanding-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        vector<long long int> ans (edges.size(), 0);\\n\\t\\t// Calculate the indegree score of the graph.\\n\\t\\t// indegree score : ans[edges[i]] += i;\\n        for (int i = 0; i < edges.size(); i++)\\n            ans[edges[i]] += i;\\n        long long int a = INT_MIN;\\n        long long int temp = INT_MIN;\\n\\t\\t// The one with maximum indegree, will be the answer.\\n\\t\\t// Incase two nodes have same indegree, return the smallest.\\n        for (int i = 0; i < ans.size(); i++)\\n        {\\n            if (temp < ans[i])\\n            {\\n                a = i;\\n                temp = ans[i];\\n            }\\n        }   \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        vector<long long int> ans (edges.size(), 0);\\n\\t\\t// Calculate the indegree score of the graph.\\n\\t\\t// indegree score : ans[edges[i]] += i;\\n        for (int i = 0; i < edges.size(); i++)\\n            ans[edges[i]] += i;\\n        long long int a = INT_MIN;\\n        long long int temp = INT_MIN;\\n\\t\\t// The one with maximum indegree, will be the answer.\\n\\t\\t// Incase two nodes have same indegree, return the smallest.\\n        for (int i = 0; i < ans.size(); i++)\\n        {\\n            if (temp < ans[i])\\n            {\\n                a = i;\\n                temp = ans[i];\\n            }\\n        }   \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428622,
                "title": "python-elegant-short-4-lines-defaultdict",
                "content": "```\\ndef edgeScore(self, edges: List[int]) -> int:\\n\\tscore = defaultdict(int)\\n\\n\\tfor u, v in enumerate(edges):\\n\\t\\tscore[v] += u\\n\\n\\treturn max(score, key=lambda x: (score[x], -x))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef edgeScore(self, edges: List[int]) -> int:\\n\\tscore = defaultdict(int)\\n\\n\\tfor u, v in enumerate(edges):\\n\\t\\tscore[v] += u\\n\\n\\treturn max(score, key=lambda x: (score[x], -x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2422299,
                "title": "c-use-indegree-logic-simple-and-efficient",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();\\n        vector<unsigned int> indeg(n, 0); //it stores indegree for each node\\n        for(int i=0; i<n; i++) indeg[edges[i]] += i; //find indegree based on node label\\n        unsigned int maxi=0;\\n        int val=0;\\n\\t\\t\\n\\t\\t//find the node with max indegree, if two nodes have same max indegree then find min label node\\n        for(int i=n-1; i>=0; i--) \\n            if(indeg[i] >= maxi)\\n            {\\n                maxi = indeg[i];\\n                val = i;\\n            }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();\\n        vector<unsigned int> indeg(n, 0); //it stores indegree for each node\\n        for(int i=0; i<n; i++) indeg[edges[i]] += i; //find indegree based on node label\\n        unsigned int maxi=0;\\n        int val=0;\\n\\t\\t\\n\\t\\t//find the node with max indegree, if two nodes have same max indegree then find min label node\\n        for(int i=n-1; i>=0; i--) \\n            if(indeg[i] >= maxi)\\n            {\\n                maxi = indeg[i];\\n                val = i;\\n            }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422137,
                "title": "java-reversing-the-edge",
                "content": "\\n    class pair{\\n    int node;\\n    long score;\\n    pair(int node1,long score1){\\n        node=node1;\\n        score=score1;\\n    }\\n}\\n    \\n\\tclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        //taking a priorityQueue for taking out smallest index\\n        Queue<pair> q=new PriorityQueue<>((a,b)->a.score==b.score?a.node-b.node:Long.compare(b.score,a.score));\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        //reversing the graph\\n        for(int i=0;i<n;i++){\\n            adj.get(edges[i]).add(i);\\n        }\\n        //looping over the adj list\\n        for(int i=0;i<n;i++){\\n            List<Integer> take=adj.get(i);\\n            long sum=0;\\n            if(!take.isEmpty())\\n                for(int u:take)sum+=u;\\n            \\n            q.add(new pair(i,sum));\\n            \\n        }\\n        return q.poll().node;\\n    }\\n}",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        //taking a priorityQueue for taking out smallest index\\n        Queue<pair> q=new PriorityQueue<>((a,b)->a.score==b.score?a.node-b.node:Long.compare(b.score,a.score));\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2422083,
                "title": "java-simple-o-n-solution-with-comments",
                "content": "Pay attention to the **overflow error** with **hidden cases in contest**.\\n```\\n10^5 * 10 ^5 > 2^31 -1\\n```\\n\\nUse `long` for score to avoid overflow error.\\n\\nTime: O(N)\\nSpace: O(N)\\n```\\nclass Solution {\\n  public int edgeScore(int[] edges) {\\n    final int n = edges.length;\\n    // avoid overflow!!!\\n    long[] score = new long[n];\\n    // i == label\\n    for (int i = 0; i < n; i++) {\\n      // add each label to pointing node\\n      score[edges[i]] += i;\\n    }\\n\\n    // get smallest index with highest edge score\\n    int result = 0;\\n    for (int i = 0; i < n; i++) {\\n      if (score[i] > score[result]) {\\n        result = i;\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n10^5 * 10 ^5 > 2^31 -1\\n```\n```\\nclass Solution {\\n  public int edgeScore(int[] edges) {\\n    final int n = edges.length;\\n    // avoid overflow!!!\\n    long[] score = new long[n];\\n    // i == label\\n    for (int i = 0; i < n; i++) {\\n      // add each label to pointing node\\n      score[edges[i]] += i;\\n    }\\n\\n    // get smallest index with highest edge score\\n    int result = 0;\\n    for (int i = 0; i < n; i++) {\\n      if (score[i] > score[result]) {\\n        result = i;\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423989,
                "title": "c-easy-solution-o-n-without-graph-counting-o-n",
                "content": "\\n**C++ Code || O(n) - > Space+Time \\n  ```\\n int edgeScore(vector<int>& edges) {\\n        vector<long long>v(edges.size(), 0);\\n        for(int i=0; i<edges.size(); i++)\\n            v[edges[i]]+=i;\\n        long long mx=INT_MIN; int res;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(v[i]>mx) {\\n                mx=v[i]; res=i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nPlease Upvote \\nHappy Coding",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\n int edgeScore(vector<int>& edges) {\\n        vector<long long>v(edges.size(), 0);\\n        for(int i=0; i<edges.size(); i++)\\n            v[edges[i]]+=i;\\n        long long mx=INT_MIN; int res;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(v[i]>mx) {\\n                mx=v[i]; res=i;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422372,
                "title": "python-easy-approach-hashmap",
                "content": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n\\n        n = len(edges)\\n        cnt = defaultdict(int)\\n        ans = 0\\n        \\n\\t\\t// we have the key stores the node edges[i], and the value indicates the edge score.\\n        for i in range(n):\\n            cnt[edges[i]] += i\\n\\n        m = max(cnt.values())\\n\\n\\t\\t// In the second iteration, i is also the index of the node. So the first one meets == m, is the smallest index.\\n        for i in range(n):\\n            if cnt[i] == m:\\n                ans = i\\n                break\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n\\n        n = len(edges)\\n        cnt = defaultdict(int)\\n        ans = 0\\n        \\n\\t\\t// we have the key stores the node edges[i], and the value indicates the edge score.\\n        for i in range(n):\\n            cnt[edges[i]] += i\\n\\n        m = max(cnt.values())\\n\\n\\t\\t// In the second iteration, i is also the index of the node. So the first one meets == m, is the smallest index.\\n        for i in range(n):\\n            if cnt[i] == m:\\n                ans = i\\n                break\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422126,
                "title": "c-simple-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();                                        // number of nodes\\n        vector<unsigned int> indegree(n,0);             // storing the indegree value\\n        \\n        // finding the node submission on particular node\\n        for(int i=0;i<n;i++)\\n        {\\n            indegree[edges[i]] += i;                                   // for each node count the summision of incoming nodes\\n        }\\n        \\n        unsigned int mx=0;\\n        int ans=0;\\n\\t\\t\\n\\t\\t// start traversing from behind because if 2 nodes are having same indegree summison then return max one\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(mx<=indegree[i])\\n            {\\n                mx = indegree[i];\\n                ans = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();                                        // number of nodes\\n        vector<unsigned int> indegree(n,0);             // storing the indegree value\\n        \\n        // finding the node submission on particular node\\n        for(int i=0;i<n;i++)\\n        {\\n            indegree[edges[i]] += i;                                   // for each node count the summision of incoming nodes\\n        }\\n        \\n        unsigned int mx=0;\\n        int ans=0;\\n\\t\\t\\n\\t\\t// start traversing from behind because if 2 nodes are having same indegree summison then return max one\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(mx<=indegree[i])\\n            {\\n                mx = indegree[i];\\n                ans = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422225,
                "title": "easy-java-solution-map",
                "content": "# **Node With Highest Edge Score**\\n# **Easy Java Solution**\\nPay attention to the **overflow** problem in this problem.\\nIt was hidden during contest.\\nUse **long** to keep track maximum edge score\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        //Creating a Hashmap\\n        HashMap<Integer,List<Integer>> map=new HashMap<Integer,List<Integer>>();\\n        //Score variable for keeping track of highest edge score\\n        long score=Integer.MIN_VALUE;\\n        //Index variable for storing answer\\n        int index=Integer.MAX_VALUE;\\n        for(int i=0;i<edges.length;i++){\\n            //If map does not contains Key then putting it to the hashmap\\n            if(!map.containsKey(edges[i])){\\n                List<Integer> list=new ArrayList<Integer>();\\n                list.add(i);\\n                map.put(edges[i],list);\\n            }\\n            //If map contains Key then adding the node directing to it in the list\\n            else{\\n                List<Integer> list=map.get(edges[i]);\\n                list.add(i);\\n            }\\n        }\\n        \\n        //HashMap contains nodes as key and value as list which contains all directing node to key node\\n        for(int key:map.keySet()){\\n            //Initializing a list which stores all nodes directing to key node\\n            List<Integer> list=map.get(key);\\n            long sum=0;\\n            //Taking sum of all directing nodes in sum variable\\n            for(int node:list){\\n                sum+=node;\\n            }\\n            //If sum>score then updating the score and iindex\\n            if(sum>score){\\n                score=sum;\\n                index=key;\\n            }\\n            //If sum==score then updating index with the smaller value from index and key\\n            else if(sum==score){\\n                index=Math.min(index,key);\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        //Creating a Hashmap\\n        HashMap<Integer,List<Integer>> map=new HashMap<Integer,List<Integer>>();\\n        //Score variable for keeping track of highest edge score\\n        long score=Integer.MIN_VALUE;\\n        //Index variable for storing answer\\n        int index=Integer.MAX_VALUE;\\n        for(int i=0;i<edges.length;i++){\\n            //If map does not contains Key then putting it to the hashmap\\n            if(!map.containsKey(edges[i])){\\n                List<Integer> list=new ArrayList<Integer>();\\n                list.add(i);\\n                map.put(edges[i],list);\\n            }\\n            //If map contains Key then adding the node directing to it in the list\\n            else{\\n                List<Integer> list=map.get(edges[i]);\\n                list.add(i);\\n            }\\n        }\\n        \\n        //HashMap contains nodes as key and value as list which contains all directing node to key node\\n        for(int key:map.keySet()){\\n            //Initializing a list which stores all nodes directing to key node\\n            List<Integer> list=map.get(key);\\n            long sum=0;\\n            //Taking sum of all directing nodes in sum variable\\n            for(int node:list){\\n                sum+=node;\\n            }\\n            //If sum>score then updating the score and iindex\\n            if(sum>score){\\n                score=sum;\\n                index=key;\\n            }\\n            //If sum==score then updating index with the smaller value from index and key\\n            else if(sum==score){\\n                index=Math.min(index,key);\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422145,
                "title": "easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        long dp[]=new long[n];\\n        for(int i=0;i<n;i++){\\n            dp[edges[i]]+=i;\\n        }\\n        long max=0;\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]>max){\\n                ans=i;\\n                max=dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        long dp[]=new long[n];\\n        for(int i=0;i<n;i++){\\n            dp[edges[i]]+=i;\\n        }\\n        long max=0;\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]>max){\\n                ans=i;\\n                max=dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422122,
                "title": "c-using-map-o-n-5-liner-very-simple-and-easy-to-understand-solution",
                "content": "```\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int, long long> mp;\\n        int mxi = 0;\\n        for(int i = 0; i < edges.size(); ++i){\\n            mp[edges[i]] += i;\\n            if(mp[mxi] < mp[edges[i]]){ mxi = edges[i]; }\\n            else if(mp[mxi] == mp[edges[i]] && mxi > edges[i]){ mxi = edges[i]; }\\n        }\\n        return mxi;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int, long long> mp;\\n        int mxi = 0;\\n        for(int i = 0; i < edges.size(); ++i){\\n            mp[edges[i]] += i;\\n            if(mp[mxi] < mp[edges[i]]){ mxi = edges[i]; }\\n            else if(mp[mxi] == mp[edges[i]] && mxi > edges[i]){ mxi = edges[i]; }\\n        }\\n        return mxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3225838,
                "title": "c-one-pass-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size(),i;\\n        vector<vector<int>> v(n);\\n        for(i = 0; i < n; i++){\\n            v[edges[i]].push_back(i);\\n        }\\n        long long int ans=0,sum=0,k=0;\\n        for(i=0;i<n;i++){\\n            sum = 0;\\n            for(auto &j: v[i])sum += j;\\n            if(sum>k){\\n                k = sum;\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size(),i;\\n        vector<vector<int>> v(n);\\n        for(i = 0; i < n; i++){\\n            v[edges[i]].push_back(i);\\n        }\\n        long long int ans=0,sum=0,k=0;\\n        for(i=0;i<n;i++){\\n            sum = 0;\\n            for(auto &j: v[i])sum += j;\\n            if(sum>k){\\n                k = sum;\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2440716,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n```\\nint edgeScore(vector<int>& edges) {\\n        vector<long long>ans(edges.size(),0);\\n        for(int i=0;i<edges.size();i++){\\n            ans[edges[i]]+=i;\\n            \\n        }\\n        int index=0;\\n        long long  score=ans[0];\\n        for(int i=1;i<ans.size();i++){\\n            if(ans[i]>score){\\n                score=ans[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint edgeScore(vector<int>& edges) {\\n        vector<long long>ans(edges.size(),0);\\n        for(int i=0;i<edges.size();i++){\\n            ans[edges[i]]+=i;\\n            \\n        }\\n        int index=0;\\n        long long  score=ans[0];\\n        for(int i=1;i<ans.size();i++){\\n            if(ans[i]>score){\\n                score=ans[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426043,
                "title": "just-sum-and-sort-it",
                "content": "class Solution {\\n       public:\\n       int edgeScore(vector<int>& edges) {\\n\\t     int n=edges.size();\\n        map<int,vector<int>> g;\\n        // push every parent of child in map;\\n        for(int i=0;i<n;i++){\\n           g[edges[i]].push_back(i);\\n        }\\n       // traverse through every node and find the number of parent pointing to it\\n\\t   //Take sum of all those and store it 2-D vector \\n        vector<vector<long long>> ans;\\n        for(auto it:g){\\n            long long sum=0;\\n            for(auto jt:it.second){\\n                sum+=jt;\\n            }\\n          ans.push_back({sum,it.first});\\n        }\\n        // Then sort the 2-D array in decreasing order,if sum is equal return the one with smaller        // index\\n        sort(ans.begin(),ans.end(),[&](vector<long long>&l,vector<long long>&r){\\n            if(l[0]==r[0]) return l[1]<r[1];\\n            \\n            return l[0]>r[0];\\n        });\\n        \\n\\t\\n        long long idx=ans[0][1];\\n       \\n        return (int)idx;\\n\\t\\t}\\n\\t\\t};\\n\\t\\t//PLease upvote if it is helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n       public:\\n       int edgeScore(vector<int>& edges) {\\n\\t     int n=edges.size();\\n        map<int,vector<int>> g;\\n        // push every parent of child in map;\\n        for(int i=0;i<n;i++){\\n           g[edges[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2425111,
                "title": "c-simple-easy-explanation-no-graph-needed-count",
                "content": "We need to find the node which has the highest edge score, i.e, if 2 -> 3 then 3 will have an edge score of 2.\\nIn the input we\\'re given an array where it\\'s i -> edge[i], so that particular edge[i] will have an edge score of i.\\n\\nSo, we traverse the array and keep a vector where we keep the sum of edge scores.\\n\\nThen we traverse the array and find out which has the highest edge score and return that particular node.\\n\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        long maxi = INT_MIN, ans = -1;\\n        vector<long> sum(n+1, 0);\\n        for(int i = 0; i < n; i++) {\\n            sum[edges[i]] += i;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(maxi < sum[i]) {\\n                maxi = sum[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity:- O(2N) as we\\'re doing two traversals.\\nSpace Complexity:- O(N) as we\\'re using an extra vector for storing the edge score counts.\\n\\nDo upvote, Happy Coding.!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        long maxi = INT_MIN, ans = -1;\\n        vector<long> sum(n+1, 0);\\n        for(int i = 0; i < n; i++) {\\n            sum[edges[i]] += i;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(maxi < sum[i]) {\\n                maxi = sum[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423461,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n        int maxV = -1;\\n        int maxIndex = -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            hm.put(edges[i], hm.getOrDefault(edges[i],0)+i);\\n            \\n            int val = hm.get(edges[i]);\\n            if(val>=maxV)\\n            {\\n                if(val>maxV)\\n                {\\n                    maxIndex = edges[i];  \\n                }\\n                else if(maxIndex == -1 ||(maxIndex>edges[i]))\\n                {\\n                    maxIndex = edges[i];\\n                }\\n                maxV = val;\\n            }       \\n        }       \\n        return maxIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\\n        int maxV = -1;\\n        int maxIndex = -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            hm.put(edges[i], hm.getOrDefault(edges[i],0)+i);\\n            \\n            int val = hm.get(edges[i]);\\n            if(val>=maxV)\\n            {\\n                if(val>maxV)\\n                {\\n                    maxIndex = edges[i];  \\n                }\\n                else if(maxIndex == -1 ||(maxIndex>edges[i]))\\n                {\\n                    maxIndex = edges[i];\\n                }\\n                maxV = val;\\n            }       \\n        }       \\n        return maxIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423099,
                "title": "c-easy-solution-o-n-without-graph-counting",
                "content": "```\\n\\n class Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n= edges.size();\\n        vector<long long int> score(n, 0);\\n        for (int i=0; i<n; i++)\\n        {\\n            score[edges[i]]+=i;\\n        }\\n        long long int temp=-1;\\n        int index=-1;\\n        for (int i=0; i<n; i++)\\n        {\\n            if (score[i]>temp)\\n            {\\n                index= i;\\n                temp= score[i];\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n class Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n= edges.size();\\n        vector<long long int> score(n, 0);\\n        for (int i=0; i<n; i++)\\n        {\\n            score[edges[i]]+=i;\\n        }\\n        long long int temp=-1;\\n        int index=-1;\\n        for (int i=0; i<n; i++)\\n        {\\n            if (score[i]>temp)\\n            {\\n                index= i;\\n                temp= score[i];\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422790,
                "title": "java-single-pass-easy",
                "content": "\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        \\n        if ( edges.length==0) return 0;\\n        \\n        int n=edges.length;\\n        \\n        int[] count=new int[n];\\n        \\n        int max=Integer.MIN_VALUE;                   // To track max sum\\n        int maxEdge=0;                               // To track highest edge score\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            count[edges[i]]+=i;                      // Get Current Edge Sum\\n            \\n            if(max<=count[edges[i]])\\n            {\\n                if(max==count[edges[i]]){            // if sum equals then update with the smallest index\\n                    \\n                if(maxEdge > edges[i])\\n                maxEdge=edges[i];\\n                    \\n                }\\n                else{\\n                maxEdge=edges[i];\\n                }\\n                \\n                max=count[edges[i]];\\n            }\\n            \\n         }\\n        \\n         return maxEdge;\\n        \\n        \\n    }\\n}\\n   \\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        \\n        if ( edges.length==0) return 0;\\n        \\n        int n=edges.length;\\n        \\n        int[] count=new int[n];\\n        \\n        int max=Integer.MIN_VALUE;                   // To track max sum\\n        int maxEdge=0;                               // To track highest edge score\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            count[edges[i]]+=i;                      // Get Current Edge Sum\\n            \\n            if(max<=count[edges[i]])\\n            {\\n                if(max==count[edges[i]]){            // if sum equals then update with the smallest index\\n                    \\n                if(maxEdge > edges[i])\\n                maxEdge=edges[i];\\n                    \\n                }\\n                else{\\n                maxEdge=edges[i];\\n                }\\n                \\n                max=count[edges[i]];\\n            }\\n            \\n         }\\n        \\n         return maxEdge;\\n        \\n        \\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422311,
                "title": "java-easy-solution-using-hashmap",
                "content": "```\\npublic static int edgeScore(int[] edges) {\\n        HashMap<Integer, Long> hashMap = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            if (hashMap.containsKey(edges[i])) {\\n                long temp = hashMap.get(edges[i]);\\n                temp = temp + i;\\n                hashMap.put(edges[i], temp);\\n            }\\n            else hashMap.put(edges[i], i*1L);\\n        }\\n        long high = Long.MIN_VALUE;\\n        int ans = 0;\\n        for (Integer key : hashMap.keySet()) {\\n            if (hashMap.get(key) > high) {\\n                high = hashMap.get(key);\\n                ans = key;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int edgeScore(int[] edges) {\\n        HashMap<Integer, Long> hashMap = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            if (hashMap.containsKey(edges[i])) {\\n                long temp = hashMap.get(edges[i]);\\n                temp = temp + i;\\n                hashMap.put(edges[i], temp);\\n            }\\n            else hashMap.put(edges[i], i*1L);\\n        }\\n        long high = Long.MIN_VALUE;\\n        int ans = 0;\\n        for (Integer key : hashMap.keySet()) {\\n            if (hashMap.get(key) > high) {\\n                high = hashMap.get(key);\\n                ans = key;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422269,
                "title": "c-quick-code-sum-of-incoming-nodes",
                "content": "```cpp\\nint edgeScore(vector<int>& edges) {\\n    int n = edges.size(), resNode = 0;\\n    vector<long long> scores(n);\\n    for(long i=0; i < n; i++)\\n        scores[edges[i]] += i;\\n    \\n\\tfor(long i=0; i < n; i++){\\n        if(scores[i] > scores[resNode])\\n            resNode = i;\\n    }\\n    return resNode;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint edgeScore(vector<int>& edges) {\\n    int n = edges.size(), resNode = 0;\\n    vector<long long> scores(n);\\n    for(long i=0; i < n; i++)\\n        scores[edges[i]] += i;\\n    \\n\\tfor(long i=0; i < n; i++){\\n        if(scores[i] > scores[resNode])\\n            resNode = i;\\n    }\\n    return resNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422178,
                "title": "java-o-n-simple-soln",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        long score[] = new long[n];\\n        Arrays.fill(score, 0L);\\n        for(int i=0; i<n; i++){\\n            score[edges[i]]+=i*1L;\\n        }\\n        long max = score[0];\\n        int maxi=0;\\n        for(int i=1; i<n; i++){\\n            if(score[i]>max){\\n                max=score[i];\\n                maxi = i;\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        long score[] = new long[n];\\n        Arrays.fill(score, 0L);\\n        for(int i=0; i<n; i++){\\n            score[edges[i]]+=i*1L;\\n        }\\n        long max = score[0];\\n        int maxi=0;\\n        for(int i=1; i<n; i++){\\n            if(score[i]>max){\\n                max=score[i];\\n                maxi = i;\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422161,
                "title": "intuitive-easy-java-solution",
                "content": "**Intuition:**\\nCreate a Ajacency list for all the nodes and find the edge score for all the edges.\\n\\nThe only tricky part was for some edges edge score can have value greater than 10^9 \\n(eg 10^5 edges and all point to same node) so we have to use long to store the edge score to prevent integer overflow.\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        \\n        int n = edges.length;\\n        List<Integer>[] adj = new ArrayList[n];\\n        // 0th index has score, 1st index has val;\\n        long[] ans = new long[2];\\n        \\n        // Create the Adj. List\\n        for(int i = 0; i < n ; i++){\\n            adj[i] = (new ArrayList<Integer>());\\n        }\\n        \\n        // Fill the list\\n        for(int i = 0; i < n ; i++){\\n            int edge = edges[i];\\n            adj[edge].add(i);\\n        }\\n        \\n        // Find Max Edge score\\n        ans[0] = -1;\\n        ans[1] = -1;\\n        for(int i = 0; i < n ; i++){\\n            long es = 0l;\\n            List<Integer> E = adj[i];\\n            \\n            for(Integer e : E){\\n                es += e;\\n            }\\n            \\n            if(es > ans[0]){\\n                ans[0] = es;\\n                ans[1] = i;\\n            }\\n        }\\n        \\n        // Return ans.\\n        return (int)ans[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        \\n        int n = edges.length;\\n        List<Integer>[] adj = new ArrayList[n];\\n        // 0th index has score, 1st index has val;\\n        long[] ans = new long[2];\\n        \\n        // Create the Adj. List\\n        for(int i = 0; i < n ; i++){\\n            adj[i] = (new ArrayList<Integer>());\\n        }\\n        \\n        // Fill the list\\n        for(int i = 0; i < n ; i++){\\n            int edge = edges[i];\\n            adj[edge].add(i);\\n        }\\n        \\n        // Find Max Edge score\\n        ans[0] = -1;\\n        ans[1] = -1;\\n        for(int i = 0; i < n ; i++){\\n            long es = 0l;\\n            List<Integer> E = adj[i];\\n            \\n            for(Integer e : E){\\n                es += e;\\n            }\\n            \\n            if(es > ans[0]){\\n                ans[0] = es;\\n                ans[1] = i;\\n            }\\n        }\\n        \\n        // Return ans.\\n        return (int)ans[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422159,
                "title": "python-simple-counting",
                "content": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        score = [0] * n\\n        \\n        for i, val in enumerate(edges):\\n            score[val] += i\\n        return score.index(max(score))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        score = [0] * n\\n        \\n        for i, val in enumerate(edges):\\n            score[val] += i\\n        return score.index(max(score))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070124,
                "title": "c-graph-hash-map-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nWe have to find the node with the maximum score. The score of a node is calculated as the sum of the labels of rest of the nodes which have an edge towards the node being considered. The vector of edges is given such that at every index i, there is an edge from i to edges[i]. So traverse through the edges vector and simply maintain a map, where the key is the node label and the value is the score of that node. Initialize a maxi variable as 0 to keep track of the max score so far as we iterate through the map using a for auto loop. If the score is greater than the greatest score yet, we update the ans to the current node and also update the max score so far. Else if current node score is equal to max score yet, we consider the node with the lesser label.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n\\n        unordered_map<int, long long> mp;\\n\\n        int n = edges.size();\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            mp[edges[i]] += i;\\n        }\\n\\n        int ans = -1;\\n\\n        long long maxi = 0;\\n\\n        for(auto &it: mp) {\\n\\n            if(it.second > maxi) {\\n\\n                maxi = it.second;\\n\\n                ans = it.first;\\n            \\n            } else if(it.second == maxi) {\\n\\n                if(ans > it.first) ans = it.first;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n\\n        unordered_map<int, long long> mp;\\n\\n        int n = edges.size();\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            mp[edges[i]] += i;\\n        }\\n\\n        int ans = -1;\\n\\n        long long maxi = 0;\\n\\n        for(auto &it: mp) {\\n\\n            if(it.second > maxi) {\\n\\n                maxi = it.second;\\n\\n                ans = it.first;\\n            \\n            } else if(it.second == maxi) {\\n\\n                if(ans > it.first) ans = it.first;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174964,
                "title": "simple-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            mp[edges[i]].push_back(i);\\n        }\\n        int node=-1,maxi=-1;\\n        for(auto it:mp)\\n        {\\n            long long  edge_score=0;\\n            for(auto p:it.second)\\n            {\\n                edge_score+=p;\\n            }\\n            if(maxi < edge_score)\\n            {\\n                maxi=edge_score;\\n                node=it.first;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            mp[edges[i]].push_back(i);\\n        }\\n        int node=-1,maxi=-1;\\n        for(auto it:mp)\\n        {\\n            long long  edge_score=0;\\n            for(auto p:it.second)\\n            {\\n                edge_score+=p;\\n            }\\n            if(maxi < edge_score)\\n            {\\n                maxi=edge_score;\\n                node=it.first;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008428,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961370,
                "title": "java-simple-solution-o-n-using-array",
                "content": "# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long ans[]=new long[edges.length];\\n        long max=0;\\n        int a=0;\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            ans[edges[i]]+=(long)i;\\n            if(max<ans[edges[i]])\\n            {\\n                a=edges[i];\\n                max=ans[edges[i]];\\n            }\\n            else if(max==ans[edges[i]] && edges[i]<a)\\n                a=edges[i];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long ans[]=new long[edges.length];\\n        long max=0;\\n        int a=0;\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            ans[edges[i]]+=(long)i;\\n            if(max<ans[edges[i]])\\n            {\\n                a=edges[i];\\n                max=ans[edges[i]];\\n            }\\n            else if(max==ans[edges[i]] && edges[i]<a)\\n                a=edges[i];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873503,
                "title": "java-solution-short-and-simple-single-loop-o-n-time-faster-than-97",
                "content": "```java \\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long[] a = new long[edges.length];\\n        int max=0;\\n        for(int i=0;i<edges.length;i++){\\n            a[edges[i]]+=i;\\n            if(a[edges[i]]>a[max])\\n                max=edges[i];\\n            else if(a[edges[i]]==a[max] && edges[i]<max)\\n                max=edges[i];\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public int edgeScore(int[] edges) {\\n        long[] a = new long[edges.length];\\n        int max=0;\\n        for(int i=0;i<edges.length;i++){\\n            a[edges[i]]+=i;\\n            if(a[edges[i]]>a[max])\\n                max=edges[i];\\n            else if(a[edges[i]]==a[max] && edges[i]<max)\\n                max=edges[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2861603,
                "title": "counting-easy-solution-o-n-time-complexity",
                "content": "class Solution {\\npublic:\\n\\n    int edgeScore(vector<int>& e) {\\n        int x=e.size();\\n        unordered_map<int, long long> mp;\\n        for(int i=0;i<x; i++)mp[e[i]]+=i;  \\n        int ind=INT_MAX, occ=INT_MIN;\\n        for(auto i: mp){\\n            if(i.second>occ){occ=i.second, ind=i.first;}\\n            else if(i.second==occ)ind=min(ind, i.first);\\n        }\\n        return ind;\\n    }\\n};",
                "solutionTags": [
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int edgeScore(vector<int>& e) {\\n        int x=e.size();\\n        unordered_map<int, long long> mp;\\n        for(int i=0;i<x; i++)mp[e[i]]+=i;  \\n        int ind=INT_MAX, occ=INT_MIN;\\n        for(auto i: mp){\\n            if(i.second>occ){occ=i.second, ind=i.first;}",
                "codeTag": "Java"
            },
            {
                "id": 2760744,
                "title": "crisp-n-clear-o-n-javascript-memory-5-55-meaningful-vars",
                "content": "\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n```\\nfunction findSmallest(arr) {\\n    let small = Infinity;\\n    for (const iterator of arr) {\\n        if (iterator < small) {\\n            small = iterator;\\n        }\\n    }\\n    return small;\\n}\\n\\nvar edgeScore = function (edges) {\\n    let maxSum = -Infinity;\\n    const outputConfig = {};\\n    const edgeConfig = {};\\n    for (let index = 0; index < edges.length; index++) {\\n        const to = edges[index];\\n        if (!edgeConfig[to]) {\\n            edgeConfig[to] = 0;\\n        }\\n        const tempOutput = edgeConfig[to] + index;\\n        if (!outputConfig[tempOutput]) {\\n            outputConfig[tempOutput] = [];\\n        }\\n        outputConfig[tempOutput].push(to);\\n        if (tempOutput > maxSum) {\\n            maxSum = tempOutput;\\n        }\\n        edgeConfig[to] = tempOutput;\\n    }\\n    return Math.min(...outputConfig[maxSum]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findSmallest(arr) {\\n    let small = Infinity;\\n    for (const iterator of arr) {\\n        if (iterator < small) {\\n            small = iterator;\\n        }\\n    }\\n    return small;\\n}\\n\\nvar edgeScore = function (edges) {\\n    let maxSum = -Infinity;\\n    const outputConfig = {};\\n    const edgeConfig = {};\\n    for (let index = 0; index < edges.length; index++) {\\n        const to = edges[index];\\n        if (!edgeConfig[to]) {\\n            edgeConfig[to] = 0;\\n        }\\n        const tempOutput = edgeConfig[to] + index;\\n        if (!outputConfig[tempOutput]) {\\n            outputConfig[tempOutput] = [];\\n        }\\n        outputConfig[tempOutput].push(to);\\n        if (tempOutput > maxSum) {\\n            maxSum = tempOutput;\\n        }\\n        edgeConfig[to] = tempOutput;\\n    }\\n    return Math.min(...outputConfig[maxSum]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737875,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int edgeScore(vector<int>& edges) {\\n        unordered_map<int, long> scores;\\n        int highestScoreNode = 0;\\n        for (int i = 0; i < edges.size(); i++) {\\n            scores[edges[i]] += i;\\n            int lastScore = scores[edges[i]], highestScore = scores[highestScoreNode];\\n            if (lastScore > highestScore)\\n                highestScoreNode = edges[i];\\n            else if (lastScore == highestScore)\\n                highestScoreNode = min(edges[i], highestScoreNode);\\n        }\\n        return highestScoreNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int edgeScore(vector<int>& edges) {\\n        unordered_map<int, long> scores;\\n        int highestScoreNode = 0;\\n        for (int i = 0; i < edges.size(); i++) {\\n            scores[edges[i]] += i;\\n            int lastScore = scores[edges[i]], highestScore = scores[highestScoreNode];\\n            if (lastScore > highestScore)\\n                highestScoreNode = edges[i];\\n            else if (lastScore == highestScore)\\n                highestScoreNode = min(edges[i], highestScoreNode);\\n        }\\n        return highestScoreNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617277,
                "title": "node-with-highest-edge-score",
                "content": "bfs solution  \\nTC:O(n+e)\\nSC:O(n+e)\\n/*make directed graph with the edges and then do bfs to find the edge score of node\\n*/\\n\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll bfs(vector<int>node){\\n        ll ans=0;\\n        \\n        for(auto i:node){\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n    \\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0;i<n;i++){  //make directed graph\\n            g[edges[i]].push_back(i);   \\n        }\\n        \\n        ll mx=0;\\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            ll x=bfs(g[i]);    //bfs function to calculate edges score of node\\n            if(mx<x){\\n                mx=x;\\n                ans=i;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nhashing solution\\nTC:O(n)\\nSC:O(n)\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size(); \\n        vector<ll>g(n,0);\\n        \\n        ll mx=0;\\n        ll ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            g[edges[i]]=g[edges[i]]+i;        /*increase the nodes value to which the current node is pointing for example edges[i]=x; then g[x]=g[x]+i; where node is directed to x */\\n        }\\n        for(int i=0;i<n;i++){       //traverse the g hashtable to find the node with max score\\n            if(g[i]>mx){\\n                mx=g[i];\\n                ans=i;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll bfs(vector<int>node){\\n        ll ans=0;\\n        \\n        for(auto i:node){\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n    \\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0;i<n;i++){  //make directed graph\\n            g[edges[i]].push_back(i);   \\n        }\\n        \\n        ll mx=0;\\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            ll x=bfs(g[i]);    //bfs function to calculate edges score of node\\n            if(mx<x){\\n                mx=x;\\n                ans=i;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size(); \\n        vector<ll>g(n,0);\\n        \\n        ll mx=0;\\n        ll ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            g[edges[i]]=g[edges[i]]+i;        /*increase the nodes value to which the current node is pointing for example edges[i]=x; then g[x]=g[x]+i; where node is directed to x */\\n        }\\n        for(int i=0;i<n;i++){       //traverse the g hashtable to find the node with max score\\n            if(g[i]>mx){\\n                mx=g[i];\\n                ans=i;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508365,
                "title": "c-count-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<ll> ans(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[edges[i]]+=i;\\n        }\\n        ll maxi=0;//idx\\n        for(int i=1;i<n;i++){\\n            if(ans[i]>ans[maxi]){\\n                maxi=i;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<ll> ans(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[edges[i]]+=i;\\n        }\\n        ll maxi=0;//idx\\n        for(int i=1;i<n;i++){\\n            if(ans[i]>ans[maxi]){\\n                maxi=i;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2476033,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long ;\\n    int n ;\\n    vector<ll>score ;\\n    int edgeScore(vector<int>& edges) {\\n        n = edges.size() ;\\n        score.resize(n,0) ;\\n        \\n        for(int i = 0 ; i < n ; ++i ) score[edges[i]] += i*1LL ;\\n        ll target = *max_element(begin(score),end(score)) ;\\n        for(int i = 0 ; i < n ; ++i ) if(score[i] == target) return i ;\\n        \\n        \\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long ;\\n    int n ;\\n    vector<ll>score ;\\n    int edgeScore(vector<int>& edges) {\\n        n = edges.size() ;\\n        score.resize(n,0) ;\\n        \\n        for(int i = 0 ; i < n ; ++i ) score[edges[i]] += i*1LL ;\\n        ll target = *max_element(begin(score),end(score)) ;\\n        for(int i = 0 ; i < n ; ++i ) if(score[i] == target) return i ;\\n        \\n        \\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459215,
                "title": "c-o-n-time-complexity-o-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<long long> edgeScore(n, 0);\\n        int res=INT_MAX, maxval=INT_MIN;\\n        for(long long i=0; i<n; i++){\\n            edgeScore[edges[i]]+=(long long)i;\\n            if(edgeScore[edges[i]]>maxval) res=edges[i], maxval=edgeScore[edges[i]];\\n            else if(edgeScore[edges[i]]==maxval) res=min(edges[i], res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<long long> edgeScore(n, 0);\\n        int res=INT_MAX, maxval=INT_MIN;\\n        for(long long i=0; i<n; i++){\\n            edgeScore[edges[i]]+=(long long)i;\\n            if(edgeScore[edges[i]]>maxval) res=edges[i], maxval=edgeScore[edges[i]];\\n            else if(edgeScore[edges[i]]==maxval) res=min(edges[i], res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444463,
                "title": "fast-and-clean-javascript-solution",
                "content": "```\\nvar edgeScore = function(edges) {\\n    let score = Array(edges.length).fill(0)\\n    let maxScore = 0 , resIndex = 0\\n    for( i = 0 ; i < edges.length ; i++ )\\n        score[edges[i]] += i;\\n    for( i = 0 ; i < edges.length ; i++ )\\n        if( score[i] > maxScore ){\\n            maxScore = score[i]\\n            resIndex = i\\n        }\\n    return resIndex\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar edgeScore = function(edges) {\\n    let score = Array(edges.length).fill(0)\\n    let maxScore = 0 , resIndex = 0\\n    for( i = 0 ; i < edges.length ; i++ )\\n        score[edges[i]] += i;\\n    for( i = 0 ; i < edges.length ; i++ )\\n        if( score[i] > maxScore ){\\n            maxScore = score[i]\\n            resIndex = i\\n        }\\n    return resIndex\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2438118,
                "title": "scala-mutable-map",
                "content": "```scala\\ndef edgeScore(edges: Array[Int]): Int = {\\n  val scores = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n  edges.zipWithIndex.foreach { case (node, index) => scores(node) -= index }\\n  scores.toList.map(_.swap).min._2\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef edgeScore(edges: Array[Int]): Int = {\\n  val scores = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n  edges.zipWithIndex.foreach { case (node, index) => scores(node) -= index }\\n  scores.toList.map(_.swap).min._2\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2428672,
                "title": "easy-graph-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<int,long long> mpp; // <node , edge score>\\n        \\n        for(int i=0;i<edges.size();i++) \\n            mpp[edges[i]] += i;\\n        \\n        long long maxScore = INT_MIN;\\n        for(auto x:mpp) {\\n            if(x.second > maxScore) \\n                maxScore = x.second;\\n        }\\n        \\n        int ans;\\n        for(auto x:mpp) {\\n            if(x.second == maxScore) {\\n                ans = x.first;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Please upvote if you liked the solution\\n\\n# \\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<int,long long> mpp; // <node , edge score>\\n        \\n        for(int i=0;i<edges.size();i++) \\n            mpp[edges[i]] += i;\\n        \\n        long long maxScore = INT_MIN;\\n        for(auto x:mpp) {\\n            if(x.second > maxScore) \\n                maxScore = x.second;\\n        }\\n        \\n        int ans;\\n        for(auto x:mpp) {\\n            if(x.second == maxScore) {\\n                ans = x.first;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427583,
                "title": "basic-practice-of-indegree-graph-theory-concepts-python",
                "content": "Method: weighted indegree, basic graph theory concept practice\\n\\nIn this problem, when seeing an in-degree, we do not counting with increment 1,\\nbut with increment by the incoming node label.\\n\\n\\nExtension: indegree can also be used in topological sorting, \\nfor example in Kahn\\'s algorithm\\n\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        # 1. prep\\n        n = len(edges)\\n        edge_score = {i:0 for i in range(n)} # node:score, weight indegree\\n        \\n        # 2. iteration\\n        for start, end in enumerate(edges):\\n            edge_score[end] += start\\n            \\n        # 3. prepare the return\\n        maximum = max(edge_score.values())\\n        candidates = [node for node, score in edge_score.items() if score == maximum]\\n        candidates.sort()\\n        return candidates[0]\\n```\\nVideo Explanation: [Click Here](https://youtu.be/gxONLlPexeM;)\\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        # 1. prep\\n        n = len(edges)\\n        edge_score = {i:0 for i in range(n)} # node:score, weight indegree\\n        \\n        # 2. iteration\\n        for start, end in enumerate(edges):\\n            edge_score[end] += start\\n            \\n        # 3. prepare the return\\n        maximum = max(edge_score.values())\\n        candidates = [node for node, score in edge_score.items() if score == maximum]\\n        candidates.sort()\\n        return candidates[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425400,
                "title": "python-no-hashmaps-clean-code-o-n",
                "content": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        scores = [0]*n\\n        for v, w in enumerate(edges):\\n            scores[w] += v\\n        return max(range(n), key = lambda x: scores[x])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        scores = [0]*n\\n        for v, w in enumerate(edges):\\n            scores[w] += v\\n        return max(range(n), key = lambda x: scores[x])",
                "codeTag": "Java"
            },
            {
                "id": 2424230,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        unordered_map<int, long long> mp;\\n        \\n        long long maxi = INT_MIN;\\n        \\n        int max_vertex = n - 1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[edges[i]] = mp[edges[i]] + i;\\n            \\n            if(mp[edges[i]] > maxi)\\n            {\\n                maxi = mp[edges[i]];\\n                \\n                max_vertex = edges[i];\\n            }\\n            else if(mp[edges[i]] == maxi && edges[i] < max_vertex)\\n            {\\n                maxi = mp[edges[i]];\\n                \\n                max_vertex = edges[i];\\n            }\\n        }\\n        \\n        return max_vertex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        unordered_map<int, long long> mp;\\n        \\n        long long maxi = INT_MIN;\\n        \\n        int max_vertex = n - 1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[edges[i]] = mp[edges[i]] + i;\\n            \\n            if(mp[edges[i]] > maxi)\\n            {\\n                maxi = mp[edges[i]];\\n                \\n                max_vertex = edges[i];\\n            }\\n            else if(mp[edges[i]] == maxi && edges[i] < max_vertex)\\n            {\\n                maxi = mp[edges[i]];\\n                \\n                max_vertex = edges[i];\\n            }\\n        }\\n        \\n        return max_vertex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423601,
                "title": "easy-map-and-graph-solution",
                "content": "Using Unordered  Map\\n\\n```\\nclass Solution {\\npublic:\\n   // static bool compare(pair<int,int> x, pair<int,int> y) {\\n   //      return x.second>y.second;\\n   //  }\\n    \\n    int edgeScore(vector<int>& edges) {\\n        #define int int64_t\\n        int n=edges.size();\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            m[edges[i]]+=i;\\n        }\\n       int mx=0;\\n        for(auto i:m) {\\n            // cout<<i.first<<\" \"<<i.second;\\n            // cout<<endl;\\n            mx=max(mx,i.second);\\n        }\\n        int ans = 1e9+123;\\n        for(auto i:m) {\\n            if(i.second==mx) ans = min(ans, i.first);\\n        }\\n        #undef int\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\nAdjacency List solution\\n```\\nclass Solution {\\npublic:\\n  \\n    int edgeScore(vector<int>& a) {\\n        #define int int64_t\\n        int n = a.size();\\n        vector<int> adj[n+1];\\n        for(int i = 0; i < n; i++) {\\n            adj[a[i]].push_back(i);\\n        }\\n        int ans = 0, mx = 0;\\n        for(int i = 0; i < n; i++) {\\n            int sum = 0;\\n            for(auto &j : adj[i]) {\\n                sum += j;\\n            }\\n            if(sum > mx) {\\n                ans = i;\\n                mx = sum;\\n            }\\n        }\\n        #undef int\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   // static bool compare(pair<int,int> x, pair<int,int> y) {\\n   //      return x.second>y.second;\\n   //  }\\n    \\n    int edgeScore(vector<int>& edges) {\\n        #define int int64_t\\n        int n=edges.size();\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            m[edges[i]]+=i;\\n        }\\n       int mx=0;\\n        for(auto i:m) {\\n            // cout<<i.first<<\" \"<<i.second;\\n            // cout<<endl;\\n            mx=max(mx,i.second);\\n        }\\n        int ans = 1e9+123;\\n        for(auto i:m) {\\n            if(i.second==mx) ans = min(ans, i.first);\\n        }\\n        #undef int\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    int edgeScore(vector<int>& a) {\\n        #define int int64_t\\n        int n = a.size();\\n        vector<int> adj[n+1];\\n        for(int i = 0; i < n; i++) {\\n            adj[a[i]].push_back(i);\\n        }\\n        int ans = 0, mx = 0;\\n        for(int i = 0; i < n; i++) {\\n            int sum = 0;\\n            for(auto &j : adj[i]) {\\n                sum += j;\\n            }\\n            if(sum > mx) {\\n                ans = i;\\n                mx = sum;\\n            }\\n        }\\n        #undef int\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2423036,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long long n = edges.size();\\n        vector<long long> v(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            v[edges[i]] += i;\\n        }\\n        long long maxi = LLONG_MIN;\\n        int index;\\n        for(int i = 0; i < n; i++) {\\n            if(maxi < v[i]) {\\n                maxi = v[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long long n = edges.size();\\n        vector<long long> v(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            v[edges[i]] += i;\\n        }\\n        long long maxi = LLONG_MIN;\\n        int index;\\n        for(int i = 0; i < n; i++) {\\n            if(maxi < v[i]) {\\n                maxi = v[i];\\n                index = i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423002,
                "title": "c-java-simple-easy-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> eScore(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            eScore[edges[i]] += i;\\n        }\\n        \\n        int idx = 0;\\n        long long score = eScore[0];\\n        \\n        for(int i=0;i<n;i++){\\n            if(eScore[i] > score){\\n                score = eScore[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int max = 0;\\n        int maxKey = 0;\\n        \\n        for(int i=0;i<edges.length;i++) {\\n            map.put(edges[i], map.getOrDefault(edges[i], 0) + i);\\n            if(!map.containsKey(maxKey))\\n            {\\n                maxKey = edges[i];\\n            }\\n            else \\n            {\\n            if(map.get(edges[i]) > map.get(maxKey)) \\n            {\\n                maxKey = edges[i];\\n            }\\n            if(map.get(edges[i]) == map.get(maxKey) && edges[i] < maxKey) \\n            {\\n                maxKey = edges[i];\\n            }\\n            }\\n            \\n        }\\n        \\n        return maxKey;\\n    }\\n}\\n```\\n\\n```\\nDo not forget to upvote if you like the solution\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> eScore(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            eScore[edges[i]] += i;\\n        }\\n        \\n        int idx = 0;\\n        long long score = eScore[0];\\n        \\n        for(int i=0;i<n;i++){\\n            if(eScore[i] > score){\\n                score = eScore[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int max = 0;\\n        int maxKey = 0;\\n        \\n        for(int i=0;i<edges.length;i++) {\\n            map.put(edges[i], map.getOrDefault(edges[i], 0) + i);\\n            if(!map.containsKey(maxKey))\\n            {\\n                maxKey = edges[i];\\n            }\\n            else \\n            {\\n            if(map.get(edges[i]) > map.get(maxKey)) \\n            {\\n                maxKey = edges[i];\\n            }\\n            if(map.get(edges[i]) == map.get(maxKey) && edges[i] < maxKey) \\n            {\\n                maxKey = edges[i];\\n            }\\n            }\\n            \\n        }\\n        \\n        return maxKey;\\n    }\\n}\\n```\n```\\nDo not forget to upvote if you like the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422877,
                "title": "java-striver-s-thought-o-n-counting-fast",
                "content": "**Map --> Only one pass solution**\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        if(edges.length==0) return -1;\\n        TreeMap<Integer,Long> mp =  new TreeMap<>();\\n        int max=0;\\n        long maxVal = Long.MIN_VALUE;\\n        for(int i=0;i<edges.length;i++){\\n            mp.put(edges[i],mp.getOrDefault(edges[i],(long)0)+(long)i);\\n            \\n            if(mp.get(edges[i])>maxVal||(mp.get(edges[i])==maxVal&&edges[i]<max)){\\n                max=edges[i];\\n                maxVal=mp.get(edges[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int edgeScore(int[] edges) {\\n        if(edges.length==0) return -1;\\n        TreeMap<Integer,Long> mp =  new TreeMap<>();\\n        int max=0;\\n        long maxVal = Long.MIN_VALUE;\\n        for(int i=0;i<edges.length;i++){\\n            mp.put(edges[i],mp.getOrDefault(edges[i],(long)0)+(long)i);\\n            \\n            if(mp.get(edges[i])>maxVal||(mp.get(edges[i])==maxVal&&edges[i]<max)){\\n                max=edges[i];\\n                maxVal=mp.get(edges[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2422822,
                "title": "counting-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<long long ,long long>um;\\n        for(int i = 0; i < edges.size(); i++){\\n            um[edges[i]] += i;\\n        }\\n        long long ans = 0, idx = 0;\\n        for(auto &p: um){\\n            if(ans == p.second){\\n                idx = min(idx, p.first);\\n            }\\n            if(ans < p.second){\\n                ans = p.second;\\n                idx = p.first;\\n            }\\n        }\\n        return idx;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<long long ,long long>um;\\n        for(int i = 0; i < edges.size(); i++){\\n            um[edges[i]] += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2422794,
                "title": "c-easy-and-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    //compare function\\n    static bool mycmp(pair<long long,long long>&p1,pair<long long,long long>&p2){\\n        //if edge score is same return min index\\n        if(p1.second==p2.second){\\n            return p1.first<p2.first;\\n        }\\n        //return with highest score\\n        return p1.second>p2.second;\\n    }\\n    int edgeScore(vector<int>& edges) {\\n        // map for storing index with egde score\\n        unordered_map<long long,long long>m;\\n        for(int i=0;i<edges.size();i++){\\n            m[edges[i]]+=i;\\n        }\\n        vector<pair<long long,long long>>v;\\n        for(auto x:m){\\n            v.push_back({x.first,x.second});\\n        }\\n        // sort according to the given condition\\n        sort(v.begin(),v.end(),mycmp);\\n        //return the index\\n        return v[0].first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //compare function\\n    static bool mycmp(pair<long long,long long>&p1,pair<long long,long long>&p2){\\n        //if edge score is same return min index\\n        if(p1.second==p2.second){\\n            return p1.first<p2.first;\\n        }\\n        //return with highest score\\n        return p1.second>p2.second;\\n    }\\n    int edgeScore(vector<int>& edges) {\\n        // map for storing index with egde score\\n        unordered_map<long long,long long>m;\\n        for(int i=0;i<edges.size();i++){\\n            m[edges[i]]+=i;\\n        }\\n        vector<pair<long long,long long>>v;\\n        for(auto x:m){\\n            v.push_back({x.first,x.second});\\n        }\\n        // sort according to the given condition\\n        sort(v.begin(),v.end(),mycmp);\\n        //return the index\\n        return v[0].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422747,
                "title": "java-easy-solution-o-n-easy-100-faster-solution-simple-solution-without-graph",
                "content": "**Use long array to store the edge score to avoid overflow.\\n\\nPlease upvote, it helps.\\n\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        // array to store the edge score of n nodes.\\n        long[] nums = new long[n];\\n        for(int i = 0;i<n;i++){\\n            nums[edges[i]]+=i;\\n        }\\n        // find the maximum edge score..\\n        long max = 0;\\n        int ind = (int)1e9;\\n        for(int i = 0;i<n;i++){\\n            if(max< nums[i]){\\n                max = nums[i];\\n                ind = i;\\n            }\\n        }\\n        return ind;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        // array to store the edge score of n nodes.\\n        long[] nums = new long[n];\\n        for(int i = 0;i<n;i++){\\n            nums[edges[i]]+=i;\\n        }\\n        // find the maximum edge score..\\n        long max = 0;\\n        int ind = (int)1e9;\\n        for(int i = 0;i<n;i++){\\n            if(max< nums[i]){\\n                max = nums[i];\\n                ind = i;\\n            }\\n        }\\n        return ind;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422620,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\nint edgeScore(vector<int>& edges) {\\n    int n=edges.size();\\n   vector<long long>vec(n,0);\\n    for(long long i=0;i<edges.size();i++){\\n        vec[edges[i]]+=i;\\n    }\\n    long long c=-1;\\n    long long maxx=-1e9;\\n   for(long long i=0;i<n;i++){\\n       if(vec[i]>maxx){\\n           c=i;\\n           maxx=vec[i];\\n       }\\n   }\\n    return c;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint edgeScore(vector<int>& edges) {\\n    int n=edges.size();\\n   vector<long long>vec(n,0);\\n    for(long long i=0;i<edges.size();i++){\\n        vec[edges[i]]+=i;\\n    }\\n    long long c=-1;\\n    long long maxx=-1e9;\\n   for(long long i=0;i<n;i++){\\n       if(vec[i]>maxx){\\n           c=i;\\n           maxx=vec[i];\\n       }\\n   }\\n    return c;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422568,
                "title": "hashmap-no-graph-easy-node-with-highest-edge-score",
                "content": "Note: To avoid integer overflow error when summing indices, take long.\\neg. If edges = [1,0,1,1,1,1,1,1 . . . . . . . . . . . . . . .] for n=10^5 nodes\\nNth Sum of indices from 1 to n = n(n+1)/2 , where n*n can overflow \\n\\n```\\n\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n\\t   //1. we will map nodes-> to their edge score , have to add up the indices\\n        Map<Integer , Long> mp = new HashMap<>();\\n        for(int i=0; i<edges.length ; i++){\\n            mp.put( edges[i] , (mp.getOrDefault( edges[i], (long)0)+ (long)i ) );\\n        }\\n        \\n        //2. simply travel in the map , see which key has highest edge score, return that key.\\n        long max=0;\\n        int label=0;\\n        for(Map.Entry<Integer, Long> it : mp.entrySet()){\\n            if((it.getValue() >= max)){\\n                if((max == it.getValue()) && (label < it.getKey()) ) continue;\\n                label = it.getKey();\\n                max = it.getValue();\\n            }\\n        }\\n        return label;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n\\t   //1. we will map nodes-> to their edge score , have to add up the indices\\n        Map<Integer , Long> mp = new HashMap<>();\\n        for(int i=0; i<edges.length ; i++){\\n            mp.put( edges[i] , (mp.getOrDefault( edges[i], (long)0)+ (long)i ) );\\n        }\\n        \\n        //2. simply travel in the map , see which key has highest edge score, return that key.\\n        long max=0;\\n        int label=0;\\n        for(Map.Entry<Integer, Long> it : mp.entrySet()){\\n            if((it.getValue() >= max)){\\n                if((max == it.getValue()) && (label < it.getKey()) ) continue;\\n                label = it.getKey();\\n                max = it.getValue();\\n            }\\n        }\\n        return label;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422535,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        Map<Integer,Long> score = new TreeMap<>();\\n        int n = edges.length;\\n        for(int i = 0; i < n; i ++){\\n            score.put(edges[i], score.getOrDefault(edges[i], 0L) + i);\\n        }\\n        int res = 0;\\n        long max = 0;\\n        for(int key: score.keySet()){\\n            if(score.get(key) > max){\\n                max = score.get(key);\\n                res = key;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        Map<Integer,Long> score = new TreeMap<>();\\n        int n = edges.length;\\n        for(int i = 0; i < n; i ++){\\n            score.put(edges[i], score.getOrDefault(edges[i], 0L) + i);\\n        }\\n        int res = 0;\\n        long max = 0;\\n        for(int key: score.keySet()){\\n            if(score.get(key) > max){\\n                max = score.get(key);\\n                res = key;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422442,
                "title": "c-easy-solution",
                "content": "```\\npublic class Solution {\\n    public int EdgeScore(int[] edges) {\\n        var scores = new long[edges.Length];\\n\\n        for (var i = 0; i < edges.Length; i++)\\n            scores[edges[i]] += i;\\n\\n        return scores.ToList().IndexOf(scores.Max());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int EdgeScore(int[] edges) {\\n        var scores = new long[edges.Length];\\n\\n        for (var i = 0; i < edges.Length; i++)\\n            scores[edges[i]] += i;\\n\\n        return scores.ToList().IndexOf(scores.Max());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422431,
                "title": "java-tc-o-n-no-map-adjmatrix-required-to-build-super-easy",
                "content": "We don\\'t need to build adjMatrix/adjList as such just sum of the node\\'s label which are directed to current node.\\nThe code is self-explanatory. Only catch is sum can overflow on Integer so we will use long for sum.\\n\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long[] sum = new long[edges.length];\\n        for(int i=0;i<edges.length;i++) {\\n            sum[edges[i]]+=i;\\n        }\\n        long max=0, res=-1;\\n        for(int i=0;i<edges.length;i++) {\\n            if(sum[i]>max) {\\n                max =sum[i];\\n                res=i;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long[] sum = new long[edges.length];\\n        for(int i=0;i<edges.length;i++) {\\n            sum[edges[i]]+=i;\\n        }\\n        long max=0, res=-1;\\n        for(int i=0;i<edges.length;i++) {\\n            if(sum[i]>max) {\\n                max =sum[i];\\n                res=i;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422428,
                "title": "easy-java-solution-with-an-explanation-and-comments",
                "content": "```\\n/*\\n\\nremeber to use long array/maxx vatriable and not int as the test cases are huge and will lead to overflow...\\n\\n    we store the score of each value node in the answer array( ans[i] is the score of the node \\'i\\')\\n    we keep a check of the index with the maxx score using the maxx varaible,\\n    at the end we search for the node whose score is equal to the maxx score\\n    \\n    */\\n    \\n    public int edgeScore(int[] edges) {\\n        \\n        int n= edges.length;\\n        \\n        \\n        // score array\\n        long[] ans= new long[n];\\n        \\n        // variable to store max score\\n        long maxx= -1;\\n        \\n        //calcualting the score of each node and keeping a check of the max. score\\n        for( int i=0; i<n; i++){\\n            ans[edges[i]]=ans[edges[i]]+i;\\n            maxx= Math.max(maxx, ans[edges[i]]);\\n        }\\n        \\n        \\n        // search the node with the max score\\n         for( int i=0; i<n; i++){\\n            if( ans[i]==maxx)return i;\\n        }\\n        \\n        //just to stope the compiler from throwing \"missing return statement error\"\\n        return -1;\\n        \\n    }\\n```\\n\\nTIme Complexity= O(n) \\nSpace Complexity = O(n)\\nwhere n is the no. of nodes in the graph",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\nremeber to use long array/maxx vatriable and not int as the test cases are huge and will lead to overflow...\\n\\n    we store the score of each value node in the answer array( ans[i] is the score of the node \\'i\\')\\n    we keep a check of the index with the maxx score using the maxx varaible,\\n    at the end we search for the node whose score is equal to the maxx score\\n    \\n    */\\n    \\n    public int edgeScore(int[] edges) {\\n        \\n        int n= edges.length;\\n        \\n        \\n        // score array\\n        long[] ans= new long[n];\\n        \\n        // variable to store max score\\n        long maxx= -1;\\n        \\n        //calcualting the score of each node and keeping a check of the max. score\\n        for( int i=0; i<n; i++){\\n            ans[edges[i]]=ans[edges[i]]+i;\\n            maxx= Math.max(maxx, ans[edges[i]]);\\n        }\\n        \\n        \\n        // search the node with the max score\\n         for( int i=0; i<n; i++){\\n            if( ans[i]==maxx)return i;\\n        }\\n        \\n        //just to stope the compiler from throwing \"missing return statement error\"\\n        return -1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422394,
                "title": "java-easy-hashmap",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer,Long> hm=new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            hm.put(edges[i],hm.getOrDefault(edges[i],0l)+i);\\n        }\\n        long max=Long.MIN_VALUE;\\n        int node=-1;\\n        for(int x:hm.keySet()){\\n            if(hm.get(x)>max){\\n                max=hm.get(x);\\n                node=x;\\n            }\\n            else if(hm.get(x)==max)\\n                node=Math.min(x,node);\\n        }\\n        System.out.println(max);\\n        return node;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer,Long> hm=new HashMap<>();\\n        for(int i=0;i<edges.length;i++){\\n            hm.put(edges[i],hm.getOrDefault(edges[i],0l)+i);\\n        }\\n        long max=Long.MIN_VALUE;\\n        int node=-1;\\n        for(int x:hm.keySet()){\\n            if(hm.get(x)>max){\\n                max=hm.get(x);\\n                node=x;\\n            }\\n            else if(hm.get(x)==max)\\n                node=Math.min(x,node);\\n        }\\n        System.out.println(max);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422386,
                "title": "c-using-map",
                "content": "```\\n  int n=e.size();\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<n;i++){\\n            mp[e[i]].push_back(i);\\n        }\\n        long long maxi=0;\\n        int ans=0;\\n        for(auto it:mp){\\n            long long sum=0;\\n            for(auto it1:it.second){\\n                sum+=it1;\\n            }\\n          if(maxi<sum){\\n              maxi=sum;\\n              ans=it.first;\\n          }\\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "```\\n  int n=e.size();\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<n;i++){\\n            mp[e[i]].push_back(i);\\n        }\\n        long long maxi=0;\\n        int ans=0;\\n        for(auto it:mp){\\n            long long sum=0;\\n            for(auto it1:it.second){\\n                sum+=it1;\\n            }\\n          if(maxi<sum){\\n              maxi=sum;\\n              ans=it.first;\\n          }\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2422375,
                "title": "simple-java",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        long[] scores = new long[n]; // i: scores of node i\\n        \\n        long maxscore = 0;\\n        for (int i = 0; i < n; i++) {\\n\\n            scores[edges[i]] += i;\\n            maxscore = Math.max(maxscore, scores[edges[i]]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (maxscore == scores[i]) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        long[] scores = new long[n]; // i: scores of node i\\n        \\n        long maxscore = 0;\\n        for (int i = 0; i < n; i++) {\\n\\n            scores[edges[i]] += i;\\n            maxscore = Math.max(maxscore, scores[edges[i]]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (maxscore == scores[i]) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422315,
                "title": "c-hashmap-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        vector<long long> v(edges.size(),0);\\n        for(long long i=0;i<edges.size();i++)\\n        {\\n            long long p=edges[i];\\n            v[p]+=i;\\n        }\\n        long long res=v[0];\\n        long long ind=0;\\n        for(long long i=1;i<v.size();i++)\\n        {\\n            if(v[i]>res)\\n            {\\n                res=v[i];\\n                ind=i;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        vector<long long> v(edges.size(),0);\\n        for(long long i=0;i<edges.size();i++)\\n        {\\n            long long p=edges[i];\\n            v[p]+=i;\\n        }\\n        long long res=v[0];\\n        long long ind=0;\\n        for(long long i=1;i<v.size();i++)\\n        {\\n            if(v[i]>res)\\n            {\\n                res=v[i];\\n                ind=i;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422304,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n\\n        unordered_map<long long, long long> m;\\n        vector<long long> v(edges.size(), 0);\\n        for(long long i=edges.size() - 1; i>=0; i--) m[edges[i]] += i;\\n        \\n        long long ans = 0, fr = -1;\\n        for(auto i : m) v[i.first] = i.second;\\n        for(long long i=0; i<v.size(); i++) {\\n            if(v[i] > fr) ans = i, fr = v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n\\n        unordered_map<long long, long long> m;\\n        vector<long long> v(edges.size(), 0);\\n        for(long long i=edges.size() - 1; i>=0; i--) m[edges[i]] += i;\\n        \\n        long long ans = 0, fr = -1;\\n        for(auto i : m) v[i.first] = i.second;\\n        for(long long i=0; i<v.size(); i++) {\\n            if(v[i] > fr) ans = i, fr = v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422282,
                "title": "c-simple-hashmap-easy",
                "content": "\\tint edgeScore(vector<int>& edges) \\n\\t{\\n        ll n = edges.size();\\n        map<ll,ll> mp;\\n        ll maxi=-1;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            mp[edges[i]] +=i;\\n            maxi = max(maxi,mp[edges[i]]);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            ll node = it.first , val = it.second;\\n            if(val==maxi)\\n                return node;\\n        }\\n        \\n        return -1;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint edgeScore(vector<int>& edges) \\n\\t{\\n        ll n = edges.size();\\n        map<ll,ll> mp;\\n        ll maxi=-1;\\n        \\n        for(ll i=0;i<n;i++)\\n        {\\n            mp[edges[i]] +=i;\\n            maxi = max(maxi,mp[edges[i]]);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            ll node = it.first , val = it.second;\\n            if(val==maxi)\\n                return node;\\n        }\\n        \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2422259,
                "title": "c-array",
                "content": "```\\n    public int EdgeScore(int[] edges)\\n    {\\n        int n = edges.Length;\\n        long[] sum = new long[n];\\n        for (int i = 0; i < n; i++)\\n            sum[edges[i]] += i;\\n\\n        long max = 0;\\n        int maxIndex = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (sum[i]> max)\\n            {\\n                max = sum[i];\\n                maxIndex = i;\\n            }\\n        }\\n\\n        return maxIndex;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int EdgeScore(int[] edges)\\n    {\\n        int n = edges.Length;\\n        long[] sum = new long[n];\\n        for (int i = 0; i < n; i++)\\n            sum[edges[i]] += i;\\n\\n        long max = 0;\\n        int maxIndex = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (sum[i]> max)\\n            {\\n                max = sum[i];\\n                maxIndex = i;\\n            }\\n        }\\n\\n        return maxIndex;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422214,
                "title": "eassy-lol",
                "content": "class Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        map<int,vector<int>>mp;// making adjacency list \\n        \\n        int n=edges.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[edges[i]].push_back(i);\\n        }\\n        \\n        int maxi=-1e9;\\n        int prev=-1, ans;\\n        for(auto ele:mp){\\n            long long sum=0;\\n            for(auto it :ele.second)sum+=it;// calcualting the sum of connected compopnents \\n           if(maxi<sum)maxi=sum;\\n           if(prev!=maxi)ans=ele.first; // \\n           prev=maxi;\\n        }\\n        \\n        return ans;// retuning the node having the largest sum \\n        // note we dosent have to check for the similar sum using the map make it eassy \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        map<int,vector<int>>mp;// making adjacency list \\n        \\n        int n=edges.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[edges[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2422203,
                "title": "node-with-highest-edge-score",
                "content": "```int edgeScore(vector<int>& edges) {\\n        map< long long int,long long int>mp;\\n        \\n        int n=edges.size();\\n        for(int i=0;i<n;i++){\\n            long long int u=i;\\n            long long int v=edges[i];\\n            mp[v]=mp[v]+u;\\n        }\\n        long long int node=0;\\n        long long int val=0;\\n        for(auto it:mp){\\n            if(it.second>val){\\n                node=it.first;\\n                val=it.second;\\n            }\\n        }\\n        return (int)node;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```int edgeScore(vector<int>& edges) {\\n        map< long long int,long long int>mp;\\n        \\n        int n=edges.size();\\n        for(int i=0;i<n;i++){\\n            long long int u=i;\\n            long long int v=edges[i];\\n            mp[v]=mp[v]+u;\\n        }\\n        long long int node=0;\\n        long long int val=0;\\n        for(auto it:mp){\\n            if(it.second>val){\\n                node=it.first;\\n                val=it.second;\\n            }\\n        }\\n        return (int)node;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422183,
                "title": "simple-approach-array-traversal-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> labelScore(n,0);\\n        for(int i=0; i<n; i++){\\n            labelScore[edges[i]] += (long long)i;\\n        }\\n        long long maxVal = (long long)INT_MIN;\\n        int minIndex;\\n        for(int i = n-1; i>=0; i--){\\n           if(labelScore[i] >= maxVal){\\n               maxVal = labelScore[i];\\n               minIndex = i;\\n           } \\n        }\\n        return minIndex;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> labelScore(n,0);\\n        for(int i=0; i<n; i++){\\n            labelScore[edges[i]] += (long long)i;\\n        }\\n        long long maxVal = (long long)INT_MIN;\\n        int minIndex;\\n        for(int i = n-1; i>=0; i--){\\n           if(labelScore[i] >= maxVal){\\n               maxVal = labelScore[i];\\n               minIndex = i;\\n           } \\n        }\\n        return minIndex;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422168,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n       vector<long long>ans(edges.size()+1,0);\\n        \\n        for(long long i=0;i<edges.size();i++)\\n        {\\n            ans[edges[i]]+=i;\\n        }\\n        \\n        long long maxi = -1;\\n        long long idx = -1;\\n        for(long long i=0;i<edges.size();i++)\\n        {\\n            if(maxi<ans[i])\\n            {\\n                maxi=ans[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n       vector<long long>ans(edges.size()+1,0);\\n        \\n        for(long long i=0;i<edges.size();i++)\\n        {\\n            ans[edges[i]]+=i;\\n        }\\n        \\n        long long maxi = -1;\\n        long long idx = -1;\\n        for(long long i=0;i<edges.size();i++)\\n        {\\n            if(maxi<ans[i])\\n            {\\n                maxi=ans[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061232,
                "title": "java-beats-100-without-graph",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        long[] arr = new long[n];\\n\\n        //store the node score\\n        for(int i=0; i<n; i++){\\n            arr[edges[i]] += i;\\n        }\\n\\n        //get the max score and the node having max score\\n        long max = arr[0]; \\n        int idx = 0;\\n        for(int i=1; i<n; i++){\\n            if(arr[i] > max) {\\n                max = arr[i];\\n                idx = i; //node with max score\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        long[] arr = new long[n];\\n\\n        //store the node score\\n        for(int i=0; i<n; i++){\\n            arr[edges[i]] += i;\\n        }\\n\\n        //get the max score and the node having max score\\n        long max = arr[0]; \\n        int idx = 0;\\n        for(int i=1; i<n; i++){\\n            if(arr[i] > max) {\\n                max = arr[i];\\n                idx = i; //node with max score\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051473,
                "title": "simple-way-to-solve-it-within-2-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) : we iterate through edges once and then max function also gives O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) : we need to keep a track of all the scores.\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        score=[0]*(len(edges))\\n        for i in range(len(edges)):\\n            score[edges[i]]+=i\\n        return(score.index(max(score)))\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        score=[0]*(len(edges))\\n        for i in range(len(edges)):\\n            score[edges[i]]+=i\\n        return(score.index(max(score)))\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040014,
                "title": "edge-score-in-python-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nloop over edege\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain a nodeScore hash map nodeScore[i], highestScore, node\\nloop over edge and find the node with the highest\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        \"\"\"\\n            maintain a nodeScore hash map nodeScore[i], highestScore, node\\n            loop over edge and find the node with the highest\\n        \"\"\"\\n        n = len(edges)\\n\\n        # init\\n        nodeScore = [0 for _ in range(n)]\\n        highestScore = 0\\n        node = n\\n\\n        # loop\\n        for i, to in enumerate(edges):\\n            nodeScore[to] += i\\n\\n            if nodeScore[to] > highestScore:\\n                highestScore, node = nodeScore[to], to\\n            \\n            elif nodeScore[to] == highestScore and to < node:\\n                node = to\\n        \\n        return node\\n\\n\\n        \"\"\"\\n            edges = [1,0,0,0,0,7,7,5]\\n\\n            highestScore, node = 11, 7\\n            nodeScore:  0   1   2   3   4   5   6   7\\n                        10  0   0   0   0   5   0   11\\n\\n            i, to = 7, 5\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        \"\"\"\\n            maintain a nodeScore hash map nodeScore[i], highestScore, node\\n            loop over edge and find the node with the highest\\n        \"\"\"\\n        n = len(edges)\\n\\n        # init\\n        nodeScore = [0 for _ in range(n)]\\n        highestScore = 0\\n        node = n\\n\\n        # loop\\n        for i, to in enumerate(edges):\\n            nodeScore[to] += i\\n\\n            if nodeScore[to] > highestScore:\\n                highestScore, node = nodeScore[to], to\\n            \\n            elif nodeScore[to] == highestScore and to < node:\\n                node = to\\n        \\n        return node\\n\\n\\n        \"\"\"\\n            edges = [1,0,0,0,0,7,7,5]\\n\\n            highestScore, node = 11, 7\\n            nodeScore:  0   1   2   3   4   5   6   7\\n                        10  0   0   0   0   5   0   11\\n\\n            i, to = 7, 5\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020188,
                "title": "python-solution-beats-100-memory",
                "content": "# Intuition\\nWe can use dynamic programming and memoization to solve this problem efficiently.\\n\\n# Approach\\nIf we replicate the edges list we can store each node\\'s total edge value with a single pass of the initial list, updating our max value as we go.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def edgeScore(self, edges):\\n        \"\"\"\\n        :type edges: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Instatiate our tracking variables.\\n        largest_edge = len(edges) # Set to the highest impossible value.\\n        largest_edge_score = 0\\n        edge_scores = [0] * len(edges)\\n        # A node\\'s \"value\" is equal to its index in the array.\\n        for node_value, edge in enumerate(edges):\\n            edge_scores[edge] += node_value\\n            if edge_scores[edge] >= largest_edge_score:\\n                # If the score is equal, we want the smallest index.\\n                if edge_scores[edge] == largest_edge_score:\\n                    largest_edge = min(edge, largest_edge)\\n                else:\\n                    largest_edge = edge\\n                largest_edge_score = edge_scores[edge]\\n        return largest_edge\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def edgeScore(self, edges):\\n        \"\"\"\\n        :type edges: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Instatiate our tracking variables.\\n        largest_edge = len(edges) # Set to the highest impossible value.\\n        largest_edge_score = 0\\n        edge_scores = [0] * len(edges)\\n        # A node\\'s \"value\" is equal to its index in the array.\\n        for node_value, edge in enumerate(edges):\\n            edge_scores[edge] += node_value\\n            if edge_scores[edge] >= largest_edge_score:\\n                # If the score is equal, we want the smallest index.\\n                if edge_scores[edge] == largest_edge_score:\\n                    largest_edge = min(edge, largest_edge)\\n                else:\\n                    largest_edge = edge\\n                largest_edge_score = edge_scores[edge]\\n        return largest_edge\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018368,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();\\n        vector<long long> edgeScore(n , 0);\\n        long long maxi = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            edgeScore[edges[i]] += i;\\n            maxi = max(maxi , edgeScore[edges[i]]);\\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(edgeScore[i] == maxi) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();\\n        vector<long long> edgeScore(n , 0);\\n        long long maxi = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            edgeScore[edges[i]] += i;\\n            maxi = max(maxi , edgeScore[edges[i]]);\\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(edgeScore[i] == maxi) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018199,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int EdgeScore(int[] edges) \\n    {\\n        var scores = new long[edges.Length];\\n        \\n        var maxScoreIndex = 0;\\n\\n        for(int edge = 0; edge < edges.Length; edge++)\\n        {\\n            var score = edges[edge];\\n            scores[score] += edge;\\n            if(scores[score] > scores[maxScoreIndex])\\n                maxScoreIndex = score;\\n            if(scores[score] == scores[maxScoreIndex])  \\n                maxScoreIndex = Math.Min(maxScoreIndex, score);\\n        }\\n\\n        return maxScoreIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Graph"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int EdgeScore(int[] edges) \\n    {\\n        var scores = new long[edges.Length];\\n        \\n        var maxScoreIndex = 0;\\n\\n        for(int edge = 0; edge < edges.Length; edge++)\\n        {\\n            var score = edges[edge];\\n            scores[score] += edge;\\n            if(scores[score] > scores[maxScoreIndex])\\n                maxScoreIndex = score;\\n            if(scores[score] == scores[maxScoreIndex])  \\n                maxScoreIndex = Math.Min(maxScoreIndex, score);\\n        }\\n\\n        return maxScoreIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981980,
                "title": "map-c-easy-solution-simple-code-aasan",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int,long long> map;\\n        for(int i = 0 ; i < edges.size();i++)\\n        {   \\n            map[edges[i]]+=i;\\n        }\\n\\n        int ans = 0;\\n        long long  mx = LLONG_MIN;\\n\\n        for(auto x : map)\\n        {\\n            if(x.second == mx){ans = min(x.first,ans);}\\n            if(x.second >mx){mx = x.second;ans = x.first;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int,long long> map;\\n        for(int i = 0 ; i < edges.size();i++)\\n        {   \\n            map[edges[i]]+=i;\\n        }\\n\\n        int ans = 0;\\n        long long  mx = LLONG_MIN;\\n\\n        for(auto x : map)\\n        {\\n            if(x.second == mx){ans = min(x.first,ans);}\\n            if(x.second >mx){mx = x.second;ans = x.first;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978257,
                "title": "java-hashmap-0-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        Map<Integer, Long> graph = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            if (graph.containsKey(edges[i])) {\\n                long score = graph.get(edges[i]) + i;\\n                graph.put(edges[i], score);\\n            } else {\\n                graph.put(edges[i], (long) i);\\n            }\\n        }\\n\\n        int minIndex = Integer.MAX_VALUE;\\n        long maxEdgeScore = Long.MIN_VALUE;\\n        for (int key: graph.keySet()) {\\n            long edgeScore = graph.get(key);\\n            if (edgeScore > maxEdgeScore) {\\n                minIndex = key;\\n                maxEdgeScore = edgeScore;\\n            } else if (edgeScore == maxEdgeScore && key < minIndex) {\\n                minIndex = key;\\n                maxEdgeScore = edgeScore;\\n            }\\n        }\\n\\n        return minIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        Map<Integer, Long> graph = new HashMap<>();\\n        for (int i = 0; i < edges.length; i++) {\\n            if (graph.containsKey(edges[i])) {\\n                long score = graph.get(edges[i]) + i;\\n                graph.put(edges[i], score);\\n            } else {\\n                graph.put(edges[i], (long) i);\\n            }\\n        }\\n\\n        int minIndex = Integer.MAX_VALUE;\\n        long maxEdgeScore = Long.MIN_VALUE;\\n        for (int key: graph.keySet()) {\\n            long edgeScore = graph.get(key);\\n            if (edgeScore > maxEdgeScore) {\\n                minIndex = key;\\n                maxEdgeScore = edgeScore;\\n            } else if (edgeScore == maxEdgeScore && key < minIndex) {\\n                minIndex = key;\\n                maxEdgeScore = edgeScore;\\n            }\\n        }\\n\\n        return minIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975509,
                "title": "just-make-adjacency-list-easy",
                "content": "\\n\\n# Approach\\nJust reverse all the edges given in the question.\\n\\n# Complexity\\n- Time complexity:\\no(n*n)\\n\\n- Space complexity:\\no(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n           adj[edges[i]].push_back(i);\\n        }\\n\\n        long long int ans=-1;\\n        int ind=INT_MAX;\\n        long long int  sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=0;\\n            if(adj[i].size()>0)\\n           { for(auto x:adj[i])\\n            {\\n                sum+=x;\\n            }}\\n            \\n            if(sum>ans)\\n            {\\n              ind=i;\\n              ans=sum;\\n            }\\n            \\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n           adj[edges[i]].push_back(i);\\n        }\\n\\n        long long int ans=-1;\\n        int ind=INT_MAX;\\n        long long int  sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=0;\\n            if(adj[i].size()>0)\\n           { for(auto x:adj[i])\\n            {\\n                sum+=x;\\n            }}\\n            \\n            if(sum>ans)\\n            {\\n              ind=i;\\n              ans=sum;\\n            }\\n            \\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951724,
                "title": "counting-100-java-submission",
                "content": "class Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        long count[]=new long[n];\\n        long max=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            count[edges[i]]+=i;\\n            max=Math.max(max, count[edges[i]]);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(count[i]==max)\\n                return i;\\n        }\\n        \\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "class Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        long count[]=new long[n];\\n        long max=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            count[edges[i]]+=i;\\n            max=Math.max(max, count[edges[i]]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3930924,
                "title": "this-is-not-at-all-question-of-graph",
                "content": "# Intuition\\nPrioritize nodes that receive edges from nodes with higher indices. The higher the index of the node that points to a particular node, the higher the contribution to that node\\'s score.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> score(n, 0);\\n        for(int i = 0 ; i < n; i++){\\n            score[edges[i]] += i;\\n        }\\n        long long maxi_index = -1;\\n        long long maxi = 0;\\n        for(int i = 0; i < n ; i++){\\n            if(score[i] > maxi){\\n                maxi = score[i];\\n                maxi_index = i;\\n            }\\n        }\\n        return maxi_index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> score(n, 0);\\n        for(int i = 0 ; i < n; i++){\\n            score[edges[i]] += i;\\n        }\\n        long long maxi_index = -1;\\n        long long maxi = 0;\\n        for(int i = 0; i < n ; i++){\\n            if(score[i] > maxi){\\n                maxi = score[i];\\n                maxi_index = i;\\n            }\\n        }\\n        return maxi_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905239,
                "title": "easy-java-solution-beats-89-of-all-java-solution-no-hashmap-and-no-graphs",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int maximum = 0; \\n        for(int i=0; i<edges.length; i++) {\\n            if(edges[i]>maximum) {\\n                maximum=edges[i] ;\\n            }\\n        }\\n        long arr[] = new long[maximum+1] ;\\n        for(int i=0; i<edges.length; i++) {\\n            arr[edges[i]] += i ;  \\n        }\\n        long maxval = arr[0] ;\\n        int maxidx = 0; \\n        for(int i=1; i<arr.length; i++) {\\n            if(arr[i]>maxval) {\\n                maxval = arr[i] ;\\n                maxidx = i ;\\n            }\\n        }\\n        return maxidx ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int maximum = 0; \\n        for(int i=0; i<edges.length; i++) {\\n            if(edges[i]>maximum) {\\n                maximum=edges[i] ;\\n            }\\n        }\\n        long arr[] = new long[maximum+1] ;\\n        for(int i=0; i<edges.length; i++) {\\n            arr[edges[i]] += i ;  \\n        }\\n        long maxval = arr[0] ;\\n        int maxidx = 0; \\n        for(int i=1; i<arr.length; i++) {\\n            if(arr[i]>maxval) {\\n                maxval = arr[i] ;\\n                maxidx = i ;\\n            }\\n        }\\n        return maxidx ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904207,
                "title": "java-simple-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        HashMap<Integer,Long> map=new HashMap<>();\\n        for (int i=0;i<n;i++){\\n            if (map.containsKey(edges[i])) map.put(edges[i],(long)map.get(edges[i])+i);\\n            else map.put(edges[i],(long)i);\\n        }\\n        int res=0;\\n        long count=0;\\n        for (Map.Entry<Integer,Long> entry:map.entrySet()){\\n            int key=entry.getKey();\\n            long val=entry.getValue();\\n            if (val>count){\\n                count=val;\\n                res=key;\\n            }\\n            if (val==count){\\n                if (key<res) res=key;                \\n            }\\n        }        \\n        return res;  \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        HashMap<Integer,Long> map=new HashMap<>();\\n        for (int i=0;i<n;i++){\\n            if (map.containsKey(edges[i])) map.put(edges[i],(long)map.get(edges[i])+i);\\n            else map.put(edges[i],(long)i);\\n        }\\n        int res=0;\\n        long count=0;\\n        for (Map.Entry<Integer,Long> entry:map.entrySet()){\\n            int key=entry.getKey();\\n            long val=entry.getValue();\\n            if (val>count){\\n                count=val;\\n                res=key;\\n            }\\n            if (val==count){\\n                if (key<res) res=key;                \\n            }\\n        }        \\n        return res;  \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891330,
                "title": "simple-two-pass-solution-c",
                "content": "# Intuition\\nThis doesn\\'t require graph knowledge to be honest, just see the problem like though it is a `normal arrays problem where you have to find the score of the node by adding those indexes which have the value of the index`. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a answer array where you just store the ans for each node. And whenever you see a node just increment that node\\'s value by the index you are currently at.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(2*N) ~ O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int long long> ans(edges.size(), 0);\\n        for(int i=0;i<n;i++) {\\n            ans[edges[i]]+=i;\\n        }\\n        int long long maxi = ans[n-1];\\n        int idx = n-1;\\n        for(int i=n-2;i>=0;i--) {\\n            if(ans[i] >= maxi) {\\n                maxi = ans[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int long long> ans(edges.size(), 0);\\n        for(int i=0;i<n;i++) {\\n            ans[edges[i]]+=i;\\n        }\\n        int long long maxi = ans[n-1];\\n        int idx = n-1;\\n        for(int i=n-2;i>=0;i--) {\\n            if(ans[i] >= maxi) {\\n                maxi = ans[i];\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889197,
                "title": "c-tc-o-n-sc-o-n-2-simple-steps-shortest-code",
                "content": "# Intuition\\nprecalculate sums vector in one array pass. Realizing the pair (edge[i], i) tells that the right value (i) should be added to the value of index (edge[i]),\\n\\nSecondly, the path to find the max of vector sums, not updating the max index value if coming across equal elements (to keep the lowest index in case of equality).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        vector<long> sums(edges.size());\\n        for (int i=0; i<edges.size(); i++) {\\n            sums[edges[i]] += i;\\n        }\\n        int max_i = 0;\\n        for(int i=0; i<sums.size(); i++) {\\n            // \\'>=\\' operator is BAD. \\'>\\' is a must in order to keep the lowest index. \\n            if (sums[i] > sums[max_i]) max_i = i;\\n        }\\n        return max_i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        vector<long> sums(edges.size());\\n        for (int i=0; i<edges.size(); i++) {\\n            sums[edges[i]] += i;\\n        }\\n        int max_i = 0;\\n        for(int i=0; i<sums.size(); i++) {\\n            // \\'>=\\' operator is BAD. \\'>\\' is a must in order to keep the lowest index. \\n            if (sums[i] > sums[max_i]) max_i = i;\\n        }\\n        return max_i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837992,
                "title": "simple-beats-97",
                "content": "# Intuition\\nTraverse the edge and increase the node score.\\n\\n# Complexity\\n- Time complexity: O(n), n = node.\\n- Space complexity: O(n), n = node.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} edges\\n * @return {number}\\n */\\nvar edgeScore = function(edges) {\\n    const edgeScore = Array(edges.length).fill(0);\\n    for(let node=0; node<edges.length; node++) {\\n        edgeScore[edges[node]] += node\\n    }\\n    let res;\\n    let maxScore = -1;\\n    for(let node=0; node<edges.length; node++) {\\n        if(edgeScore[node] > maxScore) {\\n            maxScore = edgeScore[node];\\n            res = node;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} edges\\n * @return {number}\\n */\\nvar edgeScore = function(edges) {\\n    const edgeScore = Array(edges.length).fill(0);\\n    for(let node=0; node<edges.length; node++) {\\n        edgeScore[edges[node]] += node\\n    }\\n    let res;\\n    let maxScore = -1;\\n    for(let node=0; node<edges.length; node++) {\\n        if(edgeScore[node] > maxScore) {\\n            maxScore = edgeScore[node];\\n            res = node;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835303,
                "title": "c-faster-than-100-precise-solution-w-approach",
                "content": "# Approach\\nwe create a \\'**indegreeSum**\\' array that stores the sum of all the nodes that points to that particular index.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\ntaken by the \\'indegreeSum\\' array\\n\\nPlease UPVOTE if it helped you, or if u believe this can help others!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n\\n        long long n = edges.size();\\n        vector<long long> indegreeSum(n, 0);\\n\\n        for(int i=0; i<n; i++){\\n\\n            int num = i; // the node that is currentNode\\n            int adjnode = edges[i]; \\n\\n            indegreeSum[adjnode] += (long long) num;\\n        }\\n\\n        long long maxsum = -1e5;\\n        int ansNode=0;\\n\\n        for(int i=0; i<n; i++){\\n            if(indegreeSum[i]>maxsum){\\n                ansNode = i;\\n                maxsum = indegreeSum[i];\\n            }\\n        }\\n\\n        return ansNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n\\n        long long n = edges.size();\\n        vector<long long> indegreeSum(n, 0);\\n\\n        for(int i=0; i<n; i++){\\n\\n            int num = i; // the node that is currentNode\\n            int adjnode = edges[i]; \\n\\n            indegreeSum[adjnode] += (long long) num;\\n        }\\n\\n        long long maxsum = -1e5;\\n        int ansNode=0;\\n\\n        for(int i=0; i<n; i++){\\n            if(indegreeSum[i]>maxsum){\\n                ansNode = i;\\n                maxsum = indegreeSum[i];\\n            }\\n        }\\n\\n        return ansNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828693,
                "title": "c-indegree-concept-faster-than-100-no-hashmaps",
                "content": "faster than 100% c++ | done with indegree concept\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n= edges.size();\\n        vector<long long> edgeScores(n,-1);\\n        \\n        for(int i=0; i<n; i++){\\n            edgeScores[edges[i]]+=i;\\n        }\\n        \\n        long long maxi =-1;\\n        long long res=0;\\n        for(int i=0; i<n; i++){\\n            if(edgeScores[i] >maxi){\\n                res=i;\\n                maxi = edgeScores[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n= edges.size();\\n        vector<long long> edgeScores(n,-1);\\n        \\n        for(int i=0; i<n; i++){\\n            edgeScores[edges[i]]+=i;\\n        }\\n        \\n        long long maxi =-1;\\n        long long res=0;\\n        for(int i=0; i<n; i++){\\n            if(edgeScores[i] >maxi){\\n                res=i;\\n                maxi = edgeScores[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818713,
                "title": "counting",
                "content": "```\\nint edgeScore(vector<int>& e)\\n{\\n\\tint out{};\\n\\tlong long m[100001]{}, M{LONG_MIN};\\n\\tfor(int i{}; i<size(e); ++i)\\n\\t{\\n\\t\\tm[e[i]] += i;\\n\\t\\tif(m[e[i]]==M) out=min(out,e[i]);\\n\\t\\telse if(m[e[i]]>M) out=e[i], M=m[e[i]];\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint edgeScore(vector<int>& e)\\n{\\n\\tint out{};\\n\\tlong long m[100001]{}, M{LONG_MIN};\\n\\tfor(int i{}; i<size(e); ++i)\\n\\t{\\n\\t\\tm[e[i]] += i;\\n\\t\\tif(m[e[i]]==M) out=min(out,e[i]);\\n\\t\\telse if(m[e[i]]>M) out=e[i], M=m[e[i]];\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816351,
                "title": "c-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long long int n = edges.size();\\n        unordered_map<long long int,long long int>mp;\\n\\n        for(long long int i=0;i<n;i++){\\n            mp[edges[i]]+=i;\\n        }\\n\\n        long long int idxScore=INT_MIN;\\n        long long int ans=INT_MAX;\\n\\n        for(auto i:mp){\\n            if(i.second>idxScore){\\n                idxScore=i.second;\\n                ans = i.first;\\n            }\\n            if(i.second==idxScore){\\n                //ans = min(ans, i.first);\\n                if(i.first<ans){\\n                    ans = i.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long long int n = edges.size();\\n        unordered_map<long long int,long long int>mp;\\n\\n        for(long long int i=0;i<n;i++){\\n            mp[edges[i]]+=i;\\n        }\\n\\n        long long int idxScore=INT_MIN;\\n        long long int ans=INT_MAX;\\n\\n        for(auto i:mp){\\n            if(i.second>idxScore){\\n                idxScore=i.second;\\n                ans = i.first;\\n            }\\n            if(i.second==idxScore){\\n                //ans = min(ans, i.first);\\n                if(i.first<ans){\\n                    ans = i.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816291,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int size=*max_element(edges.begin(),edges.end());\\n        vector<long long>dp(size+1,0);\\n        for(int i=0;i<edges.size();i++) dp[edges[i]]+=i;\\n        return max_element(dp.begin(),dp.end())-dp.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int size=*max_element(edges.begin(),edges.end());\\n        vector<long long>dp(size+1,0);\\n        for(int i=0;i<edges.size();i++) dp[edges[i]]+=i;\\n        return max_element(dp.begin(),dp.end())-dp.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814086,
                "title": "javascript-o-e-time-and-space",
                "content": "```\\n/**\\n * @param {number[]} edges\\n * @return {number}\\n */\\nvar edgeScore = function(edges) {\\n  const edgeScores = new Array(edges.length).fill(0);\\n  edges.forEach((v, u) => {\\n    edgeScores[v] += u;\\n  });\\n  let maxScore = 0;\\n  let maxIndex = 0;\\n  for (let i = 0; i < edgeScores.length; i++) {\\n    if (edgeScores[i] > maxScore) {\\n      maxScore = edgeScores[i];\\n      maxIndex = i;\\n    }\\n  }\\n  return maxIndex;      \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} edges\\n * @return {number}\\n */\\nvar edgeScore = function(edges) {\\n  const edgeScores = new Array(edges.length).fill(0);\\n  edges.forEach((v, u) => {\\n    edgeScores[v] += u;\\n  });\\n  let maxScore = 0;\\n  let maxIndex = 0;\\n  for (let i = 0; i < edgeScores.length; i++) {\\n    if (edgeScores[i] > maxScore) {\\n      maxScore = edgeScores[i];\\n      maxIndex = i;\\n    }\\n  }\\n  return maxIndex;      \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3801508,
                "title": "simple-java-solution-in-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmaking array to store all nodes sum of labels\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse through temporary array to get highest value node and make it as answer\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(ans[edges[i]]<1000000001){\\n                ans[edges[i]]+=i;\\n            }\\n        }\\n        int temp=-1;\\n        int t=-1;\\n        for(int i=0;i<n;i++){\\n            //System.out.print(ans[i]+\" \");\\n            if(temp<ans[i]){\\n                temp=ans[i];\\n                t=i;\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            if(ans[edges[i]]<1000000001){\\n                ans[edges[i]]+=i;\\n            }\\n        }\\n        int temp=-1;\\n        int t=-1;\\n        for(int i=0;i<n;i++){\\n            //System.out.print(ans[i]+\" \");\\n            if(temp<ans[i]){\\n                temp=ans[i];\\n                t=i;\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793369,
                "title": "simple-o-n-m-solution-using-dfs-and-reversing-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse DFS and reverse edges to get O(n + m) time solution \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$O(n + m)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$O(n + m)$\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n\\n\\n        adjList = {} \\n\\n        n = len(edges)\\n\\n        for i in range(n): adjList[i] = []\\n\\n\\n        for i in range(n):\\n\\n            adjList[edges[i]].append(i)\\n\\n\\n        edge_score = [0 for i in range(n)]\\n\\n        explored = [False for i in range(n)]\\n\\n        def search(v):\\n\\n\\n            explored[v] = True \\n\\n            for w in adjList[v]:\\n                edge_score[v] += w \\n                if not explored[w]: \\n                    search(w) \\n     \\n\\n        def dfs():\\n            for i in range(n):\\n                if not explored[i]:\\n                    search(i) \\n\\n        dfs()\\n\\n\\n        max_score = max(edge_score) \\n\\n        for i in range(n):\\n            if edge_score[i] == max_score:\\n                return i\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n\\n\\n        adjList = {} \\n\\n        n = len(edges)\\n\\n        for i in range(n): adjList[i] = []\\n\\n\\n        for i in range(n):\\n\\n            adjList[edges[i]].append(i)\\n\\n\\n        edge_score = [0 for i in range(n)]\\n\\n        explored = [False for i in range(n)]\\n\\n        def search(v):\\n\\n\\n            explored[v] = True \\n\\n            for w in adjList[v]:\\n                edge_score[v] += w \\n                if not explored[w]: \\n                    search(w) \\n     \\n\\n        def dfs():\\n            for i in range(n):\\n                if not explored[i]:\\n                    search(i) \\n\\n        dfs()\\n\\n\\n        max_score = max(edge_score) \\n\\n        for i in range(n):\\n            if edge_score[i] == max_score:\\n                return i\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765608,
                "title": "easy-java-solution-using-normal-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long score[]=new long[edges.length];\\n        long max=Integer.MIN_VALUE;\\n        int val=-1;\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            score[edges[i]]+=(long)i;\\n        }\\n          for(int i=0; i<edges.length; i++)\\n        {\\n            if(max<score[i])\\n            {\\n                val=i;\\n                max=score[i];\\n            }\\n        }\\n       \\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long score[]=new long[edges.length];\\n        long max=Integer.MIN_VALUE;\\n        int val=-1;\\n        for(int i=0; i<edges.length; i++)\\n        {\\n            score[edges[i]]+=(long)i;\\n        }\\n          for(int i=0; i<edges.length; i++)\\n        {\\n            if(max<score[i])\\n            {\\n                val=i;\\n                max=score[i];\\n            }\\n        }\\n       \\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754331,
                "title": "simple-c-easy-solution-using-adjacency-list-only",
                "content": "# Intuition\\nUse adjacency list to store the sum corresponding to every node.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<pair<long long,long long>> adjsum(n);\\n        for(long long i=0;i<n;i++){\\n            adjsum[i]={i,0};\\n        }\\n        long long maxi=-1e8;\\n        for(long long i=0;i<edges.size();i++){\\n            adjsum[edges[i]].second+=i;\\n            maxi=max(maxi,adjsum[edges[i]].second);\\n        }\\n        for(auto it:adjsum){\\n            if(it.second==maxi){\\n                return it.first;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<pair<long long,long long>> adjsum(n);\\n        for(long long i=0;i<n;i++){\\n            adjsum[i]={i,0};\\n        }\\n        long long maxi=-1e8;\\n        for(long long i=0;i<edges.size();i++){\\n            adjsum[edges[i]].second+=i;\\n            maxi=max(maxi,adjsum[edges[i]].second);\\n        }\\n        for(auto it:adjsum){\\n            if(it.second==maxi){\\n                return it.first;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725173,
                "title": "java-solution-just-make-a-reverse-adjacency-list-2-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n\\n        //STEP 1: Just making the reverse Adjacency List\\n        int n=edges.length;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList(0));\\n        for(int i=0;i<n;i++){\\n            adj.get(edges[i]).add(i);\\n        }\\n\\n        //STEP 2: Adding the contents of each list and taking the max position\\n        int ans=0;\\n        long max=-1;\\n        for(int i=0;i<n;i++){\\n            long sum=0;\\n            for(int j=0;j<adj.get(i).size();j++){\\n                sum=sum+adj.get(i).get(j);\\n            }\\n            if(sum>max){\\n                max=sum;\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n\\n        //STEP 1: Just making the reverse Adjacency List\\n        int n=edges.length;\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList(0));\\n        for(int i=0;i<n;i++){\\n            adj.get(edges[i]).add(i);\\n        }\\n\\n        //STEP 2: Adding the contents of each list and taking the max position\\n        int ans=0;\\n        long max=-1;\\n        for(int i=0;i<n;i++){\\n            long sum=0;\\n            for(int j=0;j<adj.get(i).size();j++){\\n                sum=sum+adj.get(i).get(j);\\n            }\\n            if(sum>max){\\n                max=sum;\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705060,
                "title": "java-hashmap-easy-to-understand-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n\\n        long[] result=new long[edges.length];\\n\\n        for(int i=0;i<edges.length;i++){\\n            result[edges[i]]+=i;\\n        }\\n\\n        int index=-1;\\n        long max=0;\\n\\n        for(int i=0;i<result.length;i++){\\n            if(max<result[i]){\\n                max=result[i];\\n                index=i;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n\\n        long[] result=new long[edges.length];\\n\\n        for(int i=0;i<edges.length;i++){\\n            result[edges[i]]+=i;\\n        }\\n\\n        int index=-1;\\n        long max=0;\\n\\n        for(int i=0;i<result.length;i++){\\n            if(max<result[i]){\\n                max=result[i];\\n                index=i;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701101,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        vector<long long> sum(edges.size());\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            sum[edges[i]]+=i;\\n        }  \\n\\n        return max_element(sum.begin(),sum.end())-sum.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        vector<long long> sum(edges.size());\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            sum[edges[i]]+=i;\\n        }  \\n\\n        return max_element(sum.begin(),sum.end())-sum.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683368,
                "title": "easy-solution-in-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def edgeScore(self, edges: [int]) -> int:\\n        scores = {}\\n        max_score = 0\\n\\n        for i in range(len(edges)):\\n            if edges[i] not in scores:\\n                scores[edges[i]] = 0\\n            scores[edges[i]] += i\\n\\n            if scores[edges[i]] > max_score:\\n                max_score = scores[edges[i]]\\n\\n        max_nodes = []\\n        for node in scores:\\n            if scores[node] == max_score:\\n                max_nodes.append(node)\\n\\n        return min(max_nodes)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n\\n    def edgeScore(self, edges: [int]) -> int:\\n        scores = {}\\n        max_score = 0\\n\\n        for i in range(len(edges)):\\n            if edges[i] not in scores:\\n                scores[edges[i]] = 0\\n            scores[edges[i]] += i\\n\\n            if scores[edges[i]] > max_score:\\n                max_score = scores[edges[i]]\\n\\n        max_nodes = []\\n        for node in scores:\\n            if scores[node] == max_score:\\n                max_nodes.append(node)\\n\\n        return min(max_nodes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665169,
                "title": "easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        map<int,long long>m;\\n        for(int i=0;i<n;i++){\\n            m[edges[i]]+=i;\\n        }\\n        int node=INT_MIN;\\n        long long score=INT_MIN;\\n        for(auto i=m.begin();i!=m.end();i++){\\n            if(i->second>score){\\n                score=i->second;\\n                node=i->first;\\n            }\\n            else if(i->second==score){\\n                if(i->first<node){\\n                    node=i->first;\\n                }\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        map<int,long long>m;\\n        for(int i=0;i<n;i++){\\n            m[edges[i]]+=i;\\n        }\\n        int node=INT_MIN;\\n        long long score=INT_MIN;\\n        for(auto i=m.begin();i!=m.end();i++){\\n            if(i->second>score){\\n                score=i->second;\\n                node=i->first;\\n            }\\n            else if(i->second==score){\\n                if(i->first<node){\\n                    node=i->first;\\n                }\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629925,
                "title": "c-solution-simple-easy-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        vector<int> vec[n+1];\\n\\n        vector<long long int> ans(n+1,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            vec[i].push_back(edges[i]);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto it: vec[i])\\n            {\\n                ans[it] += i;\\n            }\\n        }\\n\\n        long long int mainans = 0,ans2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans[i]>mainans)\\n            {\\n                mainans = ans[i];\\n                ans2 = i;\\n            }\\n        }\\n\\n        return ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        vector<int> vec[n+1];\\n\\n        vector<long long int> ans(n+1,0);\\n        for(int i=0; i<n; i++)\\n        {\\n            vec[i].push_back(edges[i]);\\n        }\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            for(auto it: vec[i])\\n            {\\n                ans[it] += i;\\n            }\\n        }\\n\\n        long long int mainans = 0,ans2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans[i]>mainans)\\n            {\\n                mainans = ans[i];\\n                ans2 = i;\\n            }\\n        }\\n\\n        return ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602325,
                "title": "java-4ms-91-and-clean-code",
                "content": "# Approach\\n1. Use a long[] indegree to track the indegree of each node.\\n2. Traverse edges with index i and add i to indegree of that edge (indegree[edge[i]]).\\n3. Keep track of maxScore and minIndex.\\n4. If indegree > maxScore, set new maxScore and new minIndex\\n5. if indegree[edge[i]] == maxScore, set minIndex = min(minIndex, edge[i]);\\n6. Return minIndex;\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long[] indegree = new long[edges.length];\\n        long maxScore = 0;\\n        int maxScoreMinIndex = 0;\\n        for (int i = 0; i < edges.length; i++) {\\n            indegree[edges[i]] += i;\\n            if (indegree[edges[i]] > maxScore) {\\n                maxScore = indegree[edges[i]];\\n                maxScoreMinIndex = edges[i];\\n            } else if (indegree[edges[i]] == maxScore) {\\n                maxScoreMinIndex = Math.min(maxScoreMinIndex, edges[i]);\\n            }\\n        }\\n        return maxScoreMinIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        long[] indegree = new long[edges.length];\\n        long maxScore = 0;\\n        int maxScoreMinIndex = 0;\\n        for (int i = 0; i < edges.length; i++) {\\n            indegree[edges[i]] += i;\\n            if (indegree[edges[i]] > maxScore) {\\n                maxScore = indegree[edges[i]];\\n                maxScoreMinIndex = edges[i];\\n            } else if (indegree[edges[i]] == maxScore) {\\n                maxScoreMinIndex = Math.min(maxScoreMinIndex, edges[i]);\\n            }\\n        }\\n        return maxScoreMinIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600934,
                "title": "java-tc-o-n-sc-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        long[] edgeScore = new long[n];\\n        long maxScore = 0;\\n        int maxScoreEdge = 0;\\n        for(int i=0;i<n;i++) {\\n            int u = i;\\n            int v = edges[i];\\n            edgeScore[v] += u;\\n            if(edgeScore[v] > maxScore) {\\n                maxScore = edgeScore[v];\\n                maxScoreEdge = v;\\n            }\\n            else if(edgeScore[v] == maxScore && maxScoreEdge > v){\\n                 maxScoreEdge = v;\\n            }\\n        }\\n        return maxScoreEdge;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        long[] edgeScore = new long[n];\\n        long maxScore = 0;\\n        int maxScoreEdge = 0;\\n        for(int i=0;i<n;i++) {\\n            int u = i;\\n            int v = edges[i];\\n            edgeScore[v] += u;\\n            if(edgeScore[v] > maxScore) {\\n                maxScore = edgeScore[v];\\n                maxScoreEdge = v;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3561334,
                "title": "java-clean-and-simple",
                "content": "```\\npublic int edgeScore(int[] arr) {\\n\\tlong count[] = new long[arr.length+1], maxVal = -1;\\n\\tfor (int i=0;i<arr.length;i++) count[arr[i]]+=i;\\n\\n\\tint maxNode=0;\\n\\tfor (int i=0;i<count.length;i++){\\n\\t\\tint node = i; \\n\\t\\tlong val = count[i];\\n\\t\\tif (maxVal<val){\\n\\t\\t\\tmaxVal  = val;\\n\\t\\t\\tmaxNode = node;\\n\\t\\t} \\n\\t}\\n\\treturn maxNode;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int edgeScore(int[] arr) {\\n\\tlong count[] = new long[arr.length+1], maxVal = -1;\\n\\tfor (int i=0;i<arr.length;i++) count[arr[i]]+=i;\\n\\n\\tint maxNode=0;\\n\\tfor (int i=0;i<count.length;i++){\\n\\t\\tint node = i; \\n\\t\\tlong val = count[i];\\n\\t\\tif (maxVal<val){\\n\\t\\t\\tmaxVal  = val;\\n\\t\\t\\tmaxNode = node;\\n\\t\\t} \\n\\t}\\n\\treturn maxNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3559550,
                "title": "ruby-in-3-lines",
                "content": "```ruby\\n# @param {Integer[]} edges\\n# @return {Integer}\\ndef edge_score(edges)\\n  scores_by_node = Hash.new(0)\\n  edges.each_with_index { |to_node, from_node| scores_by_node[to_node] += from_node }\\n  scores_by_node.sort_by{ |key, val| [val, -key]}[-1][0]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} edges\\n# @return {Integer}\\ndef edge_score(edges)\\n  scores_by_node = Hash.new(0)\\n  edges.each_with_index { |to_node, from_node| scores_by_node[to_node] += from_node }\\n  scores_by_node.sort_by{ |key, val| [val, -key]}[-1][0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3557472,
                "title": "c-easiest-sol-intuitive-approach-simple-for-loop",
                "content": "# Intuition\\n![leetcode1.png](https://assets.leetcode.com/users/images/52e87711-cb02-4eec-ae67-b746329893e8_1684901199.7571764.png)\\n\\nSimplest problem ever in the edges array we are given that which nodes are points to which nodes it simply means if we simply count the total sum of all nodes pointing to a particular node and take the max and report the answer\\n\\n# Approach\\nwhat i did was to main the sum of all nodes pointing to a particular node and then returned the index of max value node\\n\\n# Complexity\\n- Time complexity:\\nO(V) where V is the no of Vertices\\n- Space complexity:\\nO(V) the space needed for the extra array created to maintain the sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long n=edges.size();\\n        vector<long> ans(n,0);\\n        for(long i=0; i<n; i++){\\n            ans[edges[i]]+=i;\\n        }\\n        long fans=INT_MIN;\\n        long index=-1;\\n        for(long i=0;i<n; i++){\\n            cout<<ans[i]<<\" \";\\n            if(ans[i]>fans){\\n                fans=ans[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long n=edges.size();\\n        vector<long> ans(n,0);\\n        for(long i=0; i<n; i++){\\n            ans[edges[i]]+=i;\\n        }\\n        long fans=INT_MIN;\\n        long index=-1;\\n        for(long i=0;i<n; i++){\\n            cout<<ans[i]<<\" \";\\n            if(ans[i]>fans){\\n                fans=ans[i];\\n                index=i;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3537322,
                "title": "node-with-highest-edge-score-easy-approach-no-graph",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        long long int n = edges.size();\\n        vector<long long int>v(n,0);\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            v[edges[i]] += i;\\n        }\\n        long long int ans = INT_MIN;\\n        long long int x = -1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(v[i]>ans)\\n            {\\n                ans = v[i];\\n                x = i;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n        long long int n = edges.size();\\n        vector<long long int>v(n,0);\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            v[edges[i]] += i;\\n        }\\n        long long int ans = INT_MIN;\\n        long long int x = -1;\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(v[i]>ans)\\n            {\\n                ans = v[i];\\n                x = i;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532070,
                "title": "c-solution-o-n-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<long long ,long long > mp;\\n        long long int ans = INT_MAX;\\n        long long int count = 0;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i]] += i;\\n            if(mp[edges[i]]>count){\\n                ans = edges[i];\\n                count = mp[edges[i]];\\n            }\\n            else if(mp[edges[i]]==count){\\n                ans = min(ans,(long long)edges[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<long long ,long long > mp;\\n        long long int ans = INT_MAX;\\n        long long int count = 0;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i]] += i;\\n            if(mp[edges[i]]>count){\\n                ans = edges[i];\\n                count = mp[edges[i]];\\n            }\\n            else if(mp[edges[i]]==count){\\n                ans = min(ans,(long long)edges[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520147,
                "title": "easiest-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n       long long  res = 0 ,mx = INT_MIN;\\n       unordered_map<long long ,long long > m ; //{node no ,node score}\\n\\n       for(long long  i  = 0 ; i<edges.size();i++)\\n       {\\n           long long  node = edges[i];\\n           if(m.find(node)==m.end())\\n           m[node] = i ;\\n           else m[node] += i ; \\n       }\\n       for(auto x:m)\\n       {\\n           if(x.second>mx)\\n           {\\n               mx = x.second;\\n               res = x.first;\\n           }\\n           if(x.second==mx && x.first<res) // to get the min if value is same \\n           res = x.first;\\n       }\\n       return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n    {\\n       long long  res = 0 ,mx = INT_MIN;\\n       unordered_map<long long ,long long > m ; //{node no ,node score}\\n\\n       for(long long  i  = 0 ; i<edges.size();i++)\\n       {\\n           long long  node = edges[i];\\n           if(m.find(node)==m.end())\\n           m[node] = i ;\\n           else m[node] += i ; \\n       }\\n       for(auto x:m)\\n       {\\n           if(x.second>mx)\\n           {\\n               mx = x.second;\\n               res = x.first;\\n           }\\n           if(x.second==mx && x.first<res) // to get the min if value is same \\n           res = x.first;\\n       }\\n       return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512207,
                "title": "easy-peasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> adj(n,0);\\n        for(int i= 0; i<edges.size(); ++i){\\n            adj[edges[i]] =(long long)(adj[edges[i]] +(long long) i);\\n        }\\n        long long ans = INT_MIN; \\n        int temp = -1;\\n        for(int i = 0; i<n; ++i){\\n            if(adj[i] > ans){\\n                ans = adj[i];\\n                temp = i;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> adj(n,0);\\n        for(int i= 0; i<edges.size(); ++i){\\n            adj[edges[i]] =(long long)(adj[edges[i]] +(long long) i);\\n        }\\n        long long ans = INT_MIN; \\n        int temp = -1;\\n        for(int i = 0; i<n; ++i){\\n            if(adj[i] > ans){\\n                ans = adj[i];\\n                temp = i;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507705,
                "title": "simplest-c-code-shortest-code-easy-to-understand",
                "content": "# Intuition : Just see which node is connected to which.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Important to notice there is only one outgoing edge from each node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& a) {\\n        vector<long long int> ct(a.size(),0);\\n        int mx=0;\\n        for(int i=0;i<a.size();i++){\\n            int u=i,v=a[i];\\n            ct[v]+=u;\\n        }\\n        for(int i=0;i<a.size();i++) if(ct[mx]<ct[i]) mx=i;\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& a) {\\n        vector<long long int> ct(a.size(),0);\\n        int mx=0;\\n        for(int i=0;i<a.size();i++){\\n            int u=i,v=a[i];\\n            ct[v]+=u;\\n        }\\n        for(int i=0;i<a.size();i++) if(ct[mx]<ct[i]) mx=i;\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474728,
                "title": "node-with-highest-edge-score",
                "content": "------------------ Easy C++ Solution ---------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n       vector<long> score(edges.size());\\n        for (int i = 0; i < edges.size(); ++i) score[edges[i]] += i;\\n        return max_element(begin(score), end(score)) - begin(score);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n       vector<long> score(edges.size());\\n        for (int i = 0; i < edges.size(); ++i) score[edges[i]] += i;\\n        return max_element(begin(score), end(score)) - begin(score);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418712,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer,Long>h=new HashMap<>();\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(h.containsKey(edges[i])==false)h.put(edges[i],(long)i);\\n            else h.put(edges[i],h.get(edges[i])+(long)i);\\n        }\\n        long max=Long.MIN_VALUE;\\n        System.out.println(h);\\n        for(Map.Entry<Integer,Long>e:h.entrySet())\\n            max=(long)Math.max(max,e.getValue());\\n\\n        List<Integer>l=new ArrayList<>();\\n        for(Map.Entry<Integer,Long>e:h.entrySet())\\n        {\\n            if(e.getValue()==max)l.add(e.getKey());\\n        }\\n        Collections.sort(l);\\n        return l.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer,Long>h=new HashMap<>();\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(h.containsKey(edges[i])==false)h.put(edges[i],(long)i);\\n            else h.put(edges[i],h.get(edges[i])+(long)i);\\n        }\\n        long max=Long.MIN_VALUE;\\n        System.out.println(h);\\n        for(Map.Entry<Integer,Long>e:h.entrySet())\\n            max=(long)Math.max(max,e.getValue());\\n\\n        List<Integer>l=new ArrayList<>();\\n        for(Map.Entry<Integer,Long>e:h.entrySet())\\n        {\\n            if(e.getValue()==max)l.add(e.getKey());\\n        }\\n        Collections.sort(l);\\n        return l.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400302,
                "title": "simple-c-counting-score-of-every-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe intuition is very simple just if somehow we can count the score(as we count the in degree by just instead of +1 + i) of evry node and store it in a list ,thn all we have to do is to get the maximum out of those scores.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n**UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<long long> score(n,0);\\n        int ans=-1;\\n        long long maxi=-1;\\n        for(int i=0;i<n;i++){\\n            score[edges[i]]+=i;\\n            if(maxi<score[edges[i]]){\\n                maxi=score[edges[i]];\\n                ans=edges[i];\\n            }\\n            else if(maxi==score[edges[i]]){\\n                ans=min(ans,edges[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<long long> score(n,0);\\n        int ans=-1;\\n        long long maxi=-1;\\n        for(int i=0;i<n;i++){\\n            score[edges[i]]+=i;\\n            if(maxi<score[edges[i]]){\\n                maxi=score[edges[i]];\\n                ans=edges[i];\\n            }\\n            else if(maxi==score[edges[i]]){\\n                ans=min(ans,edges[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394699,
                "title": "simplest-and-easiest-solution-beginners-friendly",
                "content": "```\\n    int edgeScore(vector<int>& edges) {\\n        map<int,long>meraMap;\\n        for(int i=0;i<edges.size();i++){\\n            if(meraMap.find(edges[i])==meraMap.end()){\\n                meraMap[edges[i]]=0;\\n                meraMap[edges[i]]=meraMap[edges[i]]+long(i);\\n            }else{\\n                meraMap[edges[i]]=meraMap[edges[i]]+long(i);\\n            }\\n        }\\n        int hold=0;\\n        long mfrq=-1;\\n        for(auto i:meraMap){\\n            if(i.second>mfrq){\\n                mfrq=i.second;\\n                hold=i.first;\\n            }\\n        }\\n        return hold;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n    int edgeScore(vector<int>& edges) {\\n        map<int,long>meraMap;\\n        for(int i=0;i<edges.size();i++){\\n            if(meraMap.find(edges[i])==meraMap.end()){\\n                meraMap[edges[i]]=0;\\n                meraMap[edges[i]]=meraMap[edges[i]]+long(i);\\n            }else{\\n                meraMap[edges[i]]=meraMap[edges[i]]+long(i);\\n            }\\n        }\\n        int hold=0;\\n        long mfrq=-1;\\n        for(auto i:meraMap){\\n            if(i.second>mfrq){\\n                mfrq=i.second;\\n                hold=i.first;\\n            }\\n        }\\n        return hold;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3360080,
                "title": "node-with-highest-score-java-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n\\n        long []ans=new long[n];\\n\\n        for(int i=0;i<edges.length;i++){\\n            ans[edges[i]]+=i;\\n        }\\n\\n        int max=0;\\n        for(int j=0;j<n;j++){\\n            if(ans[j]>ans[max]){\\n                max=j;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n\\n        long []ans=new long[n];\\n\\n        for(int i=0;i<edges.length;i++){\\n            ans[edges[i]]+=i;\\n        }\\n\\n        int max=0;\\n        for(int j=0;j<n;j++){\\n            if(ans[j]>ans[max]){\\n                max=j;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344881,
                "title": "simple-c-solution-user-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the sum of labels of a node and find out the maximum one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array to store the sum of lables for each node and then by finding the first index of the maximum element, We can give the required answer.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int ans,n = edges.size();\\n\\n       \\n        vector<long long> sum(n,0);\\n\\n\\n        for(int i = 0;i < n;i++){\\n\\n            sum[edges[i]] += i;\\n        }\\n\\n        \\n        long long maxi = *max_element(sum.begin(),sum.end());\\n        ans = -1;\\n        for(int i = 0;i < sum.size();i++){\\n\\n            if(sum[i] == maxi){\\n\\n                ans = i;\\n                break;\\n            }\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        int ans,n = edges.size();\\n\\n       \\n        vector<long long> sum(n,0);\\n\\n\\n        for(int i = 0;i < n;i++){\\n\\n            sum[edges[i]] += i;\\n        }\\n\\n        \\n        long long maxi = *max_element(sum.begin(),sum.end());\\n        ans = -1;\\n        for(int i = 0;i < sum.size();i++){\\n\\n            if(sum[i] == maxi){\\n\\n                ans = i;\\n                break;\\n            }\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336213,
                "title": "intuitive-typescript-solution-using-a-map",
                "content": "# Intuition\\nI can\\'t think of how to do this without finding the edge score of every node, then finding the max of that result.\\n\\n# Approach\\nCount up the edge score of every node using a Map, then find node with the max edge score in that Map.\\n\\n# Complexity\\n- Time complexity:\\nO(N) because we visit every edge once and then visit every node with an edge score > 0. This can\\'t be more than N, so worst case we have O(N+N) which is O(N).\\n\\n- Space complexity:\\nWorst case, every node has an edge, so our Map will be of size n, meaning \\nO(N) is the worst cases space complexity.\\n\\n# Code\\n```\\nfunction edgeScore(edges: number[]): number {\\n    const nodeIdxToEdgeScore = new Map<number, number>();\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const currentEdgeScore = nodeIdxToEdgeScore.get(edges[i]) || 0;\\n        nodeIdxToEdgeScore.set(edges[i], currentEdgeScore + i);\\n    }\\n\\n    let highestEdgeScore = -Infinity;\\n    let highestEdgeScoreNode = Infinity;\\n    for (let [node, edgeScore] of nodeIdxToEdgeScore) {\\n        if (edgeScore > highestEdgeScore) {\\n            highestEdgeScoreNode = node;\\n            highestEdgeScore = edgeScore;\\n        } else if (edgeScore === highestEdgeScore && node < highestEdgeScoreNode) {\\n            highestEdgeScoreNode = node;\\n        }\\n    }\\n\\n    return highestEdgeScoreNode;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction edgeScore(edges: number[]): number {\\n    const nodeIdxToEdgeScore = new Map<number, number>();\\n\\n    for (let i = 0; i < edges.length; ++i) {\\n        const currentEdgeScore = nodeIdxToEdgeScore.get(edges[i]) || 0;\\n        nodeIdxToEdgeScore.set(edges[i], currentEdgeScore + i);\\n    }\\n\\n    let highestEdgeScore = -Infinity;\\n    let highestEdgeScoreNode = Infinity;\\n    for (let [node, edgeScore] of nodeIdxToEdgeScore) {\\n        if (edgeScore > highestEdgeScore) {\\n            highestEdgeScoreNode = node;\\n            highestEdgeScore = edgeScore;\\n        } else if (edgeScore === highestEdgeScore && node < highestEdgeScoreNode) {\\n            highestEdgeScoreNode = node;\\n        }\\n    }\\n\\n    return highestEdgeScoreNode;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3308758,
                "title": "c-golang-map",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        int maxScore = INT_MIN, ans = INT_MAX;\\n        vector<long> score(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            score[edges[i]] += i;\\n            if(score[edges[i]] > maxScore) {\\n                ans = edges[i];\\n                maxScore = score[edges[i]];\\n            }\\n            else if(score[edges[i]] == maxScore) {\\n                ans = min(ans, edges[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc edgeScore(edges []int) int {\\n    var maxScore int64 = math.MinInt64\\n    var ans int = math.MaxInt\\n    score := make([]int64, len(edges))\\n    for i := 0; i < len(edges); i++ {\\n        score[edges[i]] += int64(i)\\n        if score[edges[i]] > maxScore {\\n            ans = edges[i]\\n            maxScore = score[edges[i]]\\n        } else if score[edges[i]] == maxScore {\\n            if edges[i] < ans {ans = edges[i]}\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        int maxScore = INT_MIN, ans = INT_MAX;\\n        vector<long> score(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            score[edges[i]] += i;\\n            if(score[edges[i]] > maxScore) {\\n                ans = edges[i];\\n                maxScore = score[edges[i]];\\n            }\\n            else if(score[edges[i]] == maxScore) {\\n                ans = min(ans, edges[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc edgeScore(edges []int) int {\\n    var maxScore int64 = math.MinInt64\\n    var ans int = math.MaxInt\\n    score := make([]int64, len(edges))\\n    for i := 0; i < len(edges); i++ {\\n        score[edges[i]] += int64(i)\\n        if score[edges[i]] > maxScore {\\n            ans = edges[i]\\n            maxScore = score[edges[i]]\\n        } else if score[edges[i]] == maxScore {\\n            if edges[i] < ans {ans = edges[i]}\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302152,
                "title": "one-pass-intutive-solution-beginner-friendly-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<long long> ans(n+1,0);\\n        long long maxi=0;\\n        long long node=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            ans[edges[i]]+=i;\\n            if(ans[edges[i]]>maxi)\\n            {\\n                maxi=ans[edges[i]];\\n                \\n                node=edges[i];\\n            }\\n            if(ans[edges[i]]==maxi && node>edges[i])\\n            {\\n                node=edges[i];\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Graph",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<long long> ans(n+1,0);\\n        long long maxi=0;\\n        long long node=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            ans[edges[i]]+=i;\\n            if(ans[edges[i]]>maxi)\\n            {\\n                maxi=ans[edges[i]];\\n                \\n                node=edges[i];\\n            }\\n            if(ans[edges[i]]==maxi && node>edges[i])\\n            {\\n                node=edges[i];\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283029,
                "title": "counting-the-adjacent-label-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector < long long > val(n,0);\\n\\n        for(int i = 0; i < n; i++){\\n            val[edges[i]] += i;\\n        }\\n        long long res = INT_MIN;\\n        \\n        int node = 0;\\n        for(int i = 0; i < n; i++){\\n            if(val[i] > res){\\n                res = val[i];\\n                node = i;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector < long long > val(n,0);\\n\\n        for(int i = 0; i < n; i++){\\n            val[edges[i]] += i;\\n        }\\n        long long res = INT_MIN;\\n        \\n        int node = 0;\\n        for(int i = 0; i < n; i++){\\n            if(val[i] > res){\\n                res = val[i];\\n                node = i;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282055,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<int, long long> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i]] += i;\\n        }\\n        int a = 0;\\n        int b = 0;\\n        for(auto it = mp.begin(); it != mp.end(); ++it)\\n            if(it->second > a){\\n                a = it->second;\\n                b = it->first;\\n            }\\n            return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<int, long long> mp;\\n        for(int i = 0; i < edges.size(); i++){\\n            mp[edges[i]] += i;\\n        }\\n        int a = 0;\\n        int b = 0;\\n        for(auto it = mp.begin(); it != mp.end(); ++it)\\n            if(it->second > a){\\n                a = it->second;\\n                b = it->first;\\n            }\\n            return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277022,
                "title": "one-pass-simple-brute-force-100-faster",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int V = edges.length;\\n        long[] temp = new long[V];\\n        for(int i = 0 ; i < V ; i++){\\n            int ele = edges[i];\\n            temp[ele] += i;\\n        }\\n        long max = -1;\\n        int node = -1;\\n        for(int i = 0 ; i < V ; i++){\\n            if(temp[i] > max){\\n                max = temp[i];\\n                node = i;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int V = edges.length;\\n        long[] temp = new long[V];\\n        for(int i = 0 ; i < V ; i++){\\n            int ele = edges[i];\\n            temp[ele] += i;\\n        }\\n        long max = -1;\\n        int node = -1;\\n        for(int i = 0 ; i < V ; i++){\\n            if(temp[i] > max){\\n                max = temp[i];\\n                node = i;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275446,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        scores = {}\\n        graph = defaultdict()\\n\\n        for i in range(len(edges)):\\n            graph[i] = edges[i]\\n        \\n        for node, nei in graph.items():\\n            if nei not in scores:\\n                scores[nei] = node\\n            else:\\n                scores[nei] += node\\n\\n        max_edge_score = 0\\n        ans = 0\\n\\n        for node, score in scores.items():\\n            if score > max_edge_score:\\n                max_edge_score = score\\n                ans = node\\n            if score == max_edge_score:\\n                if ans > node:\\n                    ans = node\\n\\n        return ans \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        scores = {}\\n        graph = defaultdict()\\n\\n        for i in range(len(edges)):\\n            graph[i] = edges[i]\\n        \\n        for node, nei in graph.items():\\n            if nei not in scores:\\n                scores[nei] = node\\n            else:\\n                scores[nei] += node\\n\\n        max_edge_score = 0\\n        ans = 0\\n\\n        for node, score in scores.items():\\n            if score > max_edge_score:\\n                max_edge_score = score\\n                ans = node\\n            if score == max_edge_score:\\n                if ans > node:\\n                    ans = node\\n\\n        return ans \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244375,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++) {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0;i<edges.length;i++) {\\n            adj.get(i).add(edges[i]);\\n        }\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<adj.size();i++) {\\n            for(Integer it : adj.get(i)) {\\n                if(map.containsKey(it)) {\\n                    map.put(it,map.get(it)+i);\\n                }\\n                else {\\n                    map.put(it,i);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        int max = 0;\\n        for(Map.Entry<Integer,Integer> mapEl : map.entrySet()) {\\n            if(Math.abs(mapEl.getValue()) > max) {\\n                max = Math.abs(mapEl.getValue());\\n                ans = mapEl.getKey();\\n            }\\n            else if(Math.abs(mapEl.getValue()) == max) {\\n                if(mapEl.getKey()<ans) {\\n                    ans = mapEl.getKey();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++) {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i=0;i<edges.length;i++) {\\n            adj.get(i).add(edges[i]);\\n        }\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<adj.size();i++) {\\n            for(Integer it : adj.get(i)) {\\n                if(map.containsKey(it)) {\\n                    map.put(it,map.get(it)+i);\\n                }\\n                else {\\n                    map.put(it,i);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        int max = 0;\\n        for(Map.Entry<Integer,Integer> mapEl : map.entrySet()) {\\n            if(Math.abs(mapEl.getValue()) > max) {\\n                max = Math.abs(mapEl.getValue());\\n                ans = mapEl.getKey();\\n            }\\n            else if(Math.abs(mapEl.getValue()) == max) {\\n                if(mapEl.getKey()<ans) {\\n                    ans = mapEl.getKey();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215993,
                "title": "easy-hashmap-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int,long> scores;\\n        for(int i = 0; i < edges.size(); i++){\\n            scores[edges[i]] += i;\\n        }\\n        long maxScore = 0, idx = 0;\\n        for(auto& [key,val]: scores){\\n            if(val > maxScore){\\n                idx = key;\\n                maxScore = val;\\n            }\\n            else if(val == maxScore){\\n                if(idx > key){\\n                    idx = key;\\n                }\\n            }\\n        }\\n        return idx;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        unordered_map<int,long> scores;\\n        for(int i = 0; i < edges.size(); i++){\\n            scores[edges[i]] += i;\\n        }\\n        long maxScore = 0, idx = 0;\\n        for(auto& [key,val]: scores){\\n            if(val > maxScore){\\n                idx = key;\\n                maxScore = val;\\n            }\\n            else if(val == maxScore){\\n                if(idx > key){\\n                    idx = key;\\n                }\\n            }\\n        }\\n        return idx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211492,
                "title": "easiest-c-solution-10-lines-of-code-beginner-friendly",
                "content": "# Intuition\\nAll about indexing and weights.\\n# Approach\\nNeed of a distance array and we just need to increment the values of nodes which have mulitple nodes connected to them.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int max=*max_element(edges.begin(),edges.end());\\n        vector<long> e_score(max+1,0);\\n        for(int i=0;i<edges.size();i++)\\n            e_score[edges[i]]+=i;\\n        auto it=max_element(e_score.begin(),e_score.end());\\n        return it-e_score.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int max=*max_element(edges.begin(),edges.end());\\n        vector<long> e_score(max+1,0);\\n        for(int i=0;i<edges.size();i++)\\n            e_score[edges[i]]+=i;\\n        auto it=max_element(e_score.begin(),e_score.end());\\n        return it-e_score.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205282,
                "title": "beats-92-two-approaches-o-n-2-and-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Method 1:Some what slow----> Time=O(n*(max_indeg))\\n    // int edgeScore(vector<int>& edges) \\n    // {\\n    //     int n = edges.size();\\n    //     vector<int>arr[n];\\n    //     for(int i = 0; i<edges.size(); i++)\\n    //         arr[edges[i]].push_back(i);\\n        \\n    //     int ans = -1;\\n    //     long long maxi = INT_MIN;\\n    //     for(int i = 0; i<n; i++)\\n    //     {\\n    //         long long temp = 0;\\n    //         for(auto e: arr[i])\\n    //         {\\n    //             temp+= e;\\n    //         }\\n    //         if(temp>maxi)\\n    //         {\\n    //             maxi = temp;\\n    //             ans = i;\\n    //         }\\n    //     }\\n    //     return ans;\\n    // }\\n    // METHOD 2://Time ->O(n)\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();\\n        vector<long long>arr(n, 0);\\n        for(int i = 0; i<edges.size(); i++)\\n            arr[edges[i]]+=i;\\n        \\n        int ans = -1;\\n        long long maxi = INT_MIN;\\n        for(int i = 0; i<n; i++)\\n        {\\n            long long temp = arr[i];\\n            if(temp>maxi)\\n            {\\n                maxi = temp;\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Method 1:Some what slow----> Time=O(n*(max_indeg))\\n    // int edgeScore(vector<int>& edges) \\n    // {\\n    //     int n = edges.size();\\n    //     vector<int>arr[n];\\n    //     for(int i = 0; i<edges.size(); i++)\\n    //         arr[edges[i]].push_back(i);\\n        \\n    //     int ans = -1;\\n    //     long long maxi = INT_MIN;\\n    //     for(int i = 0; i<n; i++)\\n    //     {\\n    //         long long temp = 0;\\n    //         for(auto e: arr[i])\\n    //         {\\n    //             temp+= e;\\n    //         }\\n    //         if(temp>maxi)\\n    //         {\\n    //             maxi = temp;\\n    //             ans = i;\\n    //         }\\n    //     }\\n    //     return ans;\\n    // }\\n    // METHOD 2://Time ->O(n)\\n    int edgeScore(vector<int>& edges) \\n    {\\n        int n = edges.size();\\n        vector<long long>arr(n, 0);\\n        for(int i = 0; i<edges.size(); i++)\\n            arr[edges[i]]+=i;\\n        \\n        int ans = -1;\\n        long long maxi = INT_MIN;\\n        for(int i = 0; i<n; i++)\\n        {\\n            long long temp = arr[i];\\n            if(temp>maxi)\\n            {\\n                maxi = temp;\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169734,
                "title": "easy-c-minimal-soln-iterative-approach-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou just need to count the incoming value to the particular edge.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long>vis(n,0);\\n        for(int i =0;i<n;i++){\\n            vis[edges[i]] += i;\\n        }\\n        long long ans=0,tmp=INT_MIN,i=0;\\n\\n        for(auto it:vis){\\n            if(it>tmp){\\n                ans =i;\\n                tmp =it;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long>vis(n,0);\\n        for(int i =0;i<n;i++){\\n            vis[edges[i]] += i;\\n        }\\n        long long ans=0,tmp=INT_MIN,i=0;\\n\\n        for(auto it:vis){\\n            if(it>tmp){\\n                ans =i;\\n                tmp =it;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168372,
                "title": "using-unordered-map-for-calculating-score-for-each-node",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        using ll=long long;\\n        unordered_map<ll,ll>m;\\n        ll maxi=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            m[edges[i]]+=i;\\n            maxi=max(m[edges[i]],maxi);\\n        }\\n        unordered_set<int>s;\\n        for(auto x:m)\\n        if(x.second==maxi)\\n        s.insert(x.first);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(i)!=s.end())\\n            return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n=edges.size();\\n        using ll=long long;\\n        unordered_map<ll,ll>m;\\n        ll maxi=0;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            m[edges[i]]+=i;\\n            maxi=max(m[edges[i]],maxi);\\n        }\\n        unordered_set<int>s;\\n        for(auto x:m)\\n        if(x.second==maxi)\\n        s.insert(x.first);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(i)!=s.end())\\n            return i;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137637,
                "title": "java-easyunderstanding-o-n",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        \\n        long[] nodeValues = new long[edges.length];\\n       //first get the all the outdegrees\\n        for(int i = 0 ;i < edges.length ; i++){\\n            nodeValues[edges[i]]+=i;\\n        }\\n        //check proccess\\n        int nodeNum = 0;\\n        long num = nodeValues[0];\\n        for(int node = 1 ; node < nodeValues.length ; node++ ){\\n            if(nodeValues[node] > num ){\\n                num = nodeValues[node];\\n                nodeNum = node;\\n            }else if(nodeValues[node] == num){\\n                nodeNum = Math.min(node,nodeNum);\\n            }\\n        }\\n        \\n        return nodeNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        \\n        long[] nodeValues = new long[edges.length];\\n       //first get the all the outdegrees\\n        for(int i = 0 ;i < edges.length ; i++){\\n            nodeValues[edges[i]]+=i;\\n        }\\n        //check proccess\\n        int nodeNum = 0;\\n        long num = nodeValues[0];\\n        for(int node = 1 ; node < nodeValues.length ; node++ ){\\n            if(nodeValues[node] > num ){\\n                num = nodeValues[node];\\n                nodeNum = node;\\n            }else if(nodeValues[node] == num){\\n                nodeNum = Math.min(node,nodeNum);\\n            }\\n        }\\n        \\n        return nodeNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119452,
                "title": "java-solution-using-hashmap-easy-to-understand",
                "content": "![upvote.jpeg](https://assets.leetcode.com/users/images/37d6a776-396d-4548-91ae-1e8087389ee8_1675098700.3618577.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        HashMap<Integer,List<Integer>>hm=new HashMap<>();\\n       \\n        for(int i=0;i<edges.length;i++){\\n            if(!hm.containsKey(edges[i])){\\n                List<Integer>list=new ArrayList<>();\\n                list.add(i);\\n                hm.put(edges[i],list);\\n            }\\n            else{\\n                 List<Integer>list=hm.get(edges[i]);\\n                list.add(i);\\n            }\\n        }\\n        long max=Integer.MIN_VALUE;\\n        int node=-1;\\n        for(int key:hm.keySet()){\\n            List<Integer>list=hm.get(key);\\n            long sum=cal(list);\\n            if(sum>max){\\n                max=sum;\\n                node=key;\\n            }\\n            else if(sum==max){\\n                node=Math.min(node,key);\\n            }\\n        }\\n        return node;\\n        \\n    }\\n    public long cal(List<Integer>list){\\n        long sum=0;\\n        for(int i=0;i<list.size();i++){\\n            sum+=list.get(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        HashMap<Integer,List<Integer>>hm=new HashMap<>();\\n       \\n        for(int i=0;i<edges.length;i++){\\n            if(!hm.containsKey(edges[i])){\\n                List<Integer>list=new ArrayList<>();\\n                list.add(i);\\n                hm.put(edges[i],list);\\n            }\\n            else{\\n                 List<Integer>list=hm.get(edges[i]);\\n                list.add(i);\\n            }\\n        }\\n        long max=Integer.MIN_VALUE;\\n        int node=-1;\\n        for(int key:hm.keySet()){\\n            List<Integer>list=hm.get(key);\\n            long sum=cal(list);\\n            if(sum>max){\\n                max=sum;\\n                node=key;\\n            }\\n            else if(sum==max){\\n                node=Math.min(node,key);\\n            }\\n        }\\n        return node;\\n        \\n    }\\n    public long cal(List<Integer>list){\\n        long sum=0;\\n        for(int i=0;i<list.size();i++){\\n            sum+=list.get(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107760,
                "title": "simple-java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long[] score;\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        score = new long[n];\\n        for(int i = 0; i < edges.length; i++) {\\n            score[edges[i]] += i;\\n        }\\n        int index = 0;\\n        long max = -1;\\n        for(int i = 0; i < n; i++)\\n            if(score[i] > max) {\\n                max = score[i];\\n                index = i;\\n            }\\n        return index;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long[] score;\\n    public int edgeScore(int[] edges) {\\n        int n = edges.length;\\n        score = new long[n];\\n        for(int i = 0; i < edges.length; i++) {\\n            score[edges[i]] += i;\\n        }\\n        int index = 0;\\n        long max = -1;\\n        for(int i = 0; i < n; i++)\\n            if(score[i] > max) {\\n                max = score[i];\\n                index = i;\\n            }\\n        return index;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092858,
                "title": "c-solution-with-hash-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\npublic:\\n\\tint edgeScore(vector<int>& edges) {\\n\\t\\tmap<int,long long> mp;\\n\\t\\tint max_score = 0, res = 0;\\n   \\t\\tconst int N = edges.size();\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (int src = 0; src < N; src++){\\n\\t\\t\\tint dest = edges[src];\\n\\t\\t\\tmp[dest] += (double)src;\\n\\t\\t}\\n\\n\\t\\tvector<int> most;\\n\\t\\tfor (map<int,long long>::iterator itr = mp.begin(); itr != mp.end(); itr++){\\n\\t\\t\\tint node = itr->first;\\n\\t\\t\\tlong long score = itr->second;\\n\\t\\t\\tif (score > max_score){\\n\\t\\t\\t\\tmax_score = score;\\n\\t\\t\\t\\tmost.clear();\\n\\t\\t\\t\\tmost.push_back(node);\\n\\t\\t\\t} else if (score == max_score){\\n\\t\\t\\t\\tmost.push_back(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn most[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\npublic:\\n\\tint edgeScore(vector<int>& edges) {\\n\\t\\tmap<int,long long> mp;\\n\\t\\tint max_score = 0, res = 0;\\n   \\t\\tconst int N = edges.size();\\n\\t\\tint count = 0;\\n\\n\\t\\tfor (int src = 0; src < N; src++){\\n\\t\\t\\tint dest = edges[src];\\n\\t\\t\\tmp[dest] += (double)src;\\n\\t\\t}\\n\\n\\t\\tvector<int> most;\\n\\t\\tfor (map<int,long long>::iterator itr = mp.begin(); itr != mp.end(); itr++){\\n\\t\\t\\tint node = itr->first;\\n\\t\\t\\tlong long score = itr->second;\\n\\t\\t\\tif (score > max_score){\\n\\t\\t\\t\\tmax_score = score;\\n\\t\\t\\t\\tmost.clear();\\n\\t\\t\\t\\tmost.push_back(node);\\n\\t\\t\\t} else if (score == max_score){\\n\\t\\t\\t\\tmost.push_back(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn most[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043157,
                "title": "java-time-o-n-space-o-n",
                "content": "# Intuition\\nI am surprised this is not an easy problem.\\n\\n# Approach\\nObvious one pass loop.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] SCORE;\\n\\n    public int edgeScore(int[] edges) {\\n        this.SCORE = new long[edges.length];    \\n\\n        //[1,0,0,0,0,7,7,5]\\n        for(int i = 0; i < edges.length; i++) {\\n            this.SCORE[edges[i]] += i;\\n        }\\n\\n        int maxNode = -1;\\n        long maxScore = Integer.MIN_VALUE;\\n        for(int i = 0; i < this.SCORE.length; i++) {\\n            if(maxScore < this.SCORE[i]) {\\n                maxNode = i;\\n                maxScore = this.SCORE[i];\\n            }\\n        }\\n\\n        return maxNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private long[] SCORE;\\n\\n    public int edgeScore(int[] edges) {\\n        this.SCORE = new long[edges.length];    \\n\\n        //[1,0,0,0,0,7,7,5]\\n        for(int i = 0; i < edges.length; i++) {\\n            this.SCORE[edges[i]] += i;\\n        }\\n\\n        int maxNode = -1;\\n        long maxScore = Integer.MIN_VALUE;\\n        for(int i = 0; i < this.SCORE.length; i++) {\\n            if(maxScore < this.SCORE[i]) {\\n                maxNode = i;\\n                maxScore = this.SCORE[i];\\n            }\\n        }\\n\\n        return maxNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996332,
                "title": "c-hashmap-short-and-simple",
                "content": "The language of the question is quite clear. Find the **smallest** node with the **maximum** label sum with the label sum having **higher** priority.\\n\\nPlease upvote if you find the solution clean and concise.\\n***Thank You!!***\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<ll> hash(n);\\n        ll maxval = 0; int res = n;\\n        for(int i=0;i<n;i++) {\\n            hash[edges[i]] += i;\\n            if(hash[edges[i]] > maxval) {\\n                maxval = hash[edges[i]], res = edges[i];\\n            }\\n            else if(hash[edges[i]] == maxval) res = min(res, edges[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<ll> hash(n);\\n        ll maxval = 0; int res = n;\\n        for(int i=0;i<n;i++) {\\n            hash[edges[i]] += i;\\n            if(hash[edges[i]] > maxval) {\\n                maxval = hash[edges[i]], res = edges[i];\\n            }\\n            else if(hash[edges[i]] == maxval) res = min(res, edges[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976831,
                "title": "node-with-highest-edge-score-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n interface ObjectNode {\\n       key:string;\\n       sum: number;\\n }\\n\\n\\nfunction edgeScore(edges: number[]): number {\\n      let results:Record<string,number[]>={};\\n      function calculate(index:number,value:number):void{\\n             if(results[String(index)]===null||results[String(index)]===undefined){\\n                   results[String(index)]=[];\\n             }\\n             results[index].push(value);\\n      }\\n      for(let i=0;i<edges.length;i++){\\n           calculate(edges[i], i);\\n      }\\n      let obj:ObjectNode={\\n          key: \"\",\\n          sum: Number.MIN_SAFE_INTEGER\\n      }\\n      let currentSum=0;\\n      for(let key in results){\\n           results[key].forEach(value=>{\\n                currentSum+=value;\\n           })\\n           if(currentSum>obj.sum){\\n                 obj.key=key,\\n                 obj.sum=currentSum\\n           }\\n           currentSum=0;\\n      }\\n      return Number(obj.key);\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n interface ObjectNode {\\n       key:string;\\n       sum: number;\\n }\\n\\n\\nfunction edgeScore(edges: number[]): number {\\n      let results:Record<string,number[]>={};\\n      function calculate(index:number,value:number):void{\\n             if(results[String(index)]===null||results[String(index)]===undefined){\\n                   results[String(index)]=[];\\n             }\\n             results[index].push(value);\\n      }\\n      for(let i=0;i<edges.length;i++){\\n           calculate(edges[i], i);\\n      }\\n      let obj:ObjectNode={\\n          key: \"\",\\n          sum: Number.MIN_SAFE_INTEGER\\n      }\\n      let currentSum=0;\\n      for(let key in results){\\n           results[key].forEach(value=>{\\n                currentSum+=value;\\n           })\\n           if(currentSum>obj.sum){\\n                 obj.key=key,\\n                 obj.sum=currentSum\\n           }\\n           currentSum=0;\\n      }\\n      return Number(obj.key);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976547,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer,Long> m=new HashMap<>();\\n        long[] edge = Arrays.stream(edges).mapToLong(i -> i).toArray();\\n        int n=edges.length;\\n        for(int i=0;i<n;i++)\\n        {\\n                m.put(i,edge[i]);\\n        }\\n        long []ans=new long[n];\\n        for (Map.Entry<Integer, Long> pair : m.entrySet()) {\\n            long x=pair.getValue();\\n            int y=pair.getKey();\\n            ans[(int)x]+=(long)(y);\\n        }\\n        long max=0;\\n      \\n        for(int i=0;i<ans.length;i++)\\n        {\\n            if(max<ans[i])\\n            {\\n                max=ans[i];\\n            }\\n        }\\n        int ss=0;\\n        for(int i=0;i<ans.length;i++)\\n        {\\n            if(max==ans[i])\\n            {\\n                ss=i;\\n                break;\\n            }\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        HashMap<Integer,Long> m=new HashMap<>();\\n        long[] edge = Arrays.stream(edges).mapToLong(i -> i).toArray();\\n        int n=edges.length;\\n        for(int i=0;i<n;i++)\\n        {\\n                m.put(i,edge[i]);\\n        }\\n        long []ans=new long[n];\\n        for (Map.Entry<Integer, Long> pair : m.entrySet()) {\\n            long x=pair.getValue();\\n            int y=pair.getKey();\\n            ans[(int)x]+=(long)(y);\\n        }\\n        long max=0;\\n      \\n        for(int i=0;i<ans.length;i++)\\n        {\\n            if(max<ans[i])\\n            {\\n                max=ans[i];\\n            }\\n        }\\n        int ss=0;\\n        for(int i=0;i<ans.length;i++)\\n        {\\n            if(max==ans[i])\\n            {\\n                ss=i;\\n                break;\\n            }\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958248,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n- Space complexity:\\nO(V)\\n# Code\\n```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<ArrayList<Integer>>();\\n\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            adj.get(edges[i]).add(i);\\n        }\\n        \\n        int smallestNode=n+1;\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=n-1;i>=0;i--){\\n             if(adj.get(i).size()==0){\\n                 continue;\\n             }\\n             long sum=0;\\n             for(int it:adj.get(i)){\\n               sum+=it;\\n             }\\n             if(sum>=max){\\n                 max=sum;\\n                 smallestNode=i;\\n             }\\n        }\\n\\n        return smallestNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int edgeScore(int[] edges) {\\n        int n=edges.length;\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<ArrayList<Integer>>();\\n\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            adj.get(edges[i]).add(i);\\n        }\\n        \\n        int smallestNode=n+1;\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=n-1;i>=0;i--){\\n             if(adj.get(i).size()==0){\\n                 continue;\\n             }\\n             long sum=0;\\n             for(int it:adj.get(i)){\\n               sum+=it;\\n             }\\n             if(sum>=max){\\n                 max=sum;\\n                 smallestNode=i;\\n             }\\n        }\\n\\n        return smallestNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937920,
                "title": "counting-labels-using-array-as-a-hashmap-c-easiest-way",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse hashmap for counting and adding the neighbours\\'s incoming edge towards the node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> indegree(n, 0);\\n        for(int i=0; i<n; i++) {\\n            indegree[edges[i]] += i;\\n        }\\n        long long maxScore = 0;\\n        int ans_node = 0;\\n        for(int i=0; i<n; i++) {\\n            if(maxScore < indegree[i]) {\\n                maxScore = indegree[i];\\n                ans_node = i;\\n            }\\n        }\\n        return ans_node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<long long> indegree(n, 0);\\n        for(int i=0; i<n; i++) {\\n            indegree[edges[i]] += i;\\n        }\\n        long long maxScore = 0;\\n        int ans_node = 0;\\n        for(int i=0; i<n; i++) {\\n            if(maxScore < indegree[i]) {\\n                maxScore = indegree[i];\\n                ans_node = i;\\n            }\\n        }\\n        return ans_node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926240,
                "title": "an-easy-and-efficient-approach-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas it is very intuitive to solve this question by using hash table .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> i have used hashmap to solve this questions. as i have stored all nodes directed to it in hashmap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(nlogn)\\n\\n- Space complexity:\\n# 1. <!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)**Bold**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n      map<int,long long> mp;\\n      long long maxi = 0,ans = 0;\\n      for(int i = 0;i< edges.size();i++){\\n        mp[edges[i]]+=i;\\n      }\\n\\n      for(auto it: mp){\\n         if(maxi < it.second){\\n             maxi = it.second;\\n             ans = it.first;\\n         }\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n      map<int,long long> mp;\\n      long long maxi = 0,ans = 0;\\n      for(int i = 0;i< edges.size();i++){\\n        mp[edges[i]]+=i;\\n      }\\n\\n      for(auto it: mp){\\n         if(maxi < it.second){\\n             maxi = it.second;\\n             ans = it.first;\\n         }\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919503,
                "title": "c-incoming-node-evaluation-o-linear-solution-explained-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse an Indegree Adjacency List\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrepare an Indegree based adjacenecy , and the evalute edgeScore for each node with indegree>0 , and return the maximum edgeScore. \\n# Complexity\\n- Time complexity   :  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  :   O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        //preparing the adjacency list based on the indegree\\n        unordered_map<int,list<int>> indegreeStore;\\n        for(int i=0; i<edges.size(); i++)   \\n            indegreeStore[edges[i]].push_back(i);\\n        \\n        //evalute the edge score for each node having incoming edges\\n        int maxNode ;\\n        double maxEdgeScore = 0;\\n        for(auto it:indegreeStore)      {\\n            int currNode = it.first;\\n            double currEdgeScore = 0;\\n            for(auto i:it.second)   {\\n                currEdgeScore += i;\\n            }\\n            //updating result node\\n            if(currEdgeScore>maxEdgeScore)  {   \\n                maxEdgeScore = currEdgeScore;\\n                maxNode = currNode;\\n            }\\n            else if(currEdgeScore==maxEdgeScore)  { \\n                maxNode = min(currNode,maxNode);\\n            }\\n        }\\n\\n        return maxNode;\\n    }\\n};\\n```\\n*********************************DON\\'T FORGET TO UPVOTE********************************",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        \\n        //preparing the adjacency list based on the indegree\\n        unordered_map<int,list<int>> indegreeStore;\\n        for(int i=0; i<edges.size(); i++)   \\n            indegreeStore[edges[i]].push_back(i);\\n        \\n        //evalute the edge score for each node having incoming edges\\n        int maxNode ;\\n        double maxEdgeScore = 0;\\n        for(auto it:indegreeStore)      {\\n            int currNode = it.first;\\n            double currEdgeScore = 0;\\n            for(auto i:it.second)   {\\n                currEdgeScore += i;\\n            }\\n            //updating result node\\n            if(currEdgeScore>maxEdgeScore)  {   \\n                maxEdgeScore = currEdgeScore;\\n                maxNode = currNode;\\n            }\\n            else if(currEdgeScore==maxEdgeScore)  { \\n                maxNode = min(currNode,maxNode);\\n            }\\n        }\\n\\n        return maxNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916466,
                "title": "c-o-n-time-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n    int n = edges.size();\\n    vector<long long int> score(n,0);\\n    for (int i = 0; i < n; ++i) {\\n        score[edges[i]]+=i;\\n    }\\n\\n    long long int max_score = -1;\\n    int min_index = n;\\n\\n    for (int i = 0; i < n; ++i) {\\n        if(score[i]>max_score){\\n            max_score = score[i];\\n            min_index = i;\\n        }\\n    }\\n\\n    return min_index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n    int n = edges.size();\\n    vector<long long int> score(n,0);\\n    for (int i = 0; i < n; ++i) {\\n        score[edges[i]]+=i;\\n    }\\n\\n    long long int max_score = -1;\\n    int min_index = n;\\n\\n    for (int i = 0; i < n; ++i) {\\n        if(score[i]>max_score){\\n            max_score = score[i];\\n            min_index = i;\\n        }\\n    }\\n\\n    return min_index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889718,
                "title": "cpp-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n\\t{\\n        // so in the edges vecotr<int> we have and edge \\n       //  edge from node i to node edges[i]\\n     \\n       //we will keep the index of the node and the sum of the labels pointing to it\\n       map<long long int,long long int>mp;\\n       \\n       for(int i=0;i<edges.size();i++)\\n       {\\n       \\t   //u -- >v\\n       \\t   int u = i;\\n       \\t   int v = edges[i];\\n       \\t   //u -- > v\\n       \\t   \\n       \\t   mp[v] = mp[v] + i;\\n\\t   }\\n\\t   \\n\\t   int ans = -1;\\n\\t   int val = INT_MIN;\\n\\t   \\n\\t   for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n\\t   {\\n\\t       if(it->second > val)\\n\\t       {\\n\\t       \\t   ans = it->first;\\n\\t       \\t   val = it->second;\\n\\t\\t   }\\n\\t   }\\n\\t   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) \\n\\t{\\n        // so in the edges vecotr<int> we have and edge \\n       //  edge from node i to node edges[i]\\n     \\n       //we will keep the index of the node and the sum of the labels pointing to it\\n       map<long long int,long long int>mp;\\n       \\n       for(int i=0;i<edges.size();i++)\\n       {\\n       \\t   //u -- >v\\n       \\t   int u = i;\\n       \\t   int v = edges[i];\\n       \\t   //u -- > v\\n       \\t   \\n       \\t   mp[v] = mp[v] + i;\\n\\t   }\\n\\t   \\n\\t   int ans = -1;\\n\\t   int val = INT_MIN;\\n\\t   \\n\\t   for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n\\t   {\\n\\t       if(it->second > val)\\n\\t       {\\n\\t       \\t   ans = it->first;\\n\\t       \\t   val = it->second;\\n\\t\\t   }\\n\\t   }\\n\\t   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887695,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<long,long>m;\\n        for(int i=0; i<edges.size();i++)\\n        {\\n            m[edges[i]] += i;\\n        }\\n\\n        long long maxe = -1, maxval = -1;\\n\\n        for(auto it = m.begin(); it!= m.end(); it++)\\n        {\\n            if(it->second > maxval)\\n            {\\n                maxe = it->first;\\n                maxval = it->second;\\n            }\\n        }\\n\\n        return maxe;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        map<long,long>m;\\n        for(int i=0; i<edges.size();i++)\\n        {\\n            m[edges[i]] += i;\\n        }\\n\\n        long long maxe = -1, maxval = -1;\\n\\n        for(auto it = m.begin(); it!= m.end(); it++)\\n        {\\n            if(it->second > maxval)\\n            {\\n                maxe = it->first;\\n                maxval = it->second;\\n            }\\n        }\\n\\n        return maxe;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887078,
                "title": "python-js-easy-logic-count-using-map-concise-codeplug",
                "content": "**Upvote if you like the solution :)**\\n# Intuition\\nCount the incoming/indegree node values and get the node with maximum total that has minimum value.\\n\\n# Approach\\nWe can use a simple map to track the counts.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```javascript []\\nvar edgeScore = function(edges) {\\n    const track = {};\\n    edges.forEach((j, i) => track[j] = j in track ? track[j] + i : i);\\n    let maxi = -Infinity;\\n    let res = null;\\n    Object.entries(track).forEach(([node, val]) => {\\n        if (val > maxi) {\\n            maxi = val;\\n            res = node;\\n        } else if (val === maxi) res = Math.min(res, node)\\n    });\\n    return res;\\n};\\n```\\n```python []\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        track = defaultdict(int)\\n        for i, j in enumerate(edges): track[j] += i\\n        res, maxi = None, -inf\\n        for node, val in track.items():\\n            if val > maxi: maxi, res = val, node\\n            elif val == maxi: res = min(res, node)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```javascript []\\nvar edgeScore = function(edges) {\\n    const track = {};\\n    edges.forEach((j, i) => track[j] = j in track ? track[j] + i : i);\\n    let maxi = -Infinity;\\n    let res = null;\\n    Object.entries(track).forEach(([node, val]) => {\\n        if (val > maxi) {\\n            maxi = val;\\n            res = node;\\n        } else if (val === maxi) res = Math.min(res, node)\\n    });\\n    return res;\\n};\\n```\n```python []\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        track = defaultdict(int)\\n        for i, j in enumerate(edges): track[j] += i\\n        res, maxi = None, -inf\\n        for node, val in track.items():\\n            if val > maxi: maxi, res = val, node\\n            elif val == maxi: res = min(res, node)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884849,
                "title": "c-simple-approach-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long long ans = INT_MIN;\\n        int ind = edges.size();\\n        map<long long,long long> mp;\\n        vector<int> adj[edges.size()+1];\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i]]+=i;\\n        }\\n        for(auto it:mp){\\n            if(ans<it.second){\\n                ans=it.second;\\n                ind=it.first;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int edgeScore(vector<int>& edges) {\\n        long long ans = INT_MIN;\\n        int ind = edges.size();\\n        map<long long,long long> mp;\\n        vector<int> adj[edges.size()+1];\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i]]+=i;\\n        }\\n        for(auto it:mp){\\n            if(ans<it.second){\\n                ans=it.second;\\n                ind=it.first;\\n            }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882960,
                "title": "python-caulculate-the-most-score-while-building-the-graph",
                "content": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        edge_scores = defaultdict(int)\\n        for source, destination in enumerate(edges):\\n            edge_scores[destination] += source\\n            \\n        best_edge_score_node = -1\\n        best_edge_score = -1\\n        for ith_node, _ in enumerate(edges):\\n            if edge_scores[ith_node] > best_edge_score:\\n                best_edge_score = edge_scores[ith_node]\\n                best_edge_score_node = ith_node\\n            \\n        return best_edge_score_node\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        edge_scores = defaultdict(int)\\n        for source, destination in enumerate(edges):\\n            edge_scores[destination] += source\\n            \\n        best_edge_score_node = -1\\n        best_edge_score = -1\\n        for ith_node, _ in enumerate(edges):\\n            if edge_scores[ith_node] > best_edge_score:\\n                best_edge_score = edge_scores[ith_node]\\n                best_edge_score_node = ith_node\\n            \\n        return best_edge_score_node\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1811365,
                "content": [
                    {
                        "username": "user2285TI",
                        "content": "Should be labelled \\'Easy\\' imo"
                    },
                    {
                        "username": "leetcancode",
                        "content": "- Use long to store sum\\n- Use TreeMap to store the sum (It ensures the indexes are sorted)"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Use long instead of int to store score..it kept giving wrong answer for last test case...other than that this was ezz;"
                    },
                    {
                        "username": "randomtaran",
                        "content": "why it\\'s a medium ques, it should be easy"
                    },
                    {
                        "username": "pjain043",
                        "content": "Why does the test case [3,3,3,0] gives 0 as output. Shouldn't it be 3 as it has the smaller index ??\n\nEdit : Understood that if few nodes have same max score, return the noe with lowest value"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am confused about the smallest index in this question"
                    },
                    {
                        "username": "TTDLC",
                        "content": "use map instead of unordered_map "
                    }
                ]
            },
            {
                "id": 2068560,
                "content": [
                    {
                        "username": "user2285TI",
                        "content": "Should be labelled \\'Easy\\' imo"
                    },
                    {
                        "username": "leetcancode",
                        "content": "- Use long to store sum\\n- Use TreeMap to store the sum (It ensures the indexes are sorted)"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Use long instead of int to store score..it kept giving wrong answer for last test case...other than that this was ezz;"
                    },
                    {
                        "username": "randomtaran",
                        "content": "why it\\'s a medium ques, it should be easy"
                    },
                    {
                        "username": "pjain043",
                        "content": "Why does the test case [3,3,3,0] gives 0 as output. Shouldn't it be 3 as it has the smaller index ??\n\nEdit : Understood that if few nodes have same max score, return the noe with lowest value"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am confused about the smallest index in this question"
                    },
                    {
                        "username": "TTDLC",
                        "content": "use map instead of unordered_map "
                    }
                ]
            },
            {
                "id": 2020785,
                "content": [
                    {
                        "username": "user2285TI",
                        "content": "Should be labelled \\'Easy\\' imo"
                    },
                    {
                        "username": "leetcancode",
                        "content": "- Use long to store sum\\n- Use TreeMap to store the sum (It ensures the indexes are sorted)"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Use long instead of int to store score..it kept giving wrong answer for last test case...other than that this was ezz;"
                    },
                    {
                        "username": "randomtaran",
                        "content": "why it\\'s a medium ques, it should be easy"
                    },
                    {
                        "username": "pjain043",
                        "content": "Why does the test case [3,3,3,0] gives 0 as output. Shouldn't it be 3 as it has the smaller index ??\n\nEdit : Understood that if few nodes have same max score, return the noe with lowest value"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am confused about the smallest index in this question"
                    },
                    {
                        "username": "TTDLC",
                        "content": "use map instead of unordered_map "
                    }
                ]
            },
            {
                "id": 1990896,
                "content": [
                    {
                        "username": "user2285TI",
                        "content": "Should be labelled \\'Easy\\' imo"
                    },
                    {
                        "username": "leetcancode",
                        "content": "- Use long to store sum\\n- Use TreeMap to store the sum (It ensures the indexes are sorted)"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Use long instead of int to store score..it kept giving wrong answer for last test case...other than that this was ezz;"
                    },
                    {
                        "username": "randomtaran",
                        "content": "why it\\'s a medium ques, it should be easy"
                    },
                    {
                        "username": "pjain043",
                        "content": "Why does the test case [3,3,3,0] gives 0 as output. Shouldn't it be 3 as it has the smaller index ??\n\nEdit : Understood that if few nodes have same max score, return the noe with lowest value"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am confused about the smallest index in this question"
                    },
                    {
                        "username": "TTDLC",
                        "content": "use map instead of unordered_map "
                    }
                ]
            },
            {
                "id": 1944844,
                "content": [
                    {
                        "username": "user2285TI",
                        "content": "Should be labelled \\'Easy\\' imo"
                    },
                    {
                        "username": "leetcancode",
                        "content": "- Use long to store sum\\n- Use TreeMap to store the sum (It ensures the indexes are sorted)"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Use long instead of int to store score..it kept giving wrong answer for last test case...other than that this was ezz;"
                    },
                    {
                        "username": "randomtaran",
                        "content": "why it\\'s a medium ques, it should be easy"
                    },
                    {
                        "username": "pjain043",
                        "content": "Why does the test case [3,3,3,0] gives 0 as output. Shouldn't it be 3 as it has the smaller index ??\n\nEdit : Understood that if few nodes have same max score, return the noe with lowest value"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am confused about the smallest index in this question"
                    },
                    {
                        "username": "TTDLC",
                        "content": "use map instead of unordered_map "
                    }
                ]
            },
            {
                "id": 1867279,
                "content": [
                    {
                        "username": "user2285TI",
                        "content": "Should be labelled \\'Easy\\' imo"
                    },
                    {
                        "username": "leetcancode",
                        "content": "- Use long to store sum\\n- Use TreeMap to store the sum (It ensures the indexes are sorted)"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Use long instead of int to store score..it kept giving wrong answer for last test case...other than that this was ezz;"
                    },
                    {
                        "username": "randomtaran",
                        "content": "why it\\'s a medium ques, it should be easy"
                    },
                    {
                        "username": "pjain043",
                        "content": "Why does the test case [3,3,3,0] gives 0 as output. Shouldn't it be 3 as it has the smaller index ??\n\nEdit : Understood that if few nodes have same max score, return the noe with lowest value"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "i am confused about the smallest index in this question"
                    },
                    {
                        "username": "TTDLC",
                        "content": "use map instead of unordered_map "
                    }
                ]
            }
        ]
    }
]