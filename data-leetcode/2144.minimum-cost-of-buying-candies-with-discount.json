[
    {
        "title": "Minimum Cost of Buying Candies With Discount",
        "question_content": "A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.\nThe customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.\n\n\tFor example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they&nbsp;can take the candy with cost 1 for free, but not the candy with cost 4.\n\nGiven a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.\n&nbsp;\nExample 1:\n\nInput: cost = [1,2,3]\nOutput: 5\nExplanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n\nExample 2:\n\nInput: cost = [6,5,7,9,2,2]\nOutput: 23\nExplanation: The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n\nExample 3:\n\nInput: cost = [5,5]\nOutput: 10\nExplanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10.\n\n&nbsp;\nConstraints:\n\n\t1 <= cost.length <= 100\n\t1 <= cost[i] <= 100",
        "solutions": [
            {
                "id": 1709892,
                "title": "java-c-python-easy-and-consice",
                "content": "# **Explanation**\\nFor the max value, we have to pay for it.\\nFor the second max value, we still have to pay for it.\\nFor the third max value, we can get it free one as bonus.\\nAnd continuely do this for the rest.\\n\\nThe the core of problem, is need to sort the input.\\nAll `A[i]` with `i % 3  == n % 3`, we can get it for free.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumCost(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i)\\n            if (i % 3 != n % 3)\\n                res += A[i];\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumCost(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < A.size(); ++i)\\n            if (i % 3 != n % 3)\\n                res += A[i];\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumCost(self, A):\\n        return sum(a for i,a in enumerate(sorted(A)) if (len(A) - i) % 3)\\n```\\n```\\n    def minimumCost(self, A):\\n        return sum(A) - sum(sorted(A)[-3::-3])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumCost(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i)\\n            if (i % 3 != n % 3)\\n                res += A[i];\\n        return res;\\n    }\\n```\n```cpp\\n    int minimumCost(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < A.size(); ++i)\\n            if (i % 3 != n % 3)\\n                res += A[i];\\n        return res;\\n    }\\n```\n```py\\n    def minimumCost(self, A):\\n        return sum(a for i,a in enumerate(sorted(A)) if (len(A) - i) % 3)\\n```\n```\\n    def minimumCost(self, A):\\n        return sum(A) - sum(sorted(A)[-3::-3])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710283,
                "title": "c-reverse-sort-skip-every-third-element",
                "content": "Logic: \\n1-Sort the cost in descending order.\\n2-Traverse the cost and skip every third element (as it is the free candy after every 2 candies bought)\\n\\n```\\nint minimumCost(vector<int>& c,int res=0) {\\n        sort(begin(c),end(c),greater<>());\\n        for(int i=0;i<size(c);i++) \\n\\t\\t\\tif((i+1)%3)res+=c[i];\\n        return res;\\n    }\\n```\\nPlease Upvote! if find helpful, suggestions are welcomed :)\\nFind me on https://coderkay.com",
                "solutionTags": [],
                "code": "```\\nint minimumCost(vector<int>& c,int res=0) {\\n        sort(begin(c),end(c),greater<>());\\n        for(int i=0;i<size(c);i++) \\n\\t\\t\\tif((i+1)%3)res+=c[i];\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711079,
                "title": "one-liner",
                "content": "Sort cost descending, and then sum, skipping every third cost.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    minimumCost = lambda self, cost: sum(c for i, c in enumerate(sorted(cost, reverse=True)) if i % 3 != 2)\\n```\\n\\n**C++**\\nSame logic in C++.\\n```cpp\\nint minimumCost(vector<int>& cost) {\\n    int res = 0;\\n    sort(rbegin(cost), rend(cost));\\n    for (int i = 0; i < cost.size(); ++i)\\n        res += i % 3 == 2 ? 0 : cost[i];\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    minimumCost = lambda self, cost: sum(c for i, c in enumerate(sorted(cost, reverse=True)) if i % 3 != 2)\\n```\n```cpp\\nint minimumCost(vector<int>& cost) {\\n    int res = 0;\\n    sort(rbegin(cost), rend(cost));\\n    for (int i = 0; i < cost.size(); ++i)\\n        res += i % 3 == 2 ? 0 : cost[i];\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709923,
                "title": "simple-and-sort-greedy-c",
                "content": "```\\nSort the cost in Decreasing order, and then skip the each third element- for than keep a count variable and when count reaches 2, do continiue and resent cnt variable\\n\\n``class Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(),greater());\\n        int ans=0;\\n        int cnt=0;\\n        for(int i=0;i<cost.size();i++)\\n        {\\n            if(cnt==2){\\n                cnt=0;\\n                continue;\\n            }\\n            ans+=cost[i];\\n            cnt++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nSort the cost in Decreasing order, and then skip the each third element- for than keep a count variable and when count reaches 2, do continiue and resent cnt variable\\n\\n``class Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(),greater());\\n        int ans=0;\\n        int cnt=0;\\n        for(int i=0;i<cost.size();i++)\\n        {\\n            if(cnt==2){\\n                cnt=0;\\n                continue;\\n            }\\n            ans+=cost[i];\\n            cnt++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710139,
                "title": "c-easy-solution-using-sorting-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Simply sort the array and iterate from last.\\n- Take the last 2 costs & skip the next one, because we\\u2019ll get free if it\\u2019s equal or less than the minimum one.\\n- Reduce the index by 3 to skip an element **`i = i-3`**\\n- If ***i*** became 1 or 0 then return ans else we need to add the first element of the array because we won\\u2019t get that free.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        int i = n-1, ans = 0;\\n        \\n        if(n <= 2){\\n            for(auto x: cost) \\n                ans += x;\\n            return ans;\\n        }\\n        \\n        sort(cost.begin(), cost.end());\\n        \\n        while(i>=1){\\n            ans += cost[i] + cost[i-1];\\n            if(i-1 == 0 || i-1 == 1) return ans;\\n            i = i-3;\\n        }\\n        ans += cost[0];\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        int i = n-1, ans = 0;\\n        \\n        if(n <= 2){\\n            for(auto x: cost) \\n                ans += x;\\n            return ans;\\n        }\\n        \\n        sort(cost.begin(), cost.end());\\n        \\n        while(i>=1){\\n            ans += cost[i] + cost[i-1];\\n            if(i-1 == 0 || i-1 == 1) return ans;\\n            i = i-3;\\n        }\\n        ans += cost[0];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709743,
                "title": "java-solution-easy-o-nlogn-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int minCost=0;\\n        int c=0;\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(c==2){\\n                c=0;\\n            }else{\\n                minCost+=cost[i];\\n                c++;\\n            }\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int minCost=0;\\n        int c=0;\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(c==2){\\n                c=0;\\n            }else{\\n                minCost+=cost[i];\\n                c++;\\n            }\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712364,
                "title": "python-simple-solution-100-faster-o-n-logn-time-o-1-space",
                "content": "Understanding:\\nReverse sort the array of costs. Now the first two will be highest costs which can help us get the third one for free and so on. \\n\\nAlgorithm:\\n- Reverse sort the array\\n- Initialize index i at 0, resultant cost as 0 and N as length of array cost\\n- Add the cost of 2 candies to result, i.e., the cost at index and the next one\\n- Increment index by 3, continue this step and above one till index reaches length of array\\n- Return the result\\n\\nPython code :\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        res, i, N = 0, 0, len(cost)\\n        while i < N:\\n            res += sum(cost[i : i + 2])\\n            i += 3\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        res, i, N = 0, 0, len(cost)\\n        while i < N:\\n            res += sum(cost[i : i + 2])\\n            i += 3\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709867,
                "title": "java-intuition-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n     *  1. Sort the cost array. \\n     *  2. In a loop, start from the back and buy items n, n-1 to get n-2 for free.\\n     *  3. Decrement the position by 3 and continue. stop when you reach 1.\\n     *  4. From 1, add the remaining 1 or 2 items.\\n     * \\n     */\\n    public int minimumCost(int[] cost) {\\n        int minCost = 0;\\n        int index = cost.length -1;\\n        Arrays.sort(cost);\\n        // add items in pairs of 2, the 3rd one getting it for free.\\n        while (index > 1) {\\n            minCost += cost[index] + cost[index -1];\\n            index -= 3;\\n        }\\n        // add the remaining 1, 2 items, if any.\\n        while(index >= 0) {\\n            minCost += cost[index--];\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n     *  1. Sort the cost array. \\n     *  2. In a loop, start from the back and buy items n, n-1 to get n-2 for free.\\n     *  3. Decrement the position by 3 and continue. stop when you reach 1.\\n     *  4. From 1, add the remaining 1 or 2 items.\\n     * \\n     */\\n    public int minimumCost(int[] cost) {\\n        int minCost = 0;\\n        int index = cost.length -1;\\n        Arrays.sort(cost);\\n        // add items in pairs of 2, the 3rd one getting it for free.\\n        while (index > 1) {\\n            minCost += cost[index] + cost[index -1];\\n            index -= 3;\\n        }\\n        // add the remaining 1, 2 items, if any.\\n        while(index >= 0) {\\n            minCost += cost[index--];\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155348,
                "title": "python-100-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost = sorted(cost,reverse=True)\\n        i =0 \\n        output = 0\\n        while i<len(cost):\\n            output += cost[i] if i == len(cost)-1 else cost[i] + cost[i+1]\\n            i +=3\\n        return output\\n\\n\\n```\\n![Screen Shot 2023-02-07 at 4.21.14 PM.png](https://assets.leetcode.com/users/images/26f9d26f-ba68-4e0a-80a6-3c8b20f49c29_1675767143.9538887.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost = sorted(cost,reverse=True)\\n        i =0 \\n        output = 0\\n        while i<len(cost):\\n            output += cost[i] if i == len(cost)-1 else cost[i] + cost[i+1]\\n            i +=3\\n        return output\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709772,
                "title": "greedy-solution-in-python-beats-100-36ms",
                "content": "Your goal is: skip the costly items as many as possible.\\n\\nTo do so, you choose the two largest items in the list, and then skip the next largest item. Repeat this process greedily.\\n\\nAlgorithm is to sort the item in an descending order, and take the first 2 items and move the index by 3, and repeat this until you reach the end.\\n\\nTime complexity: sort dominates and O(NlogN)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        res, idx, N = 0, 0, len(cost)\\n        while idx < N:\\n            res += sum(cost[idx : idx + 2])\\n            idx += 3\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        res, idx, N = 0, 0, len(cost)\\n        while idx < N:\\n            res += sum(cost[idx : idx + 2])\\n            idx += 3\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057151,
                "title": "java-sorting-eaxplained",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        // Sort the array \\n        // we will obtain costlier prices at the and and cheaper ones at the beginning\\n        Arrays.sort(cost);\\n        int totalCost = 0;  // store our total cost incurred\\n        // start iterating from the back\\n        for (int i = cost.length - 1; i >= 0 ; i -= 3) {\\n            // say we have prices 3,4,5. We first added 5 (max) to total, \\n            // then 4 (second max) to total and we skip 3.\\n            // because 3 <= min(4,5)\\n            totalCost += cost[i];   // adding the max to total\\n\\n            // say we are left with only 1 single price, \\n            // so index i-1 will lie out of bounds\\n            // so to check that, if we are in bounds we add the second max\\n            if (i - 1 >= 0) {  \\n                totalCost += cost[i - 1];   // adding the second max to total\\n            }\\n        }\\n\\n        return totalCost;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n / 3) => O(n * logn)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        // Sort the array \\n        // we will obtain costlier prices at the and and cheaper ones at the beginning\\n        Arrays.sort(cost);\\n        int totalCost = 0;  // store our total cost incurred\\n        // start iterating from the back\\n        for (int i = cost.length - 1; i >= 0 ; i -= 3) {\\n            // say we have prices 3,4,5. We first added 5 (max) to total, \\n            // then 4 (second max) to total and we skip 3.\\n            // because 3 <= min(4,5)\\n            totalCost += cost[i];   // adding the max to total\\n\\n            // say we are left with only 1 single price, \\n            // so index i-1 will lie out of bounds\\n            // so to check that, if we are in bounds we add the second max\\n            if (i - 1 >= 0) {  \\n                totalCost += cost[i - 1];   // adding the second max to total\\n            }\\n        }\\n\\n        return totalCost;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n / 3) => O(n * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709827,
                "title": "simple-c-5-lines-of-code",
                "content": "Sort the array in decreasing orderand skip the third element of the array as we  can take it for free.\\n Input: cost = [6,5,7,9,2,2]\\nOutput: 23\\nExplanation: After sorting \\ncost = [9,7,6,5,2,2]\\n take 9 and 7 in ans and skip 6 as we can get it for free. Now we can take 5 and 2 and skip 2. Answer would be 9+7+5+2 = 23\\n  \\n\\n```\\n int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        int res=0;\\n       \\n        for(int i=0; i< cost.size(); i++){\\n           \\n            res=res+ cost[i++];\\n            if(i<cost.size()) //to avoid runtime error\\n             res=res+ cost[i++];\\n        }\\n        return res;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "Sort the array in decreasing orderand skip the third element of the array as we  can take it for free.\\n Input: cost = [6,5,7,9,2,2]\\nOutput: 23\\nExplanation: After sorting \\ncost = [9,7,6,5,2,2]\\n take 9 and 7 in ans and skip 6 as we can get it for free. Now we can take 5 and 2 and skip 2. Answer would be 9+7+5+2 = 23\\n  \\n\\n```\\n int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        int res=0;\\n       \\n        for(int i=0; i< cost.size(); i++){\\n           \\n            res=res+ cost[i++];\\n            if(i<cost.size()) //to avoid runtime error\\n             res=res+ cost[i++];\\n        }\\n        return res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2040622,
                "title": "c-priority-queue-easy-to-understand",
                "content": "**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n       //make a max heap\\n        priority_queue<int> pq;\\n        \\n        for(int &n : cost) pq.push(n);\\n        \\n        int mincost=0;\\n        \\n        while(!pq.empty()){\\n            \\n            if(pq.size()==1){\\n                mincost += pq.top();\\n                pq.pop();\\n            }\\n           \\n            else{\\n            //buy two most expensive candies\\n            int candy1=pq.top();\\n            pq.pop();\\n            int candy2=pq.top();\\n            pq.pop();\\n            \\n            //update min cost\\n            mincost += candy1 + candy2;\\n            \\n            //take one candy for free\\n            if(!pq.empty())  pq.pop(); \\n           \\n            }\\n              \\n        }\\n        return mincost;\\n    }\\n};\\n```\\n**Please Upvote, if you find this solution useful!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n       //make a max heap\\n        priority_queue<int> pq;\\n        \\n        for(int &n : cost) pq.push(n);\\n        \\n        int mincost=0;\\n        \\n        while(!pq.empty()){\\n            \\n            if(pq.size()==1){\\n                mincost += pq.top();\\n                pq.pop();\\n            }\\n           \\n            else{\\n            //buy two most expensive candies\\n            int candy1=pq.top();\\n            pq.pop();\\n            int candy2=pq.top();\\n            pq.pop();\\n            \\n            //update min cost\\n            mincost += candy1 + candy2;\\n            \\n            //take one candy for free\\n            if(!pq.empty())  pq.pop(); \\n           \\n            }\\n              \\n        }\\n        return mincost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709903,
                "title": "easy-js-javascript",
                "content": "```\\nvar minimumCost = function(cost) {\\n    if (cost.length < 3) {\\n        return cost.reduce((prev, cur) => prev + cur);\\n    }\\n    \\n    cost.sort((a, b) => b - a);\\n    let count = 0;\\n    let sum = 0;\\n    \\n    for (const num of cost) {\\n        if (count === 2) {\\n            count = 0;\\n            continue;\\n        }\\n        sum += num;\\n        count++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumCost = function(cost) {\\n    if (cost.length < 3) {\\n        return cost.reduce((prev, cur) => prev + cur);\\n    }\\n    \\n    cost.sort((a, b) => b - a);\\n    let count = 0;\\n    let sum = 0;\\n    \\n    for (const num of cost) {\\n        if (count === 2) {\\n            count = 0;\\n            continue;\\n        }\\n        sum += num;\\n        count++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709728,
                "title": "c-greedy-sorting",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Greedy\\n\\nSort the costs in descending order. \\n\\nFrom left to right, after taking every two candies, skip one candy.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/minimum-cost-of-buying-candies-with-discount/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& A) {\\n        sort(begin(A), end(A), greater<>());\\n        int ans = 0, N = A.size();\\n        for (int i = 0; i < N; ++i) {\\n            ans += A[i++];\\n            if (i < N) ans += A[i++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/minimum-cost-of-buying-candies-with-discount/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& A) {\\n        sort(begin(A), end(A), greater<>());\\n        int ans = 0, N = A.size();\\n        for (int i = 0; i < N; ++i) {\\n            ans += A[i++];\\n            if (i < N) ans += A[i++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709683,
                "title": "python3-greedy-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8fc8469e823a229654fc858172dfa9383d805e39) for solutions of biweekly 70. \\n\\n**Intuition**\\nSort the candies in descending order and group them by every 3 candies. Among each group, add the cost of largest 2 to the final answer. \\n\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(x for i, x in enumerate(sorted(cost, reverse=True)) if (i+1)%3)\\n```\\n\\n**AofA**\\ntime complexity `O(NlogN)` \\nspace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(x for i, x in enumerate(sorted(cost, reverse=True)) if (i+1)%3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832387,
                "title": "easy-c-solution-using-sorting",
                "content": "\\n\\n# Approach\\nThe function minimumCost takes a vector cost as input, representing the costs of different candies.\\n\\nThe variable n is initialized to the size of the cost vector, which represents the number of candies available.\\n\\nThe variable i is initialized to n - 1, which points to the last element of the sorted cost vector.\\n\\nThe variable ans is initialized to 0. This will be used to store the total minimum cost.\\n\\nA check is performed to see if the number of candies is less than or equal to 2. If so, the code calculates the sum of all the elements in the cost vector and returns it as the answer. This is because when there are 0, 1, or 2 candies, no discounts are applied, and the total cost will be the sum of all the costs.\\n\\nThe cost vector is sorted in ascending order using sort(cost.begin(), cost.end()). Sorting the vector helps to access the minimum cost of the candies in a structured way.\\n\\nThe main loop is executed with the condition i >= 1, which means it will continue until there are at least two candies to consider (i.e., candies at indices i and i-1).\\n\\nInside the loop, ans is updated by adding the cost of the current candy and the cost of the previous candy (since the shop gives the lower-priced one for free). This is equivalent to adding the cost of the two lowest-priced candies at each step.\\n\\nAfter updating ans, the loop index i is decremented by 3 (i.e., i = i - 3), so the next iteration will consider the next pair of candies.\\n\\nIf the loop ends and there is one remaining candy (i.e., i == 0 or i == 1), the code adds its cost to ans since it cannot be paired with any other candy to get a discount.\\n\\nFinally, the function returns the value of ans, which represents the minimum cost of buying all the candies while considering the shop\\'s discount policy.\\n\\nThe overall approach of the code is to sort the candies and then add the costs of the two lowest-priced candies at each step until all the candies are paired. If there is an odd number of candies remaining, the code adds the cost of the last candy to the total cost.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n= cost.size();\\n        int i = n-1, ans = 0;\\n        \\n        if(n <= 2){\\n            for(auto x: cost) \\n                ans += x;\\n            return ans;\\n        }\\n        \\n        sort(cost.begin(), cost.end());\\n        \\n        while(i>=1){\\n            ans = ans +  cost[i] + cost[i-1];\\n            if(i-1 == 0 || i-1 == 1) return ans;\\n            i = i-3;\\n        }\\n        ans += cost[0];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n= cost.size();\\n        int i = n-1, ans = 0;\\n        \\n        if(n <= 2){\\n            for(auto x: cost) \\n                ans += x;\\n            return ans;\\n        }\\n        \\n        sort(cost.begin(), cost.end());\\n        \\n        while(i>=1){\\n            ans = ans +  cost[i] + cost[i-1];\\n            if(i-1 == 0 || i-1 == 1) return ans;\\n            i = i-3;\\n        }\\n        ans += cost[0];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839616,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int i=cost.length-1;\\n        int sum=0;\\n    \\n        while(i >=0){\\n            //when we have less than 2 elements we cant get the third element free\\n            if(i>=2){\\n                sum+= cost[i]+cost[i-1];\\n                i=i-3;\\n            }\\n                \\n            else{\\n                sum+= cost[i];\\n                i--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int i=cost.length-1;\\n        int sum=0;\\n    \\n        while(i >=0){\\n            //when we have less than 2 elements we cant get the third element free\\n            if(i>=2){\\n                sum+= cost[i]+cost[i-1];\\n                i=i-3;\\n            }\\n                \\n            else{\\n                sum+= cost[i];\\n                i--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710370,
                "title": "c-easy-greedy-and-sorting-simple-explanation",
                "content": "Just simply sort the given cost array\\nStart traversing from back, and keep adding the sum.\\nKeep a count initialised to 2, because whenever we buy 2 candies we get a candy free(of cost less than min of bought ones ,**case handled via sorting**)  so we need to skip the next one\\nWhenever we are adding cost of candy,dec count once it hits 0, skip the next candy and reinitialise count to 2\\n\\n```\\n int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int sum = 0;\\n        int n = cost.size();\\n        int count = 2;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=cost[i];\\n            count--;\\n            if(count == 0){\\n                i--;\\n                count=2;\\n            }\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "Just simply sort the given cost array\\nStart traversing from back, and keep adding the sum.\\nKeep a count initialised to 2, because whenever we buy 2 candies we get a candy free(of cost less than min of bought ones ,**case handled via sorting**)  so we need to skip the next one\\nWhenever we are adding cost of candy,dec count once it hits 0, skip the next candy and reinitialise count to 2\\n\\n```\\n int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int sum = 0;\\n        int n = cost.size();\\n        int count = 2;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=cost[i];\\n            count--;\\n            if(count == 0){\\n                i--;\\n                count=2;\\n            }\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1709885,
                "title": "javascript-2-liner-with-detailed-explanation",
                "content": "Did this question in biweekly contest, first problem.\\nIt was actually easier than I figured.\\n\\nSince you get a free item after buying 2 others which are more expesive, you want to sort the array, buy two, get the next free, and repeat.  Basically in your new array, add cost of anything that\\'s not the 3rd item.\\n\\nAfter sorting the array, i do a reduce function to see every item in the array, and carry a sum value.  If it\\'s not in a \"free\" 3rd index, I\\'ll add it\\'s cost.\\n\\n```\\nvar minimumCost = function(cost) {\\n  cost = cost.sort((a,b)=>b-a);\\n  return cost.reduce((sum, cur, index)=> sum + ((index%3===2)?0:cur), 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumCost = function(cost) {\\n  cost = cost.sort((a,b)=>b-a);\\n  return cost.reduce((sum, cur, index)=> sum + ((index%3===2)?0:cur), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709759,
                "title": "java",
                "content": "```\\npublic int minimumCost(int[] cost) {\\n        int sum = 0;\\n        int n = cost.length;\\n        if(n<=2){\\n            for(int i = 0 ; i<n ;i++)\\n            sum+=cost[i];\\n        }\\n        else{\\n             Arrays.sort(cost);\\n        \\n            for(int i = n-1 ; i>=0 ; ){\\n                if(i-1>=0)\\n                sum += (cost[i]+cost[i-1]);\\n                else\\n                    sum+=cost[i];\\n           \\n           // System.out.println(cost[i]);\\n            i = i-3;\\n        }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumCost(int[] cost) {\\n        int sum = 0;\\n        int n = cost.length;\\n        if(n<=2){\\n            for(int i = 0 ; i<n ;i++)\\n            sum+=cost[i];\\n        }\\n        else{\\n             Arrays.sort(cost);\\n        \\n            for(int i = n-1 ; i>=0 ; ){\\n                if(i-1>=0)\\n                sum += (cost[i]+cost[i-1]);\\n                else\\n                    sum+=cost[i];\\n           \\n           // System.out.println(cost[i]);\\n            i = i-3;\\n        }\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709650,
                "title": "a-few-solutions",
                "content": "Sort the input array `A` in descending order, then return the accumulated sum of all `i`<sup>th</sup> items (excluding each 3<sup>rd</sup> item) to greedily consume the largest first.\\n    \\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var minimumCost = { A: IntArray -> A.sorted().reversed().mapIndexed{ i, x -> if ((i + 1) % 3 != 0) x else 0 }.sum() }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumCost = A => A.sort((a, b) => b - a) && _.sum(A.map((x, i) => (i + 1) % 3 ? x : 0));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    minimumCost = lambda self, A: sum(x for i, x in enumerate(reversed(sorted(A))) if (i + 1) % 3)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumCost(VI& A, int t = 0) {\\n        sort(A.rbegin(), A.rend());\\n        return accumulate(A.begin(), A.end(), 0, [i = -1](auto t, auto x) mutable {\\n            return (++i + 1) % 3 ? t + x : t;\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var minimumCost = { A: IntArray -> A.sorted().reversed().mapIndexed{ i, x -> if ((i + 1) % 3 != 0) x else 0 }.sum() }\\n}\\n```\n```\\nlet minimumCost = A => A.sort((a, b) => b - a) && _.sum(A.map((x, i) => (i + 1) % 3 ? x : 0));\\n```\n```\\nclass Solution:\\n    minimumCost = lambda self, A: sum(x for i, x in enumerate(reversed(sorted(A))) if (i + 1) % 3)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumCost(VI& A, int t = 0) {\\n        sort(A.rbegin(), A.rend());\\n        return accumulate(A.begin(), A.end(), 0, [i = -1](auto t, auto x) mutable {\\n            return (++i + 1) % 3 ? t + x : t;\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376047,
                "title": "minimum-cost-of-buying-candies-with-discount-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int i=0, sum=0;\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        while(i<cost.size())\\n        {\\n            sum += cost[i];\\n            if((i+1)<cost.size())\\n            {\\n                sum += cost[i+1];\\n            }\\n            i += 3;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int i=0, sum=0;\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        while(i<cost.size())\\n        {\\n            sum += cost[i];\\n            if((i+1)<cost.size())\\n            {\\n                sum += cost[i+1];\\n            }\\n            i += 3;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039346,
                "title": "easy-c-solution-sort-and-reverse-traverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every **Two Candies**, we get a **free Candy**. So we select two maximum costs to get the Candy with third maximum cost for free. \\n\\n# Approach\\n***Correct me in the Comments if you feel like there could be a better approach:)***\\n<!-- Describe your approach to solving the problem. -->\\nSort the Array.\\nMaintain the **purchased count**. whenever 2 Candies have been purchased, set **Count=0** and skip to next iteration (Free Candy).\\n# Complexity\\n- Time complexity: **O(nlogn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int purchasedCount=0;\\n        int totalCost=0;\\n        for(int i=cost.size()-1;i>=0;i--){\\n            if(purchasedCount!=0 && purchasedCount%2==0){\\n                purchasedCount=0;\\n                continue;\\n            }\\n            else{\\n                totalCost+=cost[i];\\n                purchasedCount++;\\n            }\\n        }\\n        return totalCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int purchasedCount=0;\\n        int totalCost=0;\\n        for(int i=cost.size()-1;i>=0;i--){\\n            if(purchasedCount!=0 && purchasedCount%2==0){\\n                purchasedCount=0;\\n                continue;\\n            }\\n            else{\\n                totalCost+=cost[i];\\n                purchasedCount++;\\n            }\\n        }\\n        return totalCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636425,
                "title": "sort-and-add",
                "content": "```\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(), greater<int>());\\n        int sum =0;\\n        for(int i=0;i<cost.size();){\\n            sum += cost[i];\\n            if(i+1<cost.size())\\n                sum+=cost[i+1];\\n            i=i+3;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(), greater<int>());\\n        int sum =0;\\n        for(int i=0;i<cost.size();){\\n            sum += cost[i];\\n            if(i+1<cost.size())\\n                sum+=cost[i+1];\\n            i=i+3;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501902,
                "title": "easy-to-understand-java-code-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum=0, toffee=1;\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(toffee%3==0){\\n                toffee=1;\\n            }else{\\n                sum+=cost[i];\\n                toffee++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum=0, toffee=1;\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(toffee%3==0){\\n                toffee=1;\\n            }else{\\n                sum+=cost[i];\\n                toffee++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384893,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int mincost = 0;\\n        int count = 0;\\n        for (int i = cost.length - 1; i >= 0; i--) \\n        {\\n            if (count != 2)\\n            {\\n                mincost += cost[i];\\n                count++;\\n            } else\\n            {\\n                count = 0;\\n            }\\n        }\\n        return mincost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int mincost = 0;\\n        int count = 0;\\n        for (int i = cost.length - 1; i >= 0; i--) \\n        {\\n            if (count != 2)\\n            {\\n                mincost += cost[i];\\n                count++;\\n            } else\\n            {\\n                count = 0;\\n            }\\n        }\\n        return mincost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776841,
                "title": "c-93-faster-very-easy-solution-beginner-friendly",
                "content": "**Please Upvote if you found this useful.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) \\n    {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        int ans= 0;\\n        int count= 0;\\n        for(int i=0; i<cost.size(); i++)\\n        {\\n            if(count!= 2)\\n            {\\n                ans+= cost[i];\\n                count++;\\n            }\\n            else\\n            {\\n                count= 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) \\n    {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        int ans= 0;\\n        int count= 0;\\n        for(int i=0; i<cost.size(); i++)\\n        {\\n            if(count!= 2)\\n            {\\n                ans+= cost[i];\\n                count++;\\n            }\\n            else\\n            {\\n                count= 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758987,
                "title": "python-2-line-99-faster",
                "content": "```py\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        return sum(cost[::3]) + sum(cost[1::3])\\n\\n``` \\nor \\n```py\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        return sum(cost) - sum(cost[2::3])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        return sum(cost[::3]) + sum(cost[1::3])\\n\\n```\n```py\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        return sum(cost) - sum(cost[2::3])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758383,
                "title": "java-easy-efficient-faster-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost); //sorting the prices so that we can get the free candy price easily.\\n        int total = 0;\\n        int j = 0;\\n        for(int i = cost.length-1; i >= 0; i--){ //starting from the last\\n            if(j == 2){\\n                j = 0; \\n                continue; //every third candy is free.\\n            }\\n            total += cost[i];\\n            j++;\\n            \\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\nPlease **UPVOTE** if you find this solution helpful.\\nhappy Coding : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost); //sorting the prices so that we can get the free candy price easily.\\n        int total = 0;\\n        int j = 0;\\n        for(int i = cost.length-1; i >= 0; i--){ //starting from the last\\n            if(j == 2){\\n                j = 0; \\n                continue; //every third candy is free.\\n            }\\n            total += cost[i];\\n            j++;\\n            \\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720238,
                "title": "java-sort-and-skip-2ms-solution-simple-and-easy",
                "content": "**please upvote if you like my solution**\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int res=0,count=0;\\n        if(cost.length==1)return cost[0];\\n        Arrays.sort(cost);\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(count==2){\\n                count=0;\\n                continue;\\n            }else{\\n            res+=cost[i];\\n            count++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int res=0,count=0;\\n        if(cost.length==1)return cost[0];\\n        Arrays.sort(cost);\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(count==2){\\n                count=0;\\n                continue;\\n            }else{\\n            res+=cost[i];\\n            count++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714025,
                "title": "java-greedy-simple",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        \\n        int paid = 0;\\n        for (int i = cost.length - 1; i > 0; i -= 3)\\n            paid += cost[i] + cost[i - 1];\\n        \\n        if (cost.length % 3 == 1) paid += cost[0];\\n        \\n        return paid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        \\n        int paid = 0;\\n        for (int i = cost.length - 1; i > 0; i -= 3)\\n            paid += cost[i] + cost[i - 1];\\n        \\n        if (cost.length % 3 == 1) paid += cost[0];\\n        \\n        return paid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713953,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int totalCost=0;\\n        int a=0;\\n        int i=0;\\n        for(i=cost.length-1;i>=0;i--)\\n        {\\n            if(a<2)\\n            {\\n                totalCost+=cost[i];\\n                a++;\\n            }\\n            else\\n            {\\n                a=0;\\n            }\\n        }\\n        return totalCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int totalCost=0;\\n        int a=0;\\n        int i=0;\\n        for(i=cost.length-1;i>=0;i--)\\n        {\\n            if(a<2)\\n            {\\n                totalCost+=cost[i];\\n                a++;\\n            }\\n            else\\n            {\\n                a=0;\\n            }\\n        }\\n        return totalCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710875,
                "title": "python3-sort-one-pass-greedy-o-n-time-o-1-space",
                "content": "Below is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        bought = res = 0\\n        for p in cost:\\n            if bought < 2:\\n                res += p\\n                bought += 1\\n            else:\\n                bought = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        bought = res = 0\\n        for p in cost:\\n            if bought < 2:\\n                res += p\\n                bought += 1\\n            else:\\n                bought = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710234,
                "title": "c-easy-to-understand-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int sum=0;\\n        for(int i=0;i<cost.size();i++)\\n            if((i+1)%3 != 0) sum+=cost[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int sum=0;\\n        for(int i=0;i<cost.size();i++)\\n            if((i+1)%3 != 0) sum+=cost[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710140,
                "title": "c-easy-solution",
                "content": "# **Easy C++ Solution using Greedy Approach**\\n\\n1. First we need to sort the array in **descending order** to satisfy the first condition i.e. the sum of cost of third product will be smaller than the sum of cost of two products bought by the person.\\n\\n2. Then we can **skip every third element** present in our vector and find the final cost.\\n\\n\\n Time Complexity - **O(nlogn)** for sort and O(n) to calculate final cost.\\n```\\n int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(), greater<int>());\\n        int n=cost.size();\\n        int totalCost=0;\\n        for(int i=0;i<n;i++){\\n            if((i+1)%3==0)\\n                continue;\\n            else\\n                totalCost+=cost[i];\\n        }\\n        return totalCost;\\n    }\\n```\\n\\n**Please Upvote if you liked the solution**\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end(), greater<int>());\\n        int n=cost.size();\\n        int totalCost=0;\\n        for(int i=0;i<n;i++){\\n            if((i+1)%3==0)\\n                continue;\\n            else\\n                totalCost+=cost[i];\\n        }\\n        return totalCost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709893,
                "title": "single-loop-c-solution",
                "content": "```\\n    int minimumCost(vector<int>& cost) {\\n        \\n        if(cost.size()==0) return 0;\\n        \\n        sort(cost.begin(),cost.end(),greater<int>());  \\n        \\n        int n=cost.size();\\n        int sum=0,cnt=1;\\n        \\n        for(auto x:cost)\\n        {\\n            if(cnt++ %3) sum+=x;    //every third  number is excluded\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minimumCost(vector<int>& cost) {\\n        \\n        if(cost.size()==0) return 0;\\n        \\n        sort(cost.begin(),cost.end(),greater<int>());  \\n        \\n        int n=cost.size();\\n        int sum=0,cnt=1;\\n        \\n        for(auto x:cost)\\n        {\\n            if(cnt++ %3) sum+=x;    //every third  number is excluded\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709832,
                "title": "python3-runtime-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost=sorted(cost)[::-1]\\n        n = len(cost)\\n        ans = 0\\n        for i in range(0,n,3):\\n            if i+1<n:\\n                ans+=cost[i+1]\\n            ans+=cost[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost=sorted(cost)[::-1]\\n        n = len(cost)\\n        ans = 0\\n        for i in range(0,n,3):\\n            if i+1<n:\\n                ans+=cost[i+1]\\n            ans+=cost[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709762,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n       int n = cost.length;\\n       int ans = 0;\\n       Arrays.sort(cost);\\n        int i = n - 1;\\n        while(i >= 0){\\n            if(i >= 0)ans += cost[i];\\n            i--;\\n            if(i >= 0)ans += cost[i];\\n            i--;\\n            i--;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n       int n = cost.length;\\n       int ans = 0;\\n       Arrays.sort(cost);\\n        int i = n - 1;\\n        while(i >= 0){\\n            if(i >= 0)ans += cost[i];\\n            i--;\\n            if(i >= 0)ans += cost[i];\\n            i--;\\n            i--;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709673,
                "title": "python-solution-using-heap-or-sorting",
                "content": "**Using Sorting:**\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        cost = cost[::-1]\\n        ans = 0\\n        n = len(cost)\\n        for i in range(n):\\n            if (i+1)%3!=0:\\n                ans += cost[i] \\n        return ans\\n```\\n**Using Heap:**\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        max_heap = []\\n        for i in cost:\\n            heappush(max_heap, -i) # make max heap with given costs\\n        ans, n = 0, len(cost)\\n        while n > 0:\\n\\t\\t# take 2 candies out with their costs added to ans\\n            ans += -heappop(max_heap) # - used to negate the -ve sign\\n            n -= 1\\n            if n > 0:\\n                ans += -heappop(max_heap) # - used to negate the -ve sign\\n                n -= 1\\n\\t\\t\\t# if heap is not empty take 3rd candy out with discount, so costs not added to ans\\n            if n > 0:\\n                heappop(max_heap)\\n                n -= 1\\n        return ans\\n```\\n\\nGive an \\u2B06\\uFE0Fupvote if you found this helpful. Happy Coding!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        cost = cost[::-1]\\n        ans = 0\\n        n = len(cost)\\n        for i in range(n):\\n            if (i+1)%3!=0:\\n                ans += cost[i] \\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        max_heap = []\\n        for i in cost:\\n            heappush(max_heap, -i) # make max heap with given costs\\n        ans, n = 0, len(cost)\\n        while n > 0:\\n\\t\\t# take 2 candies out with their costs added to ans\\n            ans += -heappop(max_heap) # - used to negate the -ve sign\\n            n -= 1\\n            if n > 0:\\n                ans += -heappop(max_heap) # - used to negate the -ve sign\\n                n -= 1\\n\\t\\t\\t# if heap is not empty take 3rd candy out with discount, so costs not added to ans\\n            if n > 0:\\n                heappop(max_heap)\\n                n -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018850,
                "title": "simple-java-solution-using-arrays-sort",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the array using Arrays.sort() then start a for loop from the end of the array. Use count=1 to count the number of elements we have covered. Use sum=0 to calculate the sum. Now add the elements in the sum and increase the count. Whenever the (count%3==0) add 0 to the sum because the third candy is free. At last return sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int count=1;\\n        int sum=0;\\n        for(int i=cost.length-1;i>=0;i--)\\n        {\\n            if(count%3==0)\\n            {\\n                sum+=0;\\n            }\\n            else\\n            {\\n                sum+=cost[i];\\n            }\\n            count++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int count=1;\\n        int sum=0;\\n        for(int i=cost.length-1;i>=0;i--)\\n        {\\n            if(count%3==0)\\n            {\\n                sum+=0;\\n            }\\n            else\\n            {\\n                sum+=cost[i];\\n            }\\n            count++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701723,
                "title": "4-lines-beats-99-runtime",
                "content": "# Intuition\\nFor the max value, we have to pay for it.\\nFor the second max value, we still have to pay for it.\\nFor the third max value, we can get it free one as bonus.\\nAnd continuely do this for the rest.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        res = 0\\n        for i in range(len(cost)):\\n            if i%3 != len(cost)%3: res+=cost[i]\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        res = 0\\n        for i in range(len(cost)):\\n            if i%3 != len(cost)%3: res+=cost[i]\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678006,
                "title": "c-super-rare-greedy-trending-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n    \\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int mini = 0;\\n        for(int i=0; i<cost.size(); i++){\\n            if(i%3 == 2) continue;\\n            mini += cost[i];\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n    \\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int mini = 0;\\n        for(int i=0; i<cost.size(); i++){\\n            if(i%3 == 2) continue;\\n            mini += cost[i];\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644938,
                "title": "98-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n     int n = cost.length;\\n     Arrays.sort(cost);\\n     int sum=0,neg=0;\\n     for(int i=0;i<n;i++){\\n         sum+=cost[i];\\n     }\\n     if(n%3==0){ \\n     for(int i=0;i<n;i=i+3){\\n         neg+=cost[i];\\n     }\\n     }\\n     if(n%3==1){ \\n     for(int i=1;i<n;i=i+3){\\n         neg+=cost[i];\\n     }\\n     }\\n     if(n%3==2){ \\n     for(int i=2;i<n;i=i+3){\\n         neg+=cost[i];\\n     }\\n     }\\n     return sum-neg;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n     int n = cost.length;\\n     Arrays.sort(cost);\\n     int sum=0,neg=0;\\n     for(int i=0;i<n;i++){\\n         sum+=cost[i];\\n     }\\n     if(n%3==0){ \\n     for(int i=0;i<n;i=i+3){\\n         neg+=cost[i];\\n     }\\n     }\\n     if(n%3==1){ \\n     for(int i=1;i<n;i=i+3){\\n         neg+=cost[i];\\n     }\\n     }\\n     if(n%3==2){ \\n     for(int i=2;i<n;i=i+3){\\n         neg+=cost[i];\\n     }\\n     }\\n     return sum-neg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441062,
                "title": "easy-peasy-using-single-loop",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(begin(cost), end(cost), greater<int>());\\n        int sum=0;\\n        int temp=0;\\n        int i=0;\\n        int count=0;\\n        for(i=0; i<cost.size(); i++){\\n            if(count==2){\\n                count=0;\\n                temp=temp+sum;\\n                sum=0;\\n                continue;\\n            }\\n            count++;\\n            sum+=cost[i];\\n            if(i==cost.size()-1) temp=temp+sum;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(begin(cost), end(cost), greater<int>());\\n        int sum=0;\\n        int temp=0;\\n        int i=0;\\n        int count=0;\\n        for(i=0; i<cost.size(); i++){\\n            if(count==2){\\n                count=0;\\n                temp=temp+sum;\\n                sum=0;\\n                continue;\\n            }\\n            count++;\\n            sum+=cost[i];\\n            if(i==cost.size()-1) temp=temp+sum;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427106,
                "title": "easy-c-solution-for-absolute-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        reverse(cost.begin(),cost.end());\\n        int k=0, sum=0;\\n        for(int i=0;i<cost.size();i++)\\n         {\\n             k++;\\n             if(k==3)\\n                k=0;\\n            else\\n              {\\n                  sum+=cost[i];\\n              }\\n               \\n         }\\n         return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        reverse(cost.begin(),cost.end());\\n        int k=0, sum=0;\\n        for(int i=0;i<cost.size();i++)\\n         {\\n             k++;\\n             if(k==3)\\n                k=0;\\n            else\\n              {\\n                  sum+=cost[i];\\n              }\\n               \\n         }\\n         return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382138,
                "title": "100-runtime-beats-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int sum = 0;\\n        int n = cost.size();\\n        sort(cost.begin(),cost.end(),greater());\\n\\n\\n        for(int i=0;i<n;i++){\\n            if((i+1)%3==0){\\n                continue;\\n            }\\n            else{\\n                sum+=cost[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int sum = 0;\\n        int n = cost.size();\\n        sort(cost.begin(),cost.end(),greater());\\n\\n\\n        for(int i=0;i<n;i++){\\n            if((i+1)%3==0){\\n                continue;\\n            }\\n            else{\\n                sum+=cost[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293839,
                "title": "python-o-n-runtime-solution-counting-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust use counting sort to get O(N) runtime.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe hardest part is counting two out of three candies.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$: You have to look through the entire array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$: The array is fixed-length due to the constraints.\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumCost(self, cost):\\n        buff = [0] * 101\\n        for x in cost:\\n            buff[x] += 1\\n        \\n        needed = 3\\n        res = 0\\n        for x in range(100, 0, -1):\\n            if buff[x]:\\n                k = buff[x]\\n                if k < needed:\\n                    res += x * k\\n                    needed -= k\\n                else:\\n                    k -= needed\\n                    res += x * (needed - 1 +\\n                                k // 3 * 2 +\\n                                k % 3)\\n                    needed = 3 - k % 3\\n        \\n        return res\\n```\\nIf it\\'s hard to understand, explore this one at first:\\n```\\nclass Solution(object):\\n    def minimumCost(self, cost):\\n        buff = [0] * 101\\n        for x in cost:\\n            buff[x] += 1\\n        \\n        count = 0\\n        res = 0\\n        for x in range(100, 0, -1):\\n            while buff[x]:\\n                if count == 2:\\n                    count = 0\\n                else:\\n                    res += x\\n                    count += 1\\n                buff[x] -= 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "Greedy",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumCost(self, cost):\\n        buff = [0] * 101\\n        for x in cost:\\n            buff[x] += 1\\n        \\n        needed = 3\\n        res = 0\\n        for x in range(100, 0, -1):\\n            if buff[x]:\\n                k = buff[x]\\n                if k < needed:\\n                    res += x * k\\n                    needed -= k\\n                else:\\n                    k -= needed\\n                    res += x * (needed - 1 +\\n                                k // 3 * 2 +\\n                                k % 3)\\n                    needed = 3 - k % 3\\n        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def minimumCost(self, cost):\\n        buff = [0] * 101\\n        for x in cost:\\n            buff[x] += 1\\n        \\n        count = 0\\n        res = 0\\n        for x in range(100, 0, -1):\\n            while buff[x]:\\n                if count == 2:\\n                    count = 0\\n                else:\\n                    res += x\\n                    count += 1\\n                buff[x] -= 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204489,
                "title": "short-and-easy-solution-sort-for",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    cost.sort((a, b) => b - a);\\n\\n    let sum = 0;\\n\\n    for (let i = 0; i < cost.length; i += 3) {\\n        // cost[i + 1] could not exist, so use 0 then\\n        sum += cost[i] + (cost?.[i + 1] ?? 0);\\n    }\\n\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    cost.sort((a, b) => b - a);\\n\\n    let sum = 0;\\n\\n    for (let i = 0; i < cost.length; i += 3) {\\n        // cost[i + 1] could not exist, so use 0 then\\n        sum += cost[i] + (cost?.[i + 1] ?? 0);\\n    }\\n\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112145,
                "title": "python3-easy-approach",
                "content": "# Code1\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost=sorted(cost,reverse=True)\\n        mincost=0\\n        lenn=len(cost)-1\\n        for i in range(0,len(cost),3):\\n            mincost+=cost[i]\\n            if i != lenn:\\n                mincost+=cost[i+1]\\n        return mincost\\n```\\n# Code 2\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(cost)-sum(sorted(cost,reverse=True)[2::3])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost=sorted(cost,reverse=True)\\n        mincost=0\\n        lenn=len(cost)-1\\n        for i in range(0,len(cost),3):\\n            mincost+=cost[i]\\n            if i != lenn:\\n                mincost+=cost[i+1]\\n        return mincost\\n```\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(cost)-sum(sorted(cost,reverse=True)[2::3])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095125,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        \\n        int n=cost.size();\\n        if(n==1)return cost[0];\\n        int i=n-1;\\n        int sum=0;\\n        while(i>=2)\\n        {\\n            sum+=cost[i]+cost[i-1];\\n            i-=3;\\n        }\\n        while(i>=0)\\n        {\\n            sum+=cost[i];\\n            i--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        \\n        int n=cost.size();\\n        if(n==1)return cost[0];\\n        int i=n-1;\\n        int sum=0;\\n        while(i>=2)\\n        {\\n            sum+=cost[i]+cost[i-1];\\n            i-=3;\\n        }\\n        while(i>=0)\\n        {\\n            sum+=cost[i];\\n            i--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776614,
                "title": "c-cpp-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int sum = 0;\\n        for(int i=cost.size()-3;i>=0;i=i-3)\\n            sum += cost[i];\\n        int totalSum = 0;\\n        for(int x:cost)\\n            totalSum+=x;\\n        return totalSum-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int sum = 0;\\n        for(int i=cost.size()-3;i>=0;i=i-3)\\n            sum += cost[i];\\n        int totalSum = 0;\\n        for(int x:cost)\\n            totalSum+=x;\\n        return totalSum-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705997,
                "title": "java-simple-solution",
                "content": "//Dev Bhayani\\n\\nclass Solution {\\n    public int minimumCost(int[] a) {\\n        int b[]=new int[a.length];\\n        Arrays.sort(a);\\n        int j=0;\\n        for(int i=a.length-1;i>=0;i--)\\n        {\\n            b[j]=a[i];\\n            j++;\\n        }\\n        int sum=0;\\n         j=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(j==2)\\n            {\\n                j=0;\\n                continue;\\n            }\\n            else\\n            {\\n                sum+=b[i];\\n                j++;\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumCost(int[] a) {\\n        int b[]=new int[a.length];\\n        Arrays.sort(a);\\n        int j=0;\\n        for(int i=a.length-1;i>=0;i--)\\n        {\\n            b[j]=a[i];\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612303,
                "title": "very-simple-and-concise-greedy-reverse-sorting-c",
                "content": "```\\nint minimumCost(vector<int>& cost) {\\n        //Reverse Sort the cost\\n        if(cost.size()==1){return cost[0];}\\n         sort(cost.begin(),cost.end(),greater());\\n        \\n        int minCost=0;\\n        int i=0;\\n        int cnt=0;\\n        \\n        for(int i=0;i<cost.size();i++)\\n        {\\n            if(cnt==2){cnt=0;continue;}\\n            \\n            minCost+=cost[i];\\n            cnt++;\\n        }\\n        \\n        return minCost;\\n    }\\n```\\n\\n***Upvote if Helpful!! :))***",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint minimumCost(vector<int>& cost) {\\n        //Reverse Sort the cost\\n        if(cost.size()==1){return cost[0];}\\n         sort(cost.begin(),cost.end(),greater());\\n        \\n        int minCost=0;\\n        int i=0;\\n        int cnt=0;\\n        \\n        for(int i=0;i<cost.size();i++)\\n        {\\n            if(cnt==2){cnt=0;continue;}\\n            \\n            minCost+=cost[i];\\n            cnt++;\\n        }\\n        \\n        return minCost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569569,
                "title": "c-optimal-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minimumCost(vector<int> &cost)\\n        {\\n            int n = cost.size();\\n            sort(cost.begin(), cost.end(), greater < > ());\\n            int ans = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if ((i + 1) % 3 != 0)\\n                {\\n                    ans = ans + cost[i];\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public:\\n        int minimumCost(vector<int> &cost)\\n        {\\n            int n = cost.size();\\n            sort(cost.begin(), cost.end(), greater < > ());\\n            int ans = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if ((i + 1) % 3 != 0)\\n                {\\n                    ans = ans + cost[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2525394,
                "title": "c-simple-greedy-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        \\n        \\n        // SOrt The cost of candies\\n        sort(cost.begin(), cost.end());\\n        \\n        \\n        // The Idea is first we will buy two candies of maximum cost \\n        // and then we get 3rd maximum cost price candy for free \\n        // Similarly we will buy 4th and 5th maximum cost candy \\n        // and we will get 6th maximum cost price candy for free and so on\\n        \\n        //count variable denotes how many candies we neeed to buy at a point\\n        int count = 2, price  = 0;\\n        for(int  i = cost.size()-1 ; i>= 0 ; i--)\\n        {\\n            // if count == 0 it means we can get this canfy for free \\n            if(count == 0)\\n            {\\n                count = 2;\\n                continue;\\n            }\\n            \\n            price += cost[i];\\n            count--;\\n        }\\n        \\n        return price;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        \\n        \\n        // SOrt The cost of candies\\n        sort(cost.begin(), cost.end());\\n        \\n        \\n        // The Idea is first we will buy two candies of maximum cost \\n        // and then we get 3rd maximum cost price candy for free \\n        // Similarly we will buy 4th and 5th maximum cost candy \\n        // and we will get 6th maximum cost price candy for free and so on\\n        \\n        //count variable denotes how many candies we neeed to buy at a point\\n        int count = 2, price  = 0;\\n        for(int  i = cost.size()-1 ; i>= 0 ; i--)\\n        {\\n            // if count == 0 it means we can get this canfy for free \\n            if(count == 0)\\n            {\\n                count = 2;\\n                continue;\\n            }\\n            \\n            price += cost[i];\\n            count--;\\n        }\\n        \\n        return price;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504463,
                "title": "c-greedy-sorting-easy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int minimumCost(vector<int>& cost) {\\n        \\n        int ans = 0 ;\\n        \\n        sort(cost.begin() , cost.end() );\\n        \\n        int buy = cost.size()-1;\\n        \\n        while( buy >=0 ){\\n            if( buy < 1 ){ \\n                ans += cost[0];\\n                break;\\n            }\\n            ans += cost[buy] + cost[buy-1];\\n            buy = buy - 3;\\n        }\\n        \\n        return ans;\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minimumCost(vector<int>& cost) {\\n        \\n        int ans = 0 ;\\n        \\n        sort(cost.begin() , cost.end() );\\n        \\n        int buy = cost.size()-1;\\n        \\n        while( buy >=0 ){\\n            if( buy < 1 ){ \\n                ans += cost[0];\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2501033,
                "title": "easy-solution",
                "content": "```\\nint minimumCost(vector<int>& cost) {\\n        \\n        sort ( cost.begin() , cost.end() );\\n        \\n        int sum = 0;\\n        \\n        int k = 0;\\n        \\n        for( int i = cost.size() - 1; i >= 0; i-- ){\\n            \\n            if(k <= 1) sum += cost[i] , k++;\\n            \\n            else k = 0;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint minimumCost(vector<int>& cost) {\\n        \\n        sort ( cost.begin() , cost.end() );\\n        \\n        int sum = 0;\\n        \\n        int k = 0;\\n        \\n        for( int i = cost.size() - 1; i >= 0; i-- ){\\n            \\n            if(k <= 1) sum += cost[i] , k++;\\n            \\n            else k = 0;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2407112,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) \\n    {\\n        Arrays.sort(cost);\\n        int sum = 0;\\n        \\n        // Method 1:\\n        for(int i = cost.length - 3; i >= 0; i -= 3)\\n            cost[i] = 0;\\n        \\n        for(int j = 0; j < cost.length; j++)\\n            sum += cost[j];\\n        \\n        // Method 2:\\n        for(int i = cost.length - 1; i >= 0; i--)\\n            if ((cost.length - i)%3 != 0)\\n                sum += cost[i];\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) \\n    {\\n        Arrays.sort(cost);\\n        int sum = 0;\\n        \\n        // Method 1:\\n        for(int i = cost.length - 3; i >= 0; i -= 3)\\n            cost[i] = 0;\\n        \\n        for(int j = 0; j < cost.length; j++)\\n            sum += cost[j];\\n        \\n        // Method 2:\\n        for(int i = cost.length - 1; i >= 0; i--)\\n            if ((cost.length - i)%3 != 0)\\n                sum += cost[i];\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077791,
                "title": "typescript-simple-solution-with-o-n-time-complexity-and-at-o-1-space",
                "content": "## Solution in linear time and constant space\\n\\nSolution: Out of 3 selection, customer will get least cost selection free. So we can sort the array in reverse order and chose all element which are not multiple of 3 and will get element multiple of 3 Free.\\n\\n```\\nfunction minimumCost(cost: number[]): number {\\n    cost.sort((a,b)=> b-a);\\n    \\n    let r = 0;\\n    for(let i=1; i<=cost.length;i++){\\n        if(i%3 != 0){\\n            r += cost[i-1];\\n        }\\n    }\\n    return r;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumCost(cost: number[]): number {\\n    cost.sort((a,b)=> b-a);\\n    \\n    let r = 0;\\n    for(let i=1; i<=cost.length;i++){\\n        if(i%3 != 0){\\n            r += cost[i-1];\\n        }\\n    }\\n    return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052002,
                "title": "python-solution-drop-every-third-value-in-the-sorted-descending-cost",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        if len(cost) < 3:\\n            return sum(cost)\\n        cost.sort(reverse=True)\\n        total = 0\\n        for i in range(0, len(cost), 3):\\n            if i + 1 < len(cost):\\n                total += cost[i] + cost[i+1]\\n            else:\\n                total += cost[i]\\n        return total\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        if len(cost) < 3:\\n            return sum(cost)\\n        cost.sort(reverse=True)\\n        total = 0\\n        for i in range(0, len(cost), 3):\\n            if i + 1 < len(cost):\\n                total += cost[i] + cost[i+1]\\n            else:\\n                total += cost[i]\\n        return total\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897301,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        a=sorted(cost)[::-1]\\n        c=0\\n        for i in range(0,len(a),3):\\n            c+=sum(a[i:i+2])\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        a=sorted(cost)[::-1]\\n        c=0\\n        for i in range(0,len(a),3):\\n            c+=sum(a[i:i+2])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883309,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        if (cost.length == 0) {\\n            return 0;\\n        }\\n        \\n        if (cost.length == 1) {\\n            return cost[0];\\n        }\\n        \\n        Arrays.sort(cost);\\n        int count = 0;\\n                \\n        for (int i = cost.length - 1; i >= 0; i = i - 3) {\\n            if (i == 0) {\\n                count = count + cost[i];\\n                break;\\n            }\\n            \\n            count = count + cost[i] + cost[i - 1];\\n            \\n            if (i == 1) {\\n                break;\\n            }\\n            if (cost[i - 2] > cost[i] || cost[i - 2] > cost[i - 1]) {\\n                count = count + cost[i - 2];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        if (cost.length == 0) {\\n            return 0;\\n        }\\n        \\n        if (cost.length == 1) {\\n            return cost[0];\\n        }\\n        \\n        Arrays.sort(cost);\\n        int count = 0;\\n                \\n        for (int i = cost.length - 1; i >= 0; i = i - 3) {\\n            if (i == 0) {\\n                count = count + cost[i];\\n                break;\\n            }\\n            \\n            count = count + cost[i] + cost[i - 1];\\n            \\n            if (i == 1) {\\n                break;\\n            }\\n            if (cost[i - 2] > cost[i] || cost[i - 2] > cost[i - 1]) {\\n                count = count + cost[i - 2];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863723,
                "title": "c-easy-with-intuition-best-than-all",
                "content": "int minimumCost(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int sum=0;\\n        int n = arr.size();\\n        int cnt=0;\\n       \\n        for(int i=n-1;i>=0;i--){\\n            if(cnt==2 && arr[i]<=arr[i+1] && arr[i]<=arr[i+2]){\\n            \\n                cnt=0;\\n                continue;\\n            \\n            }\\n            sum+=arr[i];\\n            cnt++;\\n            \\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "int minimumCost(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        int sum=0;\\n        int n = arr.size();\\n        int cnt=0;\\n       \\n        for(int i=n-1;i>=0;i--){\\n            if(cnt==2 && arr[i]<=arr[i+1] && arr[i]<=arr[i+2]){\\n            \\n                cnt=0;\\n                continue;\\n            \\n            }\\n            sum+=arr[i];\\n            cnt++;\\n            \\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1855077,
                "title": "python-solution-faster-than-94",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse = True)\\n        hops = 1\\n        min_cost = 0\\n        for i in range(len(cost)):\\n            if hops == 1 or hops == 2:\\n                min_cost += cost[i]\\n                hops += 1\\n            elif hops == 3:\\n                hops = 1\\n        return min_cost",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse = True)\\n        hops = 1\\n        min_cost = 0\\n        for i in range(len(cost)):\\n            if hops == 1 or hops == 2:\\n                min_cost += cost[i]\\n                hops += 1\\n            elif hops == 3:\\n                hops = 1\\n        return min_cost",
                "codeTag": "Java"
            },
            {
                "id": 1811872,
                "title": "calculate-every-multiple-of-3-python",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost_c = list(sorted(cost)[::-1])\\n        value = 0\\n        for i in range(len(cost)):\\n            if (i+1)%3==0:\\n                continue\\n            else:\\n                value+=cost_c[i]\\n        return value\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost_c = list(sorted(cost)[::-1])\\n        value = 0\\n        for i in range(len(cost)):\\n            if (i+1)%3==0:\\n                continue\\n            else:\\n                value+=cost_c[i]\\n        return value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774086,
                "title": "python3-2-lines",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        return sum(cost)-sum(cost[2::3])\\n```\\n\\nor \\n\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        res=0\\n        for i,el in enumerate(sorted(cost,reverse=True)):\\n            if i>1 and (i-2)%3==0: continue\\n            res+=el\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        return sum(cost)-sum(cost[2::3])\\n```\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        res=0\\n        for i,el in enumerate(sorted(cost,reverse=True)):\\n            if i>1 and (i-2)%3==0: continue\\n            res+=el\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765967,
                "title": "python-easy-simple-soultion",
                "content": "**idea:** We can first by two maximum cost candies then we can get third for free. Continue this untill you buy all candies.\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)          # sort in reverse order \\n        ans=sum(cost)                       # find total sum of price of candies\\n        for i in range(2,len(cost),3):    # we will get third candy for free\\n            ans-=cost[i]                        # so remove the price of third candy from total price\\n        return ans\\n```\\nUpvote if you find it helpful.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)          # sort in reverse order \\n        ans=sum(cost)                       # find total sum of price of candies\\n        for i in range(2,len(cost),3):    # we will get third candy for free\\n            ans-=cost[i]                        # so remove the price of third candy from total price\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763045,
                "title": "python-solution-with-explanation",
                "content": "Here first we sort the given cost array coz we are told that we have to find min cost value at the end and we can pic one candie after buying 2 candies but we have to remember that the cost of that selected candy has to be less than or equal to the value of the min cost value among those 2 selected candies.\\n\\nSo bcoz of this constraint we sort the cost array and then work on it from the back instead of front to keep on removing the the next max cost value after selecting the previous 2 max values.\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        s=0\\n        while(len(cost)!=0):\\n            if(len(cost)<2):\\n                s=s+cost[-1]\\n                cost.remove(cost[-1])\\n            else:\\n                s=s+cost[-1]\\n                cost.remove(cost[-1])\\n                s=s+cost[-1]\\n                cost.remove(cost[-1])\\n                if(len(cost)>0):\\n                    cost.remove(cost[-1])\\n        return(s)\\n```\\nIf u understood the code then plz...UPVOTE....thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        s=0\\n        while(len(cost)!=0):\\n            if(len(cost)<2):\\n                s=s+cost[-1]\\n                cost.remove(cost[-1])\\n            else:\\n                s=s+cost[-1]\\n                cost.remove(cost[-1])\\n                s=s+cost[-1]\\n                cost.remove(cost[-1])\\n                if(len(cost)>0):\\n                    cost.remove(cost[-1])\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760306,
                "title": "simple-solution-faster-than-98-68",
                "content": "```\\nvar minimumCost = function(arr) {\\n    arr.sort((a,b) => a - b);\\n    let cost = 0;\\n    \\n    while (arr.length >= 3) {\\n        cost += arr.pop();\\n        cost += arr.pop();\\n        arr.pop();\\n    }\\n    \\n    cost += (arr[0]|0) + (arr[1]|0);\\n    \\n    return cost;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumCost = function(arr) {\\n    arr.sort((a,b) => a - b);\\n    let cost = 0;\\n    \\n    while (arr.length >= 3) {\\n        cost += arr.pop();\\n        cost += arr.pop();\\n        arr.pop();\\n    }\\n    \\n    cost += (arr[0]|0) + (arr[1]|0);\\n    \\n    return cost;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745037,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 9.52 % of typescript submissions (44.8 MB)\\n```\\nfunction minimumCost(cost: number[]): number {\\n    let result: number = 0;\\n    cost.sort((a, b) => b - a);\\n    for (let i: number = 0; i < cost.length; i++) {\\n        if (i % 3 < 2) {\\n            result += cost[i];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumCost(cost: number[]): number {\\n    let result: number = 0;\\n    cost.sort((a, b) => b - a);\\n    for (let i: number = 0; i < cost.length; i++) {\\n        if (i % 3 < 2) {\\n            result += cost[i];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731557,
                "title": "c-solution-easy-to-understand-with-comments",
                "content": "Ex-   arr[]={9,6,7,2,5,2};\\nBasically sort the array and reverse the array and insert 0 at the beginning\\nnow  arr becomes {0,9,7,6,5,2,2}\\nnow start a loop at the starting and skip the element at the third position\\nand sum all the remaining elements.\\n\\n**CODE**\\n\\n vector<int>vect;\\n        vect.push_back(0);\\n        sort(costs.begin(),costs.end());\\n        reverse(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            vect.push_back(costs[i]);\\n        }\\n        int n=vect.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%3!=0){\\n            sum=sum+vect[i];\\n            }\\n        }\\n        return sum;",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "Ex-   arr[]={9,6,7,2,5,2};\\nBasically sort the array and reverse the array and insert 0 at the beginning\\nnow  arr becomes {0,9,7,6,5,2,2}\\nnow start a loop at the starting and skip the element at the third position\\nand sum all the remaining elements.\\n\\n**CODE**\\n\\n vector<int>vect;\\n        vect.push_back(0);\\n        sort(costs.begin(),costs.end());\\n        reverse(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            vect.push_back(costs[i]);\\n        }\\n        int n=vect.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%3!=0){\\n            sum=sum+vect[i];\\n            }\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 1729485,
                "title": "c-soln-minimum-cost-of-buying-candies-with-discount",
                "content": "**class Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int cnt=0;\\n        for(int i = 0;i<cost.size();i++){\\n            cnt+=cost[i];\\n        }\\n        if(cost.size()>=3){\\n        for(int i = cost.size()-3;i>=0;i-=3){\\n            cnt = cnt-cost[i];\\n        }\\n        }\\n        return cnt;\\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int cnt=0;\\n        for(int i = 0;i<cost.size();i++){\\n            cnt+=cost[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1723836,
                "title": "java-easy-understandable-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int n = cost.length;\\n        int minCost = 0;\\n        for(int i = n-1 ; i >= 0; i-=3){\\n            if(i == 0) minCost += cost[i] ;\\n            else minCost += cost[i] +cost[i-1];\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int n = cost.length;\\n        int minCost = 0;\\n        for(int i = n-1 ; i >= 0; i-=3){\\n            if(i == 0) minCost += cost[i] ;\\n            else minCost += cost[i] +cost[i-1];\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714196,
                "title": "c-counting-to-avoid-sorting-with-o-n-time-complexity",
                "content": "Since the cost is limited to max 100, we can use counting to replace sorting.\\n```\\n    int minimumCost(vector<int>& cost) {\\n        // counting alg to avoid sorting\\n        int cnt[101]={}, res=0;\\n        for (auto c : cost)\\n            cnt[c]++;\\n        for (int i=100, k=0; i>0; i--)\\n        {\\n            while (cnt[i])\\n            {\\n                cnt[i]--;\\n                if (k++<2)\\n                    res += i; // add cost for first 2 items with larger price\\n                else\\n                    k=0; // free for the third item and reset to 0\\n            }\\n        }\\n        return res;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "Since the cost is limited to max 100, we can use counting to replace sorting.\\n```\\n    int minimumCost(vector<int>& cost) {\\n        // counting alg to avoid sorting\\n        int cnt[101]={}, res=0;\\n        for (auto c : cost)\\n            cnt[c]++;\\n        for (int i=100, k=0; i>0; i--)\\n        {\\n            while (cnt[i])\\n            {\\n                cnt[i]--;\\n                if (k++<2)\\n                    res += i; // add cost for first 2 items with larger price\\n                else\\n                    k=0; // free for the third item and reset to 0\\n            }\\n        }\\n        return res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1713613,
                "title": "c-brute-force",
                "content": "**C++**\\n              \\n\\t\\tclass Solution {\\n           public:\\n    int minimumCost(vector<int>& cost) { int n=cost.size();\\n        sort(cost.begin(),cost.end());\\n        int p=accumulate(cost.begin(),cost.end(),0);\\n                                        if(n<3)return p;\\n        int sum=0;\\n        for(int i=n-3;i>=0;i=i-3){\\n            sum+=cost[i];\\n        }\\n        return p-sum;\\n    }};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n           public:\\n    int minimumCost(vector<int>& cost) { int n=cost.size();\\n        sort(cost.begin(),cost.end());\\n        int p=accumulate(cost.begin(),cost.end(),0);\\n                                        if(n<3)return p;\\n        int sum=0;\\n        for(int i=n-3;i>=0;i=i-3){\\n            sum+=cost[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1713507,
                "title": "c-simple-short-and-easy-solution-explained",
                "content": "We sort the array.\\nThen, we loop from the end, and for each adjacent trio, we take add the two first candies to `res` and take the third one for free.\\nIn that way, we can get the maximum profit.\\n\\n**Time Complexity:** O(n logn)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int res = 0;\\n        \\n        sort(cost.begin(), cost.end());\\n        \\n        for (int i = cost.size()-1; i >= 0; i -= 3)\\n            res += (i == 0) ? cost[i] : cost[i] + cost[i-1];\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int res = 0;\\n        \\n        sort(cost.begin(), cost.end());\\n        \\n        for (int i = cost.size()-1; i >= 0; i -= 3)\\n            res += (i == 0) ? cost[i] : cost[i] + cost[i-1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713404,
                "title": "using-sorting-simple-very-easy-with-comments-c",
                "content": "Implementation\\n\\n**Using sorting\\nTime Complexity = O(N)\\nSpace Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        \\n        // sort the array into descending order\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        \\n        // storing the result\\n        int totalCount = 0;\\n        \\n        // traversing the array, and skipping the every 3rd element, bcz we are buying 1st and 2nd and getting 3rd as a free.\\n        for(int itr = 0; itr < n; itr++){\\n            \\n            // adding every first element\\n            totalCount += cost[itr];\\n            \\n            // checking every 2nd index, if its valid, then add, otherwise break\\n            if(++itr < n) totalCount += cost[itr];\\n            else break;\\n            \\n            // skipping every 3rd element\\n            itr++;\\n        }\\n        return totalCount;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        \\n        // sort the array into descending order\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        \\n        // storing the result\\n        int totalCount = 0;\\n        \\n        // traversing the array, and skipping the every 3rd element, bcz we are buying 1st and 2nd and getting 3rd as a free.\\n        for(int itr = 0; itr < n; itr++){\\n            \\n            // adding every first element\\n            totalCount += cost[itr];\\n            \\n            // checking every 2nd index, if its valid, then add, otherwise break\\n            if(++itr < n) totalCount += cost[itr];\\n            else break;\\n            \\n            // skipping every 3rd element\\n            itr++;\\n        }\\n        return totalCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712546,
                "title": "using-pq-in-tc-o-n-and-sc-o-n",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:cost){\\n            pq.add(i);\\n        }\\n        while(pq.size()>2){\\n            sum+= (pq.poll() + pq.poll());\\n            pq.poll();\\n        }\\n        while(pq.size()!=0){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i:cost){\\n            pq.add(i);\\n        }\\n        while(pq.size()>2){\\n            sum+= (pq.poll() + pq.poll());\\n            pq.poll();\\n        }\\n        while(pq.size()!=0){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710467,
                "title": "c-minimum-cost-of-buying-candies-with-discount",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n=cost.size();\\n        if(n==1) return cost[0];\\n        if(n==2) return cost[0]+cost[1];\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int s=0;\\n        int i=2;\\n        while(i<n)\\n        {\\n            s+=cost[i];\\n            i=i+3;\\n        }\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=cost[i];\\n        }\\n        int res=sum-s;   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n=cost.size();\\n        if(n==1) return cost[0];\\n        if(n==2) return cost[0]+cost[1];\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int s=0;\\n        int i=2;\\n        while(i<n)\\n        {\\n            s+=cost[i];\\n            i=i+3;\\n        }\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=cost[i];\\n        }\\n        int res=sum-s;   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710417,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n=cost.size();\\n        if(n==1)return cost[0];\\n        int money=0;\\n        priority_queue<int> pq;\\n        for(auto i: cost) pq.push(i);\\n        while(!pq.empty()){\\n            int p=2;\\n            while(p--){\\n                money+=pq.top();\\n                pq.pop();\\n            }\\n            if(!pq.empty()) pq.pop();       //remove the 3 element\\n\\t\\t\\t// after removing 3 element check if only one element remains then add it\\n            if(pq.size()==1){\\n                money+=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n=cost.size();\\n        if(n==1)return cost[0];\\n        int money=0;\\n        priority_queue<int> pq;\\n        for(auto i: cost) pq.push(i);\\n        while(!pq.empty()){\\n            int p=2;\\n            while(p--){\\n                money+=pq.top();\\n                pq.pop();\\n            }\\n            if(!pq.empty()) pq.pop();       //remove the 3 element\\n\\t\\t\\t// after removing 3 element check if only one element remains then add it\\n            if(pq.size()==1){\\n                money+=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710253,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n\\t// first sorting the array from smallest to largest\\n\\t// then create a count variable which is useful for calculating the amount of candy that we have bought\\n\\t// every time we buy 2 candies the next candy is free\\n\\t// and start with the largest number in the array\\n    cost.sort((a, b) => a - b)\\n    console.log(cost)\\n    let maxCandy = cost.length - 1\\n    let result = 0;\\n    let count = 0;\\n    \\n    if (cost.length === 1) return cost\\n    \\n    while(maxCandy >= 0){\\n        if(count === 2){\\n            maxCandy--\\n            count = 0\\n        }else{\\n            result += cost[maxCandy]\\n            maxCandy--\\n            count++\\n        }\\n    }\\n    \\n\\tthen return the result\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n\\t// first sorting the array from smallest to largest\\n\\t// then create a count variable which is useful for calculating the amount of candy that we have bought\\n\\t// every time we buy 2 candies the next candy is free\\n\\t// and start with the largest number in the array\\n    cost.sort((a, b) => a - b)\\n    console.log(cost)\\n    let maxCandy = cost.length - 1\\n    let result = 0;\\n    let count = 0;\\n    \\n    if (cost.length === 1) return cost\\n    \\n    while(maxCandy >= 0){\\n        if(count === 2){\\n            maxCandy--\\n            count = 0\\n        }else{\\n            result += cost[maxCandy]\\n            maxCandy--\\n            count++\\n        }\\n    }\\n    \\n\\tthen return the result\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710128,
                "title": "java-greedy-sort-and-iterate-from-largest",
                "content": "```\\npublic int minimumCost(int[] cost) {\\n\\tArrays.sort(cost);\\n\\tint n= cost.length, total= 0;\\n\\tfor(int i=n-1; i>-1; i--){\\n\\t\\ttotal+= cost[i--];\\n\\t\\tif(i>-1) total+= cost[i--];\\n\\t}\\n\\treturn total;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int minimumCost(int[] cost) {\\n\\tArrays.sort(cost);\\n\\tint n= cost.length, total= 0;\\n\\tfor(int i=n-1; i>-1; i--){\\n\\t\\ttotal+= cost[i--];\\n\\t\\tif(i>-1) total+= cost[i--];\\n\\t}\\n\\treturn total;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1709993,
                "title": "java-sc-o-1-tc-o-nlogn-n",
                "content": "Please upvote if you like my solution.\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int size = cost.length, result = 0;\\n        for(int i = size - 1; i >= 0; i--){\\n            if((size - i) % 3 == 0) continue;\\n            result += cost[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int size = cost.length, result = 0;\\n        for(int i = size - 1; i >= 0; i--){\\n            if((size - i) % 3 == 0) continue;\\n            result += cost[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709990,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n             int sum=0;\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        for(int i=0;i<cost.size();i++)    \\n\\t\\t{\\n            if(i%3==2)\\n            {\\n                continue;\\n            }\\n            sum+=cost[i];\\n        }\\n        return sum;\\n\\t\\t}\\n\\t\\t};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n             int sum=0;\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        for(int i=0;i<cost.size();i++)    \\n\\t\\t{\\n            if(i%3==2)\\n            {\\n                continue;\\n            }\\n            sum+=cost[i];\\n        }\\n        return sum;\\n\\t\\t}\\n\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709953,
                "title": "100-runtime",
                "content": "![image](https://assets.leetcode.com/users/images/14322ba0-0a18-4590-b46c-e76ea2465f15_1642868393.039074.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int sol = 0;\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        for (int i = 0; i < cost.size(); i++) {\\n            if ((i + 1) % 3 != 0) {\\n                sol += cost[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```\\n\\nFeel free to ask doubts \\nand you are also welcome to share any suggestion\\nHappy coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int sol = 0;\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        for (int i = 0; i < cost.size(); i++) {\\n            if ((i + 1) % 3 != 0) {\\n                sol += cost[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709932,
                "title": "easy-c-solution",
                "content": "smjh\\n```\\n int minimumCost(vector<int>& cost) {\\n        \\n       \\n        int n = cost.size();\\n       sort(cost.rbegin(),cost.rend());\\n        int res = 0;\\n        int count = 0;\\n        for(int i =0;i<n;i++){\\n            if(count ==2){\\n                count =0;\\n                continue;\\n            }\\n            res +=cost[i];\\n            count++;\\n        }\\n        return res;\\n        \\n    }\\n```\\nDo upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int minimumCost(vector<int>& cost) {\\n        \\n       \\n        int n = cost.size();\\n       sort(cost.rbegin(),cost.rend());\\n        int res = 0;\\n        int count = 0;\\n        for(int i =0;i<n;i++){\\n            if(count ==2){\\n                count =0;\\n                continue;\\n            }\\n            res +=cost[i];\\n            count++;\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709926,
                "title": "very-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum = 0 ;\\n        int i = cost.length-1;\\n        while(i>=0){   \\n            if(i>=0) sum += cost[i];\\n            i--;\\n            if(i>=0) sum += cost[i];\\n            i--;\\n            i--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum = 0 ;\\n        int i = cost.length-1;\\n        while(i>=0){   \\n            if(i>=0) sum += cost[i];\\n            i--;\\n            if(i>=0) sum += cost[i];\\n            i--;\\n            i--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709889,
                "title": "solution-using-greedy-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        sort(cost.begin(),cost.end());\\n        \\n        int total =0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==0){\\n                total+=cost[0];break;\\n            }\\n            \\n           total+=cost[i]+cost[i-1];\\n            i-=2;\\n            \\n            \\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        sort(cost.begin(),cost.end());\\n        \\n        int total =0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==0){\\n                total+=cost[0];break;\\n            }\\n            \\n           total+=cost[i]+cost[i-1];\\n            i-=2;\\n            \\n            \\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709861,
                "title": "c-greedy-logic",
                "content": "Sort it. Then you want to get highest cost candie for free So,\\n\\nBuy (n-1)th and (n-2)th, and get (n-3)th for free.\\nRepeat same Buy = n-4,n-5 and get n-6 for free.\\n......\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n = cost.size();\\n        int ans=0;\\n        \\n        for(int i=n-3;i>=0;i=i-3)   ans+=cost[i+1]+cost[i+2];\\n        \\n        if(n%3==1) ans+=cost[0];\\n        else if(n%3==2) ans+=cost[0]+cost[1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n = cost.size();\\n        int ans=0;\\n        \\n        for(int i=n-3;i>=0;i=i-3)   ans+=cost[i+1]+cost[i+2];\\n        \\n        if(n%3==1) ans+=cost[0];\\n        else if(n%3==2) ans+=cost[0]+cost[1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709830,
                "title": "java-sorting-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int min = 0;\\n        Arrays.sort(cost);\\n        for(int i = cost.length-1; i >= 0; i -= 3) {\\n            min += cost[i];\\n            if(i-1 >= 0) {\\n                min += cost[i-1];\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int min = 0;\\n        Arrays.sort(cost);\\n        for(int i = cost.length-1; i >= 0; i -= 3) {\\n            min += cost[i];\\n            if(i-1 >= 0) {\\n                min += cost[i-1];\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709816,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) \\n    {\\n        int sum=0;\\n        int n=cost.size();\\n        int count=0;\\n        sort(cost.rbegin(),cost.rend());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(count==2)\\n            {\\n                count=0;\\n                continue;\\n            }\\n            sum+=cost[i];\\n            count++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) \\n    {\\n        int sum=0;\\n        int n=cost.size();\\n        int count=0;\\n        sort(cost.rbegin(),cost.rend());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(count==2)\\n            {\\n                count=0;\\n                continue;\\n            }\\n            sum+=cost[i];\\n            count++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709765,
                "title": "java-easy-solution-foreach-loop",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum=0;\\n        int cnt=1;\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(cnt%3!=0){\\n                sum+=cost[i];\\n            }\\n            cnt+=1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum=0;\\n        int cnt=1;\\n        for(int i=cost.length-1;i>=0;i--){\\n            if(cnt%3!=0){\\n                sum+=cost[i];\\n            }\\n            cnt+=1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709739,
                "title": "simple-java-solution-with-sorting",
                "content": "```class Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum = 0;\\n        int len = cost.length;\\n        for(int i=len-1;i>=0;i--){\\n            if((len-i)%3==0)\\n                continue;\\n            sum+=cost[i];\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum = 0;\\n        int len = cost.length;\\n        for(int i=len-1;i>=0;i--){\\n            if((len-i)%3==0)\\n                continue;\\n            sum+=cost[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1709730,
                "title": "java-sort-simple",
                "content": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        \\n        Arrays.sort(cost);\\n        int minCost=0;\\n        \\n        int i;\\n        for(i=cost.length-1 ;i>0 ; i--){\\n            \\n            int c1=cost[i];\\n            \\n            int c2=cost[--i];\\n            minCost+=c1+c2;\\n                  \\n            // check if we can skip the next element\\n            if(i>=0 && cost[i]<=c1 && c2>=cost[i])\\n            i--;\\n           \\n        }\\n        if(i==0)\\n        minCost+=cost[0];\\n        \\n        return minCost;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        \\n        Arrays.sort(cost);\\n        int minCost=0;\\n        \\n        int i;\\n        for(i=cost.length-1 ;i>0 ; i--){\\n            \\n            int c1=cost[i];\\n            \\n            int c2=cost[--i];\\n            minCost+=c1+c2;\\n                  \\n            // check if we can skip the next element\\n            if(i>=0 && cost[i]<=c1 && c2>=cost[i])\\n            i--;\\n           \\n        }\\n        if(i==0)\\n        minCost+=cost[0];\\n        \\n        return minCost;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084487,
                "title": "minimum-cost-of-buying-candies",
                "content": "# Approach\\n\\nIn descending order, every third sweet is free. \\n\\nTherefore, sort the array into descending order, remove every third element (because this one is free), and then sum up the remaining values inside the array before returning. \\n\\n```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n   return cost.sort((a, b) => b - a)\\n    .filter((_, i) => (i + 1) % 3 !== 0)\\n    .reduce((acc, a) => acc + a, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n   return cost.sort((a, b) => b - a)\\n    .filter((_, i) => (i + 1) % 3 !== 0)\\n    .reduce((acc, a) => acc + a, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083951,
                "title": "using-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n = cost.size();\\n        int k=2,cst=0;\\n        for(int i = n-1;i>=0;i--){\\n            if(k==0){\\n                k=2;\\n                continue;\\n            }\\n            else{\\n                cst+=cost[i];\\n                k--;\\n            }\\n        }\\n        return cst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n = cost.size();\\n        int k=2,cst=0;\\n        for(int i = n-1;i>=0;i--){\\n            if(k==0){\\n                k=2;\\n                continue;\\n            }\\n            else{\\n                cst+=cost[i];\\n                k--;\\n            }\\n        }\\n        return cst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081019,
                "title": "100-beats-in-c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size() == 1){\\n            return cost[0];\\n        }\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int len = cost.size();\\n        int i = 0;\\n        int j = 1;\\n        int min_cost = 0;\\n\\n        if(len % 3 == 0 || len % 3 == 2){\\n            while(i < len && j < len){\\n                min_cost += cost[i] + cost[j];\\n                i += 3;\\n                j += 3;\\n            }\\n        }\\n        else{\\n            while(i < len && j < len){\\n                min_cost += cost[i] + cost[j];\\n                i += 3;\\n                j += 3;\\n            }\\n            min_cost += cost[len - 1];\\n        }\\n\\n        return min_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size() == 1){\\n            return cost[0];\\n        }\\n        sort(cost.begin(),cost.end(),greater<int>());\\n        int len = cost.size();\\n        int i = 0;\\n        int j = 1;\\n        int min_cost = 0;\\n\\n        if(len % 3 == 0 || len % 3 == 2){\\n            while(i < len && j < len){\\n                min_cost += cost[i] + cost[j];\\n                i += 3;\\n                j += 3;\\n            }\\n        }\\n        else{\\n            while(i < len && j < len){\\n                min_cost += cost[i] + cost[j];\\n                i += 3;\\n                j += 3;\\n            }\\n            min_cost += cost[len - 1];\\n        }\\n\\n        return min_cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075285,
                "title": "2144",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum = 0;\\n        int num = 0;\\n        for(int i=cost.length-1;i>-1;i--){\\n            if(num==2){\\n                num = 0;\\n                continue;\\n            }else{\\n                sum+= cost[i];\\n                num++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int sum = 0;\\n        int num = 0;\\n        for(int i=cost.length-1;i>-1;i--){\\n            if(num==2){\\n                num = 0;\\n                continue;\\n            }else{\\n                sum+= cost[i];\\n                num++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073992,
                "title": "my-easy-beginner-solution",
                "content": "# Intuition\\nSorting the list in an descending order allows me to see that every third element is free.\\n\\n# Approach\\nI tried to make an integer storing the total price of bought candles, sorted the cost list in an descending array. Then I started a for loop going from 1 to cost length + 1 to allow me to sort out every third number more easily. Finally, I use the modulo operator to not include every third number in the cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        totalcost = 0\\n        cost.sort(reverse=True)\\n        for i in range(1, len(cost) + 1):\\n            if i % 3 != 0:\\n                totalcost += cost[i - 1]\\n        return totalcost\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        totalcost = 0\\n        cost.sort(reverse=True)\\n        for i in range(1, len(cost) + 1):\\n            if i % 3 != 0:\\n                totalcost += cost[i - 1]\\n        return totalcost\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067090,
                "title": "easy-solution-using-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. define some base case(ex- for length 1,2)\\n2. sort the array\\n3. now move from the last of the array and add it to final cost and every time increase the count\\n4. when count reaches the value 2 the value of free candy is to be eliminated.\\n5. repeat till 0th index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        if(cost.length==1) return cost[0];\\n        if(cost.length==2){\\n          return cost[0]+cost[1];\\n        }\\n        Arrays.sort(cost);\\n        int price=0;\\n        int min=101;\\n        int count=0;\\n      for(int i=cost.length-1;i>=0;i--){\\n        int x=cost[i];\\n        if(count==2){\\n          count=0;\\n        }\\n        else{\\n          price+=x;\\n          count++;\\n        }\\n      }\\n      return price;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        if(cost.length==1) return cost[0];\\n        if(cost.length==2){\\n          return cost[0]+cost[1];\\n        }\\n        Arrays.sort(cost);\\n        int price=0;\\n        int min=101;\\n        int count=0;\\n      for(int i=cost.length-1;i>=0;i--){\\n        int x=cost[i];\\n        if(count==2){\\n          count=0;\\n        }\\n        else{\\n          price+=x;\\n          count++;\\n        }\\n      }\\n      return price;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065978,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(c for i, c in enumerate(sorted(cost, reverse= True), start= 1) if i%3)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(c for i, c in enumerate(sorted(cost, reverse= True), start= 1) if i%3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064532,
                "title": "buying-candies-javascript-easy-sort-and-traverse",
                "content": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    cost.sort((a, b) =>  b - a)\\n    ans = 0\\n\\n    for (let i = 0; i < cost.length; i+=3) {\\n        ans += cost[i+1] ? cost[i+1] + cost[i] : cost[i]\\n    }\\n\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    cost.sort((a, b) =>  b - a)\\n    ans = 0\\n\\n    for (let i = 0; i < cost.length; i+=3) {\\n        ans += cost[i+1] ? cost[i+1] + cost[i] : cost[i]\\n    }\\n\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035961,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    cost.sort((a,b) => b - a)\\n    let res = 0\\n    for(let i=0; i < cost.length;i+=3) {\\n        res += (cost[i] || 0) + (cost[i + 1] || 0)\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    cost.sort((a,b) => b - a)\\n    let res = 0\\n    for(let i=0; i < cost.length;i+=3) {\\n        res += (cost[i] || 0) + (cost[i + 1] || 0)\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027229,
                "title": "python3-easy-peasy-solution-upvote-if-you-like",
                "content": "# Complexity\\n- Time complexity: O(nlgn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        return sum(cost[i] for i in range(-1, -len(cost)-1, -1) if i%3 != 0)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        return sum(cost[i] for i in range(-1, -len(cost)-1, -1) if i%3 != 0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026289,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter sorting the arrya you can get to know that we can sove this problem via skipping the every 3rd element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI iterated through last element after sorting \\n2,2,5,6,7,9\\ncount the two elements ans skip the 3rd element \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        // 2,2,5,6,7,9\\n\\n        sort(cost.begin(), cost.end());\\n        int totalCost=0;\\n        int interval=1;\\n\\n        for(int i=cost.size()-1; i>=0; i--){\\n            if(interval<=2){\\n                totalCost+=cost[i];\\n                interval++;\\n            }else{\\n                interval=1;\\n                continue;\\n            }\\n        }\\n\\n        return totalCost;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        // 2,2,5,6,7,9\\n\\n        sort(cost.begin(), cost.end());\\n        int totalCost=0;\\n        int interval=1;\\n\\n        for(int i=cost.size()-1; i>=0; i--){\\n            if(interval<=2){\\n                totalCost+=cost[i];\\n                interval++;\\n            }else{\\n                interval=1;\\n                continue;\\n            }\\n        }\\n\\n        return totalCost;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019238,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n\\n        int cst = 0;\\n        for(int i=0;i<cost.size();i++){\\n            if((i+1)%3 != 0){\\n                cst += cost[i];\\n            }\\n        }\\n        return cst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n\\n        int cst = 0;\\n        for(int i=0;i<cost.size();i++){\\n            if((i+1)%3 != 0){\\n                cst += cost[i];\\n            }\\n        }\\n        return cst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017957,
                "title": "o-nlogn-n-approach-sorting-and-looping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem statement there is minimum so there is some sort of comparision here third member is comparing with first 2 numbers. so lets sort it and compare first 2 elements by breaking list int groups of 3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngiven an array so sort it in descending order,\\nthen go through the array and whenever the third element appears just skip it while adding to total amount \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsorting the array --> quick sor-> O(nlogn)\\nand loop the array once --> O(n)\\nsums total time complexity --> O(nlogn + n)\\nNo extra space is used --> O(1).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int amount=0;\\n        int n = cost.size();\\n    sort(cost.begin(),cost.end(),greater <>());\\n        \\n        for(int i = 0;i<n;i++){\\n            if (i%3 == 2)\\n                continue;\\n            else{\\n                amount += cost[i];\\n            }\\n            \\n        }\\n\\n        return amount;\\n        \\n    }\\n> };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int amount=0;\\n        int n = cost.size();\\n    sort(cost.begin(),cost.end(),greater <>());\\n        \\n        for(int i = 0;i<n;i++){\\n            if (i%3 == 2)\\n                continue;\\n            else{\\n                amount += cost[i];\\n            }\\n            \\n        }\\n\\n        return amount;\\n        \\n    }\\n> };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008075,
                "title": "o-n-easy-and-simple-approach-better-than-100",
                "content": "# **Please Upvote if you like the answer and able to understand it.**\\n\\n# Approach\\nSort an array and add the top two max elements in the total and skip the third maximum element and repeat this while traversing the whole array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int total=0,n=cost.size()-1;\\n        for(int i=n;i>=0;i-=3){\\n            if(i==0) total+=cost[i];\\n            else total+=cost[i]+cost[i-1];\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int total=0,n=cost.size()-1;\\n        for(int i=n;i>=0;i-=3){\\n            if(i==0) total+=cost[i];\\n            else total+=cost[i]+cost[i-1];\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006595,
                "title": "optiminal-nive-approch-understandable-code-of-6-line",
                "content": "# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For the max value, we have to pay for it.\\n- For the second max value, we still have to pay for it.\\n- For the third max value, we can get it free one as bonus.\\n- And continuely do this for the rest.\\n\\n**The the core of problem, is need to sort the input.\\nAll A[i] with i % 3 == n % 3, we can get it for free.**\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:***O(N)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int res=0;\\n        for(int i=0; i<cost.length; i++){\\n            if(i%3 != (cost.length)%3) res+=cost[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int res=0;\\n        for(int i=0; i<cost.length; i++){\\n            if(i%3 != (cost.length)%3) res+=cost[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992457,
                "title": "2ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int min=0;\\n        int k=0;\\n        for(int i=cost.length-1;i>=0;i--)\\n        {\\n            if(k!=2)\\n            {\\n                min+=cost[i];\\n                k++;\\n            }\\n            else{\\n                k=0;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int min=0;\\n        int k=0;\\n        for(int i=cost.length-1;i>=0;i--)\\n        {\\n            if(k!=2)\\n            {\\n                min+=cost[i];\\n                k++;\\n            }\\n            else{\\n                k=0;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981979,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int sum=0;\\n        for(int i=0;i<cost.size();i++)\\n            sum+=cost[i];\\n        int i=cost.size()-3;\\n        while(i>=0)\\n        {\\n            sum-=cost[i];\\n            i-=3;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int sum=0;\\n        for(int i=0;i<cost.size();i++)\\n            sum+=cost[i];\\n        int i=cost.size()-3;\\n        while(i>=0)\\n        {\\n            sum-=cost[i];\\n            i-=3;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964941,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        l = 0\\n        count_indices = 0\\n        totalcost = 0\\n\\n        cost = sorted(cost, reverse=True)\\n\\n        while l < len(cost):\\n            if count_indices == 2:\\n                l += 1\\n                count_indices = 0\\n            else:\\n                totalcost += cost[l]\\n                count_indices += 1\\n                l += 1\\n\\n        return totalcost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        l = 0\\n        count_indices = 0\\n        totalcost = 0\\n\\n        cost = sorted(cost, reverse=True)\\n\\n        while l < len(cost):\\n            if count_indices == 2:\\n                l += 1\\n                count_indices = 0\\n            else:\\n                totalcost += cost[l]\\n                count_indices += 1\\n                l += 1\\n\\n        return totalcost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963012,
                "title": "c-easy-solution-beats-100-takes-0ms",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity her, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n\\n       int size = cost.size();\\n       int total = 0;\\n\\n        // check if size is valid\\n        if(size <= 2) {\\n            for(int i=0; i<size; i++)\\n                total += cost[i];\\n        }\\n\\n        else {\\n\\n            // sorting the given vector cost\\n            sort(cost.begin(), cost.end());\\n\\n            //  initialize minimum to last element of cost vector\\n            int minimum = cost[size-1];\\n\\n            // iterate from the last index\\n            for(int i=size-1; i>=0; i--) {\\n                \\n                minimum = i-2; \\n                // to iterate only 2 times and calculate total cost\\n                while(i > minimum && i>=0) {\\n                    total += cost[i];\\n                    i--;\\n                }\\n                // point i to minimum\\n                i = minimum;\\n            }\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n\\n       int size = cost.size();\\n       int total = 0;\\n\\n        // check if size is valid\\n        if(size <= 2) {\\n            for(int i=0; i<size; i++)\\n                total += cost[i];\\n        }\\n\\n        else {\\n\\n            // sorting the given vector cost\\n            sort(cost.begin(), cost.end());\\n\\n            //  initialize minimum to last element of cost vector\\n            int minimum = cost[size-1];\\n\\n            // iterate from the last index\\n            for(int i=size-1; i>=0; i--) {\\n                \\n                minimum = i-2; \\n                // to iterate only 2 times and calculate total cost\\n                while(i > minimum && i>=0) {\\n                    total += cost[i];\\n                    i--;\\n                }\\n                // point i to minimum\\n                i = minimum;\\n            }\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956492,
                "title": "beginner-s-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are first sorting the array then we start calculating the minimum cost(sum) .So basically we start iterating the array from the back and add the last two element and skip the third we follaw this process int the whole arra and the sum we get is the answer. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        //Cost variable is used to skip the third element\\n        int cost=0;\\n        // Sum is used to find the sum of the two chocolates\\n        int sum=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            //This if statement sets the cost variable to 0 ans skips the element which is not added in the sum.\\n            if(cost==2){\\n                cost=0;\\n                continue;\\n            }\\n            sum+=nums[i];\\n            cost++;\\n        }\\n        return sum;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        //Cost variable is used to skip the third element\\n        int cost=0;\\n        // Sum is used to find the sum of the two chocolates\\n        int sum=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            //This if statement sets the cost variable to 0 ans skips the element which is not added in the sum.\\n            if(cost==2){\\n                cost=0;\\n                continue;\\n            }\\n            sum+=nums[i];\\n            cost++;\\n        }\\n        return sum;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950461,
                "title": "simple-logic-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        j = cost[::-1]\\n    \\n        out = 0\\n        while len(j)!= 0 :\\n            if len(j) // 3 != 0 :\\n                \\n                u= j[:2]\\n                print (u,j[2])\\n                out = out + sum(u)\\n                #out = out + j[2]\\n                j = j[3:]\\n                #print (j)\\n            if len(j) // 3 == 0 :\\n                out = out + sum(j)\\n                j=[]\\n        return (out)\\n                \\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort()\\n        j = cost[::-1]\\n    \\n        out = 0\\n        while len(j)!= 0 :\\n            if len(j) // 3 != 0 :\\n                \\n                u= j[:2]\\n                print (u,j[2])\\n                out = out + sum(u)\\n                #out = out + j[2]\\n                j = j[3:]\\n                #print (j)\\n            if len(j) // 3 == 0 :\\n                out = out + sum(j)\\n                j=[]\\n        return (out)\\n                \\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923061,
                "title": "python-fast-and-easy-to-understand-solution-3-lines",
                "content": "# Approach\\nSorting the array in descending order already provides a solution. We need to pay for the first and second candies and skip the third in all cases. Additionally, we should check whether we have the \\'second\\' candy to avoid going out of index (This also can be achieved using a try-except structure to avoid checks during every iteration).\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        n = len(cost)\\n        return sum(cost[i] + cost[i+1] if i != n-1 else cost[i] for i in range(0, n, 3))\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost.sort(reverse=True)\\n        n = len(cost)\\n        return sum(cost[i] + cost[i+1] if i != n-1 else cost[i] for i in range(0, n, 3))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910577,
                "title": "esy-to-understand-for-beginner-good-luck",
                "content": "# Intuition\\nFor the max value, we have to pay for it.\\nFor the second max value, we still have to pay for it.\\nFor the third max value, we can get it free one as bonus.\\nAnd continuely do this for the rest.\\n\\n\\n# Approach\\ni sorted array and i start count from the biggest value and  i use varaibl n for count the number of candies sold if (n ==2) than we dont count the next value \\n\\n# Complexity\\n- Time complexity:O(sort)\\n\\n# Code\\n```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost) ;\\n        int j= cost.length-1 ;\\n        int n= 0 ;\\n        int minimumCost=0 ;\\n        while(j>=0){\\n          if(n<2){\\n           minimumCost+=cost[j] ;\\n           n++ ;\\n          }else{\\n            n=0 ;\\n            \\n          }\\n          j-- ;\\n        }\\n        return minimumCost ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost) ;\\n        int j= cost.length-1 ;\\n        int n= 0 ;\\n        int minimumCost=0 ;\\n        while(j>=0){\\n          if(n<2){\\n           minimumCost+=cost[j] ;\\n           n++ ;\\n          }else{\\n            n=0 ;\\n            \\n          }\\n          j-- ;\\n        }\\n        return minimumCost ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899212,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int total = 0, j = 0;\\n\\n        for (int i = cost.length - 1; i >= 0; i--) {\\n            if (j == 2) {\\n                j = 0;\\n                continue;\\n            }\\n            total += cost[i];\\n            j++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int total = 0, j = 0;\\n\\n        for (int i = cost.length - 1; i >= 0; i--) {\\n            if (j == 2) {\\n                j = 0;\\n                continue;\\n            }\\n            total += cost[i];\\n            j++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895151,
                "title": "c-beats-100-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReverse the array and check add first two/one price(s) to ans and then skip to the third element\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.rbegin(),cost.rend());\\n        int ans=0;\\n        // edge cases\\n        if(cost.size()==1) ans+=cost[0];\\n        else if(cost.size()==2) ans+=cost[0]+cost[1];\\n\\n        for(int i=0;i<cost.size() && cost.size()>=3;i=i+3){\\n            if(i<=cost.size()-2)\\n                ans+=cost[i]+cost[i+1];\\n            else ans+=cost[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.rbegin(),cost.rend());\\n        int ans=0;\\n        // edge cases\\n        if(cost.size()==1) ans+=cost[0];\\n        else if(cost.size()==2) ans+=cost[0]+cost[1];\\n\\n        for(int i=0;i<cost.size() && cost.size()>=3;i=i+3){\\n            if(i<=cost.size()-2)\\n                ans+=cost[i]+cost[i+1];\\n            else ans+=cost[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892961,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_cost(cost: Vec<i32>) -> i32 {\\n        let mut c = cost;\\n        c.sort_by(|a,b| b.cmp(&a));\\n        let mut sum = 0;\\n        let mut i=0;\\n        while i<c.len() {\\n            if c.len() - i >= 2 {\\n                let m = c[i] + c[i+1];\\n                sum += m;\\n            }else{\\n                sum += c[i];\\n            }\\n            if i < c.len(){    \\n                i += 3;\\n            }else{\\n                sum += c[i+3..].to_vec().iter().fold(0, |a,b| a+b);\\n                break;\\n            }\\n        }\\n        sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_cost(cost: Vec<i32>) -> i32 {\\n        let mut c = cost;\\n        c.sort_by(|a,b| b.cmp(&a));\\n        let mut sum = 0;\\n        let mut i=0;\\n        while i<c.len() {\\n            if c.len() - i >= 2 {\\n                let m = c[i] + c[i+1];\\n                sum += m;\\n            }else{\\n                sum += c[i];\\n            }\\n            if i < c.len(){    \\n                i += 3;\\n            }else{\\n                sum += c[i+3..].to_vec().iter().fold(0, |a,b| a+b);\\n                break;\\n            }\\n        }\\n        sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891110,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        sort(cost.rbegin(), cost.rend());\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(i < n){\\n            if(i < n) ans += cost[i];\\n            i++;\\n\\n            if(i < n) ans += cost[i];\\n            i++;\\n\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        sort(cost.rbegin(), cost.rend());\\n\\n        int ans = 0;\\n        int i = 0;\\n\\n        while(i < n){\\n            if(i < n) ans += cost[i];\\n            i++;\\n\\n            if(i < n) ans += cost[i];\\n            i++;\\n\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888083,
                "title": "c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        sort(cost.begin(), cost.end());\\n\\n        int minCost = 0;\\n        int j = n - 1;\\n        while(j >= 0){\\n            if(j - 1 >= 0 && j - 2 >= 0)\\n                minCost = minCost + cost[j] + cost[j - 1];\\n            else if(j - 1 >= 0 && j - 2 < 0)\\n                minCost = minCost + cost[j] + cost[j - 1];\\n            else\\n                minCost = minCost + cost[j];\\n            \\n            j = j - 3;\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n        sort(cost.begin(), cost.end());\\n\\n        int minCost = 0;\\n        int j = n - 1;\\n        while(j >= 0){\\n            if(j - 1 >= 0 && j - 2 >= 0)\\n                minCost = minCost + cost[j] + cost[j - 1];\\n            else if(j - 1 >= 0 && j - 2 < 0)\\n                minCost = minCost + cost[j] + cost[j - 1];\\n            else\\n                minCost = minCost + cost[j];\\n            \\n            j = j - 3;\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887433,
                "title": "sorting-and-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEdge Case if i becomes 2, we have to add the 1st element of array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        if(n==1) return cost[0];\\n        if(n==2) return cost[0]+cost[1];\\n\\n        sort(cost.begin(), cost.end());\\n\\n        int j = n-1, i=j-1;\\n        int sum = 0;\\n\\n        while(i>=0){\\n            if(i==2){\\n                sum += cost[i]+cost[j];\\n                sum += cost[0];\\n                return sum;\\n            }\\n\\n            sum += cost[i]+cost[j];\\n            j = i-2;\\n            i = j-1;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        if(n==1) return cost[0];\\n        if(n==2) return cost[0]+cost[1];\\n\\n        sort(cost.begin(), cost.end());\\n\\n        int j = n-1, i=j-1;\\n        int sum = 0;\\n\\n        while(i>=0){\\n            if(i==2){\\n                sum += cost[i]+cost[j];\\n                sum += cost[0];\\n                return sum;\\n            }\\n\\n            sum += cost[i]+cost[j];\\n            j = i-2;\\n            i = j-1;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887314,
                "title": "short-and-simple-ever-beats-99-99",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function (cost) {\\n    cost.sort((a, b) => b - a)\\n    var timeOfPurchase = Math.floor(cost.length / 3)\\n    var totalCostToPurchase = 0\\n    for (let i = 0; i < timeOfPurchase; i++) {\\n        const temp = cost.slice((i * 3), ((i * 3) + 3));\\n        totalCostToPurchase += temp[0]\\n        totalCostToPurchase += temp[1]\\n    }\\n    cost.splice(timeOfPurchase * 3, cost.length).forEach(d => totalCostToPurchase += d)\\n    return totalCostToPurchase\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function (cost) {\\n    cost.sort((a, b) => b - a)\\n    var timeOfPurchase = Math.floor(cost.length / 3)\\n    var totalCostToPurchase = 0\\n    for (let i = 0; i < timeOfPurchase; i++) {\\n        const temp = cost.slice((i * 3), ((i * 3) + 3));\\n        totalCostToPurchase += temp[0]\\n        totalCostToPurchase += temp[1]\\n    }\\n    cost.splice(timeOfPurchase * 3, cost.length).forEach(d => totalCostToPurchase += d)\\n    return totalCostToPurchase\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885634,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int high=cost.length-1,amount=0;\\n        while(high>=0){\\n            amount+=cost[high];\\n            if(high-1>=0)\\n            amount+=cost[high-1];\\n            high=high-3;\\n        }\\n        return amount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int high=cost.length-1,amount=0;\\n        while(high>=0){\\n            amount+=cost[high];\\n            if(high-1>=0)\\n            amount+=cost[high-1];\\n            high=high-3;\\n        }\\n        return amount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885423,
                "title": "runtime-57ms-memory-42-8-mb-simple-forloop-methord",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    let arr=cost.sort((a,b)=>b-a)\\n    let c=0\\n    let k=0\\n    for(let i=0;i<arr.length;i++){\\n        if(k<2){\\n            c=c+arr[i]\\n            k++\\n        }\\n        else {\\n            k=0\\n        }\\n    }\\n    return c\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minimumCost = function(cost) {\\n    let arr=cost.sort((a,b)=>b-a)\\n    let c=0\\n    let k=0\\n    for(let i=0;i<arr.length;i++){\\n        if(k<2){\\n            c=c+arr[i]\\n            k++\\n        }\\n        else {\\n            k=0\\n        }\\n    }\\n    return c\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885045,
                "title": "just-a-simple-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int amount = 0 , bought = 0;\\n        for(int i = cost.size() - 1 ; i >= 0 ; i--)\\n        {\\n            amount += cost[i];\\n            bought++;\\n            if(bought == 3)\\n            {\\n                bought = 0;\\n                amount -= cost[i];\\n            }\\n        }        \\n        return amount;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int amount = 0 , bought = 0;\\n        for(int i = cost.size() - 1 ; i >= 0 ; i--)\\n        {\\n            amount += cost[i];\\n            bought++;\\n            if(bought == 3)\\n            {\\n                bought = 0;\\n                amount -= cost[i];\\n            }\\n        }        \\n        return amount;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884972,
                "title": "c-beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n = cost.size();\\n        int ans = 0;\\n        if(cost.size()==1)return cost[0];\\n        int i = n-1;\\n        for(;i>0;i-=2){\\n            ans+=cost[i]+cost[i-1];\\n            i--;\\n        }\\n        if(i==0)ans+=cost[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n = cost.size();\\n        int ans = 0;\\n        if(cost.size()==1)return cost[0];\\n        int i = n-1;\\n        for(;i>0;i-=2){\\n            ans+=cost[i]+cost[i-1];\\n            i--;\\n        }\\n        if(i==0)ans+=cost[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884902,
                "title": "simple-c-soln-using-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n=cost.size();\\n        int ans=0;\\n        if(n==1)\\n        {\\n            return cost[0];\\n        }\\n        else if(n==2)\\n        {\\n            return cost[0]+cost[1];\\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if((i-1)>=0)\\n            {\\n            ans+=cost[i]+cost[i-1];\\n            i--;\\n            i--;\\n            }\\n            else\\n            {\\n                ans+=cost[i];\\n            }\\n\\n        }\\nreturn ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int n=cost.size();\\n        int ans=0;\\n        if(n==1)\\n        {\\n            return cost[0];\\n        }\\n        else if(n==2)\\n        {\\n            return cost[0]+cost[1];\\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if((i-1)>=0)\\n            {\\n            ans+=cost[i]+cost[i-1];\\n            i--;\\n            i--;\\n            }\\n            else\\n            {\\n                ans+=cost[i];\\n            }\\n\\n        }\\nreturn ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883317,
                "title": "easy-c-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        \\n        if(cost.size()==1)\\n            return cost[0];\\n        \\n        if(cost.size()==2)\\n            return cost[0]+cost[1];\\n        \\n        sort(cost.begin(),cost.end(),greater<int>());\\n        \\n        int a=0,c=1;\\n        \\n        for(int i=0;i<cost.size();i++)\\n        {\\n            a+=cost[i];\\n\\n            if(c==2)\\n            {\\n                i+=1;\\n                c=0;\\n            }\\n            c++;\\n        }\\n            \\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        \\n        if(cost.size()==1)\\n            return cost[0];\\n        \\n        if(cost.size()==2)\\n            return cost[0]+cost[1];\\n        \\n        sort(cost.begin(),cost.end(),greater<int>());\\n        \\n        int a=0,c=1;\\n        \\n        for(int i=0;i<cost.size();i++)\\n        {\\n            a+=cost[i];\\n\\n            if(c==2)\\n            {\\n                i+=1;\\n                c=0;\\n            }\\n            c++;\\n        }\\n            \\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877893,
                "title": "java-merge-sort-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(n * log(n))*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int n = cost.length, sum = 0, count = 0;\\n        sort(cost, 0, n-1);\\n\\n        for(int i = n-1; i >= 0; i--){\\n            if(count == 2){\\n                count = 0;\\n            }else{\\n                count ++;\\n                sum += cost[i];\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n     void sort(int arr[], int l, int r){\\n        if (l < r) {\\n            int m = (l + r) / 2;\\n            sort(arr, l, m);\\n            sort(arr, m + 1, r);\\n            merge(arr, l, m, r);\\n        }\\n    }\\n\\n    void merge(int arr[], int l, int m, int r){\\n        // Find sizes of two subarrays to be merged\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n  \\n        // Create temp arrays\\n        int L[] = new int[n1];\\n        int R[] = new int[n2];\\n  \\n        // Copy data to temp arrays\\n        for (int i = 0; i < n1; ++i)\\n            L[i] = arr[l + i];\\n        for (int j = 0; j < n2; ++j)\\n            R[j] = arr[m + 1 + j];\\n  \\n        // Merge the temp arrays\\n        // Initial indexes of first and second subarrays\\n        int i = 0, j = 0;\\n  \\n        // Initial index of merged subarray array\\n        int k = l;\\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j]) {\\n                arr[k] = L[i];\\n                i++;\\n            }\\n            else {\\n                arr[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n  \\n        // Copy remaining elements of L[] if any\\n        while (i < n1) {\\n            arr[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n  \\n        // Copy remaining elements of R[] if any\\n        while (j < n2) {\\n            arr[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int n = cost.length, sum = 0, count = 0;\\n        sort(cost, 0, n-1);\\n\\n        for(int i = n-1; i >= 0; i--){\\n            if(count == 2){\\n                count = 0;\\n            }else{\\n                count ++;\\n                sum += cost[i];\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n     void sort(int arr[], int l, int r){\\n        if (l < r) {\\n            int m = (l + r) / 2;\\n            sort(arr, l, m);\\n            sort(arr, m + 1, r);\\n            merge(arr, l, m, r);\\n        }\\n    }\\n\\n    void merge(int arr[], int l, int m, int r){\\n        // Find sizes of two subarrays to be merged\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n  \\n        // Create temp arrays\\n        int L[] = new int[n1];\\n        int R[] = new int[n2];\\n  \\n        // Copy data to temp arrays\\n        for (int i = 0; i < n1; ++i)\\n            L[i] = arr[l + i];\\n        for (int j = 0; j < n2; ++j)\\n            R[j] = arr[m + 1 + j];\\n  \\n        // Merge the temp arrays\\n        // Initial indexes of first and second subarrays\\n        int i = 0, j = 0;\\n  \\n        // Initial index of merged subarray array\\n        int k = l;\\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j]) {\\n                arr[k] = L[i];\\n                i++;\\n            }\\n            else {\\n                arr[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n  \\n        // Copy remaining elements of L[] if any\\n        while (i < n1) {\\n            arr[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n  \\n        // Copy remaining elements of R[] if any\\n        while (j < n2) {\\n            arr[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860579,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/08ef800e-5a18-4e35-8a3b-fc1bc9fa60f4_1691114029.6717322.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        int total = 0, k=1;\\n        for(int i=0; i<cost.size(); i++){\\n            if(k<3){\\n                total+=cost[i];\\n                k++;\\n            }\\n            else\\n                k=1;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int>());\\n        int total = 0, k=1;\\n        for(int i=0; i<cost.size(); i++){\\n            if(k<3){\\n                total+=cost[i];\\n                k++;\\n            }\\n            else\\n                k=1;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859951,
                "title": "meh",
                "content": "# Approach\\nSame as many other solutions, but increment the loop index by 1 + (i % 3 == 1) instead of checking (i % 3 == 2) inside the loop body.\\n\\nReally the same result, compiler output might be slightly different with less labels/jumps but not much difference besides that.\\n\\nhttps://godbolt.org/z/avxMMsx7c\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        std::sort(cost.begin(), cost.end(), std::greater<int>());\\n\\n        int minCost = cost[0];\\n        int n = cost.size();\\n        for(int i = 1; i < n; i += 1 + (i % 3 == 1))\\n        {\\n          minCost += cost[i];\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        std::sort(cost.begin(), cost.end(), std::greater<int>());\\n\\n        int minCost = cost[0];\\n        int n = cost.size();\\n        for(int i = 1; i < n; i += 1 + (i % 3 == 1))\\n        {\\n          minCost += cost[i];\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853505,
                "title": "minimum-cost-of-buying-candies-with-discount",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        if(cost.length==1)\\n        return cost[0];\\n        if(cost.length<3)\\n        return cost[0]+cost[1];\\n        int sum = 0;\\n        Arrays.sort(cost);\\n        for(int i=0;i<cost.length;i++)\\n        {\\n            System.out.print(cost[i]+\" \");\\n        }\\n        int i;\\n        for(i=cost.length-1;i>=2;i=i-3)\\n        {\\n            sum=sum+cost[i]+cost[i-1];\\n        }\\n        if(i>=0&&i<2)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                sum = sum+cost[j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        if(cost.length==1)\\n        return cost[0];\\n        if(cost.length<3)\\n        return cost[0]+cost[1];\\n        int sum = 0;\\n        Arrays.sort(cost);\\n        for(int i=0;i<cost.length;i++)\\n        {\\n            System.out.print(cost[i]+\" \");\\n        }\\n        int i;\\n        for(i=cost.length-1;i>=2;i=i-3)\\n        {\\n            sum=sum+cost[i]+cost[i-1];\\n        }\\n        if(i>=0&&i<2)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                sum = sum+cost[j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850035,
                "title": "very-basic-java-soln-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int c=0;\\n        for(int i=cost.length-1;i>=0;i-=3){\\n            c+=cost[i];\\n            if(i!=0)\\n                c+=cost[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        Arrays.sort(cost);\\n        int c=0;\\n        for(int i=cost.length-1;i>=0;i-=3){\\n            c+=cost[i];\\n            if(i!=0)\\n                c+=cost[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844775,
                "title": "beats-80-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumCost(self, cost):\\n        cost.sort()\\n        a=[]\\n        c=0\\n        i=len(cost)-1\\n        while i>=0:\\n            if c!=2:\\n                a.append(cost[i])\\n                i-=1\\n                c+=1\\n            else:\\n                i-=1\\n                c=0\\n        return sum(a)\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumCost(self, cost):\\n        cost.sort()\\n        a=[]\\n        c=0\\n        i=len(cost)-1\\n        while i>=0:\\n            if c!=2:\\n                a.append(cost[i])\\n                i-=1\\n                c+=1\\n            else:\\n                i-=1\\n                c=0\\n        return sum(a)\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843542,
                "title": "c-easy-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size() == 1)\\n        return cost.front();\\n\\n        if(cost.size() == 2)\\n        return cost.front() + cost.back();\\n\\n        sort(cost.begin(), cost.end());\\n\\n        int res = 0;\\n        for(int i = cost.size() - 1; i >= 0; i-=3)\\n        {\\n            if(i < 1)\\n            res += cost[i];\\n            else\\n            res += cost[i] + cost[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size() == 1)\\n        return cost.front();\\n\\n        if(cost.size() == 2)\\n        return cost.front() + cost.back();\\n\\n        sort(cost.begin(), cost.end());\\n\\n        int res = 0;\\n        for(int i = cost.size() - 1; i >= 0; i-=3)\\n        {\\n            if(i < 1)\\n            res += cost[i];\\n            else\\n            res += cost[i] + cost[i-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832535,
                "title": "c-optimal-100-efficient-in-time-complexity",
                "content": "```\\nint minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int i=cost.size()-1;\\n        int price=0;\\n        while(i>=0){\\n            if(i!=0){\\n            price+=cost[i]+cost[i-1];\\n            i=i-3;    \\n            }\\n            else{\\n                price+=cost[i--];\\n            }\\n            \\n            \\n        }\\n        return price;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int i=cost.size()-1;\\n        int price=0;\\n        while(i>=0){\\n            if(i!=0){\\n            price+=cost[i]+cost[i-1];\\n            i=i-3;    \\n            }\\n            else{\\n                price+=cost[i--];\\n            }\\n            \\n            \\n        }\\n        return price;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832523,
                "title": "c-sol",
                "content": "```\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int i=cost.size()-1;\\n        int price=0;\\n        if(i==0){\\n            return cost[0];\\n        }\\n        while(i>=0){\\n            if(i!=0){\\n            price+=cost[i]+cost[i-1];\\n            i=i-3;    \\n            }\\n            else{\\n                price+=cost[i--];\\n            }\\n            \\n            \\n        }\\n        return price;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int i=cost.size()-1;\\n        int price=0;\\n        if(i==0){\\n            return cost[0];\\n        }\\n        while(i>=0){\\n            if(i!=0){\\n            price+=cost[i]+cost[i-1];\\n            i=i-3;    \\n            }\\n            else{\\n                price+=cost[i--];\\n            }\\n            \\n            \\n        }\\n        return price;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832292,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size()==1){\\n            return cost[0];\\n        }\\n        sort(cost.begin(),cost.end());\\n        int c = 0;\\n        for(int i=cost.size()-1;i>=0;i-=3){\\n            if(i-1>=0){\\n                c+=cost[i]+cost[i-1];\\n            }else{\\n                c+=cost[i];\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size()==1){\\n            return cost[0];\\n        }\\n        sort(cost.begin(),cost.end());\\n        int c = 0;\\n        for(int i=cost.size()-1;i>=0;i-=3){\\n            if(i-1>=0){\\n                c+=cost[i]+cost[i-1];\\n            }else{\\n                c+=cost[i];\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829598,
                "title": "simple-solution",
                "content": "\\n\\n# Code:1\\n```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int sum=0,len=cost.length;\\n        Arrays.sort(cost);\\n        if(len>1){\\n            for(int i=len-1;i>0;i--){\\n                sum=sum+cost[i--]+cost[i--];\\n                if(i==1)\\n                    sum=sum+cost[0];\\n            }\\n        }\\n        else{\\n            sum=cost[0];\\n        }\\n    return sum;\\n    }\\n}\\n```\\n# Code:2\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int sum=0,len=cost.length;\\n        Arrays.sort(cost);\\n        for(int i=len-1;i>=0;i--){\\n            if(i==0){\\n                sum=sum+cost[0];\\n                break;\\n            }\\n            else{\\n                sum=sum+cost[i--]+cost[i--];  \\n            }              \\n        }\\n    return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumCost(int[] cost) {\\n        int sum=0,len=cost.length;\\n        Arrays.sort(cost);\\n        if(len>1){\\n            for(int i=len-1;i>0;i--){\\n                sum=sum+cost[i--]+cost[i--];\\n                if(i==1)\\n                    sum=sum+cost[0];\\n            }\\n        }\\n        else{\\n            sum=cost[0];\\n        }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825039,
                "title": "sorted-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int> ());\\n        int minCost = 0, twos = 0;\\n\\n        for(auto c: cost) {\\n            if(twos == 2) \\n                twos = 0;\\n            else\\n                minCost += c, twos++;\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end(), greater<int> ());\\n        int minCost = 0, twos = 0;\\n\\n        for(auto c: cost) {\\n            if(twos == 2) \\n                twos = 0;\\n            else\\n                minCost += c, twos++;\\n        }\\n\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824634,
                "title": "greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n=cost.size();\\n        sort(cost.begin(),cost.end());\\n        int i=n-1;\\n        int sum=0;\\n        int count=1;\\n         while(i>=0)\\n         {\\n             if( count>=3 && count%3==0)\\n             {\\n                \\n                  i--;\\n                  count++;\\n             }\\n             else\\n             {\\n                  sum+=cost[i];\\n                  count++;\\n                  i--;\\n             }\\n\\n\\n         }\\n         return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        int n=cost.size();\\n        sort(cost.begin(),cost.end());\\n        int i=n-1;\\n        int sum=0;\\n        int count=1;\\n         while(i>=0)\\n         {\\n             if( count>=3 && count%3==0)\\n             {\\n                \\n                  i--;\\n                  count++;\\n             }\\n             else\\n             {\\n                  sum+=cost[i];\\n                  count++;\\n                  i--;\\n             }\\n\\n\\n         }\\n         return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824170,
                "title": "easy-method-c-greedy-method-beats-94-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst sort the array/vector\\nmake two variables money and counter\\nrun the loop from last index to 0\\nfor every 3rd candy dont add the cost to money variable\\ndont forget to increment counter everytime loop runs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int money=0;\\n        int counter=0;\\n        for(int i=cost.size()-1;i>=0;i--){\\n            counter++;\\n            if(counter%3==0){continue;}\\n            else{money+=cost[i];}\\n        }\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(),cost.end());\\n        int money=0;\\n        int counter=0;\\n        for(int i=cost.size()-1;i>=0;i--){\\n            counter++;\\n            if(counter%3==0){continue;}\\n            else{money+=cost[i];}\\n        }\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815471,
                "title": "one-and-only-solution-full-too-unique-very-attractive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end());\\n        reverse(cost.begin(), cost.end());\\n\\n        for(int i=0; i<cost.size(); i++){\\n            cout<<cost[i]<<\" \";\\n        }\\n        cout<<endl;\\n\\n        int visited = 0;\\n        int ans=0;\\n        int i = 1;\\n        for(i; i<cost.size()-1; i=i+2){\\n            int candie1 = cost[i-1];\\n            visited++;\\n            int candie2 = cost[i];\\n            visited++;\\n            ans+=candie1;\\n            ans+=candie2;\\n            if(cost[i+1] <= min(candie1, candie2)){\\n                cout<<\"Got \"<<cost[i+1]<<\" for free form index \"<<i+2<<endl;\\n                visited++;  \\n                i++;\\n            }\\n        }\\n        i--;\\n        while(visited != cost.size()){\\n            ans+= cost[i];\\n            i++;\\n            visited++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        sort(cost.begin(), cost.end());\\n        reverse(cost.begin(), cost.end());\\n\\n        for(int i=0; i<cost.size(); i++){\\n            cout<<cost[i]<<\" \";\\n        }\\n        cout<<endl;\\n\\n        int visited = 0;\\n        int ans=0;\\n        int i = 1;\\n        for(i; i<cost.size()-1; i=i+2){\\n            int candie1 = cost[i-1];\\n            visited++;\\n            int candie2 = cost[i];\\n            visited++;\\n            ans+=candie1;\\n            ans+=candie2;\\n            if(cost[i+1] <= min(candie1, candie2)){\\n                cout<<\"Got \"<<cost[i+1]<<\" for free form index \"<<i+2<<endl;\\n                visited++;  \\n                i++;\\n            }\\n        }\\n        i--;\\n        while(visited != cost.size()){\\n            ans+= cost[i];\\n            i++;\\n            visited++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3803981,
                "title": "easy-c-solution-with-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size()<3){\\n           return  accumulate(cost.begin(), cost.end(), 0);\\n        }\\n\\n        sort(cost.begin(),cost.end());\\n        int j=1;\\n        int sum=0;\\n        for(int i=cost.size()-1;i>=0;i--){\\n             if(j%3==0){\\n                 j++;\\n                continue;\\n            }\\n            sum+=cost[i];\\n            j++;\\n           \\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n        if(cost.size()<3){\\n           return  accumulate(cost.begin(), cost.end(), 0);\\n        }\\n\\n        sort(cost.begin(),cost.end());\\n        int j=1;\\n        int sum=0;\\n        for(int i=cost.size()-1;i>=0;i--){\\n             if(j%3==0){\\n                 j++;\\n                continue;\\n            }\\n            sum+=cost[i];\\n            j++;\\n           \\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782115,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 63 ms, faster than 43.98% of Python3 online submissions for Minimum Cost of Buying Candies With Discount.\\n# Memory Usage: 16.2 MB, less than 73.95% of Python3 online submissions for Minimum Cost of Buying Candies With Discount.\\n\\n\\tclass Solution:\\n\\t\\tdef minimumCost(self, cost: List[int]) -> int:\\n\\n\\t\\t\\tif len(cost) < 3:\\n\\t\\t\\t\\treturn sum(cost)\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tcost = sorted(cost)[::-1]\\n\\n\\t\\t\\tindex = 0\\n\\n\\t\\t\\twhile index < len(cost):\\n\\n\\t\\t\\t\\tif index < len(cost):\\n\\t\\t\\t\\t\\tresult = result + cost[index]\\n\\n\\t\\t\\t\\tif (index + 1) < len(cost):\\n\\t\\t\\t\\t\\tresult = result + cost[index + 1]\\n\\n\\t\\t\\t\\tindex = index + 3\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 63 ms, faster than 43.98% of Python3 online submissions for Minimum Cost of Buying Candies With Discount.\\n# Memory Usage: 16.2 MB, less than 73.95% of Python3 online submissions for Minimum Cost of Buying Candies With Discount.\\n\\n\\tclass Solution:\\n\\t\\tdef minimumCost(self, cost: List[int]) -> int:\\n\\n\\t\\t\\tif len(cost) < 3:\\n\\t\\t\\t\\treturn sum(cost)\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tcost = sorted(cost)[::-1]\\n\\n\\t\\t\\tindex = 0\\n\\n\\t\\t\\twhile index < len(cost):\\n\\n\\t\\t\\t\\tif index < len(cost):\\n\\t\\t\\t\\t\\tresult = result + cost[index]\\n\\n\\t\\t\\t\\tif (index + 1) < len(cost):\\n\\t\\t\\t\\t\\tresult = result + cost[index + 1]\\n\\n\\t\\t\\t\\tindex = index + 3\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3781366,
                "title": "using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n       int n = cost.size();\\n       int sum = 0;\\n       sort(cost.begin(),cost.end());\\n       int i = n-1;\\n       while(i>=0){\\n           if(n<3){\\n            break;\\n           }\\n           else {\\n               sum += cost[i]+cost[i-1];\\n               i=i-3;\\n               n = n-3;\\n           }\\n       }\\n       if(n<3){\\n           for(int i=0;i<n;i++){\\n               sum += cost[i];\\n            }\\n       }\\n       return sum;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>& cost) {\\n       int n = cost.size();\\n       int sum = 0;\\n       sort(cost.begin(),cost.end());\\n       int i = n-1;\\n       while(i>=0){\\n           if(n<3){\\n            break;\\n           }\\n           else {\\n               sum += cost[i]+cost[i-1];\\n               i=i-3;\\n               n = n-3;\\n           }\\n       }\\n       if(n<3){\\n           for(int i=0;i<n;i++){\\n               sum += cost[i];\\n            }\\n       }\\n       return sum;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767306,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>&c){\\n        sort(c.begin(),c.end(),greater<>());\\n        int sum=0 , co=2;\\n        for(int i=0; i<c.size(); i++){\\n            if(co==0){\\n                co=2;\\n                continue;\\n            }\\n            else{\\n                co--;\\n                sum+=c[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumCost(vector<int>&c){\\n        sort(c.begin(),c.end(),greater<>());\\n        int sum=0 , co=2;\\n        for(int i=0; i<c.size(); i++){\\n            if(co==0){\\n                co=2;\\n                continue;\\n            }\\n            else{\\n                co--;\\n                sum+=c[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576820,
                "content": [
                    {
                        "username": "saivamsi2803",
                        "content": "cost=sorted(cost)[::-1]\\n return sum(cost)-sum(cost[2::3])"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you wonder how to solve this problem for O(N) runtime without sort function, you could have a look at [this](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3293839/python-o-n-runtime-solution-counting-sort/) solution."
                    },
                    {
                        "username": "c4tdog",
                        "content": "`a.sort()`\\n`var res = 0`\\n`for (i in 1..a.size) {`\\n`res += if (i % 3 == 0) 0 else a[a.size - i]`\\n`}`\\n`return res`"
                    },
                    {
                        "username": "kerku",
                        "content": "Example 2:\\nInput: cost = [6,5,7,9,2,2]\\nOutput: 23\\n\\nWhat if in the first step we buy candies for 7 + 2 and take a candy 9 for free, as it equals to the total sum of two candies, then we take candies for 5 and 2 and get the last one 6 for free. So in this case total min sum equals to 16, but not 23. Is it a valid scenario? \\n"
                    },
                    {
                        "username": "n0nchalant",
                        "content": "no read the question again the free candy should cost less than or equal to the cost of cheaper candy amongst the two you bought"
                    },
                    {
                        "username": "speedyy",
                        "content": "I tried to do with counting sort by fixing the loop iteration which logically makes it O(1) time and space complexity.\n[See](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3538087/from-o-nlogn-to-o-1-with-the-most-beautiful-explanation/) this if you want. I also added some explanation if any one of you encountering any problem with the normal approach."
                    }
                ]
            },
            {
                "id": 1831708,
                "content": [
                    {
                        "username": "saivamsi2803",
                        "content": "cost=sorted(cost)[::-1]\\n return sum(cost)-sum(cost[2::3])"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you wonder how to solve this problem for O(N) runtime without sort function, you could have a look at [this](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3293839/python-o-n-runtime-solution-counting-sort/) solution."
                    },
                    {
                        "username": "c4tdog",
                        "content": "`a.sort()`\\n`var res = 0`\\n`for (i in 1..a.size) {`\\n`res += if (i % 3 == 0) 0 else a[a.size - i]`\\n`}`\\n`return res`"
                    },
                    {
                        "username": "kerku",
                        "content": "Example 2:\\nInput: cost = [6,5,7,9,2,2]\\nOutput: 23\\n\\nWhat if in the first step we buy candies for 7 + 2 and take a candy 9 for free, as it equals to the total sum of two candies, then we take candies for 5 and 2 and get the last one 6 for free. So in this case total min sum equals to 16, but not 23. Is it a valid scenario? \\n"
                    },
                    {
                        "username": "n0nchalant",
                        "content": "no read the question again the free candy should cost less than or equal to the cost of cheaper candy amongst the two you bought"
                    },
                    {
                        "username": "speedyy",
                        "content": "I tried to do with counting sort by fixing the loop iteration which logically makes it O(1) time and space complexity.\n[See](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3538087/from-o-nlogn-to-o-1-with-the-most-beautiful-explanation/) this if you want. I also added some explanation if any one of you encountering any problem with the normal approach."
                    }
                ]
            },
            {
                "id": 1576317,
                "content": [
                    {
                        "username": "saivamsi2803",
                        "content": "cost=sorted(cost)[::-1]\\n return sum(cost)-sum(cost[2::3])"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you wonder how to solve this problem for O(N) runtime without sort function, you could have a look at [this](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3293839/python-o-n-runtime-solution-counting-sort/) solution."
                    },
                    {
                        "username": "c4tdog",
                        "content": "`a.sort()`\\n`var res = 0`\\n`for (i in 1..a.size) {`\\n`res += if (i % 3 == 0) 0 else a[a.size - i]`\\n`}`\\n`return res`"
                    },
                    {
                        "username": "kerku",
                        "content": "Example 2:\\nInput: cost = [6,5,7,9,2,2]\\nOutput: 23\\n\\nWhat if in the first step we buy candies for 7 + 2 and take a candy 9 for free, as it equals to the total sum of two candies, then we take candies for 5 and 2 and get the last one 6 for free. So in this case total min sum equals to 16, but not 23. Is it a valid scenario? \\n"
                    },
                    {
                        "username": "n0nchalant",
                        "content": "no read the question again the free candy should cost less than or equal to the cost of cheaper candy amongst the two you bought"
                    },
                    {
                        "username": "speedyy",
                        "content": "I tried to do with counting sort by fixing the loop iteration which logically makes it O(1) time and space complexity.\n[See](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3538087/from-o-nlogn-to-o-1-with-the-most-beautiful-explanation/) this if you want. I also added some explanation if any one of you encountering any problem with the normal approach."
                    }
                ]
            },
            {
                "id": 1945220,
                "content": [
                    {
                        "username": "saivamsi2803",
                        "content": "cost=sorted(cost)[::-1]\\n return sum(cost)-sum(cost[2::3])"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you wonder how to solve this problem for O(N) runtime without sort function, you could have a look at [this](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3293839/python-o-n-runtime-solution-counting-sort/) solution."
                    },
                    {
                        "username": "c4tdog",
                        "content": "`a.sort()`\\n`var res = 0`\\n`for (i in 1..a.size) {`\\n`res += if (i % 3 == 0) 0 else a[a.size - i]`\\n`}`\\n`return res`"
                    },
                    {
                        "username": "kerku",
                        "content": "Example 2:\\nInput: cost = [6,5,7,9,2,2]\\nOutput: 23\\n\\nWhat if in the first step we buy candies for 7 + 2 and take a candy 9 for free, as it equals to the total sum of two candies, then we take candies for 5 and 2 and get the last one 6 for free. So in this case total min sum equals to 16, but not 23. Is it a valid scenario? \\n"
                    },
                    {
                        "username": "n0nchalant",
                        "content": "no read the question again the free candy should cost less than or equal to the cost of cheaper candy amongst the two you bought"
                    },
                    {
                        "username": "speedyy",
                        "content": "I tried to do with counting sort by fixing the loop iteration which logically makes it O(1) time and space complexity.\n[See](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3538087/from-o-nlogn-to-o-1-with-the-most-beautiful-explanation/) this if you want. I also added some explanation if any one of you encountering any problem with the normal approach."
                    }
                ]
            },
            {
                "id": 1898351,
                "content": [
                    {
                        "username": "saivamsi2803",
                        "content": "cost=sorted(cost)[::-1]\\n return sum(cost)-sum(cost[2::3])"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you wonder how to solve this problem for O(N) runtime without sort function, you could have a look at [this](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3293839/python-o-n-runtime-solution-counting-sort/) solution."
                    },
                    {
                        "username": "c4tdog",
                        "content": "`a.sort()`\\n`var res = 0`\\n`for (i in 1..a.size) {`\\n`res += if (i % 3 == 0) 0 else a[a.size - i]`\\n`}`\\n`return res`"
                    },
                    {
                        "username": "kerku",
                        "content": "Example 2:\\nInput: cost = [6,5,7,9,2,2]\\nOutput: 23\\n\\nWhat if in the first step we buy candies for 7 + 2 and take a candy 9 for free, as it equals to the total sum of two candies, then we take candies for 5 and 2 and get the last one 6 for free. So in this case total min sum equals to 16, but not 23. Is it a valid scenario? \\n"
                    },
                    {
                        "username": "n0nchalant",
                        "content": "no read the question again the free candy should cost less than or equal to the cost of cheaper candy amongst the two you bought"
                    },
                    {
                        "username": "speedyy",
                        "content": "I tried to do with counting sort by fixing the loop iteration which logically makes it O(1) time and space complexity.\n[See](https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/solutions/3538087/from-o-nlogn-to-o-1-with-the-most-beautiful-explanation/) this if you want. I also added some explanation if any one of you encountering any problem with the normal approach."
                    }
                ]
            }
        ]
    }
]