[
    {
        "title": "Gray Code",
        "question_content": "An n-bit gray code sequence is a sequence of 2n integers where:\n\n\tEvery integer is in the inclusive range [0, 2n - 1],\n\tThe first integer is 0,\n\tAn integer appears no more than once in the sequence,\n\tThe binary representation of every pair of adjacent integers differs by exactly one bit, and\n\tThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\nExample 2:\n\nInput: n = 1\nOutput: [0,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 16",
        "solutions": [
            {
                "id": 29891,
                "title": "share-my-solution",
                "content": "My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2. \\n00,01,11,10 -> (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness.\\nCode is simple:\\n\\n----------\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> rs=new ArrayList<Integer>();\\n        rs.add(0);\\n        for(int i=0;i<n;i++){\\n            int size=rs.size();\\n            for(int k=size-1;k>=0;k--)\\n                rs.add(rs.get(k) | 1<<i);\\n        }\\n        return rs;\\n    }",
                "solutionTags": [],
                "code": "My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2. \\n00,01,11,10 -> (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness.\\nCode is simple:\\n\\n----------\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> rs=new ArrayList<Integer>();\\n        rs.add(0);\\n        for(int i=0;i<n;i++){\\n            int size=rs.size();\\n            for(int k=size-1;k>=0;k--)\\n                rs.add(rs.get(k) | 1<<i);\\n        }\\n        return rs;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29881,
                "title": "an-accepted-three-line-solution-in-java",
                "content": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\\n        return result;\\n    }\\n\\nThe idea is simple. G(i) = i^ (i/2).",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\\n        return result;\\n    }\\n\\nThe idea is simple. G(i) = i^ (i/2).",
                "codeTag": "Unknown"
            },
            {
                "id": 29893,
                "title": "one-liner-python-solution-with-demo-in-comments",
                "content": "All you need is a bit of careful thought.\\n\\nBtw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. \\n\\nEven if you do not solve the problem finally, the interviewer at least get to know what you're thinking. \\n\\nAnd if you don't get the problem right, he/she will have a chance to correct you.\\n\\n    class Solution:\\n        # @return a list of integers\\n        '''\\n        from up to down, then left to right\\n        \\n        0   1   11  110\\n                10  111\\n                    101\\n                    100\\n                    \\n        start:      [0]\\n        i = 0:      [0, 1]\\n        i = 1:      [0, 1, 3, 2]\\n        i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\\n        '''\\n        def grayCode(self, n):\\n            results = [0]\\n            for i in range(n):\\n                results += [x + pow(2, i) for x in reversed(results)]\\n            return results",
                "solutionTags": [],
                "code": "All you need is a bit of careful thought.\\n\\nBtw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. \\n\\nEven if you do not solve the problem finally, the interviewer at least get to know what you're thinking. \\n\\nAnd if you don't get the problem right, he/she will have a chance to correct you.\\n\\n    class Solution:\\n        # @return a list of integers\\n        '''\\n        from up to down, then left to right\\n        \\n        0   1   11  110\\n                10  111\\n                    101\\n                    100\\n                    \\n        start:      [0]\\n        i = 0:      [0, 1]\\n        i = 1:      [0, 1, 3, 2]\\n        i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\\n        '''\\n        def grayCode(self, n):\\n            results = [0]\\n            for i in range(n):\\n                results += [x + pow(2, i) for x in reversed(results)]\\n            return results",
                "codeTag": "Java"
            },
            {
                "id": 29880,
                "title": "backtracking-c-solution",
                "content": "    class Solution {\\n        void utils(bitset<32>& bits, vector<int>& result, int k){\\n            if (k==0) {\\n                result.push_back(bits.to_ulong());\\n            }\\n            else {\\n                utils(bits, result, k-1);\\n                bits.flip(k-1);\\n                utils(bits, result, k-1);\\n            }\\n        }\\n    public:\\n        vector<int> grayCode(int n) {\\n            bitset<32> bits;\\n            vector<int> result;\\n            utils(bits, result, n);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        void utils(bitset<32>& bits, vector<int>& result, int k){\\n            if (k==0) {\\n                result.push_back(bits.to_ulong());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30028,
                "title": "4-lines-c-code",
                "content": "You can also view more solution on [Github](https://github.com/flexwang/CodeTest)\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> ans(1<<n);\\n            for (int i=0; i<(1<<n); i++) \\n                ans[i] = i^(i>>1);\\n            return ans;\\n        }\\n    };\\n\\nI try to give a simple proof here. Let's denote i^(i>>1) as f(i). To proof f(i) is the ith gray code, we only need to prove the following statements:\\n\\n 1. f(0) = 0\\n 2. (i) and f(i+1) only differs in one digit\\n 3. f(i) is bijective, e.g. f(i) = f(j) if and only if i = j.\\n\\nThe first one is obvious. \\n\\nFor the second , f(i) ^ f(i+1) = i^(i>>1)^(i+1)^((i+1)>>1) = (i^(i+1)) ^ ((i^(i+1)) >> 1). Let's denote g(i) = i^(i+1), g(i) has the form of 0000111...111. So f(i) ^ f(i+1) = g(i) ^ g(i)>>1 = 00001000...000.\\n\\nThe third part can be proved alike.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> ans(1<<n);\\n            for (int i=0; i<(1<<n); i++) \\n                ans[i] = i^(i>>1);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 29884,
                "title": "what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion",
                "content": "  I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution?  (I combined the base cases in the loop as mike3 does. Thanks mike3!)\\n\\n    vector<int> grayCode(int n) \\n    {         \\n        vector<int> result(1, 0);        \\n        for (int i = 0; i < n; i++) {\\n            int curCount = result.size();\\n            // push back all element in result in reverse order\\n            while (curCount) {\\n                curCount--;\\n                int curNum = result[curCount];\\n                curNum += (1<<i);\\n                result.push_back(curNum);\\n            } \\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "  I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution?  (I combined the base cases in the loop as mike3 does. Thanks mike3!)\\n\\n    vector<int> grayCode(int n) \\n    {         \\n        vector<int> result(1, 0);        \\n        for (int i = 0; i < n; i++) {\\n            int curCount = result.size();\\n            // push back all element in result in reverse order\\n            while (curCount) {\\n                curCount--;\\n                int curNum = result[curCount];\\n                curNum += (1<<i);\\n                result.push_back(curNum);\\n            } \\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1308570,
                "title": "python-short-recursive-solution-explained",
                "content": "The idea is to use recursion, if we have gray code for `n-1`, than we can construct gray code for `n` easily. Imagine, that `n = 4` and we have code `[0,1,3,2,6,7,5,4]`. Then we need to add numbers in `[8, 15]`. Let us add `8` to each number, so we have `[8, 9, 11, 10, 14, 15, 13, 12]` which is also code with property that every two adjacent number differ by one bit. All we need to do is to concatenate these two lists, but first we need to invert one of them to get `[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]`.\\n\\n#### Complexity\\nTime complexity is `O(2^n)`, space as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def grayCode(self, n):\\n        if n == 0: return [0]\\n        t = self.grayCode(n-1)\\n        return t + [i+(1<<(n-1)) for i in t][::-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n):\\n        if n == 0: return [0]\\n        t = self.grayCode(n-1)\\n        return t + [i+(1<<(n-1)) for i in t][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245076,
                "title": "4-lines-elegant-fast-and-easy-understand-python-solution",
                "content": "Fisrt, we can explore the data and try to figure out the pattern. \\nFor example, when n=3, **results** start from 000, we can **XOR** last number in results with **X** .\\n`result[i+1] = X[i] ^ result[i]`\\nBelow we can figure out the pattern of **X**:\\n```\\nresult          X                  Y\\n0 0 0         0 0 1           0 0 1 (1)\\n0 0 1         0 1 0           0 1 0 (2)\\n0 1 1         0 0 1           0 1 1 (3)\\n0 1 0         1 0 0           1 0 0 (4)\\n1 1 0         0 0 1           1 0 1 (5)\\n1 1 1         0 1 0           1 1 0 (6)\\n1 0 1         0 0 1           1 1 1 (7)\\n1 0 0\\n```\\nSo the keypoint is to generate **X** sequence. Here is the trick, actually **X** is **lowest one-bit** of **Y** (natural number set).\\nAccording to bit-manipulation, we can get lowest one-bit of number by\\n`X = Y & -Y`\\nFinally, we can get this elegant and easy-understand solution:\\n```\\ndef grayCode(self, n: int) -> \\'List[int]\\':\\n\\tres = [0]\\n\\tfor i in range(1, 2**n):\\n\\t\\tres.append(res[-1] ^ (i & -i))\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nresult          X                  Y\\n0 0 0         0 0 1           0 0 1 (1)\\n0 0 1         0 1 0           0 1 0 (2)\\n0 1 1         0 0 1           0 1 1 (3)\\n0 1 0         1 0 0           1 0 0 (4)\\n1 1 0         0 0 1           1 0 1 (5)\\n1 1 1         0 1 0           1 1 0 (6)\\n1 0 1         0 0 1           1 1 1 (7)\\n1 0 0\\n```\n```\\ndef grayCode(self, n: int) -> \\'List[int]\\':\\n\\tres = [0]\\n\\tfor i in range(1, 2**n):\\n\\t\\tres.append(res[-1] ^ (i & -i))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1308562,
                "title": "gray-code-c-python-iterative-solution-explained",
                "content": "The main idea is to use previously calculated values\\nLook the examples in bit representation =>>\\nn=0  =>   [0]\\nn=1  =>  [0, 1] \\nn=2 => [00, 01, 11, 10]   => [00, 01] + [11, 01]  => ( 0 + [result(n-1)] ) +  ( 1 + [result(n-1)] )\\nn=3 => [000, 001, 011, 010, 110, 111, 101, 100] => ( 0 + [result(n-1) ) + ( 1+ [result(n-1)] )\\nso on ...\\nNow we can implement the above pattern easily\\nWe can make it more simple, if we observe that, Every time we just twiced the values in the prev result ans new values are just made on the folling pattern =>\\nn=0 =>  [0000]\\nn=1 => [0000, 0001]  // observe the we had just set (n-1)th bit to 1, iterating from right in the prev result ;\\nn=2 => [0000, 0001, 0011, 0010]\\nn=3 => [0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100]\\nso on ...\\nmask containes (n-1)th bit as 1,   \\nif result for n=2, 0001 =>  **mask = 0010** hence newRes = (**res | mask**) = 0011; \\nHope it helped you to understand the logic.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> result;\\n        result.push_back(0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int prevLength = result.size();\\n            int mask = 1 << (i - 1);\\n            for (int j = prevLength - 1; j >= 0; j--) {\\n                result.push_back(mask + result[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Python =>**\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        arr = []\\n        arr.append(0)\\n        for i in range(1,n+1):\\n            prevLength = len(arr)\\n            mask = 1 << (i-1)\\n            for j in range(prevLength, 0, -1):\\n                arr.append(mask + arr[j-1])\\n        return arr\\n```\\n**If you find it helpful, plz upvote**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> result;\\n        result.push_back(0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int prevLength = result.size();\\n            int mask = 1 << (i - 1);\\n            for (int j = prevLength - 1; j >= 0; j--) {\\n                result.push_back(mask + result[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        arr = []\\n        arr.append(0)\\n        for i in range(1,n+1):\\n            prevLength = len(arr)\\n            mask = 1 << (i-1)\\n            for j in range(prevLength, 0, -1):\\n                arr.append(mask + arr[j-1])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30045,
                "title": "share-my-simple-way-of-this-problem",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int N(1 << n), tmp;\\n            vector<int> result;\\n            for(int i(0); i < N; i++)\\n            {\\n                tmp = i << 1;\\n                result.push_back((tmp^i) >> 1);\\n            }\\n            return result;\\n        }\\n    };\\n\\nAs we known:\\n\\n    Gi = Bi+1 xor Bi\\n\\nFor example, trans binay '001' to gray code:\\n\\n    tmp = 001 << 1\\n\\nthen,\\n\\n    bin 0 0 0 1\\n    tmp 0 0 1 0\\n    -xor------------\\n        0 0 1 1\\nand the gray code is:\\n\\n    0 0 1 1 >> 1 (ignore last bit) => 0 0 1",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int N(1 << n), tmp;\\n            vector<int> result;\\n            for(int i(0); i < N; i++)\\n            {\\n                tmp = i << 1;\\n                result.push_back((tmp^i) >> 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3440293,
                "title": "easy-to-understand-concise-c",
                "content": "`Idea`:\\nGray code for a number n is n^(n/2), and we push the same for every number in range [0, pow(2,x)).\\n\\n`Explanation`\\nFor the explanation part, we copy the MSB from binary as it is in the code and xor the remaining bits i.e. g[i] = b[i] ^ b[i-1].\\n\\n`Lets take 13`: 1101\\n`Gray code will b`e:\\n1 + 1^1 + 0^1 + 1^0\\n\\nIf you see carefully, the xored number is actually \\'0110\\' which is equal to n/2.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30007,
                "title": "python-easy-bit-manipulation-solution",
                "content": "For n=1: 0 1\\n\\nFor n=2: 00 01 11 10\\n\\nNotice that the second half (11 and 10) are mirror of the first half (0 1) with additional 1 before it (10 11).\\nNow we have (00 01 11 10), in order to do n=3 we need to do the same. The 4 elements of n=2 will be our first half, to do the second half we mirror them to get (10 11 01 00) and add additional 1 before it (110 111 101 100). We get:\\n\\nFor n=3: 000 001 011 010 110 111 101 100\\n\\n\\n    def grayCode(n):\\n        if not n:\\n            return [0]\\n        res = [0,1]\\n        for i in range(2,n+1):\\n            for j in range(len(res)-1,-1,-1):\\n                res.append(res[j] | 1<<i-1)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "For n=1: 0 1\\n\\nFor n=2: 00 01 11 10\\n\\nNotice that the second half (11 and 10) are mirror of the first half (0 1) with additional 1 before it (10 11).\\nNow we have (00 01 11 10), in order to do n=3 we need to do the same. The 4 elements of n=2 will be our first half, to do the second half we mirror them to get (10 11 01 00) and add additional 1 before it (110 111 101 100). We get:\\n\\nFor n=3: 000 001 011 010 110 111 101 100\\n\\n\\n    def grayCode(n):\\n        if not n:\\n            return [0]\\n        res = [0,1]\\n        for i in range(2,n+1):\\n            for j in range(len(res)-1,-1,-1):\\n                res.append(res[j] | 1<<i-1)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 29953,
                "title": "java-easy-version-to-understand",
                "content": "    public static List<Integer> grayCode(int n) {\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tlist.add(0);\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tList<Integer> tmp = grayCode(n - 1);\\n\\t\\tList<Integer> result = new ArrayList<Integer>(tmp);\\n\\t\\tint addNumber = 1 << (n - 1);\\n\\t\\tfor (int i = tmp.size() - 1; i >= 0; i--) {\\n\\t\\t\\tresult.add(addNumber + tmp.get(i));\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    public static List<Integer> grayCode(int n) {\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tlist.add(0);\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tList<Integer> tmp = grayCode(n - 1);\\n\\t\\tList<Integer> result = new ArrayList<Integer>(tmp);\\n\\t\\tint addNumber = 1 << (n - 1);\\n\\t\\tfor (int i = tmp.size() - 1; i >= 0; i--) {\\n\\t\\t\\tresult.add(addNumber + tmp.get(i));\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 30084,
                "title": "4ms-simple-iterative-solution",
                "content": "    vector<int> grayCode(int n) {\\n        vector<int> result = { 0 };\\n        int t = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = result.size() - 1; j >= 0; j--)\\n                result.push_back(result[j]^t);\\n            t <<= 1;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> grayCode(int n) {\\n        vector<int> result = { 0 };\\n        int t = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = result.size() - 1; j >= 0; j--)\\n                result.push_back(result[j]^t);\\n            t <<= 1;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30092,
                "title": "one-line-python-solution-with-comments",
                "content": "These characteristics suggest a simple and fast method of translating a binary value into the corresponding Gray code. Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: g(b) = x(b) XOR x(b+1)\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {integer[]}\\n    def grayCode(self, n):\\n        return [(i>>1)^i for i in xrange(2**n)]",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 1308685,
                "title": "c-python-easy-to-understand-100-fast",
                "content": "**Idea:** \\nGray code for a number **```n```** is **```n^(n/2)```**, and we push the same for every number in range ```[0, pow(2,x))```.\\n\\n**Explanation**\\nFor the explanation part, we copy the MSB from binary as it is in the code and xor the remaining bits **i.e. ```g[i] = b[i] ^ b[i-1]```.**\\n\\nLets take 13: 1101\\nGray code will be:\\n```1 + 1^1 + 0^1 + 1^0```\\nIf you see carefully, the xored number is actually \\'0110\\' which is equal to n/2.\\n\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**Python Solution**\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i//2) for i in range(1<<n)]\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```n```\n```n^(n/2)```\n```[0, pow(2,x))```\n```g[i] = b[i] ^ b[i-1]```\n```1 + 1^1 + 0^1 + 1^0```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i//2) for i in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400651,
                "title": "java-solutions-with-detailed-comments-and-explanations-backtracking-prepending",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/gray-code/) <span class=\"gray\">EPI 15.11</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> The gray code is a binary numeral system where two successive values **differ in only one bit**.\\n\\nGiven a non-negative integer `n` representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with `0`.\\n\\n**Example:** \\n\\n```java\\nInput: 2\\nOutput: [0,1,3,2]\\nExplanation:\\n00 - 0\\n01 - 1\\n11 - 3\\n10 - 2\\n\\nFor a given n, a gray code sequence may not be uniquely defined.\\nFor example, [0,2,3,1] is also a valid gray code sequence.\\n\\n00 - 0\\n10 - 2\\n11 - 3\\n01 - 1\\n\\nInput: 0\\nOutput: [0]\\n\\nInput: 1\\nOutput: [0, 1]\\n```\\n\\n\\n## Analysis\\n\\n### Backtracking\\n\\nInstead of enumerating all possible permutations, which takes `O(2^{n * 2^n})`, we construct the gray code by a step-by-step approach.\\n\\nFirst, we design a function that checks if two numbers `n1` and `n2` differ only in one bit.\\n\\n- `n1 == n2`: `xor == 0`, returns false.\\n- Differ in more than one bit: `(xor & (xor - 1)) != 0`, returns false.\\n- Differ in one bit: `(xor & (xor - 1)) == 0`, returns true.\\n\\n**Note:** `num & (num - 1)` can remove the rightmost one-bit of `num`.\\n\\n```java\\nprivate boolean isValid(int n1, int n2) {\\n  int xor = n1 ^ n2;\\n  return xor != 0 && (xor & (xor - 1)) == 0;\\n}\\n```\\n\\nConsider we have a number `0110`. How many differ-in-one numbers can we have for `0110`? The answer is `[1110, 0010, 0100, 0111]`. We can write it out right away because we just need to do XOR operation for each bit. In other words, we XOR `0110` with `[1000, 0100, 0010, 0001]`.\\n\\nBased on this idea, we can take the latest generated number in the result list, and try out all differ-in-one possibilities. In order to know if the new candidate is qualified, we use a hash set to store all previously constructed numbers.\\n\\nIf the candidate is not in the hash set, we add it to the hash set and also append it to the result list. Then we construct the next number based on the number we\\'ve just added.\\n\\nAt last, when we have `2^n` numbers in the result list, we need to check if the first and the last elements are compatible via `isValid(n1, n2)`. If yes, everything is done; if no, backtrack and construct a new possible number, and try again.\\n\\n**Note:** `2^i` can be computed by `1 << i`.\\n\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  Set<Integer> history = new HashSet<>();\\n  generateGrayCode(n, history, result);\\n  return result;\\n}\\n\\nprivate boolean generateGrayCode(int n, Set<Integer> history, List<Integer> result) {\\n  // base case\\n  if (result.size() == (1 << n)) {\\n    // check the first element and the last element\\n    return isValid(result.get(0), result.get(result.size() - 1));\\n  }\\n  for (int i = 0; i < n; ++i) {\\n    int prevCode = result.get(result.size() - 1);\\n    int candCode = prevCode ^ (1 << i);\\n    if (!history.contains(candCode)) {\\n      history.add(candCode);\\n      result.add(candCode);\\n      boolean found = generateGrayCode(n, history, result);\\n      if (found) return true;\\n      history.remove(candCode);\\n      result.remove(result.size() - 1);\\n    }\\n  }\\n  return false;\\n}\\n```\\n\\n**Time:** `O(2^N)` <span class=\"purple\">I don\\'t know how to get it~</span>\\n**Space:** `O(2^N)`\\n\\n\\n\\n### Prepending 0 and 1\\n\\nThe idea is simple. Based on the `result` in `n = k`, we add $0$ before each element to get the first half; we add $1$ before each element of `result` and **reverse** the list to get the second half. Then concatenate them to get the result for `n = k + 1`. **See the example below to understand it!**.\\n\\nConsider how we generate gray codes from `n = 0` to `n = 3`.\\n\\n```java\\nn = 0, we have [0].\\n\\nn = 1, we previously have [0] and then construct [0, 1].\\n\\nJust add 1 (actually add 1, which is 1 << n = 1)\\n\\nn = 2, we previously have [0, 1] and construct [00, 01, 11, 10].\\n\\nBy adding 0 before each element, we get [00, 01] (actually do nothing in the code)\\nBy adding 1 before each element, we get [10, 11] (actually add 10, which is 1 << n = 10)\\nReverse [10, 11] to get [11, 10]\\nCombine [00, 01] and [11, 10], we have [00, 01, 11, 10].\\n\\nn = 3, we previously have [00, 01, 11, 10].\\n\\nAdd 0:   [000, 001, 011, 010]\\nAdd 1:   [110, 111, 101, 100] (reversed) (actually add 100, which is 1 << n = 1 << 3 = 100)\\nCombine: [000, 001, 011, 010, 110, 111, 101, 100]\\n```\\n\\n**Note:** Consider the corner cases when `n = 0` and `n = 1`, and then decide `i` should start from $0$.\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    List<Integer> res1 = result;\\n    List<Integer> res2 = new ArrayList<>(res1);\\n    Collections.reverse(res2);\\n    // prepend \"1\"\\n    int prependVal = (1 << i);\\n    for (int j = 0; j < res2.size(); ++j) {\\n      res2.set(j, res2.get(j) + prependVal);\\n    }\\n    res1.addAll(res2);\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(2^N)`\\n- `n = 0` (`[0]`), prepending \"1\" takes `1` operation (**allocating extra space takes `1` operation and reversing takes $1$ operation, but they are proportional to number of prepending operations**).\\n- `n = 1` (`[0, 1]`), prepending \"1\" takes `2` operations.\\n- `n = 2` (`[00, 01, 11, 10]`), prepending \"1\" takes `4` operations.\\n- `n = 3` (`[000, 001, 011, 010, 110, 111, 101, 100]`), prepending \"1\" takes `8` operations.\\n- `n = k`, prepending \"1\" takes `2^k` operations.\\n- In total, `T(N) = 1 + 2 + 4 + 8 + ... + 2^N = 2^N`.\\n\\n**Space:** `O(2^N)`\\n\\n**Without allocating extra space (In-Place):**\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    int prependVal = (1 << i);\\n    int oldSize = result.size();\\n    for (int j = oldSize - 1; j >= 0; --j) {\\n      result.add(result.get(j) + prependVal);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\nSame complexity.\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nInput: 2\\nOutput: [0,1,3,2]\\nExplanation:\\n00 - 0\\n01 - 1\\n11 - 3\\n10 - 2\\n\\nFor a given n, a gray code sequence may not be uniquely defined.\\nFor example, [0,2,3,1] is also a valid gray code sequence.\\n\\n00 - 0\\n10 - 2\\n11 - 3\\n01 - 1\\n\\nInput: 0\\nOutput: [0]\\n\\nInput: 1\\nOutput: [0, 1]\\n```\n```java\\nprivate boolean isValid(int n1, int n2) {\\n  int xor = n1 ^ n2;\\n  return xor != 0 && (xor & (xor - 1)) == 0;\\n}\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  Set<Integer> history = new HashSet<>();\\n  generateGrayCode(n, history, result);\\n  return result;\\n}\\n\\nprivate boolean generateGrayCode(int n, Set<Integer> history, List<Integer> result) {\\n  // base case\\n  if (result.size() == (1 << n)) {\\n    // check the first element and the last element\\n    return isValid(result.get(0), result.get(result.size() - 1));\\n  }\\n  for (int i = 0; i < n; ++i) {\\n    int prevCode = result.get(result.size() - 1);\\n    int candCode = prevCode ^ (1 << i);\\n    if (!history.contains(candCode)) {\\n      history.add(candCode);\\n      result.add(candCode);\\n      boolean found = generateGrayCode(n, history, result);\\n      if (found) return true;\\n      history.remove(candCode);\\n      result.remove(result.size() - 1);\\n    }\\n  }\\n  return false;\\n}\\n```\n```java\\nn = 0, we have [0].\\n\\nn = 1, we previously have [0] and then construct [0, 1].\\n\\nJust add 1 (actually add 1, which is 1 << n = 1)\\n\\nn = 2, we previously have [0, 1] and construct [00, 01, 11, 10].\\n\\nBy adding 0 before each element, we get [00, 01] (actually do nothing in the code)\\nBy adding 1 before each element, we get [10, 11] (actually add 10, which is 1 << n = 10)\\nReverse [10, 11] to get [11, 10]\\nCombine [00, 01] and [11, 10], we have [00, 01, 11, 10].\\n\\nn = 3, we previously have [00, 01, 11, 10].\\n\\nAdd 0:   [000, 001, 011, 010]\\nAdd 1:   [110, 111, 101, 100] (reversed) (actually add 100, which is 1 << n = 1 << 3 = 100)\\nCombine: [000, 001, 011, 010, 110, 111, 101, 100]\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    List<Integer> res1 = result;\\n    List<Integer> res2 = new ArrayList<>(res1);\\n    Collections.reverse(res2);\\n    // prepend \"1\"\\n    int prependVal = (1 << i);\\n    for (int j = 0; j < res2.size(); ++j) {\\n      res2.set(j, res2.get(j) + prependVal);\\n    }\\n    res1.addAll(res2);\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    int prependVal = (1 << i);\\n    int oldSize = result.size();\\n    for (int j = oldSize - 1; j >= 0; --j) {\\n      result.add(result.get(j) + prependVal);\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451928,
                "title": "c-bit-manipulation-easy-to-understand-explained-beginner",
                "content": "# ***Appraoch***\\n```\\nWe are required to find n-bit gray codes and return them in a vector\\n\\nThis is a pretty good bit-manipulation + backtracking problem\\nI would say backtracking part is really easy but bit-manipulation logic is really good for this particular problem\\n\\nLogic is very simple\\n\\nsuppose we are given n = 1 [means we are required all 1-bit gray codes]\\ngray codes : differ only by 1 bit in their binary representation!!!\\n    \\nfor n = 1 => codes [0 , 1]\\nfor n = 2 => codes [00 , 01 , 11 , 10]\\nfor n = 3 => codes [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n\\nObservation : for n , we have (2 ^ n ) codes\\n\\nalso for finding we can find all n-bit gray codes if we already know (n-1) bit codes\\n\\nlet\\'s find out how?\\n    \\n    suppose we are given all codes for n = 2 , [00 , 01 , 11 , 10]\\n    and required to find for n = 3\\n        \\n        means n = 3,\\n\\t\\tfor n = 3 , we have 2 ^ 3 = 8 codes [4 created by putting 0 in front of 2-bit codes + 4 created by putting 1 in front of 2-bit codes in reverse fashion]\\n\\t\\t\\n        find n-bit codes with the help of (n-1) bit codes\\n        actually 3-bit codes can be build using 2-bit codes by first placing 0 in front of all codes and then 1 bit codes in reverse fashion\\n        \\n        Put 0 in front of all 2-bit codes\\n        00  => 000\\n        01  => 001\\n        11  => 011\\n        10  => 010\\n            \\n        half of 3-bit codes are ready!!\\n            \\n        Other half can be build putting 1 in front of all 2-bit codes in reverse fashion[because if we put in forward order we get 2 changed bits in one pair]\\n        \\n        Put 1 in front of all 2-bit codes in reverse fashion\\n\\n        10  => 110\\n        11  => 111\\n        01  => 101\\n        00  => 100\\n\\n        so 3-bit codes are = [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> codes;\\n        \\n        for(string s : get_n_bit_gray_code(n))\\n            codes.push_back(stoi(s , 0 , 2)); // converting string-binary-num to int : \"100\" = 4\\n        return codes;\\n    }\\n    \\n    vector<string> get_n_bit_gray_code(int n)\\n    {\\n        if(n == 1) // base case\\n            return {\"0\" , \"1\"};\\n        \\n        vector<string> v = get_n_bit_gray_code(n - 1);\\n        \\n        vector<string> codes;\\n        \\n        for(int i = 0 ; i < v.size() ; ++i) // forward-fashion traversal to add 0 to front\\n            codes.push_back(\"0\" + v[i]);\\n        \\n        for(int i = v.size() - 1 ; i >= 0 ; --i) // reverse-fashion traversal to add 1 to front\\n            codes.push_back(\"1\" + v[i]);\\n        \\n        return codes;\\n    }\\n};\\n```\\n# ***If you liked the solution , please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nWe are required to find n-bit gray codes and return them in a vector\\n\\nThis is a pretty good bit-manipulation + backtracking problem\\nI would say backtracking part is really easy but bit-manipulation logic is really good for this particular problem\\n\\nLogic is very simple\\n\\nsuppose we are given n = 1 [means we are required all 1-bit gray codes]\\ngray codes : differ only by 1 bit in their binary representation!!!\\n    \\nfor n = 1 => codes [0 , 1]\\nfor n = 2 => codes [00 , 01 , 11 , 10]\\nfor n = 3 => codes [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n\\nObservation : for n , we have (2 ^ n ) codes\\n\\nalso for finding we can find all n-bit gray codes if we already know (n-1) bit codes\\n\\nlet\\'s find out how?\\n    \\n    suppose we are given all codes for n = 2 , [00 , 01 , 11 , 10]\\n    and required to find for n = 3\\n        \\n        means n = 3,\\n\\t\\tfor n = 3 , we have 2 ^ 3 = 8 codes [4 created by putting 0 in front of 2-bit codes + 4 created by putting 1 in front of 2-bit codes in reverse fashion]\\n\\t\\t\\n        find n-bit codes with the help of (n-1) bit codes\\n        actually 3-bit codes can be build using 2-bit codes by first placing 0 in front of all codes and then 1 bit codes in reverse fashion\\n        \\n        Put 0 in front of all 2-bit codes\\n        00  => 000\\n        01  => 001\\n        11  => 011\\n        10  => 010\\n            \\n        half of 3-bit codes are ready!!\\n            \\n        Other half can be build putting 1 in front of all 2-bit codes in reverse fashion[because if we put in forward order we get 2 changed bits in one pair]\\n        \\n        Put 1 in front of all 2-bit codes in reverse fashion\\n\\n        10  => 110\\n        11  => 111\\n        01  => 101\\n        00  => 100\\n\\n        so 3-bit codes are = [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> codes;\\n        \\n        for(string s : get_n_bit_gray_code(n))\\n            codes.push_back(stoi(s , 0 , 2)); // converting string-binary-num to int : \"100\" = 4\\n        return codes;\\n    }\\n    \\n    vector<string> get_n_bit_gray_code(int n)\\n    {\\n        if(n == 1) // base case\\n            return {\"0\" , \"1\"};\\n        \\n        vector<string> v = get_n_bit_gray_code(n - 1);\\n        \\n        vector<string> codes;\\n        \\n        for(int i = 0 ; i < v.size() ; ++i) // forward-fashion traversal to add 0 to front\\n            codes.push_back(\"0\" + v[i]);\\n        \\n        for(int i = v.size() - 1 ; i >= 0 ; --i) // reverse-fashion traversal to add 1 to front\\n            codes.push_back(\"1\" + v[i]);\\n        \\n        return codes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393673,
                "title": "python-recursive-implementation",
                "content": "This uses property of gray codes, that you can mirror and add prefix to get these codes. This is shown in the following image. \\n\\n\\n![image](https://assets.leetcode.com/users/msminhas93/image_1569797075.png)\\n\\nThe code uses basic recursion to add the appropirate prefixes to the original codes and the mirrored codes [obtained by reversing the list of original codes.].\\n\\n```\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==0:\\n            return [0]\\n        if n==1:\\n            return [0,1]\\n        if n==2:\\n            return [0,1,3,2]\\n        else:\\n            return self.grayCode(n-1) + [x + (2**(n-1)) for x in self.grayCode(n-1)[::-1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==0:\\n            return [0]\\n        if n==1:\\n            return [0,1]\\n        if n==2:\\n            return [0,1,3,2]\\n        else:\\n            return self.grayCode(n-1) + [x + (2**(n-1)) for x in self.grayCode(n-1)[::-1]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30006,
                "title": "6-line-java-solution-very-concise",
                "content": "All we need to do is to add an '1' to the top digit of the binary string and reversely added the new number to the list.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        \\n        for(int i = 0; i < n ; i++)\\n            for(int j = ans.size()-1; j>=0; j--)\\n                ans.add(ans.get(j)+(1<<i));\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "All we need to do is to add an '1' to the top digit of the binary string and reversely added the new number to the list.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        \\n        for(int i = 0; i < n ; i++)\\n            for(int j = ans.size()-1; j>=0; j--)\\n                ans.add(ans.get(j)+(1<<i));\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 741620,
                "title": "intuitive-solution-using-inputs-cpp-hard-till-you-understand-logic-xd",
                "content": "n==0 {0}  //base case\\nn==1 {0,1} //base case\\nn==2 {00,01,11,10} //traversing from left to right through for n==1 add 0 to the front and traversing from right to left add 1 at the front. \\nn==3 {000,001,011,010,110,111,101,100} // similar as above\\nn==4 {0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1111,1110,1010,1011,1001,1000} \\nNow write for n==5 yourself. \\nNow code ---> \\n```\\nclass Solution {\\npublic:\\n    int bin(string c)\\n    {\\n        int ans = 0;\\n        for(auto x:c)\\n        {\\n            ans = ans*2  + (x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> grayCode(int n) {\\n        if(n==0)return {0};\\n        if(n==1)return {0,1};\\n        vector<string>vect;\\n        vector<string>ans;\\n        ans.push_back(\"0\");\\n        ans.push_back(\"1\");\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string>temp;\\n            for(auto c: ans)\\n            {\\n                c.insert(c.begin(),\\'0\\');\\n                temp.push_back(c);\\n            }\\n            for(int k=ans.size()-1;k>=0;k--)\\n            {\\n                ans[k].insert(ans[k].begin(),\\'1\\');\\n                temp.push_back(ans[k]);\\n            }\\n           ans = temp;\\n        }\\n        vector<int>ans1;\\n        for(auto c: ans)\\n        {\\n            ans1.push_back(bin(c));\\n        }\\n        return ans1;\\n    }\\n};\\n```\\nPS:Thumbs up if you like it, It will encourage me. Have a nice day :).\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bin(string c)\\n    {\\n        int ans = 0;\\n        for(auto x:c)\\n        {\\n            ans = ans*2  + (x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> grayCode(int n) {\\n        if(n==0)return {0};\\n        if(n==1)return {0,1};\\n        vector<string>vect;\\n        vector<string>ans;\\n        ans.push_back(\"0\");\\n        ans.push_back(\"1\");\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string>temp;\\n            for(auto c: ans)\\n            {\\n                c.insert(c.begin(),\\'0\\');\\n                temp.push_back(c);\\n            }\\n            for(int k=ans.size()-1;k>=0;k--)\\n            {\\n                ans[k].insert(ans[k].begin(),\\'1\\');\\n                temp.push_back(ans[k]);\\n            }\\n           ans = temp;\\n        }\\n        vector<int>ans1;\\n        for(auto c: ans)\\n        {\\n            ans1.push_back(bin(c));\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29938,
                "title": "simplest-fastest-easiest-solution",
                "content": "    public List<Integer> grayCode(int n) {\\n        int count = (int)Math.pow(2,n);\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < count; i++){\\n            res.add((i) ^ (i >> 1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        int count = (int)Math.pow(2,n);\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < count; i++){\\n            res.add((i) ^ (i >> 1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30106,
                "title": "recursive-solution-c-6-ms-with-explaination",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result;\\n            if (n > 0) {\\n                grayCodeHelper(n, result);\\n            } else {\\n                result.push_back(0);\\n            }\\n            return result;\\n        }\\n        \\n        void grayCodeHelper(int n, vector<int>& res) {\\n            if (n == 1) {\\n                res.push_back(0);\\n                res.push_back(1);\\n                return;\\n            }\\n            \\n            grayCodeHelper(n-1, res);\\n            int size = res.size()-1;\\n            // n elements in res are already a part of\\n            // current gray code as they start with 0 as the MSB\\n            // we need to traverse the res in reverse order, or it \\n            // with 1 to get the next numbers.\\n            // If dont understand, then try making gray code seq\\n            // with 1 and then see how to get graycode(2) from 1.\\n            \\n            for (int i = size; i >= 0; --i) {\\n                int num = res[i] | (1<<(n-1));\\n                res.push_back(num);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result;\\n            if (n > 0) {\\n                grayCodeHelper(n, result);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 681993,
                "title": "java-solution-without-using-any-bitwise-operation-1ms-runtime-complexity",
                "content": "Ping in comment if anybody does not understand the login behind the answer.\\n```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList();\\n        res.add(0);\\n        for(int i=1;i<=n;i++){\\n            int count = res.size()-1;\\n            int add = (int)Math.pow(2,i-1);\\n            while(count>=0)\\n                   res.add(add+res.get(count--));\\n            }\\n     return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList();\\n        res.add(0);\\n        for(int i=1;i<=n;i++){\\n            int count = res.size()-1;\\n            int add = (int)Math.pow(2,i-1);\\n            while(count>=0)\\n                   res.add(add+res.get(count--));\\n            }\\n     return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 29954,
                "title": "dp-python-solution",
                "content": "dp is a good way to solve this problem. Every time when you increase the n by 1, you add 1 more digit in the front, which means you add 2**(n-1) to dp[n-1][-1] for you  second half number list\\n\\nn = 1: [0,1]\\nn = 2: [0,1]+ [2+0, 2+1][::-1] = [0,1,3,2]\\nn = 3: [0,1,3,2] + [4 + 0, 4 +1, 4 +3, 4 + 2][::-1] = [0,1,3,2,6,7,5,4]\\n\\n```\\n    def grayCode(self, n):\\n        dp = [[0]]\\n        for i in range(1,n+1):\\n            dp.append(dp[i-1] + [2**(i-1) + j for j in dp[i-1]][::-1])\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\n    def grayCode(self, n):\\n        dp = [[0]]\\n        for i in range(1,n+1):\\n            dp.append(dp[i-1] + [2**(i-1) + j for j in dp[i-1]][::-1])\\n        return dp[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1921930,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func grayCode(_ n: Int) -> [Int] {\\n        var arr: [Int] = [0]\\n        var e = -1\\n        \\n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\\n        \\n        for i in 1..<povv(2, n) {\\n            if i == povv(2, e + 1) { e += 1 }\\n            \\n            let index = povv(2, e + 1) - i - 1\\n            let num = povv(2, e) + arr[index]\\n            arr.append(num)\\n        }\\n        \\n        return arr\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func grayCode(_ n: Int) -> [Int] {\\n        var arr: [Int] = [0]\\n        var e = -1\\n        \\n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\\n        \\n        for i in 1..<povv(2, n) {\\n            if i == povv(2, e + 1) { e += 1 }\\n            \\n            let index = povv(2, e + 1) - i - 1\\n            let num = povv(2, e) + arr[index]\\n            arr.append(num)\\n        }\\n        \\n        return arr\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309424,
                "title": "python3-1-line-solution-list-comprehension",
                "content": "Using List Comprehension, we can easily solve this problem statement in 1 line.\\n```\\n#   Gray Code Formula:\\n#   n <= 16\\n#   Gray_Code(n) = n XOR (n / 2)\\n\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [i ^ (i // 2) for i in range(pow(2, n))]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#   Gray Code Formula:\\n#   n <= 16\\n#   Gray_Code(n) = n XOR (n / 2)\\n\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [i ^ (i // 2) for i in range(pow(2, n))]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110683,
                "title": "python-js-c-go-o-2-n-by-toggle-bitmask-w-example",
                "content": "Python O(2^n) by toggle bitmask\\n\\n---\\n\\nExample with n = 2:\\n\\n1st iteration\\n\\u3000\\u3000 0 0\\n\\u2295\\u3000  0 0\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30000 0 \\n  \\n  We get 0\\'b 00 = **0**\\n\\n---\\n\\n2nd iteration\\n\\u3000\\u3000 0 1\\n\\u2295\\u3000  0 0\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30000 1 \\n  \\n  We get 0\\'b 01 = **1**\\n\\n---\\n\\n3rd iteration\\n\\u3000\\u3000 1 0\\n\\u2295\\u3000  0 1\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30001 1 \\n  \\n  We get 0\\'b 11 = **3**\\n\\n---\\n\\n4th iteration\\n\\u3000\\u3000 1 1\\n\\u2295\\u3000  0 1\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30001 0 \\n  \\n  We get 0\\'b 10 = **2**\\n  \\n---\\n\\nFinally, we have gray codes with n=2: \\n[**0**, **1**, **3**, **2**]\\n\\n---\\n\\n**Implementation** in Python:\\n\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        # total 2^n codes for bit length n\\n        code_count = 1 << n\\n        \\n        # generate gray code from 0, and toggle 1 bit on each iteration\\n        # toggle mask: ( i >> 1 )\\n        \\n        gray_codes =[ i ^ ( i >> 1 ) for i in range(code_count) ]\\n        \\n        return gray_codes\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\n\\nvar grayCode = function(n) {\\n\\n    // toal 2^n codes for bit length n\\n    const codeCount = 1 << n;\\n    \\n    let result = [];\\n    \\n    // generate gray code from 0, and toggle 1 bit on each iteration\\n    // toggle mask: ( i >> 1 )\\n    \\n    for(let i = 0 ; i < codeCount ; i++){\\n        \\n        code = i ^ ( i >> 1);\\n        result.push( code );\\n    }\\n    \\n    return result\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **C++**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        // toal 2^n codes for bit length n\\n        const int codeCount = 1 << n;\\n        \\n        vector<int> result;\\n\\n        // generate gray code from 0, and toggle 1 bit on each iteration\\n        // toggle mask: ( i >> 1 )\\n        \\n        for( int i = 0 ; i < codeCount ; i++ ){\\n            \\n            int mask = i >> 1;\\n            result.push_back( i ^ mask );\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n\\n```\\nfunc grayCode(n int) []int {\\n    \\n    // total 2^n codes for bit length n\\n    code_count := 1 << n\\n    \\n    // slice to store gray codes\\n    gray_codes := make([]int, code_count)\\n    \\n    for i:=0 ; i < code_count ; i+=1 {\\n        \\n        toggle_mask := ( i >> 1 )\\n        \\n        gray_codes[ i ] = i ^ toggle_mask\\n    }\\n    \\n    return gray_codes\\n}\\n```\\n\\n</details>\\n\\n---\\nReference:\\n\\n[1] [Wiki: Gray code](https://en.wikipedia.org/wiki/Gray_code)\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        # total 2^n codes for bit length n\\n        code_count = 1 << n\\n        \\n        # generate gray code from 0, and toggle 1 bit on each iteration\\n        # toggle mask: ( i >> 1 )\\n        \\n        gray_codes =[ i ^ ( i >> 1 ) for i in range(code_count) ]\\n        \\n        return gray_codes\\n```\n```\\n\\nvar grayCode = function(n) {\\n\\n    // toal 2^n codes for bit length n\\n    const codeCount = 1 << n;\\n    \\n    let result = [];\\n    \\n    // generate gray code from 0, and toggle 1 bit on each iteration\\n    // toggle mask: ( i >> 1 )\\n    \\n    for(let i = 0 ; i < codeCount ; i++){\\n        \\n        code = i ^ ( i >> 1);\\n        result.push( code );\\n    }\\n    \\n    return result\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        // toal 2^n codes for bit length n\\n        const int codeCount = 1 << n;\\n        \\n        vector<int> result;\\n\\n        // generate gray code from 0, and toggle 1 bit on each iteration\\n        // toggle mask: ( i >> 1 )\\n        \\n        for( int i = 0 ; i < codeCount ; i++ ){\\n            \\n            int mask = i >> 1;\\n            result.push_back( i ^ mask );\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nfunc grayCode(n int) []int {\\n    \\n    // total 2^n codes for bit length n\\n    code_count := 1 << n\\n    \\n    // slice to store gray codes\\n    gray_codes := make([]int, code_count)\\n    \\n    for i:=0 ; i < code_count ; i+=1 {\\n        \\n        toggle_mask := ( i >> 1 )\\n        \\n        gray_codes[ i ] = i ^ toggle_mask\\n    }\\n    \\n    return gray_codes\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280958,
                "title": "1-line-python-recursion",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return (lambda r: r + [x | 1<<n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0]\\n```\\nReferences to [@girikuncoro\\'s solution](https://leetcode.com/problems/gray-code/discuss/30007/Python-Easy-Bit-Manipulation-Solution)\\n\\nOr, you can just use the method of \\'Gray Code\\'\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i ^ i >> 1  for i in range(1 << n)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return (lambda r: r + [x | 1<<n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0]\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i ^ i >> 1  for i in range(1 << n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216001,
                "title": "python-solution",
                "content": "Recursion. `grayCode(n)` can be obtained by first constructing `grayCode(n-1)` and append `grayCode(n-1)[::-1]` with a bit `1` added in front of every binary number in `grayCode(n-1)[::-1]`. The base case: `grayCode(0) = [0]`.\\n\\nConsider the example `n = 3`. With `n = 2`, we have `grayCode(2) = [00, 01, 11, 10] = [0, 1, 3, 2]`. For `n = 3`, the 4 binary numbers in `grayCode(2)` still show up, i.e., it will contain `[000, 001, 011, 010] = [0, 1, 3, 2]`. To obtain the other 4 binary numbers, we simply flip the first binary digit to `1`, i.e., `[100, 101, 111, 110] = [4, 5, 7, 6]`. Finally, we append `[6, 7, 5, 4]` to `[0, 1, 3, 2]` to obtain the output for `grayCode(3) = [0, 1, 3, 2, 6, 7, 5, 4]`. Note that we have to reverse the second list because `6 (110)` can be obtained from `2 (010)` by flipping one bit, whereas `4 (100)` cannot.\\n\\nTime complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution:\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        if n == 1:\\n            return [0, 1]\\n        res = self.grayCode(n-1)\\n        num = 2**(n-1)\\n        res += res[::-1]\\n        for i in range(num,len(res)):\\n            res[i] ^= num\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        if n == 1:\\n            return [0, 1]\\n        res = self.grayCode(n-1)\\n        num = 2**(n-1)\\n        res += res[::-1]\\n        for i in range(num,len(res)):\\n            res[i] ^= num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29979,
                "title": "typical-backtracking-solution-without-using-bit-manipulation",
                "content": "This problem is very similar with permutation pronblem. so we can use DFS and backtracking to solve this problem.But the gray code is binary numeral system where two successive values differ in only one bit, so we need to reverse the array which store 0 and 1,  when we add 1 to list which store the binary numbers. When the list's size equal n , convert binary to deciamal and add deciamal to result.\\n\\n`\\n\\n    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> grayCode = new ArrayList<>();\\n            // if (n == 0) {\\n            //     return result;\\n            // }\\n            int[] a = {0, 1};\\n            solver(result, grayCode, a, n);\\n            return result;\\n        }\\n        public void solver (List<Integer> result, List<Integer> grayCode, int[] a, int n) {\\n            if (grayCode.size() == n) {\\n                double sum = 0;\\n                for (int i = 0 ; i < grayCode.size(); i++) {\\n                    if (grayCode.get(i) == 1) {\\n                        sum += Math.pow(2, grayCode.size() - 1 - i);\\n                    }\\n                }\\n                result.add((int)sum);\\n                return;\\n            }\\n            for (int i = 0 ; i < 2; i++) {\\n                grayCode.add(a[i]);\\n                if (a[i] == 0) {\\n                    solver(result, grayCode, a, n);\\n                } else {\\n                    swap(a);\\n                    solver(result, grayCode, a, n);\\n                    swap(a);\\n                }\\n                grayCode.remove(grayCode.size() - 1);\\n            }\\n        }\\n        public void swap (int[] a) {\\n            int temp = a[0];\\n            a[0] = a[1];\\n            a[1] = temp;\\n        }\\n    }`",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> grayCode = new ArrayList<>();\\n            // if (n == 0) {\\n            //     return result;\\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 2212006,
                "title": "c-3-approaches-recursion-iteration-gray-code-property-4-lines",
                "content": "The idea is simple. if we have gray code for n-1, then we can construct gray code for n easily. Imagine, that n = 4 and we have code for n-1 i.e, n=3 [0,1,3,2,6,7,5,4]. \\nThen we need to add numbers in [8, 15].\\nLet us add 8 to each number, so we have [8, 9, 11, 10, 14, 15, 13, 12] which is also code with property that every two adjacent number differ by one bit. All we need to do is to concatenate these two lists, but first we need to invert one of them to get [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8].\\n\\n**Iterative Code in C++**\\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans={0};\\n        int value;\\n        for(int i=0;i<n;i++){\\n           vector<int> curr;\\n            for(auto it=ans.rbegin();it!=ans.rend();it++){\\n                curr.push_back((1<<i) | (*it) );\\n            }\\n            ans.insert(ans.end(),curr.begin(),curr.end());\\n        }\\n        return ans;\\n    }\\n```\\n**Recursive Code in C++**\\n```\\n\\tvector<int> grayCode(int n) {\\n        if(n==0) return {0};\\n        vector<int> curr;\\n        vector<int> prev=grayCode(n-1);\\n        for(int i=prev.size()-1;i>=0;i--){\\n            int value =(1<<(n-1)|prev[i]);\\n            curr.push_back(value);\\n        }\\n        curr.insert(curr.begin(),prev.begin(),prev.end());\\n        return curr;\\n    }\\n```\\n\\nThe third approach needs the property of gray code.\\n*G ( i ) = i ^ ( i / 2 )*\\nUsing the above property, we can easily generate gray code for any integer.\\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans;\\n        int value;\\n        for(int i=0;i<(1<<n);i++){\\n            value = i^(i>>1); // G(i) = i ^ (i/2)\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n```\\n**Please support me. If you like my effort !!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans={0};\\n        int value;\\n        for(int i=0;i<n;i++){\\n           vector<int> curr;\\n            for(auto it=ans.rbegin();it!=ans.rend();it++){\\n                curr.push_back((1<<i) | (*it) );\\n            }\\n            ans.insert(ans.end(),curr.begin(),curr.end());\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tvector<int> grayCode(int n) {\\n        if(n==0) return {0};\\n        vector<int> curr;\\n        vector<int> prev=grayCode(n-1);\\n        for(int i=prev.size()-1;i>=0;i--){\\n            int value =(1<<(n-1)|prev[i]);\\n            curr.push_back(value);\\n        }\\n        curr.insert(curr.begin(),prev.begin(),prev.end());\\n        return curr;\\n    }\\n```\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans;\\n        int value;\\n        for(int i=0;i<(1<<n);i++){\\n            value = i^(i>>1); // G(i) = i ^ (i/2)\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310706,
                "title": "c-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039828,
                "title": "java-simple-backtracking-just-like-permutation-detailed-explanation",
                "content": "Since this problem is tagged with backtracking and I also admit that it\\'s hard for me to come up with a smart algorithm to generate the gray code directly, here I share a pretty standard backtracking solution can be used in other backtracking problems.\\n\\nBit manipulations you need to know:\\n1. `1 << n = 2 ^ n`, in this problem, there\\'s `n` bits in code, so the total number is `2^n` (i.e. 0,1,...,2^n -1). Also, `1 << n` means left shift `1` by `n` bit, the mask in the example below is obtained by `1 << 1`.\\n2. `XOR(^)` operation can toggle/flip a bit, e.g. \\n```\\n    1 1 0  (original)\\n^   0 1 0  (mask)\\n----------\\n    1 0 0  (result)\\n\\t\\nThe middle bit of original is flipped, so that original and result only differ by 1 bit.\\n```\\n\\nThe problem is basically permutation of `2^n` numbers so that 2 successive numbers in the permutation differ in only one bit. The input size is can be `n = 16`, though `n` is small, generating all permutation of `2^16` numbers and check the validity would definitely lead to TLE. So we need to prune while we do the permutation. \\n\\nTo meet the 2 number differ in 1 bit constraint, we found that `XOR` operation is useful to generate the next valid number. Also, we only need ANY ONE of the valid permutaion, so when we find one, just return it, avoid further search. Like in the [permutations](https://leetcode.com/problems/permutations/) problem, we need to track the number is used or not since we can use different number only once.\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> curr = new ArrayList<>();\\n        curr.add(0);\\n        boolean[] used = new boolean[1 << n];\\n        used[0] = true;\\n        backtrack(n, curr, used);\\n        return curr;\\n    }\\n    \\n    private boolean backtrack(int n, List<Integer> curr, boolean[] used) {\\n        if (curr.size() == 1 << n) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int nex = (1 << i) ^ curr.get(curr.size() - 1); // (1 << i) is the mask in example, nex is next valid number\\n            if (used[nex]) continue;\\n            used[nex] = true;\\n            curr.add(nex);\\n            if (backtrack(n, curr, used)) return true;\\n            used[nex] = false;\\n            curr.remove(curr.size() - 1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nTime Complexity: `O(2^n)`, a very loose bound\\nSapce: `O(2^n)`",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    1 1 0  (original)\\n^   0 1 0  (mask)\\n----------\\n    1 0 0  (result)\\n\\t\\nThe middle bit of original is flipped, so that original and result only differ by 1 bit.\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> curr = new ArrayList<>();\\n        curr.add(0);\\n        boolean[] used = new boolean[1 << n];\\n        used[0] = true;\\n        backtrack(n, curr, used);\\n        return curr;\\n    }\\n    \\n    private boolean backtrack(int n, List<Integer> curr, boolean[] used) {\\n        if (curr.size() == 1 << n) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int nex = (1 << i) ^ curr.get(curr.size() - 1); // (1 << i) is the mask in example, nex is next valid number\\n            if (used[nex]) continue;\\n            used[nex] = true;\\n            curr.add(nex);\\n            if (backtrack(n, curr, used)) return true;\\n            used[nex] = false;\\n            curr.remove(curr.size() - 1);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30069,
                "title": "short-and-clear-iterative-c-solution",
                "content": "Very easy to understand, just generate the results using already generated values. Used a few intermediate variables for clarity.\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            \\n            vector<int> out = {0};\\n            for (int i = 0; i < n ; ++i)\\n            {\\n                int p = 1<<i;\\n                int s = out.size();\\n                while (s)\\n                {\\n                    int v = p | out[--s];\\n                    out.push_back(v);\\n                }\\n            }\\n    \\n            return out;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            \\n            vector<int> out = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2340177,
                "title": "simple-java-solution",
                "content": "Total no bits =1<<n,\\n   ![image](https://assets.leetcode.com/users/images/98335758-385b-4a2d-9ba4-9b3cd077c2c8_1658910773.2479193.png)\\n for n=3 total no bits=8.\\ni=0,   j=i>>1 = 0    i ^ j=0\\ni=1,    j=i>>1 = 0    i ^ j=1\\ni=2    j=i>>1 = 1     i ^ j=3          \\ni=3    j=i>>1 = 1     i ^ j=2        \\ni=4    j=i>>1 = 2     i ^ j=6\\ni=5    j=i>>1 = 2     i ^ j=7\\ni=6    j=i>>1 = 3     i ^ j=5\\ni=7    j=i>>1=3        i^j=4\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n      ArrayList list=new ArrayList();\\n       for(int i=0;i<(1<<n);i++){\\n         list.add(i^(i>>1));\\n       }\\n         return list;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public List<Integer> grayCode(int n) {\\n      ArrayList list=new ArrayList();\\n       for(int i=0;i<(1<<n);i++){\\n         list.add(i^(i>>1));\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 852558,
                "title": "detailed-explanation-with-example-100-faster",
                "content": "This is very basic problem of generating the first n numbers in `GRAY CODE` representation.\\nDefinition of GRAY Code is already described in the description of the problem statement. So I\\'m skipping that here. And if it\\'s not cleared from there then probably by going through what I\\'ve described below it will make it more clearer.\\n\\nSo first lets take a look how BINARY and GRAY codes are different from one another.\\n\\n| Binary \\t| Gray \\t|\\n|--------\\t|------\\t|\\n| 0000   \\t| 0000 \\t|\\n| 0001   \\t| 0001 \\t|\\n| 0010   \\t| 0011 \\t|\\n| 0011   \\t| 0010 \\t|\\n| 0100   \\t| 0110 \\t|\\n| 0101   \\t| 0111 \\t|\\n| 0110   \\t| 0101 \\t|\\n| 0111   \\t| 0100 \\t|\\n| 1000   \\t| 1100 \\t|\\n| 1001   \\t| 1101 \\t|\\n| 1010   \\t| 1111 \\t|\\n| 1011   \\t| 1110 \\t|\\n| 1100   \\t| 1010 \\t|\\n| 1101   \\t| 1011 \\t|\\n| 1110   \\t| 1001 \\t|\\n| 1111   \\t| 1000 \\t|\\n\\nNow try to see some pattern how the numbers are generated. At every 2<sup>x</sup> where x = [0,n) element you put mirror of `x` index and copy the same number of elements in reverse order as you see them in mirror and add 2<sup>x</sup> to it.\\n\\nLet me explain it with an example\\n\\nInitial element that will be present in the list = [0]\\n\\nlist = [0]\\n\\nNow put mirror of length x = 0 at 2<sup>0</sup>=1 index \\n```\\n0\\n-\\n```\\n\\nNow  copy the same number of elements and add 2<sup>0</sup> to it\\n```\\n0\\n-\\n0 + 1 = 1\\n```\\n\\nthis was for n = 1, now for n=2 lets do the same thing, put mirror of length x = 1 at 2<sup>1</sup>=2 index and add 2<sup>1</sup> to it.\\n\\n```\\n0 = 00\\n1 = 01\\n-\\n1(binary) + 10 (binary)  = 11\\n0(binary) + 10 (binary) = 10\\n```\\n\\nNow for 2 bit, the gray number in decimal format looks like\\n```\\n0\\n1\\n3\\n2\\n```\\n\\nNow for 3 bit, lets do the same thing, put mirror at length x = 2 at 2<sup>2</sup> index and add 2<sup>2</sup> to all of them\\n\\n```\\n00 = 000\\n01 = 001\\n11 = 011\\n10 = 010\\n--\\n10 (binary) + 100 (binary) = 110\\n11 (binary) + 100 (binary) = 111\\n01 (binary) + 100 (binary) = 101\\n00 (binary) + 100 (binary) = 100\\n```\\n\\nand so on. \\n\\nIf it is still not clear please comment below I\\'ll try to make it more clearer by adding more examples\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Handling negative n\\n        if (n < 0) {\\n            return list;\\n        }\\n\\t\\t// Initial value\\n        list.add(0);\\n\\t\\t\\n        int mirror = 0;\\n        while (mirror < n) {\\n            int count = list.size();\\n            for (int i = count-1; i >= 0; i--) {\\n                list.add((1 << mirror) | list.get(i)); // this will get the value from list and add 2^mirror to the number as we discussed above\\n            }\\n            mirror++;\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nPlease do upvote if the explaination helped you in understanding the solution.",
                "solutionTags": [],
                "code": "```\\n0\\n-\\n```\n```\\n0\\n-\\n0 + 1 = 1\\n```\n```\\n0 = 00\\n1 = 01\\n-\\n1(binary) + 10 (binary)  = 11\\n0(binary) + 10 (binary) = 10\\n```\n```\\n0\\n1\\n3\\n2\\n```\n```\\n00 = 000\\n01 = 001\\n11 = 011\\n10 = 010\\n--\\n10 (binary) + 100 (binary) = 110\\n11 (binary) + 100 (binary) = 111\\n01 (binary) + 100 (binary) = 101\\n00 (binary) + 100 (binary) = 100\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Handling negative n\\n        if (n < 0) {\\n            return list;\\n        }\\n\\t\\t// Initial value\\n        list.add(0);\\n\\t\\t\\n        int mirror = 0;\\n        while (mirror < n) {\\n            int count = list.size();\\n            for (int i = count-1; i >= 0; i--) {\\n                list.add((1 << mirror) | list.get(i)); // this will get the value from list and add 2^mirror to the number as we discussed above\\n            }\\n            mirror++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29978,
                "title": "java-short-code-with-explanation",
                "content": "how to go from  i = 1 [0,1] to i=2?\\n\\n1.copy list of i=1 in reverse order\\n\\n0, 1 || 1, 0\\n\\n\\n2 append \"1\" in front all numbers of the copy\\n\\n0, 1 || 11, 10\\n \\n\\n\\n\\n       public class Solution {\\n            public List<Integer> grayCode(int n) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(0);\\n                int mask = 1;\\n                for (int i = 1; i <= n; i++) {\\n                    // change from len i-1 to i\\n                    for (int j = list.size() - 1; j >= 0; j--) {\\n                        list.add(list.get(j) | mask);\\n                    }\\n                    mask <<= 1;\\n                }\\n                return list;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public List<Integer> grayCode(int n) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(0);\\n                int mask = 1;\\n                for (int i = 1; i <= n; i++) {\\n                    // change from len i-1 to i\\n                    for (int j = list.size() - 1; j >= 0; j--) {\\n                        list.add(list.get(j) | mask);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 30108,
                "title": "java-solution-use-a-stack-easy-to-figure-out-simple-and-interesting",
                "content": "    0\\t\\t0\\n    1\\t\\t1\\n    \\n    00  \\t\\t0\\n    01\\t\\t1\\t\\t+1\\n    11\\t\\t3\\t\\t--------\\n    10\\t\\t2\\t\\t-1\\n    \\n    000\\t\\t0\\n    001\\t\\t1\\t\\t+1\\n    011\\t\\t3\\t\\t+2\\n    010\\t\\t2\\t\\t-1\\t\\n    110\\t\\t6\\t\\t-----------\\n    111\\t\\t7\\t\\t+1\\t\\t\\t\\n    101\\t\\t5\\t\\t-2\\n    100\\t\\t4\\t\\t-1\\n    \\n    \\n    0000\\t\\t0\\n    0001\\t\\t1\\t\\t+1\\n    0011\\t\\t3\\t\\t+2\\n    0010\\t\\t2\\t\\t-1\\n    0110\\t\\t6\\t\\t+4\\n    0111\\t\\t7\\t\\t+1\\n    0101\\t\\t5\\t\\t-2\\n    0100\\t\\t4\\t\\t-1\\n    1100\\t\\t12\\t\\t-----------\\n    1101\\t\\t13\\t\\t+1\\n    1111\\t\\t15\\t\\t+2\\t\\n    1110\\t\\t14\\t\\t-1\\n    1010\\t\\t10\\t\\t-4\\n    1011\\t\\t11\\t\\t+1\\n    1001\\t\\t9\\t\\t-2\\n    1000\\t\\t8\\t\\t-1\\n\\n\\nFrom the above example, I believe you will find out that why use a stack here, all the post half is the pre half plus the Math.pow(2, i) in the symmetric form!!!\\n\\n\\n    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<Integer> stack = new Stack<Integer>();\\n            list.add(0);\\n            int i = 0;\\n            while(i < n) {\\n                int len = list.size();\\n                int inc = (int)(Math.pow(2, i));\\n                for(int j=0; j<len; j++) {\\n                    stack.push(list.get(j));\\n                }\\n                while(!stack.isEmpty()) {\\n                    list.add(stack.pop() + inc);\\n                }\\n                i++;\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<Integer> stack = new Stack<Integer>();\\n            list.add(0);\\n            int i = 0;\\n            while(i < n) {\\n                int len = list.size();\\n                int inc = (int)(Math.pow(2, i));\\n                for(int j=0; j<len; j++) {\\n                    stack.push(list.get(j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2697032,
                "title": "c-java-go-3-line-code-easy-to-understand",
                "content": "***Explain:***\\nGray code is a binary numeral system where two successive values differ in only one bit.\\nFor example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100.\\nFor more details read this blog ([Gray Code](https://cp-algorithms.com/algebra/gray-code.html))\\n\\n**C++ Solution:** \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        for(int i=0; i<1<<n; i++) {\\n            v.push_back(i^i>>1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n\\n\\n**JAVA Solution:**\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n       List<Integer> v = new ArrayList<Integer>();\\n        for(int i=0; i<1<<n; i++) {\\n            v.add(i^(i>>1));\\n        }\\n        return v;\\n    }\\n}\\n```\\n\\n\\n**GO Solution:**\\n\\n```\\nfunc grayCode(n int) []int {\\n    var v []int\\n    for i:=0; i<1<<n; i++ {\\n        v =append(v, i^(i>>1));\\n    }\\n    return v;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        for(int i=0; i<1<<n; i++) {\\n            v.push_back(i^i>>1);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n       List<Integer> v = new ArrayList<Integer>();\\n        for(int i=0; i<1<<n; i++) {\\n            v.add(i^(i>>1));\\n        }\\n        return v;\\n    }\\n}\\n```\n```\\nfunc grayCode(n int) []int {\\n    var v []int\\n    for i:=0; i<1<<n; i++ {\\n        v =append(v, i^(i>>1));\\n    }\\n    return v;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308829,
                "title": "gray-code-bitmanip-c",
                "content": "### What\\'s the Problem?\\nIn this problem, we have to frame a list of numbers from 0 to 2^n, such that the adjacent numbers and the first and last numbers should have only 1 bit difference.\\n\\n### What to Do?\\nFor any number, if we divide it by 2, it gets 1 bit shifted. \\nEg: 2 = 00**10**\\n2/2 = 1 = 00**01**\\n\\nif the values are XORed, it gives the number with 1 bit difference of the previous number.\\nEg. \\n0 ^ (0/2) = 0 = 00**00**\\n1 ^ (1/2) = 1 ^ 0 = 1 = 00**01**\\n2 ^ (2/2) = 2 ^ 1 = 3 = 00**11**\\n3 ^ (3/2) = 3 ^ 1 = 2 = 00**10**\\n\\nThis idea can be used to solve the problem.\\n\\nHope that Helps!\\n\\n### My C++ Code:\\n```\\nvector<int> grayCode(int n) {\\n        int x = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < (1 << n); ++i) {\\n            x = (i/2) ^ i;\\n            ans.push_back(x);\\n        } return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> grayCode(int n) {\\n        int x = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < (1 << n); ++i) {\\n            x = (i/2) ^ i;\\n            ans.push_back(x);\\n        } return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971284,
                "title": "bits-backtracking-explanation-visual-python",
                "content": "## Use Traditional Backtrack Template\\n\\nTL;DR using a traditional backtracking template \\n\\n```python\\n  def grayCode(self, n: int) -> List[int]:\\n\\t\\tresult = [0]  \\n\\t\\t# 2^n possible gray codes \\n\\t\\tself.backtrack(result, n, 0, pow(2, n))\\n\\t\\treturn result\\n\\t\\t\\n  def backtrack(self, result, n, curr, size):\\n\\t\\t# all gray codes same length \\n        if len(result) == size: return \\n        for i in range(n):\\n            mask = 1 << i \\n\\t\\t\\t#generate candidate by flipping left most bit\\n            candidate = curr ^ mask\\n\\t\\t\\t# avoid duplicates \\n            if candidate not in result:\\n                result.append(int(candidate))\\n                self.backtrack(result, n, candidate, size\\n\\t\\t\\t\\t# reduce number of recursive calls made\\n                if len(result) == size: return \\n```\\n\\n### Walkthrough\\n\\n![image](https://assets.leetcode.com/users/images/0b9fd653-8a79-4918-bac7-354f33a9f9a1_1607888555.8872228.png)\\n\\n### Explanation\\n\\nGray Code: to get to next code in seqeunce, flip exactly 1 bit.\\nour return values should be the value the gray code represents in binary. \\n\\n```      \\nGray Code -> Return Value \\n00 ->  0\\n01 ->  1\\n11 ->  3\\n10 ->  2\\n```\\n##### Number of Possible Gray Codes\\nGiven ```N``` bits, there are ```2^N``` possible gray codes. All adjacent gray codes in the sequence differ by ```1``` bit. for every bit we make a choice to turn this bit on or off. our decision is ***binary*** and this is done for all ```N``` bits. Our result will contain ```2^N``` gray codes. \\n\\n#### Algorithm\\n1. To generate the next candidate in the sequence, a single bit must be flipped. we flip the left most bit (excluding leading zeros). \\n\\n2. To flip the left most bit we use a mask, the last known candidate, and the XOR operation. \\n3. If we ever generate a candidate that has aready been seen, it is not added to the result and no recursive call is made. instead generate a new candidate, by generating a larger mask. \\n\\t* Becuase we only make recursive call when a valid candidate is found and then immedaitely return, there is no need for the traditional undoing found in most backtracking problems. all that must be done is to ignore duplicate codes generated. \\n\\nThis problem isnt as ```backtracking like``` as i initially thought. \\n\\n\\n***Note:***\\nthe recursion tree ends up always resulting in a linked list regardless of N, because we keep going as deep as possible until we have all possible gray codes.\\n\\n\\n[code courtesy of fabrizio3](https://leetcode.com/problems/gray-code/discuss/30087/Backtracking-Solution)\\n\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```python\\n  def grayCode(self, n: int) -> List[int]:\\n\\t\\tresult = [0]  \\n\\t\\t# 2^n possible gray codes \\n\\t\\tself.backtrack(result, n, 0, pow(2, n))\\n\\t\\treturn result\\n\\t\\t\\n  def backtrack(self, result, n, curr, size):\\n\\t\\t# all gray codes same length \\n        if len(result) == size: return \\n        for i in range(n):\\n            mask = 1 << i \\n\\t\\t\\t#generate candidate by flipping left most bit\\n            candidate = curr ^ mask\\n\\t\\t\\t# avoid duplicates \\n            if candidate not in result:\\n                result.append(int(candidate))\\n                self.backtrack(result, n, candidate, size\\n\\t\\t\\t\\t# reduce number of recursive calls made\\n                if len(result) == size: return \\n```\n```      \\nGray Code -> Return Value \\n00 ->  0\\n01 ->  1\\n11 ->  3\\n10 ->  2\\n```\n```N```\n```2^N```\n```1```\n```N```\n```2^N```\n```backtracking like```",
                "codeTag": "Python3"
            },
            {
                "id": 534055,
                "title": "python-5-line-solution-without-prior-knowledge-of-gray-code",
                "content": "If we already have the array R<sub>n</sub> consisting of 2<sup>n</sup> numbers of n bits in the gray code order, then the next 2<sup>n</sup> numbers is just the reversed R<sub>n</sub> with additional value 2<sup>n</sup> on every number.\\n```\\ndef grayCode(self, n: int) -> List[int]:\\n    b, r = 1, [0]\\n    for _ in range(n):\\n        r += [i|b for i in reversed(r)]\\n        b <<= 1\\n    return r\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef grayCode(self, n: int) -> List[int]:\\n    b, r = 1, [0]\\n    for _ in range(n):\\n        r += [i|b for i in reversed(r)]\\n        b <<= 1\\n    return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 29909,
                "title": "javascript-recursive-solution-using-reflected-gray-code",
                "content": "```\\nvar grayCode = function(n) {\\n    if (n === 0) return [0];\\n    const res = grayCode(n - 1);\\n    const mask = 1 << n - 1;\\n    for (let i = res.length - 1; i >= 0; i--) {\\n        res.push(res[i] | mask);\\n    }\\n    return res;\\n};\\n```\\nThe strategy is described [here](https://en.wikipedia.org/wiki/Gray_code#Constructing_an_n-bit_Gray_code) and can also be done iteratively.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar grayCode = function(n) {\\n    if (n === 0) return [0];\\n    const res = grayCode(n - 1);\\n    const mask = 1 << n - 1;\\n    for (let i = res.length - 1; i >= 0; i--) {\\n        res.push(res[i] | mask);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30027,
                "title": "1ms-java-solution-with-explaination",
                "content": "    public class Solution {\\n    //analyze the pattern\\n    //n=0  -> 0\\n    //n=1  -> 0, 1\\n    //n=2  -> (00,  01),  (10,  11)\\n    //n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)\\n    \\n    //so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)\\n    //                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)\\n    \\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList();\\n        result.add(0);\\n        \\n        for(int i=1; i<=n; i++){\\n            int front=1;\\n            //Create the correct value for binary format (10...0) which the value has i digi\\n            //so shift 1 to right (i-1) times\\n            for(int j=1; j<i; j++){\\n                front = front<<1;\\n            }\\n            \\n            //add the new generated value to the result list\\n            //the new generated value is the last result add front value\\n            int size=result.size();\\n            //we want to loop through the (n-1) result from end to start. This is just because want to make the test case match the Leetcode answer. You can use other way loop through the (n-1) result.\\n            for(int k=size-1; k>=0; k--){\\n                result.add(result.get(k)+front);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //analyze the pattern\\n    //n=0  -> 0\\n    //n=1  -> 0, 1\\n    //n=2  -> (00,  01),  (10,  11)\\n    //n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)\\n    \\n    //so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)\\n    //                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)\\n    \\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList();\\n        result.add(0);\\n        \\n        for(int i=1; i<=n; i++){\\n            int front=1;\\n            //Create the correct value for binary format (10...0) which the value has i digi\\n            //so shift 1 to right (i-1) times\\n            for(int j=1; j<i; j++){\\n                front = front<<1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30109,
                "title": "backtracking-solution",
                "content": "    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            helper(result,list,n);\\n            return result;\\n        }\\n        public void helper(List<Integer> result,List<Integer> list,int n){\\n            \\n            if(list.size() == Math.pow(2,n)){\\n                result.addAll(list);\\n                return;\\n            }\\n            int last = list.get(list.size() - 1);\\n            \\n            for(int i = 0; i < n; i++){\\n                int off = 1 << i;\\n                int cur = last ^ off;\\n                \\n                if(list.contains(cur)) continue;\\n                \\n                list.add(cur);\\n                helper(result,list,n);\\n                \\n                if(result.size() > 0) return;\\n                list.remove(list.size() - 1);\\n            }\\n            \\n        } \\n    }\\n    }\\n\\nUsing backtracking without knowing gray code knowledge. Find one solution and return.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            helper(result,list,n);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3433391,
                "title": "c-java-remember-this-formula",
                "content": "## Explanation\\nIt is not very intuitive to come up with a solution for this problem in an interview if you haven\\'t solved this already. But there is a simple formula/ technique to remember to solve this one without much hassle !!\\n\\nIf n = 0 => {0}\\nIf n = 1 => {0,1} `{0 , 0 + pow(2,0)}`\\nIf n = 2 => {0,1,3,2} `{0 , 1 , 1 + pow(2,1) , 0 + pow(2,1)}`\\nIf n = 3 => {0,1,3,2,6,7,5,4} `{0 , 1 , 3 , 2 , 2 + pow(2,2) , 3 + pow(2,2) , 1 + pow(2,2) , 0 + pow(2,2)}`\\n\\nHere you can observe a pattern !!\\n\\nAt each step where we\\'re supposed to calculate the gray code of `i` , **Reverse the gray code list of i-1 and add the value pow(2,i-1) to all the elements of the reversed list. Append the modified and reversed list to the (i-1) list.**\\n\\n## Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res{0};\\n        for(int i = 1; i <= n; i++) {\\n            vector<int> rev = res;\\n            reverse(begin(rev), end(rev));\\n            int val = pow(2,i-1);\\n            for(int v : rev) res.push_back(v+val);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res{0};\\n        for(int i = 1; i <= n; i++) {\\n            vector<int> rev = res;\\n            reverse(begin(rev), end(rev));\\n            int val = pow(2,i-1);\\n            for(int v : rev) res.push_back(v+val);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630427,
                "title": "2-lines-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>current;\\n\\t\\t/*\\n\\t\\t0 1 2 3 4 5 6 7 -- in range(0,2^n-1) \\n\\t\\t0 1 3 2 6 7 5 4 - required answer order(now observe difference with xor\\n\\t\\t--------------------------------------------------\\n\\t\\t0 0 1 1 2 2 3 3  - for getting these values i >> 1\\n\\t\\t*/\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            current.push_back(i ^ i>>1);\\n        }\\n        return current;\\n        \\n    }\\n};\\n```\\n**Find helpful Upvote it**\\n**For Detailed DSA Applications refer to respective README files**\\nhttps://github.com/teja963/Advanced-DSA",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>current;\\n\\t\\t/*\\n\\t\\t0 1 2 3 4 5 6 7 -- in range(0,2^n-1) \\n\\t\\t0 1 3 2 6 7 5 4 - required answer order(now observe difference with xor\\n\\t\\t--------------------------------------------------\\n\\t\\t0 0 1 1 2 2 3 3  - for getting these values i >> 1\\n\\t\\t*/\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            current.push_back(i ^ i>>1);\\n        }\\n        return current;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334453,
                "title": "java-simple-and-easy-iterative-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        List<Integer> codes = new ArrayList((1 << n));\\n        codes.add(0);\\n        \\n        for(int i = 0; i < n; i++){\\n            int size = codes.size();\\n            \\n            //most significant bit\\n            int msb = 1 << i;\\n            \\n            for(int j = size - 1; j >= 0; j--){\\n                //append msb\\n                int num = codes.get(j) | msb;\\n                \\n                codes.add(num);\\n            }\\n        }\\n        \\n        return codes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        List<Integer> codes = new ArrayList((1 << n));\\n        codes.add(0);\\n        \\n        for(int i = 0; i < n; i++){\\n            int size = codes.size();\\n            \\n            //most significant bit\\n            int msb = 1 << i;\\n            \\n            for(int j = size - 1; j >= 0; j--){\\n                //append msb\\n                int num = codes.get(j) | msb;\\n                \\n                codes.add(num);\\n            }\\n        }\\n        \\n        return codes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319275,
                "title": "python-easy-to-understand-3-line-recursive-solution",
                "content": "We see the pattern:\\n```\\n1: [0,1]\\n2: [00,01,11,10]\\n3: [000,001,011,010,110,111,101,100]\\n```\\nNotice the following recursive relation:\\n```\\ngrayCode(n) = [grayCode(n-1), new_part]\\n```\\n`new_part` consists of `1` added to the left of each item in reversed sequence of `grayCode(n-1)`.\\n\\nThis leads us to the following code:\\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==1: return [0,1]\\n        prev = self.grayCode(n-1)\\n        return prev + [2**(n-1)+i for i in prev[::-1]]\\n```\\nTime complexity: `O(n)`.",
                "solutionTags": [],
                "code": "```\\n1: [0,1]\\n2: [00,01,11,10]\\n3: [000,001,011,010,110,111,101,100]\\n```\n```\\ngrayCode(n) = [grayCode(n-1), new_part]\\n```\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==1: return [0,1]\\n        prev = self.grayCode(n-1)\\n        return prev + [2**(n-1)+i for i in prev[::-1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309277,
                "title": "easy-to-understand-solution",
                "content": "The idea is that we can leverage the fact that the last bits reverse when we move from n-1 to n and we have to concat the bit `1` as the prefix.\\n\\nEg:\\nFor `n=2`: Gray-code sequence is\\n```\\n00\\n01\\n11\\n10\\n```\\n\\nNow for `n=3` we copy the above sequence in reverse order and add prefix `0` to existing codes and `1` to newly generated codes\\n```\\n0 | 00\\n0 | 01\\n0 | 11\\n0 | 10\\n-------\\n1 | 10\\n1 | 11\\n1 | 01\\n1 | 00\\n```\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        String[] grayCodes = binaryGrayCodes(n);\\n        List<Integer> result = new ArrayList<>();\\n        for(String grayCode: grayCodes){\\n            result.add(Integer.parseInt(grayCode,2));\\n        }\\n        return result;\\n    }\\n    \\n    private String[] binaryGrayCodes(int n) {\\n        int total = (int) Math.pow(2,n);\\n        String[] grayCode = new String[total];\\n        grayCode[0]=\"0\";\\n        grayCode[1]=\"1\";\\n        \\n        for(int i=2;i<=n;i++){\\n            int start = (int) Math.pow(2,i-1);\\n            for(int j=0;j<start;j++){\\n                if(grayCode[start-j-1].length()<i-1){\\n                    grayCode[start-j-1] = \"0\".concat(grayCode[start-j-1]);\\n                }\\n                grayCode[start+j]=\"1\".concat(grayCode[start-j-1]);\\n            }\\n        }\\n        \\n        return grayCode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n00\\n01\\n11\\n10\\n```\n```\\n0 | 00\\n0 | 01\\n0 | 11\\n0 | 10\\n-------\\n1 | 10\\n1 | 11\\n1 | 01\\n1 | 00\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        String[] grayCodes = binaryGrayCodes(n);\\n        List<Integer> result = new ArrayList<>();\\n        for(String grayCode: grayCodes){\\n            result.add(Integer.parseInt(grayCode,2));\\n        }\\n        return result;\\n    }\\n    \\n    private String[] binaryGrayCodes(int n) {\\n        int total = (int) Math.pow(2,n);\\n        String[] grayCode = new String[total];\\n        grayCode[0]=\"0\";\\n        grayCode[1]=\"1\";\\n        \\n        for(int i=2;i<=n;i++){\\n            int start = (int) Math.pow(2,i-1);\\n            for(int j=0;j<start;j++){\\n                if(grayCode[start-j-1].length()<i-1){\\n                    grayCode[start-j-1] = \"0\".concat(grayCode[start-j-1]);\\n                }\\n                grayCode[start+j]=\"1\".concat(grayCode[start-j-1]);\\n            }\\n        }\\n        \\n        return grayCode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30009,
                "title": "11-lines-c-solution-4ms",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int  len = 1 << n;\\n            vector<int> res(len,0);\\n            for(int i = 0;i != len;++i){\\n                res[i] =i ^ (i >> 1); \\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int  len = 1 << n;\\n            vector<int> res(len,0);\\n            for(int i = 0;i != len;++i){\\n                res[i] =i ^ (i >> 1); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30046,
                "title": "ac-python-44ms-solution",
                "content": "    def grayCode(self, n):\\n        ans = [0]\\n        for i in xrange(n):\\n            for j in xrange(len(ans) - 1, -1, -1):\\n                ans.append(1 << i | ans[j])\\n        return ans\\n\\n\\n    # 12 / 12 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 92.86%\\n\\n\\nAppend a bit of 1 in front of on every number to generate next batch.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def grayCode(self, n):\\n        ans = [0]\\n        for i in xrange(n):\\n            for j in xrange(len(ans) - 1, -1, -1):\\n                ans.append(1 << i | ans[j])\\n        return ans\\n\\n\\n    # 12 / 12 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 92.86%\\n\\n\\nAppend a bit of 1 in front of on every number to generate next batch.",
                "codeTag": "Python3"
            },
            {
                "id": 30079,
                "title": "this-is-the-standard-backtracking-method",
                "content": "Well, I write a method using standard backtracking way. \\n\\n    class Solution {\\n    public:\\n        int Bit2Int(bitset<32> &c, int n)\\n        {\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                sum <<= 1;\\n                sum += c[i];\\n            }\\n            return sum;\\n        }\\n    \\n        void backtrack(bitset<32> &c, int k, int n, vector<int> &result)\\n        {\\n            if(++k == n)\\n                result.push_back(Bit2Int(c, n));\\n            else\\n            {\\n                backtrack(c, k, n, result);\\n                c.flip(k);\\n                backtrack(c, k, n, result);\\n            }\\n        }\\n    \\n        vector<int> grayCode(int n) {\\n            if(!n)\\n                return vector<int>{0};\\n            else if(n == 1)\\n                return vector<int>{0, 1};\\n            vector<int> result;\\n            bitset<32> c;\\n            backtrack(c, -1, n, result);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        int Bit2Int(bitset<32> &c, int n)\\n        {\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                sum <<= 1;\\n                sum += c[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3065429,
                "title": "simple-solution-in-c-with-explanation",
                "content": "# Intuition\\nThis was a pattern I noticed on writing out some examples:\\nn=1 -> 0,1\\nn=2 -> **0,1**,3,2\\nn=3 -> **0,1,3,2**,6,7,5,4\\nn=4 -> **0,1,3,2,6,7,5,4**,12,13,15,14,10,11,9,8\\n\\nNoticed for all cases above n>1, it took the first part from the previous case for n-1 and for the remaining half, the values were formed by going through the list in reverse order and adding a factor(pow(2,n-1)) to each number.\\n\\nFor n=3,\\nthe first bold half is taken from n=2 -> 0,1,3,2 and we added 4 (pow(2,2)) to each number from the reverse order. i.e we appended 2+4=**6**, 3+4=**7**, 1+4=**5**, 0+4=**4** in that specific order.\\n\\n# Approach\\nWe used the logic derived at the intution to implement the code below:\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        int iteration = 1;\\n        int fac = 1;\\n        vector<int> result{0, 1};\\n\\n        for( ; iteration < n ; iteration++ ){\\n            fac = fac*2;\\n            int l = result.size()-1;\\n            for( ; l>=0 ; l-- ){\\n                int val = result[l] + fac;\\n                result.push_back(val);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        int iteration = 1;\\n        int fac = 1;\\n        vector<int> result{0, 1};\\n\\n        for( ; iteration < n ; iteration++ ){\\n            fac = fac*2;\\n            int l = result.size()-1;\\n            for( ; l>=0 ; l-- ){\\n                int val = result[l] + fac;\\n                result.push_back(val);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769433,
                "title": "java-solutionjs-easy",
                "content": "```\\nclass Solution \\n{\\n\\tpublic List<Integer> grayCode(int n) \\n\\t{\\n\\t\\t// 0: [0]\\n\\t\\t// 1: [0,1]\\n\\t\\t// 2: [0,1,3,2]\\n\\t\\t// 3: [0,1,3,2,6,7,5,4]\\n\\t\\t// 4: [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n\\n\\t\\tint edge = 1 << n; // (1 << n) == 2 ** n\\n\\t\\tInteger[] ans = new Integer[edge];\\n\\t\\tans[0] = 0;\\n\\t\\tint lngth = 1; // is the length of the previous block\\n\\t\\tint i, j = 1;\\n\\n\\t\\twhile (j != edge)\\n\\t\\t{\\n\\t\\t\\tlngth = j;\\n\\n\\t\\t\\tfor(i = lngth - 1; i >= 0; i--)\\n\\t\\t\\t\\tans[j++] = ans[i] | lngth; // ans[i] | lngth  == ans[i] + lngth \\n\\t\\t}\\n\\n\\t\\treturn Arrays.asList(ans);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n\\tpublic List<Integer> grayCode(int n) \\n\\t{\\n\\t\\t// 0: [0]\\n\\t\\t// 1: [0,1]\\n\\t\\t// 2: [0,1,3,2]\\n\\t\\t// 3: [0,1,3,2,6,7,5,4]\\n\\t\\t// 4: [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n\\n\\t\\tint edge = 1 << n; // (1 << n) == 2 ** n\\n\\t\\tInteger[] ans = new Integer[edge];\\n\\t\\tans[0] = 0;\\n\\t\\tint lngth = 1; // is the length of the previous block\\n\\t\\tint i, j = 1;\\n\\n\\t\\twhile (j != edge)\\n\\t\\t{\\n\\t\\t\\tlngth = j;\\n\\n\\t\\t\\tfor(i = lngth - 1; i >= 0; i--)\\n\\t\\t\\t\\tans[j++] = ans[i] | lngth; // ans[i] | lngth  == ans[i] + lngth \\n\\t\\t}\\n\\n\\t\\treturn Arrays.asList(ans);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104825,
                "title": "c-short-recursive-approach-without-bit-manipulation",
                "content": "To calculate Graycode(n), we basically need to prefix 0 to each number GrayCode(n-1), prefix 1 to each number in reversed GrayCode(n-1), and add them up. \\n\\nPrefixing 1 can be done by adding 2^(n-1).\\n\\nExample GrayCode(2) to GrayCode(3) :\\n0 00\\n0 01\\n0 11\\n0 10\\n1 10\\n1 11\\n1 01\\n1 00\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1){\\n            return {0,1};\\n        }\\n        vector<int> ans = grayCode(n-1);\\n        int ans_size = ans.size();\\n        int a = pow(2,n-1);\\n        for(int i=ans_size-1;i>=0; i--){\\n            ans.push_back(ans[i]+a);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nI hope this helps :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1){\\n            return {0,1};\\n        }\\n        vector<int> ans = grayCode(n-1);\\n        int ans_size = ans.size();\\n        int a = pow(2,n-1);\\n        for(int i=ans_size-1;i>=0; i--){\\n            ans.push_back(ans[i]+a);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492687,
                "title": "java-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        if(n == 1)\\n        {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(0);list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<>();\\n        \\n        for(int i=0;i<pres.size();i++)\\n            mres.add(0+2*pres.get(i));\\n        \\n        for(int i=pres.size()-1;i>=0;i--)\\n            mres.add(1+2*pres.get(i));\\n        \\n        return mres;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        if(n == 1)\\n        {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(0);list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<>();\\n        \\n        for(int i=0;i<pres.size();i++)\\n            mres.add(0+2*pres.get(i));\\n        \\n        for(int i=pres.size()-1;i>=0;i--)\\n            mres.add(1+2*pres.get(i));\\n        \\n        return mres;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309954,
                "title": "c-mirroring-previous-result-solution-explained-100-time-95-space",
                "content": "The tricky part of this problem is to spot a pattern.\\n\\nLet\\'s assume we have a given 2<sup>n</sup> elements that correctly match the requirements, like:\\n\\n```cpp\\n0, 1, 3, 2\\n```\\n\\nYou can find the next expected 2<sup>n</sup> of them (thus going up to 2<sup>n + 1</sup>) by mirroring those numbers and adding 2<sup>n</sup> to all of them, thus obtaining:\\n\\n```cpp\\n0, 1, 3, 2, 6, 7, 5, 4\\n// ie: 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4\\n```\\n\\nNow, we that in mind, we can start working on what we know we need to do, creating a variable `res` already of the correct size (2<sup>n - 1</sup> or rather `2 << --n`), to avoid reallocations.\\n\\nWe will then loop `n + 1` times, with `a` and `b` (the latter initially set to `0`) and:\\n* set `a` to be `b + 1` -  both the starting index and the added value of our sequence;\\n* right shift `b` by `1` position;\\n* add `1` to `b` as its least significant bit;\\n* loop `a` times with `j` and having `k` initially set to `b`, increasing `j` and decreasing `k` at each iteration and:\\n\\t* set `res[k]` to be `res[j] + a` (with `j` and `k` pointing at mirrored cells in the same subsequence).\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        // support variables\\n        vector<int> res(2 << --n);\\n        for (int i = 0, a, b = 0; i <= n; i++) {\\n            // updating variables\\n            a = b + 1;\\n            b <<= 1;\\n            ++b;\\n            // building the next a elements as a mirror of the previous a, plus a\\n            for (int j = 0, k = b; j < a; j++, k--) res[k] = res[j] + a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n0, 1, 3, 2\\n```\n```cpp\\n0, 1, 3, 2, 6, 7, 5, 4\\n// ie: 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        // support variables\\n        vector<int> res(2 << --n);\\n        for (int i = 0, a, b = 0; i <= n; i++) {\\n            // updating variables\\n            a = b + 1;\\n            b <<= 1;\\n            ++b;\\n            // building the next a elements as a mirror of the previous a, plus a\\n            for (int j = 0, k = b; j < a; j++, k--) res[k] = res[j] + a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308565,
                "title": "c-simple-and-short-solution-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res = {0};\\n        int size;\\n        \\n        for (int i = 0; i < n; i++) {\\n            size = res.size();\\n            for (int j = size - 1; j >= 0; j--) {\\n                res.push_back(res[j] | 1 << i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res = {0};\\n        int size;\\n        \\n        for (int i = 0; i < n; i++) {\\n            size = res.size();\\n            for (int j = size - 1; j >= 0; j--) {\\n                res.push_back(res[j] | 1 << i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504836,
                "title": "javascript-solution",
                "content": "### The idea\\n*Based on top voted discussion*\\nSimulation:\\n| n=0 | n=1 | n=2 | n=3 |\\n|----:|----:|----:|----:|\\n| 000 | 000 | 000 | 000 |\\n|     | 001 | 001 | 001 |\\n|     |     | 011 | 011 |\\n|     |     | 010 | 010 |\\n|     |     |     | **110** |\\n|     |     |     | **111** |\\n|     |     |     | **101** |\\n|     |     |     | **100** |\\n1. From observation, we can see that at every level, we keep the previous results as the first part. The second part is just adding `1` at the begining in reverse order.\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        for (let j=arr.length-1;j>=0;j--) {\\n            arr.push(arr[j] | 1<<i);\\n        }\\n    }\\n    return arr;\\n};\\n```\\n**Shorter Ver.**\\n```\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        arr.push(...arr.map((v)=>v|1<<i).reverse());\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        for (let j=arr.length-1;j>=0;j--) {\\n            arr.push(arr[j] | 1<<i);\\n        }\\n    }\\n    return arr;\\n};\\n```\n```\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        arr.push(...arr.map((v)=>v|1<<i).reverse());\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485439,
                "title": "java-solution-with-explanation-7-lines-code",
                "content": "This problem is not complicated, we just need to find the regularity.\\nn = 1: (0, 1)-> (0,1);\\nn = 2: (00, 01, 11, 10)->(0, 1, 3, 2);\\nn = 3: (000, 001, 011, 010, 110, 111, 101, 100) -> (0, 1, 3, 2, 6, 7, 5, 4);\\n\\nAt first we compare n = 1 and n = 2. we find that :\\n0 appends (0,1) = (00, 01);  0 + 0 = 0, 0 + 1 = 1; \\nrevese (0,1) -> (1, 0)\\n1 appends (1,0) = (11, 10);  2 + 1= 3,  2 + 0 = 2; \\n\\nThen we compare n = 2 and n =3. we find that:\\n0 appends (00, 01, 11, 10) = (000, 001, 011, 010); 0 + 0 = 0, 0 + 1 = 1, 0 + 3 = 3, 0 + 2 = 2;\\nrevese (00, 01, 11, 10) -> (10, 11, 01, 00)\\n1 appends (10, 11, 01, 00) = (110, 111, 101, 100); 4 + 2 = 6, 4 + 3 = 7, 4 + 1 = 5, 4 + 0 = 4;\\nThe regularity is very obvious.\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = ans.size() - 1; j >= 0; j--){\\n                ans.add(ans.get(j) + (int)Math.pow(2, i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = ans.size() - 1; j >= 0; j--){\\n                ans.add(ans.get(j) + (int)Math.pow(2, i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393991,
                "title": "java-beats-100-with-explaination",
                "content": "```\\n/**\\n * n=0, \\u987A\\u5E8F:0\\n * n=1, \\u987A\\u5E8F:0,1\\n * n=2, \\u987A\\u5E8F:00,01,11,10\\n * n=3, \\u53EF\\u4EE5\\u8FD9\\u4E48\\u6784\\u6210,\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F110(100 + 10),\\u5373\\u7B2Cn\\u4F4D\\u7F6E1,\\u52A0\\u4E0An=2\\u7684\\u6700\\u540E\\u4E00\\u4E2A\\u6570;\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5C31\\u662F111(100+11),\\u5982\\u6B64\\u9006\\u5E8F\\u904D\\u5386\\u5B8Cn=2\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u5373\\u53EF.\\n * n=4, \\u540Cn=3\\u7684\\u89C4\\u5F8B.\\n*/\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(1<<n);\\n        res.add(0);\\n        if (n == 0) {\\n            return res;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int lastIdx = res.size() - 1;\\n            int add = 1 << (i - 1);\\n            for (int j = lastIdx; j >= 0; j--) {\\n                res.add(add + res.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * n=0, \\u987A\\u5E8F:0\\n * n=1, \\u987A\\u5E8F:0,1\\n * n=2, \\u987A\\u5E8F:00,01,11,10\\n * n=3, \\u53EF\\u4EE5\\u8FD9\\u4E48\\u6784\\u6210,\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F110(100 + 10),\\u5373\\u7B2Cn\\u4F4D\\u7F6E1,\\u52A0\\u4E0An=2\\u7684\\u6700\\u540E\\u4E00\\u4E2A\\u6570;\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5C31\\u662F111(100+11),\\u5982\\u6B64\\u9006\\u5E8F\\u904D\\u5386\\u5B8Cn=2\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u5373\\u53EF.\\n * n=4, \\u540Cn=3\\u7684\\u89C4\\u5F8B.\\n*/\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(1<<n);\\n        res.add(0);\\n        if (n == 0) {\\n            return res;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int lastIdx = res.size() - 1;\\n            int add = 1 << (i - 1);\\n            for (int j = lastIdx; j >= 0; j--) {\\n                res.add(add + res.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280620,
                "title": "java-beats-100-and-100-memoryemory",
                "content": "reference \\uFF1Ahttps://en.wikipedia.org/wiki/Gray_code\\nBinary to Gray Code\\uFF1A    \\n![image](https://assets.leetcode.com/users/u2647/image_1557797884.png)\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int len = (int) Math.pow(2, n);\\n        List<Integer> ans = new ArrayList<>(len);\\n        for (int i = 0; i < len; i++) {\\n            ans.add(i ^ (i >> 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int len = (int) Math.pow(2, n);\\n        List<Integer> ans = new ArrayList<>(len);\\n        for (int i = 0; i < len; i++) {\\n            ans.add(i ^ (i >> 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279206,
                "title": "very-intuitive-o-n-c-solution-11-lines-explained-with-examples",
                "content": "Okay so this question is actually pretty simple once you figure out the pattern:\\n\\nfor 2:\\n00\\n01\\n11\\n10\\n\\nfor 3: (pay attention to how the right part is same as 2 until 5th line)\\n(0)-00\\n(0)-01\\n(0)-11\\n(0)-10 (you can see it is just reversed after this point)\\n(1)-10\\n(1)-11\\n(1)-01\\n(1)-00\\n\\nLikewise, for each step, you only have to go backwards in your vector and then add the newdigit which will be powers of 2 since it is binary count.\\n\\nExample:\\nif my current vector is {0,1,3,2} for n = 2, \\nthen for n = 3 --> {0,1,3,2, (2+4), (3+4), (1+4), (0+4)} --> {0,1,3,2,6,7,5,4}\\n\\n``` \\n    vector<int> grayCode(int n) {\\n        vector<int> gray;\\n        gray.push_back(0);\\n        int newdigit = 1;\\n        while(n>0){\\n            for(int i = gray.size() - 1; i >= 0; i--){\\n                gray.push_back(gray[i]+newdigit);\\n            }\\n            newdigit *= 2;\\n            n--;\\n        }\\n        return gray;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\n    vector<int> grayCode(int n) {\\n        vector<int> gray;\\n        gray.push_back(0);\\n        int newdigit = 1;\\n        while(n>0){\\n            for(int i = gray.size() - 1; i >= 0; i--){\\n                gray.push_back(gray[i]+newdigit);\\n            }\\n            newdigit *= 2;\\n            n--;\\n        }\\n        return gray;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261362,
                "title": "java-beats-100-in-time-and-100-in-space",
                "content": "```\\n    public List<Integer> grayCode(int n) {\\n        list.add(0);\\n        for(int i=0;i<n;i++){\\n            recur(i);\\n        }\\n        return list;\\n    }\\n    \\n    public void recur(int j){\\n        int diff = (int)Math.pow(2,j);\\n        int size = list.size();\\n        for(int i=size-1;i>=0;i--){\\n            int x = list.get(i);\\n            list.add(x+diff);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> grayCode(int n) {\\n        list.add(0);\\n        for(int i=0;i<n;i++){\\n            recur(i);\\n        }\\n        return list;\\n    }\\n    \\n    public void recur(int j){\\n        int diff = (int)Math.pow(2,j);\\n        int size = list.size();\\n        for(int i=size-1;i>=0;i--){\\n            int x = list.get(i);\\n            list.add(x+diff);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210895,
                "title": "c-with-picture",
                "content": "For each new bit, we are reusing the existing gray code sequence. We are combining the new bit with the reflection of the existing sequence, so that newly added numbers comply with the 1-bit difference rule.\\n![image](https://assets.leetcode.com/users/votrubac/image_1546070487.png)\\n```\\nvector<int> grayCode(int n) {\\n  vector<int> res = { 0 };\\n  for (auto f = 1; n > 0; f <<= 1, --n)\\n    for (int j = f - 1; j >= 0; --j) \\n        res.push_back(res[j] + f);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n  vector<int> res = { 0 };\\n  for (auto f = 1; n > 0; f <<= 1, --n)\\n    for (int j = f - 1; j >= 0; --j) \\n        res.push_back(res[j] + f);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29933,
                "title": "o-2-n-time-complexity-o-1-space-with-my-explanation",
                "content": "The obvious way when I first saw this question is using backtracking/brute-force. By Grey Code definition, \\n1. from 0, I try to modify each bits from very right to left. \\n2. after modify this bits, If there is no such num in my hashSet, put it into hashSet and also result list, if there is such num in my hashSet, move to higher bits and repeat step 2, until get 2^n numbers\\n\\nI assume n bits must have a way to transfer 0-2^n-1 to gray code. The following is proof. \\nI use induction to proof this. So we proof If k bits can get 2^k gray code, then k+1 bits can get 2^(k+1) gray code. For the k + 1 bits gray codes, the first 2^k gray codes' highest bit is \"0\", with the same order of k bits's gray code. the second 2^k gray codes' highest bit is \"1\" with the symmetrical order of k bits' gray code. Such, we get the 2^(k+1) gray code.\\nFor this solution, time complexity is n*2^n, 2^n numbers and to get each numbers, at most n bits to modify.\\n\\nIt is far away from optimization. So I try another way. \\n```\\npublic class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < (1 << n); i++) {\\n            res.add(i ^ (i >> 1));\\n        }\\n        return res;\\n    }\\n}\\n```\\ni ^ (i >> 1) means for i-th gray code, we can get it by the following way:\\n1. invert bits if higher bit is \"1\"\\n2. keep the original bit if higher bit is \"0\"\\n\\nWhy? Generally because we get our gray code by \"recursive symmetry with 2^k\". \\nLet we take 6-th gray code as example. 6 is \"110\", The first bits \"1\" means 6-th gray code is on the second half part, in this part, second bit \"1\" shows 6-th gray code is on the second half part of second half part, third bit \"0\" shows the gray code is one the first half of the second half of the second part. By inverting, we can get symmetric position of 6-th, which is \"001\". Considering the 6-th is in the second part, also add 1 to the highest bit of \"001\", which leads to our 6-th gray code \"101\"",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < (1 << n); i++) {\\n            res.add(i ^ (i >> 1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29976,
                "title": "quite-simple-solution-accepted-as-best-in-c-well-explained",
                "content": "\\nIt's quite a math problem and the formula to convert **n** to its **gray code** is as follows:\\n\\n> grayCode = n^(n>>1)\\n\\nIf you never heard of this, please read [wiki][1] first and if you are still eager to understand this equation, you may check this [post][2] for reasoning details. \\n\\n- space cost O(2^n)\\n- time cost O(2^n)\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) \\n        {\\n            vector<int> v;\\n            for(int i = 0, a = 1<<n; i < a; ++i) v.push_back(i^(i>>1));\\n            return v;\\n        }\\n    };\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Gray_code\\n  [2]: https://www.quora.com/I-came-across-this-code-which-generates-the-nth-gray-code-number-G-n-n-n-1-How-can-we-proof-that-it-is-correct\\n  [3]: https://en.wikipedia.org/w/index.php?title=Gray_code&oldid=631353193#Converting_to_and_from_Gray_code",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) \\n        {\\n            vector<int> v;\\n            for(int i = 0, a = 1<<n; i < a; ++i) v.push_back(i^(i>>1));\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 30018,
                "title": "few-lines-of-java-code-1ms-no-recursion",
                "content": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(0);\\n\\t\\t\\n\\t\\tfor(int i=1; i<=n; i++){\\n        \\tint size = result.size()-1;\\n        \\tfor(int j=size; j>=0; j--){\\n        \\t\\tresult.add(result.get(j) | 1<<i-1);\\n        \\t}\\n        }\\n\\t\\treturn result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(0);\\n\\t\\t\\n\\t\\tfor(int i=1; i<=n; i++){\\n        \\tint size = result.size()-1;\\n        \\tfor(int j=size; j>=0; j--){\\n        \\t\\tresult.add(result.get(j) | 1<<i-1);\\n        \\t}\\n        }\\n\\t\\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30035,
                "title": "simple-2ms-java-solution",
                "content": "    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            if(n == 0) return Arrays.asList(0);\\n            List<Integer> prev = grayCode(n-1);\\n            List<Integer> next = new ArrayList<Integer>(prev);\\n            int pow = 1 << (n-1);\\n            for(int i=prev.size()-1; i >= 0; i--){\\n                next.add(prev.get(i) | pow);\\n            }\\n            return next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            if(n == 0) return Arrays.asList(0);\\n            List<Integer> prev = grayCode(n-1);\\n            List<Integer> next = new ArrayList<Integer>(prev);\\n            int pow = 1 << (n-1);\\n            for(int i=prev.size()-1; i >= 0; i--){\\n                next.add(prev.get(i) | pow);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30039,
                "title": "python-recursive-solution-easy-understanding",
                "content": "    class Solution(object):\\n\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n\\n        \"\"\"\\n        if n<1:\\n            return [0]\\n        if (n==1):\\n            return [0,1]\\n        res = self.grayCode( n-1)\\n        x=pow(2,n-1)\\n        for i in range(x-1,-1,-1):\\n            res.append(res[i]+x)\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n\\n        \"\"\"\\n        if n<1:\\n            return [0]\\n        if (n==1):\\n            return [0,1]\\n        res = self.grayCode( n-1)\\n        x=pow(2,n-1)\\n        for i in range(x-1,-1,-1):\\n            res.append(res[i]+x)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 30087,
                "title": "backtracking-solution",
                "content": "        public static List<Integer> grayCode(int n) {\\n    \\t\\tList<Integer> code = new ArrayList<Integer>();\\n    \\t\\tcode.add(0);\\n    \\t\\tgenCodes(code,n,0,1<<n);\\n    \\t\\treturn code;\\n    \\t}\\n    \\tpublic static void genCodes(List<Integer> code, int n, int curr, int size) {\\n    \\t\\tif(code.size()==size) return;\\n    \\t\\tfor(int i=0;i<n;i++) {\\n    \\t\\t\\tint mask = 1<<i;\\n    \\t\\t\\tint el = (curr^mask);\\n    \\t\\t\\tif(!code.contains(el)) {\\n    \\t\\t\\t\\tcode.add(el);\\n    \\t\\t\\t\\tgenCodes(code,n,el,size);\\n    \\t\\t\\t\\tif(code.size()==size) return;\\n    \\t\\t\\t\\tcode.remove(new Integer(el));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "        public static List<Integer> grayCode(int n) {\\n    \\t\\tList<Integer> code = new ArrayList<Integer>();\\n    \\t\\tcode.add(0);\\n    \\t\\tgenCodes(code,n,0,1<<n);\\n    \\t\\treturn code;\\n    \\t}\\n    \\tpublic static void genCodes(List<Integer> code, int n, int curr, int size) {\\n    \\t\\tif(code.size()==size) return;\\n    \\t\\tfor(int i=0;i<n;i++) {\\n    \\t\\t\\tint mask = 1<<i;\\n    \\t\\t\\tint el = (curr^mask);\\n    \\t\\t\\tif(!code.contains(el)) {\\n    \\t\\t\\t\\tcode.add(el);\\n    \\t\\t\\t\\tgenCodes(code,n,el,size);\\n    \\t\\t\\t\\tif(code.size()==size) return;\\n    \\t\\t\\t\\tcode.remove(new Integer(el));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3362071,
                "title": "easy-java-solution-using-xor",
                "content": "# Intuition\\n* The problem requires us to generate a sequence of n-bit gray codes that satisfy the given conditions.\\n * The gray code sequence has the property that the binary representation of every adjacent integer differs by only one bit.\\n * The first integer is 0 and the last integer differs from the first integer by only one bit.\\n * We can generate the gray code sequence using the following approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe start with a list that contains only 0 as the first element.\\nThen, we iterate from 0 to (2^n - 1) and perform the following steps:\\n 1. We compute the XOR of the current index i with (i & -i).\\n     This operation flips the least significant bit that is set in i.\\n     For example, if i = 3 (011), then (i & -i) = 1 (001).\\n     So, num = num ^ (i & -i) will set the least significant bit of num to 1 if it is 0, and vice versa.\\n  2. We add the computed num to the answer list.\\n  3. Repeat steps 1 and 2 for all indices from 0 to (2^n - 1).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        int num = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            // Compute the XOR of the current index i with (i & -i) to generate the next gray code.\\n            num ^= i & (-i);\\n            // Add the generated gray code to the answer list.\\n            ans.add(num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        int num = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            // Compute the XOR of the current index i with (i & -i) to generate the next gray code.\\n            num ^= i & (-i);\\n            // Add the generated gray code to the answer list.\\n            ans.add(num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196995,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        int cnt=1;\\n        vector<int>v;\\n        v.push_back(0);\\n        v.push_back(1);\\n        for(int i=1; i<n; i++){\\n            cnt*=2;\\n            int l=v.size();\\n            for(int j=l-1; j>=0; j--){\\n                v.push_back(v[j]+cnt);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        int cnt=1;\\n        vector<int>v;\\n        v.push_back(0);\\n        v.push_back(1);\\n        for(int i=1; i<n; i++){\\n            cnt*=2;\\n            int l=v.size();\\n            for(int j=l-1; j>=0; j--){\\n                v.push_back(v[j]+cnt);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185748,
                "title": "gray-code-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an initial list with 0\\n2. For each bit in n, starting from the 0th bit:\\n   1. Traverse the current list in reverse and add the current bit to each number by doing bitwise OR with (1 << i)\\n   2. This step is repeated until we have processed all the bits in n\\n3. Return the final list as the result\\n\\nExample: n = 2\\n\\n- Initial list: [0]\\n- 1st iteration: i = 0, [0, 1 | (1 << 0) = 1] = [0, 1]\\n- 2nd iteration: i = 1, [0, 1, 3 | (1 << 1) = 3, 2 | (1 << 1) = 2] = [0, 1, 3, 2]\\n- Result: [0, 1, 3, 2]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        for i in range(n):\\n            for j in range(len(res) - 1, -1, -1):\\n                res.append(res[j] | (1 << i))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        for i in range(n):\\n            for j in range(len(res) - 1, -1, -1):\\n                res.append(res[j] | (1 << i))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722095,
                "title": "c-simple-recursive-solution-backtracking",
                "content": "//for video explaination u can watch  pepcoding video on youtube\\n\\n           *    vector<string> solve(int n){\\n                   if(n==1){\\n                     return {\"0\",\"1\"};\\n                    }\\n        \\n             vector<string>ans=solve(n-1);\\n        \\n            vector<string> mainAns;\\n        \\n           for(int i=0;i<ans.size();i++){\\n            string s=ans[i];\\n              mainAns.push_back(\"0\"+s);\\n          }\\n          for(int i=ans.size()-1;i>=0;i--){\\n              string s=ans[i];\\n              mainAns.push_back(\"1\"+s);\\n          }\\n         return mainAns;\\n         }\\n        vector<int> grayCode(int n) {\\n            vector<string> strRes = solve(n);\\n           vector<int> result;\\n\\t\\t   // converting string to int \\n            for(int i=0;i<strRes.size();i++)\\n               {\\n              int val = stoi(strRes[i], 0, 2);\\n                 result.push_back(val);\\n             }\\n            return result;\\n            }\\n// in our problem we have binary-number-strings, we want them to convert to integers of base 10\\n\\nSTOI[string to integer] , stoi(string_to_be_converted , position[optional] , base of string : in our case its binary so we used 2)\\nFor more info, you can follow official documentation or the link given at the top..\\n       \\n      \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "//for video explaination u can watch  pepcoding video on youtube\\n\\n           *    vector<string> solve(int n){\\n                   if(n==1){\\n                     return {\"0\",\"1\"};\\n                    }\\n        \\n             vector<string>ans=solve(n-1);\\n        \\n            vector<string> mainAns;\\n        \\n           for(int i=0;i<ans.size();i++){\\n            string s=ans[i];\\n              mainAns.push_back(\"0\"+s);\\n          }\\n          for(int i=ans.size()-1;i>=0;i--){\\n              string s=ans[i];\\n              mainAns.push_back(\"1\"+s);\\n          }\\n         return mainAns;\\n         }\\n        vector<int> grayCode(int n) {\\n            vector<string> strRes = solve(n);\\n           vector<int> result;\\n\\t\\t   // converting string to int \\n            for(int i=0;i<strRes.size();i++)\\n               {\\n              int val = stoi(strRes[i], 0, 2);\\n                 result.push_back(val);\\n             }\\n            return result;\\n            }\\n// in our problem we have binary-number-strings, we want them to convert to integers of base 10\\n\\nSTOI[string to integer] , stoi(string_to_be_converted , position[optional] , base of string : in our case its binary so we used 2)\\nFor more info, you can follow official documentation or the link given at the top..\\n       \\n      \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1407039,
                "title": "python-very-easy-solution-using-or-operator",
                "content": "Example where n=2:\\n==> Output = [0,1,3,2]\\n\\nStep 1: write the binary of the output.\\n              00 = 0\\n\\t\\t\\t  01 = 1\\n\\t\\t\\t  11 = 3\\n\\t\\t\\t  10 = 2\\nStep 2: If you can see the pattern i.e. it is just OR operation of its n-1 output array\\n\\t\\t\\twhich has been reversed with 2**n (n is the power of 2) \\n               like : for n=2:\\n\\t\\t\\t   n-1 output will be [0,1]\\n\\t\\t\\t   so we OR it with reverse array output i.e. [1,0]\\n\\t\\t\\t        01 OR 10 = 11 = 3\\n\\t\\t\\t\\t\\t00 OR 10 = 10 = 2\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        k = 2**n-1\\n        lt = [0]\\n        x=0\\n        while(x<n):\\n            p = len(lt)\\n            two = 2**x\\n            for i in range(p-1, -1, -1): #Reverse the output array of n-1\\n                lt.append(two | lt[i])\\n            x+=1\\n        return lt\\n```\\n\\n**Please Upvote this solution if you like......**",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        k = 2**n-1\\n        lt = [0]\\n        x=0\\n        while(x<n):\\n            p = len(lt)\\n            two = 2**x\\n            for i in range(p-1, -1, -1): #Reverse the output array of n-1\\n                lt.append(two | lt[i])\\n            x+=1\\n        return lt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309394,
                "title": "c-2-approaches-clear-explanation-with-code",
                "content": "```\\n//Approach-1 (Using Simple Recursion)\\n/*\\n    Example : n = 2\\n    helper(n-1) calls-> helper(1)\\n    \\n    Now, helper(1) returns {\"0\", \"1\"}; Which is correct gray code sequence for n = 1 (# elements = 2^1)\\n    \\n    Now, juts append \"0\" to each element , you will get {\"00\", \"01\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result1\\n    \\n    Now, juts append \"1\" to each element , you will get {\"10\", \"11\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result2\\n    \\n    So, after combining Result1 and Result2 (for n = 2),  {\"00\", \"01\", \"10\", \"11\"}\\n    BUT, you notice that if we combine them, the 1st and 2nd string differ in 2 bits i.e. \"01\", \"10\"\\n    SO, \\n    instead of combining them face to face, reverse the Result2 and then combine it with Result1.\\n    \\n    That\\'s why my 2nd for loop below starts from i = temp.size()-1 and goes till i >=0 .\\n    \\n*/\\nclass Solution {\\npublic:\\n    vector<string> helper(int n) {\\n        if(n == 1) {\\n            return {\"0\", \"1\"};\\n        }\\n        \\n        vector<string> temp = helper(n-1); //To get the result of n, we fetch result from (n-1)\\n        \\n        vector<string> padded;\\n        \\n        for(int i = 0; i<temp.size(); i++) {\\n            padded.push_back(\"0\" + temp[i]); //Just add \"0\" in the beginning\\n        }\\n        \\n        for(int i = temp.size()-1; i >= 0; i--) {\\n            padded.push_back(\"1\" + temp[i]); //Just add \"1\" in the beginning\\n        }\\n        \\n        return padded;\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        vector<string> result = helper(n);\\n        \\n        vector<int> finalR;\\n        \\n        //Just convert them to integer and you got your answer\\n        for(string &s : result) {\\n            bitset<32> bt(s);\\n            finalR.push_back(bt.to_ulong());\\n        }\\n        return finalR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    void helper(bitset<32>& bt, int n) {\\n        if(n == 0) {\\n            //It means we have generate all n elements\\n            result.push_back(bt.to_ulong());\\n            return;\\n        }\\n        \\n        //Generate the remaining (n-1) numbers from bt\\n        helper(bt, n-1);\\n        \\n        //flip the (n-1)th bit (to create a difference of just one bit)\\n        bt.flip(n-1);\\n        \\n        //Generate the remaining (n-1) numbers from bt but this time (n-1)th bit flipped (to create a difference of just one bit)\\n        helper(bt, n-1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        bitset<32> bt; //by default all bits are 0 i.e. {0000000.....000}\\n        \\n        result.clear();\\n        \\n        helper(bt, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Simple Recursion)\\n/*\\n    Example : n = 2\\n    helper(n-1) calls-> helper(1)\\n    \\n    Now, helper(1) returns {\"0\", \"1\"}; Which is correct gray code sequence for n = 1 (# elements = 2^1)\\n    \\n    Now, juts append \"0\" to each element , you will get {\"00\", \"01\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result1\\n    \\n    Now, juts append \"1\" to each element , you will get {\"10\", \"11\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result2\\n    \\n    So, after combining Result1 and Result2 (for n = 2),  {\"00\", \"01\", \"10\", \"11\"}\\n    BUT, you notice that if we combine them, the 1st and 2nd string differ in 2 bits i.e. \"01\", \"10\"\\n    SO, \\n    instead of combining them face to face, reverse the Result2 and then combine it with Result1.\\n    \\n    That\\'s why my 2nd for loop below starts from i = temp.size()-1 and goes till i >=0 .\\n    \\n*/\\nclass Solution {\\npublic:\\n    vector<string> helper(int n) {\\n        if(n == 1) {\\n            return {\"0\", \"1\"};\\n        }\\n        \\n        vector<string> temp = helper(n-1); //To get the result of n, we fetch result from (n-1)\\n        \\n        vector<string> padded;\\n        \\n        for(int i = 0; i<temp.size(); i++) {\\n            padded.push_back(\"0\" + temp[i]); //Just add \"0\" in the beginning\\n        }\\n        \\n        for(int i = temp.size()-1; i >= 0; i--) {\\n            padded.push_back(\"1\" + temp[i]); //Just add \"1\" in the beginning\\n        }\\n        \\n        return padded;\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        vector<string> result = helper(n);\\n        \\n        vector<int> finalR;\\n        \\n        //Just convert them to integer and you got your answer\\n        for(string &s : result) {\\n            bitset<32> bt(s);\\n            finalR.push_back(bt.to_ulong());\\n        }\\n        return finalR;\\n    }\\n};\\n```\n```\\n//Approach-2\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    void helper(bitset<32>& bt, int n) {\\n        if(n == 0) {\\n            //It means we have generate all n elements\\n            result.push_back(bt.to_ulong());\\n            return;\\n        }\\n        \\n        //Generate the remaining (n-1) numbers from bt\\n        helper(bt, n-1);\\n        \\n        //flip the (n-1)th bit (to create a difference of just one bit)\\n        bt.flip(n-1);\\n        \\n        //Generate the remaining (n-1) numbers from bt but this time (n-1)th bit flipped (to create a difference of just one bit)\\n        helper(bt, n-1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        bitset<32> bt; //by default all bits are 0 i.e. {0000000.....000}\\n        \\n        result.clear();\\n        \\n        helper(bt, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308590,
                "title": "c-recursive-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1) return vector<int>{0,1};\\n        vector<int>prev = grayCode(n-1);\\n        \\n        for(int i=prev.size()-1;i>=0;i--)\\n            prev.push_back(prev[i]+pow(2,n-1));\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1) return vector<int>{0,1};\\n        vector<int>prev = grayCode(n-1);\\n        \\n        for(int i=prev.size()-1;i>=0;i--)\\n            prev.push_back(prev[i]+pow(2,n-1));\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773096,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ans.push_back(i^(i>>1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ans.push_back(i^(i>>1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736419,
                "title": "fastest-solution-c",
                "content": "vector<int> grayCode(int n) {\\n        int c=pow(2,n);\\n        vector<int> ans(c);\\n        for(int i=0;i<c;i++)\\n            ans[i]=i^(i>>1);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> grayCode(int n) {\\n        int c=pow(2,n);\\n        vector<int> ans(c);\\n        for(int i=0;i<c;i++)\\n            ans[i]=i^(i>>1);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 702123,
                "title": "java-0ms-three-simple-approaches",
                "content": "# Approach 1: Dynamic Programming\\n`grayCode(n) = (1 << n - 1) | each code in grayCode(n - 1))`\\n``` java\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n        code.add(0);\\n\\n        for (int mask = 0; mask < n; mask++) {\\n            for (int prev = code.size() - 1; prev >= 0; prev--) {\\n                code.add((1 << mask) | code.get(prev));\\n            }\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n).\\nSpace complexity: O(1) excluding the output list.\\n# Approach 2: Iterative\\n```\\nwhile (count < (1 << n))\\n    1st first change the rightmost bit\\n    or\\n    2st second change the left bit of the rightmost 1 bit\\n```\\n</br>\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        int prev = 0;\\n        for (int i = 0; i < 1 << n; i++) {\\n            prev ^= (i & 1) == 1 ? 1 : (prev & -prev) << 1;\\n            code.add(prev);\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n)\\nSpace complexity: O(1)\\n# Approach 3: Formula\\nRefer to [wiki/gray code](https://en.wikipedia.org/wiki/Gray_code).\\n```\\nBINARYTOGRAY(num)\\n    return num ^ (num >> 1)\\n```\\n</br>\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        // i-th code sequence of the graycode\\n        for (int i = 0; i < 1 << n; i++) {\\n            code.add(i ^ (i >> 1));\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n        code.add(0);\\n\\n        for (int mask = 0; mask < n; mask++) {\\n            for (int prev = code.size() - 1; prev >= 0; prev--) {\\n                code.add((1 << mask) | code.get(prev));\\n            }\\n        }\\n\\n        return code;\\n    }\\n}\\n```\n```\\nwhile (count < (1 << n))\\n    1st first change the rightmost bit\\n    or\\n    2st second change the left bit of the rightmost 1 bit\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        int prev = 0;\\n        for (int i = 0; i < 1 << n; i++) {\\n            prev ^= (i & 1) == 1 ? 1 : (prev & -prev) << 1;\\n            code.add(prev);\\n        }\\n\\n        return code;\\n    }\\n}\\n```\n```\\nBINARYTOGRAY(num)\\n    return num ^ (num >> 1)\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        // i-th code sequence of the graycode\\n        for (int i = 0; i < 1 << n; i++) {\\n            code.add(i ^ (i >> 1));\\n        }\\n\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651316,
                "title": "python3-easy-to-understand-beats-99-41-solutions",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n\\n        result = [0,1]\\n        iterations = 1\\n\\t\\t# calculate till row-1, reverse result and add 2^(iteration -1)\\n        # [0,1] + [1+2,0+2] => [0,1,3,2]\\n        # [0,1,3,2] + [2 + 4, 3 + 4, 1 + 4, 0 + 4] => [0,1,3,2,6,7,5,4]\\n        while iterations < n:\\n            iterations += 1\\n            temp = result\\n            increment_val = 2 ** (iterations-1)\\n            new_array = []\\n            for i in range(len(temp)-1, -1, -1):\\n                result.append(temp[i] + increment_val)\\n        \\n        return result\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n\\n        result = [0,1]\\n        iterations = 1\\n\\t\\t# calculate till row-1, reverse result and add 2^(iteration -1)\\n        # [0,1] + [1+2,0+2] => [0,1,3,2]\\n        # [0,1,3,2] + [2 + 4, 3 + 4, 1 + 4, 0 + 4] => [0,1,3,2,6,7,5,4]\\n        while iterations < n:\\n            iterations += 1\\n            temp = result\\n            increment_val = 2 ** (iterations-1)\\n            new_array = []\\n            for i in range(len(temp)-1, -1, -1):\\n                result.append(temp[i] + increment_val)\\n        \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 475200,
                "title": "python-a-very-very-easy-understanding-solution",
                "content": "# I think this python version is more easy to understand\\n\\n## explain\\nAt first glance, we find that for a gray code sequence  with n = 1 `0, 1`, its reversed sequence `1, 0` is also a gray code sequence too. \\n\\nWe can add `1` to the front of every element,  and this new sequence `10, 11` is also a gray code sequence.  It is also valid if we add `0`s to the sequence. `00, 01`.\\n\\nSince the first element of sequence is as same as the last one of its reverse, we can find that we can get a gray code sequence with n = 2 by add zeros to the sequence of n=1\\nand ones to its reverse. That are `00, 01` and `11, 10`.  Then we concatenate them to get the result -- `00, 01, 11, 10`.\\n\\nThe general scheme is   \\n\\n`seq(n) =  concatenate(  padding seq(n-1) with zeros,   padding  seq(n-1)\\'s reverse with ones )`\\n\\n## example\\n\\n1.   `01, 10`  -- reverse --> `10,  01`\\n2.   `01, 10`  --padding with zeros--> `001, 010`\\n       `10,  01` --padding with ones--> `110, 101`\\n3.    `001, 010` + `110, 101`  --concatenate--> `001, 010, 110, 101`\\n\\n## tip:\\nA number padded with zero is still itself, and is equal to plus `pow(2, n)` if it is padded with one at `n th` bit.  \\n\\n## code:\\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        bit = 1\\n        while n > 0:\\n            layer = res[::-1]\\n            for i in layer:\\n                res.append(i+bit)\\n            bit += bit\\n            n -= 1\\n        return res      \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        bit = 1\\n        while n > 0:\\n            layer = res[::-1]\\n            for i in layer:\\n                res.append(i+bit)\\n            bit += bit\\n            n -= 1\\n        return res      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 441028,
                "title": "c-0ms-beats-100-on-time-and-space-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n\\t    // Total number of combinations.\\n        int totalCombos = (int)pow(2, n);\\n        vector<int> ourVec;\\n        v.reserve(totalCombos);\\n        for (int i{}; i < totalCombos; ++i) {\\n\\t\\t\\tourVec.push_back(i^(i>>1));\\n\\t\\t}\\n        return ourVec;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n\\t    // Total number of combinations.\\n        int totalCombos = (int)pow(2, n);\\n        vector<int> ourVec;\\n        v.reserve(totalCombos);\\n        for (int i{}",
                "codeTag": "Java"
            },
            {
                "id": 354466,
                "title": "simple-python-solution-dfs",
                "content": "Not every path leads to the complete combination. eg.\\n(n = 3) 000 -> 001 -> 011 -> 111 -> 110 -> 100 -> 101 -> X\\n\\nThe goal is to find a path which reaches the level == 2^n\\nRevert bit one at a time (always from the right most one) and append to the ans list if it is not already.\\nIf the len(ans) == target, stop.\\n\\n\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        targetLevel = 2**n\\n        ans = []\\n        \\n        self.DFS(n, ans, 0, 1, targetLevel)   # Start with number = 0 (000), level = 1\\n        \\n        return ans\\n    \\n    \\n    def DFS(self, n, ans, num, level, targetLevel):\\n        if num in ans:\\n            return\\n        \\n        ans.append(num)\\n        \\n        if level == targetLevel:\\n            return\\n        \\n        for i in range(0, n):\\n            self.DFS(n, ans, num ^ (1 << i), level+1, targetLevel)  # num ^ (1 << i): revert a bit at a time\\n            \\n            if len(ans) == targetLevel: return  # result found. Stop.\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        targetLevel = 2**n\\n        ans = []\\n        \\n        self.DFS(n, ans, 0, 1, targetLevel)   # Start with number = 0 (000), level = 1\\n        \\n        return ans\\n    \\n    \\n    def DFS(self, n, ans, num, level, targetLevel):\\n        if num in ans:\\n            return\\n        \\n        ans.append(num)\\n        \\n        if level == targetLevel:\\n            return\\n        \\n        for i in range(0, n):\\n            self.DFS(n, ans, num ^ (1 << i), level+1, targetLevel)  # num ^ (1 << i): revert a bit at a time\\n            \\n            if len(ans) == targetLevel: return  # result found. Stop.\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 322062,
                "title": "beats-100-c-n-n-1-one-line",
                "content": "**if u like hit vote**\\n```\\nvector<int> grayCode(int n) {\\n        vector<int> ans;\\n       for(int i=0;i<(1<<n);i++)\\n        ans.push_back(i^(i>>1));\\n       return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n        vector<int> ans;\\n       for(int i=0;i<(1<<n);i++)\\n        ans.push_back(i^(i>>1));\\n       return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30053,
                "title": "simple-python-method-52-ms",
                "content": "\\tclass Solution(object):\\n        ```\\n\\t\\tdef grayCode(self, n): \\n\\t\\t\\t\\t\\tif n==0: return [0]\\n\\t\\t\\t\\t\\treturn self.back(n) \\n            \\n        def back(self, n):\\n            if n==1:\\n                return [0,1] \\n            cur = [] \\n            pre= self.back(n-1)\\n            for x in xrange(len(pre)-1,-1,-1):\\n                cur.append(2**(n-1)+pre[x])  \\n            return pre+cur\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\t\\tdef grayCode(self, n): \\n\\t\\t\\t\\t\\tif n==0: return [0]\\n\\t\\t\\t\\t\\treturn self.back(n) \\n            \\n        def back(self, n):\\n            if n==1:\\n                return [0,1] \\n            cur = [] \\n            pre= self.back(n-1)\\n            for x in xrange(len(pre)-1,-1,-1):\\n                cur.append(2**(n-1)+pre[x])  \\n            return pre+cur\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30105,
                "title": "iterative-5-lines-in-java",
                "content": "Hi guys!\\n\\nThe idea is standard: we have n iterations and at each iteration \"i\" we run through our list (which is a gray code for \"i-1\") in reverse adding 1 to the front of bit-wise representation of a current number.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(Arrays.asList(0));\\n        for (int i = 1; i < (1 << n); i <<= 1)\\n            for (int j = res.size()-1; j >= 0; j--)\\n                res.add(i | res.get(j));\\n        return res;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe idea is standard: we have n iterations and at each iteration \"i\" we run through our list (which is a gray code for \"i-1\") in reverse adding 1 to the front of bit-wise representation of a current number.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(Arrays.asList(0));\\n        for (int i = 1; i < (1 << n); i <<= 1)\\n            for (int j = res.size()-1; j >= 0; j--)\\n                res.add(i | res.get(j));\\n        return res;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 3125514,
                "title": "very-easy-way-gray-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        int m=pow(2,n);\\n        for(int i=0; i<m; i++){\\n            int x=i^(i>>1);\\n           \\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        int m=pow(2,n);\\n        for(int i=0; i<m; i++){\\n            int x=i^(i>>1);\\n           \\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970359,
                "title": "world-simplest-way-to-solve-this-question",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        n = pow(2, n)-1;\\n        for(int i=0; i<=n; ++i)\\n            v.push_back(i^(i>>1));\\n        return v;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        n = pow(2, n)-1;\\n        for(int i=0; i<=n; ++i)\\n            v.push_back(i^(i>>1));\\n        return v;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741505,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N+2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        oldArr = [0,1]\\n        i = 1\\n        while i< n:\\n            Arr = list(oldArr)\\n            for j in range(len(oldArr)-1,-1,-1):\\n                Arr.append((2**i)+oldArr[j])\\n            oldArr = Arr\\n            i+=1\\n        return oldArr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        oldArr = [0,1]\\n        i = 1\\n        while i< n:\\n            Arr = list(oldArr)\\n            for j in range(len(oldArr)-1,-1,-1):\\n                Arr.append((2**i)+oldArr[j])\\n            oldArr = Arr\\n            i+=1\\n        return oldArr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570947,
                "title": "gray-codes-explained-c-easy-solution",
                "content": "__Algorithm__\\n```                                                         upvote if helpful```\\n- Gray code => a sequence of numbers where binary representation of any 2 consecutive numbers differ by exactly one bit\\n- For exaple for n = 1 => [ 0 , 1 ]\\n                          n = 2 => [00 , 01 , 11 , 10]\\n- To solve this we can understand to find gray code of n bits we need the gray code of n-1 bits and then add 0 and 1 at the front of those numbers\\n- for n = 2 we first find gray code for n = 1 which is [0 , 1] now we add 0 and 1 at the front of all elements in vectro 00 , 01 , 10 , 11 but here there is a discontinuity in 01 and 10 as to bits change\\n- so to resolve this we will add 0 to all integers in the order in which elements are there is vector and for adding 1 we will go in reverse order and push them accordingly . Like -> after adding o in front array will be 00 , 01 after adding 1 array will be 00 , 01 ,11 , 10 as for adding 1 in front the last element ie 1 is used and we go in reverse order\\n- During implementation we don\\'t add 0 as the binary representation already consists of 0 for adding 1 we use bitmask ie 1<<(n-1) as for n = 2 we need to add 1 to 2nd place ie shift 1 by 1 place \\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1){\\n            vector<int> vec = {0,1};\\n            return vec;\\n        }\\n        vector<int> ans(grayCode(n-1));\\n        for(int i = ans.size()-1 ; i>= 0 ;i--){\\n            ans.push_back((ans[i] | 1<<(n-1)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```                                                         upvote if helpful```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1){\\n            vector<int> vec = {0,1};\\n            return vec;\\n        }\\n        vector<int> ans(grayCode(n-1));\\n        for(int i = ans.size()-1 ; i>= 0 ;i--){\\n            ans.push_back((ans[i] | 1<<(n-1)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316165,
                "title": "c-easy-to-understand-simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        for(int i=1;i<n;i++)\\n        {\\n            int sz=ans.size();\\n            int add=pow(2,i);\\n            for(int j=sz-1;j>=0;j--){\\n                ans.push_back(ans[j]+add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        for(int i=1;i<n;i++)\\n        {\\n            int sz=ans.size();\\n            int add=pow(2,i);\\n            for(int j=sz-1;j>=0;j--){\\n                ans.push_back(ans[j]+add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130452,
                "title": "c-almost-in-one-line",
                "content": "```\\nGray[i] = i ^ (i >> 1); // That is all you need to know\\n```\\n\\nSo, the solution is:\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> grayCode(int n)\\n\\t{\\n\\t\\tvector<int> res;\\n\\t\\tfor (int i = 0; i < (1 << n); ++i) res.push_back(i ^ (i >> 1));\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nGray[i] = i ^ (i >> 1); // That is all you need to know\\n```\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> grayCode(int n)\\n\\t{\\n\\t\\tvector<int> res;\\n\\t\\tfor (int i = 0; i < (1 << n); ++i) res.push_back(i ^ (i >> 1));\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999295,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 1:\\n            return [0, 1]\\n        \\n        code = self.grayCode(n - 1)\\n        k = 2 ** (n-1)\\n        return code + [k + i for i in reversed(code)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 1:\\n            return [0, 1]\\n        \\n        code = self.grayCode(n - 1)\\n        k = 2 ** (n-1)\\n        return code + [k + i for i in reversed(code)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942255,
                "title": "easy-100-mathematical",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> grayCode(int n) {\\n        \\n        vector<int>ans;\\n        for(int i=0;i<=(pow(2,n)-1);i++)\\n        {\\n            ans.push_back(i ^ (i>>1));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> grayCode(int n) {\\n        \\n        vector<int>ans;\\n        for(int i=0;i<=(pow(2,n)-1);i++)\\n        {\\n            ans.push_back(i ^ (i>>1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1721825,
                "title": "java-o-2-n-with-clear-explanation",
                "content": "First, let\\'s analyse these kind of results:\\n\\nn = 1:\\n```\\nGray code = [0,1]\\n```\\nn = 2:\\n```\\nGray code = [0,1,3,2]\\n```\\nn = 3:\\n```\\nGray code = [0,1,3,2,6,7,5,4]\\n```\\nn = 4\\n```\\nGray code = [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n```\\nWhat are the patterns here?\\n```\\nThe last number of gray code of n is 2^(n-1). For example for gray code of n = 4, the last number is 2^3 = 8\\n```\\nand\\n```\\nThe first half of gray code of n is the gray code of n - 1\\n```\\nand\\n```\\nThe second half of gray code of n can be constructed from the first half as in the example below:\\n```\\nFor example: With the pattern above, n = 3, assume that we somehow already have gray code of n = 2 How can we calculate the second half?\\n```\\n[0,1,3,2,A,B,C,4]\\n```\\nTurns out:\\n```\\nA = 2 + 4 = 6 (element of gray code 2 at position [3] plus the last element of gray cod 3)\\nB = 3 + 4 = 7 (element of gray code 2 at position [2] plus the last element of gray cod 3)\\nC = 1 + 4 = 5 (element of gray code 2 at position [1] plus the last element of gray cod 3)\\n```\\n\\nSo we implement like this:\\n* Declare an array with 2^n elements.\\n* Init it with the last number of all gray code from 1 to n\\n* Then calculate the right half for each gray code of n (from 1 to n)\\n\\nLike this (with n = 4)\\n```\\n_____________________________________ (array with 2^4 elements)\\n0_1___2_______4_____________________8 (last number of all gray code from 1 to 4)\\n0,1,3,2_______4_____________________8 (calculate the right half of gray code 2)\\n0,1,3,2,6,7,5,4_____________________8 (calculate the right half of gray code 3)\\n0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8 (calculate the right half of gray code 4)\\n```\\n\\nCode:\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int s = 1 << n;\\n        int[] result = new int[s];\\n\\n\\t\\t/* Init it with the last number of all gray code from 1 to n */\\n        int val = s >> 1;\\n        while (s > 0) {\\n            result[s - 1] = val;\\n            val >>= 1;\\n            s >>= 1;\\n        }\\n\\n\\t\\t/* Construct the right half for each n from 1 to n */\\n        for(int i = 4; i <= result.length; i <<= 1) {\\n            addMoreValues(result, i);\\n        }\\n\\n        return arrayToList(result);\\n    }\\n\\n    private List<Integer> arrayToList(int[] array) {\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < array.length; ++i) {\\n            result.add(array[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addMoreValues(int[] result, int m) {\\n        int mid = m >> 1;\\n        int addValue = result[m - 1];\\n        for(int i = 0; mid + i < m - 1; ++i) {\\n            result[mid + i] = result[mid - i - 1] + addValue;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nGray code = [0,1]\\n```\n```\\nGray code = [0,1,3,2]\\n```\n```\\nGray code = [0,1,3,2,6,7,5,4]\\n```\n```\\nGray code = [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n```\n```\\nThe last number of gray code of n is 2^(n-1). For example for gray code of n = 4, the last number is 2^3 = 8\\n```\n```\\nThe first half of gray code of n is the gray code of n - 1\\n```\n```\\nThe second half of gray code of n can be constructed from the first half as in the example below:\\n```\n```\\n[0,1,3,2,A,B,C,4]\\n```\n```\\nA = 2 + 4 = 6 (element of gray code 2 at position [3] plus the last element of gray cod 3)\\nB = 3 + 4 = 7 (element of gray code 2 at position [2] plus the last element of gray cod 3)\\nC = 1 + 4 = 5 (element of gray code 2 at position [1] plus the last element of gray cod 3)\\n```\n```\\n_____________________________________ (array with 2^4 elements)\\n0_1___2_______4_____________________8 (last number of all gray code from 1 to 4)\\n0,1,3,2_______4_____________________8 (calculate the right half of gray code 2)\\n0,1,3,2,6,7,5,4_____________________8 (calculate the right half of gray code 3)\\n0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8 (calculate the right half of gray code 4)\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int s = 1 << n;\\n        int[] result = new int[s];\\n\\n\\t\\t/* Init it with the last number of all gray code from 1 to n */\\n        int val = s >> 1;\\n        while (s > 0) {\\n            result[s - 1] = val;\\n            val >>= 1;\\n            s >>= 1;\\n        }\\n\\n\\t\\t/* Construct the right half for each n from 1 to n */\\n        for(int i = 4; i <= result.length; i <<= 1) {\\n            addMoreValues(result, i);\\n        }\\n\\n        return arrayToList(result);\\n    }\\n\\n    private List<Integer> arrayToList(int[] array) {\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < array.length; ++i) {\\n            result.add(array[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addMoreValues(int[] result, int m) {\\n        int mid = m >> 1;\\n        int addValue = result[m - 1];\\n        for(int i = 0; mid + i < m - 1; ++i) {\\n            result[mid + i] = result[mid - i - 1] + addValue;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579716,
                "title": "my-python-one-liner-using-logic-gates",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(num ^ (num<<1))>>1 for num in range(1<<n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(num ^ (num<<1))>>1 for num in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568408,
                "title": "c-recursive-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1}; //base case\\n        vector<int> prevRes = grayCode(n-1); //dfs call\\n        vector<int> curRes;\\n        for(int i=0; i<prevRes.size(); ++i){\\n            curRes.push_back(prevRes[i]);\\n        }\\n        for(int i=prevRes.size()-1; i>=0; --i){\\n            curRes.push_back((1<<n-1) + prevRes[i]);\\n        }\\n        return curRes;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1}; //base case\\n        vector<int> prevRes = grayCode(n-1); //dfs call\\n        vector<int> curRes;\\n        for(int i=0; i<prevRes.size(); ++i){\\n            curRes.push_back(prevRes[i]);\\n        }\\n        for(int i=prevRes.size()-1; i>=0; --i){\\n            curRes.push_back((1<<n-1) + prevRes[i]);\\n        }\\n        return curRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422842,
                "title": "how-to-approach-initial-approach-brute-force-backtracking-javascript",
                "content": "1. Initialize result array with 0 repeated n times (n bits)\\n2. toggle each bit and check if the conditions for it being the next in the sequence match, if nothing matches, the current position of this needs to be changed => backtracking.\\n3. The first element will always be 0 and the last element will always be yth power of 2.\\n \\n PS: This is only to understand the initial approach after which we can move on to using bitwise manipulations and undertsanding other more optimised way of solving the problem\\n```\\nvar grayCode = function(n) {\\n// build the first binary string. No. of bits == n;\\n\\tlet binary = \\'0\\'.repeat(n);\\n\\tlet resultBinary = [binary];\\n\\tlet set = new Set();\\n\\tset.add(binary);\\n\\tbacktrack(binary, n, set,  resultBinary);\\n\\tresult = resultBinary.map(binary => convertBinary(binary));\\n\\treturn result;\\n}\\n\\nvar backtrack = function(binary, n, set,  result) {\\n\\tif(result.length === 2 ** n) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlet called = false, found;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tlet binArray = binary.split(\\'\\');\\n\\t\\tbinArray[i] = binArray[i] === \\'0\\'  ?  \\'1\\' : \\'0\\';\\n\\t\\tlet newBinary = binArray.join(\\'\\');\\n\\t\\tif(newBinary === 10 ** (n - 1) + \\'\\' && result.length !== (2 ** n - 1)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(!set.has(newBinary)) {\\n\\t\\t\\tresult.push(newBinary);\\n\\t\\t\\tset.add(newBinary);\\n\\t\\t\\tcalled = true;\\n\\t\\t\\tfound = backtrack(newBinary, n, set, result);\\n\\t\\t}\\n\\t\\tif(found === false) {\\n\\t\\t\\tresult.pop();\\n\\t\\t\\tset.delete(newBinary);\\n\\t\\t\\tcalled = false;\\n\\t\\t}\\n\\t}\\n\\tif(!called) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nvar convertBinary = function(binary) {\\n\\tlet decimal = 0, exp = 0;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tdecimal += parseInt(binary[i]) * Math.pow(2, exp++);\\n\\t}\\n\\treturn decimal;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar grayCode = function(n) {\\n// build the first binary string. No. of bits == n;\\n\\tlet binary = \\'0\\'.repeat(n);\\n\\tlet resultBinary = [binary];\\n\\tlet set = new Set();\\n\\tset.add(binary);\\n\\tbacktrack(binary, n, set,  resultBinary);\\n\\tresult = resultBinary.map(binary => convertBinary(binary));\\n\\treturn result;\\n}\\n\\nvar backtrack = function(binary, n, set,  result) {\\n\\tif(result.length === 2 ** n) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlet called = false, found;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tlet binArray = binary.split(\\'\\');\\n\\t\\tbinArray[i] = binArray[i] === \\'0\\'  ?  \\'1\\' : \\'0\\';\\n\\t\\tlet newBinary = binArray.join(\\'\\');\\n\\t\\tif(newBinary === 10 ** (n - 1) + \\'\\' && result.length !== (2 ** n - 1)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(!set.has(newBinary)) {\\n\\t\\t\\tresult.push(newBinary);\\n\\t\\t\\tset.add(newBinary);\\n\\t\\t\\tcalled = true;\\n\\t\\t\\tfound = backtrack(newBinary, n, set, result);\\n\\t\\t}\\n\\t\\tif(found === false) {\\n\\t\\t\\tresult.pop();\\n\\t\\t\\tset.delete(newBinary);\\n\\t\\t\\tcalled = false;\\n\\t\\t}\\n\\t}\\n\\tif(!called) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nvar convertBinary = function(binary) {\\n\\tlet decimal = 0, exp = 0;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tdecimal += parseInt(binary[i]) * Math.pow(2, exp++);\\n\\t}\\n\\treturn decimal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416588,
                "title": "c-easy-5-lines-solution-with-explanation",
                "content": "The idea is simple; for example, consider `n = 2`, we have `{00, 01, 11, 10}` in binary.\\nNotice that the first half of the array starts with `0` and the second half starts with `1`. If we remove all the first bit, the array we have is **symmetric**, in which the first half is `{0, 1}` - the solution to `n = 1`\\n\\nConsider `n = 3`, we have the array `{0, 1, 3, 2, 6, 7, 5, 4}`, or `{000, 001, 011, 010, 110, 111, 101, 100}` in binary. You can notice the same pattern: if we remove all the first bit, the first half of the remaining array is `{00, 01, 11, 10}` - the solution to `n = 2`.\\n\\nSo we can build the array as follow: start with `{0}`, for each additional bit (`ith` bit) you copy each element `a[j]` in the array *backward*, and add a bit `1` in front of it - equivalent to `a[j] | (1 << i)` \\n-\\n*Note: the `1<<i` part is `100...0` with `i` bits `0`, when you use the operator `| - OR`, it will put the bit `1` in front of an `i` bit number - `a[j]` in this case*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> a = {0};\\n        for (int i = 0; i < n; i++) \\n            for (int size = a.size(), j = size-1; j >= 0; --j)\\n                a.push_back(a[j] | (1 << i));\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> a = {0};\\n        for (int i = 0; i < n; i++) \\n            for (int size = a.size(), j = size-1; j >= 0; --j)\\n                a.push_back(a[j] | (1 << i));\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346758,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;       \\n        for(int i=0;i<(1<<n);i++){\\n            v.push_back(i^(i>>1));\\n            \\n            // 00 ^ (00)\\n            // 01 ^ (00)\\n            // 10 ^ (01)\\n            // 11 ^ (01)\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;       \\n        for(int i=0;i<(1<<n);i++){\\n            v.push_back(i^(i>>1));\\n            \\n            // 00 ^ (00)\\n            // 01 ^ (00)\\n            // 10 ^ (01)\\n            // 11 ^ (01)\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316592,
                "title": "c-easy-and-short",
                "content": "```\\n        std::vector<int> grayCode(int n)\\n        {\\n            int limit = (int)std::pow(2, n);\\n            std::vector<int> code{};\\n\\n            code.push_back(0);\\n\\n            // i xor i >> 1 will give you the gray code for i.\\n            for (int i = 1; i < limit; i++) {\\n                code.push_back(i ^ (i >> 1));\\n            }\\n\\n            return code;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        std::vector<int> grayCode(int n)\\n        {\\n            int limit = (int)std::pow(2, n);\\n            std::vector<int> code{};\\n\\n            code.push_back(0);\\n\\n            // i xor i >> 1 will give you the gray code for i.\\n            for (int i = 1; i < limit; i++) {\\n                code.push_back(i ^ (i >> 1));\\n            }\\n\\n            return code;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310242,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n)\\n    {\\n        vector<int>ans;\\n        long itr = pow(2,n); //pow function for computing the base no. raised to the power of exponent\\n        \\n        for(int i=0;i<itr;i++)\\n        {\\n            ans.push_back(i^(i/2));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n)\\n    {\\n        vector<int>ans;\\n        long itr = pow(2,n); //pow function for computing the base no. raised to the power of exponent\\n        \\n        for(int i=0;i<itr;i++)\\n        {\\n            ans.push_back(i^(i/2));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310225,
                "title": "c-dfs-backtracking",
                "content": "\\n**Explanation:**\\n**Neighbours of curr node are all nodes with one bit difference with curr**\\n1. Assume 0 as the source and neighbours {powers of 2 - 1,2,4,8,16.....}\\n2. Recursively follow the below steps on each neighbour:\\n\\t* \\tMark neighbour as visited, push in vector and proceed ahead with next neighbours\\n\\t* \\tIf you reach a dead end ,backtrack - (mark visited false and pop from vector and proceed with another neighbour)\\n\\t* \\tIf you reach the answer, you will have all values in vector, just return\\n\\nYou can also draw edges between neighbours for better visualization.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int curr, vector<bool> &visited, vector<int> &v, int n){\\n        v.push_back(curr);\\n        visited[curr] = true;\\n        if(v.size()==(1<<n)){\\n            return true;\\n        }\\n            \\n        for(int i = 0; i < n; i++){\\n            int next = curr ^ (1<<i);\\n            if(!visited[next] && dfs(next,visited,v,n))\\n                return true;\\n        }\\n        \\n        v.pop_back();\\n        visited[curr] = false;\\n        return false;\\n    }\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int curr = 0;\\n        vector<bool> visited(1<<n,false);\\n        dfs(curr,visited,v,n);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int curr, vector<bool> &visited, vector<int> &v, int n){\\n        v.push_back(curr);\\n        visited[curr] = true;\\n        if(v.size()==(1<<n)){\\n            return true;\\n        }\\n            \\n        for(int i = 0; i < n; i++){\\n            int next = curr ^ (1<<i);\\n            if(!visited[next] && dfs(next,visited,v,n))\\n                return true;\\n        }\\n        \\n        v.pop_back();\\n        visited[curr] = false;\\n        return false;\\n    }\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int curr = 0;\\n        vector<bool> visited(1<<n,false);\\n        dfs(curr,visited,v,n);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309869,
                "title": "java-simple-iterative-clean",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans= new ArrayList<>();   \\n        for(int i=0;i<(1<<n);i++)\\n            ans.add(i^(i>>1));\\n        return ans;\\n    }\\n}\\n```\\n\\nMain Points to be taken care of,\\n1) There will be exactly 2^n number of gray codes for n bit,\\n2) We need to think of the fact that, can we obtain the gray code using current number,\\n\\nFor eg:\\nif current number = 0\\nthe gray code will be = 0\\n\\nif current number = 1\\nthe gray code will be = 1\\n\\nif current number = 2\\nthe gray code will be = 3\\n\\nIf we carefully observe for every number \"num\",\\nthe gray code will be = num ^ (num>>1),\\nwhy?\\nbecause it is making sure that there will be difference of 1 bit between the number and gray code to be formed,\\nLet us take the eg of num=2\\nin Binary = 10\\n(10>>1) = 01\\n10 ^ (10>>1) = 11 (3 in decimal)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans= new ArrayList<>();   \\n        for(int i=0;i<(1<<n);i++)\\n            ans.add(i^(i>>1));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309431,
                "title": "scala-1-line-solution",
                "content": "```\\ndef grayCode(n: Int) = List.tabulate(1 << n)(i => i ^ i >> 1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef grayCode(n: Int) = List.tabulate(1 << n)(i => i ^ i >> 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1309419,
                "title": "c-two-easy-solutions-recursion-and-without-recursion",
                "content": "```\\n//With Recursion\\nvector<int> grayCode(int n) \\n    {\\n       if(n == 1) \\n            return {0, 1};\\n        vector<int>prev = grayCode(n - 1);\\n        \\n        for(int i = prev.size() - 1; i >= 0; i--)\\n            prev.push_back(prev[i] + pow(2, n - 1));\\n        \\n        return prev;  \\n}\\n\\n//Without recursion\\nvector<int> grayCode(int n) \\n    {\\n        vector<int> v;\\n        long long int p = pow(2, n);   //1<<n;\\n        for(int i = 0; i < p; i++)\\n          v.push_back(i ^ (i / 2));    //i>>1\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//With Recursion\\nvector<int> grayCode(int n) \\n    {\\n       if(n == 1) \\n            return {0, 1};\\n        vector<int>prev = grayCode(n - 1);\\n        \\n        for(int i = prev.size() - 1; i >= 0; i--)\\n            prev.push_back(prev[i] + pow(2, n - 1));\\n        \\n        return prev;  \\n}\\n\\n//Without recursion\\nvector<int> grayCode(int n) \\n    {\\n        vector<int> v;\\n        long long int p = pow(2, n);   //1<<n;\\n        for(int i = 0; i < p; i++)\\n          v.push_back(i ^ (i / 2));    //i>>1\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309155,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        if(n==0){return list;}\\n        list.add(1);\\n        int prev_Bit = 1;\\n        for(int i = 2;i<=n;i++){\\n            prev_Bit *=2;\\n            for(int j = list.size()-1;j>=0;j--){\\n                list.add(prev_Bit+list.get(j));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        if(n==0){return list;}\\n        list.add(1);\\n        int prev_Bit = 1;\\n        for(int i = 2;i<=n;i++){\\n            prev_Bit *=2;\\n            for(int j = list.size()-1;j>=0;j--){\\n                list.add(prev_Bit+list.get(j));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006682,
                "title": "python-solution-with-xor-explained",
                "content": "Here is the list for n=2, as provided in the example\\n```\\ngray_code = [0,1,3,2]\\n```\\nLets XOR the values with their own indexes, which would mean,\\n```\\ngray_code[i]^i\\n```\\nDoing the above operation on the example given yields,\\n```\\n[0,0,1,1]\\n```\\nThat list looks a lot like every element is just floor(i/2). Lets hold onto that for a while.\\n\\nXOR has the interesting property: ```if A^B = C, then B^C = A```.\\nWhich implies, \\n```\\nif gray_code[i]^i = x, then x^i = gray_code[i], where x is floor(i/2)\\n```\\nOne last thing: floor(i/2) is same as i >> 1, and 2^n is same as 1<<n (n!=0), where n is the number of bits.\\n```\\ndef grayCode(self, n):\\n       lim = 1 << n\\n       return [(i>>1)^i for i in range(0, lim)]\\n```",
                "solutionTags": [],
                "code": "```\\ngray_code = [0,1,3,2]\\n```\n```\\ngray_code[i]^i\\n```\n```\\n[0,0,1,1]\\n```\n```if A^B = C, then B^C = A```\n```\\nif gray_code[i]^i = x, then x^i = gray_code[i], where x is floor(i/2)\\n```\n```\\ndef grayCode(self, n):\\n       lim = 1 << n\\n       return [(i>>1)^i for i in range(0, lim)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 881932,
                "title": "simple-c-solution-0ms-faster-than-100-6-7mb",
                "content": "```\\nvector<int> grayCode(int n) {\\n        vector<int> res;\\n        for(int i=0;i<(1<<n);i++)\\n            res.push_back(i^(i>>1));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n        vector<int> res;\\n        for(int i=0;i<(1<<n);i++)\\n            res.push_back(i^(i>>1));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825353,
                "title": "c-simple-technique-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        n = (1<<n);\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int x = ((i)^(i>>1));\\n            v.push_back(x);\\n                     \\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        n = (1<<n);\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int x = ((i)^(i>>1));\\n            v.push_back(x);\\n                     \\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808416,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(i >> 1) ^ i for i in range(2**n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(i >> 1) ^ i for i in range(2**n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749462,
                "title": "fastest-c-solution-0ms-with-only-4-5-lines-of-code",
                "content": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        int c = pow(2,n);\\n        for(int i=0;i<c;i++){\\n            res.push_back(i^i>>1);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        int c = pow(2,n);\\n        for(int i=0;i<c;i++){\\n            res.push_back(i^i>>1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 514818,
                "title": "python-bitwise-100",
                "content": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = []\\n        for i in range(1 << n):\\n            res.append(i ^ (i >> 1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = []\\n        for i in range(1 << n):\\n            res.append(i ^ (i >> 1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434639,
                "title": "python-bit-manipulation-easy-to-understand-with-explanation",
                "content": "This solution uses bit manipulation. It is much easier to see the pattern if you change n=2 to n=3\\nIf I make a loop count from 0 to 2^n then take the difference of what the output and the input should be to find a mask to use the XOR operator with. See the table be low.\\n_________________________  \\n\\t0 = 000 --->0 = 000          difference = 000\\n\\t1 = 001 --->1 = 001          difference = 000\\n\\t2 = 010 --->3 =011           difference = 001\\n\\t3 =011 --->2 = 010           difference = 001\\n\\t4 =100 --->6 =110            difference = 010\\n\\t5 =101 --->7 =111            difference = 010\\n\\t6 =110 --->5 =101            difference = 011\\n\\t7 =111 --->4 =100            difference = 011\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        if n ==0:\\n            return [0]\\n        \\n        out = [0,1]\\n        mask =0\\n        for j in range(2,2**n):\\n            if j%2 ==0:\\n                mask +=1\\n            out.append(j^mask)\\n        return out\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        if n ==0:\\n            return [0]\\n        \\n        out = [0,1]\\n        mask =0\\n        for j in range(2,2**n):\\n            if j%2 ==0:\\n                mask +=1\\n            out.append(j^mask)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423263,
                "title": "two-python-solutions-with-video-explanations",
                "content": "**Solution 1**\\n```\\ndef grayCode(self, n):\\n\\tres = []\\n\\tfor i in range(1 << n):\\n\\t\\tres.append(i ^ (i >> 1))\\n\\treturn res\\n```\\n\\n**Solution 2**\\n```\\ndef grayCode(self, n):\\n\\tdef helper(n):\\n\\t\\tif n == 0:\\n\\t\\t\\treturn [\\'0\\']\\n\\t\\tif n == 1:\\n\\t\\t\\treturn [\\'0\\', \\'1\\']\\n\\t\\tres = helper(n - 1)\\n\\t\\treturn [\\'0\\' + s for s in res] + [\\'1\\' + s for s in res[::-1]]\\n\\n\\treturn [int(s, 2) for s in helper(n)]\\n```\\n\\n**Video explanation for Gray Code**\\nhttps://www.youtube.com/watch?v=oVMOTNqVYns\\n\\n**Video explanation for both solutions**\\nhttps://www.youtube.com/watch?v=CHr3V8JDa1w\\n",
                "solutionTags": [],
                "code": "```\\ndef grayCode(self, n):\\n\\tres = []\\n\\tfor i in range(1 << n):\\n\\t\\tres.append(i ^ (i >> 1))\\n\\treturn res\\n```\n```\\ndef grayCode(self, n):\\n\\tdef helper(n):\\n\\t\\tif n == 0:\\n\\t\\t\\treturn [\\'0\\']\\n\\t\\tif n == 1:\\n\\t\\t\\treturn [\\'0\\', \\'1\\']\\n\\t\\tres = helper(n - 1)\\n\\t\\treturn [\\'0\\' + s for s in res] + [\\'1\\' + s for s in res[::-1]]\\n\\n\\treturn [int(s, 2) for s in helper(n)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 259921,
                "title": "python-20ms-2-methods",
                "content": "Method 1 : according to the Gray Code generation principle (you can check it on the Internet)\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(1<<n):\\n            res.append(i^(i>>1))      \\n        return res\\n```\\n\\nMethod 2 :  iteration and mirror\\n\\nSuch as n = 1 , the gray code is [0,1] ;\\nand when n = 2 ,  the gray code is [0,1,3,2] , equal to [0,1] + [1,0](each element plus 2**(n-1))\\nso when n = 3 , the gray code is [0,1,3,2] + [2,3,1,0](each element plus 2**2) , just [0,1,3,2,6,7,5,4]\\n\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        temp = self.grayCode(n-1)\\n        temp1 = [i+2**(n-1) for i in temp[::-1]]\\n        res = temp + temp1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(1<<n):\\n            res.append(i^(i>>1))      \\n        return res\\n```\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        temp = self.grayCode(n-1)\\n        temp1 = [i+2**(n-1) for i in temp[::-1]]\\n        res = temp + temp1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204179,
                "title": "simple-java-solution",
                "content": "Recursion and the mirror image property of gray codes+ add pow(2,n-1) can be used.\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==0){\\n            List<Integer> result = new ArrayList<Integer>();\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        List<Integer> result= grayCode(n-1);\\n        int numToAdd= 1<<(n-1);\\n        for(int i=result.size()-1;i>=0;i--) {\\n            result.add(numToAdd+result.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==0){\\n            List<Integer> result = new ArrayList<Integer>();\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        List<Integer> result= grayCode(n-1);\\n        int numToAdd= 1<<(n-1);\\n        for(int i=result.size()-1;i>=0;i--) {\\n            result.add(numToAdd+result.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156204,
                "title": "simple-java-solution-with-comments",
                "content": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> arr=new ArrayList<>();\\n        \\n        if(n==0)\\n        {\\n            arr.add(0);\\n            return arr;\\n        }\\n        arr.add(0);\\n        arr.add(1);\\n        int ptr=1;\\n\\n        while(ptr<n){\\n            for(int i=arr.size()-1;i>=0;i--){\\n                arr.add((1<<ptr)+arr.get(i));\\n            }\\n            ptr++;\\n        }\\n        // initially \\n        // 0\\n        // 1\\n        // arr = [0, 1]\\n        // now - for ptr=1, following is added\\n        // 11\\n        // 10\\n        // arr = [0, 1, 3, 2]\\n        // now for ptr=2, following is added\\n        // 101\\n        // 111\\n        // 101\\n        // 100\\n        // arr = [0, 1, 3, 2, 6, 7, 5, 4]\\n        // for each new ptr we add 1<<ptr to the reverse order of previous ptr values.\\n        // eg  6=(1<<2)+2\\n        // eg  7=(1<<2)+3\\n        // eg  5=(1<<2)+1\\n        // eg  4=(1<<2)+0\\n        // and [2, 3, 1, 0] are reverse of previous ptr arr values\\n        \\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> arr=new ArrayList<>();\\n        \\n        if(n==0)\\n        {\\n            arr.add(0);\\n            return arr;\\n        }\\n        arr.add(0);\\n        arr.add(1);\\n        int ptr=1;\\n\\n        while(ptr<n){\\n            for(int i=arr.size()-1;i>=0;i--){\\n                arr.add((1<<ptr)+arr.get(i));\\n            }\\n            ptr++;\\n        }\\n        // initially \\n        // 0\\n        // 1\\n        // arr = [0, 1]\\n        // now - for ptr=1, following is added\\n        // 11\\n        // 10\\n        // arr = [0, 1, 3, 2]\\n        // now for ptr=2, following is added\\n        // 101\\n        // 111\\n        // 101\\n        // 100\\n        // arr = [0, 1, 3, 2, 6, 7, 5, 4]\\n        // for each new ptr we add 1<<ptr to the reverse order of previous ptr values.\\n        // eg  6=(1<<2)+2\\n        // eg  7=(1<<2)+3\\n        // eg  5=(1<<2)+1\\n        // eg  4=(1<<2)+0\\n        // and [2, 3, 1, 0] are reverse of previous ptr arr values\\n        \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123663,
                "title": "just-share-some-more-about-gray-code-tower-of-hanoi",
                "content": "First I definitely agree with other commentors that this is not a great interview question since it doesn\\'t really reveal much about candidates\\'s competency. I just want to share more about what I read recently about gray code. Knuth devoted a lot of pages to gray code in his The Art of Programming Volume 4A starting at page 281.  The idea is to have a variable i iterate over 0 to 1 << N. And for each i, find the first bit set, and flip that bit on the previous value. NO credit belongs to me here. Here is my code:\\n\\n```\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> r;\\n        int m = 0;\\n        r.push_back(m);\\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                if ((1<<j) & i) {\\n                    m = m ^ (1<<j);\\n                    r.push_back(m); // Of course we can use built in functions in C/C++ like ffs\\n                    break;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\nIf you read more of Knuth\\'s book, it also says it\\'s related to ancient Chinese puzzle \\u4E5D\\u8FDE\\u73AF. If you buy one from Amazon and play with it, you would find graycode truly amazing. It\\'s also related to iterative solution of tower of hanoi.",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> r;\\n        int m = 0;\\n        r.push_back(m);\\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                if ((1<<j) & i) {\\n                    m = m ^ (1<<j);\\n                    r.push_back(m); // Of course we can use built in functions in C/C++ like ffs\\n                    break;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29885,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        return [(num ^ (num >> 1)) for num in range(2 ** n)]\\n```\\n\\n*By Yangshun*",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        return [(num ^ (num >> 1)) for num in range(2 ** n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29999,
                "title": "6-lines-4ms-easy-c-solution",
                "content": "    vector<int> grayCode(int n) {\\n        vector<int>res;\\n        for(int i=0;i<(1<<n);i++){\\n            res.push_back(i^(i>>1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> grayCode(int n) {\\n        vector<int>res;\\n        for(int i=0;i<(1<<n);i++){\\n            res.push_back(i^(i>>1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30010,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "After seeing the top voted post, I find their idea is really elegant. We just need to double expand the previous layer element by adding 1 to all the element of the previous layer.\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result(1, 0);\\n            /** level-by-level expand the result **/\\n            /** add 1 to prefix of each int the previous layer ***/\\n            for(int i=0; i<n; i++){\\n                int cur=result.size();\\n                while(cur){\\n                    cur--;\\n                    int temp=result[cur];\\n                    temp+=(1<<i);\\n                    result.push_back(temp);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result(1, 0);\\n            /** level-by-level expand the result **/\\n            /** add 1 to prefix of each int the previous layer ***/\\n            for(int i=0; i<n; i++){\\n                int cur=result.size();\\n                while(cur){\\n                    cur--;\\n                    int temp=result[cur];\\n                    temp+=(1<<i);\\n                    result.push_back(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 30022,
                "title": "multiple-approaches-topdown-bottom-up-recursive",
                "content": "\\n**Build up, DP table** \\n\\n    vector<int> grayCode_dp(int n) {\\n        if( n == 0) return {0};\\n        vector<int> prev={0};\\n        \\n        for( int cur=1; cur<=n; cur++)\\n            for( int j=prev.size()-1; j>=0; j--)\\n                    prev.push_back( (1<<(cur-1))|prev[j]);    \\n        return prev;\\n    }\\n\\n**top down, Just recursive**\\n\\n\\n    vector<int> grayCode_rec(int n) {\\n        \\n        if( n == 0) return {0};\\n        if( n == 1) return {0,1};\\n        \\n        vector<int> cur;\\n        vector<int> prev=grayCode(n-1);\\n        for( auto val : prev )\\n        {\\n            cur.push_back( (0<<n)|val);    \\n        }\\n        for( int j=prev.size()-1;j>=0;j--)\\n        {\\n            cur.push_back( (1<<(n-1))|prev[j]);    \\n        }\\n        return cur;\\n    }\\n};\\n\\n\\n**Truncated BFS with O(1 shft by n) space**\\n\\n        vector<int> res;\\n    void gc(int n, int cur, vector<bool> &exists )\\n    {\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int temp= cur^ (1<<i);\\n            \\n            if(exists[temp] == false)\\n            {\\n                exists[temp]=true;\\n                res.push_back(temp);\\n                gc(n, temp, exists);\\n                break;\\n            }\\n        }\\n        \\n    }\\n    vector<int> grayCode(int n , int cur=0) {\\n        \\n        \\n        vector<bool> exists(1<<n,false);\\n        exists[0]=true;\\n        res.push_back(0);\\n        gc(n,0, exists);\\n        \\n        return res;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "\\n**Build up, DP table** \\n\\n    vector<int> grayCode_dp(int n) {\\n        if( n == 0) return {0};\\n        vector<int> prev={0};\\n        \\n        for( int cur=1; cur<=n; cur++)\\n            for( int j=prev.size()-1; j>=0; j--)\\n                    prev.push_back( (1<<(cur-1))|prev[j]);    \\n        return prev;\\n    }\\n\\n**top down, Just recursive**\\n\\n\\n    vector<int> grayCode_rec(int n) {\\n        \\n        if( n == 0) return {0};\\n        if( n == 1) return {0,1};\\n        \\n        vector<int> cur;\\n        vector<int> prev=grayCode(n-1);\\n        for( auto val : prev )\\n        {\\n            cur.push_back( (0<<n)|val);    \\n        }\\n        for( int j=prev.size()-1;j>=0;j--)\\n        {\\n            cur.push_back( (1<<(n-1))|prev[j]);    \\n        }\\n        return cur;\\n    }\\n};\\n\\n\\n**Truncated BFS with O(1 shft by n) space**\\n\\n        vector<int> res;\\n    void gc(int n, int cur, vector<bool> &exists )\\n    {\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int temp= cur^ (1<<i);\\n            \\n            if(exists[temp] == false)\\n            {\\n                exists[temp]=true;\\n                res.push_back(temp);\\n                gc(n, temp, exists);\\n                break;\\n            }\\n        }\\n        \\n    }\\n    vector<int> grayCode(int n , int cur=0) {\\n        \\n        \\n        vector<bool> exists(1<<n,false);\\n        exists[0]=true;\\n        res.push_back(0);\\n        gc(n,0, exists);\\n        \\n        return res;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30066,
                "title": "my-java-solution-6-lines-easy-to-understand",
                "content": "    public List<Integer> grayCode(int n) {\\n    \\tList<Integer> output = new ArrayList<Integer>();\\t\\n    \\toutput.add(0);\\n    \\tfor (int i = 1; i <= n; i++)\\n    \\t\\tfor (int j = output.size() - 1; j >= 0; j--)\\n    \\t\\t\\toutput.add(output.get(j) + (int)Math.pow(2, i - 1));   \\t\\n    \\treturn output;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n    \\tList<Integer> output = new ArrayList<Integer>();\\t\\n    \\toutput.add(0);\\n    \\tfor (int i = 1; i <= n; i++)\\n    \\t\\tfor (int j = output.size() - 1; j >= 0; j--)\\n    \\t\\t\\toutput.add(output.get(j) + (int)Math.pow(2, i - 1));   \\t\\n    \\treturn output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30068,
                "title": "share-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> seq = {0};\\n            if (n == 0) {\\n                return seq;\\n            }\\n            \\n            seq = grayCode(n-1);\\n            int len = seq.size();\\n            int mask = 1 << (n-1);\\n            for (int i = len-1; i >= 0; i--) {\\n                seq.push_back(seq[i] | mask);\\n            }\\n            return seq;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> seq = {0}",
                "codeTag": "Java"
            },
            {
                "id": 30070,
                "title": "java-solution-with-explanation",
                "content": "\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        if (n == 0) return res;\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            temp.addAll(res);\\n            for (int j = temp.size() - 1; j >= 0; j--) {\\n                res.add((1<<i) + temp.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n\\n - 000\\n - 001\\n - 011\\n - 010\\n - ---------\\n - 110\\n - 111\\n - 101\\n - 100\\n\\n\\n----------\\nThink about how to get gray code when n is 3: the first 4 gray codes is the same with when n equals to 2, and the last gray codes is adding 1 in front of the gray codes when n is 2. The first 4 is symmetric to the last 4.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        if (n == 0) return res;\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            temp.addAll(res);\\n            for (int j = temp.size() - 1; j >= 0; j--) {\\n                res.add((1<<i) + temp.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n\\n - 000\\n - 001\\n - 011\\n - 010\\n - ---------\\n - 110\\n - 111\\n - 101\\n - 100\\n\\n\\n----------\\nThink about how to get gray code when n is 3: the first 4 gray codes is the same with when n equals to 2, and the last gray codes is adding 1 in front of the gray codes when n is 2. The first 4 is symmetric to the last 4.",
                "codeTag": "Unknown"
            },
            {
                "id": 30078,
                "title": "python-5-lines-no-recursive-just-generate-the-result",
                "content": "    def grayCode(self, n):\\n            ret = [0]\\n            for k in range(0, n):\\n                for i in range(len(ret)-1, -1, -1):\\n                    ret.append(ret[i]+(2**k))\\n            return ret\\n\\nThe idea as below.\\n\\nf(n=1) :\\n\\n    0\\n    1\\n\\nf(n=2) :  \\nafter got result of f(n = 1), add 1 to every elements's binary value, add result to the f(n = 1) reversed order.\\n\\n          00 \\n          01 \\n    1 --> 11\\n    0 --> 10\\n\\nf(n=3) :  do as above.\\n\\n           000 \\n           001 \\n           011\\n           010\\n    10 --> 110\\n    11 --> 111\\n    01 --> 101\\n    00 --> 100\\n\\nn = 4, 5, 6... as above.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def grayCode(self, n):\\n            ret = [0]\\n            for k in range(0, n):\\n                for i in range(len(ret)-1, -1, -1):\\n                    ret.append(ret[i]+(2**k))\\n            return ret\\n\\nThe idea as below.\\n\\nf(n=1) :\\n\\n    0\\n    1\\n\\nf(n=2) :  \\nafter got result of f(n = 1), add 1 to every elements's binary value, add result to the f(n = 1) reversed order.\\n\\n          00 \\n          01 \\n    1 --> 11\\n    0 --> 10\\n\\nf(n=3) :  do as above.\\n\\n           000 \\n           001 \\n           011\\n           010\\n    10 --> 110\\n    11 --> 111\\n    01 --> 101\\n    00 --> 100\\n\\nn = 4, 5, 6... as above.",
                "codeTag": "Python3"
            },
            {
                "id": 30061,
                "title": "solution-using-binary-tree",
                "content": "We can represent binary numbers as paths of binary tree.  \\nLeft node value is parent value times 2. \\nRight node value is parent value times 2 plus 1.\\nWe can only change a single part of a path at a time.\\nWe will look for a pattern to accomplish this.\\n\\n         /*\\n    \\t *                                  _____0_____                     000                      0000\\n    \\t *                                 /           \\\\                    001                      0001\\n    \\t *                              __0_           _1__                 011                      0011\\n    \\t *                             /    \\\\         /    \\\\                010                      0010\\n    \\t *                            0      1       2      3               110                      0110 \\n    \\t *                           / \\\\    / \\\\     / \\\\    / \\\\              111                      0111\\n    \\t *                          0   1  2   3   4   5  6   7             101                      0101 \\n    \\t *                                                                  100                      0100\\n    \\t *              n=0                                  0                                       1100\\n    \\t *              n=1                    0                            1                        1101 \\n    \\t *              n=2             0            1              3                2               1111 \\n    \\t *              n=3         0      1     3       2       6     7         5       4           1110   \\n    \\t *              n=4        0,1    3,2   6,7     5,4    12,13 15,14      10,11   9,8          1010    \\n    \\t *                                                                                           1011 \\n    \\t *                                                                                           1001\\n    \\t *                                                                                           1000\\n    \\t */\\n    public class Solution {\\n        public List<Integer> grayCode(int n){\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tresult.add(0);\\n    \\t\\t\\n    \\t\\tfor (int i=0;i<n;i++){\\n    \\t\\t\\tboolean smallerFirst=true;\\n    \\t\\t\\tList<Integer> temp = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int val:result){\\n    \\t\\t\\t\\tif (smallerFirst){\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tsmallerFirst=!smallerFirst;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult = temp;\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n){\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tresult.add(0);\\n    \\t\\t\\n    \\t\\tfor (int i=0;i<n;i++){\\n    \\t\\t\\tboolean smallerFirst=true;\\n    \\t\\t\\tList<Integer> temp = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int val:result){\\n    \\t\\t\\t\\tif (smallerFirst){\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 30088,
                "title": "accepted-4ms-c-recursive-solution-only-6-lines-easy-understand",
                "content": "If n = 2, the result will be:\\n\\n    00\\n    01\\n    11\\n    10\\n\\nIf n = 3, the result will be:\\n\\n    0  00\\n    0  01\\n    0  11\\n    0  10\\n    -----\\n    1  10\\n    1  11\\n    1  01\\n    1  00\\n\\nEasy to get the accepted solution:\\n\\n    class Solution {\\n    public:\\n        std::vector<int> grayCode(int n) {\\n    \\t\\tif (!n) \\n    \\t\\t\\treturn std::vector<int>(1);\\n            std::vector<int> res = grayCode(n - 1);\\n    \\t\\tfor (int i = res.size() - 1; i >= 0; --i)\\n    \\t\\t\\tres.push_back(res[i] + (1 << (n - 1))); // or res.push_back(res[i] | (1 << (n - 1)));\\n    \\t\\treturn res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::vector<int> grayCode(int n) {\\n    \\t\\tif (!n) \\n    \\t\\t\\treturn std::vector<int>(1);\\n            std::vector<int> res = grayCode(n - 1);\\n    \\t\\tfor (int i = res.size() - 1; i >= 0; --i)\\n    \\t\\t\\tres.push_back(res[i] + (1 << (n - 1))); // or res.push_back(res[i] | (1 << (n - 1)));\\n    \\t\\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 30097,
                "title": "my-c-solution-7ms-17lines",
                "content": "The basic idea is following:\\nif n = 3<br>\\n000<br>\\n001<br>\\n011<br>\\n010<br>\\n100<br>\\n101<br>\\n111<br>\\n110<br>\\nLook the columns, it is a repeat of {0, 1, 1, 0}. The first column (from the right) is 0110, the send column is 00111100, every element repeat twice, the third column is 0000111111110000, every element repeat four times.\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int num = 1 << n;\\n            int sum = 0;\\n            vector<int> res;\\n            int t[] = {0, 1, 1, 0};\\n            for (int i = 0; i < num; ++i) {\\n                sum = 0;\\n                for (int j = 0; j < n; ++j) {\\n                    sum += t[i/(1 << j) % 4] * (1 << j);\\n                }\\n                res.push_back(sum);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int num = 1 << n;\\n            int sum = 0;\\n            vector<int> res;\\n            int t[] = {0, 1, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 3831538,
                "title": "c-very-easy-solution-beats-100-users-with-0ms-runtime",
                "content": "# Intuition\\nFor each adjacent pair to be differing by a bit the difference between them should be a 2 power.\\n\\n# Approach\\nBy observation we can get to a conclusion that for every increment of n, adding 1<<n to previous elements in the vector all the way till beginning starting from end and adding them into the vector simultaneously gives the differenec between each adjacent elements in the vector a power of 2 i.e., 1, 2, 4, 8, ....\\n\\n# Complexity\\n- Time complexity : $$O(1<<n)$$\\n\\n- Space complexity : $$O(1<<n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> p = {0, 1};\\n        n--;\\n\\n        int prod = 1;\\n        while(n>0){\\n            prod = prod*2;\\n            for(int i=p.size()-1; i>-1; i--) p.emplace_back(p[i]+prod);\\n            n--;\\n        }\\n\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> p = {0, 1};\\n        n--;\\n\\n        int prod = 1;\\n        while(n>0){\\n            prod = prod*2;\\n            for(int i=p.size()-1; i>-1; i--) p.emplace_back(p[i]+prod);\\n            n--;\\n        }\\n\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737460,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151508,
                "title": "gray-code-rust-fast-and-easy-solution-beats-100-in-both-time-and-space-complexity",
                "content": "# Intuition\\nI knew there was some technique to calculate gray code from the binary number. I had learnt that in the first semester in the subject Digital Logic class. So wanted to convert that technique to bitwise operations.\\n\\n# Approach\\nEssentially, what you need to do is, you have to XOR the first bit with the next bit, and do it sequencially till the end. The very first bit is copied as it is, and all the subsequent bits is computed from the XOR operation between adjacent bits, till the end.\\n\\nLet us understand from the example below:\\n101110011:\\n```\\n1   0   1   1   1   0   0   1   1\\n|\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\n| \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ |\\n|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|\\n1   1   1   0   0   1   0   1   0\\n```\\nSo, all you need to do is iterate from 0 to 2^n and convert all the numbers into gray code.\\n\\nNow, 2^n can be done very cheaply using ` 1 << n`, and the operation shown above can be achieved by the bitwise operation `n ^ (n >> 1)`.\\n\\nWe can see that from following:\\n```\\nRemember, second binary number is the first binary number right shifted once.\\n 1  0  1  1  1  0  0  1  1\\n^0  1  0  1  1  1  0  0  1\\n-|--|--|--|--|--|--|--|--|-\\n 1  1  1  0  0  1  0  1  0\\n```\\n\\nFrom that, we can just use the iterator, map each element to it\\'s equivalent gray code, and collect it to a vector.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity would be $$O(2^n)$$, since we have to create 2^n elements in output, which is created one by one.\\n\\n- Space complexity:\\nSpace complexity would also be $$O(2^n)$$, for the same reason as time complexity (we have to create vector list containint 2^n elements.)\\n\\n# Code\\nThe code is as simple as it looks:\\nIt iterates from 0 to 2^n, converts each one to equivalent gray code, and collects it to a vector.\\n```\\nimpl Solution {\\n    pub fn gray_code(n: i32) -> Vec<i32> {\\n        (0..(1<<n)).map(into_gray).collect()\\n    }\\n}\\n#[inline]\\nfn into_gray(n : i32) -> i32 {\\n    n ^ (n >> 1)\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n1   0   1   1   1   0   0   1   1\\n|\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\n| \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ |\\n|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|\\n1   1   1   0   0   1   0   1   0\\n```\n```\\nRemember, second binary number is the first binary number right shifted once.\\n 1  0  1  1  1  0  0  1  1\\n^0  1  0  1  1  1  0  0  1\\n-|--|--|--|--|--|--|--|--|-\\n 1  1  1  0  0  1  0  1  0\\n```\n```\\nimpl Solution {\\n    pub fn gray_code(n: i32) -> Vec<i32> {\\n        (0..(1<<n)).map(into_gray).collect()\\n    }\\n}\\n#[inline]\\nfn into_gray(n : i32) -> i32 {\\n    n ^ (n >> 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695237,
                "title": "easy-to-understand-python-solution-faster-than-95",
                "content": "```\\n# logic is:\\n# for 1- [0,1]\\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \\noldArr = [0,1]\\ni = 1\\nwhile i< n:\\n\\t# add old array\\n\\tnewArr = list(oldArr)\\n\\t# now add bit value to old reversed values\\n\\tfor j in range(len(oldArr)-1,-1,-1):\\n\\t\\tnewArr.append((2**i)+oldArr[j])\\n\\toldArr = newArr\\n\\ti+=1\\nreturn oldArr",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# logic is:\\n# for 1- [0,1]\\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \\noldArr = [0,1]\\ni = 1\\nwhile i< n:\\n\\t# add old array\\n\\tnewArr = list(oldArr)\\n\\t# now add bit value to old reversed values\\n\\tfor j in range(len(oldArr)-1,-1,-1):\\n\\t\\tnewArr.append((2**i)+oldArr[j])\\n\\toldArr = newArr\\n\\ti+=1\\nreturn oldArr",
                "codeTag": "Unknown"
            },
            {
                "id": 2501346,
                "title": "easy-simple-small-in-o-n-n-2-time-complexity",
                "content": "```\\nimport math\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        n2=2**n\\n        ans=[]\\n        for j in range(n2):\\n            st=0\\n            for i in range(n):\\n                if(((1<<i)&j>0 and (1<<(i+1))&j==0) or ((1<<i)&j==0 and (1<<(i+1))&j>0)):\\n                    st+=2**i\\n            ans.append(st)\\n        return(ans)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        n2=2**n\\n        ans=[]\\n        for j in range(n2):\\n            st=0\\n            for i in range(n):\\n                if(((1<<i)&j>0 and (1<<(i+1))&j==0) or ((1<<i)&j==0 and (1<<(i+1))&j>0)):\\n                    st+=2**i\\n            ans.append(st)\\n        return(ans)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472189,
                "title": "direct-solution-faster-than-99-53-submissions",
                "content": "```\\n\\t\\tvector<int> out;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            out.push_back(i ^(i>>1));\\n        }\\n        return out;\\n```\\n\\nSo, gray code works as follows :  Instead of 3 i.e 110 : It is 101\\nHow?? Each bit position stays the same if the next bit is 0, else flips. \\nIn place of 0b\\'abcd : we get a1_b1_c1_d1. d1==d, if c1 is 0. else flips\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tc1=c, if b1=0. else flips\\nThus the output current bit depends on the input next bit.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tvector<int> out;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            out.push_back(i ^(i>>1));\\n        }\\n        return out;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406111,
                "title": "clean-code",
                "content": "```\\nint gray(int n) {\\n        return n ^ (n >> 1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        n=1<<n;\\n        vector<int> ans(n); // specifying size of vector is important, otherwise Runtime Error\\n        for(int i=0; i<n; i++){\\n            ans[i]= gray(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint gray(int n) {\\n        return n ^ (n >> 1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        n=1<<n;\\n        vector<int> ans(n); // specifying size of vector is important, otherwise Runtime Error\\n        for(int i=0; i<n; i++){\\n            ans[i]= gray(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171923,
                "title": "one-liner-python-solution-using-xor-and-right-shift",
                "content": "**Algorithm:**\\n1) Traverse from 0 to 2**n\\n2) In each iteration, right shift the number once and xor it with the original number to obtain the gray code.\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        ans = []\\n        for i in range(2**n):\\n            ans.append(i ^ (i>>1))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        ans = []\\n        for i in range(2**n):\\n            ans.append(i ^ (i>>1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105684,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [0]\\n        visited = set()\\n        visited.add(0)\\n        self.grayCodeHelper(n, visited, result)\\n        return result\\n    \\n    def grayCodeHelper(self, n, visited, result):\\n        \\n        if len(result) == 1 << n:\\n            return True\\n        \\n        \\n        last_number = result[-1]\\n        \\n        for i in range(0,n):\\n            new_number = last_number ^ (1 << i)\\n                \\n            if new_number not in visited:\\n                visited.add(new_number)\\n                result.append(new_number)\\n                if self.grayCodeHelper(n, visited, result):\\n                    return True\\n                result.pop(-1)\\n                visited.remove(new_number)\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [0]\\n        visited = set()\\n        visited.add(0)\\n        self.grayCodeHelper(n, visited, result)\\n        return result\\n    \\n    def grayCodeHelper(self, n, visited, result):\\n        \\n        if len(result) == 1 << n:\\n            return True\\n        \\n        \\n        last_number = result[-1]\\n        \\n        for i in range(0,n):\\n            new_number = last_number ^ (1 << i)\\n                \\n            if new_number not in visited:\\n                visited.add(new_number)\\n                result.append(new_number)\\n                if self.grayCodeHelper(n, visited, result):\\n                    return True\\n                result.pop(-1)\\n                visited.remove(new_number)\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2046672,
                "title": "observation-easy-c-solution-bit-manipulation",
                "content": "// Just observe the pattern how there is difference between bits in the input and accordingly perform the bits //operation\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>answer;               // create a vector to store the answer\\n        for(int i=0;i<=pow(2,n)-1;i++){      // traverse till 2^n-1 and push (i^(i>>1)) in the answer\\n            answer.push_back(i^(i>>1));\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF YOU FIND IT HELPFUL:)\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>answer;               // create a vector to store the answer\\n        for(int i=0;i<=pow(2,n)-1;i++){      // traverse till 2^n-1 and push (i^(i>>1)) in the answer\\n            answer.push_back(i^(i>>1));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770100,
                "title": "gray-code-solution-java",
                "content": "class Solution {\\n  public List<Integer> grayCode(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    ans.add(0);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = ans.size() - 1; j >= 0; --j)\\n        ans.add(ans.get(j) | 1 << i);\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public List<Integer> grayCode(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    ans.add(0);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = ans.size() - 1; j >= 0; --j)\\n        ans.add(ans.get(j) | 1 << i);\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1749052,
                "title": "several-ways-to-solve-it-cpp-can-t-be-more-simpler",
                "content": "**Way 1 : **\\n\\n![image](https://assets.leetcode.com/users/images/df66a229-1c9b-49d8-b2c8-6b4dcca8a620_1644127722.321113.png)\\n\\nIf you observe carefully gray(n) = gray(n-1) above the lines + gray(n-1) in reverse bellow the lines with extra 1!!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1};\\n        \\n        vector<int> p= grayCode(n-1);\\n        vector<int> q=p;reverse(q.begin(),q.end());\\n        int inc= 1<<(n-1);\\n        for(auto &i : q) i+=inc;\\n        p.insert(p.end(),q.begin(),q.end());\\n        \\n        return p;\\n    }\\n};\\n\\n```\\n\\n\\n**Way 2 **\\n\\n```\\nvector<int> grayCode(int n) {\\n      vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }: \\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1};\\n        \\n        vector<int> p= grayCode(n-1);\\n        vector<int> q=p;reverse(q.begin(),q.end());\\n        int inc= 1<<(n-1);\\n        for(auto &i : q) i+=inc;\\n        p.insert(p.end(),q.begin(),q.end());\\n        \\n        return p;\\n    }\\n};\\n\\n```\n```\\nvector<int> grayCode(int n) {\\n      vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }: \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714940,
                "title": "c-97-faster-nth-gray-code",
                "content": "For a given number `n`, the n-bit gray code can be found as `n^(n/2)`\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> grayCode(int n) \\n    {\\n        vector<int> ans;\\n        int t = pow(2,n);\\n        int i=0;\\n        while(i<t)\\n        {\\n            ans.push_back(i^(i/2));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> grayCode(int n) \\n    {\\n        vector<int> ans;\\n        int t = pow(2,n);\\n        int i=0;\\n        while(i<t)\\n        {\\n            ans.push_back(i^(i/2));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663568,
                "title": "light-weight-python-solution",
                "content": "My solution:\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n        rest = self.grayCode(n - 1)\\n        # everytime it builds one set, reverse the front part\\n        return [ r << 1 for r in rest] + [ (r << 1) + 1 for r in rest[::-1]]\\n```\\n\\nThat was evolved from my first submission which is this:\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = set()\\n        def backtrack(i):\\n            if i == 0:\\n                return [[]]\\n            rest = backtrack(i - 1)\\n            result = []\\n            for r in rest:\\n                result.append(r + [\\'0\\'])\\n            for r in rest[::-1]:\\n                result.append(r + [\\'1\\'])\\n            return result\\n        \\n        return [ int(\"\".join(ar), 2) for ar in backtrack(n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n        rest = self.grayCode(n - 1)\\n        # everytime it builds one set, reverse the front part\\n        return [ r << 1 for r in rest] + [ (r << 1) + 1 for r in rest[::-1]]\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = set()\\n        def backtrack(i):\\n            if i == 0:\\n                return [[]]\\n            rest = backtrack(i - 1)\\n            result = []\\n            for r in rest:\\n                result.append(r + [\\'0\\'])\\n            for r in rest[::-1]:\\n                result.append(r + [\\'1\\'])\\n            return result\\n        \\n        return [ int(\"\".join(ar), 2) for ar in backtrack(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519011,
                "title": "python-one-liner-short-explanation",
                "content": "Picture a cube. 2x2.\\n\\nYou start at the top-left-front corner, labeled `000`. Move back along an edge to the top-left-back corner to get `001`. Looks like just increasing by 1 each time, but if we go to 2 (corner `010`) we change two bits. Hop to the right to 3 instead, which is at corner `011`. Then, we can go to 2 `010`.\\n\\nSo, when we switch to the right side of the cube (i.e. when we switch the second digit to `1`) we go the opposite direction, starting from the top (3) and decreasing (to 2), in effect inverting the third digit.\\n\\nAs we continue this reversing onto the bottom side of the cube (go for a tesseract if you\\'re feeling particularly marvelous), a bitwise pattern emerges. Take the binary representations of the counting numbers (the boringest way to say `000`, `001`, `010`, `011`, `100`, etc.) and whenever there is a `1` (the equivalent of being on the \"backwards\" side of the cube), invert the next bit. In a truth table, with the current bit on the side and previous bit on the top, you get\\n\\n```\\n    0  1\\n    ----\\n0 | 0  1\\n1 | 1  0\\n```\\n\\nOh neat! That looks like `XOR`! So we just want to `XOR` each number with itself, but pushed over one to the right. Bit of golf to iterate through the numbers from 0 to 2^n, right shift it over once, and then save the `XOR` result in a list.\\n\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i>>1) for i in range(1<<n)]\\n```\\n\\nAlso, this provides a O(1) function to retrieve the value in the sequence at *any* index. Which is neat.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    0  1\\n    ----\\n0 | 0  1\\n1 | 1  0\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i>>1) for i in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498963,
                "title": "gray-code-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==1){\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<Integer>();\\n        for(int i=0;i<pres.size();i++){\\n            mres.add(0+2*pres.get(i));\\n        }\\n        for(int i=pres.size()-1 ; i>=0;i--){\\n            mres.add(1+2*pres.get(i));\\n        }\\n        \\n        return mres;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==1){\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<Integer>();\\n        for(int i=0;i<pres.size();i++){\\n            mres.add(0+2*pres.get(i));\\n        }\\n        for(int i=pres.size()-1 ; i>=0;i--){\\n            mres.add(1+2*pres.get(i));\\n        }\\n        \\n        return mres;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564717,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1565251,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1566741,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568912,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1766371,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1571197,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1786326,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1785411,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1573702,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 2006483,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1564717,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1565251,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1566741,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568912,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1766371,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1571197,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1786326,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1785411,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1573702,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 2006483,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568911,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1996171,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1571198,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1573155,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2059245,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2022337,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2016675,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1990286,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1960932,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1906517,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            }
        ]
    }
]