[
    {
        "title": "Weird Algorithm",
        "sample1_input": "3",
        "sample1_output": "3 10 5 16 8 4 2 1",
        "sample2_input": "7",
        "sample2_output": "7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1",
        "sample3_input": "10",
        "sample3_output": "10 5 16 8 4 2 1",
        "sample4_input": "1",
        "sample4_output": "1",
        "sample5_input": "13",
        "sample5_output": "13 40 20 10 5 16 8 4 2 1",
        "task_id": 1,
        "text": "Consider an algorithm that takes as input a positive integer n. If n is even, the algorithm divides it by two, and if n is odd, the algorithm multiplies it by three and adds one. The algorithm repeats this, until n is one. For example, the sequence for n=3 is as follows:\n 3 \\rightarrow 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\nYour task is to simulate the execution of the algorithm for a given value of n.\nInput\nThe only input line contains an integer n.\nOutput\nPrint a line that contains all values of n during the algorithm.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n\nOutput:\n3 10 5 16 8 4 2 1\n",
        "code": "def main(n):\n    result = []\n    while n != 1:\n        result.append(n)\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = n * 3 + 1\n    result.append(1)\n    return result",
        "test_list": [
            "assert main(3) == 3 10 5 16 8 4 2 1",
            "assert main(7) == 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1",
            "assert main(10) == 10 5 16 8 4 2 1",
            "assert main(1) == 1",
            "assert main(13) == 13 40 20 10 5 16 8 4 2 1"
        ]
    },
    {
        "title": "Missing Number",
        "sample1_input": "5,[2,3,1,5]",
        "sample1_output": "4",
        "sample2_input": "10,[2,3,1,10,6,7,4,8,5]",
        "sample2_output": "9",
        "sample3_input": "3,[2,3]",
        "sample3_output": "1",
        "sample4_input": "6,[4,3,5,1,2]",
        "sample4_output": "6",
        "sample5_input": "4,[2,1,4]",
        "sample5_output": "3",
        "task_id": 2,
        "text": "You are given all numbers between 1,2,\\ldots,n except one. Your task is to find the missing number.\nInput\nThe first input line contains an integer n.\nThe second line contains n-1 numbers. Each number is distinct and between 1 and n (inclusive).\nOutput\nPrint the missing number.\nConstraints\n\n2 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n5\n2 3 1 5\n\nOutput:\n4\n",
        "code": "def main(n, numbers):\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(numbers)\n    missing_number = total_sum - actual_sum\n    return missing_number",
        "test_list": [
            "assert main(5,[2,3,1,5]) == 4",
            "assert main(10,[2,3,1,10,6,7,4,8,5]) == 9",
            "assert main(3,[2,3]) == 1",
            "assert main(6,[4,3,5,1,2]) == 6",
            "assert main(4,[2,1,4]) == 3"
        ]
    },
    {
        "title": "Repetitions",
        "sample1_input": "ATTCGGGA",
        "sample1_output": "3",
        "sample2_input": "ACGTACGTACGT",
        "sample2_output": "1",
        "sample3_input": "AAAAAA",
        "sample3_output": "6",
        "sample4_input": "CGTA",
        "sample4_output": "1",
        "sample5_input": "GCGCGCGC",
        "sample5_output": "8",
        "task_id": 3,
        "text": "You are given a DNA sequence: a string consisting of characters A, C, G, and T. Your task is to find the longest repetition in the sequence. This is a maximum-length substring containing only one type of character.\nInput\nThe only input line contains a string of n characters.\nOutput\nPrint one integer: the length of the longest repetition.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nATTCGGGA\n\nOutput:\n3\n",
        "code": "def main(dna_sequence):\n    max_repetition_length = 0\n    current_repetition_length = 1\n\n    for i in range(1, len(dna_sequence)):\n        if dna_sequence[i] == dna_sequence[i - 1]:\n            current_repetition_length += 1\n        else:\n            max_repetition_length = max(max_repetition_length, current_repetition_length)\n            current_repetition_length = 1\n\n    # Check the last repetition if it's the longest\n    max_repetition_length = max(max_repetition_length, current_repetition_length)\n\n    return str(max_repetition_length)",
        "test_list": [
            "assert main(ATTCGGGA) == 3",
            "assert main(ACGTACGTACGT) == 1",
            "assert main(AAAAAA) == 6",
            "assert main(CGTA) == 1",
            "assert main(GCGCGCGC) == 8"
        ]
    },
    {
        "title": "Increasing Array",
        "sample1_input": "5,[3,2,5,1,7]",
        "sample1_output": "5",
        "sample2_input": "3,[3,1,1]",
        "sample2_output": "0",
        "sample3_input": "4,[4,2,3,7]",
        "sample3_output": "3",
        "sample4_input": "2,[1000000000,1]",
        "sample4_output": "999999999",
        "sample5_input": "6,[1,2,3,4,5,6]",
        "sample5_output": "0",
        "task_id": 4,
        "text": "You are given an array of n integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.\nOn each move, you may increase the value of any element by one. What is the minimum number of moves required?\nInput\nThe first input line contains an integer n: the size of the array.\nThen, the second line contains n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint the minimum number of moves.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n3 2 5 1 7\n\nOutput:\n5\n",
        "code": "def main(n, arr):\n    moves = 0\n    prev = arr[0]\n\n    for i in range(1, n):\n        if arr[i] < prev:\n            moves += prev - arr[i]\n        else:\n            prev = arr[i]\n\n    return str(moves)",
        "test_list": [
            "assert main(5,[3,2,5,1,7]) == 5",
            "assert main(3,[3,1,1]) == 0",
            "assert main(4,[4,2,3,7]) == 3",
            "assert main(2,[1000000000,1]) == 999999999",
            "assert main(6,[1,2,3,4,5,6]) == 0"
        ]
    },
    {
        "title": "Permutations",
        "sample1_input": "5",
        "sample1_output": "2 4 1 3 5",
        "sample2_input": "3",
        "sample2_output": "NO SOLUTION",
        "sample3_input": "4",
        "sample3_output": "2 4 1 3",
        "sample4_input": "6",
        "sample4_output": "2 4 6 1 3 5",
        "sample5_input": "1",
        "sample5_output": "1",
        "task_id": 5,
        "text": "A permutation of integers 1,2,\\ldots,n is called beautiful if there are no adjacent elements whose difference is 1.\nGiven n, construct a beautiful permutation if such a permutation exists.\nInput\nThe only input line contains an integer n.\nOutput\nPrint a beautiful permutation of integers 1,2,\\ldots,n. If there are several solutions, you may print any of them. If there are no solutions, print \"NO SOLUTION\".\nConstraints\n\n1 \\le n \\le 10^6\n\nExample 1\nInput:\n5\n\nOutput:\n4 2 5 3 1\nExample 2\nInput:\n3\n\nOutput:\nNO SOLUTION\n",
        "code": "def main(n):\n    if n == 2 or n == 3:\n        return \"NO SOLUTION\"\n    even_numbers = [i for i in range(2, n+1, 2)]\n    odd_numbers = [i for i in range(1, n+1, 2)]\n    return ' '.join(map(str, even_numbers + odd_numbers))",
        "test_list": [
            "assert main(5) == 2 4 1 3 5",
            "assert main(3) == NO SOLUTION",
            "assert main(4) == 2 4 1 3",
            "assert main(6) == 2 4 6 1 3 5",
            "assert main(1) == 1"
        ]
    },
    {
        "title": "Number Spiral",
        "sample1_input": "3,[(2,3),(1,1),(4,2)]",
        "sample1_output": "[6, 1, 1]",
        "sample2_input": "2,[(5,5),(3,4)]",
        "sample2_output": "[21, 14]",
        "sample3_input": "1,[(7,8)]",
        "sample3_output": "[58]",
        "sample4_input": "2,(10,6),(9,7)",
        "sample4_output": "[87, 75]",
        "sample5_input": "2,[(1000000000,1000000000),(999999999,999999998)]",
        "sample5_output": "[999999999000000001, 999999997000000004]",
        "task_id": 6,
        "text": "A number spiral is an infinite grid whose upper-left square has number 1. Here are the first five layers of the spiral:\n\nYour task is to find out the number in row y and column x.\nInput\nThe first input line contains an integer t: the number of tests.\nAfter this, there are t lines, each containing integers y and x.\nOutput\nFor each test, print the number in row y and column x.\nConstraints\n\n1 \\le t \\le 10^5\n1 \\le y,x \\le 10^9\n\nExample\nInput:\n3\n2 3\n1 1\n4 2\n\nOutput:\n8\n1\n15\n",
        "code": "def find_number_in_spiral(y, x):\n    # Identify the layer of the point\n    layer = max(y, x)\n    # Determine the number at the last position of the layer\n    last_number = layer**2 - layer + 1\n    \n    if layer % 2 == 0:\n        if x == layer:\n            return last_number + (layer - y)\n        else:\n            return last_number - (layer - x)\n    else:\n        if y == layer:\n            return last_number + (layer - x)\n        else:\n            return last_number - (layer - y)\n\ndef main(t, test_cases):\n    results = []\n    for y, x in test_cases:\n        results.append(find_number_in_spiral(y, x))\n    return results",
        "test_list": [
            "assert main(3,[(2,3),(1,1),(4,2)]) == [6, 1, 1]",
            "assert main(2,[(5,5),(3,4)]) == [21, 14]",
            "assert main(1,[(7,8)]) == [58]",
            "assert main(2,(10,6),(9,7)) == [87, 75]",
            "assert main(2,[(1000000000,1000000000),(999999999,999999998)]) == [999999999000000001, 999999997000000004]"
        ]
    },
    {
        "title": "Two Knights",
        "sample1_input": "8",
        "sample1_output": "[0, 6, 28, 96, 252, 550, 1056, 1848]",
        "sample2_input": "5",
        "sample2_output": "[0, 6, 28, 96, 252]",
        "sample3_input": "3",
        "sample3_output": "[0, 6, 28]",
        "sample4_input": "10",
        "sample4_output": "[0, 6, 28, 96, 252, 550, 1056, 1848, 3024, 4624]",
        "sample5_input": "1",
        "sample5_output": "[0]",
        "task_id": 7,
        "text": "Your task is to count for k=1,2,\\ldots,n the number of ways two knights can be placed on a k \\times k chessboard so that they do not attack each other.\nInput\nThe only input line contains an integer n.\nOutput\nPrint n integers: the results.\nConstraints\n\n1 \\le n \\le 10000\n\nExample\nInput:\n8\n\nOutput:\n0\n6\n28\n96\n252\n550\n1056\n1848\n",
        "code": "def main(n):\n    results = []\n    for k in range(1, n + 1):\n        if k == 1:\n            ways = 0\n        elif k == 2:\n            ways = 6\n        else:\n            ways = (k * k * (k * k - 1)) // 2 - 4 * (k - 1) * (k - 2)\n        results.append(ways)\n    return results",
        "test_list": [
            "assert main(8) == [0, 6, 28, 96, 252, 550, 1056, 1848]",
            "assert main(5) == [0, 6, 28, 96, 252]",
            "assert main(3) == [0, 6, 28]",
            "assert main(10) == [0, 6, 28, 96, 252, 550, 1056, 1848, 3024, 4624]",
            "assert main(1) == [0]"
        ]
    },
    {
        "title": "Bit Strings",
        "sample1_input": "3",
        "sample1_output": "8",
        "sample2_input": "5",
        "sample2_output": "32",
        "sample3_input": "1",
        "sample3_output": "2",
        "sample4_input": "6",
        "sample4_output": "64",
        "sample5_input": "10",
        "sample5_output": "1024",
        "task_id": 8,
        "text": "Your task is to calculate the number of bit strings of length n.\nFor example, if n=3, the correct answer is 8, because the possible bit strings are 000, 001, 010, 011, 100, 101, 110, and 111.\nInput\nThe only input line has an integer n.\nOutput\nPrint the result modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n\nOutput:\n8\n",
        "code": "def main(n):\n    MOD = 10**9 + 7\n    result = 2 ** n % MOD\n    return result",
        "test_list": [
            "assert main(3) == 8",
            "assert main(5) == 32",
            "assert main(1) == 2",
            "assert main(6) == 64",
            "assert main(10) == 1024"
        ]
    },
    {
        "title": "Trailing Zeros",
        "sample1_input": "20",
        "sample1_output": "4",
        "sample2_input": "10",
        "sample2_output": "2",
        "sample3_input": "25",
        "sample3_output": "6",
        "sample4_input": "100",
        "sample4_output": "24",
        "sample5_input": "5",
        "sample5_output": "1",
        "task_id": 9,
        "text": "Your task is to calculate the number of trailing zeros in the factorial n!.\nFor example, 20!=2432902008176640000 and it has 4 trailing zeros.\nInput\nThe only input line has an integer n.\nOutput\nPrint the number of trailing zeros in n!.\nConstraints\n\n1 \\le n \\le 10^9\n\nExample\nInput:\n20\n\nOutput:\n4\n",
        "code": "def main(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count",
        "test_list": [
            "assert main(20) == 4",
            "assert main(10) == 2",
            "assert main(25) == 6",
            "assert main(100) == 24",
            "assert main(5) == 1"
        ]
    },
    {
        "title": "Coin Piles",
        "sample1_input": "3,[(2,1),(2,2),(3,3)]",
        "sample1_output": "['YES', 'NO', 'YES']",
        "sample2_input": "2,[(5,3),(4,8)]",
        "sample2_output": "['NO', 'YES']",
        "sample3_input": "1,[(6,9)]",
        "sample3_output": "['YES']",
        "sample4_input": "1,[(10,5)]",
        "sample4_output": "['NO']",
        "sample5_input": "1,[(15,15)]",
        "sample5_output": "['NO']",
        "task_id": 10,
        "text": "You have two coin piles containing a and b coins. On each move, you can either remove one coin from the left pile and two coins from the right pile, or two coins from the left pile and one coin from the right pile.\nYour task is to efficiently find out if you can empty both the piles.\nInput\nThe first input line has an integer t: the number of tests.\nAfter this, there are t lines, each of which has two integers a and b: the numbers of coins in the piles.\nOutput\nFor each test, print \"YES\" if you can empty the piles and \"NO\" otherwise.\nConstraints\n\n1 \\le t \\le 10^5\n0 \\le a, b \\le 10^9\n\nExample\nInput:\n3\n2 1\n2 2\n3 3\n\nOutput:\nYES\nNO\nYES\n",
        "code": "def main(t, tests):\n    results = []\n    for i in range(t):\n        a, b = tests[i]\n        if (a + b) % 3 == 0 and min(a, b) * 2 >= max(a, b):\n            results.append('YES')\n        else:\n            results.append('NO')\n    return results",
        "test_list": [
            "assert main(3,[(2,1),(2,2),(3,3)]) == ['YES', 'NO', 'YES']",
            "assert main(2,[(5,3),(4,8)]) == ['NO', 'YES']",
            "assert main(1,[(6,9)]) == ['YES']",
            "assert main(1,[(10,5)]) == ['NO']",
            "assert main(1,[(15,15)]) == ['NO']"
        ]
    },
    {
        "title": "Palindrome Reorder",
        "sample1_input": "AAAACACBA",
        "sample1_output": "AAACBCAAA",
        "sample2_input": "AABB",
        "sample2_output": "ABBA",
        "sample3_input": "ABC",
        "sample3_output": "NO SOLUTION",
        "sample4_input": "AAABBB",
        "sample4_output": "NO SOLUTION",
        "sample5_input": "A",
        "sample5_output": "A",
        "task_id": 11,
        "text": "Given a string, your task is to reorder its letters in such a way that it becomes a palindrome (i.e., it reads the same forwards and backwards).\nInput\nThe only input line has a string of length n consisting of characters A–Z.\nOutput\nPrint a palindrome consisting of the characters of the original string. You may print any valid solution. If there are no solutions, print \"NO SOLUTION\".\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nAAAACACBA\n\nOutput:\nAACABACAA\n",
        "code": "def main(s):\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    odd_count = 0\n    odd_char = ''\n    first_half = ''\n    for char, count in freq.items():\n        if count % 2 == 1:\n            odd_count += 1\n            odd_char = char\n        first_half += char * (count // 2)\n    if odd_count > 1:\n        return 'NO SOLUTION'\n    second_half = first_half[::-1]\n    if odd_count == 1:\n        return first_half + odd_char + second_half\n    else:\n        return first_half + second_half",
        "test_list": [
            "assert main(AAAACACBA) == AAACBCAAA",
            "assert main(AABB) == ABBA",
            "assert main(ABC) == NO SOLUTION",
            "assert main(AAABBB) == NO SOLUTION",
            "assert main(A) == A"
        ]
    },
    {
        "title": "Tower of Hanoi",
        "sample1_input": "2",
        "sample1_output": "(3, [('1', '2'), ('1', '3'), ('2', '3')])",
        "sample2_input": "3",
        "sample2_output": "(7, [('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3')])",
        "sample3_input": "1",
        "sample3_output": "(1, [('1', '3')])",
        "sample4_input": "4",
        "sample4_output": "(15, [('1', '2'), ('1', '3'), ('2', '3'), ('1', '2'), ('3', '1'), ('3', '2'), ('1', '2'), ('1', '3'), ('2', '3'), ('2', '1'), ('3', '1'), ('2', '3'), ('1', '2'), ('1', '3'), ('2', '3')])",
        "sample5_input": "5",
        "sample5_output": "(31, [('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3'), ('1', '2'), ('3', '2'), ('3', '1'), ('2', '1'), ('3', '2'), ('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3'), ('2', '1'), ('3', '2'), ('3', '1'), ('2', '1'), ('2', '3'), ('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3')])",
        "task_id": 12,
        "text": "The Tower of Hanoi game consists of three stacks (left, middle and right) and n round disks of different sizes. Initially, the left stack has all the disks, in increasing order of size from top to bottom. \nThe goal is to move all the disks to the right stack using the middle stack. On each move you can move the uppermost disk from a stack to another stack. In addition, it is not allowed to place a larger disk on a smaller disk.\nYour task is to find a solution that minimizes the number of moves.\nInput\nThe only input line has an integer n: the number of disks.\nOutput\nFirst print an integer k: the minimum number of moves.\nAfter this, print k lines that describe the moves. Each line has two integers a and b: you move a disk from stack a to stack b.\nConstraints\n\n1 \\le n \\le 16\n\nExample\nInput:\n2\n\nOutput:\n3\n1 2\n1 3\n2 3\n",
        "code": "def main(n):\n    moves = []\n\n    def hanoi(n, source, auxiliary, target):\n        if n == 1:\n            moves.append((source, target))\n        else:\n            hanoi(n - 1, source, target, auxiliary)\n            moves.append((source, target))\n            hanoi(n - 1, auxiliary, source, target)\n\n    hanoi(n, '1', '2', '3')\n\n    return len(moves), moves",
        "test_list": [
            "assert main(2) == (3, [('1', '2'), ('1', '3'), ('2', '3')])",
            "assert main(3) == (7, [('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3')])",
            "assert main(1) == (1, [('1', '3')])",
            "assert main(4) == (15, [('1', '2'), ('1', '3'), ('2', '3'), ('1', '2'), ('3', '1'), ('3', '2'), ('1', '2'), ('1', '3'), ('2', '3'), ('2', '1'), ('3', '1'), ('2', '3'), ('1', '2'), ('1', '3'), ('2', '3')])",
            "assert main(5) == (31, [('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3'), ('1', '2'), ('3', '2'), ('3', '1'), ('2', '1'), ('3', '2'), ('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3'), ('2', '1'), ('3', '2'), ('3', '1'), ('2', '1'), ('2', '3'), ('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3')])"
        ]
    },
    {
        "title": "Creating Strings",
        "sample1_input": "aabac",
        "sample1_output": "[20, ['aaabc', 'aaacb', 'aabac', 'aabca', 'aacab', 'aacba', 'abaac', 'abaca', 'abcaa', 'acaab', 'acaba', 'acbaa', 'baaac', 'baaca', 'bacaa', 'bcaaa', 'caaab', 'caaba', 'cabaa', 'cbaaa']]",
        "sample2_input": "abcd",
        "sample2_output": "[24, ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba']]",
        "sample3_input": "xyz",
        "sample3_output": "[6, ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx']]",
        "sample4_input": "aa",
        "sample4_output": "[2, ['aa', 'aa']]",
        "sample5_input": "abcde",
        "sample5_output": "[120, ['abcde', 'abced', 'abdec', 'abecd', 'abecd', 'abced', 'acdeb', 'acbed', 'acebd', 'acebd', 'acbed', 'acdeb', 'adceb', 'adceb', 'adecb', 'adebc', 'adbec', 'adbce', 'aedcb', 'aedbc', 'aebdc', 'aebcd', 'aebcd', 'aebdc', 'aedbc', 'aedcb', 'adbce', 'adbec', 'adebc', 'adecb', 'acdeb', 'acdeb', 'acbed', 'acebd', 'acebd', 'acbed', 'abced', 'abced', 'abecd', 'abdec', 'abcde', 'abcde']]",
        "task_id": 13,
        "text": "Given a string, your task is to generate all different strings that can be created using its characters.\nInput\nThe only input line has a string of length n. Each character is between a–z.\nOutput\nFirst print an integer k: the number of strings. Then print k lines: the strings in alphabetical order.\nConstraints\n\n1 \\le n \\le 8\n\nExample\nInput:\naabac\n\nOutput:\n20\naaabc\naaacb\naabac\naabca\naacab\naacba\nabaac\nabaca\nabcaa\nacaab\nacaba\nacbaa\nbaaac\nbaaca\nbacaa\nbcaaa\ncaaab\ncaaba\ncabaa\ncbaaa\n",
        "code": "from itertools import permutations\n\ndef main(s):\n    all_permutations = set(permutations(s))\n    result = sorted([''.join(p) for p in all_permutations])\n    return len(result), result",
        "test_list": [
            "assert main(aabac) == [20, ['aaabc', 'aaacb', 'aabac', 'aabca', 'aacab', 'aacba', 'abaac', 'abaca', 'abcaa', 'acaab', 'acaba', 'acbaa', 'baaac', 'baaca', 'bacaa', 'bcaaa', 'caaab', 'caaba', 'cabaa', 'cbaaa']]",
            "assert main(abcd) == [24, ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba']]",
            "assert main(xyz) == [6, ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx']]",
            "assert main(aa) == [2, ['aa', 'aa']]",
            "assert main(abcde) == [120, ['abcde', 'abced', 'abdec', 'abecd', 'abecd', 'abced', 'acdeb', 'acbed', 'acebd', 'acebd', 'acbed', 'acdeb', 'adceb', 'adceb', 'adecb', 'adebc', 'adbec', 'adbce', 'aedcb', 'aedbc', 'aebdc', 'aebcd', 'aebcd', 'aebdc', 'aedbc', 'aedcb', 'adbce', 'adbec', 'adebc', 'adecb', 'acdeb', 'acdeb', 'acbed', 'acebd', 'acebd', 'acbed', 'abced', 'abced', 'abecd', 'abdec', 'abcde', 'abcde']]"
        ]
    },
    {
        "title": "Apple Division",
        "sample1_input": "5,[3,2,7,4,1]",
        "sample1_output": "1",
        "sample2_input": "4,[1,1,1,1]",
        "sample2_output": "0",
        "sample3_input": "3,[5,5,10]",
        "sample3_output": "0",
        "sample4_input": "6,[1,2,3,4,5,6]",
        "sample4_output": "1",
        "sample5_input": "10,[1,2,3,4,5,6,7,8,9,10]",
        "sample5_output": "1",
        "task_id": 14,
        "text": "There are n apples with known weights. Your task is to divide the apples into two groups so that the difference between the weights of the groups is minimal.\nInput\nThe first input line has an integer n: the number of apples.\nThe next line has n integers p_1,p_2,\\dots,p_n: the weight of each apple.\nOutput\nPrint one integer: the minimum difference between the weights of the groups.\nConstraints\n\n1 \\le n \\le 20\n1 \\le p_i \\le 10^9\n\nExample\nInput:\n5\n3 2 7 4 1\n\nOutput:\n1\n\nExplanation: Group 1 has weights 2, 3 and 4 (total weight 9), and group 2 has weights 1 and 7 (total weight 8).\n",
        "code": "def main(n, weights):\n    total_weight = sum(weights)\n    half_weight = total_weight // 2\n\n    dp = [[False] * (half_weight + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(half_weight + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= weights[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - weights[i - 1]]\n\n    for w in range(half_weight, -1, -1):\n        if dp[n][w]:\n            return total_weight - 2 * w",
        "test_list": [
            "assert main(5,[3,2,7,4,1]) == 1",
            "assert main(4,[1,1,1,1]) == 0",
            "assert main(3,[5,5,10]) == 0",
            "assert main(6,[1,2,3,4,5,6]) == 1",
            "assert main(10,[1,2,3,4,5,6,7,8,9,10]) == 1"
        ]
    },
    {
        "title": "Digit Queries",
        "sample1_input": "3,[7,19,12]",
        "sample1_output": "[7, 9, 1]",
        "sample2_input": "4,[1,10,100,1000]",
        "sample2_output": "[1, 1, 5, 3]",
        "sample3_input": "2,[5,25]",
        "sample3_output": "[5, 7]",
        "sample4_input": "1,[50]",
        "sample4_output": "[5]",
        "sample5_input": "2,[9,99]",
        "sample5_output": "[9, 4]",
        "task_id": 15,
        "text": "Consider an infinite string that consists of all positive integers in increasing order:\n12345678910111213141516171819202122232425...\n\nYour task is to process q queries of the form: what is the digit at position k in the string?\nInput\nThe first input line has an integer q: the number of queries.\nAfter this, there are q lines that describe the queries. Each line has an integer k: a 1-indexed position in the string.\nOutput\nFor each query, print the corresponding digit.\nConstraints\n\n1 \\le q \\le 1000\n1 \\le k \\le 10^{18}\n\nExample\nInput:\n3\n7\n19\n12\n\nOutput:\n7\n4\n1\n",
        "code": "def main(q, queries):\n    result = []\n    for k in queries:\n        # Initialize variables to keep track of the current position and the current number\n        current_position = 0\n        current_number = 1\n        # Calculate the length of the current number\n        current_length = len(str(current_number))\n        # Keep moving forward in the string until we reach the desired position k\n        while current_position + current_length < k:\n            current_position += current_length\n            current_number += 1\n            current_length = len(str(current_number))\n        # Calculate the digit at the desired position\n        digit = int(str(current_number)[k - current_position - 1])\n        result.append(digit)\n    return result",
        "test_list": [
            "assert main(3,[7,19,12]) == [7, 9, 1]",
            "assert main(4,[1,10,100,1000]) == [1, 1, 5, 3]",
            "assert main(2,[5,25]) == [5, 7]",
            "assert main(1,[50]) == [5]",
            "assert main(2,[9,99]) == [9, 4]"
        ]
    },
    {
        "title": "Distinct Numbers",
        "sample1_input": "5,[2,3,2,2,3]",
        "sample1_output": "2",
        "sample2_input": "10,[1,2,3,4,5,6,7,8,9,10]",
        "sample2_output": "10",
        "sample3_input": "5,[5,5,5,5,5]",
        "sample3_output": "1",
        "sample4_input": "6,[1,1,2,2,3,3]",
        "sample4_output": "3",
        "sample5_input": "3,[10,10,10]",
        "sample5_output": "1",
        "task_id": 16,
        "text": "You are given a list of n integers, and your task is to calculate the number of distinct values in the list.\nInput\nThe first input line has an integer n: the number of values.\nThe second line has n integers x_1,x_2,\\dots,x_n.\nOutput\nPrint one integers: the number of distinct values.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n2 3 2 2 3\n\nOutput:\n2\n",
        "code": "def main(n, values):\n    distinct_values = set()\n    for value in values:\n        distinct_values.add(value)\n    return len(distinct_values)",
        "test_list": [
            "assert main(5,[2,3,2,2,3]) == 2",
            "assert main(10,[1,2,3,4,5,6,7,8,9,10]) == 10",
            "assert main(5,[5,5,5,5,5]) == 1",
            "assert main(6,[1,1,2,2,3,3]) == 3",
            "assert main(3,[10,10,10]) == 1"
        ]
    },
    {
        "title": "Apartments",
        "sample1_input": "4,3,5,[60,45,80,60],[30,60,75]",
        "sample1_output": "2",
        "sample2_input": "5,5,2,[70,80,90,100,110],[85,80,75,70,65]",
        "sample2_output": "5",
        "sample3_input": "3,4,10,[50,70,90],[85,70,100,45]",
        "sample3_output": "2",
        "sample4_input": "2,3,1,[10,20],[30,10,25]",
        "sample4_output": "2",
        "sample5_input": "3,3,0,[100,200,300],[100,200,300]",
        "sample5_output": "3",
        "task_id": 17,
        "text": "There are n applicants and m free apartments. Your task is to distribute the apartments so that as many applicants as possible will get an apartment.\nEach applicant has a desired apartment size, and they will accept any apartment whose size is close enough to the desired size.\nInput\nThe first input line has three integers n, m, and k: the number of applicants, the number of apartments, and the maximum allowed difference.\nThe next line contains n integers a_1, a_2, \\ldots, a_n: the desired apartment size of each applicant. If the desired size of an applicant is x, he or she will accept any apartment whose size is between x-k and x+k.\nThe last line contains m integers b_1, b_2, \\ldots, b_m: the size of each apartment.\nOutput\nPrint one integer: the number of applicants who will get an apartment.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n0 \\le k \\le 10^9\n1 \\le a_i, b_i \\le 10^9\n\nExample\nInput:\n4 3 5\n60 45 80 60\n30 60 75\n\nOutput:\n2\n",
        "code": "def main(n, m, k, applicants, apartments):\n    applicants.sort()\n    apartments.sort()\n    ans = 0\n    i, j = 0, 0\n    while i < n and j < m:\n        if abs(applicants[i] - apartments[j]) <= k:\n            ans += 1\n            i += 1\n            j += 1\n        elif applicants[i] < apartments[j]:\n            i += 1\n        else:\n            j += 1\n    return ans",
        "test_list": [
            "assert main(4,3,5,[60,45,80,60],[30,60,75]) == 2",
            "assert main(5,5,2,[70,80,90,100,110],[85,80,75,70,65]) == 5",
            "assert main(3,4,10,[50,70,90],[85,70,100,45]) == 2",
            "assert main(2,3,1,[10,20],[30,10,25]) == 2",
            "assert main(3,3,0,[100,200,300],[100,200,300]) == 3"
        ]
    },
    {
        "title": "Ferris Wheel",
        "sample1_input": "4,10,[7,2,3,9]",
        "sample1_output": "3",
        "sample2_input": "5,7,[4,4,3,1,2]",
        "sample2_output": "3",
        "sample3_input": "3,5,[5,5,5]",
        "sample3_output": "2",
        "sample4_input": "6,6,[2,2,2,2,2,2]",
        "sample4_output": "3",
        "sample5_input": "4,100,[50,30,20,70]",
        "sample5_output": "2",
        "task_id": 18,
        "text": "There are n children who want to go to a Ferris wheel, and your task is to find a gondola for each child.\nEach gondola may have one or two children in it, and in addition, the total weight in a gondola may not exceed x. You know the weight of every child.\nWhat is the minimum number of gondolas needed for the children?\nInput\nThe first input line contains two integers n and x: the number of children and the maximum allowed weight.\nThe next line contains n integers p_1,p_2,\\ldots,p_n: the weight of each child.\nOutput\nPrint one integer: the minimum number of gondolas.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x \\le 10^9\n1 \\le p_i \\le x\n\nExample\nInput:\n4 10\n7 2 3 9\n\nOutput:\n3\n",
        "code": "def main(n, x, weights):\n    weights.sort()\n    left, right = 0, n - 1\n    gondolas = 0\n    while left <= right:\n        if weights[left] + weights[right] <= x:\n            left += 1\n            right -= 1\n        else:\n            right -= 1\n        gondolas += 1\n    return gondolas",
        "test_list": [
            "assert main(4,10,[7,2,3,9]) == 3",
            "assert main(5,7,[4,4,3,1,2]) == 3",
            "assert main(3,5,[5,5,5]) == 2",
            "assert main(6,6,[2,2,2,2,2,2]) == 3",
            "assert main(4,100,[50,30,20,70]) == 2"
        ]
    },
    {
        "title": "Concert Tickets",
        "sample1_input": "5,3,[5,3,7,8,5],[4,8,3]",
        "sample1_output": "[3, 8, -1]",
        "sample2_input": "6,4,[2,2,2,2,2,3],[3,2,2,1]",
        "sample2_output": "[2, 2, 2, -1]",
        "sample3_input": "4,3,[1,2,3,4],[3,4,5]",
        "sample3_output": "[3, 4, -1]",
        "sample4_input": "5,5,[10,20,30,40,50],[25,35,10,5,15]",
        "sample4_output": "[20, 30, 10, -1, 40]",
        "sample5_input": "3,3,[7,7,7],[6,5,8]",
        "sample5_output": "[-1, -1, -1]",
        "task_id": 19,
        "text": "There are n concert tickets available, each with a certain price. Then, m customers arrive, one after another.\nEach customer announces the maximum price they are willing to pay for a ticket, and after this, they will get a ticket with the nearest possible price such that it does not exceed the maximum price.\nInput\nThe first input line contains integers n and m: the number of tickets and the number of customers.\nThe next line contains n integers h_1,h_2,\\ldots,h_n: the price of each ticket.\nThe last line contains m integers t_1,t_2,\\ldots,t_m: the maximum price for each customer in the order they arrive.\nOutput\nPrint, for each customer, the price that they will pay for their ticket. After this, the ticket cannot be purchased again.\nIf a customer cannot get any ticket, print -1.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n1 \\le h_i, t_i \\le 10^9\n\nExample\nInput:\n5 3\n5 3 7 8 5\n4 8 3\n\nOutput:\n3\n8\n-1\n",
        "code": "def main(n, m, tickets, customers):\n    tickets.sort()\n    results = []\n    for customer in customers:\n        left, right = 0, n - 1\n        ticket_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if tickets[mid] <= customer:\n                ticket_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if ticket_idx == -1:\n            results.append(-1)\n        else:\n            results.append(tickets[ticket_idx])\n            del tickets[ticket_idx]\n            n -= 1\n    return results",
        "test_list": [
            "assert main(5,3,[5,3,7,8,5],[4,8,3]) == [3, 8, -1]",
            "assert main(6,4,[2,2,2,2,2,3],[3,2,2,1]) == [2, 2, 2, -1]",
            "assert main(4,3,[1,2,3,4],[3,4,5]) == [3, 4, -1]",
            "assert main(5,5,[10,20,30,40,50],[25,35,10,5,15]) == [20, 30, 10, -1, 40]",
            "assert main(3,3,[7,7,7],[6,5,8]) == [-1, -1, -1]"
        ]
    },
    {
        "title": "Restaurant Customers",
        "sample1_input": "3,[5,8],[2,4],[3,9]",
        "sample1_output": "2",
        "sample2_input": "5,[1,2],[2,3],[3,4],[4,5],[5,6]",
        "sample2_output": "1",
        "sample3_input": "4,[1,5],[2,6],[3,7],[4,8]",
        "sample3_output": "4",
        "sample4_input": "6,[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]",
        "sample4_output": "1",
        "sample5_input": "3,[1,5],[2,6],[3,7]",
        "sample5_output": "3",
        "task_id": 20,
        "text": "You are given the arrival and leaving times of n customers in a restaurant.\nWhat was the maximum number of customers in the restaurant at any time?\nInput\nThe first input line has an integer n: the number of customers.\nAfter this, there are n lines that describe the customers. Each line has two integers a and b: the arrival and leaving times of a customer.\nYou may assume that all arrival and leaving times are distinct.\nOutput\nPrint one integer: the maximum number of customers.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a &lt; b \\le 10^9\n\nExample\nInput:\n3\n5 8\n2 4\n3 9\n\nOutput:\n2\n",
        "code": "def main(n, customers):\n    events = []\n    for a, b in customers:\n        events.append((a, 1))\n        events.append((b, -1))\n    events.sort()\n    max_customers = 0\n    current_customers = 0\n    for _, event in events:\n        current_customers += event\n        max_customers = max(max_customers, current_customers)\n    return max_customers",
        "test_list": [
            "assert main(3,[5,8],[2,4],[3,9]) == 2",
            "assert main(5,[1,2],[2,3],[3,4],[4,5],[5,6]) == 1",
            "assert main(4,[1,5],[2,6],[3,7],[4,8]) == 4",
            "assert main(6,[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]) == 1",
            "assert main(3,[1,5],[2,6],[3,7]) == 3"
        ]
    },
    {
        "title": "Movie Festival",
        "sample1_input": "3,[3,5],[4,9],[5,8]",
        "sample1_output": "2",
        "sample2_input": "5,[1,2],[2,3],[3,4],[4,5],[5,6]",
        "sample2_output": "5",
        "sample3_input": "4,[1,5],[2,6],[3,7],[4,8]",
        "sample3_output": "1",
        "sample4_input": "6,[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]",
        "sample4_output": "1",
        "sample5_input": "3,[1,5],[2,6],[3,7]",
        "sample5_output": "2",
        "task_id": 21,
        "text": "In a movie festival n movies will be shown. You know the starting and ending time of each movie. What is the maximum number of movies you can watch entirely?\nInput\nThe first input line has an integer n: the number of movies.\nAfter this, there are n lines that describe the movies. Each line has two integers a and b: the starting and ending times of a movie.\nOutput\nPrint one integer: the maximum number of movies.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a &lt; b \\le 10^9\n\nExample\nInput:\n3\n3 5\n4 9\n5 8\n\nOutput:\n2\n",
        "code": "def main(n, movies):\n    movies.sort(key=lambda x: x[1])\n    current_end = -1\n    count = 0\n    for movie in movies:\n        start, end = movie\n        if start >= current_end:\n            current_end = end\n            count += 1\n    return count",
        "test_list": [
            "assert main(3,[3,5],[4,9],[5,8]) == 2",
            "assert main(5,[1,2],[2,3],[3,4],[4,5],[5,6]) == 5",
            "assert main(4,[1,5],[2,6],[3,7],[4,8]) == 1",
            "assert main(6,[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]) == 1",
            "assert main(3,[1,5],[2,6],[3,7]) == 2"
        ]
    },
    {
        "title": "Sum of Two Values",
        "sample1_input": "4,8,[2,7,5,1]",
        "sample1_output": "2 4",
        "sample2_input": "5,12,[4,9,6,3,8]",
        "sample2_output": "1 3",
        "sample3_input": "3,10,[1,2,3]",
        "sample3_output": "1 3",
        "sample4_input": "6,15,[10,7,8,6,9,5]",
        "sample4_output": "1 2",
        "sample5_input": "4,7,[3,2,4,5]",
        "sample5_output": "1 4",
        "task_id": 22,
        "text": "You are given an array of n integers, and your task is to find two values (at distinct positions) whose sum is x.\nInput\nThe first input line has two integers n and x: the array size and the target sum.\nThe second line has n integers a_1,a_2,\\dots,a_n: the array values.\nOutput\nPrint two integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n4 8\n2 7 5 1\n\nOutput:\n2 4\n",
        "code": "def main(n, x, arr):\n    seen = {}\n    for i, num in enumerate(arr):\n        complement = x - num\n        if complement in seen:\n            return [seen[complement] + 1, i + 1]\n        seen[num] = i\n    return 'IMPOSSIBLE'",
        "test_list": [
            "assert main(4,8,[2,7,5,1]) == 2 4",
            "assert main(5,12,[4,9,6,3,8]) == 1 3",
            "assert main(3,10,[1,2,3]) == 1 3",
            "assert main(6,15,[10,7,8,6,9,5]) == 1 2",
            "assert main(4,7,[3,2,4,5]) == 1 4"
        ]
    },
    {
        "title": "Maximum Subarray Sum",
        "sample1_input": "8,[-1,3,-2,5,3,-5,2,2]",
        "sample1_output": "9",
        "sample2_input": "6,[-2,-3,-4,-1,-2,-5]",
        "sample2_output": "-1",
        "sample3_input": "5,[5,-2,5,3,-5]",
        "sample3_output": "11",
        "sample4_input": "4,[1,2,3,4]",
        "sample4_output": "10",
        "sample5_input": "7,[-2,1,-3,4,-1,2,1]",
        "sample5_output": "5",
        "task_id": 23,
        "text": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous, nonempty subarray.\nInput\nThe first input line has an integer n: the size of the array.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nOutput\nPrint one integer: the maximum subarray sum.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le x_i \\le 10^9\n\nExample\nInput:\n8\n-1 3 -2 5 3 -5 2 2\n\nOutput:\n9\n",
        "code": "def main(n, arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
        "test_list": [
            "assert main(8,[-1,3,-2,5,3,-5,2,2]) == 9",
            "assert main(6,[-2,-3,-4,-1,-2,-5]) == -1",
            "assert main(5,[5,-2,5,3,-5]) == 11",
            "assert main(4,[1,2,3,4]) == 10",
            "assert main(7,[-2,1,-3,4,-1,2,1]) == 5"
        ]
    },
    {
        "title": "Stick Lengths",
        "sample1_input": "5,[2,3,1,5,2]",
        "sample1_output": "5",
        "sample2_input": "4,[1,1,1,1]",
        "sample2_output": "0",
        "sample3_input": "6,[1,1,2,2,3,3]",
        "sample3_output": "5",
        "sample4_input": "3,[5,5,5]",
        "sample4_output": "0",
        "sample5_input": "7,[10,20,30,40,50,60,70]",
        "sample5_output": "105",
        "task_id": 24,
        "text": "There are n sticks with some lengths. Your task is to modify the sticks so that each stick has the same length.\nYou can either lengthen and shorten each stick. Both operations cost x where x is the difference between the new and original length.\nWhat is the minimum total cost?\nInput\nThe first input line contains an integer n: the number of sticks.\nThen there are n integers: p_1,p_2,\\ldots,p_n: the lengths of the sticks.\nOutput\nPrint one integer: the minimum total cost.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le p_i \\le 10^9\n\nExample\nInput:\n5\n2 3 1 5 2\n\nOutput:\n5\n",
        "code": "def main(n, sticks):\n    total_cost = 0\n    sticks.sort()\n    median = sticks[n // 2]\n    for stick in sticks:\n        total_cost += abs(stick - median)\n    return total_cost",
        "test_list": [
            "assert main(5,[2,3,1,5,2]) == 5",
            "assert main(4,[1,1,1,1]) == 0",
            "assert main(6,[1,1,2,2,3,3]) == 5",
            "assert main(3,[5,5,5]) == 0",
            "assert main(7,[10,20,30,40,50,60,70]) == 105"
        ]
    },
    {
        "title": "Missing Coin Sum",
        "sample1_input": "5,[2,9,1,2,7]",
        "sample1_output": "6",
        "sample2_input": "3,[1,2,4]",
        "sample2_output": "8",
        "sample3_input": "4,[1,3,6,8]",
        "sample3_output": "19",
        "sample4_input": "5,[5,10,20,40,80]",
        "sample4_output": "1",
        "sample5_input": "6,[1,1,1,1,1,1]",
        "sample5_output": "7",
        "task_id": 25,
        "text": "You have n coins with positive integer values. What is the smallest sum you cannot create using a subset of the coins?\nInput\nThe first input line has an integer n: the number of coins.\nThe second line has n integers x_1,x_2,\\dots,x_n: the value of each coin.\nOutput\nPrint one integer: the smallest coin sum.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n2 9 1 2 7\n\nOutput:\n6\n",
        "code": "def main(n, coins):\n    coins.sort()\n    smallest_sum = 1\n    for coin in coins:\n        if coin <= smallest_sum:\n            smallest_sum += coin\n        else:\n            break\n    return smallest_sum",
        "test_list": [
            "assert main(5,[2,9,1,2,7]) == 6",
            "assert main(3,[1,2,4]) == 8",
            "assert main(4,[1,3,6,8]) == 19",
            "assert main(5,[5,10,20,40,80]) == 1",
            "assert main(6,[1,1,1,1,1,1]) == 7"
        ]
    },
    {
        "title": "Collecting Numbers",
        "sample1_input": "5,[4,2,1,5,3]",
        "sample1_output": "3",
        "sample2_input": "4,[1,2,3,4]",
        "sample2_output": "0",
        "sample3_input": "7,[5,1,6,3,7,2,4]",
        "sample3_output": "4",
        "sample4_input": "5,[5,4,3,2,1]",
        "sample4_output": "4",
        "sample5_input": "6,[1,3,2,5,4,6]",
        "sample5_output": "1",
        "task_id": 26,
        "text": "You are given an array that contains each number between 1 \\dots n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\nOn each round, you go through the array from left to right and collect as many numbers as possible. What will be the total number of rounds?\nInput\nThe first line has an integer n: the array size.\nThe next line has n integers x_1,x_2,\\dots,x_n: the numbers in the array.\nOutput\nPrint one integer: the number of rounds.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n5\n4 2 1 5 3\n\nOutput:\n3\n",
        "code": "def main(n, arr):\n    rounds = 0\n    current_expected = 1\n    for x in arr:\n        if x == current_expected:\n            current_expected += 1\n        else:\n            rounds += 1\n    return rounds",
        "test_list": [
            "assert main(5,[4,2,1,5,3]) == 3",
            "assert main(4,[1,2,3,4]) == 0",
            "assert main(7,[5,1,6,3,7,2,4]) == 4",
            "assert main(5,[5,4,3,2,1]) == 4",
            "assert main(6,[1,3,2,5,4,6]) == 1"
        ]
    },
    {
        "title": "Collecting Numbers II",
        "sample1_input": "5,3,[4,2,1,5,3],[2,3],[1,5],[2,3]",
        "sample1_output": "2\n3\n4",
        "sample2_input": "4,2,[1,2,3,4],[1,3],[2,4]",
        "sample2_output": "0\n0",
        "sample3_input": "6,1,[2,4,6,1,3,5],[1,6]",
        "sample3_output": "2",
        "sample4_input": "8,4,[5,1,6,4,3,8,7,2],[2,7],[4,5],[1,3],[6,8]",
        "sample4_output": "4\n5\n5\n6",
        "sample5_input": "5,5,[4,2,1,5,3],[2,3],[1,5],[2,3],[3,4],[4,5]",
        "sample5_output": "2\n3\n4\n4\n4",
        "task_id": 27,
        "text": "You are given an array that contains each number between 1 \\dots n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\nOn each round, you go through the array from left to right and collect as many numbers as possible.\nGiven m operations that swap two numbers in the array, your task is to report the number of rounds after each operation.\nInput\nThe first line has two integers n and m: the array size and the number of operations.\nThe next line has n integers x_1,x_2,\\dots,x_n: the numbers in the array.\nFinally, there are m lines that describe the operations. Each line has two integers a and b: the numbers at positions a and b are swapped.\nOutput\nPrint m integers: the number of rounds after each swap.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n4 2 1 5 3\n2 3\n1 5\n2 3\n\nOutput:\n2\n3\n4\n",
        "code": "def main(n, m, arr, operations):\n    def count_rounds(arr):\n        rounds = 0\n        current_expected = 1\n        for x in arr:\n            if x == current_expected:\n                current_expected += 1\n            else:\n                rounds += 1\n        return rounds\n\n    result = []\n    rounds = count_rounds(arr)\n    result.append(rounds)\n\n    for a, b in operations:\n        if arr[a - 1] > arr[b - 1]:\n            arr[a - 1], arr[b - 1] = arr[b - 1], arr[a - 1]\n            rounds = count_rounds(arr)\n        result.append(rounds)\n\n    return result",
        "test_list": [
            "assert main(5,3,[4,2,1,5,3],[2,3],[1,5],[2,3]) == 2\n3\n4",
            "assert main(4,2,[1,2,3,4],[1,3],[2,4]) == 0\n0",
            "assert main(6,1,[2,4,6,1,3,5],[1,6]) == 2",
            "assert main(8,4,[5,1,6,4,3,8,7,2],[2,7],[4,5],[1,3],[6,8]) == 4\n5\n5\n6",
            "assert main(5,5,[4,2,1,5,3],[2,3],[1,5],[2,3],[3,4],[4,5]) == 2\n3\n4\n4\n4"
        ]
    },
    {
        "title": "Playlist",
        "sample1_input": "8,[1,2,1,3,2,7,4,2]",
        "sample1_output": "5",
        "sample2_input": "5,[1,2,3,4,5]",
        "sample2_output": "5",
        "sample3_input": "10,[5,4,3,2,1,5,4,3,2,1]",
        "sample3_output": "5",
        "sample4_input": "7,[1,2,3,4,5,6,7]",
        "sample4_output": "7",
        "sample5_input": "7,[1,2,3,4,5,6,1]",
        "sample5_output": "6",
        "task_id": 28,
        "text": "You are given a playlist of a radio station since its establishment. The playlist has a total of n songs.\nWhat is the longest sequence of successive songs where each song is unique?\nInput\nThe first input line contains an integer n: the number of songs.\nThe next line has n integers k_1,k_2,\\ldots,k_n: the id number of each song.\nOutput\nPrint the length of the longest sequence of unique songs.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le k_i \\le 10^9\n\nExample\nInput:\n8\n1 2 1 3 2 7 4 2\n\nOutput:\n5\n",
        "code": "def main(n, songs):\n    last_occurrence = {}\n    longest_sequence = 0\n    current_sequence = 0\n    left_pointer = 0\n\n    for right_pointer in range(n):\n        song = songs[right_pointer]\n        if song in last_occurrence and last_occurrence[song] >= left_pointer:\n            left_pointer = last_occurrence[song] + 1\n\n        last_occurrence[song] = right_pointer\n        current_sequence = right_pointer - left_pointer + 1\n        longest_sequence = max(longest_sequence, current_sequence)\n\n    return longest_sequence",
        "test_list": [
            "assert main(8,[1,2,1,3,2,7,4,2]) == 5",
            "assert main(5,[1,2,3,4,5]) == 5",
            "assert main(10,[5,4,3,2,1,5,4,3,2,1]) == 5",
            "assert main(7,[1,2,3,4,5,6,7]) == 7",
            "assert main(7,[1,2,3,4,5,6,1]) == 6"
        ]
    },
    {
        "title": "Towers",
        "sample1_input": "5,[3,8,2,1,5]",
        "sample1_output": "2",
        "sample2_input": "6,[4,4,4,4,4,4]",
        "sample2_output": "6",
        "sample3_input": "7,[7,6,5,4,3,2,1]",
        "sample3_output": "7",
        "sample4_input": "8,[8,1,7,2,6,3,5,4]",
        "sample4_output": "1",
        "sample5_input": "4,[1,2,3,4]",
        "sample5_output": "4",
        "task_id": 29,
        "text": "You are given n cubes in a certain order, and your task is to build towers using them. Whenever two cubes are one on top of the other, the upper cube must be smaller than the lower cube.\nYou must process the cubes in the given order. You can always either place the cube on top of an existing tower, or begin a new tower. What is the minimum possible number of towers?\nInput\nThe first input line contains an integer n: the number of cubes.\nThe next line contains n integers k_1,k_2,\\ldots,k_n: the sizes of the cubes.\nOutput\nPrint one integer: the minimum number of towers.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le k_i \\le 10^9\n\nExample\nInput:\n5\n3 8 2 1 5\n\nOutput:\n2\n",
        "code": "def main(n, cubes):\n    towers = []\n\n    for cube in cubes:\n        placed = False\n\n        for i in range(len(towers)):\n            if towers[i][-1] >= cube:\n                towers[i].append(cube)\n                placed = True\n                break\n\n        if not placed:\n            towers.append([cube])\n\n    return len(towers)",
        "test_list": [
            "assert main(5,[3,8,2,1,5]) == 2",
            "assert main(6,[4,4,4,4,4,4]) == 6",
            "assert main(7,[7,6,5,4,3,2,1]) == 7",
            "assert main(8,[8,1,7,2,6,3,5,4]) == 1",
            "assert main(4,[1,2,3,4]) == 4"
        ]
    },
    {
        "title": "Traffic Lights",
        "sample1_input": "8,3,[3,6,2]",
        "sample1_output": "5\n3\n3",
        "sample2_input": "10,2,[4,7]",
        "sample2_output": "6\n3",
        "sample3_input": "5,1,[1]",
        "sample3_output": "4",
        "sample4_input": "12,4,[2,5,9,11]",
        "sample4_output": "10\n6\n3\n1",
        "sample5_input": "7,2,[3,6]",
        "sample5_output": "4\n3",
        "task_id": 30,
        "text": "There is a street of length x whose positions are numbered 0,1,\\ldots,x. Initially there are no traffic lights, but n sets of traffic lights are added to the street one after another.\nYour task is to calculate the length of the longest passage without traffic lights after each addition.\nInput\nThe first input line contains two integers x and n: the length of the street and the number of sets of traffic lights.\nThen, the next line contains n integers p_1,p_2,\\ldots,p_n: the position of each set of traffic lights. Each position is distinct.\nOutput\nPrint the length of the longest passage without traffic lights after each addition.\nConstraints\n\n1 \\le x \\le 10^9\n1 \\le n \\le 2 \\cdot 10^5\n0 &lt; p_i &lt; x\n\nExample\nInput:\n8 3\n3 6 2\n\nOutput:\n5 3 3\n",
        "code": "def main(x, n, lights):\n    gaps = [x]\n    lights_set = set(lights)\n    max_gap = x\n\n    for light in lights:\n        left_gap = light\n        right_gap = x - light\n\n        if left_gap in lights_set and right_gap in lights_set:\n            gaps.remove(max_gap)\n            gaps.append(left_gap)\n            gaps.append(right_gap)\n        elif left_gap in lights_set:\n            gaps.remove(max_gap)\n            gaps.append(left_gap)\n        elif right_gap in lights_set:\n            gaps.remove(max_gap)\n            gaps.append(right_gap)\n\n        max_gap = max(gaps)\n        print(max_gap)",
        "test_list": [
            "assert main(8,3,[3,6,2]) == 5\n3\n3",
            "assert main(10,2,[4,7]) == 6\n3",
            "assert main(5,1,[1]) == 4",
            "assert main(12,4,[2,5,9,11]) == 10\n6\n3\n1",
            "assert main(7,2,[3,6]) == 4\n3"
        ]
    },
    {
        "title": "Josephus Problem I",
        "sample1_input": "7",
        "sample1_output": "2 4 6 1 5 3 7",
        "sample2_input": "5",
        "sample2_output": "2 4 1 5 3",
        "sample3_input": "3",
        "sample3_output": "2 1 3",
        "sample4_input": "10",
        "sample4_output": "2 4 6 8 10 3 7 1 9 5",
        "sample5_input": "1",
        "sample5_output": "1",
        "task_id": 31,
        "text": "Consider a game where there are n children (numbered 1,2,\\dots,n) in a circle. During the game, every other child is removed from the circle until there are no children left. In which order will the children be removed?\nInput\nThe only input line has an integer n.\nOutput\nPrint n integers: the removal order.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n7\n\nOutput:\n2 4 6 1 5 3 7\n",
        "code": "def main(n):\n    result = []\n    queue = list(range(1, n + 1))\n    i = 0\n\n    while queue:\n        i = (i + 1) % len(queue)\n        result.append(queue[i])\n        queue.pop(i)\n\n    return result",
        "test_list": [
            "assert main(7) == 2 4 6 1 5 3 7",
            "assert main(5) == 2 4 1 5 3",
            "assert main(3) == 2 1 3",
            "assert main(10) == 2 4 6 8 10 3 7 1 9 5",
            "assert main(1) == 1"
        ]
    },
    {
        "title": "Josephus Problem II",
        "sample1_input": "7,2",
        "sample1_output": "3 6 2 7 5 1 4",
        "sample2_input": "5,1",
        "sample2_output": "1 2 3 4 5",
        "sample3_input": "3,0",
        "sample3_output": "1 2 3",
        "sample4_input": "10,3",
        "sample4_output": "3 6 9 2 7 1 8 5 10 4",
        "sample5_input": "1,0",
        "sample5_output": "1",
        "task_id": 32,
        "text": "Consider a game where there are n children (numbered 1,2,\\dots,n) in a circle. During the game, repeatedly k children are skipped and one child is removed from the circle. In which order will the children be removed?\nInput\nThe only input line has two integers n and k.\nOutput\nPrint n integers: the removal order.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n0 \\le k \\le 10^9\n\nExample\nInput:\n7 2\n\nOutput:\n3 6 2 7 5 1 4\n",
        "code": "def main(n, k):\n    result = []\n    circle = list(range(1, n + 1))\n    i = 0\n\n    while circle:\n        i = (i + k - 1) % len(circle)\n        result.append(circle.pop(i))\n\n    return result",
        "test_list": [
            "assert main(7,2) == 3 6 2 7 5 1 4",
            "assert main(5,1) == 1 2 3 4 5",
            "assert main(3,0) == 1 2 3",
            "assert main(10,3) == 3 6 9 2 7 1 8 5 10 4",
            "assert main(1,0) == 1"
        ]
    },
    {
        "title": "Nested Ranges Check",
        "sample1_input": "4,[1,6],[2,4],[4,8],[3,6]",
        "sample1_output": "1 0 0 0\n0 1 0 1",
        "sample2_input": "3,[1,5],[2,4],[3,6]",
        "sample2_output": "0 0 1\n1 1 0",
        "sample3_input": "2,[1,3],[4,6]",
        "sample3_output": "0 0\n0 0",
        "sample4_input": "5,[1,5],[2,4],[3,6],[7,8],[8,10]",
        "sample4_output": "0 0 0 1 0\n1 1 1 0 0",
        "sample5_input": "1,[1,10]",
        "sample5_output": "0\n0",
        "task_id": 33,
        "text": "Given n ranges, your task is to determine for each range if it contains some other range and if some other range contains it.\nRange [a,b] contains range [c,d] if a \\le c and d \\le b.\nInput\nThe first input line has an integer n: the number of ranges.\nAfter this, there are n lines that describe the ranges. Each line has two integers x and y: the range is [x,y].\nYou may assume that no range appears more than once in the input.\nOutput\nFirst print a line that describes for each range (in the input order) if it contains some other range (1) or not (0).\nThen print a line that describes for each range (in the input order) if some other range contains it (1) or not (0).\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x &lt; y \\le 10^9\n\nExample\nInput:\n4\n1 6\n2 4\n4 8\n3 6\n\nOutput:\n1 0 0 0\n0 1 0 1\n",
        "code": "def main(n, ranges):\n    contains = [0] * n\n    is_contained = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a, b = ranges[i]\n                c, d = ranges[j]\n                if a <= c and d <= b:\n                    contains[i] = 1\n                if a >= c and d >= b:\n                    is_contained[i] = 1\n\n    return contains, is_contained",
        "test_list": [
            "assert main(4,[1,6],[2,4],[4,8],[3,6]) == 1 0 0 0\n0 1 0 1",
            "assert main(3,[1,5],[2,4],[3,6]) == 0 0 1\n1 1 0",
            "assert main(2,[1,3],[4,6]) == 0 0\n0 0",
            "assert main(5,[1,5],[2,4],[3,6],[7,8],[8,10]) == 0 0 0 1 0\n1 1 1 0 0",
            "assert main(1,[1,10]) == 0\n0"
        ]
    },
    {
        "title": "Nested Ranges Count",
        "sample1_input": "4,[1,6],[2,4],[4,8],[3,6]",
        "sample1_output": "2 0 0 0\n0 1 0 1",
        "sample2_input": "3,[1,5],[2,4],[3,6]",
        "sample2_output": "0 0 1\n1 1 0",
        "sample3_input": "2,[1,3],[4,6]",
        "sample3_output": "0 0\n0 0",
        "sample4_input": "5,[1,5],[2,4],[3,6],[7,8],[8,10]",
        "sample4_output": "0 0 0 1 0\n1 1 1 0 0",
        "sample5_input": "1,[1,10]",
        "sample5_output": "0\n0",
        "task_id": 34,
        "text": "Given n ranges, your task is to count for each range how many other ranges it contains and how many other ranges contain it.\nRange [a,b] contains range [c,d] if a \\le c and d \\le b.\nInput\nThe first input line has an integer n: the number of ranges.\nAfter this, there are n lines that describe the ranges. Each line has two integers x and y: the range is [x,y].\nYou may assume that no range appears more than once in the input.\nOutput\nFirst print a line that describes for each range (in the input order) how many other ranges it contains.\nThen print a line that describes for each range (in the input order) how many other ranges contain it.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x &lt; y \\le 10^9\n\nExample\nInput:\n4\n1 6\n2 4\n4 8\n3 6\n\nOutput:\n2 0 0 0\n0 1 0 1\n",
        "code": "def main(n, ranges):\n    contains = [0] * n\n    is_contained = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a, b = ranges[i]\n                c, d = ranges[j]\n                if a <= c and d <= b:\n                    contains[i] += 1\n                if a >= c and d >= b:\n                    is_contained[i] += 1\n\n    return contains, is_contained",
        "test_list": [
            "assert main(4,[1,6],[2,4],[4,8],[3,6]) == 2 0 0 0\n0 1 0 1",
            "assert main(3,[1,5],[2,4],[3,6]) == 0 0 1\n1 1 0",
            "assert main(2,[1,3],[4,6]) == 0 0\n0 0",
            "assert main(5,[1,5],[2,4],[3,6],[7,8],[8,10]) == 0 0 0 1 0\n1 1 1 0 0",
            "assert main(1,[1,10]) == 0\n0"
        ]
    },
    {
        "title": "Room Allocation",
        "sample1_input": "3,[1,2],[2,4],[4,4]",
        "sample1_output": "2\n1 2 1",
        "sample2_input": "4,[1,2],[2,4],[4,4],[5,6]",
        "sample2_output": "2\n1 2 1 2",
        "sample3_input": "5,[1,2],[2,4],[4,4],[5,6],[7,8]",
        "sample3_output": "3\n1 2 1 2 3",
        "sample4_input": "3,[1,5],[2,6],[3,7]",
        "sample4_output": "1\n1 1 1",
        "sample5_input": "6,[1,3],[2,4],[3,5],[4,6],[5,7],[6,8]",
        "sample5_output": "1\n1 1 1 1 1 1",
        "task_id": 35,
        "text": "There is a large hotel, and n customers will arrive soon. Each customer wants to have a single room.\nYou know each customer's arrival and departure day. Two customers can stay in the same room if the departure day of the first customer is earlier than the arrival day of the second customer.\nWhat is the minimum number of rooms that are needed to accommodate all customers? And how can the rooms be allocated?\nInput\nThe first input line contains an integer n: the number of customers.\nThen there are n lines, each of which describes one customer. Each line has two integers a and b: the arrival and departure day.\nOutput\nPrint first an integer k: the minimum number of rooms required.\nAfter that, print a line that contains the room number of each customer in the same order as in the input. The rooms are numbered 1,2,\\ldots,k. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a \\le b \\le 10^9\n\nExample\nInput:\n3\n1 2\n2 4\n4 4\n\nOutput:\n2\n1 2 1\n",
        "code": "def main(n, customers):\n    sorted_customers = sorted(enumerate(customers, start=1), key=lambda x: x[1][0])\n    rooms = [0] * n\n    room_count = 1\n    end_times = [sorted_customers[0][1][1]]\n    rooms[sorted_customers[0][0] - 1] = room_count\n\n    for i in range(1, n):\n        customer = sorted_customers[i][1]\n        start_time = customer[0]\n        end_time = customer[1]\n\n        if start_time > end_times[0]:\n            room_count += 1\n            end_times[0] = end_time\n            rooms[sorted_customers[i][0] - 1] = room_count\n        else:\n            for j in range(len(end_times)):\n                if start_time > end_times[j]:\n                    end_times[j] = end_time\n                    rooms[sorted_customers[i][0] - 1] = j + 1\n                    break\n            else:\n                room_count += 1\n                end_times.append(end_time)\n                rooms[sorted_customers[i][0] - 1] = room_count\n\n    return room_count, rooms",
        "test_list": [
            "assert main(3,[1,2],[2,4],[4,4]) == 2\n1 2 1",
            "assert main(4,[1,2],[2,4],[4,4],[5,6]) == 2\n1 2 1 2",
            "assert main(5,[1,2],[2,4],[4,4],[5,6],[7,8]) == 3\n1 2 1 2 3",
            "assert main(3,[1,5],[2,6],[3,7]) == 1\n1 1 1",
            "assert main(6,[1,3],[2,4],[3,5],[4,6],[5,7],[6,8]) == 1\n1 1 1 1 1 1"
        ]
    },
    {
        "title": "Factory Machines",
        "sample1_input": "3,7,[3,2,5]",
        "sample1_output": "8",
        "sample2_input": "1,10,[7]",
        "sample2_output": "70",
        "sample3_input": "5,100,[1,2,3,4,5]",
        "sample3_output": "40",
        "sample4_input": "2,1000000000,[3,5]",
        "sample4_output": "2000000000",
        "sample5_input": "4,5,[2,2,2,2]",
        "sample5_output": "6",
        "task_id": 36,
        "text": "A factory has n machines which can be used to make products. Your goal is to make a total of t products.\nFor each machine, you know the number of seconds it needs to make a single product. The machines can work simultaneously, and you can freely decide their schedule.\nWhat is the shortest time needed to make t products?\nInput\nThe first input line has two integers n and t: the number of machines and products.\nThe next line has n integers k_1,k_2,\\dots,k_n: the time needed to make a product using each machine.\nOutput\nPrint one integer: the minimum time needed to make t products.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le t \\le 10^9\n1 \\le k_i \\le 10^9\n\nExample\nInput:\n3 7\n3 2 5\n\nOutput:\n8\n\nExplanation: Machine 1 makes two products, machine 2 makes four products and machine 3 makes one product.\n",
        "code": "def main(n, t, machines):\n    left = 1\n    right = 10**18\n\n    while left < right:\n        mid = (left + right) // 2\n        total_products = 0\n\n        for machine in machines:\n            total_products += mid // machine\n\n        if total_products >= t:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left",
        "test_list": [
            "assert main(3,7,[3,2,5]) == 8",
            "assert main(1,10,[7]) == 70",
            "assert main(5,100,[1,2,3,4,5]) == 40",
            "assert main(2,1000000000,[3,5]) == 2000000000",
            "assert main(4,5,[2,2,2,2]) == 6"
        ]
    },
    {
        "title": "Tasks and Deadlines",
        "sample1_input": "3,[6,10],[8,15],[5,12]",
        "sample1_output": "2",
        "sample2_input": "1,[7,5]",
        "sample2_output": "0",
        "sample3_input": "4,[2,10],[3,12],[1,5],[5,15]",
        "sample3_output": "20",
        "sample4_input": "2,[1,1],[1,1]",
        "sample4_output": "1",
        "sample5_input": "5,[5,10],[4,15],[3,12],[2,5],[1,8]",
        "sample5_output": "19",
        "task_id": 37,
        "text": "You have to process n tasks. Each task has a duration and a deadline, and you will process the tasks in some order one after another. Your reward for a task is d-f where d is its deadline and f is your finishing time. (The starting time is 0, and you have to process all tasks even if a task would yield negative reward.)\nWhat is your maximum reward if you act optimally?\nInput\nThe first input line has an integer n: the number of tasks.\nAfter this, there are n lines that describe the tasks. Each line has two integers a and d: the duration and deadline of the task.\nOutput\nPrint one integer: the maximum reward.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a,d \\le 10^6\n\nExample\nInput:\n3\n6 10\n8 15\n5 12\n\nOutput:\n2\n",
        "code": "def main(n, tasks):\n    tasks.sort(key=lambda x: x[1])\n    time = 0\n    reward = 0\n\n    for task in tasks:\n        duration, deadline = task\n        time += duration\n        reward += deadline - time\n\n    return reward",
        "test_list": [
            "assert main(3,[6,10],[8,15],[5,12]) == 2",
            "assert main(1,[7,5]) == 0",
            "assert main(4,[2,10],[3,12],[1,5],[5,15]) == 20",
            "assert main(2,[1,1],[1,1]) == 1",
            "assert main(5,[5,10],[4,15],[3,12],[2,5],[1,8]) == 19"
        ]
    },
    {
        "title": "Reading Books",
        "sample1_input": "3,[2,8,3]",
        "sample1_output": "16",
        "sample2_input": "1,[7]",
        "sample2_output": "7",
        "sample3_input": "4,[2,10,1,5]",
        "sample3_output": "15",
        "sample4_input": "2,[1,1]",
        "sample4_output": "1",
        "sample5_input": "5,[5,10,3,2,8]",
        "sample5_output": "21",
        "task_id": 38,
        "text": "There are n books, and Kotivalo and Justiina are going to read them all. For each book, you know the time it takes to read it.\nThey both read each book from beginning to end, and they cannot read a book at the same time. What is the minimum total time required?\nInput\nThe first input line has an integer n: the number of books.\nThe second line has n integers t_1,t_2,\\dots,t_n: the time required to read each book.\nOutput\nPrint one integer: the minimum total time.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le t_i \\le 10^9\n\nExample\nInput:\n3\n2 8 3\n\nOutput:\n16\n",
        "code": "def main(n, times):\n    times.sort()\n    total_time = 0\n\n    for i in range(n // 2):\n        total_time += times[n - i - 1]\n\n    return total_time",
        "test_list": [
            "assert main(3,[2,8,3]) == 16",
            "assert main(1,[7]) == 7",
            "assert main(4,[2,10,1,5]) == 15",
            "assert main(2,[1,1]) == 1",
            "assert main(5,[5,10,3,2,8]) == 21"
        ]
    },
    {
        "title": "Sum of Three Values",
        "sample1_input": "4,8,[2,7,5,1]",
        "sample1_output": "1 3 4",
        "sample2_input": "3,10,[1,5,6]",
        "sample2_output": "IMPOSSIBLE",
        "sample3_input": "5,15,[10,5,3,2,7]",
        "sample3_output": "1 4 5",
        "sample4_input": "4,6,[3,1,2,5]",
        "sample4_output": "1 2 4",
        "sample5_input": "6,13,[10,3,8,5,1,9]",
        "sample5_output": "1 3 6",
        "task_id": 39,
        "text": "You are given an array of n integers, and your task is to find three values (at distinct positions) whose sum is x.\nInput\nThe first input line has two integers n and x: the array size and the target sum.\nThe second line has n integers a_1,a_2,\\dots,a_n: the array values.\nOutput\nPrint three integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE.\nConstraints\n\n1 \\le n \\le 5000\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n4 8\n2 7 5 1\n\nOutput:\n1 3 4\n",
        "code": "def main(n, x, arr):\n    positions = {}\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            target = x - arr[i] - arr[j]\n\n            if target in positions:\n                return [positions[target], i + 1, j + 1]\n\n            positions[arr[i]] = i + 1\n\n    return 'IMPOSSIBLE'",
        "test_list": [
            "assert main(4,8,[2,7,5,1]) == 1 3 4",
            "assert main(3,10,[1,5,6]) == IMPOSSIBLE",
            "assert main(5,15,[10,5,3,2,7]) == 1 4 5",
            "assert main(4,6,[3,1,2,5]) == 1 2 4",
            "assert main(6,13,[10,3,8,5,1,9]) == 1 3 6"
        ]
    },
    {
        "title": "Sum of Four Values",
        "sample1_input": "8,15,[3,2,5,8,1,3,2,3]",
        "sample1_output": "2 4 6 7",
        "sample2_input": "6,10,[1,2,3,4,5,6]",
        "sample2_output": "IMPOSSIBLE",
        "sample3_input": "7,19,[8,5,4,7,2,1,3]",
        "sample3_output": "2 3 4 7",
        "sample4_input": "5,12,[3,4,5,6,7]",
        "sample4_output": "1 2 4 5",
        "sample5_input": "4,7,[2,1,2,2]",
        "sample5_output": "IMPOSSIBLE",
        "task_id": 40,
        "text": "You are given an array of n integers, and your task is to find four values (at distinct positions) whose sum is x.\nInput\nThe first input line has two integers n and x: the array size and the target sum.\nThe second line has n integers a_1,a_2,\\dots,a_n: the array values.\nOutput\nPrint four integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n8 15\n3 2 5 8 1 3 2 3\n\nOutput:\n2 4 6 7\n",
        "code": "def main(n, x, arr):\n    positions = {}\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                target = x - arr[i] - arr[j] - arr[k]\n\n                if target in positions:\n                    return [positions[target], i + 1, j + 1, k + 1]\n\n                positions[arr[i]] = i + 1\n\n    return 'IMPOSSIBLE'",
        "test_list": [
            "assert main(8,15,[3,2,5,8,1,3,2,3]) == 2 4 6 7",
            "assert main(6,10,[1,2,3,4,5,6]) == IMPOSSIBLE",
            "assert main(7,19,[8,5,4,7,2,1,3]) == 2 3 4 7",
            "assert main(5,12,[3,4,5,6,7]) == 1 2 4 5",
            "assert main(4,7,[2,1,2,2]) == IMPOSSIBLE"
        ]
    },
    {
        "title": "Nearest Smaller Values",
        "sample1_input": "8,[2,5,1,4,8,3,2,5]",
        "sample1_output": "0 1 0 3 4 3 3 7",
        "sample2_input": "6,[3,1,4,1,5,9]",
        "sample2_output": "0 0 2 2 4 5",
        "sample3_input": "5,[5,4,3,2,1]",
        "sample3_output": "0 1 2 3 4",
        "sample4_input": "7,[1,2,3,4,5,6,7]",
        "sample4_output": "0 1 2 3 4 5 6",
        "sample5_input": "4,[4,4,4,4]",
        "sample5_output": "0 0 0 0",
        "task_id": 41,
        "text": "Given an array of n integers, your task is to find for each array position the nearest position to its left having a smaller value.\nInput\nThe first input line has an integer n: the size of the array.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nOutput\nPrint n integers: for each array position the nearest position with a smaller value. If there is no such position, print 0.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8\n2 5 1 4 8 3 2 5\n\nOutput:\n0 1 0 3 4 3 3 7\n",
        "code": "def main(n, arr):\n    stack = []\n    result = [0] * n\n\n    for i in range(n):\n        while stack and arr[i] < arr[stack[-1]]:\n            j = stack.pop()\n            result[j] = i + 1\n        stack.append(i)\n\n    return result",
        "test_list": [
            "assert main(8,[2,5,1,4,8,3,2,5]) == 0 1 0 3 4 3 3 7",
            "assert main(6,[3,1,4,1,5,9]) == 0 0 2 2 4 5",
            "assert main(5,[5,4,3,2,1]) == 0 1 2 3 4",
            "assert main(7,[1,2,3,4,5,6,7]) == 0 1 2 3 4 5 6",
            "assert main(4,[4,4,4,4]) == 0 0 0 0"
        ]
    },
    {
        "title": "Subarray Sums I",
        "sample1_input": "5,7,[2,4,1,2,7]",
        "sample1_output": "3",
        "sample2_input": "6,10,[1,2,3,4,5,6]",
        "sample2_output": "1",
        "sample3_input": "5,5,[5,5,5,5,5]",
        "sample3_output": "5",
        "sample4_input": "5,15,[10,2,3,1,5]",
        "sample4_output": "2",
        "sample5_input": "3,4,[1,2,3]",
        "sample5_output": "1",
        "task_id": 42,
        "text": "Given an array of n positive integers, your task is to count the number of subarrays having sum x.\nInput\nThe first input line has two integers n and x: the size of the array and the target sum x.\nThe next line has n integers a_1,a_2,\\dots,a_n: the contents of the array.\nOutput\nPrint one integer: the required number of subarrays.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n5 7\n2 4 1 2 7\n\nOutput:\n3\n",
        "code": "def main(n, x, arr):\n    prefix_sum = {0: 1}\n    current_sum = 0\n    count = 0\n\n    for num in arr:\n        current_sum += num\n        if current_sum - x in prefix_sum:\n            count += prefix_sum[current_sum - x]\n        if current_sum in prefix_sum:\n            prefix_sum[current_sum] += 1\n        else:\n            prefix_sum[current_sum] = 1\n\n    return count",
        "test_list": [
            "assert main(5,7,[2,4,1,2,7]) == 3",
            "assert main(6,10,[1,2,3,4,5,6]) == 1",
            "assert main(5,5,[5,5,5,5,5]) == 5",
            "assert main(5,15,[10,2,3,1,5]) == 2",
            "assert main(3,4,[1,2,3]) == 1"
        ]
    },
    {
        "title": "Subarray Sums II",
        "sample1_input": "5,7,[2,-1,3,5,-2]",
        "sample1_output": "2",
        "sample2_input": "6,10,[1,2,3,4,5,6]",
        "sample2_output": "0",
        "sample3_input": "5,5,[5,5,5,5,5]",
        "sample3_output": "0",
        "sample4_input": "5,15,[10,2,3,1,5]",
        "sample4_output": "1",
        "sample5_input": "3,4,[1,2,3]",
        "sample5_output": "1",
        "task_id": 43,
        "text": "Given an array of n integers, your task is to count the number of subarrays having sum x.\nInput\nThe first input line has two integers n and x: the size of the array and the target sum x.\nThe next line has n integers a_1,a_2,\\dots,a_n: the contents of the array.\nOutput\nPrint one integer: the required number of subarrays.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le x,a_i \\le 10^9\n\nExample\nInput:\n5 7\n2 -1 3 5 -2\n\nOutput:\n2\n",
        "code": "def main(n, x, arr):\n    prefix_sum = {0: 1}\n    current_sum = 0\n    count = 0\n\n    for num in arr:\n        current_sum += num\n        if current_sum - x in prefix_sum:\n            count += prefix_sum[current_sum - x]\n        if current_sum in prefix_sum:\n            prefix_sum[current_sum] += 1\n        else:\n            prefix_sum[current_sum] = 1\n\n    return count",
        "test_list": [
            "assert main(5,7,[2,-1,3,5,-2]) == 2",
            "assert main(6,10,[1,2,3,4,5,6]) == 0",
            "assert main(5,5,[5,5,5,5,5]) == 0",
            "assert main(5,15,[10,2,3,1,5]) == 1",
            "assert main(3,4,[1,2,3]) == 1"
        ]
    },
    {
        "title": "Subarray Divisibility",
        "sample1_input": "5,[3,1,2,7,4]",
        "sample1_output": "1",
        "sample2_input": "6,[2,2,2,2,2,2]",
        "sample2_output": "15",
        "sample3_input": "4,[1,2,3,4]",
        "sample3_output": "4",
        "sample4_input": "3,[1,2,3]",
        "sample4_output": "2",
        "sample5_input": "5,[5,5,5,5,5]",
        "sample5_output": "10",
        "task_id": 44,
        "text": "Given an array of n integers, your task is to count the number of subarrays where the sum of values is divisible by n.\nInput\nThe first input line has an integer n: the size of the array.\nThe next line has n integers a_1,a_2,\\dots,a_n: the contents of the array.\nOutput\nPrint one integer: the required number of subarrays.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le a_i \\le 10^9\n\nExample\nInput:\n5\n3 1 2 7 4\n\nOutput:\n1\n",
        "code": "def main(n, arr):\n    prefix_remainder = {0: 1}\n    current_sum = 0\n    count = 0\n\n    for num in arr:\n        current_sum += num\n        remainder = current_sum % n\n        if remainder in prefix_remainder:\n            count += prefix_remainder[remainder]\n        if remainder in prefix_remainder:\n            prefix_remainder[remainder] += 1\n        else:\n            prefix_remainder[remainder] = 1\n\n    return count",
        "test_list": [
            "assert main(5,[3,1,2,7,4]) == 1",
            "assert main(6,[2,2,2,2,2,2]) == 15",
            "assert main(4,[1,2,3,4]) == 4",
            "assert main(3,[1,2,3]) == 2",
            "assert main(5,[5,5,5,5,5]) == 10"
        ]
    },
    {
        "title": "Subarray Distinct Values",
        "sample1_input": "5,2,[1,2,3,1,1]",
        "sample1_output": "10",
        "sample2_input": "6,3,[1,2,1,2,1,2]",
        "sample2_output": "17",
        "sample3_input": "4,1,[5,5,5,5]",
        "sample3_output": "4",
        "sample4_input": "7,4,[1,2,3,4,5,6,7]",
        "sample4_output": "21",
        "sample5_input": "5,2,[1,2,3,4,5]",
        "sample5_output": "11",
        "task_id": 45,
        "text": "Given an array of n integers, your task is to calculate the number of subarrays that have at most k distinct values.\nInput\nThe first input line has two integers n and k.\nThe next line has n integers x_1,x_2,\\dots,x_n: the contents of the array.\nOutput\nPrint one integer: the number of subarrays.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5 2\n1 2 3 1 1\n\nOutput:\n10\n",
        "code": "def main(n, k, arr):\n    left = 0\n    count = 0\n    distinct_values = {}\n\n    for right in range(n):\n        if arr[right] not in distinct_values:\n            distinct_values[arr[right]] = 0\n        distinct_values[arr[right]] += 1\n\n        while len(distinct_values) > k:\n            distinct_values[arr[left]] -= 1\n            if distinct_values[arr[left]] == 0:\n                del distinct_values[arr[left]]\n            left += 1\n\n        count += right - left + 1\n\n    return count",
        "test_list": [
            "assert main(5,2,[1,2,3,1,1]) == 10",
            "assert main(6,3,[1,2,1,2,1,2]) == 17",
            "assert main(4,1,[5,5,5,5]) == 4",
            "assert main(7,4,[1,2,3,4,5,6,7]) == 21",
            "assert main(5,2,[1,2,3,4,5]) == 11"
        ]
    },
    {
        "title": "Array Division",
        "sample1_input": "5,3,[2,4,7,3,5]",
        "sample1_output": "8",
        "sample2_input": "6,2,[1,2,3,4,5,6]",
        "sample2_output": "11",
        "sample3_input": "4,1,[5,5,5,5]",
        "sample3_output": "5",
        "sample4_input": "7,4,[1,2,3,4,5,6,7]",
        "sample4_output": "7",
        "sample5_input": "8,8,[1,2,3,4,5,6,7,8]",
        "sample5_output": "8",
        "task_id": 46,
        "text": "You are given an array containing n positive integers.\nYour task is to divide the array into k subarrays so that the maximum sum in a subarray is as small as possible.\nInput\nThe first input line contains two integers n and k: the size of the array and the number of subarrays in the division.\nThe next line contains n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint one integer: the maximum sum in a subarray in the optimal division.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le k \\le n\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5 3\n2 4 7 3 5\n\nOutput:\n8\n\nExplanation: An optimal division is [2,4],[7],[3,5] where the sums of the subarrays are 6,7,8. The largest sum is the last sum 8.\n",
        "code": "import math\n\ndef main(n, k, arr):\n    left = max(arr)\n    right = sum(arr)\n\n    while left < right:\n        mid = (left + right) // 2\n        subarrays = 1\n        current_sum = 0\n\n        for num in arr:\n            if current_sum + num > mid:\n                subarrays += 1\n                current_sum = 0\n            current_sum += num\n\n        if subarrays <= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left",
        "test_list": [
            "assert main(5,3,[2,4,7,3,5]) == 8",
            "assert main(6,2,[1,2,3,4,5,6]) == 11",
            "assert main(4,1,[5,5,5,5]) == 5",
            "assert main(7,4,[1,2,3,4,5,6,7]) == 7",
            "assert main(8,8,[1,2,3,4,5,6,7,8]) == 8"
        ]
    },
    {
        "title": "Sliding Median",
        "sample1_input": "8,3,[2,4,3,5,8,1,2,1]",
        "sample1_output": "3 4 5 5 2 1",
        "sample2_input": "6,2,[1,2,3,4,5,6]",
        "sample2_output": "1 2 3 4 5",
        "sample3_input": "5,5,[1,2,3,4,5]",
        "sample3_output": "3",
        "sample4_input": "7,4,[7,6,5,4,3,2,1]",
        "sample4_output": "6 5 4 3 2",
        "sample5_input": "10,5,[10,9,8,7,6,5,4,3,2,1]",
        "sample5_output": "6 5 4 3 2 1",
        "task_id": 47,
        "text": "You are given an array of n integers. Your task is to calculate the median of each window of k elements, from left to right.\nThe median is the middle element when the elements are sorted. If the number of elements is even, there are two possible medians and we assume that the median is the smaller of them.\nInput\nThe first input line contains two integers n and k: the number of elements and the size of the window.\nThen there are n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint n-k+1 values: the medians.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8 3\n2 4 3 5 8 1 2 1\n\nOutput:\n3 4 5 5 2 1\n",
        "code": "from collections import deque\n\ndef main(n, k, arr):\n    result = []\n    window = deque()\n\n    for i in range(n):\n        if i >= k:\n            window.popleft()\n        while window and window[-1] > arr[i]:\n            window.pop()\n        window.append(arr[i])\n\n        if i >= k - 1:\n            result.append(window[k // 2] if k % 2 == 1 else min(window[k // 2], window[k // 2 - 1]))\n\n    return result",
        "test_list": [
            "assert main(8,3,[2,4,3,5,8,1,2,1]) == 3 4 5 5 2 1",
            "assert main(6,2,[1,2,3,4,5,6]) == 1 2 3 4 5",
            "assert main(5,5,[1,2,3,4,5]) == 3",
            "assert main(7,4,[7,6,5,4,3,2,1]) == 6 5 4 3 2",
            "assert main(10,5,[10,9,8,7,6,5,4,3,2,1]) == 6 5 4 3 2 1"
        ]
    },
    {
        "title": "Sliding Cost",
        "sample1_input": "8,3,[2,4,3,5,8,1,2,1]",
        "sample1_output": "2 2 5 7 7 1",
        "sample2_input": "6,2,[1,2,3,4,5,6]",
        "sample2_output": "1 1 1 1 1",
        "sample3_input": "5,5,[1,2,3,4,5]",
        "sample3_output": "2",
        "sample4_input": "7,4,[7,6,5,4,3,2,1]",
        "sample4_output": "3 2 1 1",
        "sample5_input": "10,5,[10,9,8,7,6,5,4,3,2,1]",
        "sample5_output": "5 4 3 2 1",
        "task_id": 48,
        "text": "You are given an array of n integers. Your task is to calculate for each window of k elements, from left to right, the minimum total cost of making all elements equal.\nYou can increase or decrease each element with cost x where x is the difference between the new and the original value. The total cost is the sum of such costs.\nInput\nThe first input line contains two integers n and k: the number of elements and the size of the window.\nThen there are n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nOutput n-k+1 values: the costs.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8 3\n2 4 3 5 8 1 2 1\n\nOutput:\n2 2 5 7 7 1\n",
        "code": "def main(n, k, arr):\n    costs = []\n    prefix_sum = [0]\n\n    for x in arr:\n        prefix_sum.append(prefix_sum[-1] + x)\n\n    for i in range(n - k + 1):\n        window_sum = prefix_sum[i + k] - prefix_sum[i]\n        window_avg = window_sum / k\n        cost = 0\n\n        for j in range(i, i + k):\n            cost += abs(arr[j] - window_avg)\n\n        costs.append(cost)\n\n    return costs",
        "test_list": [
            "assert main(8,3,[2,4,3,5,8,1,2,1]) == 2 2 5 7 7 1",
            "assert main(6,2,[1,2,3,4,5,6]) == 1 1 1 1 1",
            "assert main(5,5,[1,2,3,4,5]) == 2",
            "assert main(7,4,[7,6,5,4,3,2,1]) == 3 2 1 1",
            "assert main(10,5,[10,9,8,7,6,5,4,3,2,1]) == 5 4 3 2 1"
        ]
    },
    {
        "title": "Movie Festival II",
        "sample1_input": "5,2,[1,5],[8,10],[3,6],[2,5],[6,9]",
        "sample1_output": "4",
        "sample2_input": "4,3,[1,4],[2,3],[4,5],[6,7]",
        "sample2_output": "3",
        "sample3_input": "6,1,[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]",
        "sample3_output": "1",
        "sample4_input": "7,7,[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14]",
        "sample4_output": "7",
        "sample5_input": "5,5,[1,2],[2,3],[3,4],[4,5],[5,6]",
        "sample5_output": "5",
        "task_id": 49,
        "text": "In a movie festival, n movies will be shown. Syrjälä's movie club consists of k members, who will be all attending the festival.\nYou know the starting and ending time of each movie. What is the maximum total number of movies the club members can watch entirely if they act optimally?\nInput\nThe first input line has two integers n and k: the number of movies and club members.\nAfter this, there are n lines that describe the movies. Each line has two integers a and b: the starting and ending time of a movie.\nOutput\nPrint one integer: the maximum total number of movies.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le a &lt; b \\le 10^9\n\nExample\nInput:\n5 2\n1 5\n8 10\n3 6\n2 5\n6 9\n\nOutput:\n4\n",
        "code": "def main(n, k, movies):\n    movies.sort(key=lambda x: x[1])\n    selected_movies = 0\n    end_time = 0\n\n    for start, end in movies:\n        if start >= end_time:\n            selected_movies += 1\n            end_time = end\n\n        if selected_movies == k:\n            break\n\n    return selected_movies",
        "test_list": [
            "assert main(5,2,[1,5],[8,10],[3,6],[2,5],[6,9]) == 4",
            "assert main(4,3,[1,4],[2,3],[4,5],[6,7]) == 3",
            "assert main(6,1,[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]) == 1",
            "assert main(7,7,[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14]) == 7",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[5,6]) == 5"
        ]
    },
    {
        "title": "Maximum Subarray Sum II",
        "sample1_input": "8,1,2,[-1,3,-2,5,3,-5,2,2]",
        "sample1_output": "8",
        "sample2_input": "5,2,4,[2,-1,3,4,1]",
        "sample2_output": "9",
        "sample3_input": "6,1,3,[1,2,3,-2,5,-1]",
        "sample3_output": "11",
        "sample4_input": "5,3,5,[-2,3,-4,5,-1]",
        "sample4_output": "3",
        "sample5_input": "7,2,3,[1,2,3,4,5,6,7]",
        "sample5_output": "21",
        "task_id": 50,
        "text": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous subarray with length between a and b.\nInput\nThe first input line has three integers n, a and b: the size of the array and the minimum and maximum subarray length.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nOutput\nPrint one integer: the maximum subarray sum.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a \\le b \\le n\n-10^9 \\le x_i \\le 10^9\n\nExample\nInput:\n8 1 2\n-1 3 -2 5 3 -5 2 2\n\nOutput:\n8\n",
        "code": "def main(n, a, b, arr):\n    prefix_sum = [0] * (n + 1)\n    max_sum = float('-inf')\n    min_prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    for i in range(1, n + 1):\n        min_prefix_sum[i] = min(min_prefix_sum[i - 1], prefix_sum[i])\n\n    for len_subarray in range(a, b + 1):\n        for i in range(len_subarray, n + 1):\n            max_sum = max(max_sum, prefix_sum[i] - min_prefix_sum[i - len_subarray])\n\n    return max_sum",
        "test_list": [
            "assert main(8,1,2,[-1,3,-2,5,3,-5,2,2]) == 8",
            "assert main(5,2,4,[2,-1,3,4,1]) == 9",
            "assert main(6,1,3,[1,2,3,-2,5,-1]) == 11",
            "assert main(5,3,5,[-2,3,-4,5,-1]) == 3",
            "assert main(7,2,3,[1,2,3,4,5,6,7]) == 21"
        ]
    },
    {
        "title": "Dice Combinations",
        "sample1_input": "3",
        "sample1_output": "4",
        "sample2_input": "4",
        "sample2_output": "8",
        "sample3_input": "5",
        "sample3_output": "16",
        "sample4_input": "6",
        "sample4_output": "32",
        "sample5_input": "10",
        "sample5_output": "4928",
        "task_id": 51,
        "text": "Your task is to count the number of ways to construct sum n by throwing a dice one or more times. Each throw produces an outcome between 1 and  6.\nFor example, if n=3, there are 4 ways:\n\n1+1+1\n1+2\n2+1\n3\n\nInput\nThe only input line has an integer n.\nOutput\nPrint the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n\nOutput:\n4\n",
        "code": "def main(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, 7):\n            if i - j >= 0:\n                dp[i] += dp[i - j]\n                dp[i] %= MOD\n\n    return dp[n]",
        "test_list": [
            "assert main(3) == 4",
            "assert main(4) == 8",
            "assert main(5) == 16",
            "assert main(6) == 32",
            "assert main(10) == 4928"
        ]
    },
    {
        "title": "Minimizing Coins",
        "sample1_input": "3,11,[1,5,7]",
        "sample1_output": "3",
        "sample2_input": "5,9,[2,3,5,6,8]",
        "sample2_output": "2",
        "sample3_input": "4,13,[2,4,6,8]",
        "sample3_output": "-1",
        "sample4_input": "5,7,[1,2,3,4,5]",
        "sample4_output": "2",
        "sample5_input": "4,10,[1,3,5,7]",
        "sample5_output": "2",
        "task_id": 52,
        "text": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to produce a sum of money x using the available coins in such a way that the number of coins is minimal.\nFor example, if the coins are \\{1,5,7\\} and the desired sum is 11, an optimal solution is 5+5+1 which requires 3 coins.\nInput\nThe first input line has two integers n and x: the number of coins and the desired sum of money.\nThe second line has n distinct integers c_1,c_2,\\dots,c_n: the value of each coin.\nOutput\nPrint one integer: the minimum number of coins. If it is not possible to produce the desired sum, print -1.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x \\le 10^6\n1 \\le c_i \\le 10^6\n\nExample\nInput:\n3 11\n1 5 7\n\nOutput:\n3\n",
        "code": "def main(n, x, coins):\n    INF = float('inf')\n    dp = [INF] * (x + 1)\n    dp[0] = 0\n\n    for i in range(1, x + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    if dp[x] == INF:\n        return -1\n    else:\n        return dp[x]",
        "test_list": [
            "assert main(3,11,[1,5,7]) == 3",
            "assert main(5,9,[2,3,5,6,8]) == 2",
            "assert main(4,13,[2,4,6,8]) == -1",
            "assert main(5,7,[1,2,3,4,5]) == 2",
            "assert main(4,10,[1,3,5,7]) == 2"
        ]
    },
    {
        "title": "Coin Combinations I",
        "sample1_input": "3,9,[2,3,5]",
        "sample1_output": "8",
        "sample2_input": "5,9,[2,3,5,6,8]",
        "sample2_output": "9",
        "sample3_input": "4,13,[2,4,6,8]",
        "sample3_output": "0",
        "sample4_input": "5,7,[1,2,3,4,5]",
        "sample4_output": "21",
        "sample5_input": "4,10,[1,3,5,7]",
        "sample5_output": "15",
        "task_id": 53,
        "text": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum x using the available coins.\nFor example, if the coins are \\{2,3,5\\} and the desired sum is 9, there are 8 ways:\n\n2+2+5\n2+5+2\n5+2+2\n3+3+3\n2+2+2+3\n2+2+3+2\n2+3+2+2\n3+2+2+2\n\nInput\nThe first input line has two integers n and x: the number of coins and the desired sum of money.\nThe second line has n distinct integers c_1,c_2,\\dots,c_n: the value of each coin.\nOutput\nPrint one integer: the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x \\le 10^6\n1 \\le c_i \\le 10^6\n\nExample\nInput:\n3 9\n2 3 5\n\nOutput:\n8\n",
        "code": "def main(n, x, coins):\n    MOD = 10**9 + 7\n    dp = [0] * (x + 1)\n    dp[0] = 1\n\n    for i in range(1, x + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    return dp[x]",
        "test_list": [
            "assert main(3,9,[2,3,5]) == 8",
            "assert main(5,9,[2,3,5,6,8]) == 9",
            "assert main(4,13,[2,4,6,8]) == 0",
            "assert main(5,7,[1,2,3,4,5]) == 21",
            "assert main(4,10,[1,3,5,7]) == 15"
        ]
    },
    {
        "title": "Coin Combinations II",
        "sample1_input": "3,9,[2,3,5]",
        "sample1_output": "3",
        "sample2_input": "5,9,[2,3,5,6,8]",
        "sample2_output": "6",
        "sample3_input": "4,13,[2,4,6,8]",
        "sample3_output": "0",
        "sample4_input": "5,7,[1,2,3,4,5]",
        "sample4_output": "15",
        "sample5_input": "4,10,[1,3,5,7]",
        "sample5_output": "8",
        "task_id": 54,
        "text": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ordered ways you can produce a money sum x using the available coins.\nFor example, if the coins are \\{2,3,5\\} and the desired sum is 9, there are 3 ways:\n\n2+2+5\n3+3+3\n2+2+2+3\n\nInput\nThe first input line has two integers n and x: the number of coins and the desired sum of money.\nThe second line has n distinct integers c_1,c_2,\\dots,c_n: the value of each coin.\nOutput\nPrint one integer: the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x \\le 10^6\n1 \\le c_i \\le 10^6\n\nExample\nInput:\n3 9\n2 3 5\n\nOutput:\n3\n",
        "code": "def main(n, x, coins):\n    MOD = 10**9 + 7\n    dp = [0] * (x + 1)\n    dp[0] = 1\n\n    for i in range(1, x + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    return dp[x]",
        "test_list": [
            "assert main(3,9,[2,3,5]) == 3",
            "assert main(5,9,[2,3,5,6,8]) == 6",
            "assert main(4,13,[2,4,6,8]) == 0",
            "assert main(5,7,[1,2,3,4,5]) == 15",
            "assert main(4,10,[1,3,5,7]) == 8"
        ]
    },
    {
        "title": "Removing Digits",
        "sample1_input": "27",
        "sample1_output": "5",
        "sample2_input": "123",
        "sample2_output": "6",
        "sample3_input": "9",
        "sample3_output": "1",
        "sample4_input": "54321",
        "sample4_output": "5",
        "sample5_input": "1000000",
        "sample5_output": "2",
        "task_id": 55,
        "text": "You are given an integer n. On each step, you may subtract one of the digits from the number.\nHow many steps are required to make the number equal to 0?\nInput\nThe only input line has an integer n.\nOutput\nPrint one integer: the minimum number of steps.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n27\n\nOutput:\n5\n\nExplanation: An optimal solution is 27 \\rightarrow 20 \\rightarrow 18 \\rightarrow 10 \\rightarrow 9 \\rightarrow 0.\n",
        "code": "def main(n):\n    steps = 0\n    while n > 0:\n        max_digit = max(str(n))\n        n -= int(max_digit)\n        steps += 1\n    return steps",
        "test_list": [
            "assert main(27) == 5",
            "assert main(123) == 6",
            "assert main(9) == 1",
            "assert main(54321) == 5",
            "assert main(1000000) == 2"
        ]
    },
    {
        "title": "Book Shop",
        "sample1_input": "4,10,[4,8,5,3],[5,12,8,1]",
        "sample1_output": "13",
        "sample2_input": "3,7,[2,4,3],[3,5,2]",
        "sample2_output": "5",
        "sample3_input": "2,5,[1,2],[2,3]",
        "sample3_output": "3",
        "sample4_input": "5,15,[3,7,2,6,5],[8,12,2,9,5]",
        "sample4_output": "29",
        "sample5_input": "1,1000,[1000],[1000]",
        "sample5_output": "1000",
        "task_id": 56,
        "text": "You are in a book shop which sells n different books. You know the price and number of pages of each book.\nYou have decided that the total price of your purchases will be at most x. What is the maximum number of pages you can buy? You can buy each book at most once.\nInput\nThe first input line contains two integers n and x: the number of books and the maximum total price.\nThe next line contains n integers h_1,h_2,\\ldots,h_n: the price of each book.\nThe last line contains n integers s_1,s_2,\\ldots,s_n: the number of pages of each book.\nOutput\nPrint one integer: the maximum number of pages.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le x \\le 10^5\n1 \\le h_i, s_i \\le 1000\n\nExample\nInput:\n4 10\n4 8 5 3\n5 12 8 1\n\nOutput:\n13\n\nExplanation: You can buy books 1 and 3. Their price is 4+5=9 and the number of pages is 5+8=13.\n",
        "code": "def main(n, x, prices, pages):\n    dp = [[0] * (x + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(x + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= prices[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - prices[i - 1]] + pages[i - 1])\n\n    return dp[n][x]",
        "test_list": [
            "assert main(4,10,[4,8,5,3],[5,12,8,1]) == 13",
            "assert main(3,7,[2,4,3],[3,5,2]) == 5",
            "assert main(2,5,[1,2],[2,3]) == 3",
            "assert main(5,15,[3,7,2,6,5],[8,12,2,9,5]) == 29",
            "assert main(1,1000,[1000],[1000]) == 1000"
        ]
    },
    {
        "title": "Array Description",
        "sample1_input": "3,5,[2,0,2]",
        "sample1_output": "3\n",
        "sample2_input": "4,3,[1,0,0,2]",
        "sample2_output": "0\n",
        "sample3_input": "2,4,[0,0]",
        "sample3_output": "10\n",
        "sample4_input": "5,6,[0,0,0,0,0]",
        "sample4_output": "32\n",
        "sample5_input": "1,100,[0]",
        "sample5_output": "100\n",
        "task_id": 57,
        "text": "You know that an array has n integers between 1 and  m, and the absolute difference between two adjacent values is at most 1.\nGiven a description of the array where some values may be unknown, your task is to count the number of arrays that match the description.\nInput\nThe first input line has two integers n and m: the array size and the upper bound for each value.\nThe next line has n integers x_1,x_2,\\dots,x_n: the contents of the array. Value 0 denotes an unknown value.\nOutput\nPrint one integer: the number of arrays modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 100\n0 \\le x_i \\le m\n\nExample\nInput:\n3 5\n2 0 2\n\nOutput:\n3\n\nExplanation: The arrays [2,1,2], [2,2,2] and [2,3,2] match the description.\n",
        "code": "def main(n, m, arr):\n    MOD = 10**9 + 7\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for x in range(1, m + 1):\n        if arr[0] == 0 or arr[0] == x:\n            dp[1][x] = 1\n\n    for i in range(2, n + 1):\n        for x in range(1, m + 1):\n            if arr[i - 1] == 0 or arr[i - 1] == x:\n                dp[i][x] = (dp[i - 1][x - 1] + dp[i - 1][x] + dp[i - 1][x + 1]) % MOD\n\n    return sum(dp[n]) % MOD",
        "test_list": [
            "assert main(3,5,[2,0,2]) == 3\n",
            "assert main(4,3,[1,0,0,2]) == 0\n",
            "assert main(2,4,[0,0]) == 10\n",
            "assert main(5,6,[0,0,0,0,0]) == 32\n",
            "assert main(1,100,[0]) == 100\n"
        ]
    },
    {
        "title": "Counting Towers",
        "sample1_input": "3,[2],[6],[1337]",
        "sample1_output": "8\n2864\n640403945\n",
        "sample2_input": "2,[1],[10]",
        "sample2_output": "2\n4897\n",
        "sample3_input": "1,[20]",
        "sample3_output": "33574528\n",
        "sample4_input": "4,[5],[7],[9],[11]",
        "sample4_output": "16\n48\n144\n424\n",
        "sample5_input": "5,[15],[18],[21],[24],[27]",
        "sample5_output": "1704\n17952\n190569\n2029408\n21656305\n",
        "task_id": 58,
        "text": "Your task is to build a tower whose width is 2 and height is n. You have an unlimited supply of blocks whose width and height are integers.\nFor example, here are some possible solutions for n=6:\n\nGiven n, how many different towers can you build? Mirrored and rotated towers are counted separately if they look different.\nInput\nThe first input line contains an integer t: the number of tests.\nAfter this, there are t lines, and each line contains an integer n: the height of the tower.\nOutput\nFor each test, print the number of towers modulo 10^9+7.\nConstraints\n\n1 \\le t \\le 100\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n2\n6\n1337\n\nOutput:\n8\n2864\n640403945\n",
        "code": "def main(t, heights):\n    MOD = 10**9 + 7\n    results = []\n\n    for n in heights:\n        # Initialize DP array\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n\n        # Calculate the number of towers for each height\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n        # Calculate the total number of towers\n        total_towers = (dp[n] + dp[n - 1]) % MOD\n        results.append(total_towers)\n\n    return results",
        "test_list": [
            "assert main(3,[2],[6],[1337]) == 8\n2864\n640403945\n",
            "assert main(2,[1],[10]) == 2\n4897\n",
            "assert main(1,[20]) == 33574528\n",
            "assert main(4,[5],[7],[9],[11]) == 16\n48\n144\n424\n",
            "assert main(5,[15],[18],[21],[24],[27]) == 1704\n17952\n190569\n2029408\n21656305\n"
        ]
    },
    {
        "title": "Edit Distance",
        "sample1_input": "LOVE\",\"MOVIE",
        "sample1_output": "2\n",
        "sample2_input": "ABCDEF\",\"XYZ",
        "sample2_output": "6\n",
        "sample3_input": "HELLO\",\"HI",
        "sample3_output": "4\n",
        "sample4_input": "ALGORITHM\",\"ALTRUISM",
        "sample4_output": "7\n",
        "sample5_input": "OPENAI\",\"GPT",
        "sample5_output": "5\n",
        "task_id": 59,
        "text": "The edit distance between two strings is the minimum number of operations required to transform one string into the other.\nThe allowed operations are:\n\nAdd one character to the string.\nRemove one character from the string.\nReplace one character in the string.\n\nFor example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I.\nYour task is to calculate the edit distance between two strings.\nInput\nThe first input line has a string that contains n characters between A–Z.\nThe second input line has a string that contains m characters between A–Z.\nOutput\nPrint one integer: the edit distance between the strings.\nConstraints\n\n1 \\le n,m \\le 5000\n\nExample\nInput:\nLOVE\nMOVIE\n\nOutput:\n2\n",
        "code": "def main(str1, str2):\n    n = len(str1)\n    m = len(str2)\n\n    # Create a 2D DP array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Initialize the DP array\n    for i in range(n + 1):\n        dp[i][0] = i\n    for j in range(m + 1):\n        dp[0][j] = j\n\n    # Fill the DP array using dynamic programming\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n    return dp[n][m]",
        "test_list": [
            "assert main(LOVE\",\"MOVIE) == 2\n",
            "assert main(ABCDEF\",\"XYZ) == 6\n",
            "assert main(HELLO\",\"HI) == 4\n",
            "assert main(ALGORITHM\",\"ALTRUISM) == 7\n",
            "assert main(OPENAI\",\"GPT) == 5\n"
        ]
    },
    {
        "title": "Rectangle Cutting",
        "sample1_input": "3,5",
        "sample1_output": "3\n",
        "sample2_input": "5,5",
        "sample2_output": "1\n",
        "sample3_input": "7,4",
        "sample3_output": "4\n",
        "sample4_input": "10,2",
        "sample4_output": "5\n",
        "sample5_input": "15,9",
        "sample5_output": "5\n",
        "task_id": 60,
        "text": "Given an a \\times b rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?\nInput\nThe only input line has two integers a and b.\nOutput\nPrint one integer: the minimum number of moves.\nConstraints\n\n1 \\le a,b \\le 500\n\nExample\nInput:\n3 5\n\nOutput:\n3\n",
        "code": "def main(a, b):\n    # Ensure a is the larger dimension\n    if a < b:\n        a, b = b, a\n\n    # Initialize the number of moves\n    moves = 0\n\n    while b > 0:\n        # Increment the number of moves by the number of squares that can be cut from the current rectangle\n        moves += a // b\n\n        # Update the dimensions of the remaining rectangle\n        a, b = b, a % b\n\n    return moves",
        "test_list": [
            "assert main(3,5) == 3\n",
            "assert main(5,5) == 1\n",
            "assert main(7,4) == 4\n",
            "assert main(10,2) == 5\n",
            "assert main(15,9) == 5\n"
        ]
    },
    {
        "title": "Removal Game",
        "sample1_input": "4,[4,5,1,3]",
        "sample1_output": "8\n",
        "sample2_input": "5,[7,2,8,1,5]",
        "sample2_output": "13\n",
        "sample3_input": "3,[10,2,7]",
        "sample3_output": "15\n",
        "sample4_input": "2,[-5,5]",
        "sample4_output": "5\n",
        "sample5_input": "1,[1000]",
        "sample5_output": "1000\n",
        "task_id": 61,
        "text": "There is a list of n numbers and two players who move alternately. On each move, a player removes either the first or last number from the list, and their score increases by that number. Both players try to maximize their scores.\nWhat is the maximum possible score for the first player when both players play optimally?\nInput\nThe first input line contains an integer n: the size of the list.\nThe next line has n integers x_1,x_2,\\ldots,x_n: the contents of the list.\nOutput\nPrint the maximum possible score for the first player.\nConstraints\n\n1 \\le n \\le 5000\n-10^9 \\le x_i \\le 10^9\n\nExample\nInput:\n4\n4 5 1 3\n\nOutput:\n8\n",
        "code": "def main(n, nums):\n    # Initialize a 2D table to store the maximum possible score for the first player\n    dp = [[0] * n for _ in range(n)]\n\n    # Fill the table diagonally\n    for i in range(n):\n        dp[i][i] = nums[i]\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n\n    # The maximum possible score for the first player is at dp[0][n - 1]\n    return dp[0][n - 1]",
        "test_list": [
            "assert main(4,[4,5,1,3]) == 8\n",
            "assert main(5,[7,2,8,1,5]) == 13\n",
            "assert main(3,[10,2,7]) == 15\n",
            "assert main(2,[-5,5]) == 5\n",
            "assert main(1,[1000]) == 1000\n"
        ]
    },
    {
        "title": "Two Sets II",
        "sample1_input": "7",
        "sample1_output": "4\n",
        "sample2_input": "5",
        "sample2_output": "2\n",
        "sample3_input": "10",
        "sample3_output": "42\n",
        "sample4_input": "2",
        "sample4_output": "0\n",
        "sample5_input": "1",
        "sample5_output": "0\n",
        "task_id": 62,
        "text": "Your task is to count the number of ways numbers 1,2,\\ldots,n can be divided into two sets of equal sum.\nFor example, if n=7, there are four solutions:\n\n\\{1,3,4,6\\} and \\{2,5,7\\}\n\\{1,2,5,6\\} and \\{3,4,7\\}\n\\{1,2,4,7\\} and \\{3,5,6\\}\n\\{1,6,7\\} and \\{2,3,4,5\\}\n\nInput\nThe only input line contains an integer n.\nOutput\nPrint the answer modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 500\n\nExample\nInput:\n7\n\nOutput:\n4\n",
        "code": "def main(n):\n    # Calculate the total sum of numbers from 1 to n\n    total_sum = (n * (n + 1)) // 2\n\n    # If the total sum is odd, there's no way to divide it into two sets with equal sums\n    if total_sum % 2 != 0:\n        return 0\n\n    # Initialize a 2D table to store the count of ways to achieve a given sum with the first i numbers\n    dp = [[0] * (total_sum // 2 + 1) for _ in range(n + 1)]\n\n    # There's one way to achieve a sum of 0, which is to have an empty set\n    for i in range(n + 1):\n        dp[i][0] = 1\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, total_sum // 2 + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= i:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % (10**9 + 7)\n\n    # The answer is in dp[n][total_sum // 2]\n    return dp[n][total_sum // 2]",
        "test_list": [
            "assert main(7) == 4\n",
            "assert main(5) == 2\n",
            "assert main(10) == 42\n",
            "assert main(2) == 0\n",
            "assert main(1) == 0\n"
        ]
    },
    {
        "title": "Increasing Subsequence",
        "sample1_input": "8,[7,3,5,3,6,2,9,8]",
        "sample1_output": "4\n",
        "sample2_input": "5,[1,2,3,4,5]",
        "sample2_output": "5\n",
        "sample3_input": "6,[5,4,3,2,1,6]",
        "sample3_output": "1\n",
        "sample4_input": "7,[5,1,2,3,6,4,7]",
        "sample4_output": "4\n",
        "sample5_input": "3,[1,1,1]",
        "sample5_output": "1\n",
        "task_id": 63,
        "text": "You are given an array containing n integers. Your task is to determine the longest increasing subsequence in the array, i.e., the longest subsequence where every element is larger than the previous one.\nA subsequence is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements. \nInput\nThe first line contains an integer n: the size of the array.\nAfter this there are n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint the length of the longest increasing subsequence.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8\n7 3 5 3 6 2 9 8\n\nOutput:\n4\n",
        "code": "def main(n, arr):\n    # Initialize an array to store the length of the longest increasing subsequence ending at each index\n    dp = [1] * n\n\n    # Iterate through the array to calculate the longest increasing subsequence length\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # The answer is the maximum value in the dp array\n    return max(dp)",
        "test_list": [
            "assert main(8,[7,3,5,3,6,2,9,8]) == 4\n",
            "assert main(5,[1,2,3,4,5]) == 5\n",
            "assert main(6,[5,4,3,2,1,6]) == 1\n",
            "assert main(7,[5,1,2,3,6,4,7]) == 4\n",
            "assert main(3,[1,1,1]) == 1\n"
        ]
    },
    {
        "title": "Projects",
        "sample1_input": "4,[2,4,4],[3,6,6],[6,8,2],[5,7,3]",
        "sample1_output": "7\n",
        "sample2_input": "5,[1,3,5],[2,4,6],[3,5,7],[4,6,8],[5,7,9]",
        "sample2_output": "26\n",
        "sample3_input": "3,[1,2,1],[2,3,2],[3,4,3]",
        "sample3_output": "6\n",
        "sample4_input": "3,[1,3,3],[2,4,4],[3,5,5]",
        "sample4_output": "9\n",
        "sample5_input": "2,[1,4,10],[2,5,5]",
        "sample5_output": "15\n",
        "task_id": 64,
        "text": "There are n projects you can attend. For each project, you know its starting and ending days and the amount of money you would get as reward. You can only attend one project during a day.\nWhat is the maximum amount of money you can earn?\nInput\nThe first input line contains an integer n: the number of projects.\nAfter this, there are n lines. Each such line has three integers a_i, b_i, and p_i: the starting day, the ending day, and the reward.\nOutput\nPrint one integer: the maximum amount of money you can earn.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a_i \\le b_i \\le 10^9\n1 \\le p_i \\le 10^9\n\nExample\nInput:\n4\n2 4 4\n3 6 6\n6 8 2\n5 7 3\n\nOutput:\n7\n",
        "code": "def main(n, projects):\n    # Sort the projects by their ending day\n    projects.sort(key=lambda x: x[1])\n\n    # Initialize an array to store the maximum reward for each day\n    dp = [0] * (max(p[1] for p in projects) + 1)\n\n    for i in range(n):\n        start, end, reward = projects[i]\n        # Find the maximum reward for the current day\n        dp[end] = max(dp[end], dp[start] + reward)\n\n    # The maximum reward is the maximum value in the dp array\n    return max(dp)",
        "test_list": [
            "assert main(4,[2,4,4],[3,6,6],[6,8,2],[5,7,3]) == 7\n",
            "assert main(5,[1,3,5],[2,4,6],[3,5,7],[4,6,8],[5,7,9]) == 26\n",
            "assert main(3,[1,2,1],[2,3,2],[3,4,3]) == 6\n",
            "assert main(3,[1,3,3],[2,4,4],[3,5,5]) == 9\n",
            "assert main(2,[1,4,10],[2,5,5]) == 15\n"
        ]
    },
    {
        "title": "Elevator Rides",
        "sample1_input": "4,10,[4,8,6,1]",
        "sample1_output": "2\n",
        "sample2_input": "5,15,[10,7,8,4,5]",
        "sample2_output": "3\n",
        "sample3_input": "3,7,[3,2,1]",
        "sample3_output": "2\n",
        "sample4_input": "2,5,[3,4]",
        "sample4_output": "1\n",
        "sample5_input": "1,1000,[1000]",
        "sample5_output": "1\n",
        "task_id": 65,
        "text": "There are n people who want to get to the top of a building which has only one elevator. You know the weight of each person and the maximum allowed weight in the elevator. What is the minimum number of elevator rides?\nInput\nThe first input line has two integers n and x: the number of people and the maximum allowed weight in the elevator.\nThe second line has n integers w_1,w_2,\\dots,w_n: the weight of each person.\nOutput\nPrint one integer: the minimum number of rides.\nConstraints\n\n1 \\le n \\le 20\n1 \\le x \\le 10^9\n1 \\le w_i \\le x\n\nExample\nInput:\n4 10\n4 8 6 1\n\nOutput:\n2\n",
        "code": "def main(n, x, weights):\n    weights.sort(reverse=True)\n    rides = 0\n    left, right = 0, n - 1\n\n    while left <= right:\n        if weights[left] + weights[right] <= x:\n            left += 1\n        right -= 1\n        rides += 1\n\n    return rides",
        "test_list": [
            "assert main(4,10,[4,8,6,1]) == 2\n",
            "assert main(5,15,[10,7,8,4,5]) == 3\n",
            "assert main(3,7,[3,2,1]) == 2\n",
            "assert main(2,5,[3,4]) == 1\n",
            "assert main(1,1000,[1000]) == 1\n"
        ]
    },
    {
        "title": "Counting Tilings",
        "sample1_input": "4,7",
        "sample1_output": "781\n",
        "sample2_input": "3,3",
        "sample2_output": "2\n",
        "sample3_input": "1,10",
        "sample3_output": "1\n",
        "sample4_input": "5,5",
        "sample4_output": "20\n",
        "sample5_input": "2,2",
        "sample5_output": "3\n",
        "task_id": 66,
        "text": "Your task is to count the number of ways you can fill an n \\times m grid using 1 \\times 2 and 2 \\times 1 tiles.\nInput\nThe only input line has two integers n and m.\nOutput\nPrint one integer: the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10\n1 \\le m \\le 1000\n\nExample\nInput:\n4 7\n\nOutput:\n781\n",
        "code": "def main(n, m):\n    MOD = 10**9 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i + 1 <= n and j + 2 <= m:\n                dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j]) % MOD\n            if i + 2 <= n and j + 1 <= m:\n                dp[i + 2][j + 1] = (dp[i + 2][j + 1] + dp[i][j]) % MOD\n\n    return dp[n][m]",
        "test_list": [
            "assert main(4,7) == 781\n",
            "assert main(3,3) == 2\n",
            "assert main(1,10) == 1\n",
            "assert main(5,5) == 20\n",
            "assert main(2,2) == 3\n"
        ]
    },
    {
        "title": "Counting Numbers",
        "sample1_input": "123,321",
        "sample1_output": "171\n",
        "sample2_input": "0,9",
        "sample2_output": "10\n",
        "sample3_input": "101,105",
        "sample3_output": "4\n",
        "sample4_input": "1000,1010",
        "sample4_output": "10\n",
        "sample5_input": "9876543210,9876543210",
        "sample5_output": "1\n",
        "task_id": 67,
        "text": "Your task is to count the number of integers between a and b where no two adjacent digits are the same.\nInput\nThe only input line has two integers a and b.\nOutput\nPrint one integer: the answer to the problem.\nConstraints\n\n0 \\le a \\le b \\le 10^{18}\n\nExample\nInput:\n123 321\n\nOutput:\n171\n",
        "code": "def main(a, b):\n    def count_numbers_with_no_adjacent_digits(x):\n        digits = str(x)\n        n = len(digits)\n        dp = [[0] * 10 for _ in range(n)]\n\n        for i in range(10):\n            dp[0][i] = 1\n\n        for i in range(1, n):\n            for j in range(10):\n                for k in range(10):\n                    if j != k:\n                        dp[i][j] += dp[i - 1][k]\n\n        count = sum(dp[n - 1])\n        return count\n\n    count_a = count_numbers_with_no_adjacent_digits(a - 1)\n    count_b = count_numbers_with_no_adjacent_digits(b)\n    result = count_b - count_a\n    return result",
        "test_list": [
            "assert main(123,321) == 171\n",
            "assert main(0,9) == 10\n",
            "assert main(101,105) == 4\n",
            "assert main(1000,1010) == 10\n",
            "assert main(9876543210,9876543210) == 1\n"
        ]
    },
    {
        "title": "Building Teams",
        "sample1_input": "5,3,[1,2],[1,3],[4,5]",
        "sample1_output": "1 2 2 1 2\n",
        "sample2_input": "6,4,[1,2],[1,3],[4,5],[4,6]",
        "sample2_output": "1 2 2 1 1 2\n",
        "sample3_input": "4,2,[1,2],[3,4]",
        "sample3_output": "1 2 1 2\n",
        "sample4_input": "3,3,[1,2],[2,3],[3,1]",
        "sample4_output": "IMPOSSIBLE\n",
        "sample5_input": "5,5,[1,2],[2,3],[3,4],[4,5],[5,1]",
        "sample5_output": "IMPOSSIBLE\n",
        "task_id": 68,
        "text": "There are n pupils in Uolevi's class, and m friendships between them. Your task is to divide the pupils into two teams in such a way that no two pupils in a team are friends. You can freely choose the sizes of the teams.\nInput\nThe first input line has two integers n and m: the number of pupils and friendships. The pupils are numbered 1,2,\\dots,n.\nThen, there are m lines describing the friendships. Each line has two integers a and b: pupils a and b are friends.\nEvery friendship is between two different pupils. You can assume that there is at most one friendship between any two pupils.\nOutput\nPrint an example of how to build the teams. For each pupil, print \"1\" or \"2\" depending on to which team the pupil will be assigned. You can print any valid team.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n1 2\n1 3\n4 5\n\nOutput:\n1 2 2 1 2\n",
        "code": "def main(n, m, friendships):\n    graph = [[] for _ in range(n)]\n    teams = [0] * n\n\n    for a, b in friendships:\n        graph[a - 1].append(b)\n        graph[b - 1].append(a)\n\n    def dfs(node, team):\n        teams[node] = team\n        for neighbor in graph[node]:\n            if teams[neighbor] == team:\n                return False\n            if teams[neighbor] == 0 and not dfs(neighbor, 3 - team):\n                return False\n        return True\n\n    for i in range(n):\n        if teams[i] == 0 and not dfs(i, 1):\n            return \"IMPOSSIBLE\"\n\n    return teams",
        "test_list": [
            "assert main(5,3,[1,2],[1,3],[4,5]) == 1 2 2 1 2\n",
            "assert main(6,4,[1,2],[1,3],[4,5],[4,6]) == 1 2 2 1 1 2\n",
            "assert main(4,2,[1,2],[3,4]) == 1 2 1 2\n",
            "assert main(3,3,[1,2],[2,3],[3,1]) == IMPOSSIBLE\n",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[5,1]) == IMPOSSIBLE\n"
        ]
    },
    {
        "title": "High Score",
        "sample1_input": "4,5,[1,2,3],[2,4,-1],[1,3,-2],[3,4,7],[1,4,4]",
        "sample1_output": "5\n",
        "sample2_input": "3,2,[1,2,10],[2,3,-5]",
        "sample2_output": "5\n",
        "sample3_input": "5,5,[1,2,5],[2,3,-2],[2,4,1],[4,3,-3],[3,5,4]",
        "sample3_output": "4\n",
        "sample4_input": "4,5,[1,2,1],[2,3,1],[3,4,1],[4,1,1],[1,3,2]",
        "sample4_output": "-1\n",
        "sample5_input": "6,6,[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,6,1],[1,6,1]",
        "sample5_output": "5\n",
        "task_id": 69,
        "text": "You play a game consisting of n rooms and m tunnels. Your initial score is 0, and each tunnel increases your score by x where x may be both positive or negative. You may go through a tunnel several times.\nYour task is to walk from room 1 to room n. What is the maximum score you can get?\nInput\nThe first input line has two integers n and m: the number of rooms and tunnels. The rooms are numbered 1,2,\\dots,n.\nThen, there are m lines describing the tunnels. Each line has three integers a, b and x: the tunnel starts at room a, ends at room b, and it increases your score by x. All tunnels are one-way tunnels.\nYou can assume that it is possible to get from room 1 to room n.\nOutput\nPrint one integer: the maximum score you can get. However, if you can get an arbitrarily large score, print -1.\nConstraints\n\n1 \\le n \\le 2500\n1 \\le m \\le 5000\n1 \\le a,b \\le n\n-10^9 \\le x \\le 10^9\n\nExample\nInput:\n4 5\n1 2 3\n2 4 -1\n1 3 -2\n3 4 7\n1 4 4\n\nOutput:\n5\n",
        "code": "def main(n, m, tunnels):\n    INF = float('inf')\n    dp = [0] + [-INF] * (n - 1)\n\n    for _ in range(n - 1):\n        for a, b, x in tunnels:\n            dp[b - 1] = max(dp[b - 1], dp[a - 1] + x)\n\n    for _ in range(n - 1):\n        for a, b, x in tunnels:\n            if dp[a - 1] + x > dp[b - 1]:\n                dp[b - 1] = INF\n\n    if dp[n - 1] == INF:\n        return -1\n    return dp[n - 1]\n\n\nn, m = map(int, input().split())\ntunnels = [list(map(int, input().split())) for _ in range(m)]\nresult = main(n, m, tunnels)\nprint(result)",
        "test_list": [
            "assert main(4,5,[1,2,3],[2,4,-1],[1,3,-2],[3,4,7],[1,4,4]) == 5\n",
            "assert main(3,2,[1,2,10],[2,3,-5]) == 5\n",
            "assert main(5,5,[1,2,5],[2,3,-2],[2,4,1],[4,3,-3],[3,5,4]) == 4\n",
            "assert main(4,5,[1,2,1],[2,3,1],[3,4,1],[4,1,1],[1,3,2]) == -1\n",
            "assert main(6,6,[1,2,1],[2,3,1],[3,4,1],[4,5,1],[5,6,1],[1,6,1]) == 5\n"
        ]
    },
    {
        "title": "Game Routes",
        "sample1_input": "4,5,[1,2],[2,4],[1,3],[3,4],[1,4]",
        "sample1_output": "3\n",
        "sample2_input": "5,5,[1,2],[2,3],[3,4],[4,5],[1,5]",
        "sample2_output": "1\n",
        "sample3_input": "3,2,[1,2],[2,3]",
        "sample3_output": "1\n",
        "sample4_input": "6,7,[1,2],[2,3],[3,4],[4,5],[5,6],[1,5],[2,4]",
        "sample4_output": "3\n",
        "sample5_input": "3,3,[1,2],[2,3],[1,3]",
        "sample5_output": "1\n",
        "task_id": 70,
        "text": "A game has n levels, connected by m teleporters, and your task is to get from level 1 to level n. The game has been designed so that there are no directed cycles in the underlying graph. In how many ways can you complete the game?\nInput\nThe first input line has two integers n and m: the number of levels and teleporters. The levels are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from level a to level b.\nOutput\nPrint one integer: the number of ways you can complete the game. Since the result may be large, print it modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 5\n1 2\n2 4\n1 3\n3 4\n1 4\n\nOutput:\n3\n",
        "code": "MOD = 10**9 + 7\n\n\ndef main(n, teleporters):\n    adj_list = [[] for _ in range(n)]\n    for a, b in teleporters:\n        adj_list[a - 1].append(b - 1)\n\n    dp = [0] * n\n    dp[0] = 1\n\n    for i in range(n):\n        for neighbor in adj_list[i]:\n            dp[neighbor] = (dp[neighbor] + dp[i]) % MOD\n\n    return dp[n - 1]\n\n\nn, m = map(int, input().split())\nteleporters = [tuple(map(int, input().split())) for _ in range(m)]\nresult = main(n, teleporters)\nprint(result)",
        "test_list": [
            "assert main(4,5,[1,2],[2,4],[1,3],[3,4],[1,4]) == 3\n",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[1,5]) == 1\n",
            "assert main(3,2,[1,2],[2,3]) == 1\n",
            "assert main(6,7,[1,2],[2,3],[3,4],[4,5],[5,6],[1,5],[2,4]) == 3\n",
            "assert main(3,3,[1,2],[2,3],[1,3]) == 1\n"
        ]
    },
    {
        "title": "De Bruijn Sequence",
        "sample1_input": "2",
        "sample1_output": "00011011",
        "sample2_input": "3",
        "sample2_output": "011001010000110100111101",
        "sample3_input": "4",
        "sample3_output": "1001101111011111010110001010110001100000111001000001011100110010",
        "sample4_input": "5",
        "sample4_output": "0110011011001111001110000110010000101011001010100001110101100001011010100011010111101000111111101010111000011000100010011100001101011110000010100101111111010010",
        "sample5_input": "6",
        "sample5_output": "101001110100110010110101010001001010001011110011110001011101110110000111100111000110111010111001000011100011101100100001000010010110100110011011000101111000101010101110111100100100010011011010011100010111111011000100011000111101001110011110010010011001101011110111101101101111100010000001001111000000010101100101010000111110010100001001110000001100111111100000001101101000011111001000\n",
        "task_id": 71,
        "text": "Your task is to construct a minimum-length bit string that contains all possible substrings of length n. For example, when n=2, the string 00110 is a valid solution, because its substrings of length 2 are 00, 01, 10 and 11.\nInput\nThe only input line has an integer n.\nOutput\nPrint a minimum-length bit string that contains all substrings of length n. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 15\n\nExample\nInput:\n2\n\nOutput:\n00110\n",
        "code": "def main(n):\n    # Calculate the total number of substrings\n    total_substrings = 2 ** n\n    # Initialize the result string\n    result = '0'\n    # Keep track of the last substring added\n    last_substring = '0'\n    # Start adding substrings\n    for i in range(1, total_substrings):\n        # Calculate the next substring using bitwise XOR\n        next_substring = bin(i)[2:].zfill(n)\n        next_substring = ''.join([str(int(last_substring[j]) ^ int(next_substring[j])) for j in range(n)])\n        result += next_substring\n        last_substring = next_substring\n    return result",
        "test_list": [
            "assert main(2) == 00011011",
            "assert main(3) == 011001010000110100111101",
            "assert main(4) == 1001101111011111010110001010110001100000111001000001011100110010",
            "assert main(5) == 0110011011001111001110000110010000101011001010100001110101100001011010100011010111101000111111101010111000011000100010011100001101011110000010100101111111010010",
            "assert main(6) == 101001110100110010110101010001001010001011110011110001011101110110000111100111000110111010111001000011100011101100100001000010010110100110011011000101111000101010101110111100100100010011011010011100010111111011000100011000111101001110011110010010011001101011110111101101101111100010000001001111000000010101100101010000111110010100001001110000001100111111100000001101101000011111001000\n"
        ]
    },
    {
        "title": "Teleporters Path",
        "sample1_input": "5,6,[1,2],[1,3],[2,4],[2,5],[3,1],[4,2]",
        "sample1_output": "1 3 1 2 4 2 5",
        "sample2_input": "4,3,[1,2],[2,3],[3,4]",
        "sample2_output": "1 2 3 4",
        "sample3_input": "3,2,[1,2],[2,3]",
        "sample3_output": "IMPOSSIBLE",
        "sample4_input": "6,5,[1,2],[1,3],[3,4],[3,5],[4,6]",
        "sample4_output": "1 3 5 3 4 6 4 3 1 2",
        "sample5_input": "3,1,[1,2]",
        "sample5_output": "IMPOSSIBLE",
        "task_id": 72,
        "text": "A game has n levels and m teleportes between them. You win the game if you move from level 1 to level n using every teleporter exactly once.\nCan you win the game, and what is a possible way to do it?\nInput\nThe first input line has two integers n and m: the number of levels and teleporters. The levels are numbered 1,2,\\dots,n.\nThen, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from level a to level b.\nYou can assume that each pair (a,b) in the input is distinct.\nOutput\nPrint m+1 integers: the sequence in which you visit the levels during the game. You can print any valid solution.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n2 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 6\n1 2\n1 3\n2 4\n2 5\n3 1\n4 2\n\nOutput:\n1 3 1 2 4 2 5\n",
        "code": "def main(n, m, teleporters):\n    levels = [0] * (n + 1)\n    path = []\n    g = {}\n    for a, b in teleporters:\n        g[a] = g.get(a, []) + [b]\n        g[b] = g.get(b, []) + [a]\n    for a in g:\n        g[a].sort()\n    for a in g:\n        if len(g[a]) % 2 == 1:\n            return \"IMPOSSIBLE\"\n    def dfs(node):\n        while g[node]:\n            v = g[node][0]\n            g[node] = g[node][1:]\n            dfs(v)\n        path.append(node)\n    dfs(1)\n    if len(path) != m + 1:\n        return \"IMPOSSIBLE\"\n    return path[::-1]",
        "test_list": [
            "assert main(5,6,[1,2],[1,3],[2,4],[2,5],[3,1],[4,2]) == 1 3 1 2 4 2 5",
            "assert main(4,3,[1,2],[2,3],[3,4]) == 1 2 3 4",
            "assert main(3,2,[1,2],[2,3]) == IMPOSSIBLE",
            "assert main(6,5,[1,2],[1,3],[3,4],[3,5],[4,6]) == 1 3 5 3 4 6 4 3 1 2",
            "assert main(3,1,[1,2]) == IMPOSSIBLE"
        ]
    },
    {
        "title": "Hamiltonian Flights",
        "sample1_input": "4,6,[1,2],[1,3],[2,3],[3,2],[2,4],[3,4]",
        "sample1_output": "2",
        "sample2_input": "3,3,[1,2],[2,3],[1,3]",
        "sample2_output": "0",
        "sample3_input": "5,5,[1,2],[2,3],[3,4],[4,5],[1,5]",
        "sample3_output": "4",
        "sample4_input": "3,1,[1,3]",
        "sample4_output": "0",
        "sample5_input": "6,9,[1,2],[1,3],[2,3],[3,4],[4,5],[5,6],[2,4],[3,5],[4,6]",
        "sample5_output": "6",
        "task_id": 73,
        "text": "There are n cities and m flight connections between them. You want to travel from Syrjälä to Lehmälä so that you visit each city exactly once. How many possible routes are there?\nInput\nThe first input line has two integers n and m: the number of cities and flights. The cities are numbered 1,2,\\dots,n. City 1 is Syrjälä, and city n is Lehmälä.\nThen, there are m lines describing the flights. Each line has two integers a and b: there is a flight from city a to city b. All flights are one-way flights.\nOutput\nPrint one integer: the number of routes modulo 10^9+7.\nConstraints\n\n2 \\le n \\le 20\n1 \\le m \\le n^2\n1 \\le a,b \\le n\n\nExample\nInput:\n4 6\n1 2\n1 3\n2 3\n3 2\n2 4\n3 4\n\nOutput:\n2\n",
        "code": "def main(n, m, flights):\n    mod = 10**9 + 7\n    g = [[] for _ in range(n)]\n    for a, b in flights:\n        g[a - 1].append(b - 1)\n    dp = [[0] * n for _ in range(1 << n)]\n    dp[1][0] = 1\n    for mask in range(1 << n):\n        for u in range(n):\n            if (mask >> u) & 1:\n                for v in g[u]:\n                    if (mask >> v) & 1 == 0:\n                        dp[mask | (1 << v)][v] = (dp[mask | (1 << v)][v] + dp[mask][u]) % mod\n    ans = 0\n    for u in g[n - 1]:\n        ans = (ans + dp[(1 << n) - 1][u]) % mod\n    return ans",
        "test_list": [
            "assert main(4,6,[1,2],[1,3],[2,3],[3,2],[2,4],[3,4]) == 2",
            "assert main(3,3,[1,2],[2,3],[1,3]) == 0",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[1,5]) == 4",
            "assert main(3,1,[1,3]) == 0",
            "assert main(6,9,[1,2],[1,3],[2,3],[3,4],[4,5],[5,6],[2,4],[3,5],[4,6]) == 6"
        ]
    },
    {
        "title": "Knight's Tour",
        "sample1_input": "2,1",
        "sample1_output": "8 1 10 13 6 3 20 17\n11 14 7 2 19 16 23 4\n26 9 12 15 24 5 18 21\n49 58 25 28 51 22 33 30\n40 27 50 59 32 29 52 35\n57 48 41 44 37 34 31 62\n42 39 46 55 60 63 36 53\n47 56 43 38 45 54 61 64",
        "sample2_input": "4,4",
        "sample2_output": "0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
        "sample3_input": "1,1",
        "sample3_output": "1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
        "sample4_input": "8,1",
        "sample4_output": "1 4 3 20 17 14 19 6\n2 7 2 5 18 13 16 15\n39 26 31 50 25 22 9 8\n32 37 40 49 24 21 10 23\n27 38 51 46 41 30 11 12\n36 33 28 47 52 45 42 29\n53 60 35 54 61 48 59 44\n34 55 62 57 56 63 64 43",
        "sample5_input": "5,5",
        "sample5_output": "0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
        "task_id": 74,
        "text": "Given a starting position of a knight on an 8 \\times 8 chessboard, your task is to find a sequence of moves such that it visits every square exactly once.\nOn each move, the knight may either move two steps horizontally and one step vertically, or one step horizontally and two steps vertically.\nInput\nThe only line has two integers x and y: the knight's starting position.\nOutput\nPrint a grid that shows how the knight moves (according to the example). You can print any valid solution.\nConstraints\n\n1 \\le x,y \\le 8\n\nExample\nInput:\n2 1\n\nOutput:\n8 1 10 13 6 3 20 17 \n11 14 7 2 19 16 23 4 \n26 9 12 15 24 5 18 21 \n49 58 25 28 51 22 33 30 \n40 27 50 59 32 29 52 35 \n57 48 41 44 37 34 31 62 \n42 39 46 55 60 63 36 53 \n47 56 43 38 45 54 61 64\n",
        "code": "def main(x, y):\n    grid = [[0] * 8 for _ in range(8)]\n    moves = [(2, 1), (1, 2), (-2, 1), (-1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2)]\n    current_x, current_y = x - 1, y - 1\n    for i in range(1, 65):\n        grid[current_x][current_y] = i\n        next_moves = []\n        for dx, dy in moves:\n            new_x, new_y = current_x + dx, current_y + dy\n            if 0 <= new_x < 8 and 0 <= new_y < 8 and grid[new_x][new_y] == 0:\n                next_moves.append((new_x, new_y))\n        if not next_moves:\n            break\n        next_x, next_y = min(next_moves, key=lambda p: len([d for d in moves if (p[0] - current_x, p[1] - current_y) == d]))\n        current_x, current_y = next_x, next_y\n    return '\\n'.join([' '.join(map(str, row)) for row in grid])",
        "test_list": [
            "assert main(2,1) == 8 1 10 13 6 3 20 17\n11 14 7 2 19 16 23 4\n26 9 12 15 24 5 18 21\n49 58 25 28 51 22 33 30\n40 27 50 59 32 29 52 35\n57 48 41 44 37 34 31 62\n42 39 46 55 60 63 36 53\n47 56 43 38 45 54 61 64",
            "assert main(4,4) == 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
            "assert main(1,1) == 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
            "assert main(8,1) == 1 4 3 20 17 14 19 6\n2 7 2 5 18 13 16 15\n39 26 31 50 25 22 9 8\n32 37 40 49 24 21 10 23\n27 38 51 46 41 30 11 12\n36 33 28 47 52 45 42 29\n53 60 35 54 61 48 59 44\n34 55 62 57 56 63 64 43",
            "assert main(5,5) == 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0"
        ]
    },
    {
        "title": "Download Speed",
        "sample1_input": "4,5,[1,2,3],[2,4,2],[1,3,4],[3,4,5],[4,1,3]",
        "sample1_output": "6",
        "sample2_input": "3,3,[1,2,10],[2,3,5],[1,3,7]",
        "sample2_output": "12",
        "sample3_input": "5,5,[1,2,1],[2,3,2],[3,4,3],[4,5,4],[5,1,5]",
        "sample3_output": "15",
        "sample4_input": "2,1,[1,2,8]",
        "sample4_output": "8",
        "sample5_input": "4,4,[1,2,1],[2,3,2],[3,4,3],[4,1,4]",
        "sample5_output": "10",
        "task_id": 75,
        "text": "Consider a network consisting of n computers and m connections. Each connection specifies how fast a computer can send data to another computer.\nKotivalo wants to download some data from a server. What is the maximum speed he can do this, using the connections in the network?\nInput\nThe first input line has two integers n and m: the number of computers and connections. The computers are numbered 1,2,\\dots,n. Computer 1 is the server and computer n is Kotivalo's computer.\nAfter this, there are m lines describing the connections. Each line has three integers a, b and c: computer a can send data to computer b at speed c.\nOutput\nPrint one integer: the maximum speed Kotivalo can download data.\nConstraints\n\n1 \\le n \\le 500\n1 \\le m \\le 1000\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n4 5\n1 2 3\n2 4 2\n1 3 4\n3 4 5\n4 1 3\n\nOutput:\n6\n",
        "code": "def main(n, m, connections):\n    graph = [[] for _ in range(n)]\n    for a, b, c in connections:\n        graph[a - 1].append((b - 1, c))\n    inf = float('inf')\n    dist = [inf] * n\n    dist[0] = 0\n    for _ in range(n):\n        for u in range(n):\n            for v, w in graph[u]:\n                dist[v] = min(dist[v], dist[u] + w)\n    return dist[n - 1]",
        "test_list": [
            "assert main(4,5,[1,2,3],[2,4,2],[1,3,4],[3,4,5],[4,1,3]) == 6",
            "assert main(3,3,[1,2,10],[2,3,5],[1,3,7]) == 12",
            "assert main(5,5,[1,2,1],[2,3,2],[3,4,3],[4,5,4],[5,1,5]) == 15",
            "assert main(2,1,[1,2,8]) == 8",
            "assert main(4,4,[1,2,1],[2,3,2],[3,4,3],[4,1,4]) == 10"
        ]
    },
    {
        "title": "Police Chase",
        "sample1_input": "4,5,[1,2],[1,3],[2,3],[3,4],[1,4]",
        "sample1_output": "2\n1 4\n3 4\n",
        "sample2_input": "3,3,[1,2],[2,3],[1,3]",
        "sample2_output": "0\n",
        "sample3_input": "5,5,[1,2],[2,3],[3,4],[4,5],[1,4]",
        "sample3_output": "0\n",
        "sample4_input": "2,1,[1,2]",
        "sample4_output": "1\n1 2\n",
        "sample5_input": "6,7,[1,2],[1,3],[1,4],[2,3],[2,4],[3,5],[4,6]",
        "sample5_output": "5\n1 2\n1 3\n1 4\n3 5\n4 6\n",
        "task_id": 76,
        "text": "Kaaleppi has just robbed a bank and is now heading to the harbor. However, the police wants to stop him by closing some streets of the city.\nWhat is the minimum number of streets that should be closed so that there is no route between the bank and the harbor?\nInput\nThe first input line has two integers n and m: the number of crossings and streets. The crossings are numbered 1,2,\\dots,n. The bank is located at crossing 1, and the harbor is located at crossing n.\nAfter this, there are m lines that describing the streets. Each line has two integers a and b: there is a street between crossings a and b. All streets are two-way streets, and there is at most one street between two crossings.\nOutput\nFirst print an integer k: the minimum number of streets that should be closed. After this, print k lines describing the streets. You can print any valid solution.\nConstraints\n\n2 \\le n \\le 500\n1 \\le m \\le 1000\n1 \\le a,b \\le n\n\nExample\nInput:\n4 5\n1 2\n1 3\n2 3\n3 4\n1 4\n\nOutput:\n2\n3 4\n1 4\n",
        "code": "def main(n, m, streets):\n    graph = [[] for _ in range(n)]\n    for a, b in streets:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    visited = [False] * n\n    visited[0] = True\n    stack = [0]\n    while stack:\n        node = stack.pop()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                stack.append(neighbor)\n    if visited[n - 1]:\n        closed_streets = []\n        for i in range(n):\n            for neighbor in graph[i]:\n                if not visited[i] or not visited[neighbor]:\n                    closed_streets.append((i + 1, neighbor + 1))\n        return len(closed_streets), closed_streets\n    else:\n        return 0, []",
        "test_list": [
            "assert main(4,5,[1,2],[1,3],[2,3],[3,4],[1,4]) == 2\n1 4\n3 4\n",
            "assert main(3,3,[1,2],[2,3],[1,3]) == 0\n",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[1,4]) == 0\n",
            "assert main(2,1,[1,2]) == 1\n1 2\n",
            "assert main(6,7,[1,2],[1,3],[1,4],[2,3],[2,4],[3,5],[4,6]) == 5\n1 2\n1 3\n1 4\n3 5\n4 6\n"
        ]
    },
    {
        "title": "School Dance",
        "sample1_input": "3,2,4,[1,1],[1,2],[2,1],[3,1]",
        "sample1_output": "2\n1 1\n2 2\n",
        "sample2_input": "4,4,5,[1,1],[2,2],[3,3],[4,4],[1,4]",
        "sample2_output": "4\n1 1\n2 2\n3 3\n4 4\n",
        "sample3_input": "3,3,3,[1,2],[2,3],[3,1]",
        "sample3_output": "3\n1 2\n2 3\n3 1\n",
        "sample4_input": "5,4,6,[1,1],[2,2],[3,3],[4,4],[5,5],[5,4]",
        "sample4_output": "4\n1 1\n2 2\n3 3\n4 4\n",
        "sample5_input": "2,3,2,[1,2],[1,1]",
        "sample5_output": "2\n1 1\n2 2\n",
        "task_id": 77,
        "text": "There are n boys and m girls in a school. Next week a school dance will be organized. A dance pair consists of a boy and a girl, and there are k potential pairs.\nYour task is to find out the maximum number of dance pairs and show how this number can be achieved.\nInput\nThe first input line has three integers n, m and k: the number of boys, girls, and potential pairs. The boys are numbered 1,2,\\dots,n, and the girls are numbered 1,2,\\dots,m.\nAfter this, there are k lines describing the potential pairs. Each line has two integers a and b: boy a and girl b are willing to dance together.\nOutput\nFirst print one integer r: the maximum number of dance pairs. After this, print r lines describing the pairs. You can print any valid solution.\nConstraints\n\n1 \\le n,m \\le 500\n1 \\le k \\le 1000\n1 \\le a \\le n\n1 \\le b \\le m\n\nExample\nInput:\n3 2 4\n1 1\n1 2\n2 1\n3 1\n\nOutput:\n2\n1 2\n3 1\n",
        "code": "def main(n, m, k, pairs):\n    matches = min(n, m, k)\n    pairings = [(i, i) for i in range(1, matches + 1)]\n    return matches, pairings",
        "test_list": [
            "assert main(3,2,4,[1,1],[1,2],[2,1],[3,1]) == 2\n1 1\n2 2\n",
            "assert main(4,4,5,[1,1],[2,2],[3,3],[4,4],[1,4]) == 4\n1 1\n2 2\n3 3\n4 4\n",
            "assert main(3,3,3,[1,2],[2,3],[3,1]) == 3\n1 2\n2 3\n3 1\n",
            "assert main(5,4,6,[1,1],[2,2],[3,3],[4,4],[5,5],[5,4]) == 4\n1 1\n2 2\n3 3\n4 4\n",
            "assert main(2,3,2,[1,2],[1,1]) == 2\n1 1\n2 2\n"
        ]
    },
    {
        "title": "Distinct Routes",
        "sample1_input": "6,7,[1,2],[1,3],[2,6],[3,4],[3,5],[4,6],[5,6]",
        "sample1_output": "2\n3\n1 2 6\n4\n1 3 4 6\n",
        "sample2_input": "5,5,[1,2],[2,3],[3,4],[4,5],[1,5]",
        "sample2_output": "1\n5\n1 5\n",
        "sample3_input": "3,3,[1,2],[1,3],[2,3]",
        "sample3_output": "1\n3\n1 3\n",
        "sample4_input": "4,4,[1,2],[2,3],[3,4],[1,4]",
        "sample4_output": "1\n4\n1 4\n",
        "sample5_input": "2,1,[1,2]",
        "sample5_output": "1\n2\n1 2\n",
        "task_id": 78,
        "text": "A game consists of n rooms and m teleporters. At the beginning of each day, you start in room 1 and you have to reach room n.\nYou can use each teleporter at most once during the game. How many days can you play if you choose your routes optimally?\nInput\nThe first input line has two integers n and m: the number of rooms and teleporters. The rooms are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from room a to room b.\nThere are no two teleporters whose starting and ending room are the same.\nOutput\nFirst print an integer k: the maximum number of days you can play the game. Then, print k route descriptions according to the example. You can print any valid solution.\nConstraints\n\n2 \\le n \\le 500\n1 \\le m \\le 1000\n1 \\le a,b \\le n\n\nExample\nInput:\n6 7\n1 2\n1 3\n2 6\n3 4\n3 5\n4 6\n5 6\n\nOutput:\n2\n3\n1 2 6\n4\n1 3 4 6\n",
        "code": "def main(n, m, teleporters):\n    graph = [[] for _ in range(n)]\n    for a, b in teleporters:\n        graph[a - 1].append(b - 1)\n    visited = [False] * n\n    routes = []\n    stack = [(0, [])]\n    while stack:\n        node, path = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                new_path = path + [node + 1]\n                if neighbor == n - 1:\n                    routes.append(new_path)\n                else:\n                    stack.append((neighbor, new_path))\n    return len(routes), routes",
        "test_list": [
            "assert main(6,7,[1,2],[1,3],[2,6],[3,4],[3,5],[4,6],[5,6]) == 2\n3\n1 2 6\n4\n1 3 4 6\n",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[1,5]) == 1\n5\n1 5\n",
            "assert main(3,3,[1,2],[1,3],[2,3]) == 1\n3\n1 3\n",
            "assert main(4,4,[1,2],[2,3],[3,4],[1,4]) == 1\n4\n1 4\n",
            "assert main(2,1,[1,2]) == 1\n2\n1 2\n"
        ]
    },
    {
        "title": "Static Range Sum Queries",
        "sample1_input": "8,4,[3,2,4,5,1,1,5,3],[2,4],[5,6],[1,8],[3,3]",
        "sample1_output": "11\n2\n24\n4\n",
        "sample2_input": "5,3,[1,2,3,4,5],[1,5],[2,4],[3,3]",
        "sample2_output": "15\n9\n3\n",
        "sample3_input": "3,1,[1,1,1],[1,3]",
        "sample3_output": "3\n",
        "sample4_input": "6,2,[1,2,3,4,5,6],[2,5],[1,6]",
        "sample4_output": "14\n21\n",
        "sample5_input": "4,1,[1,1,1,1],[2,4]",
        "sample5_output": "3\n",
        "task_id": 79,
        "text": "Given an array of n integers, your task is to process q queries of the form: what is the sum of values in range [a,b]?\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has two integers a and b: what is the sum of values in range [a,b]?\nOutput\nPrint the result of each query.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n\nOutput:\n11\n2\n24\n4\n",
        "code": "def main(n, q, values, queries):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + values[i]\n    results = []\n    for a, b in queries:\n        results.append(prefix_sum[b] - prefix_sum[a - 1])\n    return results",
        "test_list": [
            "assert main(8,4,[3,2,4,5,1,1,5,3],[2,4],[5,6],[1,8],[3,3]) == 11\n2\n24\n4\n",
            "assert main(5,3,[1,2,3,4,5],[1,5],[2,4],[3,3]) == 15\n9\n3\n",
            "assert main(3,1,[1,1,1],[1,3]) == 3\n",
            "assert main(6,2,[1,2,3,4,5,6],[2,5],[1,6]) == 14\n21\n",
            "assert main(4,1,[1,1,1,1],[2,4]) == 3\n"
        ]
    },
    {
        "title": "Range Xor Queries",
        "sample1_input": "8,4,[3,2,4,5,1,1,5,3],[2,4],[5,6],[1,8],[3,3]",
        "sample1_output": "3\n0\n6\n4\n",
        "sample2_input": "5,3,[1,2,3,4,5],[2,1,5],[1,3,1],[2,1,5]",
        "sample2_output": "15\n1\n15\n",
        "sample3_input": "4,2,[2,2,2,2],[1,3,5],[2,1,4]",
        "sample3_output": "2\n2\n",
        "sample4_input": "7,3,[1,2,3,4,5,6,7],[2,3,5],[1,4,8],[2,1,7]",
        "sample4_output": "7\n6\n7\n",
        "sample5_input": "6,4,[10,20,30,40,50,60],[2,1,6],[1,4,25],[2,2,5],[2,1,4]",
        "sample5_output": "150\n55\n30\n100\n",
        "task_id": 80,
        "text": "Given an array of n integers, your task is to process q queries of the form: what is the xor sum of values in range [a,b]?\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has two integers a and b: what is the xor sum of values in range [a,b]?\nOutput\nPrint the result of each query.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n\nOutput:\n3\n0\n6\n4\n",
        "code": "def main(n, q, values, queries):\n    result = []\n    prefix_xor = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ values[i]\n\n    for query in queries:\n        a, b = query\n        result.append(prefix_xor[b] ^ prefix_xor[a - 1])\n\n    return result",
        "test_list": [
            "assert main(8,4,[3,2,4,5,1,1,5,3],[2,4],[5,6],[1,8],[3,3]) == 3\n0\n6\n4\n",
            "assert main(5,3,[1,2,3,4,5],[2,1,5],[1,3,1],[2,1,5]) == 15\n1\n15\n",
            "assert main(4,2,[2,2,2,2],[1,3,5],[2,1,4]) == 2\n2\n",
            "assert main(7,3,[1,2,3,4,5,6,7],[2,3,5],[1,4,8],[2,1,7]) == 7\n6\n7\n",
            "assert main(6,4,[10,20,30,40,50,60],[2,1,6],[1,4,25],[2,2,5],[2,1,4]) == 150\n55\n30\n100\n"
        ]
    },
    {
        "title": "Range Update Queries",
        "sample1_input": "8,3,[3,2,4,5,1,1,5,3],[2,4],[1,2,5,1],[2,4]",
        "sample1_output": "5\n6\n",
        "sample2_input": "5,4,[1,2,3,4,5],[2,5],[1,2,4,1],[2,1],[2,5]",
        "sample2_output": "5\n4\n15\n",
        "sample3_input": "6,4,[10,20,30,40,50,60],[1,3,4,5],[2,1],[1,4,6,10],[2,6]",
        "sample3_output": "30\n20\n60\n",
        "sample4_input": "7,5,[5,5,5,5,5,5,5],[2,3],[1,1,7,2],[2,7],[2,1]",
        "sample4_output": "5\n7\n10\n5\n",
        "sample5_input": "10,4,[1,2,3,4,5,6,7,8,9,10],[1,2,7,3],[2,10],[2,5],[2,9]",
        "sample5_output": "12\n15\n45\n",
        "task_id": 81,
        "text": "Given an array of n integers, your task is to process q queries of the following types:\n\nincrease each value in range [a,b] by u\nwhat is the value at position k?\n\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has three integers: either \"1 a b u\" or \"2 k\".\nOutput\nPrint the result of each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i, u \\le 10^9\n1 \\le k \\le n\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 3\n3 2 4 5 1 1 5 3\n2 4\n1 2 5 1\n2 4\n\nOutput:\n5\n6\n",
        "code": "def main(n, q, values, queries):\n    result = []\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + values[i]\n\n    for query in queries:\n        if query[0] == 1:\n            a, b, u = query[1], query[2], query[3]\n            prefix_sum[a - 1] += u\n            prefix_sum[b] -= u\n        elif query[0] == 2:\n            k = query[1]\n            result.append(prefix_sum[k])\n\n    return result",
        "test_list": [
            "assert main(8,3,[3,2,4,5,1,1,5,3],[2,4],[1,2,5,1],[2,4]) == 5\n6\n",
            "assert main(5,4,[1,2,3,4,5],[2,5],[1,2,4,1],[2,1],[2,5]) == 5\n4\n15\n",
            "assert main(6,4,[10,20,30,40,50,60],[1,3,4,5],[2,1],[1,4,6,10],[2,6]) == 30\n20\n60\n",
            "assert main(7,5,[5,5,5,5,5,5,5],[2,3],[1,1,7,2],[2,7],[2,1]) == 5\n7\n10\n5\n",
            "assert main(10,4,[1,2,3,4,5,6,7,8,9,10],[1,2,7,3],[2,10],[2,5],[2,9]) == 12\n15\n45\n"
        ]
    },
    {
        "title": "Hotel Queries",
        "sample1_input": "8,5,[3,2,4,1,5,5,2,6],[4,4,7,1,1]",
        "sample1_output": "3 5 0 1 1\n",
        "sample2_input": "5,4,[2,3,4,5,1],[3,2,5,1]",
        "sample2_output": "2 0 3 0\n",
        "sample3_input": "3,2,[1,1,1],[3,1]",
        "sample3_output": "0 0\n",
        "sample4_input": "1,5,[5],[1,2,3,4,5]",
        "sample4_output": "1 0 0 0 0\n",
        "sample5_input": "4,3,[3,3,3,3],[3,4,5]",
        "sample5_output": "1 2 3\n",
        "task_id": 82,
        "text": "There are n hotels on a street. For each hotel you know the number of free rooms. Your task is to assign hotel rooms for groups of tourists. All members of a group want to stay in the same hotel.\nThe groups will come to you one after another, and you know for each group the number of rooms it requires. You always assign a group to the first hotel having enough rooms. After this, the number of free rooms in the hotel decreases.\nInput\nThe first input line contains two integers n and m: the number of hotels and the number of groups. The hotels are numbered 1,2,\\ldots,n.\nThe next line contains n integers h_1,h_2,\\ldots,h_n: the number of free rooms in each hotel.\nThe last line contains m integers r_1,r_2,\\ldots,r_m: the number of rooms each group requires.\nOutput\nPrint the assigned hotel for each group. If a group cannot be assigned a hotel, print 0 instead.\nConstraints\n\n1 \\le n,m \\le 2 \\cdot 10^5\n1 \\le h_i \\le 10^9\n1 \\le r_i \\le 10^9\n\nExample\nInput:\n8 5\n3 2 4 1 5 5 2 6\n4 4 7 1 1\n\nOutput:\n3 5 0 1 1\n",
        "code": "def main(n, m, hotels, groups):\n    result = []\n    for group in groups:\n        assigned = False\n        for i in range(n):\n            if hotels[i] >= group:\n                result.append(i + 1)\n                hotels[i] -= group\n                assigned = True\n                break\n        if not assigned:\n            result.append(0)\n    return result",
        "test_list": [
            "assert main(8,5,[3,2,4,1,5,5,2,6],[4,4,7,1,1]) == 3 5 0 1 1\n",
            "assert main(5,4,[2,3,4,5,1],[3,2,5,1]) == 2 0 3 0\n",
            "assert main(3,2,[1,1,1],[3,1]) == 0 0\n",
            "assert main(1,5,[5],[1,2,3,4,5]) == 1 0 0 0 0\n",
            "assert main(4,3,[3,3,3,3],[3,4,5]) == 1 2 3\n"
        ]
    },
    {
        "title": "List Removals",
        "sample1_input": "5,[2,6,1,4,2],[3,1,3,1,1]",
        "sample1_output": "1 2 2 6 4\n",
        "sample2_input": "4,[10,20,30,40],[4,3,2,1]",
        "sample2_output": "40 30 20 10\n",
        "sample3_input": "6,[5,4,3,2,1,0],[6,5,4,3,2,1]",
        "sample3_output": "0 1 2 3 4 5\n",
        "sample4_input": "3,[7,8,9],[2,1,1]",
        "sample4_output": "8 7 9\n",
        "sample5_input": "10,[1,2,3,4,5,6,7,8,9,10],[10,1,1,1,1,1,1,1,1,1]",
        "sample5_output": "1 2 3 4 5 6 7 8 9 10\n",
        "task_id": 83,
        "text": "You are given a list consisting of n integers. Your task is to remove elements from the list at given positions, and report the removed elements.\nInput\nThe first input line has an integer n: the initial size of the list. During the process, the elements are numbered 1,2,\\dots,k where k is the current size of the list.\nThe second line has n integers x_1,x_2,\\dots,x_n: the contents of the list.\nThe last line has n integers p_1,p_2,\\dots,p_n: the positions of the elements to be removed.\nOutput\nPrint the elements in the order they are removed.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le p_i \\le n-i+1\n\nExample\nInput:\n5\n2 6 1 4 2\n3 1 3 1 1\n\nOutput:\n1 2 2 6 4\n\nExplanation: The contents of the list are [2,6,1,4,2], [2,6,4,2], [6,4,2], [6,4], [4] and [].\n",
        "code": "def main(n, lst, positions):\n    removed_elements = []\n    for i in range(n):\n        position = positions[i] - 1\n        removed_elements.append(lst[position])\n        del lst[position]\n    return removed_elements",
        "test_list": [
            "assert main(5,[2,6,1,4,2],[3,1,3,1,1]) == 1 2 2 6 4\n",
            "assert main(4,[10,20,30,40],[4,3,2,1]) == 40 30 20 10\n",
            "assert main(6,[5,4,3,2,1,0],[6,5,4,3,2,1]) == 0 1 2 3 4 5\n",
            "assert main(3,[7,8,9],[2,1,1]) == 8 7 9\n",
            "assert main(10,[1,2,3,4,5,6,7,8,9,10],[10,1,1,1,1,1,1,1,1,1]) == 1 2 3 4 5 6 7 8 9 10\n"
        ]
    },
    {
        "title": "Prefix Sum Queries",
        "sample1_input": "8,4,[1,2,-1,3,1,-5,1,4],[2,2,6],[1,4,-2],[2,2,6],[2,3,4]",
        "sample1_output": "5\n2\n0\n",
        "sample2_input": "6,3,[-2,-3,5,-1,2,-2],[2,1,6],[1,4,-2],[2,1,6]",
        "sample2_output": "3\n1\n",
        "sample3_input": "5,4,[-1,2,-3,4,-5],[1,5,-10],[2,2,4],[1,1,1],[2,2,3]",
        "sample3_output": "6\n-1\n",
        "sample4_input": "7,3,[5,-3,2,-6,4,1,-1],[2,1,7],[1,2,3],[2,2,6]",
        "sample4_output": "3\n-2\n",
        "sample5_input": "10,4,[-3,5,-2,1,4,-2,-5,3,0,-1],[2,1,10],[1,4,3],[2,3,7]",
        "sample5_output": "10\n-1\n1\n",
        "task_id": 84,
        "text": "Given an array of n integers, your task is to process q queries of the following types:\n\nupdate the value at position k to u\nwhat is the maximum prefix sum in range [a,b]?\n\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has three integers: either \"1 k u\" or \"2 a b\".\nOutput\nPrint the result of each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n-10^9 \\le x_i, u \\le 10^9\n1 \\le k \\le n\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n1 2 -1 3 1 -5 1 4\n2 2 6\n1 4 -2\n2 2 6\n2 3 4\n\nOutput:\n5\n2\n0\n",
        "code": "def main(n, values, queries):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + values[i]\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            k, u = query[1], query[2]\n            delta = u - values[k - 1]\n            values[k - 1] = u\n            for i in range(k, n + 1):\n                prefix_sum[i] += delta\n        else:\n            a, b = query[1], query[2]\n            result = prefix_sum[b] - prefix_sum[a - 1]\n            results.append(result)\n    return results",
        "test_list": [
            "assert main(8,4,[1,2,-1,3,1,-5,1,4],[2,2,6],[1,4,-2],[2,2,6],[2,3,4]) == 5\n2\n0\n",
            "assert main(6,3,[-2,-3,5,-1,2,-2],[2,1,6],[1,4,-2],[2,1,6]) == 3\n1\n",
            "assert main(5,4,[-1,2,-3,4,-5],[1,5,-10],[2,2,4],[1,1,1],[2,2,3]) == 6\n-1\n",
            "assert main(7,3,[5,-3,2,-6,4,1,-1],[2,1,7],[1,2,3],[2,2,6]) == 3\n-2\n",
            "assert main(10,4,[-3,5,-2,1,4,-2,-5,3,0,-1],[2,1,10],[1,4,3],[2,3,7]) == 10\n-1\n1\n"
        ]
    },
    {
        "link": "/problemset/task/2206",
        "title": "Pizzeria Queries",
        "content": "There are n buildings on a street, numbered 1,2,\\dots,n. Each building has a pizzeria and an apartment.\nThe pizza price in building k is p_k. If you order a pizza from building a to building b, its price (with delivery) is p_a+|a-b|.\nYour task is to process two types of queries:\n\nThe pizza price p_k in building k becomes x.\nYou are in building k and want to order a pizza. What is the minimum price?\n\nInput\nThe first input line has two integers n and q: the number of buildings and queries.\nThe second line has n integers p_1,p_2,\\dots,p_n: the initial pizza price in each building.\nFinally, there are q lines that describe the queries. Each line is either \"1 k x\" or \"2 k\".\nOutput\nPrint the answer for each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le p_i, x \\le 10^9\n1 \\le k \\le n\n\nExample\nInput:\n6 3\n8 6 4 5 7 5\n2 2\n1 5 1\n2 2\n\nOutput:\n5\n4\n",
        "sample1_input": "6,3,[8,6,4,5,7,5],[2,2],[1,5,1],[2,2]",
        "sample1_output": "5\n4\n",
        "sample2_input": "5,4,[5,7,3,9,2],[2,4],[1,2,8],[2,3],[2,5]",
        "sample2_output": "9\n7\n12\n",
        "sample3_input": "3,2,[1,1,1],[2,1],[1,2,9]",
        "sample3_output": "0\n1\n",
        "sample4_input": "4,3,[10,5,7,2],[2,1],[1,4,8],[2,3]",
        "sample4_output": "10\n7\n",
        "sample5_input": "7,4,[3,6,9,4,2,5,8],[2,6],[1,1,5],[2,7],[2,3]",
        "sample5_output": "17\n8\n12\n",
        "task_id": 85,
        "code": "def main(n, q, pizza_prices, queries):\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            k, x = query[1], query[2]\n            pizza_prices[k - 1] = x\n        else:\n            k = query[1]\n            min_price = pizza_prices[k - 1] + min(abs(k - i - 1) for i in range(n))\n            result.append(min_price)\n    return result",
        "test_list": [
            "assert main(6,3,[8,6,4,5,7,5],[2,2],[1,5,1],[2,2]) == 5\n4\n",
            "assert main(5,4,[5,7,3,9,2],[2,4],[1,2,8],[2,3],[2,5]) == 9\n7\n12\n",
            "assert main(3,2,[1,1,1],[2,1],[1,2,9]) == 0\n1\n",
            "assert main(4,3,[10,5,7,2],[2,1],[1,4,8],[2,3]) == 10\n7\n",
            "assert main(7,4,[3,6,9,4,2,5,8],[2,6],[1,1,5],[2,7],[2,3]) == 17\n8\n12\n"
        ]
    },
    {
        "link": "/problemset/task/1190",
        "title": "Subarray Sum Queries",
        "content": "There is an array consisting of n integers. Some values of the array will be updated, and after each update, your task is to report the maximum subarray sum in the array. \nInput\nThe first input line contains integers n and m: the size of the array and the number of updates. The array is indexed 1,2,\\ldots,n.\nThe next line has n integers: x_1,x_2,\\ldots,x_n: the initial contents of the array.\nThen there are m lines describing the changes. Each line has two integers k and x: the value at position k becomes x.\nOutput\nAfter each update, print the maximum subarray sum. Empty subarrays (with sum 0) are allowed.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n-10^9 \\le x_i \\le 10^9\n1 \\le k \\le n\n-10^9 \\le x \\le 10^9\n\nExample\nInput:\n5 3\n1 2 -3 5 -1\n2 6\n3 1\n2 -2\n\nOutput:\n9\n13\n6\n",
        "sample1_input": "5,3,[1,2,-3,5,-1],[2,6],[3,1],[2,-2]",
        "sample1_output": "9\n13\n6\n",
        "sample2_input": "7,4,[-2,3,4,-1,2,5,7],[2,6],[3,1],[7,-2],[4,9]",
        "sample2_output": "10\n12\n18\n",
        "sample3_input": "3,2,[-5,8,-6],[1,10],[2,3]",
        "sample3_output": "10\n14\n",
        "sample4_input": "4,3,[10,-2,5,-7],[2,-5],[3,6],[1,9]",
        "sample4_output": "13\n14\n19\n",
        "sample5_input": "6,4,[1,2,3,4,5,6],[4,8],[5,-1],[6,0],[3,9]",
        "sample5_output": "24\n23\n22\n",
        "task_id": 86,
        "code": "def main(n, m, arr, updates):\n    result = []\n    prefix_sum = [0] * (n + 1)\n    max_subarray_sum = 0\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    for k, x in updates:\n        arr[k - 1] = x\n        max_subarray_sum = 0\n        current_sum = 0\n        for i in range(n):\n            current_sum = max(arr[i], current_sum + arr[i])\n            max_subarray_sum = max(max_subarray_sum, current_sum)\n        result.append(max_subarray_sum)\n    return result",
        "test_list": [
            "assert main(5,3,[1,2,-3,5,-1],[2,6],[3,1],[2,-2]) == 9\n13\n6\n",
            "assert main(7,4,[-2,3,4,-1,2,5,7],[2,6],[3,1],[7,-2],[4,9]) == 10\n12\n18\n",
            "assert main(3,2,[-5,8,-6],[1,10],[2,3]) == 10\n14\n",
            "assert main(4,3,[10,-2,5,-7],[2,-5],[3,6],[1,9]) == 13\n14\n19\n",
            "assert main(6,4,[1,2,3,4,5,6],[4,8],[5,-1],[6,0],[3,9]) == 24\n23\n22\n"
        ]
    },
    {
        "link": "/problemset/task/1734",
        "title": "Distinct Values Queries",
        "content": "You are given an array of n integers and q queries of the form: how many distinct values are there in a range [a,b]?\nInput\nThe first input line has two integers n and q: the array size and number of queries.\nThe next line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has two integers a and b.\nOutput\nFor each query, print the number of distinct values in the range.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n5 3\n3 2 3 1 2\n1 3\n2 4\n1 5\n\nOutput:\n2\n3\n3\n",
        "sample1_input": "5,3,[3,2,3,1,2],[1,3],[2,4],[1,5]",
        "sample1_output": "2\n3\n3\n",
        "sample2_input": "6,4,[1,2,3,4,5,6],[2,4],[1,6],[3,6],[4,5]",
        "sample2_output": "3\n6\n4\n2\n",
        "sample3_input": "3,2,[1,1,1],[1,3],[2,2]",
        "sample3_output": "1\n1\n",
        "sample4_input": "4,3,[1,2,1,2],[1,4],[2,4],[1,2]",
        "sample4_output": "3\n3\n2\n",
        "sample5_input": "7,4,[5,4,3,5,2,5,6],[2,6],[1,7],[3,7],[4,5]",
        "sample5_output": "5\n7\n5\n4\n",
        "task_id": 87,
        "code": "def main(n, q, arr, queries):\n    result = []\n    distinct_counts = {}\n    for i in range(n):\n        distinct_counts[arr[i]] = distinct_counts.get(arr[i], 0) + 1\n    for a, b in queries:\n        distinct_values = set(arr[a - 1:b])\n        count = 0\n        for val in distinct_values:\n            count += distinct_counts[val]\n        result.append(count)\n    return result",
        "test_list": [
            "assert main(5,3,[3,2,3,1,2],[1,3],[2,4],[1,5]) == 2\n3\n3\n",
            "assert main(6,4,[1,2,3,4,5,6],[2,4],[1,6],[3,6],[4,5]) == 3\n6\n4\n2\n",
            "assert main(3,2,[1,1,1],[1,3],[2,2]) == 1\n1\n",
            "assert main(4,3,[1,2,1,2],[1,4],[2,4],[1,2]) == 3\n3\n2\n",
            "assert main(7,4,[5,4,3,5,2,5,6],[2,6],[1,7],[3,7],[4,5]) == 5\n7\n5\n4\n"
        ]
    },
    {
        "link": "/problemset/task/2416",
        "title": "Increasing Array Queries",
        "content": "You are given an array that consists of n integers. The array elements are indexed 1,2,\\dots,n.\nYou can modify the array using the following operation: choose an array element and increase its value by one.\nYour task is to process q queries of the form: when we consider a subarray from position a to position b, what is the minimum number of operations after which the subarray is increasing?\nAn array is increasing if each element is greater than or equal with the previous element.\nInput\nThe first input line has two integers n and q: the size of the array and the number of queries.\nThe next line has n integers x_1,x_2,\\dots,x_n: the contents of the array.\nFinally, there are q lines that describe the queries. Each line has two integers a and b: the starting and ending position of a subarray.\nOutput\nFor each query, print the minimum number of operations.\nConstraints\n\n1 \\le n,q \\le 2\\cdot10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n5 3\n2 10 4 2 5\n3 5\n2 2\n1 4\n\nOutput:\n2\n0\n14\n",
        "sample1_input": "5,3,[2,10,4,2,5],[3,5],[2,2],[1,4]",
        "sample1_output": "2\n0\n14\n",
        "sample2_input": "7,4,[5,4,3,5,2,5,6],[2,6],[1,7],[3,7],[4,5]",
        "sample2_output": "2\n3\n4\n1\n",
        "sample3_input": "3,2,[1,2,3],[1,2],[2,3]",
        "sample3_output": "0\n0\n",
        "sample4_input": "4,3,[5,5,5,5],[1,4],[2,4],[1,2]",
        "sample4_output": "15\n10\n0\n",
        "sample5_input": "6,4,[6,6,6,6,6,6],[1,6],[2,5],[1,3],[3,4]",
        "sample5_output": "0\n0\n3\n0\n",
        "task_id": 88,
        "code": "def main(n, q, arr, queries):\n    result = []\n    prefix_ops = [0] * n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            prefix_ops[i] = prefix_ops[i - 1]\n        else:\n            prefix_ops[i] = prefix_ops[i - 1] + 1\n    for a, b in queries:\n        ops_needed = prefix_ops[b - 1] - prefix_ops[a - 1]\n        result.append(ops_needed)\n    return result",
        "test_list": [
            "assert main(5,3,[2,10,4,2,5],[3,5],[2,2],[1,4]) == 2\n0\n14\n",
            "assert main(7,4,[5,4,3,5,2,5,6],[2,6],[1,7],[3,7],[4,5]) == 2\n3\n4\n1\n",
            "assert main(3,2,[1,2,3],[1,2],[2,3]) == 0\n0\n",
            "assert main(4,3,[5,5,5,5],[1,4],[2,4],[1,2]) == 15\n10\n0\n",
            "assert main(6,4,[6,6,6,6,6,6],[1,6],[2,5],[1,3],[3,4]) == 0\n0\n3\n0\n"
        ]
    },
    {
        "link": "/problemset/task/1739",
        "title": "Forest Queries II",
        "content": "You are given an n \\times n grid representing the map of a forest. Each square is either empty or has a tree. Your task is to process q queries of the following types:\n\nChange the state (empty/tree) of a square.\nHow many trees are inside a rectangle in the forest?\n\nInput\nThe first input line has two integers n and q: the size of the forest and the number of queries.\nThen, there are n lines describing the forest. Each line has n characters: . is an empty square and * is a tree.\nFinally, there are q lines describing the queries. The format of each line is either \"1 y x\" or \"2 y_1 x_1 y_2 x_2\".\nOutput\nPrint the answer to each query of the second type.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le q \\le 2 \\cdot 10^5\n1 \\le y,x \\le n\n1 \\le y_1 \\le y_2 \\le n\n1 \\le x_1 \\le x_2 \\le n\n\nExample\nInput:\n4 3\n.*..\n*.**\n**..\n****\n2 2 2 3 4\n1 3 3\n2 2 2 3 4\n\nOutput:\n3\n4\n",
        "sample1_input": "4 3\n.*..\n*.**\n**..\n****\n2 2 2 3 4\n1 3 3\n2 2 2 3 4\n",
        "sample1_output": "3\n4\n",
        "sample2_input": "5 2\n***..\n..*..\n.*...\n...*.\n...*.\n1 1\n2 1 1 5 5\n",
        "sample2_output": "14\n4\n",
        "sample3_input": "3 3\n.*.\n*..\n*.*\n2 2 2 2 3\n2 1 1 2 2\n1 1 2\n",
        "sample3_output": "2\n1\n",
        "sample4_input": "2 2\n**\n.*\n1 1\n2 1 1 2 2\n",
        "sample4_output": "1\n2\n",
        "sample5_input": "6 3\n..***.\n*..*..\n.*..*.\n....*.\n.*...*\n*.*.*.\n2 2 2 4 4\n1 6 3\n2 2 2 4 4\n",
        "sample5_output": "7\n5\n3\n",
        "task_id": 89,
        "code": "def main(n, q, forest, queries):\n    result = []\n    tree_count = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(n):\n            tree_count[i + 1][j + 1] = tree_count[i][j + 1] + tree_count[i + 1][j] - tree_count[i][j]\n            if forest[i][j] == '*':\n                tree_count[i + 1][j + 1] += 1\n    for query in queries:\n        if query[0] == 1:\n            y, x = query[1], query[2]\n            if forest[y - 1][x - 1] == '*':\n                tree_count[y][x] -= 1\n                forest[y - 1] = forest[y - 1][:x - 1] + '.' + forest[y - 1][x:]\n            else:\n                tree_count[y][x] += 1\n                forest[y - 1] = forest[y - 1][:x - 1] + '*' + forest[y - 1][x:]\n        else:\n            y1, x1, y2, x2 = query[1], query[2], query[3], query[4]\n            count = tree_count[y2][x2] - tree_count[y1 - 1][x2] - tree_count[y2][x1 - 1] + tree_count[y1 - 1][x1 - 1]\n            result.append(count)\n    return result",
        "test_list": [
            "assert main(4 3\n.*..\n*.**\n**..\n****\n2 2 2 3 4\n1 3 3\n2 2 2 3 4\n) == 3\n4\n",
            "assert main(5 2\n***..\n..*..\n.*...\n...*.\n...*.\n1 1\n2 1 1 5 5\n) == 14\n4\n",
            "assert main(3 3\n.*.\n*..\n*.*\n2 2 2 2 3\n2 1 1 2 2\n1 1 2\n) == 2\n1\n",
            "assert main(2 2\n**\n.*\n1 1\n2 1 1 2 2\n) == 1\n2\n",
            "assert main(6 3\n..***.\n*..*..\n.*..*.\n....*.\n.*...*\n*.*.*.\n2 2 2 4 4\n1 6 3\n2 2 2 4 4\n) == 7\n5\n3\n"
        ]
    },
    {
        "link": "/problemset/task/1735",
        "title": "Range Updates and Sums",
        "content": "Your task is to maintain an array of n values and efficiently process the following types of queries:\n\nIncrease each value in range [a,b] by x.\nSet each value in range [a,b] to x.\nCalculate the sum of values in range [a,b].\n\nInput\nThe first input line has two integers n and q: the array size and the number of queries.\nThe next line has n values t_1,t_2,\\dots,t_n: the initial contents of the array.\nFinally, there are q lines describing the queries. The format of each line is one of the following: \"1 a b x\",  \"2 a b x\", or \"3 a b\". \nOutput\nPrint the answer to each sum query.\nConstraints\n\n1 \\le n, q \\le 2 \\cdot 10^5\n1 \\le t_i, x \\le 10^6\n1 \\le a \\le b \\le n\n\nExample\nInput:\n6 5\n2 3 1 1 5 3\n3 3 5\n1 2 4 2\n3 3 5\n2 2 4 5\n3 3 5\n\nOutput:\n7\n11\n15\n",
        "sample1_input": "6,5,[2,3,1,1,5,3],[3,3,5],[1,2,4,2],[3,3,5],[2,2,4,5],[3,3,5]",
        "sample1_output": "7\n11\n15\n",
        "sample2_input": "4,4,[1,2,3,4],[3,1,4],[1,2,4,1],[3,1,4],[2,1,4,5]",
        "sample2_output": "10\n11\n",
        "sample3_input": "5,3,[3,3,3,3,3],[1,1,5,1],[3,1,5],[2,2,4,2]",
        "sample3_output": "15\n9\n",
        "sample4_input": "7,5,[1,2,3,4,5,6,7],[2,1,7,1],[3,1,7],[1,2,4,2],[3,1,7],[2,3,6,5]",
        "sample4_output": "28\n16\n",
        "sample5_input": "8,6,[1,1,1,1,1,1,1,1],[1,1,3,1],[2,2,6,3],[3,1,8],[1,4,6,2],[3,4,7],[2,3,5,4]",
        "sample5_output": "4\n10\n11\n",
        "task_id": 90,
        "code": "def main(n, q, arr, queries):\n    result = []\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    for query in queries:\n        if query[0] == 1:\n            a, b, x = query[1], query[2], query[3]\n            arr[a - 1] += x\n            arr[b] -= x\n        elif query[0] == 2:\n            a, b, x = query[1], query[2], query[3]\n            arr[a - 1] = x\n            arr[b] -= x\n        else:\n            a, b = query[1], query[2]\n            result.append(prefix_sum[b] - prefix_sum[a - 1])\n    return result",
        "test_list": [
            "assert main(6,5,[2,3,1,1,5,3],[3,3,5],[1,2,4,2],[3,3,5],[2,2,4,5],[3,3,5]) == 7\n11\n15\n",
            "assert main(4,4,[1,2,3,4],[3,1,4],[1,2,4,1],[3,1,4],[2,1,4,5]) == 10\n11\n",
            "assert main(5,3,[3,3,3,3,3],[1,1,5,1],[3,1,5],[2,2,4,2]) == 15\n9\n",
            "assert main(7,5,[1,2,3,4,5,6,7],[2,1,7,1],[3,1,7],[1,2,4,2],[3,1,7],[2,3,6,5]) == 28\n16\n",
            "assert main(8,6,[1,1,1,1,1,1,1,1],[1,1,3,1],[2,2,6,3],[3,1,8],[1,4,6,2],[3,4,7],[2,3,5,4]) == 4\n10\n11\n"
        ]
    },
    {
        "link": "/problemset/task/1736",
        "title": "Polynomial Queries",
        "content": "Your task is to maintain an array of n values and efficiently process the following types of queries:\n\nIncrease the first value in range [a,b] by 1, the second value by 2, the third value by 3, and so on.\nCalculate the sum of values in range [a,b].\n\nInput\nThe first input line has two integers n and q: the size of the array and the number of queries.\nThe next line has n values t_1,t_2,\\dots,t_n: the initial contents of the array.\nFinally, there are q lines describing the queries. The format of each line is either \"1 a b\" or \"2 a b\".\nOutput\nPrint the answer to each sum query.\nConstraints\n\n1 \\le n, q \\le 2 \\cdot 10^5\n1 \\le t_i \\le 10^6\n1 \\le a \\le b \\le n\n\nExample\nInput:\n5 3\n4 2 3 1 7\n2 1 5\n1 1 5\n2 1 5\n\nOutput:\n17\n32\n",
        "sample1_input": "5,3,[4,2,3,1,7],[2,1,5],[1,1,5],[2,1,5]",
        "sample1_output": "17\n32\n",
        "sample2_input": "4,4,[1,2,3,4],[2,1,4],[1,1,4],[2,1,4],[1,2,4]",
        "sample2_output": "20\n28\n33\n",
        "sample3_input": "3,3,[3,3,3],[1,1,3],[2,1,2],[1,2,3]",
        "sample3_output": "18\n6\n12\n",
        "sample4_input": "6,5,[1,2,3,4,5,6],[1,1,6],[2,1,4],[1,2,5],[2,2,3],[1,4,6]",
        "sample4_output": "56\n20\n34\n15\n15\n",
        "sample5_input": "7,6,[7,6,5,4,3,2,1],[2,1,7],[1,1,7],[2,1,7],[1,1,5],[2,3,5],[1,2,6]",
        "sample5_output": "28\n28\n28\n15\n12\n27\n",
        "task_id": 91,
        "code": "def main(n, q, arr, queries):\n    result = []\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + (i + 1) * arr[i]\n    for query in queries:\n        if query[0] == 1:\n            a, b = query[1], query[2]\n            result.append(prefix_sum[b] - prefix_sum[a - 1])\n        else:\n            a, b = query[1], query[2]\n            result.append(prefix_sum[b] - prefix_sum[a - 1])\n    return result",
        "test_list": [
            "assert main(5,3,[4,2,3,1,7],[2,1,5],[1,1,5],[2,1,5]) == 17\n32\n",
            "assert main(4,4,[1,2,3,4],[2,1,4],[1,1,4],[2,1,4],[1,2,4]) == 20\n28\n33\n",
            "assert main(3,3,[3,3,3],[1,1,3],[2,1,2],[1,2,3]) == 18\n6\n12\n",
            "assert main(6,5,[1,2,3,4,5,6],[1,1,6],[2,1,4],[1,2,5],[2,2,3],[1,4,6]) == 56\n20\n34\n15\n15\n",
            "assert main(7,6,[7,6,5,4,3,2,1],[2,1,7],[1,1,7],[2,1,7],[1,1,5],[2,3,5],[1,2,6]) == 28\n28\n28\n15\n12\n27\n"
        ]
    },
    {
        "link": "/problemset/task/1737",
        "title": "Range Queries and Copies",
        "content": "Your task is to maintain a list of arrays which initially has a single array. You have to process the following types of queries:\n\nSet the value a in array k to x.\nCalculate the sum of values in range [a,b] in array k.\nCreate a copy of array k and add it to the end of the list.\n\nInput\nThe first input line has two integers n and q: the array size and the number of queries.\nThe next line has n integers t_1,t_2,\\ldots,t_n: the initial contents of the array.\nFinally, there are q lines describing the queries. The format of each line is one of the following: \"1 k a x\", \"2 k a b\" or \"3 k\".\nOutput\nPrint the answer to each sum query.\nConstraints\n\n1 \\le n, q \\le 2 \\cdot 10^5\n1 \\le t_i, x \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n5 6\n2 3 1 2 5\n3 1\n2 1 1 5\n2 2 1 5\n1 2 2 5\n2 1 1 5\n2 2 1 5\n\nOutput:\n13\n13\n13\n15\n",
        "sample1_input": "5,6,[2,3,1,2,5],[3,1],[2,1,1,5],[2,2,1,5],[1,2,2,5],[2,1,1,5],[2,2,1,5]",
        "sample1_output": "13\n13\n13\n15\n",
        "sample2_input": "4,5,[1,2,3,4],[3,1],[2,1,1,4],[1,1,2,5],[2,2,1,4],[2,1,1,4]",
        "sample2_output": "1\n10\n12\n",
        "sample3_input": "3,5,[3,3,3],[3,1],[1,1,3,4],[2,1,1,3],[3,2],[2,1,1,3]",
        "sample3_output": "9\n12\n15\n",
        "sample4_input": "6,6,[1,2,3,4,5,6],[1,2,1,5],[2,2,2,6],[1,1,3,1],[3,2],[2,1,1,4],[1,1,1,4]",
        "sample4_output": "14\n13\n",
        "sample5_input": "7,5,[7,6,5,4,3,2,1],[2,1,1,7],[1,1,7,1],[3,1],[2,1,1,7],[1,1,1,6]",
        "sample5_output": "28\n7\n30\n",
        "task_id": 92,
        "code": "def main(n, q, arr, queries):\n    result = []\n    arrays = [arr]\n    for query in queries:\n        if query[0] == 1:\n            k, a, x = query[1], query[2], query[3]\n            arrays[k - 1][a - 1] = x\n        elif query[0] == 2:\n            k, a, b = query[1], query[2], query[3]\n            sum_range = sum(arrays[k - 1][a - 1:b])\n            result.append(sum_range)\n        else:\n            k = query[1]\n            copy = list(arrays[k - 1])\n            arrays.append(copy)\n    return result",
        "test_list": [
            "assert main(5,6,[2,3,1,2,5],[3,1],[2,1,1,5],[2,2,1,5],[1,2,2,5],[2,1,1,5],[2,2,1,5]) == 13\n13\n13\n15\n",
            "assert main(4,5,[1,2,3,4],[3,1],[2,1,1,4],[1,1,2,5],[2,2,1,4],[2,1,1,4]) == 1\n10\n12\n",
            "assert main(3,5,[3,3,3],[3,1],[1,1,3,4],[2,1,1,3],[3,2],[2,1,1,3]) == 9\n12\n15\n",
            "assert main(6,6,[1,2,3,4,5,6],[1,2,1,5],[2,2,2,6],[1,1,3,1],[3,2],[2,1,1,4],[1,1,1,4]) == 14\n13\n",
            "assert main(7,5,[7,6,5,4,3,2,1],[2,1,1,7],[1,1,7,1],[3,1],[2,1,1,7],[1,1,1,6]) == 28\n7\n30\n"
        ]
    },
    {
        "link": "/problemset/task/1674",
        "title": "Subordinates",
        "content": "Given the structure of a company, your task is to calculate for each employee the number of their subordinates.\nInput\nThe first input line has an integer n: the number of employees. The employees are numbered 1,2,\\dots,n, and employee 1 is the general director of the company.\nAfter this, there are n-1 integers: for each employee 2,3,\\dots,n their direct boss in the company.\nOutput\nPrint n integers: for each employee 1,2,\\dots,n the number of their subordinates.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n5\n1 1 2 3\n\nOutput:\n4 1 1 0 0\n",
        "sample1_input": "5,[1,1,2,3]",
        "sample1_output": "4 1 1 0 0\n",
        "sample2_input": "6,[1,1,2,3,3]",
        "sample2_output": "5 1 2 0 0 0\n",
        "sample3_input": "4,[1,2,3]",
        "sample3_output": "3 1 1 0\n",
        "sample4_input": "8,[1,1,1,2,2,2,3]",
        "sample4_output": "6 3 3 0 0 0 0 0\n",
        "sample5_input": "7,[1,2,3,4,4,5]",
        "sample5_output": "6 4 2 1 0 0 0\n",
        "task_id": 93,
        "code": "def main(n, bosses):\n    subordinates = [0] * n\n    for i in range(1, n):\n        boss = bosses[i - 1]\n        subordinates[boss - 1] += 1\n    return subordinates",
        "test_list": [
            "assert main(5,[1,1,2,3]) == 4 1 1 0 0\n",
            "assert main(6,[1,1,2,3,3]) == 5 1 2 0 0 0\n",
            "assert main(4,[1,2,3]) == 3 1 1 0\n",
            "assert main(8,[1,1,1,2,2,2,3]) == 6 3 3 0 0 0 0 0\n",
            "assert main(7,[1,2,3,4,4,5]) == 6 4 2 1 0 0 0\n"
        ]
    },
    {
        "link": "/problemset/task/1139",
        "title": "Distinct Colors",
        "content": "You are given a rooted tree consisting of n nodes. The nodes are numbered 1,2,\\ldots,n, and node 1 is the root. Each node has a color.\nYour task is to determine for each node the number of distinct colors in the subtree of the node.\nInput\nThe first input line contains an integer n: the number of nodes. The nodes are numbered 1,2,\\ldots,n.\nThe next line consists of n integers c_1,c_2,\\ldots,c_n: the color of each node.\nThen there are n-1 lines describing the edges. Each line contains two integers a and b: there is an edge between nodes a and b.\nOutput\nPrint n integers: for each node 1,2,\\ldots,n, the number of distinct colors.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n1 \\le c_i \\le 10^9\n\nExample\nInput:\n5\n2 3 2 2 1\n1 2\n1 3\n3 4\n3 5\n\nOutput:\n3 1 2 1 1\n",
        "sample1_input": "5,[2,3,2,2,1],[1,2],[1,3],[3,4],[3,5]",
        "sample1_output": "3 1 2 1 1",
        "sample2_input": "3,[1,1,1],[1,2],[1,3]",
        "sample2_output": "1 1 1",
        "sample3_input": "4,[1,2,3,4],[1,2],[2,3],[3,4]",
        "sample3_output": "1 2 3 4",
        "sample4_input": "6,[1,1,1,2,2,2],[1,2],[2,3],[2,4],[3,5],[3,6]",
        "sample4_output": "2 1 2 1 1 1",
        "sample5_input": "7,[1,2,3,1,2,3,1],[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]",
        "sample5_output": "3 3 3 3 3 3 3",
        "task_id": 94,
        "code": "def main(n, colors, edges):\n    def dfs(node, parent):\n        color_count = dict()\n        for neighbor in edges[node]:\n            if neighbor != parent:\n                child_color_count = dfs(neighbor, node)\n                for color, count in child_color_count.items():\n                    color_count[color] = color_count.get(color, 0) + count\n        color_count[colors[node - 1]] = color_count.get(colors[node - 1], 0) + 1\n        result[node - 1] = len(color_count)\n        return color_count\n\n    result = [0] * n\n    edges = [[] for _ in range(n + 1)]\n\n    for a, b in edges:\n        edges[a].append(b)\n        edges[b].append(a)\n\n    dfs(1, 0)\n\n    return result",
        "test_list": [
            "assert main(5,[2,3,2,2,1],[1,2],[1,3],[3,4],[3,5]) == 3 1 2 1 1",
            "assert main(3,[1,1,1],[1,2],[1,3]) == 1 1 1",
            "assert main(4,[1,2,3,4],[1,2],[2,3],[3,4]) == 1 2 3 4",
            "assert main(6,[1,1,1,2,2,2],[1,2],[2,3],[2,4],[3,5],[3,6]) == 2 1 2 1 1 1",
            "assert main(7,[1,2,3,1,2,3,1],[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]) == 3 3 3 3 3 3 3"
        ]
    },
    {
        "link": "/problemset/task/2079",
        "title": "Finding a Centroid",
        "content": "Given a tree of n nodes, your task is to find a centroid, i.e., a node such that when it is appointed the root of the tree, each subtree has at most \\lfloor n/2 \\rfloor nodes.\nInput\nThe first input line contains an integer n: the number of nodes. The nodes are numbered 1,2,…,n.\nThen there are n-1 lines describing the edges. Each line contains two integers a and b: there is an edge between nodes a and b.\nOutput\nPrint one integer: a centroid node. If there are several possibilities, you can choose any of them.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5\n1 2\n2 3\n3 4\n3 5\n\nOutput:\n3\n",
        "sample1_input": "5,[1,2],[2,3],[3,4],[3,5]",
        "sample1_output": "3",
        "sample2_input": "3,[1,2],[2,3]",
        "sample2_output": "2",
        "sample3_input": "7,[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]",
        "sample3_output": "1",
        "sample4_input": "4,[1,2],[2,3],[2,4]",
        "sample4_output": "2",
        "sample5_input": "6,[1,2],[2,3],[2,4],[4,5],[5,6]",
        "sample5_output": "4",
        "task_id": 95,
        "code": "def main(n, edges):\n    def dfs(node, parent):\n        subtree_sizes[node] = 1\n        is_centroid = True\n        max_subtree_size = 0\n        for neighbor in edges[node]:\n            if neighbor != parent:\n                dfs(neighbor, node)\n                subtree_sizes[node] += subtree_sizes[neighbor]\n                max_subtree_size = max(max_subtree_size, subtree_sizes[neighbor])\n                if subtree_sizes[neighbor] > n // 2:\n                    is_centroid = False\n        if n - subtree_sizes[node] > n // 2:\n            is_centroid = False\n        if is_centroid:\n            centroids.append(node)\n\n    centroids = []\n    subtree_sizes = [0] * (n + 1)\n\n    dfs(1, 0)\n\n    return centroids[0]",
        "test_list": [
            "assert main(5,[1,2],[2,3],[3,4],[3,5]) == 3",
            "assert main(3,[1,2],[2,3]) == 2",
            "assert main(7,[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]) == 1",
            "assert main(4,[1,2],[2,3],[2,4]) == 2",
            "assert main(6,[1,2],[2,3],[2,4],[4,5],[5,6]) == 4"
        ]
    },
    {
        "link": "/problemset/task/2080",
        "title": "Fixed-Length Paths I",
        "content": "Given a tree of n nodes, your task is to count the number of distinct paths that consist of exactly k edges.\nInput\nThe first input line contains two integers n and k: the number of nodes and the path length. The nodes are numbered 1,2,\\ldots,n.\nThen there are n-1 lines describing the edges. Each line contains two integers a and b: there is an edge between nodes a and b.\nOutput\nPrint one integer: the number of paths.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 2\n1 2\n2 3\n3 4\n3 5\n\nOutput:\n4\n",
        "sample1_input": "5,2,[1,2],[2,3],[3,4],[3,5]",
        "sample1_output": "4",
        "sample2_input": "3,1,[1,2],[2,3]",
        "sample2_output": "2",
        "sample3_input": "4,3,[1,2],[2,3],[3,4]",
        "sample3_output": "0",
        "sample4_input": "6,4,[1,2],[2,3],[2,4],[4,5],[5,6]",
        "sample4_output": "0",
        "sample5_input": "7,2,[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]",
        "sample5_output": "14",
        "task_id": 96,
        "code": "def main(n, k, edges):\n    def dfs(node, parent, depth):\n        nonlocal path_count\n        depth_counts[depth] += 1\n        for neighbor in edges[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, depth + 1)\n        if depth >= k:\n            path_count += depth_counts[depth - k]\n        depth_counts[depth] -= 1\n\n    depth_counts = [0] * (n + 1)\n    path_count = 0\n\n    dfs(1, 0, 0)\n\n    return path_count",
        "test_list": [
            "assert main(5,2,[1,2],[2,3],[3,4],[3,5]) == 4",
            "assert main(3,1,[1,2],[2,3]) == 2",
            "assert main(4,3,[1,2],[2,3],[3,4]) == 0",
            "assert main(6,4,[1,2],[2,3],[2,4],[4,5],[5,6]) == 0",
            "assert main(7,2,[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]) == 14"
        ]
    },
    {
        "link": "/problemset/task/2081",
        "title": "Fixed-Length Paths II",
        "content": "Given a tree of n nodes, your task is to count the number of distinct paths that have at least k_1 and at most k_2 edges.\nInput\nThe first input line contains three integers n, k_1 and k_2: the number of nodes and the path lengths. The nodes are numbered 1,2,\\ldots,n.\nThen there are n-1 lines describing the edges. Each line contains two integers a and b: there is an edge between nodes a and b.\nOutput\nPrint one integer: the number of paths.\nConstraints\n\n1 \\le k_1 \\le k_2 \\le n \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 2 3\n1 2\n2 3\n3 4\n3 5\n\nOutput:\n6\n",
        "sample1_input": "5,2,3,[1,2],[2,3],[3,4],[3,5]",
        "sample1_output": "6",
        "sample2_input": "3,1,2,[1,2],[2,3]",
        "sample2_output": "5",
        "sample3_input": "4,2,2,[1,2],[2,3],[3,4]",
        "sample3_output": "0",
        "sample4_input": "6,1,3,[1,2],[2,3],[2,4],[4,5],[5,6]",
        "sample4_output": "7",
        "sample5_input": "7,1,4,[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]",
        "sample5_output": "10",
        "task_id": 97,
        "code": "def main(n, k1, k2, edges):\n    def dfs(node, parent, depth):\n        nonlocal path_count\n        if k1 <= depth <= k2:\n            path_count += 1\n        for neighbor in edges[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, depth + 1)\n\n    path_count = 0\n\n    dfs(1, 0, 0)\n\n    return path_count",
        "test_list": [
            "assert main(5,2,3,[1,2],[2,3],[3,4],[3,5]) == 6",
            "assert main(3,1,2,[1,2],[2,3]) == 5",
            "assert main(4,2,2,[1,2],[2,3],[3,4]) == 0",
            "assert main(6,1,3,[1,2],[2,3],[2,4],[4,5],[5,6]) == 7",
            "assert main(7,1,4,[1,2],[1,3],[2,4],[2,5],[3,6],[3,7]) == 10"
        ]
    },
    {
        "link": "/problemset/task/2164",
        "title": "Josephus Queries",
        "content": "Consider a game where there are n children (numbered 1,2,\\dots,n) in a circle. During the game, every second child is removed from the circle, until there are no children left.\nYour task is to process q queries of the form: \"when there are n children, who is the kth child that will be removed?\"\nInput\nThe first input line has an integer q: the number of queries.\nAfter this, there are q lines that describe the queries. Each line has two integers n and k: the number of children and the position of the child.\nOutput\nPrint q integers: the answer for each query.\nConstraints\n\n1 \\le q \\le 10^5\n1 \\le k \\le n \\le 10^9\n\nExample\nInput:\n4\n7 1\n7 3\n2 2\n1337 1313\n\nOutput:\n2\n6\n1\n1107\n",
        "sample1_input": "4,[7,1],[7,3],[2,2],[1337,1313]",
        "sample1_output": "2\n6\n1\n1107",
        "sample2_input": "3,[5,4],[10,7],[3,2]",
        "sample2_output": "4\n6\n2",
        "sample3_input": "2,[1,1],[3,3]",
        "sample3_output": "1\n3",
        "sample4_input": "5,[100,50],[13,7],[20,19],[25,24],[7,1]",
        "sample4_output": "50\n7\n19\n24\n1",
        "sample5_input": "1,[999999999,555555555]",
        "sample5_output": "555555555",
        "task_id": 98,
        "code": "def main(q, queries):\n    results = []\n    for n, k in queries:\n        result = ((k - 1) % n) + 1\n        results.append(result)\n    return results",
        "test_list": [
            "assert main(4,[7,1],[7,3],[2,2],[1337,1313]) == 2\n6\n1\n1107",
            "assert main(3,[5,4],[10,7],[3,2]) == 4\n6\n2",
            "assert main(2,[1,1],[3,3]) == 1\n3",
            "assert main(5,[100,50],[13,7],[20,19],[25,24],[7,1]) == 50\n7\n19\n24\n1",
            "assert main(1,[999999999,555555555]) == 555555555"
        ]
    },
    {
        "link": "/problemset/task/1095",
        "title": "Exponentiation",
        "content": "Your task is to efficiently calculate values a^b modulo 10^9+7.\nNote that in this task we assume that 0^0=1.\nInput\nThe first input line contains an integer n: the number of calculations.\nAfter this, there are n lines, each containing two integers a and b.\nOutput\nPrint each value a^b modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n0 \\le a,b \\le 10^9\n\nExample\nInput:\n3\n3 4\n2 8\n123 123\n\nOutput:\n81\n256\n921450052\n",
        "sample1_input": "3,[3,4],[2,8],[123,123]",
        "sample1_output": "81\n256\n921450052",
        "sample2_input": "2,[7,5],[5,7]",
        "sample2_output": "16807\n78125",
        "sample3_input": "1,[10,0]",
        "sample3_output": "1",
        "sample4_input": "4,[2,16],[3,27],[4,256],[5,1024]",
        "sample4_output": "65536\n7625597484987\n228767922050\n976371285",
        "sample5_input": "5,[2,3],[3,2],[4,1],[5,0],[6,10]",
        "sample5_output": "8\n9\n4\n1\n60466176",
        "task_id": 99,
        "code": "def main(n, queries):\n    MOD = 10**9 + 7\n    results = []\n    for a, b in queries:\n        result = pow(a, b, MOD)\n        results.append(result)\n    return results",
        "test_list": [
            "assert main(3,[3,4],[2,8],[123,123]) == 81\n256\n921450052",
            "assert main(2,[7,5],[5,7]) == 16807\n78125",
            "assert main(1,[10,0]) == 1",
            "assert main(4,[2,16],[3,27],[4,256],[5,1024]) == 65536\n7625597484987\n228767922050\n976371285",
            "assert main(5,[2,3],[3,2],[4,1],[5,0],[6,10]) == 8\n9\n4\n1\n60466176"
        ]
    },
    {
        "link": "/problemset/task/1712",
        "title": "Exponentiation II",
        "content": "Your task is to efficiently calculate values a^{b^c} modulo 10^9+7.\nNote that in this task we assume that 0^0=1.\nInput\nThe first input line has an integer n: the number of calculations.\nAfther this, there are n lines, each containing three integers a, b and c.\nOutput\nPrint each value a^{b^c} modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n0 \\le a,b,c \\le 10^9\n\nExample\nInput:\n3\n3 7 1\n15 2 2\n3 4 5\n\nOutput:\n2187\n50625\n763327764\n",
        "sample1_input": "3,[3,7,1],[15,2,2],[3,4,5]",
        "sample1_output": "2187\n50625\n763327764",
        "sample2_input": "2,[2,3,4],[5,1,10]",
        "sample2_output": "16\n5",
        "sample3_input": "1,[10,0,0]",
        "sample3_output": "1",
        "sample4_input": "4,[3,2,1],[4,3,2],[5,4,3],[6,5,4]",
        "sample4_output": "3\n64\n3969\n10460353203",
        "sample5_input": "5,[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]",
        "sample5_output": "951425207\n184755218\n127556072\n866989898\n491984693",
        "task_id": 100,
        "code": "def main(n, queries):\n    MOD = 10**9 + 7\n    results = []\n    for a, b, c in queries:\n        result = pow(a, pow(b, c, MOD), MOD)\n        results.append(result)\n    return results",
        "test_list": [
            "assert main(3,[3,7,1],[15,2,2],[3,4,5]) == 2187\n50625\n763327764",
            "assert main(2,[2,3,4],[5,1,10]) == 16\n5",
            "assert main(1,[10,0,0]) == 1",
            "assert main(4,[3,2,1],[4,3,2],[5,4,3],[6,5,4]) == 3\n64\n3969\n10460353203",
            "assert main(5,[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]) == 951425207\n184755218\n127556072\n866989898\n491984693"
        ]
    },
    {
        "link": "/problemset/task/1713",
        "title": "Counting Divisors",
        "content": "Given n integers, your task is to report for each integer the number of its divisors.\nFor example, if x=18, the correct answer is 6 because its divisors are 1,2,3,6,9,18.\nInput\nThe first input line has an integer n: the number of integers.\nAfter this, there are n lines, each containing an integer x.\nOutput\nFor each integer, print the number of its divisors.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le x \\le 10^6\n\nExample\nInput:\n3\n16\n17\n18\n\nOutput:\n5\n2\n6\n",
        "sample1_input": "3,[16],[17],[18]",
        "sample1_output": "5\n2\n6",
        "sample2_input": "2,[10],[28]",
        "sample2_output": "4\n6",
        "sample3_input": "1,[999999]",
        "sample3_output": "144",
        "sample4_input": "4,[7],[1],[6],[12]",
        "sample4_output": "2\n1\n4\n6",
        "sample5_input": "3,[5],[23],[31]",
        "sample5_output": "2\n2\n2",
        "task_id": 101,
        "code": "def main(n, integers):\n    def count_divisors(x):\n        divisors = 0\n        for i in range(1, int(x**0.5) + 1):\n            if x % i == 0:\n                if x // i == i:\n                    divisors += 1\n                else:\n                    divisors += 2\n        return divisors\n\n    results = []\n    for x in integers:\n        divisors = count_divisors(x)\n        results.append(divisors)\n    return results",
        "test_list": [
            "assert main(3,[16],[17],[18]) == 5\n2\n6",
            "assert main(2,[10],[28]) == 4\n6",
            "assert main(1,[999999]) == 144",
            "assert main(4,[7],[1],[6],[12]) == 2\n1\n4\n6",
            "assert main(3,[5],[23],[31]) == 2\n2\n2"
        ]
    },
    {
        "link": "/problemset/task/1081",
        "title": "Common Divisors",
        "content": "You are given an array of n positive integers. Your task is to find two integers such that their greatest common divisor is as large as possible.\nInput\nThe first input line has an integer n: the size of the array.\nThe second line has n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint the maximum greatest common divisor.\nConstraints\n\n2 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^6\n\nExample\nInput:\n5\n3 14 15 7 9\n\nOutput:\n7\n",
        "sample1_input": "5,[3,14,15,7,9]",
        "sample1_output": "7",
        "sample2_input": "4,[10,20,30,40]",
        "sample2_output": "10",
        "sample3_input": "3,[17,23,29]",
        "sample3_output": "1",
        "sample4_input": "2,[13,27]",
        "sample4_output": "1",
        "sample5_input": "6,[6,15,24,33,42,51]",
        "sample5_output": "3",
        "task_id": 102,
        "code": "from math import gcd\n\ndef main(n, arr):\n    max_gcd = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_gcd = max(max_gcd, gcd(arr[i], arr[j]))\n    return max_gcd",
        "test_list": [
            "assert main(5,[3,14,15,7,9]) == 7",
            "assert main(4,[10,20,30,40]) == 10",
            "assert main(3,[17,23,29]) == 1",
            "assert main(2,[13,27]) == 1",
            "assert main(6,[6,15,24,33,42,51]) == 3"
        ]
    },
    {
        "link": "/problemset/task/1082",
        "title": "Sum of Divisors",
        "content": "Let \\sigma(n) denote the sum of divisors of an integer n. For example, \\sigma(12)=1+2+3+4+6+12=28.\nYour task is to calculate the sum \\sum_{i=1}^n \\sigma(i) modulo 10^9+7.\nInput\nThe only input line has an integer n.\nOutput\nPrint \\sum_{i=1}^n \\sigma(i) modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^{12}\n\nExample\nInput:\n5\n\nOutput:\n21\n",
        "sample1_input": "5",
        "sample1_output": "21",
        "sample2_input": "10",
        "sample2_output": "87",
        "sample3_input": "1",
        "sample3_output": "1",
        "sample4_input": "3",
        "sample4_output": "10",
        "sample5_input": "15",
        "sample5_output": "520",
        "task_id": 103,
        "code": "def main(n):\n    mod = 10**9 + 7\n    result = 0\n    for i in range(1, n + 1):\n        div_sum = 0\n        for j in range(1, int(i**0.5) + 1):\n            if i % j == 0:\n                div_sum += j\n                if j != i // j:\n                    div_sum += i // j\n        result = (result + div_sum) % mod\n    return result",
        "test_list": [
            "assert main(5) == 21",
            "assert main(10) == 87",
            "assert main(1) == 1",
            "assert main(3) == 10",
            "assert main(15) == 520"
        ]
    },
    {
        "link": "/problemset/task/2182",
        "title": "Divisor Analysis",
        "content": "Given an integer, your task is to find the number, sum and product of its divisors. As an example, let us consider the number 12:\n\nthe number of divisors is 6 (they are 1, 2, 3, 4, 6, 12)\nthe sum of divisors is 1+2+3+4+6+12=28\nthe product of divisors is 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 6 \\cdot 12 = 1728\n\nSince the input number may be large, it is given as a prime factorization.\nInput\nThe first line has an integer n: the number of parts in the prime factorization.\nAfter this, there are n lines that describe the factorization. Each line has two numbers x and k where x is a prime and k is its power.\nOutput\nPrint three integers modulo 10^9+7: the number, sum and product of the divisors.\nConstraints\n\n1 \\le n \\le 10^5\n2 \\le x \\le 10^6\neach x is a distinct prime\n1 \\le k \\le 10^9\n\nExample\nInput:\n2\n2 2\n3 1\n\nOutput:\n6 28 1728\n",
        "sample1_input": "2,[2,2],[3,1]",
        "sample1_output": "6 28 1728",
        "sample2_input": "3,[5,2],[7,3],[11,1]",
        "sample2_output": "3888 215850 1836735360",
        "sample3_input": "1,[19,5]",
        "sample3_output": "1162261467 713288348 893353197",
        "sample4_input": "1,[29,7]",
        "sample4_output": "250822656 431866831 250606562",
        "sample5_input": "3,[17,4],[23,2],[31,3]",
        "sample5_output": "260144 40440 170625",
        "task_id": 104,
        "code": "def main(n, factors):\n    mod = 10**9 + 7\n    num = 1\n    div_sum = 1\n    div_product = 1\n    for x, k in factors:\n        num = (num * (x**k + 1)) % mod\n        div_sum = (div_sum * (x**(k + 1) - 1) * pow(x - 1, -1, mod)) % mod\n        div_product = (div_product * pow(x, k * (k + 1) // 2, mod)) % mod\n    return (num, div_sum, div_product)",
        "test_list": [
            "assert main(2,[2,2],[3,1]) == 6 28 1728",
            "assert main(3,[5,2],[7,3],[11,1]) == 3888 215850 1836735360",
            "assert main(1,[19,5]) == 1162261467 713288348 893353197",
            "assert main(1,[29,7]) == 250822656 431866831 250606562",
            "assert main(3,[17,4],[23,2],[31,3]) == 260144 40440 170625"
        ]
    },
    {
        "link": "/problemset/task/2185",
        "title": "Prime Multiples",
        "content": "You are given k distinct prime numbers a_1,a_2,\\ldots,a_k and an integer n.\nYour task is to calculate how many of the first n positive integers are divisible by at least one of the given prime numbers.\nInput\nThe first input line has two integers n and k.\nThe second line has k prime numbers a_1,a_2,\\ldots,a_k.\nOutput\nPrint one integer: the number integers within the interval 1,2,\\ldots,n that are divisible by at least one of the prime numbers.\nConstraints\n\n1 \\le n \\le 10^{18}\n1 \\le k \\le 20\n2 \\le a_i \\le n\n\nExample\nInput:\n20 2\n2 5\n\nOutput:\n12\n\nExplanation: the 12 numbers are 2,4,5,6,8,10,12,14,15,16,18,20.\n",
        "sample1_input": "20,2,[2,5]",
        "sample1_output": "12",
        "sample2_input": "10,3,[2,3,5]",
        "sample2_output": "7",
        "sample3_input": "15,1,[7]",
        "sample3_output": "2",
        "sample4_input": "1000000000000000000,5,[2,3,5,7,11]",
        "sample4_output": "81818181818181815",
        "sample5_input": "30,4,[2,3,5,7]",
        "sample5_output": "25",
        "task_id": 105,
        "code": "def main(n, k, primes):\n    lcm = 1\n    for prime in primes:\n        lcm *= prime\n\n    result = n // lcm\n\n    for i in range(1, k + 1):\n        combinations = itertools.combinations(primes, i)\n        for combo in combinations:\n            lcm_combo = 1\n            for prime in combo:\n                lcm_combo *= prime\n            if i % 2 == 1:\n                result -= n // lcm_combo\n            else:\n                result += n // lcm_combo\n\n    return result",
        "test_list": [
            "assert main(20,2,[2,5]) == 12",
            "assert main(10,3,[2,3,5]) == 7",
            "assert main(15,1,[7]) == 2",
            "assert main(1000000000000000000,5,[2,3,5,7,11]) == 81818181818181815",
            "assert main(30,4,[2,3,5,7]) == 25"
        ]
    },
    {
        "link": "/problemset/task/2417",
        "title": "Counting Coprime Pairs",
        "content": "Given a list of n positive integers, your task is to count the number of pairs of integers that are coprime (i.e., their greatest common divisor is one).\nInput\nThe first input line has an integer n: the number of elements.\nThe next line has n integers x_1,x_2,\\dots,x_n: the contents of the list.\nOutput\nPrint one integer: the answer for the task.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le x_i \\le 10^6\n\nExample\nInput:\n8\n5 4 20 1 16 17 5 15\n\nOutput:\n19\n",
        "sample1_input": "8,[5,4,20,1,16,17,5,15]",
        "sample1_output": "19",
        "sample2_input": "5,[1,1,1,1,1]",
        "sample2_output": "0",
        "sample3_input": "10,[2,3,5,7,11,13,17,19,23,29]",
        "sample3_output": "45",
        "sample4_input": "7,[10,20,30,40,50,60,70]",
        "sample4_output": "0",
        "sample5_input": "6,[1,2,3,4,5,6]",
        "sample5_output": "5",
        "task_id": 106,
        "code": "def main(n, arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    coprime_pairs = 0\n    frequency = [0] * (max(arr) + 1)\n\n    for num in arr:\n        frequency[num] += 1\n\n    for i in range(1, len(frequency)):\n        for j in range(i * 2, len(frequency), i):\n            frequency[i] += frequency[j]\n\n    for num in arr:\n        coprime_pairs += n - frequency[num]  # Pairs with gcd > 1\n\n    return coprime_pairs // 2",
        "test_list": [
            "assert main(8,[5,4,20,1,16,17,5,15]) == 19",
            "assert main(5,[1,1,1,1,1]) == 0",
            "assert main(10,[2,3,5,7,11,13,17,19,23,29]) == 45",
            "assert main(7,[10,20,30,40,50,60,70]) == 0",
            "assert main(6,[1,2,3,4,5,6]) == 5"
        ]
    },
    {
        "link": "/problemset/task/1079",
        "title": "Binomial Coefficients",
        "content": "Your task is to calculate n binomial coefficients modulo 10^9+7.\nA binomial coefficient {a \\choose b} can be calculated using the formula \\frac{a!}{b!(a-b)!}. We assume that a and b are integers and 0 \\le b \\le a.\nInput\nThe first input line contains an integer n: the number of calculations.\nAfter this, there are n lines, each of which contains two integers a and b.\nOutput\nPrint each binomial coefficient modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n0 \\le b \\le a \\le 10^6\n\nExample\nInput:\n3\n5 3\n8 1\n9 5\n\nOutput:\n10\n8\n126\n",
        "sample1_input": "3,[5,3],[8,1],[9,5]",
        "sample1_output": "10\n8\n126",
        "sample2_input": "2,[4,2],[7,3]",
        "sample2_output": "6\n35",
        "sample3_input": "1,[10,5]",
        "sample3_output": "252",
        "sample4_input": "4,[6,0],[10,0],[15,1],[20,10]",
        "sample4_output": "1\n1\n15\n184\n",
        "sample5_input": "3,[3,1],[4,2],[6,3]",
        "sample5_output": "3\n6\n20",
        "task_id": 107,
        "code": "import math\n\nMOD = 10**9 + 7\n\ndef main(n, coefficients):\n    def binomial_coefficient(a, b):\n        return (math.factorial(a) // (math.factorial(b) * math.factorial(a - b))) % MOD\n\n    result = []\n    for a, b in coefficients:\n        result.append(binomial_coefficient(a, b))\n\n    return result",
        "test_list": [
            "assert main(3,[5,3],[8,1],[9,5]) == 10\n8\n126",
            "assert main(2,[4,2],[7,3]) == 6\n35",
            "assert main(1,[10,5]) == 252",
            "assert main(4,[6,0],[10,0],[15,1],[20,10]) == 1\n1\n15\n184\n",
            "assert main(3,[3,1],[4,2],[6,3]) == 3\n6\n20"
        ]
    },
    {
        "link": "/problemset/task/1715",
        "title": "Creating Strings II",
        "content": "Given a string, your task is to calculate the number of different strings that can be created using its characters.\nInput\nThe only input line has a string of length n. Each character is between a–z.\nOutput\nPrint the number of different strings modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\naabac\n\nOutput:\n20\n",
        "sample1_input": "aabac",
        "sample1_output": "20",
        "sample2_input": "abc",
        "sample2_output": "6",
        "sample3_input": "aaaaaa",
        "sample3_output": "1",
        "sample4_input": "abcdabcd",
        "sample4_output": "576",
        "sample5_input": "abcdefgh",
        "sample5_output": "40320",
        "task_id": 108,
        "code": "MOD = 10**9 + 7\n\ndef main(s):\n    unique_characters = set(s)\n    num_unique_characters = len(unique_characters)\n\n    # Calculate the number of ways to arrange the unique characters\n    arrangements = 1\n    for i in range(1, num_unique_characters + 1):\n        arrangements = (arrangements * i) % MOD\n\n    # Calculate the total number of different strings\n    total_strings = pow(arrangements, len(s), MOD)\n\n    return total_strings",
        "test_list": [
            "assert main(aabac) == 20",
            "assert main(abc) == 6",
            "assert main(aaaaaa) == 1",
            "assert main(abcdabcd) == 576",
            "assert main(abcdefgh) == 40320"
        ]
    },
    {
        "link": "/problemset/task/1716",
        "title": "Distributing Apples",
        "content": "There are n children and m apples that will be distributed to them. Your task is to count the number of ways this can be done.\nFor example, if n=3 and m=2, there are 6 ways: [0,0,2], [0,1,1], [0,2,0], [1,0,1], [1,1,0] and [2,0,0].\nInput\nThe only input line has two integers n and m.\nOutput\nPrint the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n,m \\le 10^6\n\nExample\nInput:\n3 2\n\nOutput:\n6\n",
        "sample1_input": "3,2",
        "sample1_output": "6",
        "sample2_input": "4,3",
        "sample2_output": "10",
        "sample3_input": "2,5",
        "sample3_output": "2",
        "sample4_input": "5,1",
        "sample4_output": "1",
        "sample5_input": "6,6",
        "sample5_output": "64",
        "task_id": 109,
        "code": "MOD = 10**9 + 7\n\ndef main(n, m):\n    def count_ways(n, m):\n        if n == 0:\n            return 1\n        if m == 0:\n            return 0\n\n        # Calculate the number of ways using dynamic programming\n        ways = [0] * (n + 1)\n        ways[0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, min(m, i) + 1):\n                ways[i] = (ways[i] + ways[i - j]) % MOD\n\n        return ways[n]\n\n    return count_ways(n, m)",
        "test_list": [
            "assert main(3,2) == 6",
            "assert main(4,3) == 10",
            "assert main(2,5) == 2",
            "assert main(5,1) == 1",
            "assert main(6,6) == 64"
        ]
    },
    {
        "link": "/problemset/task/1717",
        "title": "Christmas Party",
        "content": "There are n children at a Christmas party, and each of them has brought a gift. The idea is that everybody will get a gift brought by someone else.\nIn how many ways can the gifts be distributed?\nInput\nThe only input line has an integer n: the number of children.\nOutput\nPrint the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n4\n\nOutput:\n9\n",
        "sample1_input": "4",
        "sample1_output": "9",
        "sample2_input": "5",
        "sample2_output": "44",
        "sample3_input": "3",
        "sample3_output": "2",
        "sample4_input": "1",
        "sample4_output": "0",
        "sample5_input": "10",
        "sample5_output": "115920",
        "task_id": 110,
        "code": "MOD = 10**9 + 7\n\ndef main(n):\n    def count_ways(n):\n        if n == 1:\n            return 0\n\n        # Calculate the number of ways using dynamic programming\n        dp = [0] * (n + 1)\n        dp[2] = 1\n\n        for i in range(3, n + 1):\n            dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n\n        return dp[n]\n\n    return count_ways(n)",
        "test_list": [
            "assert main(4) == 9",
            "assert main(5) == 44",
            "assert main(3) == 2",
            "assert main(1) == 0",
            "assert main(10) == 115920"
        ]
    },
    {
        "link": "/problemset/task/2064",
        "title": "Bracket Sequences I",
        "content": "Your task is to calculate the number of valid bracket sequences of length n. For example, when n=6, there are 5 sequences:\n\n()()()\n()(())\n(())()\n((()))\n(()())\n\nInput\nThe only input line has an integer n.\nOutput\nPrint the number of sequences modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n6\n\nOutput:\n5\n",
        "sample1_input": "6",
        "sample1_output": "5",
        "sample2_input": "4",
        "sample2_output": "2",
        "sample3_input": "8",
        "sample3_output": "14",
        "sample4_input": "10",
        "sample4_output": "42",
        "sample5_input": "5",
        "sample5_output": "0",
        "task_id": 111,
        "code": "MOD = 10**9 + 7\n\ndef main(n):\n    def count_valid_sequences(n):\n        if n % 2 == 1:\n            return 0  # No valid sequences for odd n\n\n        # Calculate the number of valid sequences using dynamic programming\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(2, n + 1, 2):\n            for j in range(2, i + 1, 2):\n                dp[i] = (dp[i] + dp[j - 2] * dp[i - j]) % MOD\n\n        return dp[n]\n\n    return count_valid_sequences(n)",
        "test_list": [
            "assert main(6) == 5",
            "assert main(4) == 2",
            "assert main(8) == 14",
            "assert main(10) == 42",
            "assert main(5) == 0"
        ]
    },
    {
        "link": "/problemset/task/2187",
        "title": "Bracket Sequences II",
        "content": "Your task is to calculate the number of valid bracket sequences of length n when a prefix of the sequence is given.\nInput\nThe first input line has an integer n.\nThe second line has a string of k characters: the prefix of the sequence.\nOutput\nPrint the number of sequences modulo 10^9+7.\nConstraints\n\n1 \\le k \\le n \\le 10^6\n\nExample\nInput:\n6\n(()\n\nOutput:\n2\n\nExplanation: There are two possible sequences: (())() and (()()).\n",
        "sample1_input": "6,\"(())\"",
        "sample1_output": "2",
        "sample2_input": "8,\"(()()))(\"",
        "sample2_output": "0",
        "sample3_input": "5,\"(()(\"",
        "sample3_output": "0",
        "sample4_input": "10,\"((()))(())\"",
        "sample4_output": "10",
        "sample5_input": "7,\"()()()(\"",
        "sample5_output": "6",
        "task_id": 112,
        "code": "MOD = 10**9 + 7\n\ndef main(n, prefix):\n    def count_valid_sequences(n, prefix):\n        k = len(prefix)\n\n        # Check if the prefix is already invalid\n        if prefix.count('(') > k // 2 or prefix.count(')') > k // 2:\n            return 0\n\n        # Calculate the number of valid sequences using dynamic programming\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            if prefix[i - 1] == '(':\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = (dp[i - 1] + dp[i - 1] - dp[i - k - 1]) % MOD\n\n        return dp[n]\n\n    return count_valid_sequences(n, prefix)",
        "test_list": [
            "assert main(6,\"(())\") == 2",
            "assert main(8,\"(()()))(\") == 0",
            "assert main(5,\"(()(\") == 0",
            "assert main(10,\"((()))(())\") == 10",
            "assert main(7,\"()()()(\") == 6"
        ]
    },
    {
        "link": "/problemset/task/2209",
        "title": "Counting Necklaces",
        "content": "Your task is to count the number of different necklaces that consist of n pearls and each pearl has m possible colors.\nTwo necklaces are considered to be different if it is not possible to rotate one of them so that they look the same.\nInput\nThe only input line has two numbers n and m: the number of pearls and colors.\nOutput\nPrint one integer: the number of different necklaces modulo 10^9+7.\nConstraints\n\n1 \\le n,m \\le 10^6\n\nExample\nInput:\n4 3\n\nOutput:\n24\n",
        "sample1_input": "4,3",
        "sample1_output": "24",
        "sample2_input": "2,2",
        "sample2_output": "2",
        "sample3_input": "5,4",
        "sample3_output": "170",
        "sample4_input": "3,5",
        "sample4_output": "240",
        "sample5_input": "6,6",
        "sample5_output": "83460",
        "task_id": 113,
        "code": "MOD = 10**9 + 7\n\ndef main(n, m):\n    def power(x, y, mod):\n        result = 1\n        x %= mod\n        while y > 0:\n            if y % 2 == 1:\n                result = (result * x) % mod\n            y //= 2\n            x = (x * x) % mod\n        return result\n\n    def count_necklaces(n, m):\n        total_necklaces = power(m, n, MOD)\n        for i in range(1, n + 1):\n            total_necklaces = (total_necklaces + ((m - 1) * power(m - 1, n - i, MOD)) % MOD) % MOD\n        return total_necklaces\n\n    return count_necklaces(n, m)",
        "test_list": [
            "assert main(4,3) == 24",
            "assert main(2,2) == 2",
            "assert main(5,4) == 170",
            "assert main(3,5) == 240",
            "assert main(6,6) == 83460"
        ]
    },
    {
        "link": "/problemset/task/2210",
        "title": "Counting Grids",
        "content": "Your task is to count the number of different n \\times n grids whose each square is black or white.\nTwo grids are considered to be different if it is not possible to rotate one of them so that they look the same.\nInput\nThe only input line has an integer n: the size of the grid.\nOutput\nPrint one integer: the number of grids modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^9\n\nExample\nInput:\n4\n\nOutput:\n16456\n",
        "sample1_input": "4",
        "sample1_output": "16456",
        "sample2_input": "3",
        "sample2_output": "10",
        "sample3_input": "5",
        "sample3_output": "136",
        "sample4_input": "6",
        "sample4_output": "1092",
        "sample5_input": "7",
        "sample5_output": "8728",
        "task_id": 114,
        "code": "MOD = 10**9 + 7\n\ndef main(n):\n    def power(x, y, mod):\n        result = 1\n        x %= mod\n        while y > 0:\n            if y % 2 == 1:\n                result = (result * x) % mod\n            y //= 2\n            x = (x * x) % mod\n        return result\n\n    def count_grids(n):\n        if n % 2 == 0:\n            return (power(2, n, MOD) + power(2, n // 2, MOD)) % MOD\n        else:\n            return (power(2, n, MOD) + power(2, (n + 1) // 2, MOD)) % MOD\n\n    return count_grids(n)",
        "test_list": [
            "assert main(4) == 16456",
            "assert main(3) == 10",
            "assert main(5) == 136",
            "assert main(6) == 1092",
            "assert main(7) == 8728"
        ]
    },
    {
        "link": "/problemset/task/1722",
        "title": "Fibonacci Numbers",
        "content": "The Fibonacci numbers can be defined as follows:\n\nF_0=0\nF_1=1\nF_n = F_{n-2}+F_{n-1}\n\nYour task is to calculate the value of F_n for a given n.\nInput\nThe only input line has an integer n.\nOutput\nPrint the value of F_n modulo 10^9+7.\nConstraints\n\n0 \\le n \\le 10^{18}\n\nExample\nInput:\n10\n\nOutput:\n55\n",
        "sample1_input": "10",
        "sample1_output": "55",
        "sample2_input": "5",
        "sample2_output": "5",
        "sample3_input": "0",
        "sample3_output": "0",
        "sample4_input": "18",
        "sample4_output": "2584",
        "sample5_input": "20",
        "sample5_output": "6765",
        "task_id": 115,
        "code": "MOD = 10**9 + 7\n\ndef main(n):\n    def matrix_multiply(a, b):\n        return [[(a[0][0] * b[0][0] + a[0][1] * b[1][0]) % MOD, (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % MOD],\n                [(a[1][0] * b[0][0] + a[1][1] * b[1][0]) % MOD, (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % MOD]]\n\n    def matrix_power(matrix, exp):\n        result = [[1, 0], [0, 1]]  # Identity matrix\n        while exp > 0:\n            if exp % 2 == 1:\n                result = matrix_multiply(result, matrix)\n            matrix = matrix_multiply(matrix, matrix)\n            exp //= 2\n        return result\n\n    if n == 0:\n        return 0\n\n    fibonacci_matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(fibonacci_matrix, n - 1)\n    return result_matrix[0][0]",
        "test_list": [
            "assert main(10) == 55",
            "assert main(5) == 5",
            "assert main(0) == 0",
            "assert main(18) == 2584",
            "assert main(20) == 6765"
        ]
    },
    {
        "link": "/problemset/task/1096",
        "title": "Throwing Dice",
        "content": "Your task is to calculate the number of ways to get a sum n by throwing dice. Each throw yields an integer between 1 \\ldots 6.\nFor example, if n=10, some possible ways are 3+3+4, 1+4+1+4 and 1+1+6+1+1.\nInput\nThe only input line contains an integer n.\nOutput\nPrint the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^{18}\n\nExample\nInput:\n8\n\nOutput:\n125\n",
        "sample1_input": "8",
        "sample1_output": "125",
        "sample2_input": "10",
        "sample2_output": "492",
        "sample3_input": "1",
        "sample3_output": "1",
        "sample4_input": "20",
        "sample4_output": "14497",
        "sample5_input": "5",
        "sample5_output": "13",
        "task_id": 116,
        "code": "MOD = 10**9 + 7\n\ndef main(n):\n    def count_ways_to_sum(n):\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, 7):\n                if i - j >= 0:\n                    dp[i] = (dp[i] + dp[i - j]) % MOD\n\n        return dp[n]\n\n    return count_ways_to_sum(n)",
        "test_list": [
            "assert main(8) == 125",
            "assert main(10) == 492",
            "assert main(1) == 1",
            "assert main(20) == 14497",
            "assert main(5) == 13"
        ]
    },
    {
        "link": "/problemset/task/1723",
        "title": "Graph Paths I",
        "content": "Consider a directed graph that has n nodes and m edges. Your task is to count the number of paths from node 1 to node n with exactly k edges.\nInput\nThe first input line contains three integers n, m and k: the number of nodes and edges, and the length of the path. The nodes are numbered 1,2,\\dots,n.\nThen, there are m lines describing the edges. Each line contains two integers a and b: there is an edge from node a to node b.\nOutput\nPrint the number of paths modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 100\n1 \\le m \\le n(n-1)\n1 \\le k \\le 10^9\n1 \\le a,b \\le n\n\nExample\nInput:\n3 4 8\n1 2\n2 3\n3 1\n3 2\n\nOutput:\n2\n\nExplanation: The paths are 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 and 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3 \\rightarrow 2 \\rightarrow 3.\n",
        "sample1_input": "3,4,8,[1,2],[2,3],[3,1],[3,2]",
        "sample1_output": "2",
        "sample2_input": "4,5,6,[1,2],[1,3],[2,3],[2,4],[3,4]",
        "sample2_output": "5",
        "sample3_input": "2,1,1,[1,2]",
        "sample3_output": "1",
        "sample4_input": "5,7,5,[1,2],[1,3],[2,3],[2,4],[3,4],[4,5],[3,5]",
        "sample4_output": "5",
        "sample5_input": "6,10,10,[1,2],[1,3],[2,3],[2,4],[3,4],[4,5],[3,5],[5,6],[1,4],[4,6]",
        "sample5_output": "10",
        "task_id": 117,
        "code": "MOD = 10**9 + 7\n\ndef main(n, m, k, edges):\n    def count_paths(n, m, k, edges):\n        graph = [[] for _ in range(n)]\n        for a, b in edges:\n            graph[a - 1].append(b - 1)\n\n        dp = [[0] * n for _ in range(k + 1)]\n        dp[0][0] = 1\n\n        for steps in range(1, k + 1):\n            for node in range(n):\n                for neighbor in graph[node]:\n                    dp[steps][node] += dp[steps - 1][neighbor]\n                    dp[steps][node] %= MOD\n\n        return dp[k][n - 1]\n\n    return count_paths(n, m, k, edges)",
        "test_list": [
            "assert main(3,4,8,[1,2],[2,3],[3,1],[3,2]) == 2",
            "assert main(4,5,6,[1,2],[1,3],[2,3],[2,4],[3,4]) == 5",
            "assert main(2,1,1,[1,2]) == 1",
            "assert main(5,7,5,[1,2],[1,3],[2,3],[2,4],[3,4],[4,5],[3,5]) == 5",
            "assert main(6,10,10,[1,2],[1,3],[2,3],[2,4],[3,4],[4,5],[3,5],[5,6],[1,4],[4,6]) == 10"
        ]
    },
    {
        "link": "/problemset/task/1724",
        "title": "Graph Paths II",
        "content": "Consider a directed weighted graph having n nodes and m edges. Your task is to calculate the minimum path length from node 1 to node n with exactly k edges.\nInput\nThe first input line contains three integers n, m and k: the number of nodes and edges, and the length of the path. The nodes are numbered 1,2,\\dots,n.\nThen, there are m lines describing the edges. Each line contains three integers a, b and c: there is an edge from node a to node b with weight c.\nOutput\nPrint the minimum path length. If there are no such paths, print -1.\nConstraints\n\n1 \\le n \\le 100\n1 \\le m \\le n(n-1)\n1 \\le k \\le 10^9\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n3 4 8\n1 2 5\n2 3 4\n3 1 1\n3 2 2\n\nOutput:\n27\n",
        "sample1_input": "3,4,8,[1,2,5],[2,3,4],[3,1,1],[3,2,2]",
        "sample1_output": "27",
        "sample2_input": "4,5,6,[1,2,2],[1,3,5],[2,3,1],[2,4,7],[3,4,3]",
        "sample2_output": "16",
        "sample3_input": "2,1,1,[1,2,10]",
        "sample3_output": "10",
        "sample4_input": "3,3,4,[1,2,2],[2,3,3],[1,3,5]",
        "sample4_output": "-1",
        "sample5_input": "5,6,2,[1,2,1],[2,3,2],[2,4,3],[1,3,5],[3,4,1],[4,5,1]",
        "sample5_output": "5",
        "task_id": 118,
        "code": "import sys\n\ndef main(n, m, k, edges):\n    INF = sys.maxsize\n\n    def min_path_length(n, m, k, edges):\n        dist = [[INF] * (k + 1) for _ in range(n)]\n        dist[0][0] = 0\n\n        for steps in range(1, k + 1):\n            for a, b, c in edges:\n                a -= 1\n                b -= 1\n                for prev in range(n):\n                    if dist[prev][steps - 1] != INF:\n                        dist[b][steps] = min(dist[b][steps], dist[prev][steps - 1] + c)\n\n        return dist[n - 1][k] if dist[n - 1][k] != INF else -1\n\n    return min_path_length(n, m, k, edges)",
        "test_list": [
            "assert main(3,4,8,[1,2,5],[2,3,4],[3,1,1],[3,2,2]) == 27",
            "assert main(4,5,6,[1,2,2],[1,3,5],[2,3,1],[2,4,7],[3,4,3]) == 16",
            "assert main(2,1,1,[1,2,10]) == 10",
            "assert main(3,3,4,[1,2,2],[2,3,3],[1,3,5]) == -1",
            "assert main(5,6,2,[1,2,1],[2,3,2],[2,4,3],[1,3,5],[3,4,1],[4,5,1]) == 5"
        ]
    },
    {
        "link": "/problemset/task/1725",
        "title": "Dice Probability",
        "content": "You throw a dice n times, and every throw produces an outcome between 1 and 6. What is the probability that the sum of outcomes is between a and b?\nInput\nThe only input line contains three integers n, a and b.\nOutput\nPrint the probability rounded to six decimal places (rounding half to even).\nConstraints\n\n1 \\le n \\le 100\n1 \\le a \\le b \\le 6n\n\nExample\nInput:\n2 9 10\n\nOutput:\n0.194444\n",
        "sample1_input": "2,9,10",
        "sample1_output": "0.194444",
        "sample2_input": "3,7,14",
        "sample2_output": "0.097222",
        "sample3_input": "4,12,18",
        "sample3_output": "0.125",
        "sample4_input": "1,1,3",
        "sample4_output": "0.5",
        "sample5_input": "5,25,30",
        "sample5_output": "0.000759",
        "task_id": 119,
        "code": "def main(n, a, b):\n    def probability(n, a, b):\n        # Initialize a 2D array to store the probabilities\n        dp = [[0] * (6 * n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, 6 * n + 1):\n                for k in range(1, 7):\n                    if j - k >= 0:\n                        dp[i][j] += dp[i - 1][j - k]\n\n        total_ways = 6 ** n\n        favorable_ways = sum(dp[n][a:b + 1])\n        probability = favorable_ways / total_ways\n        return round(probability, 6)\n\n    return probability(n, a, b)",
        "test_list": [
            "assert main(2,9,10) == 0.194444",
            "assert main(3,7,14) == 0.097222",
            "assert main(4,12,18) == 0.125",
            "assert main(1,1,3) == 0.5",
            "assert main(5,25,30) == 0.000759"
        ]
    },
    {
        "link": "/problemset/task/1726",
        "title": "Moving Robots",
        "content": "Each square of an 8 \\times 8 chessboard has a robot. Each robot independently moves k steps, and there can be many robots on the same square.\nOn each turn, a robot moves one step left, right, up or down, but not outside the board. It randomly chooses a direction among those where it can move.\nYour task is to calculate the expected number of empty squares after k turns.\nInput\nThe only input line has an integer k.\nOutput\nPrint the expected number of empty squares rounded to six decimal places (rounding half to even).\nConstraints\n\n1 \\le k \\le 100\n\nExample\nInput:\n10\n\nOutput:\n23.120740\n",
        "sample1_input": "10",
        "sample1_output": "23.120740",
        "sample2_input": "5",
        "sample2_output": "25.000000",
        "sample3_input": "3",
        "sample3_output": "28.000000",
        "sample4_input": "1",
        "sample4_output": "32.000000",
        "sample5_input": "8",
        "sample5_output": "23.857143",
        "task_id": 120,
        "code": "def main(k):\n    def expected_empty_squares(k):\n        # Initialize a 2D grid to represent the chessboard\n        chessboard = [[1] * 8 for _ in range(8)]\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        for _ in range(k):\n            # Create a new grid to store the updated probabilities\n            new_chessboard = [[0] * 8 for _ in range(8)]\n\n            for i in range(8):\n                for j in range(8):\n                    for dx, dy in directions:\n                        x, y = i + dx, j + dy\n                        if 0 <= x < 8 and 0 <= y < 8:\n                            # Calculate the probability for the robot to move to (x, y)\n                            new_chessboard[x][y] += chessboard[i][j] / 4\n\n            chessboard = new_chessboard\n\n        # Calculate the expected number of empty squares\n        expected_empty = sum(row.count(1) for row in chessboard)\n        return round(expected_empty, 6)\n\n    return expected_empty_squares(k)",
        "test_list": [
            "assert main(10) == 23.120740",
            "assert main(5) == 25.000000",
            "assert main(3) == 28.000000",
            "assert main(1) == 32.000000",
            "assert main(8) == 23.857143"
        ]
    },
    {
        "link": "/problemset/task/1727",
        "title": "Candy Lottery",
        "content": "There are n children, and each of them independently gets a random integer number of candies between 1 and k.\nWhat is the expected maximum number of candies a child gets?\nInput\nThe only input line contains two integers n and k.\nOutput\nPrint the expected number rounded to six decimal places (rounding half to even).\nConstraints\n\n1 \\le n \\le 100\n1 \\le k \\le 100\n\nExample\nInput:\n2 3\n\nOutput:\n2.444444\n",
        "sample1_input": "2,3",
        "sample1_output": "2.444444",
        "sample2_input": "4,5",
        "sample2_output": "3.123611",
        "sample3_input": "3,2",
        "sample3_output": "1.75",
        "sample4_input": "1,100",
        "sample4_output": "100.000000",
        "sample5_input": "5,10",
        "sample5_output": "5.159274",
        "task_id": 121,
        "code": "def main(n, k):\n    expected_max_candies = 0\n    for i in range(1, k + 1):\n        expected_max_candies += i * (i / k) ** n\n    return round(expected_max_candies, 6)",
        "test_list": [
            "assert main(2,3) == 2.444444",
            "assert main(4,5) == 3.123611",
            "assert main(3,2) == 1.75",
            "assert main(1,100) == 100.000000",
            "assert main(5,10) == 5.159274"
        ]
    },
    {
        "link": "/problemset/task/1728",
        "title": "Inversion Probability",
        "content": "An array has n integers x_1,x_2,\\dots,x_n, and each of them has been randomly chosen between 1 and r_i. An inversion is a pair (a,b) where a&lt;b and x_a&gt;x_b.\nWhat is the expected number of inversions in the array?\nInput\nThe first input line contains an integer n: the size of the array.\nThe second line contains n integers r_1,r_2,\\dots,r_n: the range of possible values for each array position.\nOutput\nPrint the expected number of inversions rounded to six decimal places (rounding half to even).\nConstraints\n\n1 \\le n \\le 100\n1 \\le r_i \\le 100\n\nExample\nInput:\n3\n5 2 7\n\nOutput:\n1.057143\n",
        "sample1_input": "3,[5,2,7]",
        "sample1_output": "1.057143",
        "sample2_input": "4,[3,4,2,1]",
        "sample2_output": "7.888889",
        "sample3_input": "2,[10,8]",
        "sample3_output": "1.500000",
        "sample4_input": "1,[1]",
        "sample4_output": "0.000000",
        "sample5_input": "5,[6,6,6,6,6]",
        "sample5_output": "6.000000",
        "task_id": 122,
        "code": "import itertools\n\ndef main(n, r):\n    total_inversions = 0\n    total_permutations = 0\n    for permutation in itertools.permutations(range(1, max(r) + 1), n):\n        total_permutations += 1\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if permutation[i] > permutation[j]:\n                    inversions += 1\n        total_inversions += inversions\n    expected_inversions = total_inversions / total_permutations\n    return round(expected_inversions, 6)",
        "test_list": [
            "assert main(3,[5,2,7]) == 1.057143",
            "assert main(4,[3,4,2,1]) == 7.888889",
            "assert main(2,[10,8]) == 1.500000",
            "assert main(1,[1]) == 0.000000",
            "assert main(5,[6,6,6,6,6]) == 6.000000"
        ]
    },
    {
        "link": "/problemset/task/1729",
        "title": "Stick Game",
        "content": "Consider a game where two players remove sticks from a heap. The players move alternately, and the player who removes the last stick wins the game.\nA set P=\\{p_1,p_2,\\ldots,p_k\\} determines the allowed moves. For example, if P=\\{1,3,4\\}, a player may remove 1, 3 or 4 sticks.\nYour task is find out for each number of sticks 1,2,\\dots,n if the first player has a winning or losing position.\nInput\nThe first input line has two integers n and k: the number of sticks and moves.\nThe next line has k integers p_1,p_2,\\dots,p_k that describe the allowed moves. All integers are distinct, and one of them is 1.\nOutput\nPrint a string containing n characters: W means a winning position, and L means a losing position.\nConstraints\n\n1 \\le n \\le 10^6\n1 \\le k \\le 100\n1 \\le p_i \\le n\n\nExample\nInput:\n10 3\n1 3 4\n\nOutput:\nWLWWWWLWLW\n",
        "sample1_input": "10,3,[1,3,4]",
        "sample1_output": "WLWWWWLWLW",
        "sample2_input": "5,2,[1,2]",
        "sample2_output": "WLWLW",
        "sample3_input": "7,3,[1,2,4]",
        "sample3_output": "WLWWLWL",
        "sample4_input": "3,1,[1]",
        "sample4_output": "WLW",
        "sample5_input": "6,2,[1,5]",
        "sample5_output": "WLWLWW",
        "task_id": 123,
        "code": "def main(n, k, moves):\n    winning_positions = ['L'] * (n + 1)\n    for i in range(1, n + 1):\n        for move in moves:\n            if i - move >= 0 and winning_positions[i - move] == 'L':\n                winning_positions[i] = 'W'\n                break\n    return ''.join(winning_positions[1:])",
        "test_list": [
            "assert main(10,3,[1,3,4]) == WLWWWWLWLW",
            "assert main(5,2,[1,2]) == WLWLW",
            "assert main(7,3,[1,2,4]) == WLWWLWL",
            "assert main(3,1,[1]) == WLW",
            "assert main(6,2,[1,5]) == WLWLWW"
        ]
    },
    {
        "link": "/problemset/task/1730",
        "title": "Nim Game I",
        "content": "There are n heaps of sticks and two players who move alternately. On each move, a player chooses a non-empty heap and removes any number of sticks. The player who removes the last stick wins the game.\nYour task is to find out who wins if both players play optimally.\nInput\nThe first input line contains an integer t: the number of tests. After this, t test cases are described:\nThe first line contains an integer n: the number of heaps.\nThe next line has n integers x_1,x_2,\\ldots,x_n: the number of sticks in each heap.\nOutput\nFor each test case, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\nConstraints\n\n1 \\le t \\le 2 \\cdot 10^5\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\nthe sum of all n is at most 2 \\cdot 10^5\n\nExample\nInput:\n3\n4\n5 7 2 5\n2\n4 1\n3\n3 5 6\n\nOutput:\nfirst\nfirst\nsecond\n",
        "sample1_input": "3,[4],[5,7,2,5],[2],[4,1],[3],[3,5,6]",
        "sample1_output": "first\nfirst\nsecond",
        "sample2_input": "2,[3],[1,2,3],[3],[4,5,6]",
        "sample2_output": "second\nfirst",
        "sample3_input": "1,[1],[1]",
        "sample3_output": "first",
        "sample4_input": "1,[3],[1,2,3]",
        "sample4_output": "second",
        "sample5_input": "2,[2],[2,2],[3],[1,1,1]",
        "sample5_output": "second\nsecond",
        "task_id": 124,
        "code": "def main(t, test_cases):\n    results = []\n    for i in range(t):\n        n, heaps = test_cases[i]\n        xor_sum = 0\n        for x in heaps:\n            xor_sum ^= x\n        if xor_sum == 0:\n            results.append('second')\n        else:\n            results.append('first')\n    return results",
        "test_list": [
            "assert main(3,[4],[5,7,2,5],[2],[4,1],[3],[3,5,6]) == first\nfirst\nsecond",
            "assert main(2,[3],[1,2,3],[3],[4,5,6]) == second\nfirst",
            "assert main(1,[1],[1]) == first",
            "assert main(1,[3],[1,2,3]) == second",
            "assert main(2,[2],[2,2],[3],[1,1,1]) == second\nsecond"
        ]
    },
    {
        "link": "/problemset/task/1098",
        "title": "Nim Game II",
        "content": "There are n heaps of sticks and two players who move alternately. On each move, a player chooses a non-empty heap and removes 1, 2, or 3 sticks. The player who removes the last stick wins the game.\nYour task is to find out who wins if both players play optimally.\nInput\nThe first input line contains an integer t: the number of tests. After this, t test cases are described:\nThe first line contains an integer n: the number of heaps.\nThe next line has n integers x_1,x_2,\\ldots,x_n: the number of sticks in each heap.\nOutput\nFor each test case, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\nConstraints\n\n1 \\le t \\le 2 \\cdot 10^5\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\nthe sum of all n is at most 2 \\cdot 10^5\n\nExample\nInput:\n3\n4\n5 7 2 5\n2\n4 1\n3\n4 4 4\n\nOutput:\nfirst\nfirst\nsecond\n",
        "sample1_input": "3,[4],[5,7,2,5],[2],[4,1],[3],[4,4,4]",
        "sample1_output": "first\nfirst\nsecond",
        "sample2_input": "2,[2],[2,2],[3],[1,1,1]",
        "sample2_output": "first\nfirst",
        "sample3_input": "1,[1],[1]",
        "sample3_output": "first",
        "sample4_input": "1,[3],[1,2,3]",
        "sample4_output": "first",
        "sample5_input": "2,[2],[3,3],[3],[3,3,3]",
        "sample5_output": "first\nsecond",
        "task_id": 125,
        "code": "def main(t, test_cases):\n    results = []\n    for i in range(t):\n        n, heaps = test_cases[i]\n        xor_sum = 0\n        for x in heaps:\n            xor_sum ^= x % 4\n        if xor_sum == 0:\n            results.append('second')\n        else:\n            results.append('first')\n    return results",
        "test_list": [
            "assert main(3,[4],[5,7,2,5],[2],[4,1],[3],[4,4,4]) == first\nfirst\nsecond",
            "assert main(2,[2],[2,2],[3],[1,1,1]) == first\nfirst",
            "assert main(1,[1],[1]) == first",
            "assert main(1,[3],[1,2,3]) == first",
            "assert main(2,[2],[3,3],[3],[3,3,3]) == first\nsecond"
        ]
    },
    {
        "link": "/problemset/task/1099",
        "title": "Stair Game",
        "content": "There is a staircase consisting of n stairs, numbered 1,2,\\ldots,n. Initially, each stair has some number of balls.\nThere are two players who move alternately. On each move, a player chooses a stair k where k \\neq 1 and it has at least one ball. Then, the player moves any number of balls from stair k to stair k-1. The player who moves last wins the game.\nYour task is to find out who wins the game when both players play optimally.\nNote that if there are no possible moves at all, the second player wins.\nInput\nThe first input line has an integer t: the number of tests. After this, t test cases are described:\nThe first line contains an integer n: the number of stairs.\nThe next line has n integers p_1,p_2,\\ldots,p_n: the initial number of balls on each stair.\nOutput\nFor each test, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\nConstraints\n\n1 \\le t \\le 2 \\cdot 10^5\n1 \\le n \\le 2 \\cdot 10^5\n0 \\le p_i \\le 10^9\nthe sum of all n is at most 2 \\cdot 10^5\n\nExample\nInput:\n3\n3\n0 2 1\n4\n1 1 1 1\n2\n5 3\n\nOutput:\nfirst\nsecond\nfirst\n",
        "sample1_input": "3,[3],[0,2,1],[4],[1,1,1,1],[2],[5,3]",
        "sample1_output": "first\nsecond\nfirst",
        "sample2_input": "1,[1],[0]",
        "sample2_output": "second",
        "sample3_input": "1,[5],[0,0,0,0,1]",
        "sample3_output": "first",
        "sample4_input": "1,[10],[0,0,0,0,0,0,0,0,0,1]",
        "sample4_output": "second",
        "sample5_input": "1,[5],[1,2,3,4,5]",
        "sample5_output": "first",
        "task_id": 126,
        "code": "def main(t, test_cases):\n    results = []\n    for i in range(t):\n        n, stairs = test_cases[i]\n        xor_sum = 0\n        for p in stairs[1:]:\n            xor_sum ^= p % 2\n        if xor_sum == 0:\n            results.append('second')\n        else:\n            results.append('first')\n    return results",
        "test_list": [
            "assert main(3,[3],[0,2,1],[4],[1,1,1,1],[2],[5,3]) == first\nsecond\nfirst",
            "assert main(1,[1],[0]) == second",
            "assert main(1,[5],[0,0,0,0,1]) == first",
            "assert main(1,[10],[0,0,0,0,0,0,0,0,0,1]) == second",
            "assert main(1,[5],[1,2,3,4,5]) == first"
        ]
    },
    {
        "link": "/problemset/task/2207",
        "title": "Grundy's Game",
        "content": "There is a heap of n coins and two players who move alternately. On each move, a player chooses a heap and divides into two nonempty heaps that have a different number of coins. The player who makes the last move wins the game.\nYour task is to find out who wins if both players play optimally.\nInput\nThe first input line contains an integer t: the number of tests.\nAfter this, there are t lines that describe the tests. Each line has an integer n: the number of coins in the initial heap.\nOutput\nFor each test case, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\nConstraints\n\n1 \\le t \\le 10^5\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n6\n7\n8\n\nOutput:\nfirst\nsecond\nfirst\n",
        "sample1_input": "3,[6],[7],[8]",
        "sample1_output": "first\nsecond\nfirst",
        "sample2_input": "1,[1]",
        "sample2_output": "second",
        "sample3_input": "1,[1000000]",
        "sample3_output": "first",
        "sample4_input": "1,[999999]",
        "sample4_output": "second",
        "sample5_input": "1,[2]",
        "sample5_output": "first",
        "task_id": 127,
        "code": "def main(t, test_cases):\n    results = []\n    for i in range(t):\n        n = test_cases[i]\n        if n % 2 == 0:\n            results.append('first')\n        else:\n            results.append('second')\n    return results",
        "test_list": [
            "assert main(3,[6],[7],[8]) == first\nsecond\nfirst",
            "assert main(1,[1]) == second",
            "assert main(1,[1000000]) == first",
            "assert main(1,[999999]) == second",
            "assert main(1,[2]) == first"
        ]
    },
    {
        "link": "/problemset/task/2208",
        "title": "Another Game",
        "content": "There are n heaps of coins and two players who move alternately. On each move, a player selects some of the nonempty heaps and removes one coin from each heap. The player who removes the last coin wins the game.\nYour task is to find out who wins if both players play optimally.\nInput\nThe first input line contains an integer t: the number of tests. After this, t test cases are described:\nThe first line contains an integer n: the number of heaps.\nThe next line has n integers x_1,x_2,\\ldots,x_n: the number of coins in each heap.\nOutput\nFor each test case, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\nConstraints\n\n1 \\le t \\le 2 \\cdot 10^5\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\nthe sum of all n is at most 2 \\cdot 10^5\n\nExample\nInput:\n3\n3\n1 2 3\n2\n2 2\n4\n5 5 4 5\n\nOutput:\nfirst\nsecond\nfirst\n",
        "sample1_input": "3,[3],[1,2,3],[2],[2,2],[4],[5,5,4,5]",
        "sample1_output": "first\nsecond\nfirst",
        "sample2_input": "1,[1],[1]",
        "sample2_output": "first",
        "sample3_input": "1,[3],[1,1,1]",
        "sample3_output": "second",
        "sample4_input": "1,[5],[1,2,3,4,5]",
        "sample4_output": "second",
        "sample5_input": "1,[5],[1,1,1,1,1]",
        "sample5_output": "first",
        "task_id": 128,
        "code": "def main(t, test_cases):\n    results = []\n    for i in range(t):\n        n, heaps = test_cases[i]\n        xor_sum = 0\n        for x in heaps:\n            xor_sum ^= x\n        if xor_sum == 0:\n            results.append('second')\n        else:\n            results.append('first')\n    return results",
        "test_list": [
            "assert main(3,[3],[1,2,3],[2],[2,2],[4],[5,5,4,5]) == first\nsecond\nfirst",
            "assert main(1,[1],[1]) == first",
            "assert main(1,[3],[1,1,1]) == second",
            "assert main(1,[5],[1,2,3,4,5]) == second",
            "assert main(1,[5],[1,1,1,1,1]) == first"
        ]
    },
    {
        "link": "/problemset/task/1731",
        "title": "Word Combinations",
        "content": "You are given a string of length n and a dictionary containing k words. In how many ways can you create the string using the words?\nInput\nThe first input line has a string containing n characters between a–z.\nThe second line has an integer k: the number of words in the dictionary.\nFinally there are k lines describing the words. Each word is unique and consists of characters a–z.\nOutput\nPrint the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 5000\n1 \\le k \\le 10^5\nthe total length of the words is at most 10^6\n\nExample\nInput:\nababc\n4\nab\nabab\nc\ncb\n\nOutput:\n2\n\nExplanation: The possible ways are ab+ab+c and abab+c.\n",
        "sample1_input": "ababc,4,[\"ab\",\"abab\",\"c\",\"cb\"]",
        "sample1_output": "2",
        "sample2_input": "aaaa,1,[\"a\"]",
        "sample2_output": "1",
        "sample3_input": "xyzxxyz,3,[\"x\",\"y\",\"z\"]",
        "sample3_output": "4",
        "sample4_input": "abcdefg,1,[\"a\"]",
        "sample4_output": "1",
        "sample5_input": "abcdefgh,5,[\"ab\",\"cd\",\"ef\",\"gh\",\"abcd\"]",
        "sample5_output": "10",
        "task_id": 129,
        "code": "def main(s, k, words):\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for word in words:\n            if i >= len(word) and s[i - len(word):i] == word:\n                dp[i] += dp[i - len(word)]\n                dp[i] %= MOD\n    return dp[n]",
        "test_list": [
            "assert main(ababc,4,[\"ab\",\"abab\",\"c\",\"cb\"]) == 2",
            "assert main(aaaa,1,[\"a\"]) == 1",
            "assert main(xyzxxyz,3,[\"x\",\"y\",\"z\"]) == 4",
            "assert main(abcdefg,1,[\"a\"]) == 1",
            "assert main(abcdefgh,5,[\"ab\",\"cd\",\"ef\",\"gh\",\"abcd\"]) == 10"
        ]
    },
    {
        "link": "/problemset/task/1753",
        "title": "String Matching",
        "content": "Given a string and a pattern, your task is to count the number of positions where the pattern occurs in the string.\nInput\nThe first input line has a string of length n, and the second input line has a pattern of length m. Both of them consist of characters a–z.\nOutput\nPrint one integer: the number of occurrences.\nConstraints\n\n1 \\le n,m \\le 10^6\n\nExample\nInput:\nsaippuakauppias\npp\n\nOutput:\n2\n",
        "sample1_input": "saippuakauppias\",\"pp",
        "sample1_output": "2",
        "sample2_input": "abcdefg\",\"xyz",
        "sample2_output": "0",
        "sample3_input": "aaaaa\",\"aa",
        "sample3_output": "4",
        "sample4_input": "hello\",\"lo",
        "sample4_output": "1",
        "sample5_input": "programming\",\"gram",
        "sample5_output": "1",
        "task_id": 130,
        "code": "def main(string, pattern):\n    count = 0\n    n = len(string)\n    m = len(pattern)\n    for i in range(n - m + 1):\n        if string[i:i + m] == pattern:\n            count += 1\n    return count",
        "test_list": [
            "assert main(saippuakauppias\",\"pp) == 2",
            "assert main(abcdefg\",\"xyz) == 0",
            "assert main(aaaaa\",\"aa) == 4",
            "assert main(hello\",\"lo) == 1",
            "assert main(programming\",\"gram) == 1"
        ]
    },
    {
        "link": "/problemset/task/1732",
        "title": "Finding Borders",
        "content": "A border of a string is a prefix that is also a suffix of the string but not the whole string. For example, the borders of abcababcab are ab and abcab.\nYour task is to find all border lengths of a given string.\nInput\nThe only input line has a string of length n consisting of characters a–z.\nOutput\nPrint all border lengths of the string in increasing order.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nabcababcab\n\nOutput:\n2 5\n",
        "sample1_input": "abcababcab",
        "sample1_output": "2 5",
        "sample2_input": "ababababab",
        "sample2_output": "2 4 6 8",
        "sample3_input": "abcdefg",
        "sample3_output": "",
        "sample4_input": "aaabaaa",
        "sample4_output": "3",
        "sample5_input": "abacaba",
        "sample5_output": "1 3 5",
        "task_id": 131,
        "code": "def main(s):\n    n = len(s)\n    borders = []\n    for i in range(1, n):\n        prefix = s[:i]\n        suffix = s[n - i:]\n        if prefix == suffix:\n            borders.append(i)\n    return ' '.join(map(str, borders))",
        "test_list": [
            "assert main(abcababcab) == 2 5",
            "assert main(ababababab) == 2 4 6 8",
            "assert main(abcdefg) == ",
            "assert main(aaabaaa) == 3",
            "assert main(abacaba) == 1 3 5"
        ]
    },
    {
        "link": "/problemset/task/1733",
        "title": "Finding Periods",
        "content": "A period of a string is a prefix that can be used to generate the whole string by repeating the prefix. The last repetition may be partial. For example, the periods of abcabca are abc, abcabc and abcabca.\nYour task is to find all period lengths of a string.\nInput\nThe only input line has a string of length n consisting of characters a–z.\nOutput\nPrint all period lengths in increasing order.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nabcabca\n\nOutput:\n3 6 7\n",
        "sample1_input": "abcabca",
        "sample1_output": "3 6 7",
        "sample2_input": "abababab",
        "sample2_output": "2 4 8",
        "sample3_input": "abcdefg",
        "sample3_output": "7",
        "sample4_input": "aaabaaa",
        "sample4_output": "3",
        "sample5_input": "abacaba",
        "sample5_output": "1 3 7",
        "task_id": 132,
        "code": "def main(s):\n    n = len(s)\n    periods = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            prefix = s[:i]\n            if prefix * (n // i) == s:\n                periods.append(i)\n    return ' '.join(map(str, periods))",
        "test_list": [
            "assert main(abcabca) == 3 6 7",
            "assert main(abababab) == 2 4 8",
            "assert main(abcdefg) == 7",
            "assert main(aaabaaa) == 3",
            "assert main(abacaba) == 1 3 7"
        ]
    },
    {
        "link": "/problemset/task/1111",
        "title": "Longest Palindrome",
        "content": "Given a string, your task is to determine the longest palindromic substring of the string. For example, the longest palindrome in aybabtu is bab.\nInput\nThe only input line contains a string of length n. Each character is one of a–z.\nOutput\nPrint the longest palindrome in the string. If there are several solutions, you may print any of them.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\naybabtu\n\nOutput:\nbab\n",
        "sample1_input": "acab",
        "sample1_output": "abac",
        "sample2_input": "abcde",
        "sample2_output": "abcde",
        "sample3_input": "banana",
        "sample3_output": "aanban",
        "sample4_input": "xyzyx",
        "sample4_output": "xyzyx",
        "sample5_input": "racecar",
        "sample5_output": "acecarr",
        "task_id": 133,
        "code": "def main(s):\n    n = len(s)\n    s += s\n    p = [0] * n\n    p[0] = -1\n    k = -1\n    for i in range(1, n):\n        while k >= 0 and s[i] != s[k + 1]:\n            k = p[k]\n        if s[i] == s[k + 1]:\n            k += 1\n        p[i] = k\n    return s[:n - k]\n",
        "test_list": [
            "assert main(acab) == abac",
            "assert main(abcde) == abcde",
            "assert main(banana) == aanban",
            "assert main(xyzyx) == xyzyx",
            "assert main(racecar) == acecarr"
        ]
    },
    {
        "link": "/problemset/task/1112",
        "title": "Required Substring",
        "content": "Your task is to calculate the number of strings of length n having a given pattern of length m as their substring. All strings consist of characters A–Z.\nInput\nThe first input line has an integer n: the length of the final string.\nThe second line has a pattern of length m.\nOutput\nPrint the number of strings modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le m \\le 100\n\nExample\nInput:\n6\nABCDB\n\nOutput:\n52\n\nExplanation: The final string will be of the form ABCDBx or xABCDB where x is any character between A–Z.\n",
        "sample1_input": "6\nABCDB",
        "sample1_output": "52",
        "sample2_input": "5\nABABA",
        "sample2_output": "17",
        "sample3_input": "8\nAA",
        "sample3_output": "255",
        "sample4_input": "10\nXYZXYZ",
        "sample4_output": "85",
        "sample5_input": "7\nX",
        "sample5_output": "25",
        "task_id": 134,
        "code": "def main(n, pattern):\n    m = len(pattern)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    for i in range(m):\n        dp[i] = 1\n    for i in range(m, n + 1):\n        for j in range(1, m + 1):\n            if pattern[j - 1] != pattern[m - 1]:\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n    return dp[n]",
        "test_list": [
            "assert main(6\nABCDB) == 52",
            "assert main(5\nABABA) == 17",
            "assert main(8\nAA) == 255",
            "assert main(10\nXYZXYZ) == 85",
            "assert main(7\nX) == 25"
        ]
    },
    {
        "link": "/problemset/task/2189",
        "title": "Point Location Test",
        "content": "There is a line that goes through the points p_1=(x_1,y_1) and p_2=(x_2,y_2). There is also a point p_3=(x_3,y_3).\nYour task is to determine whether p_3 is located on the left or right side of the line or if it touches the line when we are looking from p_1 to p_2.\nInput\nThe first input line has an integer t: the number of tests.\nAfter this, there are t lines that describe the tests. Each line has six integers: x_1, y_1, x_2, y_2, x_3 and y_3.\nOutput\nFor each test, print \"LEFT\", \"RIGHT\" or \"TOUCH\".\nConstraints\n\n1 \\le t \\le 10^5\n-10^9 \\le x_1, y_1, x_2, y_2, x_3, y_3 \\le 10^9\nx_1 \\neq x_2 or y_1 \\neq y_2\n\nExample\nInput:\n3\n1 1 5 3 2 3\n1 1 5 3 4 1\n1 1 5 3 3 2\n\nOutput:\nLEFT\nRIGHT\nTOUCH\n",
        "sample1_input": "3,[1,1,5,3,2,3],[1,1,5,3,4,1],[1,1,5,3,3,2]",
        "sample1_output": "LEFT\nRIGHT\nTOUCH\n",
        "sample2_input": "2,[0,0,1,1,1,0],[0,0,1,1,0,1]",
        "sample2_output": "LEFT\nRIGHT\n",
        "sample3_input": "1,[-1,1,1,1,0,1]",
        "sample3_output": "LEFT\n",
        "sample4_input": "1,[0,0,1,1,2,2]",
        "sample4_output": "LEFT\n",
        "sample5_input": "1,[0,0,1,1,0,0]",
        "sample5_output": "TOUCH\n",
        "task_id": 135,
        "code": "def main(t, tests):\n    result = []\n    for i in range(t):\n        x1, y1, x2, y2, x3, y3 = tests[i]\n        det = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n\n        if det > 0:\n            result.append('LEFT')\n        elif det < 0:\n            result.append('RIGHT')\n        else:\n            result.append('TOUCH')\n\n    return result",
        "test_list": [
            "assert main(3,[1,1,5,3,2,3],[1,1,5,3,4,1],[1,1,5,3,3,2]) == LEFT\nRIGHT\nTOUCH\n",
            "assert main(2,[0,0,1,1,1,0],[0,0,1,1,0,1]) == LEFT\nRIGHT\n",
            "assert main(1,[-1,1,1,1,0,1]) == LEFT\n",
            "assert main(1,[0,0,1,1,2,2]) == LEFT\n",
            "assert main(1,[0,0,1,1,0,0]) == TOUCH\n"
        ]
    },
    {
        "link": "/problemset/task/2190",
        "title": "Line Segment Intersection",
        "content": "There are two line segments: the first goes through the points (x_1,y_1) and (x_2,y_2), and the second goes through the points (x_3,y_3) and (x_4,y_4).\nYour task is to determine if the line segments intersect, i.e., they have at least one common point.\nInput\nThe first input line has an integer t: the number of tests.\nAfter this, there are t lines that describe the tests. Each line has eight integers x_1, y_1, x_2, y_2, x_3, y_3, x_4 and y_4.\nOutput\nFor each test, print \"YES\" if the line segments intersect and \"NO\" otherwise.\nConstraints\n\n1 \\le t \\le 10^5\n-10^9 \\le x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 \\le 10^9\n(x_1,y_1) \\neq (x_2,y_2)\n(x_3,y_3) \\neq (x_4,y_4)\n\nExample\nInput:\n5\n1 1 5 3 1 2 4 3\n1 1 5 3 1 1 4 3\n1 1 5 3 2 3 4 1\n1 1 5 3 2 4 4 1\n1 1 5 3 3 2 7 4\n\nOutput:\nNO\nYES\nYES\nYES\nYES\n",
        "sample1_input": "5,[1,1,5,3,1,2,4,3],[1,1,5,3,1,1,4,3],[1,1,5,3,2,3,4,1],[1,1,5,3,2,4,4,1],[1,1,5,3,3,2,7,4]",
        "sample1_output": "NO\nYES\nYES\nYES\nYES\n",
        "sample2_input": "2,[0,0,1,1,1,0,1,1],[0,0,1,1,2,2,3,3]",
        "sample2_output": "YES\nYES\n",
        "sample3_input": "1,[0,0,1,1,1,2,2,3]",
        "sample3_output": "NO\n",
        "sample4_input": "1,[0,0,1,1,1,1,2,2]",
        "sample4_output": "YES\n",
        "sample5_input": "1,[-1000000000,-1000000000,1000000000,1000000000,0,0,0,0]",
        "sample5_output": "YES\n",
        "task_id": 136,
        "code": "def main(t, tests):\n    result = []\n    for i in range(t):\n        x1, y1, x2, y2, x3, y3, x4, y4 = tests[i]\n        det = (x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1)\n\n        if det == 0:\n            result.append('NO')\n        else:\n            t1 = ((x3 - x1) * (y4 - y3) - (x4 - x3) * (y3 - y1)) / det\n            t2 = ((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / det\n\n            if 0 <= t1 <= 1 and 0 <= t2 <= 1:\n                result.append('YES')\n            else:\n                result.append('NO')\n\n    return result",
        "test_list": [
            "assert main(5,[1,1,5,3,1,2,4,3],[1,1,5,3,1,1,4,3],[1,1,5,3,2,3,4,1],[1,1,5,3,2,4,4,1],[1,1,5,3,3,2,7,4]) == NO\nYES\nYES\nYES\nYES\n",
            "assert main(2,[0,0,1,1,1,0,1,1],[0,0,1,1,2,2,3,3]) == YES\nYES\n",
            "assert main(1,[0,0,1,1,1,2,2,3]) == NO\n",
            "assert main(1,[0,0,1,1,1,1,2,2]) == YES\n",
            "assert main(1,[-1000000000,-1000000000,1000000000,1000000000,0,0,0,0]) == YES\n"
        ]
    },
    {
        "link": "/problemset/task/2191",
        "title": "Polygon Area",
        "content": "Your task is to calculate the area of a given polygon.\nThe polygon consists of n vertices (x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n). The vertices (x_i,y_i) and (x_{i+1},y_{i+1}) are adjacent for i=1,2,\\dots,n-1, and the vertices (x_1,y_1) and (x_n,y_n) are also adjacent.\nInput\nThe first input line has an integer n: the number of vertices.\nAfter this, there are n lines that describe the vertices. The ith such line has two integers x_i and y_i.\nYou may assume that the polygon is simple, i.e., it does not intersect itself.\nOutput\nPrint one integer: 2a where the area of the polygon is a (this ensures that the result is an integer).\nConstraints\n\n3 \\le n \\le 1000\n-10^9 \\le x_i, y_i \\le 10^9\n\nExample\nInput:\n4\n1 1\n4 2\n3 5\n1 4\n\nOutput:\n16\n",
        "sample1_input": "4,[1,1],[4,2],[3,5],[1,4]",
        "sample1_output": "16\n",
        "sample2_input": "3,[0,0],[0,1],[1,0]",
        "sample2_output": "1\n",
        "sample3_input": "3,[-1,0],[0,1],[1,0]",
        "sample3_output": "1\n",
        "sample4_input": "3,[0,0],[0,-1],[-1,0]",
        "sample4_output": "1\n",
        "sample5_input": "4,[0,0],[0,1],[1,1],[1,0]",
        "sample5_output": "1\n",
        "task_id": 137,
        "code": "def main(n, vertices):\n    area = 0\n    for i in range(n - 1):\n        area += (vertices[i][0] * vertices[i + 1][1]) - (vertices[i + 1][0] * vertices[i][1])\n\n    area += (vertices[n - 1][0] * vertices[0][1]) - (vertices[0][0] * vertices[n - 1][1])\n\n    return abs(area)",
        "test_list": [
            "assert main(4,[1,1],[4,2],[3,5],[1,4]) == 16\n",
            "assert main(3,[0,0],[0,1],[1,0]) == 1\n",
            "assert main(3,[-1,0],[0,1],[1,0]) == 1\n",
            "assert main(3,[0,0],[0,-1],[-1,0]) == 1\n",
            "assert main(4,[0,0],[0,1],[1,1],[1,0]) == 1\n"
        ]
    },
    {
        "link": "/problemset/task/2192",
        "title": "Point in Polygon",
        "content": "You are given a polygon of n vertices and a list of m points. Your task is to determine for each point if it is inside, outside or on the boundary of the polygon.\nThe polygon consists of n vertices (x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n). The vertices (x_i,y_i) and (x_{i+1},y_{i+1}) are adjacent for i=1,2,\\dots,n-1, and the vertices (x_1,y_1) and (x_n,y_n) are also adjacent.\nInput\nThe first input line has two integers n and m: the number of vertices in the polygon and the number of points.\nAfter this, there are n lines that describe the polygon. The ith such line has two integers x_i and y_i.\nYou may assume that the polygon is simple, i.e., it does not intersect itself.\nFinally, there are m lines that describe the points. Each line has two integers x and y.\nOutput\nFor each point, print \"INSIDE\", \"OUTSIDE\" or \"BOUNDARY\".\nConstraints\n\n3 \\le n,m \\le 1000\n1 \\le m \\le 1000\n-10^9 \\le x_i, y_i \\le 10^9\n-10^9 \\le x, y \\le 10^9\n\nExample\nInput:\n4 3\n1 1\n4 2\n3 5\n1 4\n2 3\n3 1\n1 3\n\nOutput:\nINSIDE\nOUTSIDE\nBOUNDARY\n",
        "sample1_input": "4,3,[1,1],[4,2],[3,5],[1,4],[2,3],[3,1],[1,3]",
        "sample1_output": "INSIDE\nOUTSIDE\nBOUNDARY\n",
        "sample2_input": "3,3,[0,0],[0,1],[1,0],[-1,0],[-1,1],[2,2]",
        "sample2_output": "BOUNDARY\nOUTSIDE\nINSIDE\n",
        "sample3_input": "4,4,[0,0],[1,0],[1,1],[0,1],[2,2],[-1,-1],[2,0],[-2,-2]",
        "sample3_output": "INSIDE\nOUTSIDE\nINSIDE\nOUTSIDE\n",
        "sample4_input": "5,5,[0,0],[1,0],[1,1],[0,1],[2,2],[-1,-1],[2,0],[-2,-2],[1.5,1.5],[0.5,0.5]",
        "sample4_output": "INSIDE\nOUTSIDE\nINSIDE\nOUTSIDE\nBOUNDARY\n",
        "sample5_input": "4,4,[0,0],[1,0],[1,1],[0,1],[2,2],[-1,-1],[2,0],[-2,-2],[1.5,1.5],[0.5,0.5]",
        "sample5_output": "INSIDE\nOUTSIDE\nINSIDE\nOUTSIDE\nBOUNDARY\n",
        "task_id": 138,
        "code": "def is_inside_polygon(vertices, point):\n    n = len(vertices)\n    x, y = point\n    odd_nodes = False\n\n    j = n - 1\n    for i in range(n):\n        xi, yi = vertices[i]\n        xj, yj = vertices[j]\n        if yi < y and yj >= y or yj < y and yi >= y:\n            if xi + (y - yi) / (yj - yi) * (xj - xi) < x:\n                odd_nodes = not odd_nodes\n        j = i\n\n    return 'INSIDE' if odd_nodes else 'OUTSIDE'\n\n\ndef main(n, m, polygon, points):\n    result = []\n    for point in points:\n        result.append(is_inside_polygon(polygon, point))\n    return result",
        "test_list": [
            "assert main(4,3,[1,1],[4,2],[3,5],[1,4],[2,3],[3,1],[1,3]) == INSIDE\nOUTSIDE\nBOUNDARY\n",
            "assert main(3,3,[0,0],[0,1],[1,0],[-1,0],[-1,1],[2,2]) == BOUNDARY\nOUTSIDE\nINSIDE\n",
            "assert main(4,4,[0,0],[1,0],[1,1],[0,1],[2,2],[-1,-1],[2,0],[-2,-2]) == INSIDE\nOUTSIDE\nINSIDE\nOUTSIDE\n",
            "assert main(5,5,[0,0],[1,0],[1,1],[0,1],[2,2],[-1,-1],[2,0],[-2,-2],[1.5,1.5],[0.5,0.5]) == INSIDE\nOUTSIDE\nINSIDE\nOUTSIDE\nBOUNDARY\n",
            "assert main(4,4,[0,0],[1,0],[1,1],[0,1],[2,2],[-1,-1],[2,0],[-2,-2],[1.5,1.5],[0.5,0.5]) == INSIDE\nOUTSIDE\nINSIDE\nOUTSIDE\nBOUNDARY\n"
        ]
    },
    {
        "link": "/problemset/task/2194",
        "title": "Minimum Euclidean Distance",
        "content": "Given a set of points in the two-dimensional plane, your task is to find the minimum Euclidean distance between two distinct points.\nThe Euclidean distance of points (x_1,y_1) and (x_2,y_2) is \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}.\nInput\nThe first input line has an integer n: the number of points.\nAfter this, there are n lines that describe the points. Each line has two integers x and y. You may assume that each point is distinct.\nOutput\nPrint one integer: d^2 where d is the minimum Euclidean distance (this ensures that the result is an integer).\nConstraints\n\n2 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le x,y \\le 10^9\n\nExample\nInput:\n4\n2 1\n4 4\n1 2\n6 3\n\nOutput:\n2\n",
        "sample1_input": "4,[2,1],[4,4],[1,2],[6,3]",
        "sample1_output": "2\n",
        "sample2_input": "3,[0,0],[1,1],[2,2]",
        "sample2_output": "2\n",
        "sample3_input": "5,[-1,-1],[0,0],[1,1],[2,2],[3,3]",
        "sample3_output": "2\n",
        "sample4_input": "5,[-1,1],[-2,2],[0,0],[2,-2],[1,-1]",
        "sample4_output": "2\n",
        "sample5_input": "2,[-1,-1],[1,1]",
        "sample5_output": "8\n",
        "task_id": 139,
        "code": "import math\n\ndef main(n, points):\n    def euclidean_distance(p1, p2):\n        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    min_distance = float('inf')\n\n    # Iterate through all pairs of distinct points\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = euclidean_distance(points[i], points[j])\n            min_distance = min(min_distance, distance)\n\n    return min_distance",
        "test_list": [
            "assert main(4,[2,1],[4,4],[1,2],[6,3]) == 2\n",
            "assert main(3,[0,0],[1,1],[2,2]) == 2\n",
            "assert main(5,[-1,-1],[0,0],[1,1],[2,2],[3,3]) == 2\n",
            "assert main(5,[-1,1],[-2,2],[0,0],[2,-2],[1,-1]) == 2\n",
            "assert main(2,[-1,-1],[1,1]) == 8\n"
        ]
    },
    {
        "link": "/problemset/task/1628",
        "title": "Meet in the Middle",
        "content": "You are given an array of n numbers. In how many ways can you choose a subset of the numbers with sum x?\nInput\nThe first input line has two numbers n and x: the array size and the required sum.\nThe second line has n integers t_1,t_2,\\dots,t_n: the numbers in the array.\nOutput\nPrint the number of ways you can create the sum x.\nConstraints\n\n1 \\le n \\le 40\n1 \\le x \\le 10^9\n1 \\le t_i \\le 10^9\n\nExample\nInput:\n4 5\n1 2 3 2\n\nOutput:\n3\n",
        "sample1_input": "4,5,[1,2,3,2]",
        "sample1_output": "3\n",
        "sample2_input": "5,10,[2,2,2,2,2]",
        "sample2_output": "1\n",
        "sample3_input": "5,5,[1,2,3,4,5]",
        "sample3_output": "3\n",
        "sample4_input": "4,8,[1,2,3,4]",
        "sample4_output": "2\n",
        "sample5_input": "3,5,[5,5,5]",
        "sample5_output": "1\n",
        "task_id": 140,
        "code": "def main(n, x, nums):\n    def count_subsets_with_sum(nums, n, x):\n        dp = [[0] * (x + 1) for _ in range(n + 1)]\n\n        # Initialize the first column to 1, as there is always an empty subset with sum 0.\n        for i in range(n + 1):\n            dp[i][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, x + 1):\n                if nums[i - 1] <= j:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][x]\n\n    return count_subsets_with_sum(nums, n, x)",
        "test_list": [
            "assert main(4,5,[1,2,3,2]) == 3\n",
            "assert main(5,10,[2,2,2,2,2]) == 1\n",
            "assert main(5,5,[1,2,3,4,5]) == 3\n",
            "assert main(4,8,[1,2,3,4]) == 2\n",
            "assert main(3,5,[5,5,5]) == 1\n"
        ]
    },
    {
        "link": "/problemset/task/2136",
        "title": "Hamming Distance",
        "content": "The Hamming distance between two strings a and b of equal length is the number of positions where the strings differ.\nYou are given n bit strings, each of length k and your task is to calculate the minimum Hamming distance between two strings. \nInput\nThe first input line has two integers n and k: the number of bit strings and their length. \nThen there are n lines each consisting of one bit string of length k.\nOutput\nPrint the minimum Hamming distance between two strings.\nConstraints\n\n2 \\le n \\le 2 \\cdot 10^4\n1 \\le k \\le 30\n\nExample\nInput:\n5 6\n110111\n001000\n100001\n101000\n101110\n\nOutput:\n1\n\nExplanation: The strings 101000 and 001000 differ only at the first position.\n",
        "sample1_input": "5,6,[\"110111\",\"001000\",\"100001\",\"101000\",\"101110\"]",
        "sample1_output": "1\n",
        "sample2_input": "4,3,[\"101\",\"110\",\"010\",\"011\"]",
        "sample2_output": "1\n",
        "sample3_input": "3,5,[\"10010\",\"01000\",\"00101\"]",
        "sample3_output": "3\n",
        "sample4_input": "2,2,[\"10\",\"01\"]",
        "sample4_output": "2\n",
        "sample5_input": "6,4,[\"1110\",\"0110\",\"1010\",\"0101\",\"1100\",\"0010\"]",
        "sample5_output": "1\n",
        "task_id": 141,
        "code": "def main(n, k, bit_strings):\n    min_hamming_distance = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            hamming_distance = sum(1 for a, b in zip(bit_strings[i], bit_strings[j]) if a != b)\n            min_hamming_distance = min(min_hamming_distance, hamming_distance)\n\n    return min_hamming_distance",
        "test_list": [
            "assert main(5,6,[\"110111\",\"001000\",\"100001\",\"101000\",\"101110\"]) == 1\n",
            "assert main(4,3,[\"101\",\"110\",\"010\",\"011\"]) == 1\n",
            "assert main(3,5,[\"10010\",\"01000\",\"00101\"]) == 3\n",
            "assert main(2,2,[\"10\",\"01\"]) == 2\n",
            "assert main(6,4,[\"1110\",\"0110\",\"1010\",\"0101\",\"1100\",\"0010\"]) == 1\n"
        ]
    },
    {
        "link": "/problemset/task/2137",
        "title": "Beautiful Subgrids",
        "content": "You are given an n \\times n grid whose each square is either black or white. A subgrid is called beautiful if its height and width is at least two and all of its corners are black. How many beautiful subgrids are there within the given grid?\nInput\nThe first input line has an integer n: the size of the grid.\nThen there are n lines describing the grid: 1 means that a square is black and 0 means it is white.\nOutput\nPrint the number of beautiful subgrids.\nConstraints\n\n1 \\le n \\le 3000\n\nExample\nInput:\n5\n00010\n11111\n00110\n11001\n00010\n\nOutput:\n4\n",
        "sample1_input": "5,[\"00010\",\"11111\",\"00110\",\"11001\",\"00010\"",
        "sample1_output": "4\n",
        "sample2_input": "3,[\"100\",\"011\",\"000\"]",
        "sample2_output": "0\n",
        "sample3_input": "4,[\"1100\",\"1100\",\"0011\"\"0011\"]",
        "sample3_output": "4\n",
        "sample4_input": "6,[\"110011\",\"111111\",\"001100\",\"110011\",\"111111\",\"000000\"]",
        "sample4_output": "12\n",
        "sample5_input": "2,[\"11\",\"11\"]",
        "sample5_output": "1\n",
        "task_id": 142,
        "code": "def main(n, grid):\n    count = 0\n\n    for i in range(n - 1):\n        for j in range(n - 1):\n            if grid[i][j] == 1 and grid[i][j + 1] == 1 and grid[i + 1][j] == 1 and grid[i + 1][j + 1] == 1:\n                count += 1\n\n    return count",
        "test_list": [
            "assert main(5,[\"00010\",\"11111\",\"00110\",\"11001\",\"00010\") == 4\n",
            "assert main(3,[\"100\",\"011\",\"000\"]) == 0\n",
            "assert main(4,[\"1100\",\"1100\",\"0011\"\"0011\"]) == 4\n",
            "assert main(6,[\"110011\",\"111111\",\"001100\",\"110011\",\"111111\",\"000000\"]) == 12\n",
            "assert main(2,[\"11\",\"11\"]) == 1\n"
        ]
    },
    {
        "link": "/problemset/task/2143",
        "title": "Reachability Queries",
        "content": "A directed graph consists of n nodes and m edges. The edges are numbered 1,2,\\dots,n.\nYour task is to answer q queries of the form \"can you reach node b from node a?\"\nInput\nThe first input line has three integers n, m and q: the number of nodes, edges and queries.\nThen there are m lines describing the edges. Each line has two distinct integers a and b: there is an edge from node a to node b.\nFinally there are q lines describing the queries. Each line consists of two integers a and b: \"can you reach node b from node a?\"\nOutput\nPrint the answer for each query: either \"YES\" or \"NO\".\nConstraints\n\n1 \\le n \\le 5 \\cdot 10^4\n1 \\le m,q \\le 10^5\n\nExample\nInput:\n4 4 3\n1 2\n2 3\n3 1\n4 3\n1 3\n1 4\n4 1\n\nOutput:\nYES\nNO\nYES\n",
        "sample1_input": "4,4,3,[1,2],[2,3],[3,1],[4,3],[1,3],[1,4],[4,1]",
        "sample1_output": "YES\nNO\nYES\n",
        "sample2_input": "3,2,2,[1,2],[2,3],[1,3],[2,1]",
        "sample2_output": "YES\nNO\n",
        "sample3_input": "5,4,3,[1,2],[2,3],[3,4],[4,5],[1,5],[2,5],[4,1]",
        "sample3_output": "YES\nYES\nYES\n",
        "sample4_input": "5,4,2,[1,2],[2,3],[3,4],[4,5],[1,5],[2,5]",
        "sample4_output": "NO\nNO\n",
        "sample5_input": "6,6,1,[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],[1,6]",
        "sample5_output": "YES\n",
        "task_id": 143,
        "code": "def main(n, m, q, edges, queries):\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a - 1].append(b - 1)\n\n    def can_reach(a, b):\n        nonlocal graph\n        visited = [False] * n\n        stack = [a - 1]\n\n        while stack:\n            node = stack.pop()\n            visited[node] = True\n            if node == b - 1:\n                return 'YES'\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n\n        return 'NO'\n\n    results = [can_reach(a, b) for a, b in queries]\n    return results",
        "test_list": [
            "assert main(4,4,3,[1,2],[2,3],[3,1],[4,3],[1,3],[1,4],[4,1]) == YES\nNO\nYES\n",
            "assert main(3,2,2,[1,2],[2,3],[1,3],[2,1]) == YES\nNO\n",
            "assert main(5,4,3,[1,2],[2,3],[3,4],[4,5],[1,5],[2,5],[4,1]) == YES\nYES\nYES\n",
            "assert main(5,4,2,[1,2],[2,3],[3,4],[4,5],[1,5],[2,5]) == NO\nNO\n",
            "assert main(6,6,1,[1,2],[2,3],[3,4],[4,5],[5,6],[6,1],[1,6]) == YES\n"
        ]
    },
    {
        "link": "/problemset/task/2072",
        "title": "Cut and Paste",
        "content": "Given a string, your task is to process operations where you cut a substring and paste it to the end of the string. What is the final string after all the operations?\nInput\nThe first input line has two integers n and m: the length of the string and the number of operations. The characters of the string are numbered 1,2,\\dots,n.\nThe next line has a string of length n that consists of characters A–Z.\nFinally, there are m lines that describe the operations. Each line has two integers a and b: you cut a substring from position a to position b.\nOutput\nPrint the final string after all the operations.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n1 \\le a \\le b \\le n\n\nExample\nInput:\n7 2\nAYBABTU\n3 5\n3 5\n\nOutput:\nAYABTUB\n",
        "sample1_input": "7,2,\"AYBABTU\",[(3,5),(3,5)]",
        "sample1_output": "AYABTUB\n",
        "sample2_input": "5,3,\"HELLO\",[(1,2),(2,3),(3,5)]",
        "sample2_output": "LLOHE\n",
        "sample3_input": "10,4,\"ABCDEFGHIJ\",[(1,3),(4,7),(2,8),(5,10)]",
        "sample3_output": "BCDEFGHIJAF\n",
        "sample4_input": "6,1,\"ABCDE\",[(2,6)]",
        "sample4_output": "BCDEA\n",
        "sample5_input": "8,2,\"SLEEPING\",[(2,5),(6,8)]",
        "sample5_output": "EEPSLING\n",
        "task_id": 144,
        "code": "def main(n, m, s, operations):\n    # Initialize a list to represent the string as characters\n    result = list(s)\n\n    for a, b in operations:\n        # Extract the substring to cut\n        substring = result[a - 1:b]\n        # Remove the extracted substring from the result\n        del result[a - 1:b]\n        # Append the extracted substring to the end of the result\n        result.extend(substring)\n\n    # Join the characters in the result list to form the final string\n    final_string = ''.join(result)\n    return final_string",
        "test_list": [
            "assert main(7,2,\"AYBABTU\",[(3,5),(3,5)]) == AYABTUB\n",
            "assert main(5,3,\"HELLO\",[(1,2),(2,3),(3,5)]) == LLOHE\n",
            "assert main(10,4,\"ABCDEFGHIJ\",[(1,3),(4,7),(2,8),(5,10)]) == BCDEFGHIJAF\n",
            "assert main(6,1,\"ABCDE\",[(2,6)]) == BCDEA\n",
            "assert main(8,2,\"SLEEPING\",[(2,5),(6,8)]) == EEPSLING\n"
        ]
    },
    {
        "link": "/problemset/task/2073",
        "title": "Substring Reversals",
        "content": "Given a string, your task is to process operations where you reverse a substring of the string. What is the final string after all the operations?\nInput\nThe first input line has two integers n and m: the length of the string and the number of operations. The characters of the string are numbered 1,2,\\dots,n.\nThe next line has a string of length n that consists of characters A–Z.\nFinally, there are m lines that describe the operations. Each line has two integers a and b: you reverse a substring from position a to position b.\nOutput\nPrint the final string after all the operations.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n1 \\le a \\le b \\le n\n\nExample\nInput:\n7 2\nAYBABTU\n3 4\n4 7\n\nOutput:\nAYAUTBB\n",
        "sample1_input": "7,2,\"AYBABTU\",[(3,4),(4,7)]",
        "sample1_output": "AYAUTBB\n",
        "sample2_input": "5,3,\"HELLO\",[(1,2),(2,3),(3,5)",
        "sample2_output": "OLHLE\n",
        "sample3_input": "10,4,\"ABCDEFGHIJ\",[(1,3),(4,7),(2,8),(5,10)]",
        "sample3_output": "CBAGFEDJIH\n",
        "sample4_input": "6,1,\"ABCDE\",[(2,6)]",
        "sample4_output": "AEDCBA\n",
        "sample5_input": "8,2,\"SLEEPING\",[(2,5),(6,8)]",
        "sample5_output": "LEESPINB\n",
        "task_id": 145,
        "code": "def main(n, m, s, operations):\n    # Initialize a list to represent the string as characters\n    result = list(s)\n\n    for a, b in operations:\n        # Reverse the substring from position a to position b\n        result[a - 1:b] = reversed(result[a - 1:b])\n\n    # Join the characters in the result list to form the final string\n    final_string = ''.join(result)\n    return final_string",
        "test_list": [
            "assert main(7,2,\"AYBABTU\",[(3,4),(4,7)]) == AYAUTBB\n",
            "assert main(5,3,\"HELLO\",[(1,2),(2,3),(3,5)) == OLHLE\n",
            "assert main(10,4,\"ABCDEFGHIJ\",[(1,3),(4,7),(2,8),(5,10)]) == CBAGFEDJIH\n",
            "assert main(6,1,\"ABCDE\",[(2,6)]) == AEDCBA\n",
            "assert main(8,2,\"SLEEPING\",[(2,5),(6,8)]) == LEESPINB\n"
        ]
    },
    {
        "link": "/problemset/task/2074",
        "title": "Reversals and Sums",
        "content": "Given an array of n integers, you have to process following operations:\n\nreverse a subarray\ncalculate the sum of values in a subarray\n\nInput\nThe first input line has two integers n and m: the size of the array and the number of operations. The array elements are numbered 1,2,\\dots,n.\nThe next line as n integers x_1,x_2,\\dots,x_n: the contents of the array.\nFinally, there are m lines that describe the operations. Each line has three integers t, a and b. If t=1, you should reverse a subarray from a to b. If t=2, you should calculate the sum of values from a to b.\nOutput\nPrint the answer to each operation where t=2.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le m \\le 10^5\n0 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 3\n2 1 3 4 5 3 4 4\n2 2 4\n1 3 6\n2 2 4\n\nOutput:\n8\n9\n",
        "sample1_input": "8,3,[2,1,3,4,5,3,4,4],[2,2,4],[1,3,6],[2,2,4]",
        "sample1_output": "8\n9\n",
        "sample2_input": "5,2,[5,4,3,2,1],[2,1,5],[1,2,4]",
        "sample2_output": "15\n4\n",
        "sample3_input": "10,4,[1,2,3,4,5,6,7,8,9,10],[2,2,5],[1,3,6],[2,1,10],[1,4,8]",
        "sample3_output": "14\n45\n30\n",
        "sample4_input": "3,3,[10,20,30],[2,1,2],[1,1,3],[2,1,3]",
        "sample4_output": "30\n10\n60\n",
        "sample5_input": "6,1,[1,2,3,4,5,6],[2,2,5]",
        "sample5_output": "14\n",
        "task_id": 146,
        "code": "def main(n, m, arr, operations):\n    result = []\n    for t, a, b in operations:\n        if t == 1:\n            # Reverse a subarray from a to b\n            arr[a - 1:b] = reversed(arr[a - 1:b])\n        elif t == 2:\n            # Calculate the sum of values from a to b\n            result.append(sum(arr[a - 1:b]))\n    return result",
        "test_list": [
            "assert main(8,3,[2,1,3,4,5,3,4,4],[2,2,4],[1,3,6],[2,2,4]) == 8\n9\n",
            "assert main(5,2,[5,4,3,2,1],[2,1,5],[1,2,4]) == 15\n4\n",
            "assert main(10,4,[1,2,3,4,5,6,7,8,9,10],[2,2,5],[1,3,6],[2,1,10],[1,4,8]) == 14\n45\n30\n",
            "assert main(3,3,[10,20,30],[2,1,2],[1,1,3],[2,1,3]) == 30\n10\n60\n",
            "assert main(6,1,[1,2,3,4,5,6],[2,2,5]) == 14\n"
        ]
    },
    {
        "link": "/problemset/task/2078",
        "title": "Eulerian Subgraphs",
        "content": "You are given an undirected graph that has n nodes and m edges.\nWe consider subgraphs that have all nodes of the original graph and some of its edges. A subgraph is called Eulerian if each node has even degree.\nYour task is to count the number of Eulerian subgraphs modulo 10^9+7.\nInput\nThe first input line has two integers n and m: the number of nodes and edges. The nodes are numbered 1,2,\\dots,n.\nAfter this, there are m lines that describe the edges. Each line has two integers a and b: there is an edge between nodes a and b. There is at most one edge between two nodes, and each edge connects two distinct nodes.\nOutput\nPrint the number of Eulerian subgraphs modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n0 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 3\n1 2\n1 3\n2 3\n\nOutput:\n2\n\nExplanation: You can either keep or remove all edges, so there are two possible Eulerian subgraphs.\n",
        "sample1_input": "4,3,[1,2],[1,3],[2,3]",
        "sample1_output": "2\n",
        "sample2_input": "5,7,[1,2],[1,3],[2,3],[2,4],[3,4],[4,5],[5,1]",
        "sample2_output": "16\n",
        "sample3_input": "3,2,[1,2],[2,3]",
        "sample3_output": "4\n",
        "sample4_input": "6,0",
        "sample4_output": "64\n",
        "sample5_input": "2,1,[1,2]",
        "sample5_output": "1\n",
        "task_id": 147,
        "code": "def main(n, m, edges):\n    MOD = 10**9 + 7\n\n    # Initialize a list to store the degrees of nodes\n    degrees = [0] * n\n\n    # Count the degrees of nodes based on the edges\n    for a, b in edges:\n        degrees[a - 1] += 1\n        degrees[b - 1] += 1\n\n    # Count the number of nodes with odd degrees\n    odd_degrees = sum(1 for degree in degrees if degree % 2 == 1)\n\n    # Calculate the number of Eulerian subgraphs modulo 10^9+7\n    # The result is 2^(number of nodes with odd degrees) modulo MOD\n    result = pow(2, odd_degrees, MOD)\n\n    return result",
        "test_list": [
            "assert main(4,3,[1,2],[1,3],[2,3]) == 2\n",
            "assert main(5,7,[1,2],[1,3],[2,3],[2,4],[3,4],[4,5],[5,1]) == 16\n",
            "assert main(3,2,[1,2],[2,3]) == 4\n",
            "assert main(6,0) == 64\n",
            "assert main(2,1,[1,2]) == 1\n"
        ]
    },
    {
        "link": "/problemset/task/2084",
        "title": "Monster Game I",
        "content": "You are playing a game that consists of n levels. Each level has a monster. On levels 1,2,\\dots,n-1, you can either kill or escape the monster. However, on level n you must kill the final monster to win the game.\nKilling a monster takes sf time where s is the monster's strength and f is your skill factor (lower skill factor is better). After killing a monster, you get a new skill factor. What is the minimum total time in which you can win the game?\nInput\nThe first input line has two integers n and x: the number of levels and your initial skill factor.\nThe second line has n integers s_1,s_2,\\dots,s_n: each monster's strength.\nThe third line has n integers f_1,f_2,\\dots,f_n: your new skill factor after killing a monster.\nOutput\nPrint one integer: the minimum total time to win the game.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x \\le 10^6\n1 \\le s_1 \\le s_2 \\le \\dots \\le s_n \\le 10^6\nx \\ge f_1 \\ge f_2 \\ge \\dots \\ge f_n \\ge 1\n\nExample\nInput:\n5 100\n20 30 30 50 90\n90 60 20 20 10\n\nOutput:\n4800\n\nExplanation: The best way to play is to kill the third and fifth monster.\n",
        "sample1_input": "5,100,[20,30,30,50,90],[90,60,20,20,10]",
        "sample1_output": "4800\n",
        "sample2_input": "3,10,[10,20,30],[10,5,1]",
        "sample2_output": "160\n",
        "sample3_input": "2,5,[100,200],[5,1]",
        "sample3_output": "1000\n",
        "sample4_input": "4,100,[10,20,30,40],[50,40,30,20]",
        "sample4_output": "5000\n",
        "sample5_input": "1,1,[1000],[1]",
        "sample5_output": "1000\n",
        "task_id": 148,
        "code": "def main(n, x, strengths, factors):\n    min_time = 0\n    for i in range(n):\n        min_time += strengths[i] * factors[i]\n        x = min(x, factors[i])\n    return min_time",
        "test_list": [
            "assert main(5,100,[20,30,30,50,90],[90,60,20,20,10]) == 4800\n",
            "assert main(3,10,[10,20,30],[10,5,1]) == 160\n",
            "assert main(2,5,[100,200],[5,1]) == 1000\n",
            "assert main(4,100,[10,20,30,40],[50,40,30,20]) == 5000\n",
            "assert main(1,1,[1000],[1]) == 1000\n"
        ]
    },
    {
        "link": "/problemset/task/2085",
        "title": "Monster Game II",
        "content": "You are playing a game that consists of n levels. Each level has a monster. On levels 1,2,\\dots,n-1, you can either kill or escape the monster. However, on level n you must kill the final monster to win the game.\nKilling a monster takes sf time where s is the monster's strength and f is your skill factor. After killing a monster, you get a new skill factor  (lower skill factor is better). What is the minimum total time in which you can win the game?\nInput\nThe first input line has two integers n and x: the number of levels and your initial skill factor.\nThe second line has n integers s_1,s_2,\\dots,s_n: each monster's strength.\nThe third line has n integers f_1,f_2,\\dots,f_n: your new skill factor after killing a monster.\nOutput\nPrint one integer: the minimum total time to win the game.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x \\le 10^6\n1 \\le s_i, f_i \\le 10^6\n\nExample\nInput:\n5 100\n50 20 30 90 30\n60 20 20 10 90\n\nOutput:\n2600\n\nExplanation: The best way to play is to kill the second and fifth monster.\n",
        "sample1_input": "5,100,[50,20,30,90,30],[60,20,20,10,90]",
        "sample1_output": "2600\n",
        "sample2_input": "3,10,[10,20,30],[10,5,1]",
        "sample2_output": "160\n",
        "sample3_input": "2,5,[100,200],[5,1]",
        "sample3_output": "1000\n",
        "sample4_input": "4,100,[10,20,30,40],[50,40,30,20]",
        "sample4_output": "5000\n",
        "sample5_input": "1,1,[1000],[1]",
        "sample5_output": "1000\n",
        "task_id": 149,
        "code": "def main(n, x, strengths, factors):\n    min_time = 0\n    for i in range(n):\n        min_time += strengths[i] * factors[i]\n        x = min(x, factors[i])\n    return min_time",
        "test_list": [
            "assert main(5,100,[50,20,30,90,30],[60,20,20,10,90]) == 2600\n",
            "assert main(3,10,[10,20,30],[10,5,1]) == 160\n",
            "assert main(2,5,[100,200],[5,1]) == 1000\n",
            "assert main(4,100,[10,20,30,40],[50,40,30,20]) == 5000\n",
            "assert main(1,1,[1000],[1]) == 1000\n"
        ]
    },
    {
        "link": "/problemset/task/2086",
        "title": "Subarray Squares",
        "content": "Given an array of n elements, your task is to divide into k subarrays. The cost of each subarray is the square of the sum of the values in the subarray. What is the minimum total cost if you act optimally?\nInput\nThe first input line has two integers n and k: the array elements and the number of subarrays. The array elements are numbered 1,2,\\dots,n.\nThe second line has n integers x_1,x_2,\\dots,x_n: the contents of the array.\nOutput\nPrint one integer: the minimum total cost.\nConstraints\n\n1 \\le k \\le n \\le 3000\n1 \\le x_i \\le 10^5\n\nExample\nInput:\n8 3\n2 3 1 2 2 3 4 1\n\nOutput:\n110\n\nExplanation: An optimal solution is [2,3,1], [2,2,3], [4,1], whose cost is (2+3+1)^2+(2+2+3)^2+(4+1)^2=110.\n",
        "sample1_input": "8,3,[2,3,1,2,2,3,4,1]",
        "sample1_output": "110\n",
        "sample2_input": "5,2,[1,2,3,4,5]",
        "sample2_output": "46\n",
        "sample3_input": "6,1,[10,20,30,40,50,60]",
        "sample3_output": "44100\n",
        "sample4_input": "10,5,[1,2,3,4,5,6,7,8,9,10]",
        "sample4_output": "805\n",
        "sample5_input": "7,4,[3,2,3,2,3,1,3]",
        "sample5_output": "101\n",
        "task_id": 150,
        "code": "def main(n, k, arr):\n    dp = [[float('inf')] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 0\n    prefix = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] + arr[i - 1]\n\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            for x in range(j):\n                cost = (prefix[j] - prefix[x]) ** 2 + dp[i - 1][x]\n                dp[i][j] = min(dp[i][j], cost)\n\n    return dp[k][n]",
        "test_list": [
            "assert main(8,3,[2,3,1,2,2,3,4,1]) == 110\n",
            "assert main(5,2,[1,2,3,4,5]) == 46\n",
            "assert main(6,1,[10,20,30,40,50,60]) == 44100\n",
            "assert main(10,5,[1,2,3,4,5,6,7,8,9,10]) == 805\n",
            "assert main(7,4,[3,2,3,2,3,1,3]) == 101\n"
        ]
    },
    {
        "link": "/problemset/task/2087",
        "title": "Houses and Schools",
        "content": "There are n houses on a street, numbered 1,2,\\dots,n. The distance of houses a and b is |a-b|. You know the number of children in each house.\nYour task is to establish k schools in such a way that each school is in some house. Then, each child goes to the nearest school. What is the minimum total walking distance of the children if you act optimally?\nInput\nThe first input line has two integers n and k: the number of houses and the number of schools. The houses are numbered 1,2\\dots,n.\nAfter this, there are n integers c_1,c_2,\\dots,c_n: the number of children in each house.\nOutput\nPrint the minimum total distance.\nConstraints\n\n1 \\le k \\le n \\le 3000\n1 \\le c_i \\le 10^9\n\nExample\nInput:\n6 2\n2 7 1 4 6 4\n\nOutput:\n11\n\nExplanation: Houses 2 and 5 will have schools.\n",
        "sample1_input": "6,2,[2,7,1,4,6,4]",
        "sample1_output": "11\n",
        "sample2_input": "5,1,[5,5,5,5,5]",
        "sample2_output": "0\n",
        "sample3_input": "7,3,[1,1,1,1,1,1,100]",
        "sample3_output": "196\n",
        "sample4_input": "8,4,[1,2,3,4,5,6,7,8]",
        "sample4_output": "20\n",
        "sample5_input": "4,1,[10,20,30,40]",
        "sample5_output": "60\n",
        "task_id": 151,
        "code": "def main(n, k, children):\n    children.sort()\n    schools = [0] * (n - k + 1)\n\n    for i in range(n - k + 1):\n        schools[i] = children[i + k - 1] - children[i]\n\n    min_distance = children[-1] - children[0]\n\n    for i in range(n - k + 1):\n        min_distance -= schools[i]\n\n    return min_distance",
        "test_list": [
            "assert main(6,2,[2,7,1,4,6,4]) == 11\n",
            "assert main(5,1,[5,5,5,5,5]) == 0\n",
            "assert main(7,3,[1,1,1,1,1,1,100]) == 196\n",
            "assert main(8,4,[1,2,3,4,5,6,7,8]) == 20\n",
            "assert main(4,1,[10,20,30,40]) == 60\n"
        ]
    },
    {
        "link": "/problemset/task/2088",
        "title": "Knuth Division",
        "content": "Given an array of n numbers, your task is to divide it into n subarrays, each of which has a single element.\nOn each move, you may choose any subarray and split it into two subarrays. The cost of such a move is the sum of values in the chosen subarray.\nWhat is the minimum total cost if you act optimally?\nInput\nThe first input line has an integer n: the array size. The array elements are numbered 1,2,\\dots,n.\nThe second line has n integers x_1,x_2,\\dots,x_n: the contents of the array.\nOutput\nPrint one integer: the minimum total cost.\nConstraints\n\n1 \\le n \\le 5000\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n2 7 3 2 5\n\nOutput:\n43\n",
        "sample1_input": "5,[2,7,3,2,5]",
        "sample1_output": "43\n",
        "sample2_input": "3,[10,20,30]",
        "sample2_output": "100\n",
        "sample3_input": "6,[5,5,5,5,5,5]",
        "sample3_output": "60\n",
        "sample4_input": "4,[1,2,3,4]",
        "sample4_output": "19\n",
        "sample5_input": "8,[8,7,6,5,4,3,2,1]",
        "sample5_output": "122\n",
        "task_id": 152,
        "code": "def main(n, arr):\n    arr.sort()\n    total_cost = 0\n\n    while len(arr) > 1:\n        subarray_sum = arr.pop(0)\n        total_cost += subarray_sum\n        arr[0] += subarray_sum\n        arr.sort()\n\n    return total_cost",
        "test_list": [
            "assert main(5,[2,7,3,2,5]) == 43\n",
            "assert main(3,[10,20,30]) == 100\n",
            "assert main(6,[5,5,5,5,5,5]) == 60\n",
            "assert main(4,[1,2,3,4]) == 19\n",
            "assert main(8,[8,7,6,5,4,3,2,1]) == 122\n"
        ]
    },
    {
        "link": "/problemset/task/2111",
        "title": "Apples and Bananas",
        "content": "There are apples and bananas and each of them has an integer weight between 1 \\ldots k. Your task is to calculate for each weight w between 2...2k the number of ways we can choose an apple and a banana whose combined weight is w.\nInput\nThe first input line contains three integers k, n and m: the number k, the number of apples and the number of bananas.\nThe next line contains n integers a_1,a_2,\\ldots,a_n: weight of each apple.\nThe last line contains m integers b_1,b_2,\\ldots,b_m: weight of each banana.\nOutput\nFor each integer w between 2 \\ldots 2k print the number of ways to choose an apple and a banana whose combined weight is w.\nConstraints\n\n1 \\le k,n,m \\le 2 \\cdot 10^5\n1 \\le a_i \\le k\n1 \\le b_i \\le k\n\nExample\nInput:\n5 3 4\n5 2 5\n4 3 2 3\n\nOutput:\n0 0 1 2 1 2 4 2 0  \n\nExplanation: For example for w = 8 there are 4 different ways: we can pick an apple of weight 5 in two different ways and a banana of weight 3 in two different ways.\n",
        "sample1_input": "5,3,4,[5,2,5],[4,3,2,3]",
        "sample1_output": "0 0 1 2 1 2 4 2 0\n",
        "sample2_input": "3,2,2,[2,3],[1,1]",
        "sample2_output": "0 0 1 1 1 0\n",
        "sample3_input": "4,4,3,[1,2,2,4],[1,2,4]",
        "sample3_output": "0 1 1 1 2 1 0 0 0\n",
        "sample4_input": "1,1,1,[1],[1]",
        "sample4_output": "0 1\n",
        "sample5_input": "5,5,5,[5,5,5,5,5],[5,5,5,5,5]",
        "sample5_output": "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n",
        "task_id": 153,
        "code": "def main(k, n, m, apples, bananas):\n    combined_weights = [0] * (2 * k + 1)\n\n    for apple_weight in apples:\n        for banana_weight in bananas:\n            combined_weight = apple_weight + banana_weight\n            combined_weights[combined_weight] += 1\n\n    return ' '.join(str(combined_weights[w]) for w in range(2, 2 * k + 1))",
        "test_list": [
            "assert main(5,3,4,[5,2,5],[4,3,2,3]) == 0 0 1 2 1 2 4 2 0\n",
            "assert main(3,2,2,[2,3],[1,1]) == 0 0 1 1 1 0\n",
            "assert main(4,4,3,[1,2,2,4],[1,2,4]) == 0 1 1 1 2 1 0 0 0\n",
            "assert main(1,1,1,[1],[1]) == 0 1\n",
            "assert main(5,5,5,[5,5,5,5,5],[5,5,5,5,5]) == 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n"
        ]
    },
    {
        "link": "/problemset/task/2112",
        "title": "One Bit Positions",
        "content": "You are given a binary string of length n and your task is to calculate for every k between 1 \\ldots n-1 the number of ways we can choose two positions i and j such that i-j=k and there is a one-bit at both positions.\nInput\nThe only input line has a string that consists only of characters 0 and 1.\nOutput\nFor every distance k between 1\\ldots n-1 print the number of ways we can choose two such positions.\nConstraints\n\n2 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n1001011010\n\nOutput:\n1 2 3 0 2 1 0 1 0\n",
        "sample1_input": "1001011010",
        "sample1_output": "1 2 3 0 2 1 0 1 0\n",
        "sample2_input": "110000000000",
        "sample2_output": "1 0 0 0 0 0 0 0 0 0\n",
        "sample3_input": "101010101010",
        "sample3_output": "1 1 1 1 1 1 1 1 1 1\n",
        "sample4_input": "1111111111",
        "sample4_output": "1 2 3 4 5 6 7 8 9\n",
        "sample5_input": "0000000000000",
        "sample5_output": "0 0 0 0 0 0 0 0 0 0 0 0\n",
        "task_id": 154,
        "code": "def main(binary_string):\n    n = len(binary_string)\n    count = [0] * (n - 1)\n\n    for k in range(1, n):\n        for i in range(n - k):\n            if binary_string[i] == '1' and binary_string[i + k] == '1':\n                count[k - 1] += 1\n\n    return ' '.join(map(str, count))",
        "test_list": [
            "assert main(1001011010) == 1 2 3 0 2 1 0 1 0\n",
            "assert main(110000000000) == 1 0 0 0 0 0 0 0 0 0\n",
            "assert main(101010101010) == 1 1 1 1 1 1 1 1 1 1\n",
            "assert main(1111111111) == 1 2 3 4 5 6 7 8 9\n",
            "assert main(0000000000000) == 0 0 0 0 0 0 0 0 0 0 0 0\n"
        ]
    },
    {
        "link": "/problemset/task/2113",
        "title": "Signal Processing",
        "content": "You are given two integer sequences: a signal and a mask. Your task is to process the signal by moving the mask through the signal from left to right. At each mask position calculate the sum of products of aligned signal and mask values in the part where the signal and the mask overlap.\nInput\nThe first input line consists of two integers n and m: the length of the signal and the length of the mask.\nThe next line consists of n integers a_1,a_2,\\ldots,a_n defining the signal.\nThe last line consists of m integers b_1,b_2,\\ldots,b_m defining the mask. \nOutput\nPrint n+m-1 integers: the sum of products of aligned values at each mask position from left to right.\nConstraints\n\n1 \\le n,m \\le 2 \\cdot 10^5\n1 \\le a_i,b_i \\le 100\n\nExample\nInput:\n5 3\n1 3 2 1 4\n1 2 3\n\nOutput:\n3 11 13 10 16 9 4\n\nExplanation: For example, at the second mask position the sum of aligned products is 2 \\cdot 1 + 3 \\cdot 3 = 11.\n",
        "sample1_input": "5,3,[1,3,2,1,4],[1,2,3]",
        "sample1_output": "3 11 13 10 16 9 4\n",
        "sample2_input": "4,2,[2,2,2,2],[1,2]",
        "sample2_output": "2 6 6 6 4\n",
        "sample3_input": "6,4,[1,1,1,1,1,1],[1,1,1,1]",
        "sample3_output": "1 2 3 4 4 4 3 2 1\n",
        "sample4_input": "3,3,[5,5,5],[1,2,3]",
        "sample4_output": "5 15 30 35 30 15 5\n",
        "sample5_input": "4,1,[2,2,2,2],[2]",
        "sample5_output": "4 4 4 4\n",
        "task_id": 155,
        "code": "def main(n, m, signal, mask):\n    result = [0] * (n + m - 1)\n\n    for i in range(n):\n        for j in range(m):\n            result[i + j] += signal[i] * mask[j]\n\n    return result",
        "test_list": [
            "assert main(5,3,[1,3,2,1,4],[1,2,3]) == 3 11 13 10 16 9 4\n",
            "assert main(4,2,[2,2,2,2],[1,2]) == 2 6 6 6 4\n",
            "assert main(6,4,[1,1,1,1,1,1],[1,1,1,1]) == 1 2 3 4 4 4 3 2 1\n",
            "assert main(3,3,[5,5,5],[1,2,3]) == 5 15 30 35 30 15 5\n",
            "assert main(4,1,[2,2,2,2],[2]) == 4 4 4 4\n"
        ]
    },
    {
        "link": "/problemset/task/2129",
        "title": "Task Assignment",
        "content": "A company has n employees and there are n tasks that need to be done. We know for each employee the cost of carrying out each task. Every employee should be assigned to exactly one task. What is the minimum total cost if we assign the tasks optimally and how could they be assigned?\nInput\nThe first input line has one integer n: the number of employees and the number of tasks that need to be done.\nAfter this, there are n lines each consisting of n integers. The ith line consists of integers c_{i1},c_{i2},\\ldots,c_{in}: the cost of each task when it is assigned to the ith employee.\nOutput\nFirst print the minimum total cost.\nThen print n lines each consisting of two integers a and b: you assign the bth task to the ath employee.\nIf there are multiple solutions you can print any of them.\nConstraints\n\n1 \\le n \\le 200\n1 \\le c_{ij} \\le 1000\n\nExample\nInput:\n4\n17 8 16 9\n7 15 12 19\n6 9 10 11\n14 7 13 10\n\nOutput:\n33\n1 4\n2 1\n3 3\n4 2\n\nExplanation: The minimum total cost is 33. We can reach this by assigning employee 1 task 4, employee 2 task 1, employee 3 task 3 and employee 4 task 2. This will cost 9 + 7 + 10 + 7 = 33.\n",
        "sample1_input": "4,[17,8,16,9],[7,15,12,19],[6,9,10,11],[14,7,13,10]",
        "sample1_output": "33\n1 4\n2 1\n3 3\n4 2\n",
        "sample2_input": "3,[10,5,8],[12,7,6],[8,2,6]",
        "sample2_output": "13\n1 2\n2 3\n3 1\n",
        "sample3_input": "5,[1,2,3,4,5],[5,4,3,2,1],[1,3,5,7,9],[3,2,5,8,6],[4,7,1,9,3],[5,6,2,8,4]",
        "sample3_output": "15\n1 3\n2 4\n3 5\n4 2\n5 1\n",
        "sample4_input": "2,[3,5],[6,2]",
        "sample4_output": "5\n1 2\n2 1\n",
        "sample5_input": "1,[1]",
        "sample5_output": "1\n1 1\n",
        "task_id": 156,
        "code": "def main(n, cost_matrix):\n    assignments = []\n    total_cost = 0\n\n    for i in range(n):\n        min_cost = float('inf')\n        assigned_task = -1\n\n        for j in range(n):\n            if cost_matrix[i][j] < min_cost:\n                min_cost = cost_matrix[i][j]\n                assigned_task = j\n\n        total_cost += min_cost\n        assignments.append((i + 1, assigned_task + 1))\n\n    return total_cost, assignments",
        "test_list": [
            "assert main(4,[17,8,16,9],[7,15,12,19],[6,9,10,11],[14,7,13,10]) == 33\n1 4\n2 1\n3 3\n4 2\n",
            "assert main(3,[10,5,8],[12,7,6],[8,2,6]) == 13\n1 2\n2 3\n3 1\n",
            "assert main(5,[1,2,3,4,5],[5,4,3,2,1],[1,3,5,7,9],[3,2,5,8,6],[4,7,1,9,3],[5,6,2,8,4]) == 15\n1 3\n2 4\n3 5\n4 2\n5 1\n",
            "assert main(2,[3,5],[6,2]) == 5\n1 2\n2 1\n",
            "assert main(1,[1]) == 1\n1 1\n"
        ]
    },
    {
        "link": "/problemset/task/1087",
        "title": "Shortest Subsequence",
        "content": "You are given a DNA sequence consisting of characters A, C, G, and T.\nYour task is to find the shortest DNA sequence that is not a subsequence of the original sequence.\nInput\nThe only input line contains a DNA sequence with n characters.\nOutput\nPrint the shortest DNA sequence that is not a subsequence of the original sequence. If there are several solutions, you may print any of them.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nACGTACGT\n\nOutput:\nAAA\n",
        "sample1_input": "ACGTACGT",
        "sample1_output": "AAC\n",
        "sample2_input": "AAAA",
        "sample2_output": "AAA\n",
        "sample3_input": "ACACACAC",
        "sample3_output": "AAC\n",
        "sample4_input": "GTTTTTTTTTTT",
        "sample4_output": "GTTTTTTTTTTA\n",
        "sample5_input": "CGTACGTACGTA",
        "sample5_output": "CGTACGTACGTAA\n",
        "task_id": 157,
        "code": "def main(s):\n    n = len(s)\n    ans = 'A'\n\n    for i in range(n):\n        if s[i] == ans[-1]:\n            if ans[-1] == 'A':\n                ans += 'C'\n            elif ans[-1] == 'C':\n                ans += 'G'\n            elif ans[-1] == 'G':\n                ans += 'T'\n            else:\n                ans += 'A'\n        else:\n            ans += s[i]\n\n    return ans[1:]",
        "test_list": [
            "assert main(ACGTACGT) == AAC\n",
            "assert main(AAAA) == AAA\n",
            "assert main(ACACACAC) == AAC\n",
            "assert main(GTTTTTTTTTTT) == GTTTTTTTTTTA\n",
            "assert main(CGTACGTACGTA) == CGTACGTACGTAA\n"
        ]
    },
    {
        "link": "/problemset/task/1146",
        "title": "Counting Bits",
        "content": "Your task is to count the number of one bits in the binary representations of integers between 1 and n.\nInput\nThe only input line has an integer n.\nOutput\nPrint the number of one bits in the binary representations of integers between 1 and n.\nConstraints\n\n1 \\le n \\le 10^{15}\n\nExample\nInput:\n7\n\nOutput:\n12\n\nExplanation: The binary representations of 1 \\ldots 7 are 1, 10, 11, 100, 101, 110, and 111, so there are a total of 12 one bits.\n",
        "sample1_input": "7",
        "sample1_output": "12\n",
        "sample2_input": "10",
        "sample2_output": "17\n",
        "sample3_input": "15",
        "sample3_output": "24\n",
        "sample4_input": "255",
        "sample4_output": "2040\n",
        "sample5_input": "10000000000000",
        "sample5_output": "42535295865160\n",
        "task_id": 158,
        "code": "def main(n):\n    count = 0\n    i = 1\n\n    while i <= n:\n        count += (n // (i * 2)) * i + max(0, n % (i * 2) - i + 1)\n        i *= 2\n\n    return count",
        "test_list": [
            "assert main(7) == 12\n",
            "assert main(10) == 17\n",
            "assert main(15) == 24\n",
            "assert main(255) == 2040\n",
            "assert main(10000000000000) == 42535295865160\n"
        ]
    },
    {
        "link": "/problemset/task/1670",
        "title": "Swap Game",
        "content": "You are given a 3 \\times 3 grid containing the numbers 1,2,\\dots,9. Your task is to perform a sequence of moves so that the grid will look like this:\n1 2 3\n4 5 6\n7 8 9\n\nOn each move, you can swap the numbers in any two adjacent squares (horizontally or vertically). What is the minimum number of moves required?\nInput\nThe input has three lines, and each of them has three integers.\nOutput\nPrint one integer: the minimum number of moves.\nExample\nInput:\n2 1 3\n7 5 9\n8 4 6\n\nOutput:\n4\n",
        "sample1_input": "2,1,3,[7,5,9],[8,4,6]",
        "sample1_output": "4\n",
        "sample2_input": "1,2,3,[4,5,6],[7,8,9]",
        "sample2_output": "0\n",
        "sample3_input": "9,8,7,[6,5,4],[3,2,1]",
        "sample3_output": "18\n",
        "sample4_input": "1,9,7,[3,6,5],[4,2,8]",
        "sample4_output": "12\n",
        "sample5_input": "5,2,9,[7,3,8],[1,4,6]",
        "sample5_output": "16\n",
        "task_id": 159,
        "code": "def main(grid):\n    target = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    moves = 0\n\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] != target[i][j]:\n                x, y = divmod(grid[i][j] - 1, 3)\n                grid[i][j], grid[x][y] = grid[x][y], grid[i][j]\n                moves += 1\n\n    return moves",
        "test_list": [
            "assert main(2,1,3,[7,5,9],[8,4,6]) == 4\n",
            "assert main(1,2,3,[4,5,6],[7,8,9]) == 0\n",
            "assert main(9,8,7,[6,5,4],[3,2,1]) == 18\n",
            "assert main(1,9,7,[3,6,5],[4,2,8]) == 12\n",
            "assert main(5,2,9,[7,3,8],[1,4,6]) == 16\n"
        ]
    },
    {
        "link": "/problemset/task/1756",
        "title": "Acyclic Graph Edges",
        "content": "Given an undirected graph, your task is to choose a direction for each edge so that the resulting directed graph is acyclic.\nInput\nThe first input line has two integers n and m: the number of nodes and edges. The nodes are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the edges. Each line has two distinct integers a and b: there is an edge between nodes a and b.\nOutput\nPrint m lines describing the directions of the edges. Each line has two integers a and b: there is an edge from node a to node b. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n3 3\n1 2\n2 3\n3 1\n\nOutput:\n1 2\n3 2\n3 1\n",
        "sample1_input": "3,3,[1,2],[2,3],[3,1]",
        "sample1_output": "1 2\n2 3\n3 1\n",
        "sample2_input": "4,4,[1,2],[2,3],[3,4],[4,1]",
        "sample2_output": "1 2\n2 3\n3 4\n4 1\n",
        "sample3_input": "5,5,[1,2],[2,3],[3,4],[4,5],[5,1]",
        "sample3_output": "1 2\n2 3\n3 4\n4 5\n5 1\n",
        "sample4_input": "4,3,[1,2],[2,3],[3,4]",
        "sample4_output": "1 2\n2 3\n3 4\n",
        "sample5_input": "5,4,[1,2],[2,3],[3,4],[4,5]",
        "sample5_output": "1 2\n2 3\n3 4\n4 5\n",
        "task_id": 160,
        "code": "def main(n, edges):\n    indegree = [0] * (n + 1)\n    directions = []\n    adj = [[] for _ in range(n + 1)]\n\n    for (a, b) in edges:\n        indegree[b] += 1\n        adj[a].append(b)\n\n    for i in range(1, n + 1):\n        for j in adj[i]:\n            if indegree[j] == 1:\n                directions.append((i, j))\n                indegree[j] -= 1\n                break\n\n    for i in range(1, n + 1):\n        for j in adj[i]:\n            if indegree[j] != 0:\n                directions.append((i, j))\n\n    return directions",
        "test_list": [
            "assert main(3,3,[1,2],[2,3],[3,1]) == 1 2\n2 3\n3 1\n",
            "assert main(4,4,[1,2],[2,3],[3,4],[4,1]) == 1 2\n2 3\n3 4\n4 1\n",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[5,1]) == 1 2\n2 3\n3 4\n4 5\n5 1\n",
            "assert main(4,3,[1,2],[2,3],[3,4]) == 1 2\n2 3\n3 4\n",
            "assert main(5,4,[1,2],[2,3],[3,4],[4,5]) == 1 2\n2 3\n3 4\n4 5\n"
        ]
    },
    {
        "link": "/problemset/task/2179",
        "title": "Even Outdegree Edges",
        "content": "Given an undirected graph, your task is to choose a direction for each edge so that in the resulting directed graph each node has an even outdegree. The outdegree of a node is the number of edges coming out of that node.\nInput\nThe first input line has two integers n and m: the number of nodes and edges. The nodes are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the edges. Each line has two integers a and b: there is an edge between nodes a and b.\nYou may assume that the graph is simple, i.e., there is at most one edge between any two nodes and every edge connects two distinct nodes.\nOutput\nPrint m lines describing the directions of the edges. Each line has two integers a and b: there is an edge from node a to node b. You can print any valid solution.\nIf there are no solutions, only print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 4\n1 2\n2 3\n3 4\n1 4\n\nOutput:\n1 2\n3 2\n3 4\n1 4\n",
        "sample1_input": "4,4,[1,2],[2,3],[3,4],[1,4]",
        "sample1_output": "1 2\n2 3\n3 4\n1 4\n",
        "sample2_input": "3,3,[1,2],[2,3],[1,3]",
        "sample2_output": "1 2\n2 3\n1 3\n",
        "sample3_input": "5,5,[1,2],[2,3],[3,4],[4,5],[5,1]",
        "sample3_output": "1 2\n2 3\n3 4\n4 5\n1 5\n",
        "sample4_input": "2,1,[1,2]",
        "sample4_output": "1 2\n",
        "sample5_input": "1,0",
        "sample5_output": "1 1\n",
        "task_id": 161,
        "code": "def main(n, edges):\n    if n == 1:\n        return [(1, 1)]\n\n    indegrees = [0] * (n + 1)\n\n    for (a, b) in edges:\n        indegrees[a] += 1\n        indegrees[b] += 1\n\n    if any(indegree % 2 == 1 for indegree in indegrees[1:]):\n        return 'IMPOSSIBLE'\n\n    directions = []\n\n    for (a, b) in edges:\n        if a < b:\n            directions.append((a, b))\n        else:\n            directions.append((b, a))\n\n    return directions",
        "test_list": [
            "assert main(4,4,[1,2],[2,3],[3,4],[1,4]) == 1 2\n2 3\n3 4\n1 4\n",
            "assert main(3,3,[1,2],[2,3],[1,3]) == 1 2\n2 3\n1 3\n",
            "assert main(5,5,[1,2],[2,3],[3,4],[4,5],[5,1]) == 1 2\n2 3\n3 4\n4 5\n1 5\n",
            "assert main(2,1,[1,2]) == 1 2\n",
            "assert main(1,0) == 1 1\n"
        ]
    },
    {
        "title": "Maximum Number of Tasks You Can Assign",
        "content": "You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]).\nAdditionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill.\nGiven the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed.\n&nbsp;\nExample 1:\n\nInput: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1\nOutput: 3\nExplanation:\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 2 (0 + 1 >= 1)\n- Assign worker 1 to task 1 (3 >= 2)\n- Assign worker 2 to task 0 (3 >= 3)\n\nExample 2:\n\nInput: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5\nOutput: 1\nExplanation:\nWe can assign the magical pill and tasks as follows:\n- Give the magical pill to worker 0.\n- Assign worker 0 to task 0 (0 + 5 >= 5)\n\nExample 3:\n\nInput: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10\nOutput: 2\nExplanation:\nWe can assign the magical pills and tasks as follows:\n- Give the magical pill to worker 0 and worker 1.\n- Assign worker 0 to task 0 (0 + 10 >= 10)\n- Assign worker 1 to task 1 (10 + 10 >= 15)\nThe last pill is not given because it will not make any worker strong enough for the last task.\n\n&nbsp;\nConstraints:\n\n\tn == tasks.length\n\tm == workers.length\n\t1 <= n, m <= 5 * 104\n\t0 <= pills <= m\n\t0 <= tasks[i], workers[j], strength <= 109",
        "sample1_input": "[3,2,1], [0,3,3], 1, 1\n",
        "sample1_output": "3\n",
        "sample2_input": "[5,4], [0,0,0], 1, 5\n",
        "sample2_output": "1\n",
        "sample3_input": "[10,15,30], [0,10,10,10,10], 3, 10\n",
        "sample3_output": "2\n",
        "sample4_input": "[5,10,15,20], [15,25,20,5], 2, 10\n",
        "sample4_output": "4\n",
        "sample5_input": "[1,2,3], [4,5,6,7], 1, 1\n",
        "sample5_output": "3\n",
        "task_id": 162,
        "code": "def main(tasks, workers, pills, strength):\n    tasks.sort()\n    workers.sort()\n    left, right = 0, len(tasks) - 1\n    result = 0\n\n    while left <= right and pills >= 0:\n        if workers[-1] >= tasks[right]:\n            right -= 1\n            pills -= 1\n            result += 1\n        else:\n            pills += strength\n            left += 1\n            workers.pop()\n\n    return result",
        "test_list": [
            "assert main([3,2,1], [0,3,3], 1, 1\n) == 3\n",
            "assert main([5,4], [0,0,0], 1, 5\n) == 1\n",
            "assert main([10,15,30], [0,10,10,10,10], 3, 10\n) == 2\n",
            "assert main([5,10,15,20], [15,25,20,5], 2, 10\n) == 4\n",
            "assert main([1,2,3], [4,5,6,7], 1, 1\n) == 3\n"
        ]
    },
    {
        "title": "Find Good Days to Rob the Bank",
        "content": "You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\nThe ith day is a good day to rob the bank if:\n\n\tThere are at least time days before and after the ith day,\n\tThe number of guards at the bank for the time days before i are non-increasing, and\n\tThe number of guards at the bank for the time days after i are non-decreasing.\n\nMore formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\nReturn a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.\n&nbsp;\nExample 1:\n\nInput: security = [5,3,3,3,5,6,2], time = 2\nOutput: [2,3]\nExplanation:\nOn day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\nOn day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\nExample 2:\n\nInput: security = [1,1,1,1,1], time = 0\nOutput: [0,1,2,3,4]\nExplanation:\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\nExample 3:\n\nInput: security = [1,2,3,4,5,6], time = 2\nOutput: []\nExplanation:\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n&nbsp;\nConstraints:\n\n\t1 <= security.length <= 105\n\t0 <= security[i], time <= 105",
        "sample1_input": "[5,3,3,3,5,6,2], 2\n",
        "sample1_output": "[2,3]\n",
        "sample2_input": "[1,1,1,1,1], 0\n",
        "sample2_output": "[0,1,2,3,4]\n",
        "sample3_input": "[1,2,3,4,5,6], 2\n",
        "sample3_output": "[]\n",
        "sample4_input": "[5,5,5,5,5,5,5], 3\n",
        "sample4_output": "[0,1,2,3,4,5,6]\n",
        "sample5_input": "[10,20,15,10,5,2,1], 1\n",
        "sample5_output": "[2,3,4,5]\n",
        "task_id": 163,
        "code": "def main(security, time):\n    n = len(security)\n    good_days = []\n\n    for i in range(n):\n        min_security_before = min(security[max(0, i - time):i])\n        max_security_after = max(security[i:i + time + 1])\n\n        if security[i] >= min_security_before and security[i] <= max_security_after:\n            good_days.append(i)\n\n    return good_days",
        "test_list": [
            "assert main([5,3,3,3,5,6,2], 2\n) == [2,3]\n",
            "assert main([1,1,1,1,1], 0\n) == [0,1,2,3,4]\n",
            "assert main([1,2,3,4,5,6], 2\n) == []\n",
            "assert main([5,5,5,5,5,5,5], 3\n) == [0,1,2,3,4,5,6]\n",
            "assert main([10,20,15,10,5,2,1], 1\n) == [2,3,4,5]\n"
        ]
    },
    {
        "title": "Maximum Sum Obtained of Any Permutation",
        "content": "We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.\n\nReturn the maximum total sum of all requests among all permutations of nums.\n\nSince the answer may be too large, return it modulo 109 + 7.\n\n&nbsp;\nExample 1:\n\n\nInput: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\nOutput: 19\nExplanation: One permutation of nums is [2,1,3,4,5] with the following result: \nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\nA permutation with a higher total sum is [3,5,4,2,1] with the following result:\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do.\n\n\nExample 2:\n\n\nInput: nums = [1,2,3,4,5,6], requests = [[0,1]]\nOutput: 11\nExplanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].\n\nExample 3:\n\n\nInput: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\nOutput: 47\nExplanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].\n\n&nbsp;\nConstraints:\n\n\n\tn == nums.length\n\t1 &lt;= n &lt;= 105\n\t0 &lt;= nums[i]&nbsp;&lt;= 105\n\t1 &lt;= requests.length &lt;=&nbsp;105\n\trequests[i].length == 2\n\t0 &lt;= starti&nbsp;&lt;= endi&nbsp;&lt;&nbsp;n\n\n",
        "sample1_input": "[5, [[1,3],[0,1]]]\n",
        "sample1_output": "19\n",
        "sample2_input": "[6, [[0,1]]]\n",
        "sample2_output": "11\n",
        "sample3_input": "[6, [[0,2],[1,3],[1,1]]]\n",
        "sample3_output": "47\n",
        "sample4_input": "[3, [[0,1],[1,2],[2,3]]]\n",
        "sample4_output": "10\n",
        "sample5_input": "[4, [[0,0],[1,1],[2,2],[3,3]]]\n",
        "sample5_output": "20\n",
        "task_id": 164,
        "code": "def main(n, requests):\n    count = [0] * n\n\n    for start, end in requests:\n        count[start] += 1\n        if end + 1 < n:\n            count[end + 1] -= 1\n\n    for i in range(1, n):\n        count[i] += count[i - 1]\n\n    nums.sort()\n    count.sort()\n\n    return sum(nums[i] * count[i] for i in range(n)) % (10**9 + 7)",
        "test_list": [
            "assert main([5, [[1,3],[0,1]]]\n) == 19\n",
            "assert main([6, [[0,1]]]\n) == 11\n",
            "assert main([6, [[0,2],[1,3],[1,1]]]\n) == 47\n",
            "assert main([3, [[0,1],[1,2],[2,3]]]\n) == 10\n",
            "assert main([4, [[0,0],[1,1],[2,2],[3,3]]]\n) == 20\n"
        ]
    },
    {
        "title": "Find the Score of All Prefixes of an Array",
        "content": "We define the conversion array conver of an array arr as follows:\n\n\tconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "sample1_input": "[2,3,7,5,10]\n",
        "sample1_output": "[4,10,24,36,56]\n",
        "sample2_input": "[1,1,2,4,8,16]\n",
        "sample2_output": "[2,4,8,16,32,64]\n",
        "sample3_input": "[3,2,1,4,5]\n",
        "sample3_output": "[6,8,9,16,26]\n",
        "sample4_input": "[1,2,3,4,5,6,7,8,9,10]\n",
        "sample4_output": "[2,6,12,20,30,42,56,72,90,110]\n",
        "sample5_input": "[10,9,8,7,6,5,4,3,2,1]\n",
        "sample5_output": "[20,28,36,44,52,60,68,76,84,92]\n",
        "task_id": 165,
        "code": "def main(nums):\n    n = len(nums)\n    max_val = nums[0]\n    prefix_score = nums[0]\n    ans = [prefix_score]\n\n    for i in range(1, n):\n        max_val = max(max_val, nums[i])\n        prefix_score += nums[i] + max_val\n        ans.append(prefix_score)\n\n    return ans",
        "test_list": [
            "assert main([2,3,7,5,10]\n) == [4,10,24,36,56]\n",
            "assert main([1,1,2,4,8,16]\n) == [2,4,8,16,32,64]\n",
            "assert main([3,2,1,4,5]\n) == [6,8,9,16,26]\n",
            "assert main([1,2,3,4,5,6,7,8,9,10]\n) == [2,6,12,20,30,42,56,72,90,110]\n",
            "assert main([10,9,8,7,6,5,4,3,2,1]\n) == [20,28,36,44,52,60,68,76,84,92]\n"
        ]
    },
    {
        "title": "Count Distinct Numbers on Board",
        "content": "You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:\n\n\tFor each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.\n\tThen, place those numbers on the board.\n\nReturn the number of distinct integers present on the board after 109 days have elapsed.\nNote:\n\n\tOnce a number is placed on the board, it will remain on it until the end.\n\t%&nbsp;stands&nbsp;for the modulo operation. For example,&nbsp;14 % 3 is 2.\n\n&nbsp;\nExample 1:\n\nInput: n = 5\nOutput: 4\nExplanation: Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\nExample 2:\n\nInput: n = 3\nOutput: 2\nExplanation: \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3. \n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 100",
        "sample1_input": "5",
        "sample1_output": "4\n",
        "sample2_input": "3",
        "sample2_output": "2\n",
        "sample3_input": "10",
        "sample3_output": "9\n",
        "sample4_input": "7",
        "sample4_output": "6\n",
        "sample5_input": "2",
        "sample5_output": "1\n",
        "task_id": 166,
        "code": "def main(n):\n    # Initialize a set to store distinct numbers on the board\n    distinct_numbers = set()\n    # Start with the initial number n\n    current_numbers = {n}\n\n    # Perform the procedure for 10^9 days\n    for _ in range(10**9):\n        # Create a new set to store numbers for the next day\n        next_numbers = set()\n        for x in current_numbers:\n            # Find all numbers 1 <= i <= n such that x % i == 1\n            for i in range(1, n + 1):\n                if x % i == 1:\n                    next_numbers.add(i)\n        # Update the set of distinct numbers\n        distinct_numbers.update(next_numbers)\n        # Set the current numbers to the numbers for the next day\n        current_numbers = next_numbers\n\n    # Return the number of distinct integers present on the board\n    return len(distinct_numbers)",
        "test_list": [
            "assert main(5) == 4\n",
            "assert main(3) == 2\n",
            "assert main(10) == 9\n",
            "assert main(7) == 6\n",
            "assert main(2) == 1\n"
        ]
    },
    {
        "title": "Smallest Even Multiple",
        "content": "Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.\n&nbsp;\nExample 1:\n\nInput: n = 5\nOutput: 10\nExplanation: The smallest multiple of both 5 and 2 is 10.\n\nExample 2:\n\nInput: n = 6\nOutput: 6\nExplanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 150",
        "sample1_input": "5",
        "sample1_output": "10\n",
        "sample2_input": "6",
        "sample2_output": "6\n",
        "sample3_input": "10",
        "sample3_output": "10\n",
        "sample4_input": "3",
        "sample4_output": "6\n",
        "sample5_input": "7",
        "sample5_output": "14\n",
        "task_id": 167,
        "code": "def main(n):\n    # Calculate the least common multiple (LCM) of 2 and n\n    def lcm(a, b):\n        return (a * b) // math.gcd(a, b)\n\n    import math\n\n    return lcm(2, n)",
        "test_list": [
            "assert main(5) == 10\n",
            "assert main(6) == 6\n",
            "assert main(10) == 10\n",
            "assert main(3) == 6\n",
            "assert main(7) == 14\n"
        ]
    },
    {
        "title": "Minimum Cost of Buying Candies With Discount",
        "content": "A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.\nThe customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.\n\n\tFor example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they&nbsp;can take the candy with cost 1 for free, but not the candy with cost 4.\n\nGiven a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.\n&nbsp;\nExample 1:\n\nInput: cost = [1,2,3]\nOutput: 5\nExplanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free.\nThe total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies.\nNote that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free.\nThe cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n\nExample 2:\n\nInput: cost = [6,5,7,9,2,2]\nOutput: 23\nExplanation: The way in which we can get the minimum cost is described below:\n- Buy candies with costs 9 and 7\n- Take the candy with cost 6 for free\n- We buy candies with costs 5 and 2\n- Take the last remaining candy with cost 2 for free\nHence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n\nExample 3:\n\nInput: cost = [5,5]\nOutput: 10\nExplanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free.\nHence, the minimum cost to buy all candies is 5 + 5 = 10.\n\n&nbsp;\nConstraints:\n\n\t1 <= cost.length <= 100\n\t1 <= cost[i] <= 100",
        "sample1_input": "[1,2,3]\n",
        "sample1_output": "5\n",
        "sample2_input": "[6,5,7,9,2,2]\n",
        "sample2_output": "23\n",
        "sample3_input": "[5,5]\n",
        "sample3_output": "10\n",
        "sample4_input": "[1,1,1,1,1,1,1,1,1,1,1]\n",
        "sample4_output": "7\n",
        "sample5_input": "[10,20,30,40,50,60,70,80,90,100,110]\n",
        "sample5_output": "330\n",
        "task_id": 168,
        "code": "def main(cost):\n    cost.sort()\n    total_cost = 0\n    n = len(cost)\n    for i in range(n // 3, n, 2):\n        total_cost += cost[i]\n    return total_cost",
        "test_list": [
            "assert main([1,2,3]\n) == 5\n",
            "assert main([6,5,7,9,2,2]\n) == 23\n",
            "assert main([5,5]\n) == 10\n",
            "assert main([1,1,1,1,1,1,1,1,1,1,1]\n) == 7\n",
            "assert main([10,20,30,40,50,60,70,80,90,100,110]\n) == 330\n"
        ]
    },
    {
        "title": "Find the Score of All Prefixes of an Array",
        "content": "We define the conversion array conver of an array arr as follows:\n\n\tconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "sample1_input": "[2,3,7,5,10]",
        "sample1_output": "[4,10,24,36,56]",
        "sample2_input": "[1,1,2,4,8,16]",
        "sample2_output": "[2,4,8,16,32,64]",
        "sample3_input": "[1,2,3,4,5]",
        "sample3_output": "[2,5,9,14,20]",
        "sample4_input": "[5,4,3,2,1]",
        "sample4_output": "[5,9,12,14,15]",
        "sample5_input": "[10,9,8,7,6]",
        "sample5_output": "[10,19,27,34,40]",
        "task_id": 169,
        "code": "def main(nums):\n    n = len(nums)\n    conversion = [0] * n\n    score = [0] * n\n    max_val = -1\n\n    for i in range(n):\n        max_val = max(max_val, nums[i])\n        conversion[i] = nums[i] + max_val\n\n    for i in range(n):\n        if i == 0:\n            score[i] = conversion[i]\n        else:\n            score[i] = conversion[i] + score[i - 1]\n\n    return score",
        "test_list": [
            "assert main([2,3,7,5,10]) == [4,10,24,36,56]",
            "assert main([1,1,2,4,8,16]) == [2,4,8,16,32,64]",
            "assert main([1,2,3,4,5]) == [2,5,9,14,20]",
            "assert main([5,4,3,2,1]) == [5,9,12,14,15]",
            "assert main([10,9,8,7,6]) == [10,19,27,34,40]"
        ]
    },
    {
        "title": "Count the Number of Complete Components",
        "content": "You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.\n\nReturn the number of complete connected components of the graph.\n\nA connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\n\nA connected component is said to be complete if there exists an edge between every pair of its vertices.\n\n&nbsp;\nExample 1:\n\n\n\n\nInput: n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\nOutput: 3\nExplanation: From the picture above, one can see that all of the components of this graph are complete.\n\n\nExample 2:\n\n\n\n\nInput: n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\nOutput: 1\nExplanation: The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= n &lt;= 50\n\t0 &lt;= edges.length &lt;= n * (n - 1) / 2\n\tedges[i].length == 2\n\t0 &lt;= ai, bi &lt;= n - 1\n\tai != bi\n\tThere are no repeated edges.\n\n",
        "sample1_input": "6, [[0,1],[0,2],[1,2],[3,4]]",
        "sample1_output": "3",
        "sample2_input": "6, [[0,1],[0,2],[1,2],[3,4],[3,5]]",
        "sample2_output": "1",
        "sample3_input": "5, [[0,1],[1,2],[2,3],[3,4]]",
        "sample3_output": "1",
        "sample4_input": "4, [[0,1],[1,2],[2,3],[3,0]]",
        "sample4_output": "2",
        "sample5_input": "3, [[0,1],[1,2],[2,0]]",
        "sample5_output": "1",
        "task_id": 170,
        "code": "def main(n, edges):\n    def dfs(node, component):\n        if node not in visited:\n            visited.add(node)\n            component.add(node)\n            for neighbor in graph[node]:\n                dfs(neighbor, component)\n\n    graph = [[] for _ in range(n)]\n    visited = set()\n    components = []\n\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    for node in range(n):\n        if node not in visited:\n            component = set()\n            dfs(node, component)\n            components.append(component)\n\n    complete_components = 0\n\n    for component in components:\n        complete = True\n        for i in range(len(component)):\n            for j in range(i + 1, len(component)):\n                if component[i] not in graph[component[j]]:\n                    complete = False\n                    break\n            if not complete:\n                break\n        if complete:\n            complete_components += 1\n\n    return complete_components",
        "test_list": [
            "assert main(6, [[0,1],[0,2],[1,2],[3,4]]) == 3",
            "assert main(6, [[0,1],[0,2],[1,2],[3,4],[3,5]]) == 1",
            "assert main(5, [[0,1],[1,2],[2,3],[3,4]]) == 1",
            "assert main(4, [[0,1],[1,2],[2,3],[3,0]]) == 2",
            "assert main(3, [[0,1],[1,2],[2,0]]) == 1"
        ]
    },
    {
        "title": "Minimum Cost to Make All Characters Equal",
        "content": "You are given a 0-indexed binary string s of length n on which you can apply two types of operations:\n\n\n\tChoose an index i and invert all characters from&nbsp;index 0 to index i&nbsp;(both inclusive), with a cost of i + 1\n\tChoose an index i and invert all characters&nbsp;from&nbsp;index i to index n - 1&nbsp;(both inclusive), with a cost of n - i\n\n\nReturn the minimum cost to make all characters of the string equal.\n\nInvert a character means&nbsp;if its value is &#39;0&#39; it becomes &#39;1&#39; and vice-versa.\n\n&nbsp;\nExample 1:\n\n\nInput: s = &quot;0011&quot;\nOutput: 2\nExplanation: Apply the second operation with i = 2 to obtain s = &quot;0000&quot; for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal.\n\n\nExample 2:\n\n\nInput: s = &quot;010101&quot;\nOutput: 9\nExplanation: Apply the first operation with i = 2 to obtain s = &quot;101101&quot; for a cost of 3.\nApply the first operation with i = 1 to obtain s = &quot;011101&quot; for a cost of 2. \nApply the first operation with i = 0 to obtain s = &quot;111101&quot; for a cost of 1. \nApply the second operation with i = 4 to obtain s = &quot;111110&quot; for a cost of 2.\nApply the second operation with i = 5 to obtain s = &quot;111111&quot; for a cost of 1. \nThe total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= s.length == n &lt;= 105\n\ts[i] is either &#39;0&#39; or &#39;1&#39;\n\n",
        "sample1_input": "\"0011\"",
        "sample1_output": "2",
        "sample2_input": "\"010101\"",
        "sample2_output": "9",
        "sample3_input": "\"11111\"",
        "sample3_output": "0",
        "sample4_input": "\"00000\"",
        "sample4_output": "0",
        "sample5_input": "\"110110100\"",
        "sample5_output": "13",
        "task_id": 171,
        "code": "def main(s):\n    n = len(s)\n    cost = 0\n    ones_count = s.count('1')\n    zeros_count = n - ones_count\n    ones_so_far = 0\n    zeros_so_far = 0\n\n    for i in range(n):\n        if s[i] == '1':\n            ones_so_far += 1\n            cost += min(ones_so_far, zeros_count)\n        else:\n            zeros_so_far += 1\n            cost += min(zeros_so_far, ones_count)\n\n    return cost",
        "test_list": [
            "assert main(\"0011\") == 2",
            "assert main(\"010101\") == 9",
            "assert main(\"11111\") == 0",
            "assert main(\"00000\") == 0",
            "assert main(\"110110100\") == 13"
        ]
    },
    {
        "title": "Check if The Number is Fascinating",
        "content": "You are given an integer n that consists of exactly 3 digits.\n\nWe call the number n fascinating if, after the following modification, the resulting number contains all the digits from 1 to 9 exactly once and does not contain any 0&#39;s:\n\n\n\tConcatenate n with the numbers 2 * n and 3 * n.\n\n\nReturn true if n is fascinating, or false otherwise.\n\nConcatenating two numbers means joining them together. For example, the concatenation of 121 and 371 is 121371.\n\n&nbsp;\nExample 1:\n\n\nInput: n = 192\nOutput: true\nExplanation: We concatenate the numbers n = 192 and 2 * n = 384 and 3 * n = 576. The resulting number is 192384576. This number contains all the digits from 1 to 9 exactly once.\n\n\nExample 2:\n\n\nInput: n = 100\nOutput: false\nExplanation: We concatenate the numbers n = 100 and 2 * n = 200 and 3 * n = 300. The resulting number is 100200300. This number does not satisfy any of the conditions.\n\n\n&nbsp;\nConstraints:\n\n\n\t100 &lt;= n &lt;= 999\n\n",
        "sample1_input": "192",
        "sample1_output": "true",
        "sample2_input": "100",
        "sample2_output": "false",
        "sample3_input": "123",
        "sample3_output": "true",
        "sample4_input": "456",
        "sample4_output": "true",
        "sample5_input": "789",
        "sample5_output": "false",
        "task_id": 172,
        "code": "def main(n):\n    n_str = str(n)\n    concatenated_str = n_str + str(2 * n) + str(3 * n)\n    if len(concatenated_str) != 9 or '0' in concatenated_str:\n        return False\n    return set(concatenated_str) == set('123456789')",
        "test_list": [
            "assert main(192) == true",
            "assert main(100) == false",
            "assert main(123) == true",
            "assert main(456) == true",
            "assert main(789) == false"
        ]
    },
    {
        "title": "Total Distance Traveled",
        "content": "A truck has two fuel tanks. You are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters.\n\nThe truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get&nbsp;used up in the main tank,&nbsp;if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank.\n\nReturn the maximum distance which can be traveled.\n\nNote: Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.\n\n&nbsp;\nExample 1:\n\n\nInput: mainTank = 5, additionalTank = 10\nOutput: 60\nExplanation: \nAfter spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km.\nAfter spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.\nTotal distance traveled is 60km.\n\n\nExample 2:\n\n\nInput: mainTank = 1, additionalTank = 2\nOutput: 10\nExplanation: \nAfter spending 1 litre of fuel, the main tank becomes empty.\nTotal distance traveled is 10km.\n\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= mainTank, additionalTank &lt;= 100\n\n",
        "sample1_input": "5,10",
        "sample1_output": "60",
        "sample2_input": "1,2",
        "sample2_output": "10",
        "sample3_input": "3,7",
        "sample3_output": "40",
        "sample4_input": "8,20",
        "sample4_output": "180",
        "sample5_input": "7,0",
        "sample5_output": "70",
        "task_id": 173,
        "code": "def main(mainTank, additionalTank):\n    total_distance = 0\n    while mainTank > 0:\n        total_distance += mainTank * 10\n        if mainTank >= 5:\n            mainTank -= 5\n        else:\n            additionalTank -= (5 - mainTank)\n            mainTank = 0\n        if additionalTank < 0:\n            additionalTank = 0\n        mainTank += additionalTank\n    return total_distance",
        "test_list": [
            "assert main(5,10) == 60",
            "assert main(1,2) == 10",
            "assert main(3,7) == 40",
            "assert main(8,20) == 180",
            "assert main(7,0) == 70"
        ]
    },
    {
        "title": "Prime Pairs With Target Sum",
        "content": "You are given an integer n. We say that two integers x and y form a prime number pair if:\n\n\n\t1 &lt;= x &lt;= y &lt;= n\n\tx + y == n\n\tx and y are prime numbers\n\n\nReturn the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array.\n\nNote: A prime number is a natural number greater than 1 with only two factors, itself and 1.\n\n&nbsp;\nExample 1:\n\n\nInput: n = 10\nOutput: [[3,7],[5,5]]\nExplanation: In this example, there are two prime pairs that satisfy the criteria. \nThese pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.\n\n\nExample 2:\n\n\nInput: n = 2\nOutput: []\nExplanation: We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. \n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= n &lt;= 106\n\n",
        "sample1_input": "10",
        "sample1_output": "[[3,7],[5,5]]",
        "sample2_input": "2",
        "sample2_output": "[]",
        "sample3_input": "15",
        "sample3_output": "[[2,13],[3,12],[5,10],[7,8],[11,4]]",
        "sample4_input": "20",
        "sample4_output": "[[2,18],[3,17],[5,15],[7,13],[11,9]]",
        "sample5_input": "30",
        "sample5_output": "[[2,28],[3,27],[5,25],[7,23],[11,19],[13,17]]",
        "task_id": 174,
        "code": "def main(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_pairs = []\n\n    for x in range(2, n + 1):\n        y = n - x\n        if is_prime(x) and is_prime(y):\n            prime_pairs.append([x, y])\n\n    return prime_pairs",
        "test_list": [
            "assert main(10) == [[3,7],[5,5]]",
            "assert main(2) == []",
            "assert main(15) == [[2,13],[3,12],[5,10],[7,8],[11,4]]",
            "assert main(20) == [[2,18],[3,17],[5,15],[7,13],[11,9]]",
            "assert main(30) == [[2,28],[3,27],[5,25],[7,23],[11,19],[13,17]]"
        ]
    },
    {
        "title": "Longest Non-decreasing Subarray From Two Arrays",
        "content": "You are given two 0-indexed integer arrays nums1 and nums2 of length n.\n\nLet&#39;s define another 0-indexed integer array, nums3, of length n. For each index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i] to nums3[i].\n\nYour task is to maximize the length of the longest non-decreasing subarray in nums3 by choosing its values optimally.\n\nReturn an integer representing the length of the longest non-decreasing subarray in nums3.\n\nNote: A subarray is a contiguous non-empty sequence of elements within an array.\n\n&nbsp;\nExample 1:\n\n\nInput: nums1 = [2,3,1], nums2 = [1,2,1]\nOutput: 2\nExplanation: One way to construct nums3 is: \nnums3 = [nums1[0], nums2[1], nums2[2]] =&gt; [2,2,1]. \nThe subarray starting from index 0 and ending at index 1, [2,2], forms a non-decreasing subarray of length 2. \nWe can show that 2 is the maximum achievable length.\n\nExample 2:\n\n\nInput: nums1 = [1,3,2,1], nums2 = [2,2,3,4]\nOutput: 4\nExplanation: One way to construct nums3 is: \nnums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] =&gt; [1,2,3,4]. \nThe entire array forms a non-decreasing subarray of length 4, making it the maximum achievable length.\n\n\nExample 3:\n\n\nInput: nums1 = [1,1], nums2 = [2,2]\nOutput: 2\nExplanation: One way to construct nums3 is: \nnums3 = [nums1[0], nums1[1]] =&gt; [1,1]. \nThe entire array forms a non-decreasing subarray of length 2, making it the maximum achievable length.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= nums1.length == nums2.length == n &lt;= 105\n\t1 &lt;= nums1[i], nums2[i] &lt;= 109\n\n",
        "sample1_input": "[2,3,1]",
        "sample1_output": "2",
        "sample2_input": "[1,3,2,1]",
        "sample2_output": "4",
        "sample3_input": "[1,1]",
        "sample3_output": "2",
        "sample4_input": "[5,4,3,2,1]",
        "sample4_output": "3",
        "sample5_input": "[1,2,3,4,5]",
        "sample5_output": "5",
        "task_id": 175,
        "code": "def main(nums1, nums2):\n    n = len(nums1)\n    max_len = 0\n    dp = [0] * n\n\n    for i in range(n):\n        dp[i] = 1  # Initialize with a minimum length of 1\n        if nums1[i] <= nums2[i]:\n            for j in range(i):\n                if nums1[i] >= nums1[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        if nums2[i] <= nums1[i]:\n            for j in range(i):\n                if nums2[i] >= nums2[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        max_len = max(max_len, dp[i])\n\n    return max_len",
        "test_list": [
            "assert main([2,3,1]) == 2",
            "assert main([1,3,2,1]) == 4",
            "assert main([1,1]) == 2",
            "assert main([5,4,3,2,1]) == 3",
            "assert main([1,2,3,4,5]) == 5"
        ]
    },
    {
        "title": "Split Strings by Separator",
        "content": "Given an array of strings words and a character separator, split each string in words by separator.\n\nReturn an array of strings containing the new strings formed after the splits, excluding empty strings.\n\nNotes\n\n\n\tseparator is used to determine where the split should occur, but it is not included as part of the resulting strings.\n\tA split may result in more than two strings.\n\tThe resulting strings must maintain the same order as they were initially given.\n\n\n&nbsp;\nExample 1:\n\n\nInput: words = [&quot;one.two.three&quot;,&quot;four.five&quot;,&quot;six&quot;], separator = &quot;.&quot;\nOutput: [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;]\nExplanation: In this example we split as follows:\n\n&quot;one.two.three&quot; splits into &quot;one&quot;, &quot;two&quot;, &quot;three&quot;\n&quot;four.five&quot; splits into &quot;four&quot;, &quot;five&quot;\n&quot;six&quot; splits into &quot;six&quot; \n\nHence, the resulting array is [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;].\n\nExample 2:\n\n\nInput: words = [&quot;$easy$&quot;,&quot;$problem$&quot;], separator = &quot;$&quot;\nOutput: [&quot;easy&quot;,&quot;problem&quot;]\nExplanation: In this example we split as follows: \n\n&quot;$easy$&quot; splits into &quot;easy&quot; (excluding empty strings)\n&quot;$problem$&quot; splits into &quot;problem&quot; (excluding empty strings)\n\nHence, the resulting array is [&quot;easy&quot;,&quot;problem&quot;].\n\n\nExample 3:\n\n\nInput: words = [&quot;|||&quot;], separator = &quot;|&quot;\nOutput: []\nExplanation: In this example the resulting split of &quot;|||&quot; will contain only empty strings, so we return an empty array []. \n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= words.length &lt;= 100\n\t1 &lt;= words[i].length &lt;= 20\n\tcharacters in words[i] are either lowercase English letters or characters from the string &quot;.,|$#@&quot; (excluding the quotes)\n\tseparator is a character from the string &quot;.,|$#@&quot; (excluding the quotes)\n\n",
        "sample1_input": "[\"one.two.three\",\"four.five\",\"six\"], \".\"",
        "sample1_output": "[\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]",
        "sample2_input": "[\"$easy$\",\"$problem$\"],\"$\"}",
        "sample2_output": "[\"easy\",\"problem\"]",
        "sample3_input": "[\"|||\"],\"|\"",
        "sample3_output": "[]",
        "sample4_input": "[\"apple#orange#banana\",\"grape\"],\"#\"}",
        "sample4_output": "[\"apple\",\"orange\",\"banana\",\"grape\"]",
        "sample5_input": "[\"hello,world\",\"this,is,a,test\"],\",\"}",
        "sample5_output": "[\"hello\",\"world\",\"this\",\"is\",\"a\",\"test\"]",
        "task_id": 176,
        "code": "def main(words, separator):\n    result = []\n    for word in words:\n        split_words = word.split(separator)\n        result.extend([s for s in split_words if s])\n    return result",
        "test_list": [
            "assert main([\"one.two.three\",\"four.five\",\"six\"], \".\") == [\"one\",\"two\",\"three\",\"four\",\"five\",\"six\"]",
            "assert main([\"$easy$\",\"$problem$\"],\"$\"}) == [\"easy\",\"problem\"]",
            "assert main([\"|||\"],\"|\") == []",
            "assert main([\"apple#orange#banana\",\"grape\"],\"#\"}) == [\"apple\",\"orange\",\"banana\",\"grape\"]",
            "assert main([\"hello,world\",\"this,is,a,test\"],\",\"}) == [\"hello\",\"world\",\"this\",\"is\",\"a\",\"test\"]"
        ]
    },
    {
        "title": "Maximum Elegance of a K-Length Subsequence",
        "content": "You are given a 0-indexed 2D integer array items of length n and an integer k.\n\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively.\n\nLet&#39;s define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\n\nYour task is to find the maximum elegance from all subsequences of size k in items.\n\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\n\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order.\n\n&nbsp;\nExample 1:\n\n\nInput: items = [[3,2],[5,1],[10,1]], k = 2\nOutput: 17\nExplanation: In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 22 = 17, and we can show that it is the maximum achievable elegance. \n\n\nExample 2:\n\n\nInput: items = [[3,1],[3,1],[2,2],[5,3]], k = 3\nOutput: 19\nExplanation: In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 32 = 19, and we can show that it is the maximum achievable elegance.\n\nExample 3:\n\n\nInput: items = [[1,1],[2,1],[3,1]], k = 3\nOutput: 7\nExplanation: In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 12 = 7.  \n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= items.length == n &lt;= 105\n\titems[i].length == 2\n\titems[i][0] == profiti\n\titems[i][1] == categoryi\n\t1 &lt;= profiti &lt;= 109\n\t1 &lt;= categoryi &lt;= n \n\t1 &lt;= k &lt;= n\n\n",
        "sample1_input": "[(3,2),(5,1),(10,1)],2",
        "sample1_output": "17",
        "sample2_input": "[(3,1),(3,1),(2,2),(5,3)],3",
        "sample2_output": "19",
        "sample3_input": "[(1,1),(2,1),(3,1)],3",
        "sample3_output": "7",
        "sample4_input": "[(5,1),(5,1),(5,1),(5,2)],4",
        "sample4_output": "30",
        "sample5_input": "[(10,1),(5,2),(5,2),(3,3),(2,1)],5",
        "sample5_output": "56",
        "task_id": 177,
        "code": "def main(items, k):\n    # Sort items by profit in descending order\n    items.sort(key=lambda x: -x[0])\n    \n    # Initialize a dictionary to keep track of category counts\n    category_counts = {}\n    \n    # Initialize variables for total profit and elegance\n    total_profit = 0\n    elegance = 0\n    \n    # Initialize the index to iterate through items\n    i = 0\n    \n    # Iterate through items and calculate the elegance\n    while i < len(items) and k > 0:\n        profit, category = items[i]\n        if category not in category_counts or category_counts[category] < 2:\n            # Add profit to total_profit\n            total_profit += profit\n            \n            # Increment the category count\n            if category in category_counts:\n                category_counts[category] += 1\n            else:\n                category_counts[category] = 1\n            \n            # Update elegance\n            elegance = total_profit + len(category_counts) ** 2\n            \n            k -= 1\n        \n        i += 1\n    \n    return elegance",
        "test_list": [
            "assert main([(3,2),(5,1),(10,1)],2) == 17",
            "assert main([(3,1),(3,1),(2,2),(5,3)],3) == 19",
            "assert main([(1,1),(2,1),(3,1)],3) == 7",
            "assert main([(5,1),(5,1),(5,1),(5,2)],4) == 30",
            "assert main([(10,1),(5,2),(5,2),(3,3),(2,1)],5) == 56"
        ]
    },
    {
        "title": "Furthest Point From Origin",
        "content": "You are given a string moves of length n consisting only of characters &#39;L&#39;, &#39;R&#39;, and &#39;_&#39;. The string represents your movement on a number line starting from the origin 0.\n\nIn the ith move, you can choose one of the following directions:\n\n\n\tmove to the left if moves[i] = &#39;L&#39; or moves[i] = &#39;_&#39;\n\tmove to the right if moves[i] = &#39;R&#39; or moves[i] = &#39;_&#39;\n\n\nReturn the distance from the origin of the furthest point you can get to after n moves.\n\n&nbsp;\nExample 1:\n\n\nInput: moves = &quot;L_RL__R&quot;\nOutput: 3\nExplanation: The furthest point we can reach from the origin 0 is point -3 through the following sequence of moves &quot;LLRLLLR&quot;.\n\n\nExample 2:\n\n\nInput: moves = &quot;_R__LL_&quot;\nOutput: 5\nExplanation: The furthest point we can reach from the origin 0 is point -5 through the following sequence of moves &quot;LRLLLLL&quot;.\n\n\nExample 3:\n\n\nInput: moves = &quot;_______&quot;\nOutput: 7\nExplanation: The furthest point we can reach from the origin 0 is point 7 through the following sequence of moves &quot;RRRRRRR&quot;.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= moves.length == n &lt;= 50\n\tmoves consists only of characters &#39;L&#39;, &#39;R&#39; and &#39;_&#39;.\n\n",
        "sample1_input": "L_RL__R",
        "sample1_output": "3",
        "sample2_input": "_R__LL_",
        "sample2_output": "5",
        "sample3_input": "_______",
        "sample3_output": "7",
        "sample4_input": "_L__R_L_R__R_L__L_R__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R",
        "sample4_output": "49",
        "sample5_input": "R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R",
        "sample5_output": "99",
        "task_id": 178,
        "code": "def main(moves):\n    max_distance = 0\n    current_position = 0\n\n    for move in moves:\n        if move == 'L' or move == '_':\n            current_position -= 1\n        if move == 'R' or move == '_':\n            current_position += 1\n\n        max_distance = max(max_distance, abs(current_position))\n\n    return max_distance",
        "test_list": [
            "assert main(L_RL__R) == 3",
            "assert main(_R__LL_) == 5",
            "assert main(_______) == 7",
            "assert main(_L__R_L_R__R_L__L_R__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R_L__R) == 49",
            "assert main(R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R_L_R) == 99"
        ]
    },
    {
        "title": "  Count Symmetric Integers",
        "content": "You are given two positive integers low and high.\n\nAn integer x consisting of 2 * n digits is symmetric if the sum of the first n digits of x is equal to the sum of the last n digits of x. Numbers with an odd number of digits are never symmetric.\n\nReturn the number of symmetric integers in the range [low, high].\n\n&nbsp;\nExample 1:\n\n\nInput: low = 1, high = 100\nOutput: 9\nExplanation: There are 9 symmetric integers between 1 and 100: 11, 22, 33, 44, 55, 66, 77, 88, and 99.\n\n\nExample 2:\n\n\nInput: low = 1200, high = 1230\nOutput: 4\nExplanation: There are 4 symmetric integers between 1200 and 1230: 1203, 1212, 1221, and 1230.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= low &lt;= high &lt;= 104\n\n",
        "sample1_input": "1,100",
        "sample1_output": "9",
        "sample2_input": "1200,1230",
        "sample2_output": "4",
        "sample3_input": "1000,1050",
        "sample3_output": "1",
        "sample4_input": "999,1000",
        "sample4_output": "2",
        "sample5_input": "1,9999",
        "sample5_output": "36",
        "task_id": 179,
        "code": "def main(low, high):\n    def is_symmetric(num):\n        num_str = str(num)\n        n = len(num_str) // 2\n        first_half = num_str[:n]\n        second_half = num_str[-n:]\n        return sum(map(int, first_half)) == sum(map(int, second_half))\n\n    count = 0\n    for num in range(low, high + 1):\n        if is_symmetric(num):\n            count += 1\n\n    return count",
        "test_list": [
            "assert main(1,100) == 9",
            "assert main(1200,1230) == 4",
            "assert main(1000,1050) == 1",
            "assert main(999,1000) == 2",
            "assert main(1,9999) == 36"
        ]
    },
    {
        "title": "Apply Bitwise Operations to Make Strings Equal",
        "content": "You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:\n\n\tChoose two different indices i and j where 0 <= i, j < n.\n\tSimultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).\n\nFor example, if s = \"0110\", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = \"1110\".\nReturn true if you can make the string s equal to target, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: s = \"1010\", target = \"0110\"\nOutput: true\nExplanation: We can do the following operations:\n- Choose i = 2 and j = 0. We have now s = \"0010\".\n- Choose i = 2 and j = 1. We have now s = \"0110\".\nSince we can make s equal to target, we return true.\n\nExample 2:\n\nInput: s = \"11\", target = \"00\"\nOutput: false\nExplanation: It is not possible to make s equal to target with any number of operations.\n\n&nbsp;\nConstraints:\n\n\tn == s.length == target.length\n\t2 <= n <= 105\n\ts and target consist of only the digits 0 and 1.",
        "sample1_input": "\"1010\", \"0110\"",
        "sample1_output": "true",
        "sample2_input": "\"11\", \"00\"",
        "sample2_output": "false",
        "sample3_input": "\"110\", \"011\"",
        "sample3_output": "true",
        "sample4_input": "\"0\", \"1\"",
        "sample4_output": "false",
        "sample5_input": "\"101010101\", \"111110110\"",
        "sample5_output": "true",
        "task_id": 180,
        "code": "def main(s, target):\n    # Count the number of 1s in s and target\n    count_s_ones = s.count('1')\n    count_target_ones = target.count('1')\n\n    # If the counts are not equal, return False\n    if count_s_ones != count_target_ones:\n        return False\n\n    # If both strings are equal, return True\n    if s == target:\n        return True\n\n    # If there are at least two 1s in s, return True\n    if count_s_ones >= 2:\n        return True\n\n    # If there is a 1 in both s and target, return True\n    if '1' in s and '1' in target:\n        return True\n\n    return False",
        "test_list": [
            "assert main(\"1010\", \"0110\") == true",
            "assert main(\"11\", \"00\") == false",
            "assert main(\"110\", \"011\") == true",
            "assert main(\"0\", \"1\") == false",
            "assert main(\"101010101\", \"111110110\") == true"
        ]
    },
    {
        "title": "Group Anagrams",
        "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n&nbsp;\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.",
        "sample1_input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "sample1_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
        "sample2_input": "[\"\"]",
        "sample2_output": "[[\"\"]]",
        "sample3_input": "[\"a\"]",
        "sample3_output": "[[\"a\"]]",
        "sample4_input": "[\"abc\",\"def\",\"bca\",\"fed\",\"cba\",\"xyz\"]",
        "sample4_output": "[[\"abc\",\"bca\",\"cba\"],[\"def\",\"fed\"],[\"xyz\"]]",
        "sample5_input": "[\"dog\",\"god\",\"act\",\"cat\",\"tac\"]",
        "sample5_output": "[[\"dog\",\"god\"],[\"act\",\"cat\",\"tac\"]]",
        "task_id": 181,
        "code": "def main(strs):\n    anagrams = {}\n\n    for word in strs:\n        # Sort the characters in the word\n        sorted_word = ''.join(sorted(word))\n\n        # Add the word to the corresponding anagram group\n        if sorted_word in anagrams:\n            anagrams[sorted_word].append(word)\n        else:\n            anagrams[sorted_word] = [word]\n\n    # Convert the values of the dictionary to a list of lists\n    grouped_anagrams = list(anagrams.values())\n\n    return grouped_anagrams",
        "test_list": [
            "assert main([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]) == [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
            "assert main([\"\"]) == [[\"\"]]",
            "assert main([\"a\"]) == [[\"a\"]]",
            "assert main([\"abc\",\"def\",\"bca\",\"fed\",\"cba\",\"xyz\"]) == [[\"abc\",\"bca\",\"cba\"],[\"def\",\"fed\"],[\"xyz\"]]",
            "assert main([\"dog\",\"god\",\"act\",\"cat\",\"tac\"]) == [[\"dog\",\"god\"],[\"act\",\"cat\",\"tac\"]]"
        ]
    },
    {
        "title": "House Robber IV",
        "content": "There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes.\nThe capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\nYou are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars.\nYou are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses.\nReturn the minimum capability of the robber out of all the possible ways to steal at least k houses.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,5,9], k = 2\nOutput: 5\nExplanation: \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\nExample 2:\n\nInput: nums = [2,7,9,3,1], k = 2\nOutput: 2\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\t1 <= k <= (nums.length + 1)/2",
        "sample1_input": "[2,3,5,9], 2",
        "sample1_output": "5",
        "sample2_input": "[2,7,9,3,1], 2",
        "sample2_output": "2",
        "sample3_input": "[1,2,3,4,5], 3",
        "sample3_output": "4",
        "sample4_input": "[1,1,1,1,1], 5",
        "sample4_output": "1",
        "sample5_input": "[10,20,30,40,50], 2",
        "sample5_output": "50",
        "task_id": 182,
        "code": "def main(nums, k):\n    left = 1\n    right = max(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        current_sum = 0\n\n        for num in nums:\n            current_sum += num\n            if current_sum >= mid:\n                count += 1\n                current_sum = 0\n\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left - 1",
        "test_list": [
            "assert main([2,3,5,9], 2) == 5",
            "assert main([2,7,9,3,1], 2) == 2",
            "assert main([1,2,3,4,5], 3) == 4",
            "assert main([1,1,1,1,1], 5) == 1",
            "assert main([10,20,30,40,50], 2) == 50"
        ]
    },
    {
        "title": "Root Equals Sum of Children",
        "content": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\nExample 2:\n\nInput: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n&nbsp;\nConstraints:\n\n\tThe tree consists only of the root, its left child, and its right child.\n\t-100 <= Node.val <= 100",
        "sample1_input": "[10,4,6]",
        "sample1_output": "true",
        "sample2_input": "[5,3,1]",
        "sample2_output": "false",
        "sample3_input": "[0,0,0]",
        "sample3_output": "true",
        "sample4_input": "[1,2,3]",
        "sample4_output": "false",
        "sample5_input": "[-1,-1,-1]",
        "sample5_output": "false",
        "task_id": 183,
        "code": "def main(root):\n    if root is None:\n        return False\n\n    # Helper function to calculate the sum of all nodes in the tree\n    def getSum(node):\n        if node is None:\n            return 0\n        return node.val + getSum(node.left) + getSum(node.right)\n\n    # Get the sum of the root's children\n    children_sum = getSum(root.left) + getSum(root.right)\n\n    # Check if the sum of the children is equal to the root's value\n    return root.val == children_sum",
        "test_list": [
            "assert main([10,4,6]) == true",
            "assert main([5,3,1]) == false",
            "assert main([0,0,0]) == true",
            "assert main([1,2,3]) == false",
            "assert main([-1,-1,-1]) == false"
        ]
    },
    {
        "title": "Find Resultant Array After Removing Anagrams",
        "content": "You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.\n\nIn one operation, select any index i such that 0 &lt; i &lt; words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions.\n\nReturn words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, &quot;dacb&quot; is an anagram of &quot;abdc&quot;.\n\n&nbsp;\nExample 1:\n\n\nInput: words = [&quot;abba&quot;,&quot;baba&quot;,&quot;bbaa&quot;,&quot;cd&quot;,&quot;cd&quot;]\nOutput: [&quot;abba&quot;,&quot;cd&quot;]\nExplanation:\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words[2] = &quot;bbaa&quot; and words[1] = &quot;baba&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;baba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[1] = &quot;baba&quot; and words[0] = &quot;abba&quot; are anagrams, we choose index 1 and delete words[1].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[2] = &quot;cd&quot; and words[1] = &quot;cd&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;].\nWe can no longer perform any operations, so [&quot;abba&quot;,&quot;cd&quot;] is the final answer.\n\nExample 2:\n\n\nInput: words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\nOutput: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\nExplanation:\nNo two adjacent strings in words are anagrams of each other, so no operations are performed.\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= words.length &lt;= 100\n\t1 &lt;= words[i].length &lt;= 10\n\twords[i] consists of lowercase English letters.\n\n",
        "sample1_input": "[\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]",
        "sample1_output": "[\"abba\",\"cd\"]",
        "sample2_input": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
        "sample2_output": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
        "sample3_input": "[\"abc\",\"def\",\"bac\",\"fed\",\"cab\",\"xyz\"]",
        "sample3_output": "[\"abc\",\"def\",\"xyz\"]",
        "sample4_input": "[\"hello\",\"world\",\"loleh\",\"dlrow\",\"hell\",\"wool\",\"dlorw\"]",
        "sample4_output": "[\"hello\",\"world\",\"hell\"]",
        "sample5_input": "[\"abcd\",\"dcba\",\"abcd\",\"abcd\",\"abcd\",\"abcd\"]",
        "sample5_output": "[\"abcd\"]",
        "task_id": 184,
        "code": "def main(words):\n    anagram_map = {}\n    result = []\n\n    for word in words:\n        # Sort the characters in the word to create a unique key for anagrams\n        key = ''.join(sorted(word))\n\n        # If the key is already in the anagram_map, it's an anagram\n        if key in anagram_map:\n            anagram_map[key].append(word)\n        else:\n            anagram_map[key] = [word]\n\n    # Iterate through the anagram groups and keep only one word from each group\n    for group in anagram_map.values():\n        result.append(group[0])\n\n    return result",
        "test_list": [
            "assert main([\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]) == [\"abba\",\"cd\"]",
            "assert main([\"a\",\"b\",\"c\",\"d\",\"e\"]) == [\"a\",\"b\",\"c\",\"d\",\"e\"]",
            "assert main([\"abc\",\"def\",\"bac\",\"fed\",\"cab\",\"xyz\"]) == [\"abc\",\"def\",\"xyz\"]",
            "assert main([\"hello\",\"world\",\"loleh\",\"dlrow\",\"hell\",\"wool\",\"dlorw\"]) == [\"hello\",\"world\",\"hell\"]",
            "assert main([\"abcd\",\"dcba\",\"abcd\",\"abcd\",\"abcd\",\"abcd\"]) == [\"abcd\"]"
        ]
    },
    {
        "title": "Long Pressed Name",
        "content": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n&nbsp;\nExample 1:\n\nInput: name = \"alex\", typed = \"aaleex\"\nOutput: true\nExplanation: 'a' and 'e' in 'alex' were long pressed.\n\nExample 2:\n\nInput: name = \"saeed\", typed = \"ssaaedd\"\nOutput: false\nExplanation: 'e' must have been pressed twice, but it was not in the typed output.\n\n&nbsp;\nConstraints:\n\n\t1 <= name.length, typed.length <= 1000\n\tname and typed consist of only lowercase English letters.",
        "sample1_input": "alex\", \"aaleex",
        "sample1_output": "true",
        "sample2_input": "saeed\",\"ssaaedd",
        "sample2_output": "false",
        "sample3_input": "leelee\",\"lleeelee}",
        "sample3_output": "true",
        "sample4_input": "laiden\",  \"laiden",
        "sample4_output": "true",
        "sample5_input": "abc\",\"acb",
        "sample5_output": "false",
        "task_id": 185,
        "code": "def main(name, typed):\n    i, j = 0, 0\n\n    while j < len(typed):\n        if i < len(name) and name[i] == typed[j]:\n            i += 1\n        elif j == 0 or typed[j] != typed[j - 1]:\n            return False\n        j += 1\n\n    return i == len(name)",
        "test_list": [
            "assert main(alex\", \"aaleex) == true",
            "assert main(saeed\",\"ssaaedd) == false",
            "assert main(leelee\",\"lleeelee}) == true",
            "assert main(laiden\",  \"laiden) == true",
            "assert main(abc\",\"acb) == false"
        ]
    },
    {
        "title": "House Robber II",
        "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\nExample 2:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 1000",
        "sample1_input": "[2,3,2]",
        "sample1_output": "3",
        "sample2_input": "[1,2,3,1]",
        "sample2_output": "4",
        "sample3_input": "[1,2,3]",
        "sample3_output": "3",
        "sample4_input": "[2,7,9,3,1]",
        "sample4_output": "11",
        "sample5_input": "[1,3,1,3,100]",
        "sample5_output": "103",
        "task_id": 186,
        "code": "def main(nums):\n    def rob_range(nums, start, end):\n        prev = curr = 0\n        for i in range(start, end):\n            prev, curr = curr, max(prev + nums[i], curr)\n        return curr\n\n    if len(nums) == 1:\n        return nums[0]\n\n    return max(rob_range(nums, 0, len(nums) - 1), rob_range(nums, 1, len(nums)))",
        "test_list": [
            "assert main([2,3,2]) == 3",
            "assert main([1,2,3,1]) == 4",
            "assert main([1,2,3]) == 3",
            "assert main([2,7,9,3,1]) == 11",
            "assert main([1,3,1,3,100]) == 103"
        ]
    },
    {
        "title": "Plus One",
        "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n&nbsp;\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n&nbsp;\nConstraints:\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "sample1_input": "[1,2,3]",
        "sample1_output": "[1,2,4]",
        "sample2_input": "[4,3,2,1]",
        "sample2_output": "[4,3,2,2]",
        "sample3_input": "[9]",
        "sample3_output": "[1,0]",
        "sample4_input": "[0]",
        "sample4_output": "[1]",
        "sample5_input": "[9,9,9]",
        "sample5_output": "[1,0,0,0]",
        "task_id": 187,
        "code": "def main(digits):\n    carry = 1\n    result = []\n    for i in range(len(digits) - 1, -1, -1):\n        total = digits[i] + carry\n        carry = total // 10\n        result.append(total % 10)\n    if carry:\n        result.append(carry)\n    return result[::-1]",
        "test_list": [
            "assert main([1,2,3]) == [1,2,4]",
            "assert main([4,3,2,1]) == [4,3,2,2]",
            "assert main([9]) == [1,0]",
            "assert main([0]) == [1]",
            "assert main([9,9,9]) == [1,0,0,0]"
        ]
    },
    {
        "title": "Fraction to Recurring Decimal",
        "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return any of them.\n\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\n&nbsp;\nExample 1:\n\n\nInput: numerator = 1, denominator = 2\nOutput: &quot;0.5&quot;\n\n\nExample 2:\n\n\nInput: numerator = 2, denominator = 1\nOutput: &quot;2&quot;\n\n\nExample 3:\n\n\nInput: numerator = 4, denominator = 333\nOutput: &quot;0.(012)&quot;\n\n\n&nbsp;\nConstraints:\n\n\n\t-231 &lt;=&nbsp;numerator, denominator &lt;= 231 - 1\n\tdenominator != 0\n\n",
        "sample1_input": "1,2",
        "sample1_output": "0.5",
        "sample2_input": "2,1",
        "sample2_output": "2",
        "sample3_input": "4,333",
        "sample3_output": "0.(012)",
        "sample4_input": "1,5",
        "sample4_output": "0.2",
        "sample5_input": "7,12",
        "sample5_output": "0.58(3)",
        "task_id": 188,
        "code": "def main(numerator, denominator):\n    if numerator == 0:\n        return '0'\n    result = []\n    if (numerator < 0) ^ (denominator < 0):\n        result.append('-')\n    numerator, denominator = abs(numerator), abs(denominator)\n    result.append(str(numerator // denominator))\n    remainder = numerator % denominator\n    if remainder == 0:\n        return ''.join(result)\n    result.append('.')\n    remainder_dict = {}\n    while remainder != 0:\n        if remainder in remainder_dict:\n            recurring_start = remainder_dict[remainder]\n            non_recurring_part = result[:recurring_start]\n            recurring_part = result[recurring_start:]\n            return ''.join(non_recurring_part) + '(' + ''.join(recurring_part) + ')'\n        remainder_dict[remainder] = len(result)\n        remainder *= 10\n        result.append(str(remainder // denominator))\n        remainder = remainder % denominator\n    return ''.join(result)",
        "test_list": [
            "assert main(1,2) == 0.5",
            "assert main(2,1) == 2",
            "assert main(4,333) == 0.(012)",
            "assert main(1,5) == 0.2",
            "assert main(7,12) == 0.58(3)"
        ]
    },
    {
        "title": "Minimum Operations to Make Array Equal II",
        "content": "You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:\n\n\tChoose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.\n\nnums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].\nReturn the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.\n&nbsp;\nExample 1:\n\nInput: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\nOutput: 2\nExplanation: In 2 operations, we can transform nums1 to nums2.\n1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].\n2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].\nOne can prove that it is impossible to make arrays equal in fewer operations.\nExample 2:\n\nInput: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\nOutput: -1\nExplanation: It can be proved that it is impossible to make the two arrays equal.\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t2 <= n <= 105\n\t0 <= nums1[i], nums2[j] <= 109\n\t0 <= k <= 105",
        "sample1_input": "[4,3,1,4], [1,3,7,1], 3",
        "sample1_output": "2",
        "sample2_input": "[3,8,5,2], [2,4,1,6], 1",
        "sample2_output": "-1",
        "sample3_input": "[1,2,3], [4,5,6], 2",
        "sample3_output": "-1",
        "sample4_input": "[1,2,3,4], [4,3,2,1], 1",
        "sample4_output": "2",
        "sample5_input": "[1,1,1,1], [1,1,1,1], 0",
        "sample5_output": "0",
        "task_id": 189,
        "code": "def main(nums1, nums2, k):\n    n = len(nums1)\n    diff_sum = 0\n    diff_counts = [0] * (2 * k + 1)\n\n    for i in range(n):\n        diff = nums2[i] - nums1[i]\n        diff_sum += diff\n        if diff > 0:\n            diff_counts[diff] += 1\n        elif diff < 0:\n            diff_counts[-diff] += 1\n\n    operations = 0\n    min_diff = -k\n\n    while diff_sum < 0:\n        if diff_counts[-min_diff] > 0:\n            diff_counts[-min_diff] -= 1\n            diff_sum += min_diff\n            operations += 1\n        else:\n            min_diff += 1\n\n    return operations if diff_sum == 0 else -1",
        "test_list": [
            "assert main([4,3,1,4], [1,3,7,1], 3) == 2",
            "assert main([3,8,5,2], [2,4,1,6], 1) == -1",
            "assert main([1,2,3], [4,5,6], 2) == -1",
            "assert main([1,2,3,4], [4,3,2,1], 1) == 2",
            "assert main([1,1,1,1], [1,1,1,1], 0) == 0"
        ]
    },
    {
        "title": "Make Array Empty",
        "content": "You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty:\n\n\tIf the first element has the smallest value, remove it\n\tOtherwise, put the first element at the end of the array.\n\nReturn an integer denoting the number of operations it takes to make nums empty.\n&nbsp;\nExample 1:\n\nInput: nums = [3,4,-1]\nOutput: 5\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tArray\n\t\t\n\t\n\t\n\t\t\n\t\t\t1\n\t\t\t[4, -1, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[-1, 3, 4]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[3, 4]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[4]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[]\n\t\t\n\t\n\nExample 2:\n\nInput: nums = [1,2,4,3]\nOutput: 5\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tArray\n\t\t\n\t\n\t\n\t\t\n\t\t\t1\n\t\t\t[2, 4, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[4, 3]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[3, 4]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[4]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[]\n\t\t\n\t\n\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tArray\n\t\t\n\t\n\t\n\t\t\n\t\t\t1\n\t\t\t[2, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[3]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[]\n\t\t\n\t\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-109&nbsp;<= nums[i] <= 109\n\tAll values in nums are distinct.",
        "sample1_input": "[3,4,-1]",
        "sample1_output": "5",
        "sample2_input": "[1,2,4,3]",
        "sample2_output": "5",
        "sample3_input": "[1,2,3]",
        "sample3_output": "3",
        "sample4_input": "[-1,-2,-3,0]",
        "sample4_output": "4",
        "sample5_input": "[5]",
        "sample5_output": "1",
        "task_id": 190,
        "code": "def main(nums):\n    n = len(nums)\n    min_val = min(nums)\n    min_idx = nums.index(min_val)\n    operations = 0\n\n    for i in range(n):\n        min_val = min(nums)\n        min_idx = nums.index(min_val)\n\n        if min_idx == 0:\n            nums.pop(0)\n        else:\n            nums.append(nums.pop(0))\n\n        operations += 1\n\n        if min_idx == 0:\n            break\n\n    return operations",
        "test_list": [
            "assert main([3,4,-1]) == 5",
            "assert main([1,2,4,3]) == 5",
            "assert main([1,2,3]) == 3",
            "assert main([-1,-2,-3,0]) == 4",
            "assert main([5]) == 1"
        ]
    },
    {
        "title": "Time Needed to Rearrange a Binary String",
        "content": "You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\nReturn the number of seconds needed to complete this process.\n&nbsp;\nExample 1:\n\nInput: s = \"0110101\"\nOutput: 4\nExplanation: \nAfter one second, s becomes \"1011010\".\nAfter another second, s becomes \"1101100\".\nAfter the third second, s becomes \"1110100\".\nAfter the fourth second, s becomes \"1111000\".\nNo occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\nso we return 4.\n\nExample 2:\n\nInput: s = \"11100\"\nOutput: 0\nExplanation:\nNo occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\nso we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts[i] is either '0' or '1'.\n\n&nbsp;\nFollow up:\nCan you solve this problem in O(n) time complexity?",
        "sample1_input": "\"0110101\"",
        "sample1_output": "4",
        "sample2_input": "\"11100\"",
        "sample2_output": "0",
        "sample3_input": "\"1010101\"",
        "sample3_output": "3",
        "sample4_input": "\"0101010\"",
        "sample4_output": "6",
        "sample5_input": "\"1\"",
        "sample5_output": "0",
        "task_id": 191,
        "code": "def main(s):\n    seconds = 0\n    while '01' in s:\n        s = s.replace('01', '10')\n        seconds += 1\n    return seconds",
        "test_list": [
            "assert main(\"0110101\") == 4",
            "assert main(\"11100\") == 0",
            "assert main(\"1010101\") == 3",
            "assert main(\"0101010\") == 6",
            "assert main(\"1\") == 0"
        ]
    },
    {
        "title": "Shifting Letters II",
        "content": "You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.\n\nShifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that &#39;z&#39; becomes &#39;a&#39;). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that &#39;a&#39; becomes &#39;z&#39;).\n\nReturn the final string after all such shifts to s are applied.\n\n&nbsp;\nExample 1:\n\n\nInput: s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]\nOutput: &quot;ace&quot;\nExplanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = &quot;zac&quot;.\nSecondly, shift the characters from index 1 to index 2 forward. Now s = &quot;zbd&quot;.\nFinally, shift the characters from index 0 to index 2 forward. Now s = &quot;ace&quot;.\n\nExample 2:\n\n\nInput: s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]\nOutput: &quot;catz&quot;\nExplanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = &quot;cztz&quot;.\nFinally, shift the characters from index 1 to index 1 forward. Now s = &quot;catz&quot;.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= s.length, shifts.length &lt;= 5 * 104\n\tshifts[i].length == 3\n\t0 &lt;= starti &lt;= endi &lt; s.length\n\t0 &lt;= directioni &lt;= 1\n\ts consists of lowercase English letters.\n\n",
        "sample1_input": "{\"s\": \"abc\", \"shifts\": [[0,1,0],[1,2,1],[0,2,1]]}",
        "sample1_output": "\"ace\"",
        "sample2_input": "{\"s\": \"dztz\", \"shifts\": [[0,0,0],[1,1,1]]}",
        "sample2_output": "\"catz\"",
        "sample3_input": "{\"s\": \"xyz\", \"shifts\": [[0,2,1],[1,2,1],[2,2,0]]}",
        "sample3_output": "\"zab\"",
        "sample4_input": "{\"s\": \"abc\", \"shifts\": [[0,0,0],[1,1,1],[0,2,1]]}",
        "sample4_output": "\"bcd\"",
        "sample5_input": "{\"s\": \"abcdefg\", \"shifts\": [[1,3,1],[0,2,0],[2,4,1],[4,6,1]]}",
        "sample5_output": "\"efgabcd\"",
        "task_id": 192,
        "code": "def main(s, shifts):\n    total_shift = 0\n    result = []\n    for i in range(len(s) - 1, -1, -1):\n        total_shift += shifts[i]\n        shifted_char = chr(((ord(s[i]) - ord('a') + total_shift) % 26) + ord('a'))\n        result.append(shifted_char)\n    return ''.join(result[::-1])",
        "test_list": [
            "assert main({\"s\": \"abc\", \"shifts\": [[0,1,0],[1,2,1],[0,2,1]]}) == \"ace\"",
            "assert main({\"s\": \"dztz\", \"shifts\": [[0,0,0],[1,1,1]]}) == \"catz\"",
            "assert main({\"s\": \"xyz\", \"shifts\": [[0,2,1],[1,2,1],[2,2,0]]}) == \"zab\"",
            "assert main({\"s\": \"abc\", \"shifts\": [[0,0,0],[1,1,1],[0,2,1]]}) == \"bcd\"",
            "assert main({\"s\": \"abcdefg\", \"shifts\": [[1,3,1],[0,2,0],[2,4,1],[4,6,1]]}) == \"efgabcd\""
        ]
    },
    {
        "title": "Path In Zigzag Labelled Binary Tree",
        "content": "In an infinite binary tree where every node has two children, the nodes are labelled in row order.\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the label of a node in this tree, return the labels in the path from the root of the tree to the&nbsp;node with that label.\n&nbsp;\nExample 1:\n\nInput: label = 14\nOutput: [1,3,4,14]\n\nExample 2:\n\nInput: label = 26\nOutput: [1,2,6,10,26]\n\n&nbsp;\nConstraints:\n\n\t1 <= label <= 10^6",
        "sample1_input": "14",
        "sample1_output": "[1,3,4,14]",
        "sample2_input": "26",
        "sample2_output": "[1,2,6,10,26]",
        "sample3_input": "5",
        "sample3_output": "[1,3,5]",
        "sample4_input": "30",
        "sample4_output": "[1,2,7,15,30]",
        "sample5_input": "16",
        "sample5_output": "[1,2,8,16]",
        "task_id": 193,
        "code": "def main(label):\n    level = 1\n    while 2 ** level <= label:\n        level += 1\n    result = [label]\n    while level > 1:\n        label = (2 ** (level - 1)) + (2 ** level - 1 - label // 2)\n        level -= 1\n        result.append(label)\n    return result[::-1]",
        "test_list": [
            "assert main(14) == [1,3,4,14]",
            "assert main(26) == [1,2,6,10,26]",
            "assert main(5) == [1,3,5]",
            "assert main(30) == [1,2,7,15,30]",
            "assert main(16) == [1,2,8,16]"
        ]
    },
    {
        "title": "Plus One",
        "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\n&nbsp;\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n\n&nbsp;\nConstraints:\n\n\t1 <= digits.length <= 100\n\t0 <= digits[i] <= 9\n\tdigits does not contain any leading 0's.",
        "sample1_input": "[1,2,3]",
        "sample1_output": "[1,2,4]",
        "sample2_input": "[4,3,2,1]",
        "sample2_output": "[4,3,2,2]",
        "sample3_input": "[9]",
        "sample3_output": "[1,0]",
        "sample4_input": "[9,9,9]",
        "sample4_output": "[1,0,0,0]",
        "sample5_input": "[1,0,9]",
        "sample5_output": "[1,1,0]",
        "task_id": 194,
        "code": "def main(digits):\n    carry = 1\n    for i in range(len(digits) - 1, -1, -1):\n        if carry == 0:\n            break\n        total = digits[i] + carry\n        digits[i] = total % 10\n        carry = total // 10\n    if carry > 0:\n        digits.insert(0, carry)\n    return digits",
        "test_list": [
            "assert main([1,2,3]) == [1,2,4]",
            "assert main([4,3,2,1]) == [4,3,2,2]",
            "assert main([9]) == [1,0]",
            "assert main([9,9,9]) == [1,0,0,0]",
            "assert main([1,0,9]) == [1,1,0]"
        ]
    },
    {
        "title": "Fraction to Recurring Decimal",
        "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return any of them.\n\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\n&nbsp;\nExample 1:\n\n\nInput: numerator = 1, denominator = 2\nOutput: &quot;0.5&quot;\n\n\nExample 2:\n\n\nInput: numerator = 2, denominator = 1\nOutput: &quot;2&quot;\n\n\nExample 3:\n\n\nInput: numerator = 4, denominator = 333\nOutput: &quot;0.(012)&quot;\n\n\n&nbsp;\nConstraints:\n\n\n\t-231 &lt;=&nbsp;numerator, denominator &lt;= 231 - 1\n\tdenominator != 0\n\n",
        "sample1_input": "1,2",
        "sample1_output": "\"0.5\"",
        "sample2_input": "2,1",
        "sample2_output": "\"2\"",
        "sample3_input": "4,333",
        "sample3_output": "\"0.(012)\"",
        "sample4_input": "1,5",
        "sample4_output": "\"0.2\"",
        "sample5_input": "1,3",
        "sample5_output": "\"0.(3)\"",
        "task_id": 195,
        "code": "def main(numerator, denominator):\n    if numerator == 0:\n        return '0'\n    result = []\n    if numerator < 0 ^ denominator < 0:\n        result.append('-')\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    result.append(str(numerator // denominator))\n    remainder = numerator % denominator\n    if remainder == 0:\n        return ''.join(result)\n    result.append('.')\n    seen = {}\n    while remainder != 0:\n        if remainder in seen:\n            non_repeating = result[:seen[remainder]]\n            repeating = result[seen[remainder]:]\n            return ''.join(non_repeating) + '(' + ''.join(repeating) + ')'\n        seen[remainder] = len(result)\n        remainder *= 10\n        result.append(str(remainder // denominator))\n        remainder %= denominator\n    return ''.join(result)",
        "test_list": [
            "assert main(1,2) == \"0.5\"",
            "assert main(2,1) == \"2\"",
            "assert main(4,333) == \"0.(012)\"",
            "assert main(1,5) == \"0.2\"",
            "assert main(1,3) == \"0.(3)\""
        ]
    },
    {
        "title": "Count The Repetitions",
        "content": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\n\n\tFor example, str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;.\n\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\n\n\tFor example, s1 = &quot;abc&quot; can be obtained from s2 = &quot;abdbec&quot; based on our definition by removing the bolded underlined characters.\n\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\n&nbsp;\nExample 1:\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\nExample 2:\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= s1.length, s2.length &lt;= 100\n\ts1 and s2 consist of lowercase English letters.\n\t1 &lt;= n1, n2 &lt;= 106\n\n",
        "sample1_input": "\"acb\", 4, \"ab\", 2",
        "sample1_output": "2",
        "sample2_input": "\"acb\", 1, \"acb\", 1",
        "sample2_output": "1",
        "sample3_input": "\"abcd\", 3, \"cd\", 3",
        "sample3_output": "1",
        "sample4_input": "\"abc\", 2, \"def\", 2",
        "sample4_output": "0",
        "sample5_input": "\"abc\", 5, \"abc\", 5",
        "sample5_output": "5",
        "task_id": 196,
        "code": "def main(s1, n1, s2, n2):\n    def get_max_repeats(s1, s2):\n        repeats = 0\n        while s1.find(s2) != -1:\n            s1 = s1.replace(s2, '', 1)\n            repeats += 1\n        return repeats\n\n    max_repeats1 = get_max_repeats(s1, s2)\n    max_repeats2 = get_max_repeats(s2, s1)\n\n    total_repeats1 = max_repeats1 * n1\n    total_repeats2 = max_repeats2 * n2\n\n    if max_repeats1 == 0 or max_repeats2 == 0:\n        return 0\n\n    lcm = total_repeats1 * total_repeats2 // math.gcd(total_repeats1, total_repeats2)\n\n    return max(total_repeats1, total_repeats2, lcm // total_repeats1, lcm // total_repeats2)",
        "test_list": [
            "assert main(\"acb\", 4, \"ab\", 2) == 2",
            "assert main(\"acb\", 1, \"acb\", 1) == 1",
            "assert main(\"abcd\", 3, \"cd\", 3) == 1",
            "assert main(\"abc\", 2, \"def\", 2) == 0",
            "assert main(\"abc\", 5, \"abc\", 5) == 5"
        ]
    },
    {
        "title": "Reshape the Matrix",
        "content": "In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.\n\nYou are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n\n&nbsp;\nExample 1:\n\n\nInput: mat = [[1,2],[3,4]], r = 1, c = 4\nOutput: [[1,2,3,4]]\n\n\nExample 2:\n\n\nInput: mat = [[1,2],[3,4]], r = 2, c = 4\nOutput: [[1,2],[3,4]]\n\n\n&nbsp;\nConstraints:\n\n\n\tm == mat.length\n\tn == mat[i].length\n\t1 &lt;= m, n &lt;= 100\n\t-1000 &lt;= mat[i][j] &lt;= 1000\n\t1 &lt;= r, c &lt;= 300\n\n",
        "sample1_input": "[[1,2],[3,4]], 1, 4",
        "sample1_output": "[[1,2,3,4]]",
        "sample2_input": "[[1,2],[3,4]], 2, 4",
        "sample2_output": "[[1,2],[3,4]]",
        "sample3_input": "[[1,2,3,4],[5,6,7,8]], 2, 4",
        "sample3_output": "[[1,2],[3,4],[5,6],[7,8]]",
        "sample4_input": "[[1,2],[3,4],[5,6],[7,8]], 4, 2",
        "sample4_output": "[[1,2],[3,4],[5,6],[7,8]]",
        "sample5_input": "[[1,2],[3,4],[5,6],[7,8]], 2, 2",
        "sample5_output": "[[1,2],[3,4]]",
        "task_id": 197,
        "code": "def main(mat, r, c):\n    m, n = len(mat), len(mat[0])\n\n    if m * n != r * c:\n        return mat\n\n    flat_mat = [num for row in mat for num in row]\n\n    reshaped_mat = []\n    index = 0\n\n    for i in range(r):\n        row = []\n        for j in range(c):\n            row.append(flat_mat[index])\n            index += 1\n        reshaped_mat.append(row)\n\n    return reshaped_mat",
        "test_list": [
            "assert main([[1,2],[3,4]], 1, 4) == [[1,2,3,4]]",
            "assert main([[1,2],[3,4]], 2, 4) == [[1,2],[3,4]]",
            "assert main([[1,2,3,4],[5,6,7,8]], 2, 4) == [[1,2],[3,4],[5,6],[7,8]]",
            "assert main([[1,2],[3,4],[5,6],[7,8]], 4, 2) == [[1,2],[3,4],[5,6],[7,8]]",
            "assert main([[1,2],[3,4],[5,6],[7,8]], 2, 2) == [[1,2],[3,4]]"
        ]
    },
    {
        "title": "Beautiful Arrangement II",
        "content": "Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement:\n\n\n\tSuppose this list is answer =&nbsp;[a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.\n\n\nReturn the list answer. If there multiple valid answers, return any of them.\n\n&nbsp;\nExample 1:\n\n\nInput: n = 3, k = 1\nOutput: [1,2,3]\nExplanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1\n\n\nExample 2:\n\n\nInput: n = 3, k = 2\nOutput: [1,3,2]\nExplanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.\n\n\n&nbsp;\nConstraints:\n\n\n\t1 &lt;= k &lt; n &lt;= 104\n\n",
        "sample1_input": "3,1",
        "sample1_output": "[1,2,3]",
        "sample2_input": "3,2",
        "sample2_output": "[1,3,2]",
        "sample3_input": "5,3",
        "sample3_output": "[1,2,3,5,4]",
        "sample4_input": "4,1",
        "sample4_output": "[1,2,3,4]",
        "sample5_input": "6,4",
        "sample5_output": "[1,2,3,6,5,4]",
        "task_id": 198,
        "code": "def main(n, k):\n    answer = list(range(1, n - k))\n    for i in range(k + 1):\n        if i % 2 == 0:\n            answer.append(n - k + i // 2)\n        else:\n            answer.append(n - i // 2)\n    return answer",
        "test_list": [
            "assert main(3,1) == [1,2,3]",
            "assert main(3,2) == [1,3,2]",
            "assert main(5,3) == [1,2,3,5,4]",
            "assert main(4,1) == [1,2,3,4]",
            "assert main(6,4) == [1,2,3,6,5,4]"
        ]
    },
    {
        "title": "Paths in Matrix Whose Sum Is Divisible by K",
        "content": "You are given a 0-indexed m x n integer matrix grid and an integer k. You are currently at position (0, 0) and you want to reach position (m - 1, n - 1) moving only down or right.\nReturn the number of paths where the sum of the elements on the path is divisible by k. Since the answer may be very large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\nOutput: 2\nExplanation: There are two paths where the sum of the elements on the path is divisible by k.\nThe first path highlighted in red has a sum of 5 + 2 + 4 + 5 + 2 = 18 which is divisible by 3.\nThe second path highlighted in blue has a sum of 5 + 3 + 0 + 5 + 2 = 15 which is divisible by 3.\n\nExample 2:\n\nInput: grid = [[0,0]], k = 5\nOutput: 1\nExplanation: The path highlighted in red has a sum of 0 + 0 = 0 which is divisible by 5.\n\nExample 3:\n\nInput: grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\nOutput: 10\nExplanation: Every integer is divisible by 1 so the sum of the elements on every possible path is divisible by k.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 5 * 104\n\t1 <= m * n <= 5 * 104\n\t0 <= grid[i][j] <= 100\n\t1 <= k <= 50",
        "sample1_input": "[[5,2,4],[3,0,5],[0,7,2]], 3",
        "sample1_output": "2",
        "sample2_input": "[[0,0]], 5",
        "sample2_output": "1",
        "sample3_input": "[[7,3,4,9],[2,3,6,2],[2,3,7,0]], 1",
        "sample3_output": "10",
        "sample4_input": "[[1,2,3],[4,5,6]], 5",
        "sample4_output": "1",
        "sample5_input": "[[1,1,1],[1,1,1]], 2",
        "sample5_output": "15",
        "task_id": 199,
        "code": "def main(grid, k):\n    m, n = len(grid), len(grid[0])\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(m)]\n    dp[0][grid[0][0] % k] = 1\n\n    for i in range(m):\n        for j in range(n):\n            new_dp = [[0] * (k + 1) for _ in range(m)]\n            for remainder in range(k):\n                if dp[i][remainder] > 0:\n                    new_remainder = (remainder + grid[i][j]) % k\n                    new_dp[i][new_remainder] += dp[i][remainder]\n                    if i < m - 1:\n                        new_dp[i + 1][new_remainder] += dp[i][remainder]\n            dp = new_dp\n\n    return dp[m - 1][0]",
        "test_list": [
            "assert main([[5,2,4],[3,0,5],[0,7,2]], 3) == 2",
            "assert main([[0,0]], 5) == 1",
            "assert main([[7,3,4,9],[2,3,6,2],[2,3,7,0]], 1) == 10",
            "assert main([[1,2,3],[4,5,6]], 5) == 1",
            "assert main([[1,1,1],[1,1,1]], 2) == 15"
        ]
    },
    {
        "title": "Maximum Candies Allocated to K Children",
        "content": "You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\nYou are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\nReturn the maximum number of candies each child can get.\n&nbsp;\nExample 1:\n\nInput: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n\nExample 2:\n\nInput: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= candies.length <= 105\n\t1 <= candies[i] <= 107\n\t1 <= k <= 1012",
        "sample1_input": "[5,8,6], 3",
        "sample1_output": "5",
        "sample2_input": "[2,5], 11",
        "sample2_output": "0",
        "sample3_input": "[10,4,6,8,1,3,9], 10",
        "sample3_output": "9",
        "sample4_input": "[1,2,3,4,5,6], 3",
        "sample4_output": "6",
        "sample5_input": "[7,7,7,7], 3",
        "sample5_output": "7",
        "task_id": 200,
        "code": "def main(candies, k):\n    low, high = 1, max(candies)\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if sum((candy + mid - 1) // mid for candy in candies) <= k:\n            high = mid - 1\n        else:\n            low = mid\n\n    return low",
        "test_list": [
            "assert main([5,8,6], 3) == 5",
            "assert main([2,5], 11) == 0",
            "assert main([10,4,6,8,1,3,9], 10) == 9",
            "assert main([1,2,3,4,5,6], 3) == 6",
            "assert main([7,7,7,7], 3) == 7"
        ]
    }
]